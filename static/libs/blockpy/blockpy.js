(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_17__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_17__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */



 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_4__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration;
      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray([]),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(configuration["submission.code"] || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_6__["DisplayModes"].SPLIT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true")
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {}
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_8__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.submission.code(submission.code);
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status);
      this.model.submission.submissionStatus(submission.submission_status);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.log(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_9__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_16__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          })
        },
        secondRow: {
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_8__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          })
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + (traceData[step].line - 1);
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_20__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_9__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideEditors() ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_9__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_9__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_9__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_10__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_7__["StatusState"].ACTIVE;
          }),
          run: function run() {
            return self.components.engine.delayedRun();
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_19__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_8__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_15__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_14__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_12__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_13__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_11__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_9__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_5__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_7__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_17__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_18__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='col-md-6 blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.position().top; //$('html').scrollTop(top);

        $("html").scrollTop(0); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.position().top;
        $("html").scrollTop(0);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var ctx = canvas.getContext("2d");
          var img = new Image();
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle output is saved whenever the program uses it."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */


var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> Run\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() -->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHOok: function imageDownloadHOok(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        return Promise.resolve("Image(" + JSON.stringify(URL.createObjectURL(blob)) + ")");
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        return "Image(\"".concat(oldUrl, "\")");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      });
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */









/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"col-md-12 blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "'\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback()) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found;

      this.sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      var $main = new Sk.builtin.str("__main__");

      if (this.sysmodules !== undefined) {
        if (this.sysmodules.quick$lookup($main)) {
          this.sysmodules.del$item($main);
        }
      }

      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  var indentedCode = Object(_utilities__WEBPACK_IMPORTED_MODULE_3__["indent"])(Object(_utilities__WEBPACK_IMPORTED_MODULE_3__["indent"])(isSafe ? studentCode : "None"));
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\nMAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, ")\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n# Run the actual instructor code\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports;
      var studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var lineOffset = instructorCode.split(_on_run__WEBPACK_IMPORTED_MODULE_2__["NEW_LINE_REGEX"]).length;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentCodeSafe, instructorCode, disableTifa, isSafe);
      lineOffset = instructorCode.split(_on_run__WEBPACK_IMPORTED_MODULE_2__["NEW_LINE_REGEX"]).length - lineOffset;
      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var NEW_LINE_REGEX = /\r\n|\r|\n/;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  var indentedCode = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["indent"])(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["indent"])(isSafe ? studentCode : "pass"));
  var tifaAnalysis = "";

  if (!quick) {
    tifaAnalysis = "from pedal.tifa import tifa_analysis\ntifa_analysis(False)";
  }

  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom cisc108 import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          main_code=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n# Run the actual instructor code\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentCodeSafe = this.main.model.ui.files.getStudentCode();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var lineOffset = instructorCode.split(NEW_LINE_REGEX).length;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentCodeSafe, instructorCode, disableTifa, isSafe);
      lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode(); //this.code = this.main.model.submission.code();

      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring) {
      if (filename === "answer.py") {
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(globals); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear();
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback col-md-6 blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 1000);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      this.feedbackModel.message("*Ready*");
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);
        this.scrollIntoView();
      }
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this4 = this;

      return error.traceback.map(function (frame) {
        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(_filename, _contents) {
  return {
    filename: function filename() {
      return _filename;
    },
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var filename in files) {
      if (files.hasOwnProperty(filename)) {
        modelFiles.push(makeModelFile(filename, files[filename]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    modelFileList(modelFiles);
  } else {
    modelFileList([]);
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.main.model.display.instructor.subscribe(function (visiblity) {
      $(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          console.log("OH HEY IT UPDATED:", fileArray, changes);
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        console.log("ADDING EXISTING FILE", filename); // File already exists! Just update its handle

        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        console.log("NEW FILE", filename); // File does not exist

        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        console.log(Object.keys(this.files_));
        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      console.log("DLEETING", filename);
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row'>\n         \n         <!-- Description -->\n         <div class='col-md-10 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-2 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\"\n            ><span class='fas',\n                           data-bind=\"class: ui.menu.textFullscreen\"\n            ></span></button>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\"\n            ><span class='fas fa-list-alt'></span></button>\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div class='row'>\n    \n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n         \n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        \n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n         \n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible -->\n    <div class='row'>\n        ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    <div class=\"row\">\n        ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    </div>\n\n    <!-- Row 5: Footer Row -->    \n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");


/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  this.showOverlay(attempts);
  return $.post(this.urls[endpoint], data).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this10 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this10.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this11 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this11._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this11.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this11.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    \n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <caption>Current variables at this step</caption>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = [];

      if (!this.main.model.display.traceExecution()) {
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Arguments: " + value.func_code.co_varnames.join(", ") : " No arguments"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/


function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2pzb24uanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvbWFya2Rvd24uanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvcHl0aG9uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3F1aXouanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3Ivc2FtcGxlX3N1Ym1pc3Npb25zLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RhZ3MuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdGV4dC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90b29sYm94LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9ycy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9jb25maWd1cmF0aW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvb25fY2hhbmdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2V2YWwuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvb25fcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9ydW4uanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvc2FtcGxlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3N0dWRlbnQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9mZWVkYmFjay5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2ZpbGVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZm9vdGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NlcnZlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2NvdmVyYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9wZWRhbF90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9za19tb2RfaW5zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy90cmFjZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3V0aWxpdGllcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwialF1ZXJ5XCIiLCJ3ZWJwYWNrOi8vYmxvY2tweS9leHRlcm5hbCBcImtvXCIiXSwibmFtZXMiOlsiRURJVE9SX1ZFUlNJT04iLCJCbG9ja1B5IiwiY29uZmlndXJhdGlvbiIsImFzc2lnbm1lbnQiLCJzdWJtaXNzaW9uIiwiaW5pdE1vZGVsIiwidW5kZWZpbmVkIiwic2V0QXNzaWdubWVudCIsImluaXRNYWluIiwiaW5pdFV0aWxpdGllcyIsImluaXRNb2RlbE1ldGhvZHMiLCJ0dXJuT25IYWNrcyIsImluaXRJbnRlcmZhY2UiLCJhcHBseU1vZGVsIiwiaW5pdENvbXBvbmVudHMiLCJtYWtlRXh0cmFTdWJzY3JpcHRpb25zIiwic3RhcnQiLCJrZXkiLCJkZWZhdWx0VmFsdWUiLCJpbml0aWFsQ29uZmlndXJhdGlvbl8iLCJsb2NhbFNldHRpbmdzXyIsImhhcyIsImdldCIsIkxvY2FsU3RvcmFnZVdyYXBwZXIiLCJtb2RlbCIsInVzZXIiLCJpZCIsImtvIiwib2JzZXJ2YWJsZSIsIm5hbWUiLCJyb2xlIiwiZ2V0U2V0dGluZyIsImNvdXJzZUlkIiwiZ3JvdXBJZCIsImluc3RydWN0aW9ucyIsInVybCIsInR5cGUiLCJBc3NpZ21lbnRUeXBlIiwiQkxPQ0tQWSIsInBvaW50cyIsInN0YXJ0aW5nQ29kZSIsIm9uUnVuIiwib25DaGFuZ2UiLCJvbkV2YWwiLCJleHRyYUluc3RydWN0b3JGaWxlcyIsIm9ic2VydmFibGVBcnJheSIsImV4dHJhU3RhcnRpbmdGaWxlcyIsImZvcmtlZElkIiwiZm9ya2VkVmVyc2lvbiIsIm93bmVySWQiLCJ2ZXJzaW9uIiwidGFncyIsInNhbXBsZVN1Ym1pc3Npb25zIiwicmV2aWV3ZWQiLCJoaWRkZW4iLCJpcFJhbmdlcyIsInNldHRpbmdzIiwibWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsIiwiY29kZSIsImV4dHJhRmlsZXMiLCJlbmRwb2ludCIsInNjb3JlIiwiY29ycmVjdCIsInN1Ym1pc3Npb25TdGF0dXMiLCJncmFkaW5nU3RhdHVzIiwiZGlzcGxheSIsImZpbGVuYW1lIiwiaW5zdHJ1Y3RvciIsIm11dGVQcmludGVyIiwicHl0aG9uTW9kZSIsIkRpc3BsYXlNb2RlcyIsIlNQTElUIiwiaGlzdG9yeU1vZGUiLCJhdXRvU2F2ZSIsImJpZ0NvbnNvbGUiLCJwcmV2aW91c0NvbnNvbGVIZWlnaHQiLCJjdXJyZW50Q29uc29sZUhlaWdodCIsInNlY29uZFJvd1NlY29uZFBhbmVsIiwiU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zIiwiRkVFREJBQ0siLCJ0cmFjZUV4ZWN1dGlvbiIsImxvYWRpbmdEYXRhc2V0cyIsImNoYW5nZWRJbnN0cnVjdGlvbnMiLCJ0cmlnZ2VyT25DaGFuZ2UiLCJkaXJ0eVN1Ym1pc3Npb24iLCJmdWxsc2NyZWVuIiwicGFzc2NvZGUiLCJjbGVhcklucHV0cyIsImVkaXRvclZlcnNpb24iLCJyZWFkT25seSIsInRvU3RyaW5nIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsIm9uRXhlY3V0aW9uIiwiZXhlY3V0aW9uIiwicmVwb3J0cyIsIm91dHB1dCIsImlucHV0IiwiaW5wdXRJbmRleCIsInN0dWRlbnQiLCJjdXJyZW50U3RlcCIsImxhc3RTdGVwIiwiY3VycmVudExpbmUiLCJsYXN0TGluZSIsImN1cnJlbnRUcmFjZURhdGEiLCJjdXJyZW50VHJhY2VTdGVwIiwicmVzdWx0cyIsImdsb2JhbHMiLCJjYWxscyIsInN5c21vZHVsZXMiLCJmZWVkYmFjayIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxhYmVsIiwibGluZXNFcnJvciIsImxpbmVzVW5jb3ZlcmVkIiwiY2FsbGJhY2tzIiwic2VydmVyQ29ubmVjdGVkIiwiYmxvY2tseVBhdGgiLCJhdHRhY2htZW50UG9pbnQiLCJjb250YWluZXIiLCJ1cmxzIiwiY29uc3RhbnRzIiwiZ3VpIiwibWFrZUludGVyZmFjZSIsIiQiLCJodG1sIiwiYXNzaWdubWVudF9pZCIsImNvbXBvbmVudHMiLCJzZXJ2ZXIiLCJzYW1wbGVzIiwic3RhcnRpbmdfY29kZSIsImxvYWRDb25jYXRlbmF0ZWRGaWxlIiwiZXh0cmFfc3RhcnRpbmdfZmlsZXMiLCJsb2FkTm9TdWJtaXNzaW9uIiwiZ3JhZGluZ19zdGF0dXMiLCJzdWJtaXNzaW9uX3N0YXR1cyIsInVzZXJfaWQiLCJjb3Vyc2VfaWQiLCJleHRyYV9maWxlcyIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwicmVzZXRJbnRlcmZhY2UiLCJmaWxlU3lzdGVtIiwiZGlzbW91bnRFeHRyYUZpbGVzIiwid2FzU2VydmVyQ29ubmVjdGVkIiwiZm9ya2VkX2lkIiwiZm9ya2VkX3ZlcnNpb24iLCJpcF9yYW5nZXMiLCJvbl9jaGFuZ2UiLCJuZXdGaWxlIiwib25fZXZhbCIsIm9uX3J1biIsIm93bmVyX2lkIiwibG9hZFRhZ3MiLCJsb2FkU2FtcGxlU3VibWlzc2lvbnMiLCJzYW1wbGVfc3VibWlzc2lvbnMiLCJleHRyYV9pbnN0cnVjdG9yX2ZpbGVzIiwibG9hZEFzc2lnbm1lbnRTZXR0aW5ncyIsImxvYWRTdWJtaXNzaW9uIiwiY29yZ2lzIiwibG9hZERhdGFzZXRzIiwicHl0aG9uRWRpdG9yIiwiYm0iLCJyZWZyZXNoIiwic2V0U3RhdHVzIiwic2VsZiIsInVpIiwiaXNHcmFkZXIiLCJwdXJlQ29tcHV0ZWQiLCJpc0NoYW5nZWQiLCJjdXJyZW50IiwidXRpbGl0aWVzIiwibWFya2Rvd24iLCJyZXNldCIsIm1lbnUiLCJ0ZXh0RnVsbHNjcmVlbiIsImNsaWNrRnVsbHNjcmVlbiIsImVkaXRJbnB1dHMiLCJkaWFsb2ciLCJFRElUX0lOUFVUUyIsImNhbk1hcmtTdWJtaXR0ZWQiLCJjYW5DbG9zZSIsInRleHRNYXJrU3VibWl0dGVkIiwiaXNDb21wbGV0ZWQiLCJpc1N1Ym1pdHRlZCIsImNsaWNrTWFya1N1Ym1pdHRlZCIsImFsZXJ0IiwiZW5naW5lIiwiZGVsYXllZFJ1biIsInRvTG93ZXJDYXNlIiwic2hvd1F1ZXVlZElucHV0cyIsImhpZGVRdWV1ZWRJbnB1dHMiLCJzZWNvbmRSb3ciLCJpc0FsbFZpc2libGUiLCJoaWRlTWlkZGxlUGFuZWwiLCJpc0ZlZWRiYWNrVmlzaWJsZSIsImlzVHJhY2VWaXNpYmxlIiwiVFJBQ0UiLCJpc0NvbnNvbGVTaG93VmlzaWJsZSIsInN3aXRjaExhYmVsIiwiYWR2YW5jZVN0YXRlIiwiY3VycmVudFBhbmVsIiwiTk9ORSIsInNpemUiLCJoaWRlRXZhbHVhdGUiLCJBQ1RJVkUiLCJiYWRnZSIsInRyYWNlIiwibGluZSIsInN0ZXAiLCJ0cmFjZURhdGEiLCJmaXJzdCIsImJhY2t3YXJkIiwicHJldmlvdXMiLCJNYXRoIiwibWF4IiwiZm9yd2FyZCIsIm5leHQiLCJtaW4iLCJsYXN0IiwiZmlsZXMiLCJ2aXNpYmxlIiwiaGlkZUZpbGVzIiwiaGFzQ29udGVudHMiLCJwYXRoIiwic29tZSIsImZpbGUiLCJsZW5ndGgiLCJhZGQiLCJub3JtYWxUb29sYm94IiwiYmxvY2tFZGl0b3IiLCJUT09MQk9YRVMiLCJKU09OIiwic3RyaW5naWZ5IiwiU2FtcGxlU3VibWlzc2lvbiIsIkJsYW5rIiwibmV3RmlsZURpYWxvZyIsImRlbGV0ZUZpbGUiLCJnZXRTdHVkZW50Q29kZSIsInByZWZpeFB5IiwiZ2V0RmlsZSIsInN1ZmZpeFB5IiwiaGFuZGxlIiwiZXh0cmFTdHVkZW50RmlsZXMiLCJvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZSIsImRpc3BsYXlGaWxlbmFtZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImVkaXRvcnMiLCJnZXRFZGl0b3IiLCJ2aWV3IiwiaGlkZUVkaXRvcnMiLCJtYXAiLCJzdWJzdHIiLCJtYWtlTW9kZWxGaWxlIiwiY29udGVudHMiLCJjYW5TYXZlIiwiY2FuRGVsZXRlIiwiVU5ERUxFVEFCTEVfRklMRVMiLCJpbmRleE9mIiwiY2FuUmVuYW1lIiwiVU5SRU5BTUFCTEVfRklMRVMiLCJ1cGxvYWQiLCJ1cGxvYWRGaWxlIiwiYmluZCIsImRvd25sb2FkIiwiZG93bmxvYWRGaWxlIiwiaW1wb3J0RGF0YXNldCIsIm9wZW5EaWFsb2ciLCJweXRob24iLCJjb2RlTWlycm9yIiwidGV4dEVkaXRvciIsInNldE9wdGlvbiIsImdldE9wdGlvbiIsInVwZGF0ZU1vZGUiLCJuZXdNb2RlIiwib2xkUHl0aG9uTW9kZSIsImlzSGlzdG9yeUF2YWlsYWJsZSIsImlzRW5kcG9pbnRDb25uZWN0ZWQiLCJ0dXJuT2ZmSGlzdG9yeU1vZGUiLCJ1cGRhdGVFZGl0b3IiLCJzZXRSZWFkT25seSIsInR1cm5Pbkhpc3RvcnlNb2RlIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiaGlzdG9yeSIsImxvYWQiLCJFUlJPUl9MT0FESU5HX0hJU1RPUlkiLCJ0b2dnbGVIaXN0b3J5TW9kZSIsIm1vdmVUb1N0YXJ0IiwibW92ZVByZXZpb3VzIiwibW92ZU5leHQiLCJtb3N0UmVjZW50IiwibW92ZVRvTW9zdFJlY2VudCIsInVzZSIsInNhdmUiLCJidWlsZEVkaXRvciIsIm5ld0RPTSIsImluZGV4IiwibmV3RWxlbWVudCIsImVkaXRvciIsImJ5TmFtZSIsImV4ZWN1dGUiLCJpc1J1bm5pbmciLCJydW4iLCJldmFsdWF0ZSIsIm1lc3NhZ2VzIiwiY2FwaXRhbGl6ZSIsImZvcmNlIiwiZXZlbnQiLCJhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uIiwidGFyZ2V0IiwicGFyZW50IiwiZmFkZU91dCIsImZhZGVJbiIsImZyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJhc3NpZ25tZW50U3VibWlzc2lvbiIsInBhcnNlIiwicmVzdWx0IiwibG9hZEFzc2lnbm1lbnREYXRhXyIsImZpbGVOYW1lIiwicmVhZEFzVGV4dCIsInZhbCIsIm1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMiLCJTayIsImJ1aWx0aW5GaWxlcyIsImltYWdlTW9kdWxlIiwiYXBwbHlCaW5kaW5ncyIsIm1haW4iLCJ0ZXh0IiwiRWFzeU1ERSIsInByb3RvdHlwZSIsIkJsb2NrUHlEaWFsb2ciLCJmaW5kIiwiQmxvY2tQeUZlZWRiYWNrIiwiQmxvY2tQeVRyYWNlIiwiQmxvY2tQeUNvbnNvbGUiLCJCbG9ja1B5RW5naW5lIiwiQmxvY2tQeUZpbGVTeXN0ZW0iLCJFZGl0b3JzIiwiQmxvY2tQeVNlcnZlciIsIkJsb2NrUHlDb3JnaXMiLCJCbG9ja1B5SGlzdG9yeSIsInNob3ciLCJoaWRlIiwic3Vic2NyaWJlIiwiY2hhbmdlZCIsImFsdExvZ0VudHJ5IiwidXNlclN1cHBsaWVkUGFzc2NvZGUiLCJwcm9tcHQiLCJTVEFSVF9FVkFMX0hUTUwiLCJORVdfQ09OU09MRV9MSU5FX0hUTUwiLCJDT05TT0xFX0hUTUwiLCJDb25zb2xlTGluZVR5cGUiLCJURVhUIiwiSFRNTCIsIlBMT1QiLCJJTUFHRSIsIlBZR0FNRSIsIlRVUlRMRSIsIkVWQUwiLCJTVEFSVF9FVkFMIiwiVkFMVUUiLCJJTlBVVCIsIlRFU1RfQ0FTRSIsIkNvbnNvbGVMaW5lIiwiY29udGVudCIsIm9yaWdpbiIsImN1cnJGaWxlbmFtZSIsImV4ZWN1dGlvbkJ1ZmZlciIsImZmaSIsInJlbWFwVG9QeSIsInJlbW92ZSIsIkNvbnNvbGVMaW5lVHVydGxlIiwiYWRkQ2xhc3MiLCJ3aGVyZSIsInByZXBlbmQiLCJ0b3AiLCJwb3NpdGlvbiIsInNjcm9sbFRvcCIsIkNvbnNvbGVMaW5lUHlnYW1lIiwicHlnYW1lT2JqIiwiaW5pdGlhbGl6ZWQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJjbGVhbnVwIiwiY2xlYW51cEZ1bmN0aW9uIiwibGlzdGVuZXJzIiwiQ29uc29sZUxpbmVJbWFnZSIsIkNvbnNvbGVMaW5lUGxvdCIsIkNvbnNvbGVMaW5lVGV4dCIsImVuY29kZWRUZXh0IiwiZW5jb2RlSFRNTCIsInRyaW0iLCJsaW5lRGF0YSIsInRvb2x0aXAiLCJDb25zb2xlTGluZVZhbHVlIiwiQ29uc29sZUxpbmVJbnB1dCIsInByb21wdE1lc3NhZ2UiLCJpbnB1dEZvcm0iLCJpbnB1dEJ0biIsImlucHV0R3JvdXAiLCJpbnB1dEJveCIsImlucHV0TXNnIiwibWFrZUludGVyYWN0aXZlIiwiYnV0dG9uIiwicmVzb2x2ZU9uQ2xpY2siLCJzdWJtaXR0ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdWJtaXRGb3JtIiwidXNlcklucHV0dGVkVmFsdWUiLCJxdWV1ZWRJbnB1dCIsInB1c2giLCJwcm9wIiwiY2xpY2siLCJrZXl1cCIsImtleUNvZGUiLCJmb2N1cyIsIkNvbnNvbGVMaW5lRXZhbHVhdGUiLCJDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUiLCJ0YWciLCJwcmludGVyVGFnIiwiTUlOSU1VTV9XSURUSCIsIk1JTklNVU1fSEVJR0hUIiwiREVGQVVMVF9IRUlHSFQiLCJoZWlnaHQiLCJjbGVhciIsInJlbW92ZUFsbCIsImxpbmVCdWZmZXIiLCJwbG90QnVmZmVyIiwiZW1wdHkiLCJ0dXJ0bGVMaW5lIiwiVHVydGxlR3JhcGhpY3MiLCJnZXRUdXJ0bGVMaW5lIiwid2lkdGgiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImFzc2V0cyIsImxvYWRBc3NldCIsInB5Z2FtZUxpbmUiLCJyZW5kZXIiLCJjdXJyZW50UHJpbnRlckRpbWVuc2lvbiIsInNhdmVUdXJ0bGVPdXRwdXQiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1nIiwiSW1hZ2UiLCJkYXRhVXJsIiwidG9EYXRhVVJMIiwicGFnZSIsImVhY2giLCJhdHRyIiwibGluZVRleHQiLCJmbHVzaCIsImNoYXJBdCIsInNwbGl0TGluZXMiLCJzcGxpdCIsImFkZENvbnRlbnQiLCJpIiwicGxvdHMiLCJpbWFnZURhdGEiLCJpbWFnZSIsImltYWdlQnVmZmVyIiwidmFsdWUiLCJwcmludGVkVmFsdWUiLCJpbnB1dEJ1ZmZlciIsInN0YXJ0RXZhbHVhdGlvbiIsImFuaW1hdGUiLCJfSU1QT1JURURfREFUQVNFVFMiLCJfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMiLCJzZXRCdXR0b25Mb2FkZWQiLCJidG4iLCJyZW1vdmVDbGFzcyIsImxvYWRlZERhdGFzZXRzIiwic2lsZW50bHkiLCJpbXBvcnRzIiwiZGF0YXNldHMiLCJmb3JFYWNoIiwiQmxvY2tNaXJyb3JCbG9ja0VkaXRvciIsIkVYVFJBX1RPT0xTIiwiYXBwbHkiLCJzbHVnIiwid2hlbiIsImRvbmUiLCJmb3JjZUJsb2NrUmVmcmVzaCIsInJlbWFrZVRvb2xib3giLCJmYWlsIiwiYXJndW1lbnRzIiwiZXJyb3IiLCJhbHdheXMiLCJmaW5hbGl6ZVN1YnNjcmlwdGlvbnMiLCJ1cmxfcmV0cmlldmFscyIsInJvb3QiLCJpbXBvcnREYXRhc2V0cyIsImdldERhdGFzZXQiLCJnZXRTY3JpcHQiLCJnZXRDb21wbGV0ZSIsImdldFNrdWxwdCIsImdldEJsb2NrbHkiLCJ0ZXh0VG9CbG9ja3MiLCJoaWRkZW5JbXBvcnRzIiwiZ2V0SlNPTiIsImJsb2NrcHkiLCJkb2N1bWVudGF0aW9uIiwiYm9keSIsIk9iamVjdCIsImtleXMiLCJzb3J0Iiwic2x1Z2dlZE5hbWUiLCJ0aXRsZU5hbWUiLCJpbWdTcmMiLCJ0aXRsZSIsIm92ZXJ2aWV3IiwiYXBwZW5kVG8iLCJESUFMT0dfSFRNTCIsInRpdGxlVGFnIiwiYm9keVRhZyIsImZvb3RlclRhZyIsIm9rYXlCdXR0b24iLCJjbG9zZUJ1dHRvbiIsInllcyIsIm5vIiwibW9kYWwiLCJjbG9zZSIsIm9uY2xvc2UiLCJkcmFnZ2FibGUiLCJvbiIsImNvbmZpcm0iLCJ5ZXNUZXh0IiwiQVNTSUdOTUVOVF9WRVJTSU9OX0NIQU5HRUQiLCJFUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UIiwicmVhc29uIiwiRVJST1JfU0FWSU5HX0FTU0lHTk1ORU5UIiwiRVJST1JfU0hPV19TVFVERU5UX0VSUk9SIiwiUE9TSVRJVkVfRkVFREJBQ0tfRlVMTCIsIlNDUkVFTlNIT1RfQkxPQ0tTIiwiRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMiLCJPRkZFUl9GT1JLIiwic2V0dXBVcmwiLCJpbnN0cnVjdGlvbnNBc3NpZ25tZW50U2V0dXAiLCJpbnB1dFRleHQiLCJqb2luIiwiY2hlY2tlZCIsImlucHV0cyIsImZpbGVSZWFkZXIiLCJzbHVnZ2lmeSIsInJlcGxhY2UiLCJleHRlbnNpb24iLCJtaW1ldHlwZSIsImJsb2IiLCJCbG9iIiwid2luZG93IiwibmF2aWdhdG9yIiwibXNTYXZlT3JPcGVuQmxvYiIsIm1zU2F2ZUJsb2IiLCJ0ZW1wb3JhcnlEb3dubG9hZExpbmsiLCJocmVmIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIkFic3RyYWN0RWRpdG9yIiwiY2hhbmdlRWRpdG9yIiwid2F0Y2hGaWxlIiwidXBkYXRlZCIsIm9uRmlsZVVwZGF0ZWQiLCJkZWxldGVkIiwib25GaWxlRGVsZXRlZCIsIm5ld0ZpbGVuYW1lIiwib2xkRWRpdG9yIiwidHJhY2tDdXJyZW50RmlsZSIsIm5ld0VkaXRvciIsInN0b3BXYXRjaGluZ0ZpbGUiLCJwYXJzZUZpbGVuYW1lIiwiQVNTSUdOTUVOVF9TRVRUSU5HUyIsIk1BWkUiLCJRVUlaIiwiUkVBRElORyIsImdldERvY3VtZW50YXRpb24iLCJtYWtlU3RhcnRWaWV3VGFiIiwiaWNvbiIsIm1vZGUiLCJBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MIiwiZmlsdGVyIiwic2V0dGluZyIsInByZXR0eU5hbWUiLCJ3b3JkIiwidG9VcHBlckNhc2UiLCJBU1NJR05NRU5UX1NFVFRJTkdTX0VESVRPUl9IVE1MIiwiQkxPQ0siLCJzYXZlQXNzaWdubWVudFNldHRpbmdzIiwiY2xpZW50TmFtZSIsInNlcnZlck5hbWUiLCJzdGFydF92aWV3IiwiZmllbGRUeXBlIiwiY29uZmlnVmFsdWUiLCJBc3NpZ25tZW50U2V0dGluZ3NWaWV3IiwiZGlydHkiLCJjdXJyZW50TGlzdGVuZXIiLCJ1cGRhdGVIYW5kbGUiLCJuZXdDb250ZW50cyIsIkFzc2lnbm1lbnRTZXR0aW5ncyIsImV4dGVuc2lvbnMiLCJjb25zdHJ1Y3RvciIsInRlbXBsYXRlIiwiZGVmYXVsdF9oZWFkZXIiLCJKU09OX0VESVRPUl9IVE1MIiwiSnNvbkVkaXRvclZpZXciLCJDb2RlTWlycm9yIiwiZnJvbVRleHRBcmVhIiwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmciLCJsaW5lTnVtYmVycyIsImZpcnN0TGluZU51bWJlciIsImluZGVudFVuaXQiLCJ0YWJTaXplIiwiaW5kZW50V2l0aFRhYnMiLCJleHRyYUtleXMiLCJjbSIsImJsdXIiLCJjdXJyZW50U3Vic2NyaXB0aW9uIiwic2V0VGltZW91dCIsInNldFZhbHVlIiwiZ2V0VmFsdWUiLCJkaXNwb3NlIiwib2ZmIiwiSnNvbkVkaXRvciIsIk1BUktET1dOX0VESVRPUl9IVE1MIiwiTWFya2Rvd25FZGl0b3JWaWV3IiwibWRlIiwiZWxlbWVudCIsImF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lIiwiZm9yY2VTeW5jIiwibWluSGVpZ2h0IiwicmVuZGVyaW5nQ29uZmlnIiwiY29kZVN5bnRheEhpZ2hsaWdodGluZyIsImNvZGVtaXJyb3IiLCJNYXJrZG93bkVkaXRvciIsIm1ha2VUYWIiLCJQWVRIT05fRURJVE9SX0hUTUwiLCJISVNUT1JZX1RPT0xCQVJfSFRNTCIsImNvbnZlcnRJcHluYlRvUHl0aG9uIiwiaXB5bmIiLCJpc1VzYWJsZSIsImNlbGwiLCJjZWxsX3R5cGUiLCJzb3VyY2UiLCJtYWtlUHl0aG9uIiwiY2VsbHMiLCJQeXRob25FZGl0b3JWaWV3IiwiQmxvY2tseSIsInNldFBhcmVudENvbnRhaW5lciIsIkJsb2NrTWlycm9yIiwidG9vbGJveCIsImltYWdlRG93bmxvYWRIT29rIiwib2xkVXJsIiwiaW1hZ2VVcGxvYWRIb29rIiwiaW1hZ2VMaXRlcmFsSG9vayIsIm1ha2VTdWJzY3JpcHRpb25zIiwibGluZUVycm9yU3Vic2NyaXB0aW9uIiwibGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiIsIm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucyIsIndvcmtzcGFjZSIsImNvbmZpZ3VyZUNvbnRleHRNZW51Iiwib3B0aW9ucyIsImVuYWJsZWQiLCJjYWxsYmFjayIsIm9sZEZpbGVuYW1lIiwiY3VycmVudEJNTGlzdGVuZXIiLCJhZGRDaGFuZ2VMaXN0ZW5lciIsImlzUGFyc29ucyIsImxpbmVzIiwic2V0SGlnaGxpZ2h0ZWRMaW5lcyIsImRlbGV0ZUZpbGVMb2NhbGx5XyIsInNldENvZGUiLCJjbGVhckhpZ2hsaWdodGVkTGluZXMiLCJnZXRDb2RlIiwicmVtb3ZlQ2hhbmdlTGlzdGVuZXIiLCJjbGVhckxpbmVTdWJzY3JpcHRpb25zIiwic2V0TW9kZSIsImVuYWJsZUJsb2NrcyIsInJlbG9hZFRvb2xib3giLCJlbmFibGVJbWFnZXMiLCJpbWFnZU1vZGUiLCJzZXRJbWFnZU1vZGUiLCJjdXN0b21Ub29sYm94IiwiZGVjaWRlSWZOb3RFZGl0YWJsZSIsIm9ubHlVcGxvYWRzIiwiaXNSZWFkT25seSIsImVuZHNXaXRoIiwiUHl0aG9uRWRpdG9yIiwiUVVJWl9FRElUT1JfSFRNTCIsIlF1aXpFZGl0b3JWaWV3IiwiUXVpekVkaXRvciIsIlN1Ym1pc3Npb25TdGF0dXNlcyIsIlVOS05PV04iLCJQQVNTRUQiLCJGQUlMRUQiLCJFUlJPUiIsIlNLSVBQRUQiLCJjb3VudCIsIlNBTVBMRV9TVUJNSVNTSU9OU19IVE1MIiwiYmluZGluZ0hhbmRsZXJzIiwiY29kZU1pcnJvckluc3RhbmNlIiwiaW5pdCIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0Iiwic2V0U2l6ZSIsInVwZGF0ZSIsIlNhbXBsZVN1Ym1pc3Npb25zVmlldyIsImNvZGVNaXJyb3JzIiwiU2FtcGxlU3VibWlzc2lvbnMiLCJUQUdTX0VESVRPUl9IVE1MIiwiVGFnc0VkaXRvclZpZXciLCJUYWdzRWRpdG9yIiwiVEVYVF9FRElUT1JfSFRNTCIsIlRleHRFZGl0b3JWaWV3IiwiVGV4dEVkaXRvciIsIlRPT0xCT1hfRURJVE9SX0hUTUwiLCJUb29sYm94RWRpdG9yVmlldyIsIlRvb2xib3hFZGl0b3IiLCJFZGl0b3JzRW51bSIsIlNVQk1JU1NJT04iLCJBU1NJR05NRU5UIiwiSU5TVFJVQ1RJT05TIiwiT05fUlVOIiwiT05fQ0hBTkdFIiwiT05fRVZBTCIsIlNUQVJUSU5HX0NPREUiLCJTQU1QTEVfU1VCTUlTU0lPTlMiLCJJTlNUUlVDVE9SX0ZJTEUiLCJTUEVDSUFMX05BTUVTUEFDRVMiLCJBVkFJTEFCTEVfRURJVE9SUyIsIkVESVRPUlNfSFRNTCIsInJlZ2lzdGVyZWRfIiwiZXh0ZW5zaW9uc18iLCJieU5hbWVfIiwicmVnaXN0ZXJFZGl0b3IiLCJpbnN0YW5jZSIsImV4aXQiLCJlbnRlciIsInNwYWNlIiwiYXNzaWdubWVudFR5cGUiLCJBc3NpZ25tZW50VHlwZSIsImxhc3RJbmRleE9mIiwiZXhlY3V0aW9uTW9kZWwiLCJjb25maWd1cmF0aW9ucyIsIlJ1bkNvbmZpZ3VyYXRpb24iLCJldmFsIiwiRXZhbENvbmZpZ3VyYXRpb24iLCJPblJ1bkNvbmZpZ3VyYXRpb24iLCJPbkNoYW5nZUNvbmZpZ3VyYXRpb24iLCJPbkV2YWxDb25maWd1cmF0aW9uIiwiY29uZmlndXJlIiwiZ2V0U2t1bHB0T3B0aW9ucyIsIm9uRXhlY3V0aW9uQmVnaW4iLCJvbkV4ZWN1dGlvbkVuZCIsInJlcG9ydCIsInRyYWNpbmciLCJyZXNldFN0dWRlbnRNb2RlbCIsInJlc2V0UmVwb3J0cyIsInJlc2V0RXhlY3V0aW9uQnVmZmVyIiwidGhlbiIsImZhaWx1cmUiLCJkaXNhYmxlRmVlZGJhY2siLCJwcm92aWRlU2VjcmV0RXJyb3IiLCJzaG93RXJyb3JzIiwiZXhlY3V0aW9uRW5kXyIsImV2YWx1YXRpb25JbnB1dCIsInVzZXJJbnB1dCIsIm1pc2NldmFsIiwiYXN5bmNUb1Byb21pc2UiLCJpbXBvcnRNYWluV2l0aEJvZHkiLCJGSUxFTkFNRSIsInByb2dyYW1zIiwic2F2ZUNvZGUiLCJ2ZXJpZnlDb2RlIiwidXBkYXRlUGFyc2UiLCJydW5JbnN0cnVjdG9yQ29kZSIsIm1vZHVsZSIsImV4ZWN1dGlvblJlcG9ydHMiLCJwcmVzZW50RmVlZGJhY2siLCIkZCIsIkVNUFRZX01PRFVMRSIsIkNvbmZpZ3VyYXRpb24iLCJpbkJyb3dzZXIiLCJvcGVuRmlsZSIsInJlcXVlc3RzR2V0IiwidGltZW91dCIsIm9wZW5VUkwiLCJ0aW1lb3V0SGFuZGxlciIsInRpbWVQYXNzZWQiLCJleGVjTGltaXQiLCJkaXNhYmxlVGltZW91dCIsImdldFRpbWVvdXRQcm9tcHQiLCJkZWxheSIsInBhcnNlSW50IiwiZXhlY0xpbWl0RnVuY3Rpb24iLCJJbmZpbml0eSIsImJlZm9yZUNhbGwiLCJsb25nVGltZW91dCIsIl9fZnV0dXJlX18iLCJweXRob24zIiwicmVhZCIsImltcG9ydEZpbGUiLCJmaWxld3JpdGUiLCJ3cml0ZUZpbGUiLCJwcmludCIsImlucHV0ZnVuIiwiaW5wdXRmdW5UYWtlc1Byb21wdCIsImltYWdlUHJveHkiLCJnZXRJbWFnZVByb3h5IiwicmV0YWluR2xvYmFscyIsIndhcm4iLCJtb2NrVXJsRGF0YSIsImJ1aWx0aW4iLCJJT0Vycm9yIiwiaGFzT3duUHJvcGVydHkiLCJmaWxlRGF0YSIsInJlYWRGaWxlIiwiRXJyb3IiLCJzdG9wIiwiZnVuY3Rpb25OYW1lIiwicG9zYXJncyIsImt3YXJncyIsInN0dWRlbnRNb2RlbCIsImFyZ3MiLCJwb3AiLCJhZnRlclNpbmdsZUV4ZWN1dGlvbiIsInByaW50VmFsdWUiLCJyZW1hcFRvSnMiLCJfIiwiJHIiLCJyZWplY3QiLCJ4IiwiaXNEb2NzdHJpbmciLCJTdHVkZW50Q29uZmlndXJhdGlvbiIsIlVUSUxJVFlfTU9EVUxFX0NPREUiLCIkc2tfbW9kX2luc3RydWN0b3IiLCJDT1ZFUkFHRV9NT0RVTEVfQ09ERSIsIiRza19tb2RfY292ZXJhZ2UiLCJJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiIsImJlZm9yZUNhbGxCYWNrdXAiLCIkcGVkYWxfdHJhY2VyIiwiJG1haW4iLCJzdHIiLCJxdWljayRsb29rdXAiLCJkZWwkaXRlbSIsImZvdW5kIiwic2VhcmNoRm9yRmlsZSIsIk9TRXJyb3IiLCJuZXh0SW5wdXQiLCJjbGVhclRpbWVvdXQiLCJXUkFQX0lOU1RSVUNUT1JfQ09ERSIsInN0dWRlbnRDb2RlIiwiaW5zdHJ1Y3RvckNvZGUiLCJxdWljayIsImlzU2FmZSIsInNhZmVDb2RlIiwiaW5kZW50ZWRDb2RlIiwiaW5kZW50IiwiZGlzYWJsZVRpZmEiLCJzdHVkZW50Q29kZVNhZmUiLCJldmFsdWF0aW9uIiwiZHVtbXlPdXRTYW5kYm94IiwibGluZU9mZnNldCIsIk5FV19MSU5FX1JFR0VYIiwiU1VDQ0VTUyIsIlNDT1JFIiwib2xkU2NvcmUiLCJISURFIiwic2Nyb2xsaW5nIiwic2Nyb2xsVG9Cb3R0b20iLCJ0cCRuYW1lIiwicHJlc2VudEludGVybmFsRXJyb3IiLCJ0aWZhQW5hbHlzaXMiLCJza2lwX3RpZmEiLCJPblNhbXBsZUNvbmZpZ3VyYXRpb24iLCJCb29sZWFuIiwiY2xlYXJJbnB1dCIsImZpbmlzaFR1cnRsZXMiLCJiZWdpbkV2YWwiLCJwYXJzZXIiLCJ2ZXJpZmllciIsIlNhbXBsZUNvbmZpZ3VyYXRpb24iLCJpc0ZvcmJpZGRlbiIsImxvY2FscyIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJwYXJzZUdsb2JhbHMiLCJwcm9wZXJ0aWVzIiwibW9kdWxlcyIsImFzdCIsInZpc2l0ZWRMaW5lcyIsIlNldCIsInZpc2l0Qm9keSIsIm5vZGUiLCJsaW5lbm8iLCJzdGF0ZW1lbnQiLCJvcmVsc2UiLCJmaW5hbGJvZHkiLCJBcnJheSIsImZyb20iLCJhc3RGcm9tUGFyc2UiLCJjc3QiLCJmbGFncyIsImdldExpbmVzIiwicHJlc2VudFJ1bkVycm9yIiwiZXJyb3JCdXR0b24iLCJGRUVEQkFDS19IVE1MIiwiZmVlZGJhY2tNb2RlbCIsInBvc2l0aXZlIiwib2Zmc2V0IiwidmlzaWJpbGl0eUJ1ZmZlciIsInRvcE9mRWxlbWVudCIsImJvdHRvbU9mRWxlbWVudCIsImJvdHRvbU9mU2NyZWVuIiwidG9wT2ZTY3JlZW4iLCJjbGVhclBvc2l0aXZlRmVlZGJhY2siLCJleGVjdXRpb25SZXN1bHRzIiwiTUVTU0FHRSIsIkNBVEVHT1JZIiwiTEFCRUwiLCJEQVRBIiwicG9zaXRpdmVzIiwiUE9TSVRJVkUiLCJoaWRlU2NvcmUiLCJibG9jayIsImhsanMiLCJoaWdobGlnaHRCbG9jayIsImZpbmRGaXJzdEVycm9yTGluZSIsInN0dWRlbnRSZXBvcnQiLCJ1bmNvdmVyZWRMaW5lcyIsInBvc2l0aXZlRGF0YSIsImFkZFBvc2l0aXZlRmVlZGJhY2siLCJjb2xvciIsIm9uY2xpY2siLCJ0b0VuZCIsImNzcyIsImhvdmVyIiwidXBkYXRlRmVlZGJhY2siLCJub3RpZnlGZWVkYmFja1VwZGF0ZSIsInNjcm9sbEludG9WaWV3IiwianVzdF9yZXR1cm4iLCJjb252ZXJ0U2t1bHB0RXJyb3IiLCJmaWxlbmFtZUV4ZWN1dGVkIiwidHJhY2ViYWNrIiwiZnJhbWUiLCJzY29wZSIsImlzSW5zdHJ1Y3RvciIsImVyciIsImFsbEZyYW1lcyIsImJ1aWxkVHJhY2ViYWNrIiwiZmVlZGJhY2tEYXRhIiwibG9jYXRpb24iLCJ0cCRnZXRhdHRyIiwiZnJpZW5kbHlOYW1lIiwiaGlkZUlmRW1wdHkiLCJub3RJbnN0cnVjdG9yIiwiaW5zdHJ1Y3RvckZpbGVDbGFzcyIsImhpZGVJZk5vdEluc3RydWN0b3IiLCJGSUxFU19IVE1MIiwiTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCIsIlNUQVJUSU5HX0ZJTEVTIiwiQkFTSUNfTkVXX0ZJTEVTIiwiSU5TVFJVQ1RPUl9ESVJFQ1RPUlkiLCJTVFVERU5UX0RJUkVDVE9SWSIsIlNlYXJjaE1vZGVzIiwiRVZFUllXSEVSRSIsIlNUQVJUX1dJVEhfSU5TVFJVQ1RPUiIsIk9OTFlfU1RVREVOVF9GSUxFUyIsIkRFTEVUQUJMRV9TSU1QTEVfRklMRVMiLCJCbG9ja1B5RmlsZSIsIm93bmVyIiwibWFrZU1vY2tNb2RlbEZpbGUiLCJjb25jYXRlbmF0ZWRGaWxlIiwibW9kZWxGaWxlTGlzdCIsIm1vZGVsRmlsZXMiLCJjcmVhdGVDb25jYXRlbmF0ZWRGaWxlIiwiZmlsZXNfIiwibW91bnRGaWxlcyIsIndhdGNoTW9kZWwiLCJ3YXRjaGVzXyIsInZpc2libGl0eSIsInRvZ2dsZSIsImZpbGVzeXN0ZW0iLCJmaWxlQXJyYXkiLCJjaGFuZ2VzIiwic2Vjb25kIiwibG9jYWxlQ29tcGFyZSIsImNoYW5nZSIsIm1vZGVsRmlsZSIsIm5vdGlmeVdhdGNoZXMiLCJvYnNlcnZlSW5BcnJheV8iLCJhcnJheSIsImNvZGVCdW5kbGUiLCJleGlzdGluZ0ZpbGUiLCJvYnNlcnZlRmlsZV8iLCJzdHVkZW50U2VhcmNoIiwic2VhcmNoTW9kZSIsInNwZWNpYWxGaWxlIiwic2VhcmNoRm9yU3BlY2lhbEZpbGVzXyIsInN0dWRlbnRWZXJzaW9uIiwic2VhcmNoRm9yRmlsZUluTGlzdF8iLCJnZW5lcmF0ZWRWZXJzaW9uIiwiZGVmYXVsdFZlcnNpb24iLCJmaXJzdERlZmluZWRWYWx1ZSIsImluc3RydWN0b3JWZXJzaW9uIiwiaGlkZGVuVmVyc2lvbiIsInN0YXJ0aW5nVmVyc2lvbiIsIm1vZGVsTGlzdCIsImtpbmQiLCJmaWxldHlwZSIsIm5hbWVzcGFjZSIsImV4dGVuc2lvblJlZ2V4IiwiZXhlYyIsInByZWZpeCIsInN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwiRk9PVEVSX0hUTUwiLCJjdXJyZW50SWQiLCJlZGl0RXZlbnRzIiwic2VsZWN0b3IiLCJlZGl0SWQiLCJlbnRyeSIsImZpbGVfcGF0aCIsImV2ZW50X3R5cGUiLCJSRU1BUF9FVkVOVF9UWVBFUyIsImRpc3BsYXllZCIsInByZXR0eVByaW50RGF0ZVRpbWUiLCJjbGllbnRfdGltZXN0YW1wIiwiZGlzYWJsZSIsIm9wdGlvbiIsImRpc2FibGVkIiwiaXNFZGl0RXZlbnQiLCJldnQiLCJtb250aE5hbWVzIiwid2Vla0RheXMiLCJpc1NhbWVEYXkiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsInRpbWVTdHJpbmciLCJub3ciLCJEYXRlIiwicGFzdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImRheVN0ciIsImdldERheSIsIm1vbnRoU3RyIiwiZGF0ZSIsImdldEhpc3RvcnkiLCJyZXZlcnNlIiwicmVkdWNlIiwiY29tcGxldGUiLCJlbGVtIiwiY29tcGxldGVfc3RyIiwidGltZSIsIm5ld19saW5lIiwiaGlnaGxpZ2h0VGltZW91dCIsImlzRnVsbHNjcmVlbiIsInJlcXVlc3RGdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJUUkFDRV9IVE1MIiwiUkVUUllJTkciLCJPRkZMSU5FIiwic3RvcmFnZSIsInF1ZXVlIiwiZ2V0RGVmYXVsdCIsIk1BWF9RVUVVRV9TSVpFIiwiVElNRVJfREVMQVkiLCJGQUlMX0RFTEFZIiwidGltZXJzIiwib3ZlcmxheSIsImJsb2NraW5nQXR0ZW1wdHMiLCJjYWNoZWRGaWxlbmFtZXMiLCJjcmVhdGVTdWJzY3JpcHRpb25zIiwiY2hlY2tDYWNoZXMiLCJjaGVja0lQIiwib2xkSVAiLCJpcCIsInNldCIsIl9wb3N0TGF0ZXN0UmV0cnkiLCJwdXNoQW55UXVldWVkIiwiX3Bvc3RSZXRyeSIsImNyZWF0ZUZpbGVTdWJzY3JpcHRpb24iLCJjcmVhdGVFdmVudExvZ3MiLCJvbmJsdXIiLCJvbmZvY3VzIiwiY3JlYXRlU2VydmVyRGF0YSIsIm1pY3Jvc2Vjb25kcyIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNob3dPdmVybGF5IiwiYXR0ZW1wdCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlT3ZlcmxheSIsIl9lbnF1ZXVlRGF0YSIsImNhY2hlIiwiX2RlcXVldWVEYXRhIiwic3BsaWNlIiwicG9zdFJlcXVlc3QiLCJwb3N0IiwidGV4dFN0YXR1cyIsImZhaWx1cmVGdW5jdGlvbiIsImRvbmVGdW5jdGlvbiIsInJlcXVlc3QiLCJjYWNoZWRUaW1lIiwiX3Bvc3RCbG9ja2luZyIsImF0dGVtcHRzIiwiZXJyb3JUaHJvd24iLCJzdGFydFBvc3NpYmxlRm9yayIsImRpcmVjdG9yeSIsIm5ld1N0YXR1cyIsInBvc3RTdGF0dXNDaGFuZ2UiLCJlcnJvckNhbGxiYWNrIiwibG9hZF9maWxlIiwiZm9ya2FibGUiLCJoaWRkZW5PdmVycmlkZSIsImZvcmNlVXBkYXRlIiwiZ2V0UG5nRnJvbUJsb2NrcyIsInBuZ0RhdGEiLCIkYnVpbHRpbm1vZHVsZSIsIm1vZCIsInNhbXBsZVdyYXBwZXIiLCJfX25hbWVfXyIsIlBJTCIsIkluc3RhbnRQcm9taXNlIiwibGFzdFJlc3VsdCIsImxhc3RFcnJvciIsImNiIiwiYnVpbGRJbWFnZSIsImdldEFzc2V0IiwiY3Jvc3NPcmlnaW4iLCJvbmVycm9yIiwic3JjIiwiJGdibCIsIiRsb2MiLCJfX2luaXRfXyIsImZ1bmMiLCJmaWxlX29yX3VybCIsInB5Q2hlY2tBcmdzIiwicHlDaGVja1R5cGUiLCJjaGVja1N0cmluZyIsImltYWdlUHJvbWlzZSIsInN1c3AiLCJTdXNwZW5zaW9uIiwibm9uZSIsIm5vbmUkIiwicmVzdW1lIiwicHJvbWlzZSIsImRyYXdJbWFnZSIsInBpeGVscyIsImdldEltYWdlRGF0YSIsIk5hbWVFcnJvciIsImNvbnNvbGVEYXRhIiwicHJpbnRQSUxJbWFnZSIsImZsaXAiLCJzdHlsZSIsInRyYW5zZm9ybSIsImJ1aWxkQ2xhc3MiLCJwcmlvciIsInRpbWVpdCIsImRpZmZlcmVuY2UiLCJjb25zb2xlX2xvZyIsImNvbnNvbGVfZGVidWciLCJnZXRfb3V0cHV0IiwiaXRlbSIsInRvU2t1bHB0IiwibGlzdCIsInJlc2V0X291dHB1dCIsImdldF9wcm9ncmFtIiwiZ2V0X2V2YWx1YXRpb24iLCJ0cmFjZV9saW5lcyIsInJlYWxMaW5lcyIsInRyYWNlX2NhbGxzIiwiZGljdCIsInN0YXJ0X3RyYWNlIiwic3RvcF90cmFjZSIsImdldF9zdHVkZW50X2Vycm9yIiwidHVwbGUiLCJoYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3IiLCJiYWNrdXBUaW1lIiwibGltaXRfZXhlY3V0aW9uX3RpbWUiLCJleGVjU3RhcnQiLCJ1bmxpbWl0X2V4ZWN1dGlvbl90aW1lIiwic3VwcHJlc3Nfc2Nyb2xsaW5nIiwiZ2V0X3Bsb3RzIiwib3V0cHV0cyIsImdyYXBoIiwicGxvdCIsIm5ld1Bsb3QiLCJ2IiwieSIsIlN0dWRlbnREYXRhIiwibmV3RGljdCIsImFic3RyIiwic2F0dHIiLCJvYmplY3RTZXRJdGVtIiwidW5maXhSZXNlcnZlZCIsImNhbGxfZiIsImt3YSIsInB5Q2hlY2tBcmdzTGVuIiwiY2FsbCIsImJ1aWx0aW5zIiwibXAkbG9va3VwIiwiZnVuY3Rpb25PYmplY3QiLCJ0cCRjYWxsIiwiY29fa3dhcmdzIiwiY29fbmFtZSIsImdldF9uYW1lc19ieV90eXBlIiwiZXhjbHVkZV9idWlsdGlucyIsImNoZWNrQm9vbCIsInByb3BlcnR5IiwiZ2V0X3ZhbHVlc19ieV90eXBlIiwiY2FsbHNpbU9yU3VzcGVuZCIsImdldF9zdHVkZW50X2RhdGEiLCJzZXRfaW5zdHJ1Y3Rpb25zIiwibmV3SW5zdHJ1Y3Rpb25zIiwiZ2V0X21vZGVsX2luZm8iLCJMT0NBTF9TVE9SQUdFX1JFRiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiX2RhdGEiLCJTdHJpbmciLCJnZXRJdGVtIiwiaXNfbmV3Iiwic2VydmVyX3RpbWUiLCJzdG9yZWRfdGltZSIsIklHTk9SRURfR0xPQkFMUyIsInZhcmlhYmxlcyIsInBhcnNlZCIsInBhcnNlVmFsdWUiLCJmdWxsTGVuZ3RoIiwiZnVuY19jb2RlIiwiY29fdmFybmFtZXMiLCJzcSRsZW5ndGgiLCJib29sIiwibm1iZXIiLCJza1R5cGUiLCJpbnRfIiwiZmxvYXRfIiwiTnVtYmVyIiwiYXJyYXlDb250YWlucyIsIm5lZWRsZSIsImhheXN0YWNrIiwiYXJyYXlVbmlxdWUiLCJhIiwiY29uY2F0IiwiaiIsImV4cGFuZEFycmF5IiwiYWRkQXJyYXkiLCJyZW1vdmVBcnJheSIsImNvcHlBcnJheSIsImNsb25lTm9kZSIsImNsb25lIiwibm9kZVR5cGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsImNoaWxkIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicyIsInJhbmRvbUludGVnZXIiLCJmbG9vciIsInJhbmRvbSIsIldvcmtzcGFjZVN2ZyIsInNodWZmbGUiLCJtZXRyaWNzIiwiZ2V0TWV0cmljcyIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJibG9ja3MiLCJnZXRUb3BCbG9ja3MiLCJtYXhpbWFsX2luY3JlYXNlIiwiZ2V0UmVsYXRpdmVUb1N1cmZhY2VYWSIsIm1vdmVCeSIsIm1vdmVFbGVtZW50cyIsIm1vdmVDaGVjayIsImlzU2tCdWlsdGluIiwib2JqIiwibG5nIiwiaXNBc3ROb2RlIiwibWl4ZWRSZW1hcFRvUHkiLCJrIiwia3ZzIiwiYXJyIiwic3VidmFsIiwiYXNzayQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7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ZSxPQUFILENBQVcwZCxLQUFYLENBQWlCUixHQUFqQixDQUFQO0FBQ0gsR0FGTSxNQUVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFNBQW5CLEVBQThCO0FBQ2pDLFdBQU8sSUFBSWo4QixFQUFFLENBQUMrZSxPQUFILENBQVd1YSxJQUFmLENBQW9CMkMsR0FBcEIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFHLE9BQU9BLEdBQVAsS0FBZSxVQUFsQixFQUE4QjtBQUNqQyxXQUFPLElBQUlqOEIsRUFBRSxDQUFDK2UsT0FBSCxDQUFXOEIsR0FBZixDQUFtQm9iLEdBQUcsQ0FBQ2x3QyxJQUF2QixDQUFQO0FBQ0g7QUFDSixDOzs7Ozs7Ozs7OztBQ25RRCxvRDs7Ozs7Ozs7Ozs7QUNBQSxzRCIsImZpbGUiOiJibG9ja3B5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJibG9ja3B5XCIsIFtcImpRdWVyeVwiLCBcImtvXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImJsb2NrcHlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJqUXVlcnlcIiksIHJlcXVpcmUoXCJrb1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiYmxvY2tweVwiXSA9IGZhY3Rvcnkocm9vdFtcImpRdWVyeVwiXSwgcm9vdFtcImtvXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2tub2Nrb3V0X18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9ibG9ja3B5LmpzXCIpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YXJ0aW5nIHBvaW50IG9mIHRoZSBCbG9ja1B5IGFwcGxpY2F0aW9uLCBjb250YWluaW5nIHRoZSBtYWluXG4gKiBCbG9ja1B5IGNsYXNzLlxuICovXG5pbXBvcnQgXCIuL2Nzcy9ibG9ja3B5LmNzc1wiO1xuaW1wb3J0IFwiLi9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzXCI7XG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIGltYWdlTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvaW1hZ2VcIjtcbi8vaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyBtYXRwbG90bGliTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvbWF0cGxvdGxpYjJcIjtcbmltcG9ydCB7TG9jYWxTdG9yYWdlV3JhcHBlcn0gZnJvbSBcInN0b3JhZ2UuanNcIjtcbmltcG9ydCB7RWRpdG9yc0VudW19IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge0Rpc3BsYXlNb2Rlc30gZnJvbSBcImVkaXRvci9weXRob24uanNcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCJzZXJ2ZXIuanNcIjtcbmltcG9ydCB7bWFrZUludGVyZmFjZSwgbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucywgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfSBmcm9tIFwiaW50ZXJmYWNlLmpzXCI7XG5pbXBvcnQge0VkaXRvcnN9IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge1xuICAgIEJsb2NrUHlGaWxlU3lzdGVtLFxuICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlLFxuICAgIG1ha2VNb2RlbEZpbGUsXG4gICAgb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUsXG4gICAgVU5ERUxFVEFCTEVfRklMRVMsXG4gICAgVU5SRU5BTUFCTEVfRklMRVNcbn0gZnJvbSBcIi4vZmlsZXNcIjtcbmltcG9ydCB7dXBsb2FkRmlsZSwgZG93bmxvYWRGaWxlfSBmcm9tIFwiLi9lZGl0b3IvYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0Jsb2NrUHlFbmdpbmV9IGZyb20gXCJlbmdpbmUuanNcIjtcbmltcG9ydCB7QmxvY2tQeVRyYWNlfSBmcm9tIFwiLi90cmFjZVwiO1xuaW1wb3J0IHtCbG9ja1B5Q29uc29sZX0gZnJvbSBcIi4vY29uc29sZVwiO1xuaW1wb3J0IHtCbG9ja1B5RmVlZGJhY2t9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtCbG9ja1B5U2VydmVyfSBmcm9tIFwiLi9zZXJ2ZXJcIjtcbmltcG9ydCB7QmxvY2tQeURpYWxvZ30gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQge0Fzc2lnbWVudFR5cGUsIGxvYWRBc3NpZ25tZW50U2V0dGluZ3MsIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbH0gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcbmltcG9ydCB7QmxvY2tQeUNvcmdpcywgX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTLCBfSU1QT1JURURfREFUQVNFVFN9IGZyb20gXCIuL2Nvcmdpc1wiO1xuaW1wb3J0IHtCbG9ja1B5SGlzdG9yeX0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtjYXBpdGFsaXplfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U2FtcGxlU3VibWlzc2lvbn0gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuXG5leHBvcnQge19JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfTtcblxuY29uc3QgRURJVE9SX1ZFUlNJT04gPSBcIjUuMS4yXCI7XG5cbi8qKlxuICogTWFqb3IgZW50cnkgcG9pbnQgZm9yIGNyZWF0aW5nIGEgQmxvY2tQeSBpbnN0YW5jZS5cbiAqIFR3byBtb3N0IGltcG9ydGFudCBmaWVsZHMgYXJlIGBtb2RlbGAgYW5kIGBjb21wb25lbnRzYC5cbiAqIFRoZSBgbW9kZWxgIGhvbGRzIGFsbCB0aGUgZGF0YSBhYm91dCB0aGUgaW50ZXJmYWNlLlxuICogVGhlIGBjb21wb25lbnRzYCBhcmUgcmVmZXJlbmNlcyB0byB0aGUgZGlzcGFyYXRlIHBhcnRzIG9mIEJsb2NrUHkuXG4gKlxuICogTW9zdCBvZiB0aGlzIGNsYXNzZXMgZGVmaW5pdGlvbiBpcyBqdXN0IGluaXRpYWxpemluZyB0aGUgbW9kZWwgYW5kIHVwZGF0aW5nXG4gKiBpdCBvbiBhbiBhc3NpZ25tZW50IHN3aXRjaC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIC0gVXNlciBsZXZlbCBzZXR0aW5ncyAoZS5nLiwgd2hhdCBlZGl0b3IgbW9kZSwgd2hldGhlciB0byBtdXRlIHNlbWFudGljIGVycm9ycywgZXRjLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudCAtIEFzc2lnbm1lbnQgbGV2ZWwgc2V0dGluZ3MgKGRhdGEgYWJvdXQgdGhlIGxvYWRlZCBhc3NpZ25tZW50LCB1c2VyLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIC0gSW5jbHVkZXMgdGhlIHNvdXJjZSBjb2RlIG9mIGFueSBwcm9ncmFtcyB0byBiZSBsb2FkZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAoYXNzaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFzc2lnbm1lbnQoY29uZmlndXJhdGlvbiwgYXNzaWdubWVudCwgc3VibWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWFpbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBCbG9ja1B5IG9iamVjdCBieSBpbml0aWFsaXppbmcgaXRzIGludGVyZmFjZSxcbiAgICAgKiBtb2RlbCwgYW5kIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0TWFpbigpIHtcbiAgICAgICAgdGhpcy5pbml0VXRpbGl0aWVzKCk7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsTWV0aG9kcygpO1xuICAgICAgICB0aGlzLnR1cm5PbkhhY2tzKCk7XG4gICAgICAgIHRoaXMuaW5pdEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmFwcGx5TW9kZWwoKTtcbiAgICAgICAgdGhpcy5pbml0Q29tcG9uZW50cygpO1xuICAgICAgICB0aGlzLm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBkZWZhdWx0IHZhbHVlIG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdG8gbG9vayB1cCBhIHZhbHVlIGZvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0VmFsdWUgLSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBhbnl3aGVyZSwgdXNlIHRoaXMgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5nKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxTZXR0aW5nc18uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU2V0dGluZ3NfLmdldChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RlbCB0byBpdHMgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBDYXRlZ29yaWVzOlxuICAgICAqICAgKiB1c2VyOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIgKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGFzc2lnbm1lbnQ6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgYXNzaWdubWVudCAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogc3VibWlzc2lvbjogdmFsdWVzIGZvciB0aGUgY3VycmVudCBzdWJtaXNzaW9uIChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBkaXNwbGF5OiBmbGFncyByZWxhdGVkIHRvIGN1cnJlbnQgdmlzaWJpbGl0eSAoc3RvcmVkIHRvIGxvY2FsU2V0dGluZ3MpXG4gICAgICogICAqIHN0YXR1czogbWVzc2FnZXMgcmVsYXRlZCB0byBjdXJyZW50IHN0YXR1cyAobm90IHN0b3JlZClcbiAgICAgKiAgICogZXhlY3V0aW9uOiB2YWx1ZXMgcmVsYXRlZCB0byBsYXN0IHJ1biAobm90IHN0b3JlZClcbiAgICAgKiAgICogY29uZmlndXJhdGlvbjogY29uc3RhbnQgdmFsdWVzIHJlbGF0ZWQgdG8gc2V0dXAgKG5vdCBzdG9yZWQpXG4gICAgICovXG4gICAgaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgLy8gQ29ubmVjdCB0byBsb2NhbCBzdG9yYWdlXG4gICAgICAgIHRoaXMubG9jYWxTZXR0aW5nc18gPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcImxvY2FsU2V0dGluZ3NcIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fID0gY29uZmlndXJhdGlvbjtcblxuICAgICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmlkXCJdKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLm5hbWVcIl0pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgeW91IGFyZSBhbiBPd25lciAoY2FuIG1vZGlmeSB0aGUgYXNzaWdubWVudCksIEdyYWRlciAoY2FuIHZpZXdcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXNzaWdubWVudHMnIGluZm9ybWF0aW9uKSBvciBTdHVkZW50IChjYW4gbm90IHNlZSBhbnkgaW5zdHJ1Y3RvciBzdHVmZikuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcm9sZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJ1c2VyLnJvbGVcIiwgXCJvd25lclwiKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBjb3Vyc2UgZm9yIHRoaXMgdXNlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmNvdXJzZV9pZFwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBhc3NpZ25tZW50IGdyb3VwIHRoYXQgdGhpcyB1c2VyIGlzIGluc2lkZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuZ3JvdXBfaWRcIl0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWdubWVudDoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoXCJTY3JhdGNoIENhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUoXCJXZWxjb21lIHRvIEJsb2NrUHkuIFRyeSBlZGl0aW5nIGFuZCBydW5uaW5nIHRoZSBjb2RlIGJlbG93LlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaHVtYW4tZnJpZW5kbHkgVVJMIHRvIHVzZSBhcyBhIHNob3J0Y3V0IGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybmluZyBtZXNzYWdlIGlmIG1hemVcbiAgICAgICAgICAgICAgICB0eXBlOiBrby5vYnNlcnZhYmxlKEFzc2lnbWVudFR5cGUuQkxPQ0tQWSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQ29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zdGFydGluZ19jb2RlXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uUnVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX3J1blwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9jaGFuZ2VcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgb25FdmFsOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2V2YWxcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgZXh0cmFTdGFydGluZ0ZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGZvcmtlZElkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGZvcmtlZFZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgcmV2aWV3ZWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQucmV2aWV3ZWRcIl0pLFxuICAgICAgICAgICAgICAgIHB1YmxpYzoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5wdWJsaWNcIl0pLFxuICAgICAgICAgICAgICAgIGhpZGRlbjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5oaWRkZW5cIl0pLFxuICAgICAgICAgICAgICAgIGlwUmFuZ2VzOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmlwX3Jhbmdlc1wiXSksXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgZXh0cmFGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgc2NvcmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgY29ycmVjdDoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudElkIGluZmVycmVkIGZyb20gYXNzaWdubWVudC5pZFxuICAgICAgICAgICAgICAgIC8vIGNvdXJzZUlkIGluZmVycmVkIGZyb20gdXNlci5jb3Vyc2VJZFxuICAgICAgICAgICAgICAgIC8vIHVzZXJJZCBpbmZlcnJlZCBmcm9tIHVzZXIuaWRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50VmVyc2lvbiBpbmZlcnJlZCBmcm9tIGFzc2lnbm1lbnQudmVyc2lvblxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShcIlN0YXJ0ZWRcIiksXG4gICAgICAgICAgICAgICAgZ3JhZGluZ1N0YXR1czoga28ub2JzZXJ2YWJsZShcIk5vdFJlYWR5XCIpLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IGtvLm9ic2VydmFibGUobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudGx5IHZpc2libGUgRmlsZSwgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgcHJlc2VudGVkIHdpdGggdGhlIGluc3RydWN0b3Igc2V0dGluZ3MgYW5kIGZpbGVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoga28ub2JzZXJ2YWJsZShcIlwiK3RoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkuaW5zdHJ1Y3RvclwiLCBcImZhbHNlXCIpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHByZXZlbnQgdGhlIHByaW50ZXIgZnJvbSBzaG93aW5nIHRoaW5nc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG11dGVQcmludGVyOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAoUHl0aG9uIFZpZXdzKSBUaGUgY3VycmVudCBlZGl0b3IgbW9kZS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7RGlzcGxheU1vZGVzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHB5dGhvbk1vZGU6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5weXRob24ubW9kZVwiLCBEaXNwbGF5TW9kZXMuU1BMSVQpKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBIaXN0b3J5IG1vZGUgaXMgZW5nYWdlZC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBoaXN0b3J5TW9kZToga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgYXV0by1zYXZpbmcgY2hhbmdlcyBpbiBQeXRob24gZWRpdG9yXG4gICAgICAgICAgICAgICAgICogSWYgYW4gaW50ZWdlciwgc3BlY2lmaWVzIHRoZSBkZWxheSB0aGF0IHNob3VsZCBiZSB1c2VkIChtaWNyb3NlY29uZHMpLlxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgbmV2ZXIgb24gaW4gbm9uLVB5dGhvbiBlZGl0b3JzLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfGludH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhdXRvU2F2ZToga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY29uc29sZSBpcyBmdWxsIHdpZHRoIGFuZCBmZWVkYmFjayBpcyBoaWRkZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBiaWdDb25zb2xlOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIGNvbnNvbGUuXG4gICAgICAgICAgICAgICAgICogICAgSWYgbnVsbCwgdGhlbiBsZXQgdGhlIGhlaWdodCByZW1haW4gdW5jaGFuZ2VkXG4gICAgICAgICAgICAgICAgICogICAgSWYgYSBudW1iZXIsIHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJldmlvdXNDb25zb2xlSGVpZ2h0OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb25zb2xlSGVpZ2h0OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoaWNoIHBhbmVsIHRvIHNob3cgaW4gdGhlIHNlY29uZCByb3cncyBzZWNvbmQgY29sdW1uXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1NlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9uc31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWNvbmRSb3dTZWNvbmRQYW5lbDoga28ub2JzZXJ2YWJsZShTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0spLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIHRyYWNpbmcgdGhlIGNvZGUgcmlnaHQgbm93XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJhY2VFeGVjdXRpb246IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBsaXN0IG9mIHByb21pc2VzIHRvIHN0aWxsIHJlc29sdmUgd2hpbGUgbG9hZGluZyBkYXRhc2V0c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxQcm9taXNlPn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsb2FkaW5nRGF0YXNldHM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHRlbXBvcmFyeSBjaGFuZ2VkIHZhbHVlIG9mIHRoZSBpbnN0cnVjdGlvbnMgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSB3aGF0IGlzIGluIHRoZSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhbmdlZEluc3RydWN0aW9uczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIGhvbGRlciBmb3IgdGhlIHRpbWVyIHRvIHRyaWdnZXIgb24tY2hhbmdlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyaWdnZXJPbkNoYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IGZlZWRiYWNrIGFuZCBvdXRwdXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgc3VibWlzc2lvbi5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdvdWxkIGJlIGZhbHNlIGlmIHRoZXJlIGlzIG5vIGZlZWRiYWNrL291dHB1dCAoaS5lLiwgY29kZSBoYXMgbm90IGJlZW4gcnVuKSxcbiAgICAgICAgICAgICAgICAgKiBvciBpZiB0aGUgdXNlciBoYXMgbW9kaWZpZWQgdGhlIHN1Ym1pc3Npb24gYWZ0ZXIgdGhlIGxhc3QgcnVuIChlLmcuLCBieSBlZGl0aW5nXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpcnR5U3VibWlzc2lvbjoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdG8gbWFrZSB0aGUgQmxvY2tQeSBlbGVtZW50IGluIEZVTEwgU0NSRUVOIG1vZGUuIFNhZGx5LCBub3QgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICAqICB3aXRoaW4gdGhlIHdpbmRvdywgYnV0IEZVTEwgU0NSRUVOLiBWZXJ5IGFnZ3Jlc3NpdmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVsbHNjcmVlbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXNlci1zdXBwbGllZCBwYXNzY29kZSB0byBjb21wYXJlIG9uIHRoZSBzZXJ2ZXIgYWdhaW5zdCB0aGUgY3VycmVudCBwYXNzY29kZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXNzY29kZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBjbGVhciBvdXQgaW5wdXRzIGFmdGVyIGEgcnVuL29uX3J1biBjeWNsZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNsZWFySW5wdXRzOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIGVkaXRvclZlcnNpb246IEVESVRPUl9WRVJTSU9OLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkucmVhZF9vbmx5XCIsIFwiZmFsc2VcIikudG9TdHJpbmcoKT09PVwidHJ1ZVwiKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEhpc3RvcnlNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkRGF0YXNldE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2dFdmVudDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9nRXZlbnRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2VNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXM6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgb25FeGVjdXRpb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IGluLXByb2dyZXNzIGV4ZWN1dGlvbnNcbiAgICAgICAgICAgICAgICByZXBvcnRzOiB7fSxcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIE91dHB1dCBvYmplY3RzXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIC8vIExpc3Qgb2YgaW5wdXR0ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIGlucHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXg6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBhIHN0dWRlbnQgcnVuXG4gICAgICAgICAgICAgICAgc3R1ZGVudDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHI6IHRoZSBmaWxlbmFtZSB0aGF0IHdhcyBsYXN0IGV4ZWN1dGVkIGFuZCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdExpbmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIHNpbXBsZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjZURhdGE6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlU3RlcDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsIGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGNhbGxzOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gZmVlZGJhY2sgZnJvbSB0aGUgaW5zdHJ1Y3RvciBydW5cbiAgICAgICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHIgKG1hcmtkb3duKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiUmVhZHlcIiksXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNFcnJvcjoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNVbmNvdmVyZWQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBudWxsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyB0byBmaXJlIHdoZW4gY2VydGFpbiBldmVudHMgb2NjdXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIHN0dWRlbnQgZ2V0cyBhIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImNhbGxiYWNrLnN1Y2Nlc3NcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2VydmVyIGlzIGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb25uZWN0ZWQ6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwic2VydmVyLmNvbm5lY3RlZFwiLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYmxvY2tseVBhdGg6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiYmxvY2tseS5wYXRoXCJdLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRQb2ludDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJhdHRhY2htZW50LnBvaW50XCJdLFxuICAgICAgICAgICAgICAgIC8vIEpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgLy8gTWFwcyBjb2RlcyAoJ2xvZ19ldmVudCcsICdzYXZlX2NvZGUnKSB0byBVUkxzXG4gICAgICAgICAgICAgICAgdXJsczogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJ1cmxzXCJdIHx8IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGludGVyZmFjZVxuICAgICAqL1xuICAgIGluaXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIGxldCBjb25zdGFudHMgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGxldCBndWkgPSBtYWtlSW50ZXJmYWNlKHRoaXMpO1xuICAgICAgICBjb25zdGFudHMuY29udGFpbmVyID0gJChjb25zdGFudHMuYXR0YWNobWVudFBvaW50KS5odG1sKCQoZ3VpKSk7XG4gICAgfTtcblxuICAgIGxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5sb2FkQXNzaWdubWVudChhc3NpZ25tZW50X2lkKTtcbiAgICB9XG5cbiAgICBsb2FkVGFncyh0YWdzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHRhZ3NcbiAgICB9XG5cbiAgICBsb2FkU2FtcGxlU3VibWlzc2lvbnMoc2FtcGxlcykge1xuICAgICAgICAvLyBBbHJlYWR5IGEgSlNPTiBsaXN0IHJlcHJlc2VudGluZyBzYW1wbGVzXG4gICAgfVxuXG4gICAgbG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICB9XG5cbiAgICBsb2FkU3VibWlzc2lvbihzdWJtaXNzaW9uLCBhc3NpZ25tZW50KSB7XG4gICAgICAgIGlmICghc3VibWlzc2lvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogU2NhcmllciBcIllvdSBhcmUgbm90IGxvZ2dlZCBpbiBtZXNzYWdlXCJcbiAgICAgICAgICAgIHRoaXMubG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHN1Ym1pc3Npb25zJyBhc3NpZ25tZW50IHZlcnNpb24gYW5kIHRoZSBhc3NpZ25tZW50cycgdmVyc2lvbiBjb25mbGljdD9cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmlkKHN1Ym1pc3Npb24uaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29kZShzdWJtaXNzaW9uLmNvZGUpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWJtaXNzaW9uLmNvcnJlY3QpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc3VibWlzc2lvbi5zY29yZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5lbmRwb2ludChzdWJtaXNzaW9uLmVuZHBvaW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnVybChzdWJtaXNzaW9uLnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi52ZXJzaW9uKHN1Ym1pc3Npb24udmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5ncmFkaW5nU3RhdHVzKHN1Ym1pc3Npb24uZ3JhZGluZ19zdGF0dXMpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhzdWJtaXNzaW9uLnN1Ym1pc3Npb25fc3RhdHVzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLm93bmVySWQoc3VibWlzc2lvbi51c2VyX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC51c2VyLmNvdXJzZUlkKHN1Ym1pc3Npb24uY291cnNlX2lkKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoc3VibWlzc2lvbi5leHRyYV9maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRBc3NpZ25tZW50RGF0YV8oZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgdGhpcy5yZXNldEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kaXNtb3VudEV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IHdhc1NlcnZlckNvbm5lY3RlZCA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgIGxldCBhc3NpZ25tZW50ID0gZGF0YS5hc3NpZ25tZW50O1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaWQoYXNzaWdubWVudC5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC52ZXJzaW9uKGFzc2lnbm1lbnQudmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5jb3Vyc2VJZChhc3NpZ25tZW50LmNvdXJzZV9pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5mb3JrZWRJZChhc3NpZ25tZW50LmZvcmtlZF9pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5mb3JrZWRWZXJzaW9uKGFzc2lnbm1lbnQuZm9ya2VkX3ZlcnNpb24pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKGFzc2lnbm1lbnQuaGlkZGVuKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKGFzc2lnbm1lbnQucmV2aWV3ZWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucHVibGljKGFzc2lnbm1lbnQucHVibGljKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnR5cGUoYXNzaWdubWVudC50eXBlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnVybChhc3NpZ25tZW50LnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wb2ludHMoYXNzaWdubWVudC5wb2ludHMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaXBSYW5nZXMoYXNzaWdubWVudC5pcF9yYW5nZXMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKGFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoYXNzaWdubWVudC5uYW1lKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKGFzc2lnbm1lbnQub25fY2hhbmdlIHx8IG51bGwpO1xuICAgICAgICBpZiAoYXNzaWdubWVudC5vbl9jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUoXCIhb25fY2hhbmdlLnB5XCIsIGFzc2lnbm1lbnQub25fY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKGFzc2lnbm1lbnQub25fZXZhbCB8fCBudWxsKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQub25fZXZhbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShcIiFvbl9ldmFsLnB5XCIsIGFzc2lnbm1lbnQub25fZXZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuKGFzc2lnbm1lbnQub25fcnVuKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZShhc3NpZ25tZW50LnN0YXJ0aW5nX2NvZGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub3duZXJJZChhc3NpZ25tZW50Lm93bmVyX2lkKTtcbiAgICAgICAgdGhpcy5sb2FkVGFncyhhc3NpZ25tZW50LnRhZ3MpO1xuICAgICAgICB0aGlzLmxvYWRTYW1wbGVTdWJtaXNzaW9ucyhhc3NpZ25tZW50LnNhbXBsZV9zdWJtaXNzaW9ucyk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcywgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9zdGFydGluZ19maWxlcywgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyk7XG4gICAgICAgIGxvYWRBc3NpZ25tZW50U2V0dGluZ3ModGhpcy5tb2RlbCwgYXNzaWdubWVudC5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMubG9hZFN1Ym1pc3Npb24oZGF0YS5zdWJtaXNzaW9uLCBhc3NpZ25tZW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbih0cnVlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobnVsbCk7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQod2FzU2VydmVyQ29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmNvcmdpcy5sb2FkRGF0YXNldHModHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0ucmVmcmVzaCgpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgIH1cblxuICAgIGluaXRNb2RlbE1ldGhvZHMoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgbW9kZWwudWkgPSB7XG4gICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgaXNHcmFkZXI6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVzZXIucm9sZSgpID09PSBcIm93bmVyXCIgfHwgbW9kZWwudXNlci5yb2xlKCkgPT09IFwiZ3JhZGVyXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuaXNDaGFuZ2VkKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51dGlsaXRpZXMubWFya2Rvd24obW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZXNldDogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG51bGwpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudToge1xuICAgICAgICAgICAgICAgIHRleHRGdWxsc2NyZWVuOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKSA/IFwiZmEtY29tcHJlc3MtYXJyb3dzLWFsdFwiIDogXCJmYS1leHBhbmQtYXJyb3dzLWFsdFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjbGlja0Z1bGxzY3JlZW46ICgpID0+e1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oIW1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVkaXRJbnB1dHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmRpYWxvZy5FRElUX0lOUFVUUygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuTWFya1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuY2FuQ2xvc2UoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dE1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC51c2VyLmdyb3VwSWQoKSA/IFwiUHJvYmxlbSBjbG9zZWRcIiA6IFwiQXNzaWdubWVudCBjbG9zZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJlb3BlbiBmb3IgZWRpdGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpICYmIG1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3VibWl0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdCBlYXJseVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2xpY2tNYXJrU3VibWl0dGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiWW91IGNhbm5vdCByZW9wZW4gY2xvc2VkIGFzc2lnbm1lbnRzLiBDb250YWN0IGEgZ3JhZGVyIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvblN0YXR1cyhcImluUHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJTdWJtaXR0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fCBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cygpLnRvTG93ZXJDYXNlKCkgPT09IFwic3VibWl0dGVkXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBsZXRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG93UXVldWVkSW5wdXRzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZVF1ZXVlZElucHV0cygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlY29uZFJvdzoge1xuICAgICAgICAgICAgICAgIGlzQWxsVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVNaWRkbGVQYW5lbCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0ZlZWRiYWNrVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc1RyYWNlVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbnNvbGVTaG93VmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlY29uZFJvdy5pc0ZlZWRiYWNrVmlzaWJsZSgpIHx8IG1vZGVsLnVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hMYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJWaWV3IFRyYWNlXCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhZHZhbmNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYW5lbCA9IG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0spO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25zb2xlOiB7XG4gICAgICAgICAgICAgICAgc2l6ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC02XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZGVFdmFsdWF0ZToga28ucHVyZUNvbXB1dGVkKCAoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUV2YWx1YXRlKCkgfHwgIW1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmdsb2JhbHMoKSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgICAgYmFkZ2U6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ1bnRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ydW50aW1lLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc3ludGF4LWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWRpdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc3ludGF4LWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1pbnRlcm5hbC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbWFudGljXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5hbHl6ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zZW1hbnRpYy1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZlZWRiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWZlZWRiYWNrLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1wcm9ibGVtLWNvbXBsZXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3Rpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtaW5zdHJ1Y3Rpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm8gZXJyb3JzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm8tZXJyb3JzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ1bnRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSdW50aW1lIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3ludGF4IEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWRpdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRWRpdG9yIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnRlcm5hbCBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbWFudGljXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5hbHl6ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbGdvcml0aG0gRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmZWVkYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkluc3RydWN0aW9uc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbmNvcnJlY3QgQW5zd2VyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJDb21wbGV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vIGVycm9yc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjZToge1xuICAgICAgICAgICAgICAgIGhhczoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGluZToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhIHx8IHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHRyYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJlZm9yZSBydW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBsYXN0U3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRmluaXNoZWQgcnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgYXJlIHRoZXNlIG51bWJlcnMgd29ua3k/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMaW5lIFwiKyh0cmFjZURhdGFbc3RlcF0ubGluZS0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYWNrd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBNYXRoLm1heCgwLCBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3J3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gTWF0aC5taW4obW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSwgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobmV4dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxhc3RTdGVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZURhdGFbc3RlcCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VEYXRhW3N0ZXBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnRzOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuc3dlci5weVwiOiByZXR1cm4gbW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWluc3RydWN0aW9ucy5tZFwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2V2YWwucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP21vY2tfdXJscy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3ByZWZpeC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3N1ZmZpeC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dG9vbGJveC5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj90b29sYm94LmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXRhZ3MuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC50YWdzKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9tb2NrX3VybHMuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfcHJlZml4LnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9zdWZmaXgucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dGFncy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3NldHRpbmdzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dG9vbGJveC5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vcm1hbFRvb2xib3ggPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLlRPT0xCT1hFU1tcIm5vcm1hbFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxUb29sYm94ID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsVG9vbGJveCwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoLCBub3JtYWxUb29sYm94KTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucyhbU2FtcGxlU3VibWlzc2lvbi5CbGFuaygpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZml4IGV4dHJhZmlsZXMgZm9yIGluc3RydWN0b3IgYW5kIHN0dWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHVkZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0dWRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0YXJ0aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFN0dWRlbnRDb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeFB5ID0gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIiFhbnN3ZXJfcHJlZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4UHkgPSBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiIWFuc3dlcl9zdWZmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeFB5ICYmIHByZWZpeFB5LmhhbmRsZSAmJiBwcmVmaXhQeS5oYW5kbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IHByZWZpeFB5LmhhbmRsZSgpICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VmZml4UHkgJiYgc3VmZml4UHkuaGFuZGxlICYmIHN1ZmZpeFB5LmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSArIHN1ZmZpeFB5LmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFTdHVkZW50RmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhU3RhcnRpbmdGaWxlczogb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlGaWxlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVVJMIERhdGFcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbnN3ZXIgUHJlZml4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiIWFuc3dlcl9zdWZmaXgucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQW5zd2VyIFN1ZmZpeFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIj90b29sYm94LmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVG9vbGJveFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCImXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVkaXRvcnM6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBrby5wdXJlQ29tcHV0ZWQoICgpPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuZ2V0RWRpdG9yKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHZpZXc6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUVkaXRvcnMoKSkgPyBcIk5vbmVcIiA6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA/IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpIDogXCJOb25lXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5SZXNldFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5jb2RlKG1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMoKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lKCkuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhblNhdmU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuZGlzcGxheS5hdXRvU2F2ZSgpKSxcbiAgICAgICAgICAgICAgICBjYW5EZWxldGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKCkgfHwgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIFVOREVMRVRBQkxFX0ZJTEVTLmluZGV4T2YobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKSA9PT0gLTEpLFxuICAgICAgICAgICAgICAgIGNhblJlbmFtZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKSB8fCBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgVU5SRU5BTUFCTEVfRklMRVMuaW5kZXhPZihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpID09PSAtMSksXG4gICAgICAgICAgICAgICAgdXBsb2FkOiB1cGxvYWRGaWxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkRmlsZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgICAgIGltcG9ydERhdGFzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmNvcmdpcy5vcGVuRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBweXRob246IHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGVNaXJyb3IgPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuY29kZU1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlTWlycm9yLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNvZGVNaXJyb3IuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1vZGU6IChuZXdNb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1WaWV3LkNoYW5nZVwiLCBcIlwiLCBcIlwiLCBuZXdNb2RlLCBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5weXRob25Nb2RlKG5ld01vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iub2xkUHl0aG9uTW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzSGlzdG9yeUF2YWlsYWJsZToga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpLFxuICAgICAgICAgICAgICAgICAgICB0dXJuT2ZmSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnNldFJlYWRPbmx5KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0dXJuT25IaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2FkSGlzdG9yeSgocmVzcG9uc2UpID0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5oaXN0b3J5LmxvYWQocmVzcG9uc2UuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9uSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVUb1N0YXJ0KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVByZXZpb3VzKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlTmV4dCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFJlY2VudDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVRvTW9zdFJlY2VudCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlOiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS51c2UoKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICAgICAgICBzYXZlOiAoKSA9PiBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnNhdmVBc3NpZ25tZW50KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNhbXBsZVN1Ym1pc3Npb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRWRpdG9yOiAobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRvciA9IHNlbGYuY29tcG9uZW50cy5lZGl0b3JzLmJ5TmFtZShcIlNhbXBsZSBTdWJtaXNzaW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5idWlsZEVkaXRvcihuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhlY3V0ZToge1xuICAgICAgICAgICAgICAgIGlzUnVubmluZzoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJ1bjogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKCksXG4gICAgICAgICAgICAgICAgZXZhbHVhdGU6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZXZhbHVhdGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHN0YXR1czogKGVuZHBvaW50ID0+XG4gICAgICAgICAgICAgICAgICAgIFwic2VydmVyLXN0YXR1cy1cIiArIG1vZGVsLnN0YXR1c1tlbmRwb2ludF0oKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNFbmRwb2ludENvbm5lY3RlZDogKGVuZHBvaW50KSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24udXJscyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tlbmRwb2ludF0gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIGNhcGl0YWxpemUobW9kZWwuc3RhdHVzLmxvYWRBc3NpZ25tZW50TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2FkSGlzdG9yeU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRGaWxlTWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2FkRGF0YXNldE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvZ0V2ZW50TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUltYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy51cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMudXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2UoKSB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZm9yY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgZmlsZUhhbmRsZXIgPSAkKFwiLmJsb2NrcHktZm9yY2UtbG9hZC1hc3NpZ25tZW50LWZpbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlsZUhhbmRsZXIuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKS5mYWRlT3V0KDEwMCkuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB1c2VyIHRvIHVwbG9hZCBhIGZpbGUgY29udGFpbmluZyBhbiBhc3NpZ25tZW50IHN1Ym1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uWzBdLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50U3VibWlzc2lvbiA9IEpTT04ucGFyc2UoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRBc3NpZ25tZW50RGF0YV8oYXNzaWdubWVudFN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbi52YWwoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNlbGYubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMoc2VsZiwgbW9kZWwpO1xuICAgIH1cblxuICAgIHR1cm5PbkhhY2tzKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ET1wiKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9pbWFnZS5qc1wiXSA9IGltYWdlTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9tYXRwbG90bGliL3B5cGxvdC9fX2luaXRfXy5qc1wiXSA9IG1hdHBsb3RsaWJNb2R1bGUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseXMgdGhlIEtub2Nrb3V0SlMgYmluZGluZ3MgdG8gdGhlIG1vZGVsLCBpbnN0YW50aWF0aW5nIHRoZSB2YWx1ZXMgaW50byB0aGVcbiAgICAgKiBIVE1MLlxuICAgICAqL1xuICAgIGFwcGx5TW9kZWwoKSB7XG4gICAgICAgIGtvLmFwcGx5QmluZGluZ3ModGhpcy5tb2RlbCwgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lclswXSk7XG4gICAgfVxuXG4gICAgaW5pdFV0aWxpdGllcygpIHtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzO1xuICAgICAgICB0aGlzLnV0aWxpdGllcyA9IHtcbiAgICAgICAgICAgIG1hcmtkb3duOiAodGV4dCkgPT4gdGV4dCA/IEVhc3lNREUucHJvdG90eXBlLm1hcmtkb3duKHRleHQpIDogXCI8cD48L3A+XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbml0Q29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXI7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIGxldCBtYWluID0gdGhpcztcbiAgICAgICAgLy8gRWFjaCBvZiB0aGVzZSBjb21wb25lbnRzIHdpbGwgdGFrZSB0aGUgQmxvY2tQeSBpbnN0YW5jZSwgYW5kIHBvc3NpYmx5IGFcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIHRoZSByZWxldmFudCBIVE1MIGxvY2F0aW9uIHdoZXJlIGl0IHdpbGwgYmUgZW1iZWRkZWQuXG4gICAgICAgIGNvbXBvbmVudHMuZGlhbG9nID0gbmV3IEJsb2NrUHlEaWFsb2cobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1kaWFsb2dcIikpO1xuICAgICAgICBjb21wb25lbnRzLmZlZWRiYWNrID0gbmV3IEJsb2NrUHlGZWVkYmFjayhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy50cmFjZSA9IG5ldyBCbG9ja1B5VHJhY2UobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29uc29sZSA9IG5ldyBCbG9ja1B5Q29uc29sZShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWNvbnNvbGVcIikpO1xuICAgICAgICBjb21wb25lbnRzLmVuZ2luZSA9IG5ldyBCbG9ja1B5RW5naW5lKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmZpbGVTeXN0ZW0gPSBuZXcgQmxvY2tQeUZpbGVTeXN0ZW0obWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuZWRpdG9ycyA9IG5ldyBFZGl0b3JzKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZWRpdG9yXCIpKTtcbiAgICAgICAgLy8gQ29udmVuaWVudCBzaG9ydGN1dCBkaXJlY3RseSB0byBQeXRob25FZGl0b3JcbiAgICAgICAgY29tcG9uZW50cy5weXRob25FZGl0b3IgPSB0aGlzLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJweXRob25cIik7XG4gICAgICAgIGNvbXBvbmVudHMuc2VydmVyID0gbmV3IEJsb2NrUHlTZXJ2ZXIobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29yZ2lzID0gbmV3IEJsb2NrUHlDb3JnaXMobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuaGlzdG9yeSA9IG5ldyBCbG9ja1B5SGlzdG9yeShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWhpc3RvcnktdG9vbGJhclwiKSk7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgfVxuXG4gICAgbWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1JbnN0cnVjdGlvbnMuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQsIFwiaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIHJlc2V0SW50ZXJmYWNlKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIC8vIERpc2FibGUgYW55IGFsdGVybmF0aXZlIGxvZ0VudHJ5IGZ1bmN0aW9ucyB3ZSBoYXZlIGJlZW4gZ2l2ZW5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5hbHRMb2dFbnRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVxdWVzdFBhc3Njb2RlKCkge1xuICAgICAgICBsZXQgdXNlclN1cHBsaWVkUGFzc2NvZGUgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIHBhc3Njb2RlLlwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LnBhc3Njb2RlKHVzZXJTdXBwbGllZFBhc3Njb2RlKTtcbiAgICB9XG5cbn1cblxuIiwiaW1wb3J0IHtlbmNvZGVIVE1MfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBFdmFsdWF0ZSBidXR0b24gSFRNTCB0ZW1wbGF0ZVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgU1RBUlRfRVZBTF9IVE1MID0gYFxuPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1vdXRsaW5lIGZsb2F0LXJpZ2h0IGJsb2NrcHktYnRuLWV2YWxcIj5cbiAgICBFdmFsdWF0ZVxuPC9idXR0b24+YDtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciBhIG5ldyBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgTkVXX0NPTlNPTEVfTElORV9IVE1MID0gXCI8ZGl2PjwvZGl2PlwiO1xuXG4vKipcbiAqIEhUTUwgdGVtcGxhdGUgZm9yIHRoZSBlbnRpcmUgY29uc29sZSBhcmVhXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ09OU09MRV9IVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9J2NvbC1tZC02IGJsb2NrcHktcGFuZWwgYmxvY2tweS1jb25zb2xlJ1xuICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiQ29uc29sZVwiXG4gICAgICAgICAgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLmNvbnNvbGUuc2l6ZVwiPlxuICAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0IGJsb2NrcHktc2hvdy1mZWVkYmFjaydcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNlY29uZFJvdy5pc0NvbnNvbGVTaG93VmlzaWJsZSwgY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICA8c3Ryb25nPkNvbnNvbGU6PC9zdHJvbmc+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LXByaW50ZXIgYmxvY2tweS1wcmludGVyLWRlZmF1bHQnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgIDwvZGl2PmA7XG5cbi8qKlxuICogQWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBmb3IgYSBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQGVudW1cbiAqL1xuZXhwb3J0IGxldCBDb25zb2xlTGluZVR5cGUgPSB7XG4gICAgVEVYVDogXCJ0ZXh0XCIsXG4gICAgSFRNTDogXCJodG1sXCIsXG4gICAgUExPVDogXCJwbG90XCIsXG4gICAgSU1BR0U6IFwiaW1hZ2VcIixcbiAgICBQWUdBTUU6IFwicHlnYW1lXCIsXG4gICAgVFVSVExFOiBcInR1cnRsZVwiLFxuICAgIEVWQUw6IFwiZXZhbFwiLFxuICAgIFNUQVJUX0VWQUw6IFwic3RhcnRfZXZhbFwiLFxuICAgIFZBTFVFOiBcInZhbHVlXCIsXG4gICAgSU5QVVQ6IFwiaW5wdXRcIixcbiAgICBURVNUX0NBU0U6IFwidGVzdF9jYXNlXCJcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgdmVyc2lvbiBvZiBhIGxpbmUgaW4gdGhlIGNvbnNvbGUuIEFsbCBvdGhlciBjb25zb2xlIGxpbmVzXG4gKiBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuIENyaXRpY2FsbHksIHRoZXkgbmVlZCB0byBpbXBsZW1lbnQgYSByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmNsYXNzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgYmFjayB0byB0aGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlLlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge0Jsb2NrUHl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F0ZWdvcml6ZXMgd2hhdCBraW5kIG9mIGxpbmUgdGhpcyBpcyAodGV4dC9odG1sL3Bsb3QvZXRjLilcbiAgICAgICAgICogQHR5cGUge0NvbnNvbGVMaW5lVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0dWFsIGRhdGEgc3RvcmVkIG9uIHRoaXMgbGluZS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRhZGF0YSBhYm91dCB3aGVyZSB0aGUgbGluZSBvcmlnaW5hdGVkIGZyb20gaW4gdGhlIGNvZGUuXG4gICAgICAgICAqIEB0eXBlIHt7ZmlsZW5hbWU6IHN0cmluZywgbGluZTogbnVtYmVyLCBzdGVwOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB7XG4gICAgICAgICAgICBmaWxlbmFtZTogU2suY3VyckZpbGVuYW1lLFxuICAgICAgICAgICAgc3RlcDogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCxcbiAgICAgICAgICAgIGxpbmU6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIGNvbnRlbnQgc3RvcmVkIG9uIHRoaXMgbGluZSwgbWVhbnQgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICogdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEB0eXBlIHsqfGpRdWVyeS5mbi5pbml0fGpRdWVyeXxIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHRtbCA9ICQoXCI8ZGl2PjwvZGl2PlwiLCB7XG4gICAgICAgICAgICBcImNsYXNzXCI6ICBcImJsb2NrcHktcHJpbnRlci1vdXRwdXRcIixcbiAgICAgICAgICAgIFwiZGF0YS1jb250YWluZXJcIjogbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludCxcbiAgICAgICAgICAgIFwiZGF0YS10b2dnbGVcIjogXCJ0b29sdGlwXCIsXG4gICAgICAgICAgICBcImRhdGEtcGxhY2VtZW50XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJkYXRhLXN0ZXBcIjogdGhpcy5vcmlnaW4uc3RlcCxcbiAgICAgICAgICAgIFwidGl0bGVcIjogXCJTdGVwIFwiICsgdGhpcy5vcmlnaW4uc3RlcCArIFwiLCBMaW5lIFwiICsgdGhpcy5vcmlnaW4ubGluZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGluZSBzaG91bGQgYmUgdmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9ICFtYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTa3VscHQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zb2xlIGxpbmUncyBjb250ZW50LlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHRvU2t1bHB0KCkge1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeSh0aGlzLmNvbnRlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnNvbGUgbGluZSBieSBkZWxldGluZyBpdHMgSFRNTCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuaHRtbC5yZW1vdmUoKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVHVydGxlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIC8vIFRPRE86IENhcHR1cmUgdHVydGxlIGNvbW1hbmRzIGZvciB0cmFjaW5nIHB1cnBvc2VzXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuVFVSVExFKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXR1cnRsZS1vdXRwdXRcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sWzBdLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6IFwic21vb3RoXCIgfSk7XG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5odG1sLnBvc2l0aW9uKCkudG9wO1xuICAgICAgICAgICAgLy8kKCdodG1sJykuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUHlnYW1lIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUFlHQU1FKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXB5Z2FtZS1vdXRwdXRcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW47XG4gICAgICAgIHRoaXMucHlnYW1lT2JqID0gcHlnYW1lT2JqO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgLy9Tay5tYWluX2NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDYW52YXNcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgd2hlcmUucHJlcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgICQoXCJodG1sXCIpLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIC8vIFN0YXJ0cyBvZmYgYXMgYSBuby1vcFxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCA9ICgpID0+IHt9O1xuICAgIH1cblxuICAgIGZpbmFsaXplKGNsZWFudXBGdW5jdGlvbiwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiBjbGVhbnVwRnVuY3Rpb24odGhpcy5weWdhbWVPYmosIGxpc3RlbmVycyk7XG4gICAgfVxuXG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW1hZ2UgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU1BR0UsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtaW1hZ2Utb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUGxvdCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5QTE9ULCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXBsb3Qtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVUZXh0IGV4dGVuZHMgQ29uc29sZUxpbmUge1xuXG4gICAgYWRkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudCArIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGlmICghZW5jb2RlZFRleHQgfHwgZW5jb2RlZFRleHQudHJpbSgpLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFRleHQgPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVWYWx1ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlZBTFVFLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IGVuY29kZWRUZXh0ID0gZW5jb2RlSFRNTCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxjb2RlPjwvY29kZT5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVJbnB1dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5JTlBVVCwgcHJvbXB0TWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBJbnB1dCBib3ggZm9yIHJlY2VpdmluZyBpbnB1dCgpIGZyb20gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFuaW5nXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIElucHV0IGZvcm1cbiAgICAgICAgICAgIGxldCBpbnB1dEZvcm0gPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIC8+XCIpO1xuICAgICAgICAgICAgLy8gRW50ZXIgYnV0dG9uXG4gICAgICAgICAgICBsZXQgaW5wdXRCdG4gPSAkKFwiPGJ1dHRvbj48L2J1dHRvbj5cIiwge1wiaHRtbFwiOiBcIkVudGVyXCJ9KTtcbiAgICAgICAgICAgIC8vIEdyb3VwIGZvcm0gYW5kIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0R3JvdXAgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1wiY2xhc3NcIjogXCJibG9ja3B5LWNvbnNvbGUtaW5wdXRcIn0pO1xuICAgICAgICAgICAgaW5wdXRHcm91cC5hcHBlbmQoaW5wdXRGb3JtKTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0QnRuKTtcbiAgICAgICAgICAgIC8vIFByb21wdCBib3gsIG5ldyBsaW5lLCBpbnB1dCBncm91cFxuICAgICAgICAgICAgbGV0IGlucHV0Qm94ID0gJChcIjxkaXY+PC9kaXY+XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudCAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRNc2cgPSAkKFwiPHNhbXA+PC9zYW1wPlwiLCAge1wiaHRtbFwiOiBlbmNvZGVkVGV4dH0pO1xuICAgICAgICAgICAgICAgIGlucHV0Qm94LmFwcGVuZChpbnB1dE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoJChcIjxicj5cIikpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChpbnB1dEdyb3VwKTtcbiAgICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChpbnB1dEJveCk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgaW50ZXJhY3RpdmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VJbnRlcmFjdGl2ZShpbnB1dEZvcm0sIGlucHV0QnRuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgbWFrZUludGVyYWN0aXZlKGlucHV0LCBidXR0b24pIHtcbiAgICAgICAgbGV0IHJlc29sdmVPbkNsaWNrO1xuICAgICAgICBsZXQgc3VibWl0dGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICBsZXQgc3VibWl0Rm9ybSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB1c2VySW5wdXR0ZWRWYWx1ZSA9IGlucHV0LnZhbCgpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5wdXNoKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHJlc29sdmVPbkNsaWNrKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIGlucHV0LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1dHRvbi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9O1xuICAgICAgICBidXR0b24uY2xpY2soc3VibWl0Rm9ybSk7XG4gICAgICAgIGlucHV0LmtleXVwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgIHN1Ym1pdEZvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGlmIChpbnB1dEluZGV4IDwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHVzZXJJbnB1dHRlZFZhbHVlID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgaW5wdXQudmFsKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleChpbnB1dEluZGV4KzEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5wdXQucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJtaXR0ZWRQcm9taXNlO1xuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVFdmFsdWF0ZSBleHRlbmRzIENvbnNvbGVMaW5lSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgXCJFdmFsdWF0ZTpcIik7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuU1RBUlRfRVZBTCk7XG4gICAgICAgIHRoaXMuaHRtbC5hcHBlbmQoJChTVEFSVF9FVkFMX0hUTUwpKTtcbiAgICAgICAgdGhpcy5odG1sLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5leGVjdXRlLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tQeUNvbnNvbGUge1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGZvciBtYW5hZ2luZyB0aGUgY29uc29sZSwgd2l0aCBmZWF0dXJlcyBmb3IgdGhpbmdzIGxpa2UgcHJpbnRpbmcsIHBsb3R0aW5nLCBldmFsaW5nLCBpbnB1dGluZy5cbiAgICAgKiBUaGUgXCJwcmludGVyXCIgaXMgdGhlIHJlZ2lvbiB3aGVyZSB3ZSBwdXQgdGhpbmdzLCBhcyBvcHBvc2VkIHRvIHRoZSBjb25zb2xlIGFzIGEgd2hvbGUuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcgPSB0YWcuZmluZChcIi5ibG9ja3B5LXByaW50ZXJcIik7XG5cbiAgICAgICAgdGhpcy5NSU5JTVVNX1dJRFRIID0gMjAwO1xuICAgICAgICB0aGlzLk1JTklNVU1fSEVJR0hUID0gMjAwO1xuICAgICAgICB0aGlzLkRFRkFVTFRfSEVJR0hUID0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpOyAvLyBMZXQgQ1NTIGRlZmluZSB0aGlzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLkRFRkFVTFRfSEVJR0hUKTtcblxuICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ub3V0cHV0O1xuICAgICAgICAvL3RoaXMuaW5wdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAvLyBUT0RPOiBJZiB0aGUgdXNlciBtb2RpZmllcyBhIGZpbGUsIHRoZW4gbWFrZSB0aGUgY29uc29sZSBsb29rIGZhZGVkIGEgbGl0dGxlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBzdGF0dXMgb2YgdGhlIHByaW50ZXIsIGluY2x1ZGluZyByZW1vdmluZyBhbnkgdGV4dCBpbiBpdCBhbmRcbiAgICAgKiBmaXhpbmcgaXRzIHNpemUuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LnJlbW92ZUFsbCgpO1xuXG4gICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMucGxvdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZy5lbXB0eSgpO1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCB3ZSdsbCByZXNldCBpdFxuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KCkgPT09IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSkge1xuICAgICAgICAgICAgdGhpcy5wcmludGVyVGFnLmhlaWdodCh0aGlzLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50dXJ0bGVMaW5lID0gbnVsbDtcbiAgICAgICAgU2suVHVydGxlR3JhcGhpY3MgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0VHVydGxlTGluZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgIGFzc2V0czogdGhpcy5sb2FkQXNzZXQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucHlnYW1lTGluZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGxvYWRBc3NldChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGdldFR1cnRsZUxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR1cnRsZUxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudHVydGxlTGluZSA9IG5ldyBDb25zb2xlTGluZVR1cnRsZSh0aGlzLm1haW4pO1xuICAgICAgICAgICAgdGhpcy50dXJ0bGVMaW5lLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgd2UnbGwgZG8gc29cbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQcmludGVyRGltZW5zaW9uID0gdGhpcy5wcmludGVyVGFnLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludGVyVGFnLmhlaWdodChjdXJyZW50UHJpbnRlckRpbWVuc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgU2suVHVydGxlR3JhcGhpY3MuaGVpZ2h0ID0gY3VycmVudFByaW50ZXJEaW1lbnNpb24tNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHVydGxlTGluZS5odG1sWzBdO1xuICAgIH1cblxuICAgIGZpbmlzaFR1cnRsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zYXZlVHVydGxlT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR1cnRsZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50dXJ0bGVMaW5lLmh0bWwuZmluZChcImNhbnZhc1wiKS5sYXN0KClbMF07XG4gICAgICAgICAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUltYWdlKFwidHVydGxlX291dHB1dFwiLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGVyZSBhcmUgbm8gdHVydGxlcyB0byBzYXZlP1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdHVydGxlcyBzaG91bGQgYmUgYmFzZWQgb24gdGhlIGN1cnJlbnQgd2lkdGhcbiAgICBuZXdUdXJ0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5NSU5JTVVNX1dJRFRILCB0aGlzLnByaW50ZXJUYWcud2lkdGgoKS00MCk7XG4gICAgfVxuXG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5NSU5JTVVNX0hFSUdIVCwgdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKzQwKTtcbiAgICB9XG5cbiAgICBpc011dGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGVhY2ggcHJpbnRlZCBlbGVtZW50IGluIHRoZSBwcmludGVyIGFuZCBtYWtlcyBpdCBoaWRkZW5cbiAgICAgKiBvciB2aXNpYmxlLCBkZXBlbmRpbmcgb24gd2hhdCBzdGVwIHdlJ3JlIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgLSBUaGUgY3VycmVudCBzdGVwIG9mIHRoZSBleGVjdXRlZCBwcm9ncmFtIHRoYXQgd2UncmUgb247IGVhY2ggZWxlbWVudCBpbiB0aGUgcHJpbnRlciBtdXN0IGJlIG1hcmtlZCB3aXRoIGEgXCJkYXRhLXN0ZXBcIiBwcm9wZXJ0eSB0byByZXNvbHZlIHRoaXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgLSBEZXByZWNhdGVkLCBub3Qgc3VyZSB3aGF0IHRoaXMgZXZlbiBkb2VzLlxuICAgICAqL1xuICAgIHN0ZXBQcmludGVyKHN0ZXAsIHBhZ2UpIHtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmZpbmQoXCIuYmxvY2tweS1wcmludGVyLW91dHB1dFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuYXR0cihcImRhdGEtc3RlcFwiKSA8PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodGhpcykuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpbnQgYSBsaW5lIHRvIHRoZSBvbi1zY3JlZW4gcHJpbnRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVRleHQgLSBBIGxpbmUgb2YgdGV4dCB0byBiZSBwcmludGVkIG91dC5cbiAgICAgKi9cbiAgICBwcmludChsaW5lVGV4dCkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIG1lYW5zIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIHByaW50KFwiXCIsIGVuZD1cIlwiKVxuICAgICAgICBpZiAoIWxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChsaW5lVGV4dC5jaGFyQXQobGluZVRleHQubGVuZ3RoLTEpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBmbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwbGl0TGluZXMgPSBsaW5lVGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lVGV4dCh0aGlzLm1haW4sIENvbnNvbGVMaW5lVHlwZS5URVhULCBzcGxpdExpbmVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5hZGRDb250ZW50KHNwbGl0TGluZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MTsgaSA8IHNwbGl0TGluZXMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0aGlzLmxpbmVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lVGV4dCh0aGlzLm1haW4sIENvbnNvbGVMaW5lVHlwZS5URVhULCBzcGxpdExpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGhpcy5saW5lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBwbG90KHBsb3RzKSB7XG4gICAgICAgIHRoaXMucGxvdEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVBsb3QodGhpcy5tYWluLCBwbG90cyk7XG4gICAgICAgIHRoaXMucGxvdEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdEJ1ZmZlcjtcbiAgICB9XG5cbiAgICBweWdhbWUoc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKSB7XG4gICAgICAgIGlmICh0aGlzLnB5Z2FtZUxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHlnYW1lTGluZSA9IG5ldyBDb25zb2xlTGluZVB5Z2FtZSh0aGlzLm1haW4sIHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaik7XG4gICAgICAgICAgICB0aGlzLnB5Z2FtZUxpbmUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHlnYW1lTGluZTtcbiAgICB9XG5cbiAgICBwcmludFBJTEltYWdlKGltYWdlRGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRFU1RcIiwgaW1hZ2VEYXRhLmltYWdlKTtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUltYWdlKHRoaXMubWFpbiwgaW1hZ2VEYXRhLmltYWdlKTtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VCdWZmZXI7XG4gICAgfVxuXG4gICAgcHJpbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgcHJpbnRlZFZhbHVlID0gbmV3IENvbnNvbGVMaW5lVmFsdWUodGhpcy5tYWluLCB2YWx1ZSk7XG4gICAgICAgIHByaW50ZWRWYWx1ZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgcmV0dXJuIHByaW50ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZWdpc3RlcnMgYSBQcm9taXNlIGZyb20gdGhlIElucHV0IGJveFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9tcHRNZXNzYWdlIC0gTWVzc2FnZSB0byBkaXNwbGF5IHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICovXG4gICAgaW5wdXQocHJvbXB0TWVzc2FnZSkge1xuICAgICAgICB0aGlzLmlucHV0QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lSW5wdXQodGhpcy5tYWluLCBwcm9tcHRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgfTtcblxuXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVFdmFsdWF0ZSh0aGlzLm1haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9XG5cbiAgICBiZWdpbkV2YWwoKSB7XG4gICAgICAgIGxldCBzdGFydEV2YWx1YXRpb24gPSBuZXcgQ29uc29sZUxpbmVTdGFydEV2YWx1YXRlKHRoaXMubWFpbik7XG4gICAgICAgIHJldHVybiBzdGFydEV2YWx1YXRpb24ucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5jb25kaXRpb25hbGx5IHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSB3aW5kb3cuXG4gICAgICpcbiAgICAgKi9cbiAgICBzY3JvbGxUb0JvdHRvbSgpIHtcbiAgICAgICAgdGhpcy50YWcuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMudGFnLnByb3AoXCJzY3JvbGxIZWlnaHRcIikgLSB0aGlzLnRhZy5wcm9wKFwiY2xpZW50SGVpZ2h0XCIpXG4gICAgICAgIH0sIDUwMCk7XG4gICAgfTtcblxufSIsImltcG9ydCB7c2x1Z30gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5cbi8vIFRPRE86IGVkaXRvci5ibS5ibG9ja0VkaXRvci5leHRyYVRvb2xzW11cblxuZXhwb3J0IGxldCBfSU1QT1JURURfREFUQVNFVFMgPSB7fTtcbmV4cG9ydCBsZXQgX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTID0ge307XG5cbi8qKlxuICogVGhpcyBpcyBhIHZlcnkgc2ltcGxpc3RpYyBoZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIHRyYW5zZm9ybVxuICogYSBnaXZlbiBidXR0b24gaW50byBhIFwiTG9hZGVkXCIgc3RhdGUgKGRpc2FibGVkLCBwcmVzc2VkIHN0YXRlLCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBidG4gLSBBbiBIVE1MIGVsZW1lbnQgdG8gY2hhbmdlIHRoZSB0ZXh0IG9mLlxuICovXG5sZXQgc2V0QnV0dG9uTG9hZGVkID0gZnVuY3Rpb24gKGJ0bikge1xuICAgIGJ0bi5hZGRDbGFzcyhcImFjdGl2ZVwiKVxuICAgICAgICAuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidG4tcHJpbWFyeVwiKVxuICAgICAgICAucHJvcChcImRpc2FibGVkXCIsIHRydWUpXG4gICAgICAgIC50ZXh0KFwiTG9hZGVkXCIpXG4gICAgICAgIC5hdHRyKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKTtcbn07XG5cblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBjb25uZWN0cyB0byB0aGUgQ09SR0lTIGRhdGFzZXRzIGFuZCBtYW5hZ2VzIGludGVyYWN0aW9uc1xuICogd2l0aCB0aGVtLiBUaGlzIGluY2x1ZGVzIGxvYWRpbmcgaW4gZGF0YXNldHMgYXQgbGF1bmNoIGFuZCBvbi10aGUtZmx5LlxuICogTm90ZSB0aGF0IHRoaXMgaGFzIG5vIHByZXNlbmNlIG9uIHNjcmVlbiwgc28gaXQgZG9lcyBub3QgaGF2ZSBhIHRhZy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5Q29yZ2lzfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5Q29yZ2lzKG1haW4pIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuXG4gICAgdGhpcy5sb2FkZWREYXRhc2V0cyA9IFtdO1xuICAgIHRoaXMubG9hZERhdGFzZXRzKCk7XG59XG5cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLmxvYWREYXRhc2V0cyA9IGZ1bmN0aW9uIChzaWxlbnRseSkge1xuICAgIC8vIExvYWQgaW4gZWFjaCB0aGUgZGF0YXNldHNcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWwsXG4gICAgICAgIGVkaXRvciA9IHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvcixcbiAgICAgICAgc2VydmVyID0gdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyO1xuICAgIGxldCBpbXBvcnRzID0gW107XG4gICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0cygpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lICYmICEobmFtZSBpbiBCbG9ja01pcnJvckJsb2NrRWRpdG9yLkVYVFJBX1RPT0xTKSkge1xuICAgICAgICAgICAgaW1wb3J0cy5wdXNoLmFwcGx5KGltcG9ydHMsIHRoaXMuaW1wb3J0RGF0YXNldChzbHVnKG5hbWUpLCBuYW1lLCBzaWxlbnRseSkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGFyZSBsb2FkZWQsIHVwZGF0ZSB0aGUgdG9vbGJveC5cbiAgICAkLndoZW4uYXBwbHkoJCwgaW1wb3J0cykuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUUklHR0VSRURcIik7XG4gICAgICAgIGVkaXRvci5ibS5mb3JjZUJsb2NrUmVmcmVzaCgpO1xuICAgICAgICBlZGl0b3IuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9KS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXJ2ZXIuZmluYWxpemVTdWJzY3JpcHRpb25zKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIExvYWRzIHRoZSBkZWZpbml0aW9ucyBmb3IgYSBkYXRhc2V0IGludG8gdGhlIGVudmlyb25tZW50LCBpbmNsdWRpbmdcbiAqIHRoZSBkYXRhc2V0IChhcyBhIEpTIGZpbGUpLCB0aGUgc2t1bHB0IGJpbmRpbmdzLCBhbmQgdGhlIGJsb2NrbHlcbiAqIGJpbmRpbmdzLiBUaGlzIHJlcXVpcmVzIGFjY2VzcyB0byBhIENPUkdJUyBzZXJ2ZXIsIGFuZCBvY2N1cnNcbiAqIGFzeW5jaHJvbm91c2x5LiBUaGUgcmVxdWVzdHMgYXJlIGZpcmVkIGFuZCB0aGVpciBkZWZlcnJlZCBvYmplY3RzXG4gKiBhcmUgcmV0dXJuZWQgLSBjYWxsZXJzIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBwZXJmb3JtIGFuIGFjdGlvblxuICogb24gY29tcGxldGlvbiBvZiB0aGUgaW1wb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzbHVnIC0gVGhlIFVSTCBzYWZlIHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgdXNlci1mcmllbmRseSB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXkuPERlZmVycmVkPn0gLSBSZXR1cm5zIHRoZSBhc3luYyByZXF1ZXN0cyBhcyBkZWZlcnJlZCBvYmplY3RzLlxuICovXG5CbG9ja1B5Q29yZ2lzLnByb3RvdHlwZS5pbXBvcnREYXRhc2V0ID0gZnVuY3Rpb24gKHNsdWcsIG5hbWUpIHtcbiAgICBsZXQgdXJsX3JldHJpZXZhbHMgPSBbXTtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwiaW1wb3J0RGF0YXNldHNcIikpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzLmltcG9ydERhdGFzZXRzICsgXCJibG9ja3B5L1wiICsgc2x1ZyArIFwiL1wiICsgc2x1ZztcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubG9hZGluZ0RhdGFzZXRzLnB1c2gobmFtZSk7XG4gICAgICAgIC8vIEFjdHVhbGx5IGdldCBkYXRhXG4gICAgICAgIGxldCBnZXREYXRhc2V0ID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2RhdGFzZXQuanNcIik7XG4gICAgICAgIC8vIExvYWQgZ2V0Q29tcGxldGUgc2lsZW50bHkgaW4gdGhlIGJhY2tncm91bmQgYmVjYXVzZSBpdHMgYmlnIDooXG4gICAgICAgIGxldCBnZXRDb21wbGV0ZSA9ICQuZ2V0U2NyaXB0KHJvb3QgKyBcIl9jb21wbGV0ZS5qc1wiKTtcbiAgICAgICAgbGV0IGdldFNrdWxwdCA9ICQuZ2V0KHJvb3QgKyBcIl9za3VscHQuanNcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW1wic3JjL2xpYi9cIiArIHNsdWcgKyBcIi9fX2luaXRfXy5qc1wiXSA9IGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZ2V0QmxvY2tseSA9ICQuZ2V0U2NyaXB0KHJvb3QgKyBcIl9ibG9ja2x5LmpzXCIpO1xuICAgICAgICAvLyBPbiBjb21wbGV0aW9uLCB1cGRhdGUgbWVudXMuXG4gICAgICAgICQud2hlbihnZXREYXRhc2V0LCBnZXRTa3VscHQsIGdldEJsb2NrbHkpLmRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWREYXRhc2V0cy5wdXNoKHNsdWcpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRUb0Jsb2Nrcy5oaWRkZW5JbXBvcnRzLnB1c2goc2x1Zyk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uZm9yY2VCbG9ja1JlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5sb2FkaW5nRGF0YXNldHMucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdXJsX3JldHJpZXZhbHMucHVzaChnZXREYXRhc2V0LCBnZXRTa3VscHQsIGdldEJsb2NrbHkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsX3JldHJpZXZhbHM7XG59O1xuXG4vKipcbiAqIE9wZW5zIGEgZGlhbG9nIGJveCB0byBwcmVzZW50IHRoZSB1c2VyIHdpdGggdGhlIGRhdGFzZXRzIGF2YWlsYWJsZVxuICogdGhyb3VnaCB0aGUgQ09SR0lTIHNlcnZlci4gVGhpcyByZXF1aXJlcyBhIGNhbGwsIHNvIHRoaXMgbWV0aG9kXG4gKiBjb21wbGV0ZXMgYXN5bmNocm9ub3VzbHkuIFRoZSBkaWFsb2cgaXMgY29tcG9zZWQgb2YgYSB0YWJsZSB3aXRoXG4gKiBidXR0b25zIHRvIGxvYWQgdGhlIGRhdGFzZXRzIChNb3JlIHRoYW4gb25lIGRhdGFzZXQgY2FuIGJlIGxvYWRlZFxuICogZnJvbSB3aXRoaW4gdGhlIGRpYWxvZyBhdCBhIHRpbWUpLlxuICovXG5CbG9ja1B5Q29yZ2lzLnByb3RvdHlwZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJpbXBvcnREYXRhc2V0c1wiKSkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW1wb3J0RGF0YXNldHM7XG4gICAgICAgICQuZ2V0SlNPTihyb290ICsgXCJpbmRleC5qc29uXCIsICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSB1cCB0aGUgQm9keVxuICAgICAgICAgICAgbGV0IGRhdGFzZXRzID0gZGF0YS5ibG9ja3B5O1xuICAgICAgICAgICAgbGV0IGRvY3VtZW50YXRpb24gPSByb290K1wiYmxvY2tweS9pbmRleC5odG1sXCI7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAkKGA8cD5Eb2N1bWVudGF0aW9uIGlzIGF2YWlsYWJsZSBhdCA8YSBocmVmPScke2RvY3VtZW50YXRpb259JyB0YXJnZXQ9X2JsYW5rPnVybDwvYT48L3A+YCk7XG4gICAgICAgICAgICBsZXQgYm9keSA9ICQoXCI8dGFibGU+PC90YWJsZT5cIiwge1wiY2xhc3NcIjogXCJ0YWJsZSB0YWJsZS1ib3JkZXJlZCB0YWJsZS1zbSB0YWJsZS1zdHJpcGVkXCJ9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGFzZXRzKS5zb3J0KCkubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNsdWdnZWROYW1lID0gc2x1ZyhkYXRhc2V0c1tuYW1lXS5uYW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGVOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgYnRuID0gJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvblwiIGFyaWEtcHJlc3NlZD1cImZhbHNlXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCI+TG9hZDwvYnV0dG9uPicpO1xuICAgICAgICAgICAgICAgIGxldCBpbWdTcmMgPSByb290K1wiLi4vaW1hZ2VzL2RhdGFzZXRzL1wiK25hbWUrXCItaWNvbi5wbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2FkZWREYXRhc2V0cy5pbmRleE9mKHNsdWdnZWROYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEJ1dHRvbkxvYWRlZChidG4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ0bi5jbGljayggKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnREYXRhc2V0KHNsdWdnZWROYW1lLCBcIkRhdGEgLSBcIiArIGRhdGFzZXRzW25hbWVdLnRpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ1dHRvbkxvYWRlZChidG4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9sZXQgaW1nID0gYDxpbWcgc3JjPScke2ltZ1NyY30nIGNsYXNzPVwiY29yZ2lzLWljb25cIj5gO1xuICAgICAgICAgICAgICAgICQoXCI8dHI+PC90cj5cIilcbiAgICAgICAgICAgICAgICAgICAgLy8uYXBwZW5kKCQoXCI8dGQ+XCIgKyBpbWcgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+XCIgKyBkYXRhc2V0c1tuYW1lXS50aXRsZSArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD5cIiArIGRhdGFzZXRzW25hbWVdLm92ZXJ2aWV3ICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPjwvdGQ+XCIpLmFwcGVuZChidG4pKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oYm9keSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kVG8oc3RhcnQpO1xuICAgICAgICAgICAgLy8gU2hvdyB0aGUgYWN0dWFsIGRpYWxvZ1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLnNob3coXCJJbXBvcnQgRGF0YXNldHNcIiwgc3RhcnQsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNjMzOTc5OTMzNDExXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL2FjYmFydC9Qcm9qZWN0cy9ibG9ja3B5LWVkdS9ibG9ja3B5L25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi4uL1wiLFwiaG1yXCI6dHJ1ZSxcImxvY2Fsc1wiOmZhbHNlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIG1vZHVsZS5ob3QuYWNjZXB0KHVuZGVmaW5lZCwgY3NzUmVsb2FkKTtcbiAgICB9XG4gICIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE2MzM5Nzk5MzM0MDRcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvYWNiYXJ0L1Byb2plY3RzL2Jsb2NrcHktZWR1L2Jsb2NrcHkvbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiLi4vXCIsXCJobXJcIjp0cnVlLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gVE9ETzogRHlhbm1pY2FsbHkgcG9wdWxhdGUgYXJpYS1sYWJlbGxlZGJ5IGluIHRoaXMgYW5kIG90aGVyIHBsYWNlc1xuXG5leHBvcnQgbGV0IERJQUxPR19IVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktZGlhbG9nIG1vZGFsIGhpZGRlbidcbiAgICAgICAgIHJvbGU9XCJkaWFsb2dcIlxuICAgICAgICAgYXJpYS1sYWJlbD0nRGlhbG9nJ1xuICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgIGFyaWEtbW9kYWw9XCJ0cnVlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWRpYWxvZyBtb2RhbC1sZycgcm9sZT1cImRvY3VtZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1jb250ZW50JyByb2xlPSdyZWdpb24nIGFyaWEtbGFiZWw9J0RpYWxvZyBjb250ZW50Jz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1oZWFkZXInPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9J21vZGFsLXRpdGxlJz5EeW5hbWljIENvbnRlbnQ8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2Nsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJyBhcmlhLWhpZGRlbj0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5JyBzdHlsZT0nbWF4LXdpZHRoOjEwMCU7IG1heC1oZWlnaHQ6NDAwcHgnPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSBtb2RhbC1jbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+Q2xvc2U8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXN1Y2Nlc3MgbW9kYWwtb2theScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+T2theTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbmA7XG5cbi8qKlxuICogQSB1dGlsaXR5IG9iamVjdCBmb3IgcXVpY2tseSBhbmQgY29udmVuaWVudGx5IGdlbmVyYXRpbmcgZGlhbG9nIGJveGVzLlxuICogVW5mb3J0dW5hdGVseSwgdGhpcyBkb2Vzbid0IGR5bmFtaWNhbGx5IGNyZWF0ZSBuZXcgYm94ZXM7IGl0IHJldXNlcyB0aGUgc2FtZSBvbmVcbiAqIG92ZXIgYW5kIG92ZXIgYWdhaW4uIEl0IHR1cm5zIG91dCBkeW5hbWljYWxseSBnZW5lcmF0aW5nIG5ldyBkaWFsb2cgYm94ZXNcbiAqIGlzIGEgcGFpbiEgU28gd2UgY2FuJ3Qgc3RhY2sgdGhlbS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5RGlhbG9nfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlEaWFsb2cobWFpbiwgdGFnKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgIHRoaXMudGl0bGVUYWcgPSB0YWcuZmluZChcIi5tb2RhbC10aXRsZVwiKTtcbiAgICB0aGlzLmJvZHlUYWcgPSB0YWcuZmluZChcIi5tb2RhbC1ib2R5XCIpO1xuICAgIHRoaXMuZm9vdGVyVGFnID0gdGFnLmZpbmQoXCIubW9kYWwtZm9vdGVyXCIpO1xuICAgIHRoaXMub2theUJ1dHRvbiA9IHRhZy5maW5kKFwiLm1vZGFsLW9rYXlcIik7XG4gICAgdGhpcy5jbG9zZUJ1dHRvbiA9IHRhZy5maW5kKFwiLm1vZGFsLWNsb3NlXCIpO1xuXG4gICAgdGhpcy55ZXMgPSAoKSA9PiB7fTtcbiAgICB0aGlzLm5vID0gKCkgPT4ge307XG4gICAgdGhpcy5va2F5QnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy55ZXMoKTtcbiAgICAgICAgdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xvc2VCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLm5vKCk7XG4gICAgICAgIC8vdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xuICAgIH0pO1xufVxuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGV4dGVybmFsbHkgYXZhaWxhYmxlIGZ1bmN0aW9uIGZvciBwb3BwaW5nIHVwIGEgZGlhbG9nXG4gKiBtZXNzYWdlLiBUaGlzIG1lbnUgd2lsbCBiZSBkcmFnZ2FibGUgYnkgaXRzIHRpdGxlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbWVzc2FnZSBkaWFsb2cuIENhbiBoYXZlIEhUTUwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBtZXNzYWdlIGRpYWxvZy4gQ2FuIGhhdmUgSFRNTC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uY2xvc2UgLSBBIGZ1bmN0aW9uIHRvIGJlIHJ1biB3aGVuIHRoZSB1c2VyIGNsb3NlcyB0aGUgZGlhbG9nLlxuICovXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHRpdGxlLCBib2R5LCBvbmNsb3NlKSB7XG4gICAgdGhpcy50aXRsZVRhZy5odG1sKHRpdGxlKTtcbiAgICB0aGlzLmJvZHlUYWcuaHRtbChib2R5KTtcbiAgICB0aGlzLnRhZy5tb2RhbChcInNob3dcIik7XG4gICAgdGhpcy5va2F5QnV0dG9uLmhpZGUoKTtcbiAgICB0aGlzLnRhZy5kcmFnZ2FibGUoe1xuICAgICAgICBcImhhbmRsZVwiOiBcIi5tb2RhbC10aXRsZVwiXG4gICAgfSk7XG5cbiAgICB0aGlzLnRhZy5vbihcImhpZGRlbi5icy5tb2RhbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAob25jbG9zZSAhPT0gdW5kZWZpbmVkICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uICh0aXRsZSwgYm9keSwgeWVzLCBubywgeWVzVGV4dCkge1xuICAgIGlmICh5ZXNUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWVzVGV4dCA9IFwiT2theVwiO1xuICAgIH1cbiAgICB0aGlzLnNob3codGl0bGUsIGJvZHksIG5vKTtcbiAgICB0aGlzLnllcyA9IHllcztcbiAgICB0aGlzLm5vID0gbm87XG4gICAgdGhpcy5va2F5QnV0dG9uLnNob3coKS5odG1sKHllc1RleHQpO1xuICAgIC8vIFRPRE86IGFkZCBva2F5IGJ1dHRvbiBhbmQgY2FuY2VsIGJ1dHRvblxufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuQVNTSUdOTUVOVF9WRVJTSU9OX0NIQU5HRUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25maXJtKFwiQXNzaWdubWVudCBDaGFuZ2VkXCIsIFwiWW91ciBpbnN0cnVjdG9yIGhhcyBtYWRlIGNoYW5nZXMgdG8gdGhpcyBhc3NpZ25tZW50LiBXb3VsZCB5b3UgbGlrZSB0byByZWxvYWQ/IEFsbCB5b3VyIHdvcmsgaGFzIGJlZW4gc2F2ZWQuXCIsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgTG9hZGluZyBBc3NpZ25tZW50XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIGFzc2lnbm1lbnQuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfU0FWSU5HX0FTU0lHTk1ORU5UID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFNhdmluZyBBc3NpZ25tZW50XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHNhdmluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9TSE9XX1NUVURFTlRfRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLnNob3coXCJPcmlnaW5hbCBFcnJvclwiLCBgV2hlbiBJIHJhbiB5b3VyIGNvZGUsIEkgZW5jb3VudGVyZWQgYW4gZXJyb3I6XFxuXFxuPGRpdiBjbGFzcz1cImJsb2NrcHktZGlhbG9nLXN0dWRlbnQtZXJyb3ItbWVzc2FnZVwiPiR7ZXJyb3J9PC9kaXY+YCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5QT1NJVElWRV9GRUVEQkFDS19GVUxMID0gZnVuY3Rpb24gKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KHRpdGxlLCBtZXNzYWdlKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLlNDUkVFTlNIT1RfQkxPQ0tTID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE9cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFVwZGF0aW5nIFN1Ym1pc3Npb24gU3RhdHVzXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIHlvdXIgc3VibWlzc2lvbiBzdGF0dXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19ISVNUT1JZID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgSGlzdG9yeVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHlvdXIgaGlzdG9yeS48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5PRkZFUl9GT1JLID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzZXR1cFVybCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwO1xuICAgIHNldHVwVXJsID0gc2V0dXBVcmwgPyBgICg8YSBocmVmPVwiJHtzZXR1cFVybH1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5Ib3cgZG8gSSBkbyB0aGF0PzwvYT4pYCA6IFwiXCI7XG4gICAgdGhpcy5zaG93KFwiQXNzaWdubWVudCBOb3QgT3duZWQ7IEZvcms/XCIsIGBcbiAgICA8ZGl2IGNsYXNzPVwibWItNFwiPlxuICAgICAgICBJdCBsb29rcyBsaWtlIHlvdSB3YW50IHRvIGVkaXQgdGhpcyBhc3NpZ25tZW50LCBidXQgeW91IGFyZSBub3QgYW4gaW5zdHJ1Y3RvclxuICAgIG9yIGRlc2lnbmVyIGluIHRoZSBjb3Vyc2UgdGhhdCBvd25zIGl0IChcIkNvdXJzZSBOYW1lXCIpLiBXb3VsZCB5b3UgbGlrZSB0byBmb3JrXG4gICAgdGhpcyBhc3NpZ25tZW50IChvciBpdHMgZW50aXJlIGdyb3VwKSBzbyB0aGF0IHlvdSBjYW4gc2F2ZSB5b3VyIG1vZGlmaWNhdGlvbnM/XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgUmVtZW1iZXIgdG8gdXBkYXRlIHRoZSBMYXVuY2ggVVJMIGluIHRoZSBhc3NpZ25tZW50cycgc2V0dGluZ3Mgb24gQ2FudmFzISR7c2V0dXBVcmx9XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUnPkZvcmsgZW50aXJlIGFzc2lnbm1lbnQgZ3JvdXA8L2J1dHRvbj48L2Rpdj5cbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSc+Rm9yayBqdXN0IHRoaXMgYXNzaWdubWVudDwvYnV0dG9uPjwvZGl2PlxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLWRhbmdlcic+UmVzZXQgbXkgbG9jYWwgY2hhbmdlczwvYnV0dG9uPjwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICAgICAgICAgIG5hbWU9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+VHJhbnNmZXIgU3R1ZGVudCBTdWJtaXNzaW9ucyBmb3IgdGhpcyBjb3Vyc2U8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgPGxhYmVsIGNsYXNzPVwiZm9ybS10ZXh0XCIgZm9yPVwiYmxvY2tweS1jb3Vyc2UtaWRcIj5OZXcgb3duaW5nIGNvdXJzZSBpZDogPC9sYWJlbD5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImJsb2NrcHktY291cnNlLWlkXCIgdmFsdWU9XCIke3RoaXMubWFpbi5tb2RlbC51c2VyLmNvdXJzZUlkKCl9XCI+XG4gICAgPC9kaXY+XG4gICAgYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FRElUX0lOUFVUUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgaW5wdXRUZXh0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIik7XG4gICAgbGV0IGNsZWFySW5wdXRzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoKSA/IFwiXCIgOiBcImNoZWNrZWRcIjtcbiAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hlY2tlZCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIikucHJvcChcImNoZWNrZWRcIik7XG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktaW5wdXQtbGlzdFwiKS52YWwoKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoIWNoZWNrZWQpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KGlucHV0cyk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpcm0oXCJFZGl0IFJlbWVtYmVyZWQgSW5wdXRzXCIsIGBcblxuPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzIGZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICBuYW1lPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIiAke2NsZWFySW5wdXRzfT5cbjxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiPlJldXNlIGlucHV0cyBmb3IgbmV4dCBleGVjdXRpb248L2xhYmVsPlxuPC9kaXY+XG5cbjx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktaW5wdXQtbGlzdCBmb3JtLWNvbnRyb2xcIiByb3dzPVwiNFwiPiR7aW5wdXRUZXh0fTwvdGV4dGFyZWE+PGJyPlxuRWRpdCB0aGUgaW5wdXRzIGFib3ZlIHRvIHN0b3JlIGFuZCByZXVzZSB0aGVtIGFjcm9zcyBtdWx0aXBsZSBleGVjdXRpb25zLlxuRWFjaCBpbnB1dCBzaG91bGQgYmUgcHV0IG9uIGl0cyBvd24gbGluZS5cbllvdSBkbyBub3QgbmVlZCBxdW90ZXM7IHRoZSB0ZXh0IHdpbGwgYmUgZW50ZXJlZCBsaXRlcmFsbHkuXG4gXG5gLCB5ZXMsIHRoaXMubm8sIFwiU2F2ZVwiKTtcbiAgICAvLyBUT0RPOiBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgdGhlIGluZmluaXRlIHN0cmluZyB0byBrZWVwIGdpdmluZyB3aGVuIHRoZSBvdGhlcnMgcnVuIG91dFxufTsiLCJpbXBvcnQge0VkaXRvcnN9IGZyb20gXCIuLi9lZGl0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRGaWxlKG1vZGVsLCBldmVudCkge1xuICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoZSA9PlxuICAgICAgICBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS51cGxvYWRGaWxlKGUpXG4gICAgKTtcbiAgICBmaWxlUmVhZGVyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbHVnZ2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQge25hbWUsIGV4dGVuc2lvbiwgY29udGVudHMsIG1pbWV0eXBlfSA9IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpLmRvd25sb2FkRmlsZSgpO1xuICAgIC8vIE1ha2Ugc2FmZVxuICAgIG5hbWUgPSBzbHVnZ2lmeShuYW1lKTtcbiAgICBuYW1lID0gbmFtZSArIGV4dGVuc2lvbjtcbiAgICAvLyBNYWtlIHRoZSBkYXRhIGRvd25sb2FkIGFzIGEgZmlsZVxuICAgIGxldCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRzXSwge3R5cGU6IG1pbWV0eXBlfSk7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgfSBlbHNle1xuICAgICAgICBsZXQgdGVtcG9yYXJ5RG93bmxvYWRMaW5rID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuZG93bmxvYWQgPSBuYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0gPSBtYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcihcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICBvbkZpbGVEZWxldGVkKCkge1xuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIGZpbGUgaW5zdGVhZCBvZiBhIGRlZmF1bHQgZmlsZVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlVXBkYXRlZChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSB0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcih0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2tDdXJyZW50RmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLndhdGNoRmlsZSh0aGlzLmZpbGVuYW1lLCB7XG4gICAgICAgICAgICB1cGRhdGVkOiB0aGlzLm9uRmlsZVVwZGF0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRoaXMub25GaWxlRGVsZXRlZC5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG5ld0ZpbGVuYW1lO1xuICAgICAgICB0aGlzLmZpbGUgPSB0aGlzLmZpbGVTeXN0ZW0uZ2V0RmlsZShuZXdGaWxlbmFtZSk7XG4gICAgICAgIHRoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0ZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIHRoYXQgdGhlIG90aGVyIGVkaXRvciB3aWxsIGJlIHN3aXRjaGluZyB0b1xuICAgICAqIEBwYXJhbSBvbGRFZGl0b3JcbiAgICAgKiBAcGFyYW0gbmV3RWRpdG9yXG4gICAgICovXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZXZlbnQudGFyZ2V0LmZpbGVOYW1lO1xuICAgICAgICBsZXQgY29udGVudHMgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZEZpbGUoKSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLm5hbWUsXG4gICAgICAgICAgICBleHRlbnNpb246IGZpbGVuYW1lLnR5cGUsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5maWxlLmhhbmRsZSgpLFxuICAgICAgICAgICAgbWltZXR5cGU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH07XG4gICAgfVxufSIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCIuL3B5dGhvblwiO1xuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTID0gW1xuICAgIFtcInRvb2xib3hcIiwgXCJ0b29sYm94XCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIldoaWNoIHZlcnNpb24gb2YgdGhlIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlci5cIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVcIiwgXCJibG9ja3B5XCIsIFwidHlwZVwiLCBcIlRoZSB0eXBlIG9mIHF1ZXN0aW9uOyBCbG9ja1B5IHByb2dyYW1taW5nIHByb2JsZW1zIGFyZSB0aGUgZGVmYXVsdCwgYnV0IHdlIGFsc28gc3VwcG9ydCBzdGF0aWMgcmVhZGluZ3MsIHF1aXogcXVlc3Rpb25zLCBhbmQgYSBNYXplIGdhbWUuXCJdLFxuICAgIFtcInBhc3Njb2RlXCIsIFwicGFzc2NvZGVcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJBIHN0cmluZyB0aGF0IHRoZSB1c2VyIG11c3QgZW50ZXIgdG8gYWNjZXNzIHRoZSBwcm9ibGVtLiBJZiBibGFuaywgdGhlbiBubyBwYXNzY29kZSBpcyBwcm9tcHRlZC5cIl0sXG4gICAgLy9bXCJ0b29sYm94TGV2ZWxcIiwgXCJ0b29sYm94X2xldmVsXCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIklOQ09NUExFVEU6IFdoYXQgbGV2ZWwgb2YgdG9vbGJveCB0byBwcmVzZW50IHRvIHRoZSB1c2VyIChoaWRpbmcgYW5kIHNob3dpbmcgY2F0ZWdvcmllcykuXCJdLFxuICAgIFtcInN0YXJ0Vmlld1wiLCBcInN0YXJ0X3ZpZXdcIiwgRGlzcGxheU1vZGVzLlNQTElULCBEaXNwbGF5TW9kZXMsIFwiVGhlIFB5dGhvbiBlZGl0b3IgbW9kZSB0byBzdGFydCBpbiB3aGVuIHRoZSBzdHVkZW50IHN0YXJ0cyB0aGUgcHJvYmxlbS5cIl0sXG4gICAgW1wiZGF0YXNldHNcIiwgXCJkYXRhc2V0c1wiLCBcIlwiLCBcInN0cmluZ1wiLCBcIlRoZSBjdXJyZW50IGxpc3Qgb2YgZGF0YXNldHMgYXZhaWxhYmxlIG9uIGxvYWQgYXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nLlwiXSxcbiAgICBbXCJkaXNhYmxlVGltZW91dFwiLCBcImRpc2FibGVfdGltZW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyBjb2RlIGlzIGFsbG93ZWQgdG8gcnVuIHdpdGhvdXQgdGltZW91dHMgKHBvdGVudGlhbGx5IGFsbG93aW5nIGluZmluaXRlIGxvb3BzKS5cIl0sXG4gICAgW1wiaXNQYXJzb25zXCIsIFwiaXNfcGFyc29uc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGlzIGlzIGEgcGFyc29uJ3Mgc3R5bGUgcXVlc3Rpb24gKGp1bWJsZWQpLlwiXSxcbiAgICBbXCJkaXNhYmxlRmVlZGJhY2tcIiwgXCJkaXNhYmxlX2ZlZWRiYWNrXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIG5vIGluc3RydWN0b3Igc2NyaXB0cyBhcmUgcnVuIChlLmcuLCBvbl9ydW4gYW5kIG9uX2V2YWwpLlwiXSxcbiAgICBbXCJkaXNhYmxlSW5zdHJ1Y3RvclJ1blwiLCBcImRpc2FibGVfaW5zdHJ1Y3Rvcl9ydW5cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGluc3RydWN0b3Igb25fcnVuIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcnVuIHRoZSBzdHVkZW50cycgY29kZS4gVGhpcyBzdGlsbCBydW5zIHRoZSBzdHVkZW50cycgY29kZSBvbmNlIGJlZm9yZWhhbmQsIGJ1dCB0aGUgb3V0cHV0L2RhdGEgd2lsbCBub3QgYmUgYXZhaWxhYmxlIHRvIHRoZSBpbnN0cnVjdG9yJ3Mgb25fcnVuLnB5IHNjcmlwdC5cIl0sXG4gICAgW1wiZGlzYWJsZVN0dWRlbnRSdW5cIiwgXCJkaXNhYmxlX3N0dWRlbnRfcnVuXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBydW4gYnV0dG9uIG5vIGxvbmdlciBydW4gdGhlIHN0dWRlbnRzJyBjb2RlLiBUaGlzIHN0aWxsIHJ1bnMgdGhlIGluc3RydWN0b3IncyBmZWVkYmFjayBvbl9ydW4gc2NyaXB0LlwiXSxcbiAgICBbXCJkaXNhYmxlVGlmYVwiLCBcImRpc2FibGVfdGlmYVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBkbyBub3QgYXV0b21hdGljYWxseSBydW4gVGlmYSAod2hpY2ggY2FuIGJlIHNsb3cpLlwiXSxcbiAgICBbXCJkaXNhYmxlVHJhY2VcIiwgXCJkaXNhYmxlX3RyYWNlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cyBjb2RlIHdpbGwgbm90IGhhdmUgaXRzIGV4ZWN1dGlvbiB0cmFjZWQgKG5vIHZhcmlhYmxlcyByZWNvcmRlZCwgbm8gY292ZXJhZ2UgdHJhY2tlZCkuXCJdLFxuICAgIFtcImRpc2FibGVFZGl0XCIsIFwiZGlzYWJsZV9lZGl0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cycgZmlsZSB3aWxsIG5vdCBiZSBlZGl0YWJsZS5cIl0sXG4gICAgW1wiZW5hYmxlSW1hZ2VzXCIsIFwiY2FuX2ltYWdlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHVzZXJzIGNhbiBjb3B5L3Bhc3RlIGltYWdlcyBkaXJlY3RseSBpbnRvIHRoZSB0ZXh0IGVkaXRvci5cIl0sXG4gICAgW1wiZW5hYmxlQmxvY2tzXCIsIFwiY2FuX2Jsb2Nrc1wiLCB0cnVlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IGNhbiBlZGl0IHRoZSBibG9jayBpbnRlcmZhY2UgKGlmIG5vdCwgdGhlbiBpdCBpcyB2aXNpYmxlIGJ1dCBub3QgZWRpdGFibGUpLlwiXSxcbiAgICBbXCJjYW5DbG9zZVwiLCBcImNhbl9jbG9zZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudCBzaG91bGQgbWFyayB0aGVpciBzdWJtaXNzaW9uIGNsb3NlZCB3aGVuIHRoZXkgYXJlIGRvbmUuIFRoZXJlIGlzIG5vIHdheSB0byBmb3JjZSBhIHN0dWRlbnQgdG8gZG8gc28uIFVubGlrZSBSZXZpZXdlZCwgdGhpcyBzdGlsbCBzdWJtaXRzIHRoZSBjb3JyZWN0bmVzcy5cIl0sXG4gICAgW1wib25seUludGVyYWN0aXZlXCIsIFwib25seV9pbnRlcmFjdGl2ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbiwgdGhlIHByb2dyYW0gaXMgYXV0b21hdGljYWxseSBydW4sIGFuZCB0aGVuIHRoZSBjb25zb2xlIGVudGVycyBFdmFsIG1vZGUgKGludGVyYWN0aXZlKS5cIl0sXG4gICAgW1wib25seVVwbG9hZHNcIiwgXCJvbmx5X3VwbG9hZHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzJyBmaWxlIHdpbGwgbm90IGJlIGRpcmVjdGx5IGVkaXRhYmxlICh0aGV5IHdpbGwgaGF2ZSB0byB1cGxvYWQgc3VibWlzc2lvbnMpLlwiXSxcbiAgICAvLyBXaGF0IG1lbnVzL2ZlZWRiYWNrIHRvIHNob3cgYW5kIGhpZGVcbiAgICBbXCJoaWRlU3VibWlzc2lvblwiLCBcImhpZGVfc3VibWlzc2lvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGVpciBzdWJtaXNzaW9uJ3MgY29kZSBvciBoaXN0b3J5IG9uIENhbnZhcy5cIl0sXG4gICAgW1wiaGlkZUZpbGVzXCIsIFwiaGlkZV9maWxlc1wiLCB0cnVlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IHNlZSB0aGUgVmlldyBGaWxlcyB0b29sYmFyLlwiXSxcbiAgICBbXCJoaWRlUXVldWVkSW5wdXRzXCIsIFwiaGlkZV9xdWV1ZWRfaW5wdXRzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cyBjYW5ub3QgYWNjZXNzIHRoZSBxdWV1ZWQgaW5wdXRzIGJveCAobWFrZXMgcmVwZWF0ZWQgZGVidWdnaW5nIGVhc2llciBmb3IgdGhlIGlucHV0IGZ1bmN0aW9uKS5cIl0sXG4gICAgW1wiaGlkZUVkaXRvcnNcIiwgXCJoaWRlX2VkaXRvcnNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gYWxsIG9mIHRoZSBlZGl0b3JzIGFyZSBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVNaWRkbGVQYW5lbFwiLCBcImhpZGVfbWlkZGxlX3BhbmVsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBjb25zb2xlIGFuZCBmZWVkYmFjayBhcmVhcyBpcyBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVBbGxcIiwgXCJoaWRlX2FsbFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlbiB0aGUgZW50aXJlIGludGVyZmFjZSBpcyBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVFdmFsdWF0ZVwiLCBcImhpZGVfZXZhbHVhdGVcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIEV2YWx1YXRlIGJ1dHRvbiBpcyBub3Qgc2hvd24gb24gdGhlIGNvbnNvbGUuXCJdLFxuICAgIFtcImhpZGVJbXBvcnREYXRhc2V0c0J1dHRvblwiLCBcImhpZGVfaW1wb3J0X2RhdGFzZXRzX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyBjYW5ub3Qgc2VlIHRoZSBpbXBvcnQgZGF0YXNldHMgYnV0dG9uLlwiXSxcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBvbmUgdG8gYmUgc2V0dGFibGVcbiAgICBbXCJoaWRlSW1wb3J0U3RhdGVtZW50c1wiLCBcImhpZGVfaW1wb3J0X3N0YXRlbWVudHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklOQ09NUExFVEU6IElmIGNoZWNrZWQsIGNlcnRhaW4ga2luZHMgb2YgaW1wb3J0IHN0YXRlbWVudHMgKG1hdHBsb3RsaWIsIHR1cnRsZSwgZGF0YXNldHMpIGFyZSBub3Qgc2hvd24gaW4gdGhlIGJsb2NrIGludGVyZmFjZS5cIl0sXG4gICAgW1wiaGlkZUNvdmVyYWdlQnV0dG9uXCIsIFwiaGlkZV9jb3ZlcmFnZV9idXR0b25cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklOQ09NUExFVEU6IElmIGNoZWNrZWQsIHRoZSBjb3ZlcmFnZSBidXR0b24gaXMgbm90IHNob3duLlwiXSxcbiAgICBbXCJzYXZlVHVydGxlT3V0cHV0XCIsIFwic2F2ZV90dXJ0bGVfb3V0cHV0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHR1cnRsZSBvdXRwdXQgaXMgc2F2ZWQgd2hlbmV2ZXIgdGhlIHByb2dyYW0gdXNlcyBpdC5cIl0sXG5dO1xuXG5leHBvcnQgbGV0IEFzc2lnbWVudFR5cGUgPSB7XG4gICAgQkxPQ0tQWTogXCJibG9ja3B5XCIsXG4gICAgTUFaRTogXCJtYXplXCIsXG4gICAgUVVJWjogXCJxdWl6XCIsXG4gICAgUkVBRElORzogXCJyZWFkaW5nXCJcbn07XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50YXRpb24obmFtZSkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IEFTU0lHTk1FTlRfU0VUVElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBU1NJR05NRU5UX1NFVFRJTkdTW2ldWzRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIkRvY3VtZW50YXRpb24gbm90IGZvdW5kIGZvciBmaWVsZFwiO1xufVxuXG5mdW5jdGlvbiBtYWtlU3RhcnRWaWV3VGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogYXNzaWdubWVudC5zZXR0aW5ncy5zdGFydFZpZXcoKSA9PT0gJyR7bW9kZX0nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0Vmlldy5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LXN0YXJ0LXZpZXctc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MID0gQVNTSUdOTUVOVF9TRVRUSU5HU1xuICAgIC8vIE9ubHkgaGFuZGxlIHRoZSBzaW1wbGUgYm9vbGVhbnMgdGhpcyB3YXlcbiAgICAuZmlsdGVyKChzZXR0aW5nKSA9PiBzZXR0aW5nWzNdID09PSBcImJvb2xcIilcbiAgICAubWFwKChzZXR0aW5nKSA9PiB7XG4gICAgICAgIGxldCBwcmV0dHlOYW1lID0gc2V0dGluZ1sxXS5zcGxpdChcIl9cIikubWFwKHdvcmQ9Pih3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3dvcmQuc2xpY2UoMSkpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIj4ke3ByZXR0eU5hbWV9PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy0ke3NldHRpbmdbMF19XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5zZXR0aW5ncy4ke3NldHRpbmdbMF19XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtzZXR0aW5nWzRdfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgfSkuam9pbihcIlxcblxcblwiKTtcblxuZXhwb3J0IGNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktdmlldy1zZXR0aW5nc1wiPlxuICAgIFxuICAgIDxmb3JtPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMiBteC1hdXRvXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3NcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5zZXR0aW5ncy5zYXZlXCI+U2F2ZSBjaGFuZ2VzPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtbmFtZVwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPk5hbWU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5uYW1lXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIHN0dWRlbnQtZmFjaW5nIG5hbWUgb2YgdGhlIGFzc2lnbm1lbnQuIEFzc2lnbm1lbnRzIHdpdGhpbiBhIGdyb3VwIGFyZSBvcmRlcmVkIGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGJ5IHRoZWlyIG5hbWUsIHNvIHlvdSBtYXkgd2FudCB0byB1c2UgYSBuYW1pbmcgc2NoZW1lIGxpa2UgXCIjNDMuNSkgV2hhdGV2ZXJcIi5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5VUkw6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnVybFwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBjb3Vyc2UtdW5pcXVlIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnNpc3RlbnRseSByZWZlciB0byB0aGlzIGFzc2lnbm1lbnQuIFxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCI+UHVibGljOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5wdWJsaWNcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHVibGljLCB1c2VycyBvdXRzaWRlIG9mIHRoZSBjb3Vyc2Ugd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlIGFzc2lnbm1lbnQgaW4gY291cnNlIGxpc3RpbmdzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCI+SGlkZGVuOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBoaWRkZW4sIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIGdyYWRlIHdoaWxlIHdvcmtpbmcgb24gdGhlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlJldmlld2VkOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnJldmlld2VkXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgSWYgcmV2aWV3ZWQsIHRoZSBhc3NpZ25tZW50IG5lZWQgdG8gYmUgY29tbWVudGVkIHVwb24gYW5kIHJlZ3JhZGVkIGJ5IHRoZSBzdGFmZiBhZnRlciBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBvaW50c1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlBvaW50czo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5wb2ludHNcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGlzIGFzc2lnbm1lbnQgaXMgd29ydGg7IGRlZmF1bHRzIHRvIDEgcG9pbnQuIFxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIj5TdGFydGluZyBWaWV3OjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tM1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXRvZ2dsZSBtci0yXCIgZGF0YS10b2dnbGU9XCJidXR0b25zXCI+XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlNwbGl0XCIsIFwiY29sdW1uc1wiLCBEaXNwbGF5TW9kZXMuU1BMSVQpfVxuICAgICAgICAgICAgICAgICAgICAke21ha2VTdGFydFZpZXdUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTdcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJzdGFydFZpZXdcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+SVAgUmFuZ2VzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5pcFJhbmdlc1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBJUCBBZGRyZXNzZXMgdGhhdCB3aWxsIGJlIGV4cGxpY2l0bHkgYWxsb3dlZC4gSWYgYmxhbmssXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGFkZHJlc3NlcyBhcmUgYWxsb3dlZC4gSWYgYW4gYWRkcmVzcyBzdGFydHMgd2l0aCA8Y29kZT5ePC9jb2RlPiB0aGVuIGl0IGl0IGlzIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tsaXN0ZWQsIGJ1dCB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIGluIHR1cm4gd2l0aCBhIDxjb2RlPiE8L2NvZGU+LiBBZGRyZXNzZXMgY2FuIGFsc29cbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBhIGJpdCBtYXNrIHRvIGFsbG93IGEgcmFuZ2Ugb2YgYWRkcmVzc2VzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UGFzc2NvZGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wYXNzY29kZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MucGFzc2NvZGVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJwYXNzY29kZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1kYXRhc2V0c1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlByZWxvYWRlZCBEYXRhc2V0czo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcImRhdGFzZXRzXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5CbG9jayBUb29sYm94OjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy10b29sYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveFwiPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub3JtYWxcIj5Ob3JtYWwgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdFwiPkNUQFZUIFRvb2xib3g8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3QyXCI+Q1RAVlQgVG9vbGJveCBWMjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtaW5pbWFsXCI+TWluaW1hbCBTZXQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZnVsbFwiPkFsbCBCbG9ja3M8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3VzdG9tXCI+Q3VzdG9tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidG9vbGJveFwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy10eXBlXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJvYmxlbSBUeXBlOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy10eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudHlwZVwiPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJibG9ja3B5XCI+QmxvY2tQeTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtYXplXCI+TWF6ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJxdWl6XCI+UXVpeiBRdWVzdGlvbjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZWFkaW5nXCI+UmVhZGluZzwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInR5cGVcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgICR7QVNTSUdOTUVOVF9TRVRUSU5HU19CT09MRUFOX0NPTVBPTkVOVFNfSFRNTH1cbiAgICA8L2Zvcm0+XG4gICAgXG4gICAgPC9kaXY+XG5gO1xuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCkge1xuICAgIGxldCBzZXR0aW5ncyA9IHt9O1xuICAgIEFTU0lHTk1FTlRfU0VUVElOR1MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXSwgZGVmYXVsdFZhbHVlID0gc2V0dGluZ1syXTtcbiAgICAgICAgbGV0IHZhbHVlID0gbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXSgpO1xuICAgICAgICAvLyBPbmx5IHN0b3JlIHRoaXMgc2V0dGluZyBpZiBpdHMgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW3NlcnZlck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCwgc2V0dGluZ3MpIHtcbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHNldHRpbmdzKTtcbiAgICAgICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJOYW1lIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nc1tzZXJ2ZXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3NbY2xpZW50TmFtZV0oc2V0dGluZ1syXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdGFydF92aWV3KSB7XG4gICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoc2V0dGluZ3Muc3RhcnRfdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWwoY29uZmlndXJhdGlvbikge1xuICAgIGxldCBzZXR0aW5ncyA9IHt9O1xuICAgIEFTU0lHTk1FTlRfU0VUVElOR1MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXSwgZGVmYXVsdFZhbHVlID0gc2V0dGluZ1syXSxcbiAgICAgICAgICAgIGZpZWxkVHlwZSA9IHNldHRpbmdbM107XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zZXR0aW5ncy5cIitzZXJ2ZXJOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb25maWdWYWx1ZSA9IGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICBjb25maWdWYWx1ZSA9IGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dGluZ3NbY2xpZW50TmFtZV0gPSBrby5vYnNlcnZhYmxlKGNvbmZpZ1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xufVxuXG5jbGFzcyBBc3NpZ25tZW50U2V0dGluZ3NWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvL1RPRE86IHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICAvLyB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy9UT0RPOiB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IERvIHVwZGF0ZVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLnZhbHVlKCkpO1xuICAgICAgICAgICAgLy8gVE9ETzogVXBkYXRlXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICAvL3RoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZVxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFzc2lnbm1lbnRTZXR0aW5ncyA9IHtcbiAgICBuYW1lOiBcIkFzc2lnbm1lbnQgU2V0dGluZ3NcIixcbiAgICBleHRlbnNpb25zOiBbXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBBc3NpZ25tZW50U2V0dGluZ3NWaWV3LFxuICAgIHRlbXBsYXRlOiBBU1NJR05NRU5UX1NFVFRJTkdTX0VESVRPUl9IVE1MXG59OyIsIlxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRfaGVhZGVyID0gYFxyXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tdG9vbGJhciBjb2wtbWQtMTIgYnRuLXRvb2xiYXJcIlxyXG4gICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlB5dGhvbiBUb29sYmFyXCI+XHJcbiAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCI+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1maWxlLXVwbG9hZFwiPjwvc3Bhbj4gVXBsb2FkXHJcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImJsb2NrcHktdG9vbGJhci11cGxvYWRcIiB0eXBlPVwiZmlsZVwiXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5cclxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImV2ZW50OiB7Y2hhbmdlOiB1aS5lZGl0b3JzLnVwbG9hZH1cIj5cclxuICAgICAgICAgPC9sYWJlbD5cclxuXHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGRyb3Bkb3duLXRvZ2dsZSBkcm9wZG93bi10b2dnbGUtc3BsaXRcIlxyXG4gICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+VG9nZ2xlIERyb3Bkb3duPC9zcGFuPlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cclxuICAgICAgICAgICAgPGEgY2xhc3M9J2Ryb3Bkb3duLWl0ZW0gYmxvY2tweS10b29sYmFyLWRvd25sb2FkJ1xyXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuZG93bmxvYWRcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1kb3dubG9hZCc+PC9zcGFuPiBEb3dubG9hZFxyXG4gICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIFxyXG4gICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkRlbGV0ZSBHcm91cFwiXHJcbiAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5EZWxldGVcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcclxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmRlbGV0ZVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvc3Bhbj4gRGVsZXRlXHJcbiAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgIDwvZGl2PlxyXG4gPC9kaXY+XHJcbmA7XHJcbiIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEpTT05fRURJVE9SX0hUTUwgPSBgXHJcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxyXG4gICAgIDxkaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItanNvblwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEpzb25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1qc29uXCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBKc29uRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJKU09OXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCIuanNvblwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBKc29uRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBKU09OX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgTUFSS0RPV05fRURJVE9SX0hUTUwgPSBgXG4gICAgJHtkZWZhdWx0X2hlYWRlcn1cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1tYXJrZG93blwiPjwvdGV4dGFyZWE+ICAgIFxuYDtcblxuXG5jbGFzcyBNYXJrZG93bkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMubWRlID0gbmV3IEVhc3lNREUoe1xuICAgICAgICAgICAgZWxlbWVudDogdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItbWFya2Rvd25cIilbMF0sXG4gICAgICAgICAgICBhdXRvRG93bmxvYWRGb250QXdlc29tZTogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZVN5bmM6IHRydWUsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IFwiMzAwcHhcIixcbiAgICAgICAgICAgIC8vc2Nyb2xsYmFyU3R5bGU6IFwibmF0aXZlXCIsXG4gICAgICAgICAgICAvLyBUT0RPOiBpbWFnZVVwbG9hZEZ1bmN0aW9uXG4gICAgICAgICAgICByZW5kZXJpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICBjb2RlU3ludGF4SGlnaGxpZ2h0aW5nOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1kZS5jb2RlbWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMubWRlLmNvZGVtaXJyb3IpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWRlLnZhbHVlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLm1kZS52YWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bkVkaXRvciA9IHtcbiAgICBuYW1lOiBcIk1hcmtkb3duXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLm1kXCJdLFxuICAgIGNvbnN0cnVjdG9yOiBNYXJrZG93bkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IE1BUktET1dOX0VESVRPUl9IVE1MXG59OyIsIi8qKlxuICogVE9ETzogcmVuYW1lIGZpbGVzLCBtYW51YWwgc2F2ZSwgdGFncywgc2FtcGxlX3N1Ym1pc3Npb25zLCBvbl9ldmFsLCBub24tYnVpbHRpbiBmaWxlc1xuICogVE9ETzogaW1wb3J0IGRhdGEsIGhpc3RvcnksIHJ1biwgdXJsX2RhdGEsIGFzc2lnbm1lbnRfc2V0dGluZ3MsIHBhcnNvbnNfbW9kZVxuICogVE9ETzogZGVsZXRlIGJlY29tZXMgXCJjbGVhclwiIGZvciBpbnN0cnVjdG9yIGZpbGVzXG4gKi9cblxuLyoqXG4gKlxuICogQGVudW0ge3N0cn1cbiAqL1xuaW1wb3J0IHtBYnN0cmFjdEVkaXRvciwgc2x1Z2dpZnl9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtISVNUT1JZX1RPT0xCQVJfSFRNTH0gZnJvbSBcIi4uL2hpc3RvcnlcIjtcblxuZXhwb3J0IGxldCBEaXNwbGF5TW9kZXMgPSB7XG4gICAgQkxPQ0s6IFwiYmxvY2tcIixcbiAgICBTUExJVDogXCJzcGxpdFwiLFxuICAgIFRFWFQ6IFwidGV4dFwiXG59O1xuXG5mdW5jdGlvbiBtYWtlVGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICcke21vZGV9J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZWRpdG9ycy5weXRob24udXBkYXRlTW9kZS5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LW1vZGUtc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5leHBvcnQgY29uc3QgUFlUSE9OX0VESVRPUl9IVE1MID0gYFxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLXRvb2xiYXIgY29sLW1kLTEyIGJ0bi10b29sYmFyXCJcbiAgICAgICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlB5dGhvbiBUb29sYmFyXCI+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSdW4gR3JvdXBcIj4gICAgICAgICBcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJsb2NrcHktcnVuIG5vdHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmV4ZWN1dGUucnVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeydibG9ja3B5LXJ1bi1ydW5uaW5nJzogdWkuZXhlY3V0ZS5pc1J1bm5pbmd9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtcGxheVwiPjwvc3Bhbj4gUnVuXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgIDwhLS0ga28gaWY6ICRyb290LmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlQmxvY2tzKCkgLS0+XG4gICAgICAgICAgICAke21ha2VUYWIoXCJCbG9ja3NcIiwgXCJ0aC1sYXJnZVwiLCBEaXNwbGF5TW9kZXMuQkxPQ0spfVxuICAgICAgICAgICAgJHttYWtlVGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVzZXQgR3JvdXBcIj5cbiAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5yZXNldFwiPlxuICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zeW5jXCI+PC9zcGFuPiBSZXNldFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIGtvIGlmOiAhYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlSW1wb3J0RGF0YXNldHNCdXR0b24oKSAtLT5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJJbXBvcnQgR3JvdXBcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuaW1wb3J0RGF0YXNldFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWNsb3VkLWRvd25sb2FkLWFsdFwiPjwvc3Bhbj4gSW1wb3J0IGRhdGFzZXRzXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxuICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGRyb3Bkb3duLXRvZ2dsZSBkcm9wZG93bi10b2dnbGUtc3BsaXRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+VG9nZ2xlIERyb3Bkb3duPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9J2Ryb3Bkb3duLWl0ZW0gYmxvY2tweS10b29sYmFyLWRvd25sb2FkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuZG93bmxvYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1kb3dubG9hZCc+PC9zcGFuPiBEb3dubG9hZFxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkhpc3RvcnkgR3JvdXBcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi50b2dnbGVIaXN0b3J5TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdWkuZWRpdG9ycy5weXRob24uaXNIaXN0b3J5QXZhaWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7IGFjdGl2ZTogZGlzcGxheS5oaXN0b3J5TW9kZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjogeyAnYXJpYS1wcmVzc2VkJzogZGlzcGxheS5oaXN0b3J5TW9kZSB9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtaGlzdG9yeVwiPjwvc3Bhbj4gSGlzdG9yeVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0gRnVsbHkgZnVuY3Rpb25hbCwgYnV0IGEgbGl0dGxlIHRvby4uIEludmFzaXZlIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkZ1bGxzY3JlZW4gR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICd0ZXh0J1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uZnVsbHNjcmVlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWV4cGFuZC1hcnJvd3MtYWx0XCI+PC9zcGFuPiBGdWxsc2NyZWVuXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIC0tPlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiU2F2ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblNhdmVcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXNhdmVcIj48L3NwYW4+IFNhdmVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuRGVsZXRlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L3NwYW4+IERlbGV0ZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS08ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVuYW1lIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuUmVuYW1lXCI+XG4gICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS1zaWduYXR1cmVcIj48L3NwYW4+IFJlbmFtZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+LS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICAke0hJU1RPUllfVE9PTEJBUl9IVE1MfVxuXG5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIlxuICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLm1lbnUuaXNTdWJtaXR0ZWRcIj5cbiAgICA8L2Rpdj5cbmA7XG5cblxuXG5mdW5jdGlvbiBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKSB7XG4gICAgbGV0IGlweW5iID0gSlNPTi5wYXJzZShjb2RlKTtcbiAgICBsZXQgaXNVc2FibGUgPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIWNlbGwuc291cmNlWzBdLnN0YXJ0c1dpdGgoXCIlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG1ha2VQeXRob24gPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgIGNlbGwuY2VsbF90eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInJydcIitjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpK1wiJycnXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpcHluYi5jZWxscy5maWx0ZXIoaXNVc2FibGUpLm1hcChtYWtlUHl0aG9uKS5qb2luKFwiXFxuXCIpO1xufVxuXG5jbGFzcyBQeXRob25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcuZmluZChcIi5ibG9ja3B5LXB5dGhvbi1ibG9ja21pcnJvclwiKSk7XG4gICAgICAgIEJsb2NrbHkuc2V0UGFyZW50Q29udGFpbmVyKG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXJbMF0pO1xuICAgICAgICB0aGlzLmJtID0gbmV3IEJsb2NrTWlycm9yKHtcbiAgICAgICAgICAgIFwiY29udGFpbmVyXCI6IHRoaXMudGFnWzBdLFxuICAgICAgICAgICAgXCJydW5cIjogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5ydW4uYmluZChtYWluLmNvbXBvbmVudHMuZW5naW5lKSxcbiAgICAgICAgICAgIFwic2tpcFNrdWxwdFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJibG9ja2x5TWVkaWFQYXRoXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5ibG9ja2x5UGF0aCxcbiAgICAgICAgICAgIFwidG9vbGJveFwiOiBtYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveCgpLFxuICAgICAgICAgICAgXCJpbWFnZU1vZGVcIjogdHJ1ZSxcbiAgICAgICAgICAgIGltYWdlRG93bmxvYWRIT29rOiAob2xkVXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFVybDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZVVwbG9hZEhvb2s6IChibG9iKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIkltYWdlKFwiK0pTT04uc3RyaW5naWZ5KFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpK1wiKVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZUxpdGVyYWxIb29rOiAob2xkVXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbWFnZShcIiR7b2xkVXJsfVwiKWA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8naGVpZ2h0JzogJzIwMDBweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG5cbiAgICAgICAgdGhpcy5tYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG5cbiAgICBjb25maWd1cmVFeHRyYUJsb2NrbHkoKSB7XG4gICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLmNvbmZpZ3VyZUNvbnRleHRNZW51ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlNjcmVlbnNob3RcIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlNDUkVFTlNIT1RfQkxPQ0tTXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIGxldCBvbGRGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBpZiAob2xkRmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKERpc3BsYXlNb2Rlcy5URVhUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUodGhpcy5vbGRQeXRob25Nb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50Qk1MaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm0uYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50Qk1MaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLmJtLmlzUGFyc29ucyA9ICgpID0+IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibS5pc1BhcnNvbnMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5pc1BhcnNvbnM7XG5cbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5saW5lc0Vycm9yLnN1YnNjcmliZSgobGluZXMpID0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLWVycm9yLWxpbmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGluZXNVbmNvdmVyZWQuc3Vic2NyaWJlKChsaW5lcykgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLXVuY292ZXJlZC1saW5lXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL3RoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLnJlbmRlcigpO1xuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGlzIGRvZXNuJ3QgZW5kIHVwIGxvb2tpbmcgcmlnaHQgKGdvIHRvIGEgZGlmZmVyZW50IGVkaXRvciwgY29tZSBiYWNrLCBhbmQgaXQnbGwgYmUgc3F1aXNoZWQpXG4gICAgICAgIC8vdGhpcy5ibS5yZWZyZXNoKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ibS5yZWZyZXNoKCksIDApO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICBpZiAobmV3Q29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gdGhpcy5maWxlLmhhbmRsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciwgZmlsZSB3YXMgYWxyZWFkeSBzaHV0IGRvd24uXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudHMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBjbG9zaW5nIHRoaXMgZmlsZVxuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8odGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJtLnNldENvZGUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5ibS5nZXRDb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJtLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJMaW5lU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIGNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uc2V0TW9kZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlLnN1YnNjcmliZShtb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZShtb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUJsb2Nrcy5zdWJzY3JpYmUoZW5hYmxlZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3guc3Vic2NyaWJlKHRoaXMucmVsb2FkVG9vbGJveC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlSW1hZ2VzLnN1YnNjcmliZShpbWFnZU1vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRJbWFnZU1vZGUoaW1hZ2VNb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVsb2FkVG9vbGJveCh0b29sYm94KSB7XG4gICAgICAgIGlmICh0b29sYm94ID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tVG9vbGJveCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj90b29sYm94LmJsb2NrcHlcIik7XG4gICAgICAgICAgICBpZiAoY3VzdG9tVG9vbGJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJveCA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IEpTT04ucGFyc2UoY3VzdG9tVG9vbGJveC5oYW5kbGUoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBUT0RPOiBJbXByb3ZlIGVycm9yIG1lc3NhZ2UgZm9yIGluc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IFwibWluaW1hbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24udG9vbGJveCA9IHRvb2xib3g7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBpbnZhbGlkIHRvb2xib3ggYmV0dGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi50b29sYm94ID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWRPbmx5KHRoaXMuZGVjaWRlSWZOb3RFZGl0YWJsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkT25seSh0aGlzLmRlY2lkZUlmTm90RWRpdGFibGUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlY2lkZUlmTm90RWRpdGFibGUoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSB8fCAoXG4gICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzKCkgJiYgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0UmVhZE9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5ibS5zZXRSZWFkT25seShpc1JlYWRPbmx5KTtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvZGUgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIuaXB5bmJcIikpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuVXBsb2FkXCIsIFwiXCIsIFwiXCIsIGNvZGUsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvZGUpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuKCk7XG4gICAgICAgIC8vIFRPRE86IFJ1biBjb2RlXG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZG93bmxvYWRGaWxlKCk7XG4gICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiByZXN1bHQuZXh0ZW5zaW9uID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IHNsdWdnaWZ5KHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1pbWV0eXBlID0gXCJ0ZXh0L3gtcHl0aG9uXCI7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5Eb3dubG9hZFwiLCBcIlwiLCBcIlwiLCBcIlwiLCByZXN1bHQubmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQeXRob25FZGl0b3IgPSB7XG4gICAgbmFtZTogXCJQeXRob25cIixcbiAgICBleHRlbnNpb25zOiBbXCIucHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFB5dGhvbkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFBZVEhPTl9FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBRVUlaX0VESVRPUl9IVE1MID0gYFxyXG4gICAgPGRpdj5cclxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXF1aXpcIj48L3RleHRhcmVhPlxyXG4gICAgPC9kaXY+XHJcbmA7XHJcblxyXG5jbGFzcyBRdWl6RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xyXG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcclxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcclxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFF1aXpFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIlF1aXpcIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5xdWl6XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFF1aXpFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFFVSVpfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIFBhbmVsIGZvciBlZGl0aW5nIHRoZSBzZXQgb2YgU2FtcGxlIFN1Ym1pc3Npb25zLlxuICogVGhlc2UgYXJlIG5vdCBwcm92aWRlZCBhdCBhbGwgdG8gc3R1ZGVudHMgd2l0aG91dCB0aGUgR3JhZGVyIHJvbGUuXG4gKi9cblxuaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBTdWJtaXNzaW9uU3RhdHVzZXMgPSB7XG4gICAgVU5LTk9XTjogXCJ1bmtub3duXCIsXG4gICAgUEFTU0VEOiBcInBhc3NlZFwiLFxuICAgIEZBSUxFRDogXCJmYWlsZWRcIixcbiAgICBFUlJPUjogXCJlcnJvclwiLFxuICAgIFNLSVBQRUQ6IFwic2tpcHBlZFwiXG59O1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlU3VibWlzc2lvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBCbGFuayhjb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oXCJVbnRpdGxlZFwiKyhjb3VudCB8fCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pc3Npb25TdGF0dXNlcy5VTktOT1dOLCBcImE9MFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oZGF0YS5uYW1lLCBkYXRhLnN0YXR1cywgZGF0YS5jb2RlKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU0FNUExFX1NVQk1JU1NJT05TX0hUTUwgPSBgXG48ZGl2PlxuICAgIDxkaXYgZGF0YS1iaW5kPVwiZm9yZWFjaDoge2RhdGE6IGFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnN9XCJcbiAgICAgICAgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3Itc2FtcGxlLXN1Ym1pc3Npb25zLWNvZGVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNvZGVNaXJyb3JJbnN0YW5jZTogY29kZVwiPjwvdGV4dGFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN0YXR1c1wiPjwvc3Bhbj4gICAgICAgIFxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxua28uYmluZGluZ0hhbmRsZXJzLmNvZGVNaXJyb3JJbnN0YW5jZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50XG4gICAgICAgIC8vIFNldCB1cCBhbnkgaW5pdGlhbCBzdGF0ZSwgZXZlbnQgaGFuZGxlcnMsIGV0Yy4gaGVyZVxuICAgICAgICBjb25zb2xlLmxvZyhcIklOSVRcIik7XG4gICAgICAgIGxldCBjbSA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNtLnNldFNpemUoXCIxMDAlXCIsIFwiMTAwcHhcIik7XG4gICAgICAgIHJldHVybiBjbTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50LFxuICAgICAgICAvLyBhbmQgYWdhaW4gd2hlbmV2ZXIgYW55IG9ic2VydmFibGVzL2NvbXB1dGVkcyB0aGF0IGFyZSBhY2Nlc3NlZCBjaGFuZ2VcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBET00gZWxlbWVudCBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgdmFsdWVzIGhlcmUuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVVBEQVRFXCIpO1xuICAgIH1cbn07XG5cbmNsYXNzIFNhbXBsZVN1Ym1pc3Npb25zVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpIHtcblxuICAgIH1cblxuICAgIHJlYnVpbGRFZGl0b3JzKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlYnVpbGRpbmcgZWRpdG9yc1wiKTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vdGhpcy5yZWJ1aWxkRWRpdG9ycygpO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLGNtKSA9PiBjb25zb2xlLmxvZyhcIisrK1wiLCBjbS5Db2RlTWlycm9yKSkpO1xuICAgICAgICAgICAgdGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSwgY20pID0+IGNtLkNvZGVNaXJyb3IucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVGUkVTSFwiKTtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLCBjbSkgPT4gY20uQ29kZU1pcnJvci5yZWZyZXNoKCkpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvZGVNaXJyb3JzKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnNldFZhbHVlKG5ld0NvbnRlbnRzLmpvaW4oXCJcXG5cIikpKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnJlZnJlc2goKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvcnMubWFwKGNtID0+IGNtLmdldFZhbHVlKCkpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTYW1wbGVTdWJtaXNzaW9ucyA9IHtcbiAgICBuYW1lOiBcIlNhbXBsZSBTdWJtaXNzaW9uc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogU2FtcGxlU3VibWlzc2lvbnNWaWV3LFxuICAgIHRlbXBsYXRlOiBTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTFxufTtcbiIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgVEFHU19FRElUT1JfSFRNTCA9IGBcbkNyZWF0ZSBuZXdcbkltcG9ydCBieSBuYW1lXG5GaW5kIGJ5IG93bmVyL2NvdXJzZS9raW5kXG5cblRhZ3M6XG4gICAgRGF0YTpcbiAgICAgICAgTmFtZVxuICAgICAgICBLaW5kXG4gICAgICAgIExldmVsXG4gICAgICAgIFZlcnNpb25cbiAgICAgICAgRGVzY3JpcHRpb25cbiAgICBDb250cm9sczpcbiAgICAgICAgRWRpdFxuICAgICAgICBSZW1vdmVcbiAgICAgICAgRGVsZXRlIFxuYDtcblxuY2xhc3MgVGFnc0VkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRhZ3NcIikpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRhZ3NFZGl0b3IgPSB7XG4gICAgbmFtZTogXCJUYWdzXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIXRhZ3MuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogVGFnc0VkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFRBR1NfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgVEVYVF9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDxkaXY+XG4gICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdGV4dFwiPjwvdGV4dGFyZWE+XG4gICAgPC9kaXY+XG5gO1xuXG5jbGFzcyBUZXh0RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0RWRpdG9yID0ge1xuICAgIG5hbWU6IFwiVGV4dFwiLFxuICAgIGV4dGVuc2lvbnM6IFtcIi50eHRcIl0sXG4gICAgY29uc3RydWN0b3I6IFRleHRFZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBURVhUX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPT0xCT1hfRURJVE9SX0hUTUwgPSBgXHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIlxyXG4gICAgICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJUb29sYm94IFRvb2xiYXJcIj5cclxuICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJTYXZlIEdyb3VwXCI+ICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLWVkaXRvci1qc29uLXNhdmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXHJcbiAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdG9vbGJveFwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIFRvb2xib3hFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10b29sYm94XCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLWpzb24tc2F2ZVwiKS5vbihcImNsaWNrXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94KCkgPT09IFwiY3VzdG9tXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5yZWxvYWRUb29sYm94KFwiY3VzdG9tXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLXRvb2xib3gtc2F2ZVwiKS5vZmYoXCJjbGlja1wiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUb29sYm94RWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJUb29sYm94XCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/dG9vbGJveC5ibG9ja3B5XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFRvb2xib3hFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFRPT0xCT1hfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIEVkaXRvcnMgYXJlIGluZmVycmVkIGZyb20gRmlsZW5hbWVzLlxuICpcbiAqIFRoZSBlZGl0b3IgaXMgYmFzZWQgb24gdGhlIGV4dGVuc2lvbjpcbiAqICAuYmxvY2tweTogU3BlY2lhbCBlZGl0b3IgKHdpbGwgYmUgY2hvc2VuIGJ5IGZpbGVuYW1lKVxuICogIC5weTogUHl0aG9uIEVkaXRvclxuICogIC5tZDogTWFya2Rvd24gRWRpdG9yXG4gKiAgLnR4dDogVGV4dCBFZGl0b3IgKGFsc28gdXNlZCBmb3Igb3RoZXIgdHlwZXMpXG4gKiAgLnBlbWw6IFBFTUwgRWRpdG9yXG4gKiAgLnBuZywgLmdpZiwgLmpwZWcsIC5qcGcsIC5ibXA6IEltYWdlIEVkaXRvclxuICogIC5qc29uOiBKU09OIEVkaXRvclxuICogIC55YW1sOiBZQU1MIEVkaXRvclxuICovXG5cbmltcG9ydCB7UHl0aG9uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcHl0aG9uXCI7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90ZXh0XCI7XG5pbXBvcnQge0Fzc2lnbWVudFR5cGUgYXMgQXNzaWdubWVudFR5cGUsIEFzc2lnbm1lbnRTZXR0aW5nc30gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcbmltcG9ydCB7VGFnc0VkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3RhZ3NcIjtcbmltcG9ydCB7TWFya2Rvd25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9tYXJrZG93blwiO1xuaW1wb3J0IHtTYW1wbGVTdWJtaXNzaW9uc30gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuaW1wb3J0IHtKc29uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvanNvblwiO1xuaW1wb3J0IHtUb29sYm94RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdG9vbGJveFwiO1xuaW1wb3J0IHtRdWl6RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcXVpelwiO1xuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgcG9zc2libGUgZWRpdG9ycyBhdmFpbGFibGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgRWRpdG9yc0VudW0gPSB7XG4gICAgU1VCTUlTU0lPTjogXCJzdWJtaXNzaW9uXCIsXG4gICAgQVNTSUdOTUVOVDogXCJhc3NpZ25tZW50XCIsXG4gICAgSU5TVFJVQ1RJT05TOiBcImluc3RydWN0aW9uc1wiLFxuICAgIE9OX1JVTjogXCJvbl9ydW5cIixcbiAgICBPTl9DSEFOR0U6IFwib25fY2hhbmdlXCIsXG4gICAgT05fRVZBTDogXCJvbl9ldmFsXCIsXG4gICAgU1RBUlRJTkdfQ09ERTogXCJzdGFydGluZ19jb2RlXCIsXG4gICAgU0FNUExFX1NVQk1JU1NJT05TOiBcInNhbXBsZV9zdWJtaXNzaW9uc1wiLFxuICAgIElOU1RSVUNUT1JfRklMRTogXCJpbnN0cnVjdG9yX2ZpbGVcIlxufTtcblxuY29uc3QgU1BFQ0lBTF9OQU1FU1BBQ0VTID0gW1wiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJFwiXTtcblxuY29uc3QgQVZBSUxBQkxFX0VESVRPUlMgPSBbXG4gICAgVGV4dEVkaXRvciwgUHl0aG9uRWRpdG9yLCBBc3NpZ25tZW50U2V0dGluZ3MsIFRhZ3NFZGl0b3IsIE1hcmtkb3duRWRpdG9yLFxuICAgIFNhbXBsZVN1Ym1pc3Npb25zLCBKc29uRWRpdG9yLCBUb29sYm94RWRpdG9yLCBRdWl6RWRpdG9yXG5dO1xuXG5leHBvcnQgY29uc3QgRURJVE9SU19IVE1MID0gQVZBSUxBQkxFX0VESVRPUlMubWFwKGVkaXRvciA9PiBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1lZGl0b3JcIiBcbiAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy52aWV3KCkubmFtZSA9PT0gJyR7ZWRpdG9yLm5hbWV9J1wiPlxuICAgIDxkaXY+XG4gICAgJHtlZGl0b3IudGVtcGxhdGV9XG4gICAgPC9kaXY+XG48L2Rpdj5cbmBcbiAgICAvKlxuICAgIGBcbjwhLS0ga28gaWY6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfScgLS0+XG4ke2VkaXRvci50ZW1wbGF0ZX1cbjwhLS0gL2tvIC0tPmAqL1xuKS5qb2luKFwiXFxuXCIpO1xuXG5leHBvcnQgY2xhc3MgRWRpdG9ycyB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfID0gW107XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc18gPSB7fTtcbiAgICAgICAgdGhpcy5ieU5hbWVfID0ge307XG4gICAgICAgIEFWQUlMQUJMRV9FRElUT1JTLmZvckVhY2goZWRpdG9yID0+IHRoaXMucmVnaXN0ZXJFZGl0b3IoZWRpdG9yKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lLnN1YnNjcmliZSh0aGlzLmNoYW5nZUVkaXRvciwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJFZGl0b3IoZGF0YSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9IGRhdGEuZXh0ZW5zaW9ucztcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IGRhdGEuY29uc3RydWN0b3IodGhpcy5tYWluLCB0aGlzLnRhZyk7XG4gICAgICAgIGluc3RhbmNlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZF8ucHVzaChpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYnlOYW1lX1tkYXRhLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBpbnN0YW5jZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zX1tleHRlbnNpb25zW2ldXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnlOYW1lX1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cblxuICAgIGNoYW5nZUVkaXRvcihuZXdGaWxlbmFtZSkge1xuICAgICAgICBsZXQgb2xkRWRpdG9yID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBsZXQgbmV3RWRpdG9yID0gdGhpcy5nZXRFZGl0b3IobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVkaXRvci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3RWRpdG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnQuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlRmlsZW5hbWUocGF0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSBwYXRoLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKFNQRUNJQUxfTkFNRVNQQUNFUy5pbmRleE9mKHNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwYWNlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB7XCJzcGFjZVwiOiBzcGFjZSwgXCJuYW1lXCI6IG5hbWUsIFwidHlwZVwiOiB0eXBlfTtcbiAgICB9XG5cbiAgICBnZXRFZGl0b3IocGF0aCkge1xuICAgICAgICBsZXQge3NwYWNlLCBuYW1lLCB0eXBlfSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiLmJsb2NrcHlcIiAmJiBwYXRoIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW3BhdGhdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc3NpZ25tZW50VHlwZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnR5cGUoKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRUeXBlICE9PSBBc3NpZ25tZW50VHlwZS5CTE9DS1BZKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiB0eXBlID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiLlwiK2Fzc2lnbm1lbnRUeXBlIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bXCIuXCIrYXNzaWdubWVudFR5cGVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBlZGl0b3IgcmVnaXN0ZXJlZCBmb3IgYXNzaWdubWVudCB0eXBlOlwiLCBhc3NpZ25tZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudHlwZSgpLCBzcGFjZSwgbmFtZSwgdHlwZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4vc2VydmVyXCI7XG5pbXBvcnQge09uUnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX3J1blwiO1xuaW1wb3J0IHtSdW5Db25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvcnVuXCI7XG5pbXBvcnQge0V2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvZXZhbFwiO1xuaW1wb3J0IHtTYW1wbGVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvc2FtcGxlXCI7XG5pbXBvcnQge09uQ2hhbmdlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX2NoYW5nZVwiO1xuaW1wb3J0IHtPbkV2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fZXZhbFwiO1xuaW1wb3J0IHtPblNhbXBsZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9zYW1wbGVcIjtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGV4ZWN1dGluZyBQeXRob24gY29kZSBhbmQgcGFzc2luZyB0aGUgcmVzdWx0cyBhbG9uZyB0byBpbnRlcmVzdGVkIGNvbXBvbmVudHMuXG4gKlxuICogSW50ZXJlc3RpbmcgY29tcG9uZW50czpcbiAqICBFeGVjdXRpb24gQnVmZmVyOiBSZXNwb25zaWJsZSBmb3IgY29sbGVjdGluZyB0aGUgdHJhY2UgZHVyaW5nIHByb2dyYW0gZXhlY3V0aW9uLlxuICogICAgICAgICAgICAgICAgICAgIFRoaXMgcHJldmVudHMgS25vY2tvdXRqcyBmcm9tIHVwZGF0aW5nIHRoZSBlZGl0b3IgZHVyaW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5RWRpdG9yfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5leGVjdXRpb25Nb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb247XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IHtcbiAgICAgICAgICAgIHJ1bjogbmV3IFJ1bkNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBldmFsOiBuZXcgRXZhbENvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvblJ1bjogbmV3IE9uUnVuQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBuZXcgT25DaGFuZ2VDb25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25FdmFsOiBuZXcgT25FdmFsQ29uZmlndXJhdGlvbihtYWluKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByZWNvbmZpZ3VyZSBza3VscHQgc28gd2UgY2FuIHBhcnNlXG4gICAgICAgIFNrLmNvbmZpZ3VyZSh0aGlzLmNvbmZpZ3VyYXRpb25zLnJ1bi5nZXRTa3VscHRPcHRpb25zKCkpO1xuXG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB0cmFjaW5nIHdoaWxlIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGluZ1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmFibGUgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gZXhlY3V0aW9uIGhhcyBmdWxseSBlbmRlZCxcbiAgICAgICAgICogd2hldGhlciBpdCBzdWNjZWVkcyBvciBmYWlscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25FeGVjdXRpb25CZWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25FeGVjdXRpb25FbmQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHJlcG9ydHNcbiAgICAgKi9cbiAgICByZXNldFJlcG9ydHMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLmV4ZWN1dGlvbk1vZGVsLnJlcG9ydHM7XG4gICAgICAgIHJlcG9ydFtcInZlcmlmaWVyXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wibW9kZWxcIl0gPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgfTtcblxuICAgIHJlc2V0U3R1ZGVudE1vZGVsKCkge1xuICAgICAgICBsZXQgc3R1ZGVudCA9IHRoaXMuZXhlY3V0aW9uTW9kZWwuc3R1ZGVudDtcbiAgICAgICAgc3R1ZGVudC5jYWxscyA9IHt9O1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRTdGVwKG51bGwpO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQubGFzdFN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudExpbmUobnVsbCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFRyYWNlRGF0YS5yZW1vdmVBbGwoKTtcbiAgICAgICAgc3R1ZGVudC5yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgc3R1ZGVudC50cmFjaW5nID0gW107XG4gICAgfVxuXG4gICAgcmVzZXRFeGVjdXRpb25CdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uQnVmZmVyID0ge1xuICAgICAgICAgICAgXCJ0cmFjZVwiOiBbXSxcbiAgICAgICAgICAgIFwic3RlcFwiOiAwLFxuICAgICAgICAgICAgXCJsaW5lXCI6IDAsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaW50ZXJmYWNlIGFzcGVjdHMgb2YgdGhlIHByZXZpb3VzIFJ1bi5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy8gVE9ETzogQ2xlYXIgb3V0IGFueSBjb3ZlcmFnZS90cmFjZS9lcnJvciBoaWdobGlnaHRzIGluIGVkaXRvcnNcbiAgICAgICAgLy8gUmVzZXQgZXhlY3V0aW9uIGluIG1vZGVsXG4gICAgICAgIHRoaXMucmVzZXRTdHVkZW50TW9kZWwoKTtcbiAgICAgICAgLy8gR2V0IHJlcG9ydHMgcmVhZHlcbiAgICAgICAgdGhpcy5yZXNldFJlcG9ydHMoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBleGVjdXRpb24gYnVmZmVyXG4gICAgICAgIHRoaXMucmVzZXRFeGVjdXRpb25CdWZmZXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBjb25zb2xlIG9mIHByaW50ZWQgc3R1ZmZcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5jbGVhcigpO1xuICAgICAgICAvLyBDbGVhciBvdXQgYW55IG9sZCBmZWVkYmFja1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5jbGVhcigpO1xuICAgIH1cblxuICAgIGRlbGF5ZWRSdW4oKSB7XG4gICAgICAgIC8vdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyQoXCIuYmxvY2tweS1ydW5cIikuYWRkQ2xhc3MoXCJibG9ja3B5LXJ1bi1ydW5uaW5nXCIpO1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAvL3NldFRpbWVvdXQodGhpcy5ydW4uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLnJ1bi51c2UodGhpcyk7XG4gICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUZlZWRiYWNrKCkpIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZVNlY3JldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25SdW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgIH1cblxuICAgIG9uUnVuKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uUnVuLnVzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgICAudGhlbih0aGlzLmV4ZWN1dGlvbkVuZF8uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgbGV0IGV2YWx1YXRpb25JbnB1dCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuZXZhbHVhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coZXZhbHVhdGlvbklucHV0KTtcbiAgICAgICAgZXZhbHVhdGlvbklucHV0LnRoZW4oKHVzZXJJbnB1dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ldmFsLnVzZSh0aGlzLCB1c2VySW5wdXQpO1xuICAgICAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUZlZWRiYWNrKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSkge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMub25FdmFsLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uc2hvd0Vycm9ycy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuZXZhbHVhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkV2YWwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMub25FdmFsLnVzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbih0aGlzLmV2YWx1YXRlLmJpbmQodGhpcykpXG4gICAgICAgICAgICAudGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgIH1cblxuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uQ2hhbmdlLnVzZSh0aGlzKTtcbiAgICB9XG5cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIHJldHVybiBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZSgoKSA9PlxuICAgICAgICAgICAgU2suaW1wb3J0TWFpbldpdGhCb2R5KHRoaXMuY29uZmlndXJhdGlvbi5maWxlbmFtZSwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmNvZGUsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN5c21vZHVsZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVkIHdoZW5ldmVyIHRoZSBQeXRob24gY29kZSBjaGFuZ2VzXG4gICAgICovXG4gICAgb25fY2hhbmdlKCkge1xuICAgICAgICBsZXQgRklMRU5BTUUgPSBcIm9uX2NoYW5nZVwiO1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBpbnN0cnVjdG9yIGhhcyBub3QgZGVmaW5lZCBhbnl0aGluZ1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5wcm9ncmFtc1tGSUxFTkFNRV0oKS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0YXR1cyhcImNoYW5naW5nXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUNvZGUoKTtcbiAgICAgICAgLy8gT24gc3RlcCBkb2VzIG5vdCBwZXJmb3JtIHBhcnNlIGFuYWx5c2lzIGJ5IGRlZmF1bHQgb3IgcnVuIHN0dWRlbnQgY29kZVxuICAgICAgICBsZXQgZW5naW5lID0gdGhpcztcbiAgICAgICAgbGV0IGZlZWRiYWNrID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2s7XG4gICAgICAgIGVuZ2luZS5yZXNldFJlcG9ydHMoKTtcbiAgICAgICAgZW5naW5lLnZlcmlmeUNvZGUoKTtcbiAgICAgICAgZW5naW5lLnVwZGF0ZVBhcnNlKCk7XG4gICAgICAgIGVuZ2luZS5ydW5JbnN0cnVjdG9yQ29kZShGSUxFTkFNRSwgdHJ1ZSwgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSkge1xuICAgICAgICAgICAgICAgIC8vIFNVQ0NFU1MsIFNDT1JFLCBDQVRFR09SWSwgTEFCRUwsIE1FU1NBR0UsIERBVEEsIEhJREVcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBvbmx5IHNob3cgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzXG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICEoY2F0ZWdvcnkgPT09IFwiSW5zdHJ1Y3RvclwiICYmIGxhYmVsID09PSBcIk5vIGVycm9yc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBmZWVkYmFjay5wcmVzZW50RmVlZGJhY2soY2F0ZWdvcnksIGxhYmVsLCBtZXNzYWdlLCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5naW5lLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2sobW9kdWxlLiRkKTtcbiAgICAgICAgICAgICAgICBlbmdpbmUubWFpbi5tb2RlbC5leGVjdXRpb24uc3RhdHVzKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbmdpbmUubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcImVuZ2luZVwiLCBcIm9uX2NoYW5nZVwiKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGF0dGVtcHQgdG8gY2FsbCB0aGUgZGVmaW5lZCBvbkV4ZWN1dGlvbkVuZCxcbiAgICAgKiBidXQgd2lsbCBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vIGZ1bmN0aW9uIGRlZmluZWQuXG4gICAgICovXG4gICAgZXhlY3V0aW9uRW5kXygpIHtcbiAgICAgICAgaWYgKHRoaXMub25FeGVjdXRpb25FbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25FeGVjdXRpb25FbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZXhlY3V0aW9uQmVnaW5fKCkge1xuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGlvbkJlZ2luICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0aW9uQmVnaW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4iLCJleHBvcnQgY29uc3QgRU1QVFlfTU9EVUxFID0gXCJsZXQgJGJ1aWx0aW5tb2R1bGUgPSBmdW5jdGlvbihtb2QpeyByZXR1cm4gbW9kOyB9XCI7XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGhvbGRpbmcgc2V0dGluZ3Mgb2YgYSBwYXJ0aWN1bGFyIHJ1biBjb25maWd1cmF0aW9uLlxuICogVGhpcyBpcyB0aGUgcm9vdCBjbGFzcyBmb3IgYWxsIG90aGVyIGNvbmZpZ3VyYXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5c21vZHVsZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICAvLyBBY2Nlc3MgcG9pbnQgZm9yIGluc3RydWN0b3IgZGF0YVxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0cyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgU2suY29uc29sZSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGU7XG4gICAgICAgIFNrLnF1ZXVlZElucHV0ID0gW107XG4gICAgICAgIFNrLmNvbmZpZ3VyZSh0aGlzLmdldFNrdWxwdE9wdGlvbnMoKSk7XG4gICAgICAgIC8vIFNldCBvcGVuRmlsZSBhcyBtZWNoYW5pc20gdG8gcmVhZCBmaWxlc1xuICAgICAgICBTay5pbkJyb3dzZXIgPSB0aGlzLm9wZW5GaWxlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IHJlcXVlc3RzXG4gICAgICAgIFNrLnJlcXVlc3RzR2V0ID0gKHVybCwgZGF0YSwgdGltZW91dCkgPT4gdGhpcy5vcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCk7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFwiZG8geW91IHdhbnQgdG8gd2FpdD8gcHJvbXB0XCJcbiAgICAgICAgU2sudGltZW91dEhhbmRsZXIgPSAodGltZVBhc3NlZCwgZXhlY0xpbWl0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb21wdE1lc3NhZ2UgPSB0aGlzLmdldFRpbWVvdXRQcm9tcHQodGltZVBhc3NlZC8xMDAwID4gMzApO1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gcHJvbXB0KHByb21wdE1lc3NhZ2UsIFNrLmV4ZWNMaW1pdC8xMDAwKTtcbiAgICAgICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCB8fCBkZWxheT09MCkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gU2suZXhlY0xpbWl0ICsgcGFyc2VJbnQoZGVsYXksIDEwKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiBkZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWxheTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0YWNoIGJlZm9yZUNhbGxcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IHRoaXMuYmVmb3JlQ2FsbC5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRUaW1lb3V0UHJvbXB0KGxvbmdUaW1lb3V0KSB7XG4gICAgICAgIGlmIChsb25nVGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIHByb2dyYW0gaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBydW4gKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBpcyB0YWtpbmcgYSB3aGlsZSB0byBydW4uIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2t1bHB0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fZnV0dXJlX186IFNrLnB5dGhvbjMsXG4gICAgICAgICAgICAvLyBpbXBvcnRcbiAgICAgICAgICAgIHJlYWQ6IHRoaXMuaW1wb3J0RmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gb3BlblxuICAgICAgICAgICAgLy9maWxlb3BlbjogdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gZmlsZS53cml0ZVxuICAgICAgICAgICAgZmlsZXdyaXRlOiB0aGlzLndyaXRlRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gcHJpbnRcbiAgICAgICAgICAgIG91dHB1dDogdGhpcy5wcmludC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gaW5wdXRcbiAgICAgICAgICAgIGlucHV0ZnVuOiB0aGlzLmlucHV0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBpbnB1dGZ1blRha2VzUHJvbXB0OiB0cnVlLFxuICAgICAgICAgICAgLy8gTWVkaWEgSW1hZ2UgUHJveHkgVVJMXG4gICAgICAgICAgICBpbWFnZVByb3h5OiB0aGlzLmdldEltYWdlUHJveHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIGtlZXAgdGhlIGdsb2JhbHNcbiAgICAgICAgICAgIHJldGFpbkdsb2JhbHM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFjY2VzcyBTa3VscHQgYnVpbHQtaW5zLiBUaGlzIGlzIHByZXR0eSBnZW5lcmljLCB0YWtlblxuICAgICAqIGFsbW9zdCBkaXJlY3RseSBmcm9tIHRoZSBTa3VscHQgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBweXRob24gZmlsZW5hbWUgKGUuZy4sIFwib3NcIiBvciBcInBwcmludFwiKSB0aGF0IHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIG9mIHRoZSBmaWxlICh3ZWlyZCwgcmlnaHQ/KVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpc24ndCBmb3VuZC5cbiAgICAgKi9cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG5cbiAgICBvcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCkge1xuICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBtb2NrVXJsRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgaWYgKG1vY2tVcmxEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFVSTCBEYXRhIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9ja1VybERhdGEgPSBKU09OLnBhcnNlKG1vY2tVcmxEYXRhLmhhbmRsZSgpKTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gbW9ja1VybERhdGEpIHtcbiAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YS5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2NrVXJsRGF0YVtmaWxlbmFtZV0ubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ja1VybERhdGFbZmlsZW5hbWVdW2ldID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ucmVhZEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWplY3QobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogXCIrdXJsK1wiIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIC8vfSk7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIHdyaXRlRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaW5wdXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIGNsZWFySW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cygpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlucHV0TW9ja0Z1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2sucXVldWVkSW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gU2sucXVldWVkSW5wdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXRJbWFnZVByb3h5KHVybCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgc3RlcCgpIHtcblxuICAgIH1cblxuICAgIGxhc3RTdGVwKCkge1xuXG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0IHN1Y2Nlc3MgZXhlY3V0aW9uXCIpO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3QgZmFpbHVyZSBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmluYWxseShyZXN1bHQpIHtcbiAgICAgICAgLy8gRm9yY2UgUHlnYW1lIHRvIHN0b3AgdHJhcHBpbmcga2V5Ym9hcmQgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHVtbXlPdXRTYW5kYm94KCkge1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC9zYW5kYm94LnB5XCJdID0gXCJjbGFzcyBTYW5kYm94OiBwYXNzXFxuZGVmIHJ1bigpOiBwYXNzXFxuZGVmIHJlc2V0KCk6IHBhc3NcXG5cIjtcbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUUkFDS0lORyBDQUxMXCIsIGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGZhc3RjYWxsIHRvbz8gQ2hlY2sgaG93IHRoYXQgd29ya3MgaW4gU2t1bHB0IHNpZGVcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICBpZiAoIShcImNhbGxzXCIgaW4gc3R1ZGVudE1vZGVsKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZnVuY3Rpb25OYW1lIGluIHN0dWRlbnRNb2RlbC5jYWxscykpIHtcbiAgICAgICAgICAgIHN0dWRlbnRNb2RlbC5jYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgLy8gR2V0IGFjdHVhbCBwYXJhbWV0ZXIgbmFtZXMhIVxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBwb3NhcmdzLmxlbmd0aDsgaSs9IDEpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1wiK2ldID0gcG9zYXJnc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa3dhcmdzICYmIGt3YXJnc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19BUkdTXCJdID0ga3dhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0tXQVJHU1wiXSA9IGt3YXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXS5wdXNoKGFyZ3MpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuLi90cmFjZVwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSwgY29kZSkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdG8gYmUgY3VycmVudGx5IGFkZGVkIGxpbmVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiXyA9IFwiICsgY29kZTtcbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gdHJ1ZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLkFkZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIHRoaXMuY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1FdmFsdWF0ZS5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludFZhbHVlKFNrLmZmaS5yZW1hcFRvSnMobW9kdWxlLiRkLl8uJHIoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnMuanNcIjtcbmltcG9ydCB7JHNrX21vZF9pbnN0cnVjdG9yfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3JcIjtcbmltcG9ydCB7JHNrX21vZF9jb3ZlcmFnZX0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL2NvdmVyYWdlXCI7XG5pbXBvcnQgeyRwZWRhbF90cmFjZXJ9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9wZWRhbF90cmFjZXJcIjtcblxuY29uc3QgVVRJTElUWV9NT0RVTEVfQ09ERSA9IFwidmFyICRidWlsdGlubW9kdWxlID0gXCIgKyAkc2tfbW9kX2luc3RydWN0b3IudG9TdHJpbmcoKTtcbmNvbnN0IENPVkVSQUdFX01PRFVMRV9DT0RFID0gJHNrX21vZF9jb3ZlcmFnZTtcblxuZXhwb3J0IGNsYXNzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIGV4dGVuZHMgQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gSW5zdHJ1Y3RvcnMgZ2V0IDQgc2Vjb25kc1xuICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiA3MDAwO1xuICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAvLyBTdGVwcGVyISBFeGVjdXRlZCBhZnRlciBldmVyeSBzdGF0ZW1lbnQuXG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gbnVsbDsgLy8gMTAgKjEwMDBcbiAgICAgICAgLy8gTXV0ZSBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKHRydWUpO1xuICAgICAgICAvLyBEaXNhYmxlIGlucHV0IGJveFxuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICAvLyBUT0RPIFNrLmlucHV0ZnVuID0gQmxvY2tQeUVuZ2luZS5pbnB1dE1vY2tGdW5jdGlvbjtcbiAgICAgICAgLy8gVE9ETzogQWxsb3cgaW5wdXQgZnVuY3Rpb24gdG8gZGlzYWJsZSB0aGUgdGltZXIsIHNvbWVob3dcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgYmVmb3JlQ2FsbCBjaGVja2VyIHVubGVzcyBzcGVjaWZpY2FsbHkgcmVxdWVzdGVkXG4gICAgICAgIFNrLmJlZm9yZUNhbGxCYWNrdXAgPSBTay5iZWZvcmVDYWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcbiAgICAgICAgLy8gRW5hYmxlIHV0aWxpdHkgbW9kZVxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3V0aWxpdHkvX19pbml0X18uanNcIl0gPSBVVElMSVRZX01PRFVMRV9DT0RFO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2NvdmVyYWdlLnB5XCJdID0gQ09WRVJBR0VfTU9EVUxFX0NPREU7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgbmVlZHMgdG8gYmUgb3B0aW1pemVkXG4gICAgICAgIC8vY29uc3QgUEVEQUxfVFJBQ0VSX01PRFVMRV9DT0RFID0gU2suY29tcGlsZSgkcGVkYWxfdHJhY2VyLCBcInRyYWNlci5weVwiLCBcImV4ZWNcIiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLnB5XCJdID0gJHBlZGFsX3RyYWNlcjtcbiAgICAgICAgZGVsZXRlIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC90cmFjZXIuanNcIl07XG4gICAgICAgIC8vIFRPRE86IE1vY2sgUGVkYWwncyB0cmFjZXIgbW9kdWxlIHdpdGggdGhlIGFwcHJvcHJpYXRlIHZlcnNpb25cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiXSA9IEVNUFRZX01PRFVMRTtcbiAgICAgICAgLy8gUmV1c2UgYW55IGV4aXN0aW5nIHN5c21vZHVsZXMgdGhhdCB3ZSBwcmV2aW91c2x5IGZvdW5kO1xuICAgICAgICB0aGlzLnN5c21vZHVsZXMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcztcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIGxldCAkbWFpbiA9IG5ldyBTay5idWlsdGluLnN0cihcIl9fbWFpbl9fXCIpO1xuICAgICAgICBpZiAodGhpcy5zeXNtb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN5c21vZHVsZXMucXVpY2skbG9va3VwKCRtYWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3lzbW9kdWxlcy5kZWwkaXRlbSgkbWFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBjaGVjayB5b3VyIGNvZGUgKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlIChvciBnZXQgaGVscCBmcm9tIGFuIGluc3RydWN0b3IpLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGlzIHRha2luZyBhIGxpdHRsZSB3aGlsZSB0byBjaGVjayB5b3VyIGNvZGU7IGl0IG1pZ2h0IGp1c3QgbmVlZCBhIGxpdHRsZSBtb3JlIHRpbWUuIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiK2ZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfTU9EVUxFO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgLy9yZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCkgPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG5leHRJbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleChpbnB1dEluZGV4KzEpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHRJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIkFwcGxlUGllXCI7XG4gICAgICAgIH1cbiAgICAgICAgLypyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoU2sucXVldWVkSW5wdXQucG9wKCkpO1xuICAgICAgICB9KTsqL1xuICAgIH1cblxuICAgIGJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpIHtcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiSEVZIElOU1RSVUNUT1IgQ0FMTFwiLCBmdW5jdGlvbk5hbWUsIHN0dWRlbnRNb2RlbC50cmFjaW5nKTtcbiAgICAgICAgaWYgKHN0dWRlbnRNb2RlbC50cmFjaW5nICYmIHN0dWRlbnRNb2RlbC50cmFjaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgc3VwZXIuYmVmb3JlQ2FsbChmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5cbmV4cG9ydCBjbGFzcyBPbkNoYW5nZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwib25fY2hhbmdlLnB5XCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnRyaWdnZXJPbkNoYW5nZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7TkVXX0xJTkVfUkVHRVh9IGZyb20gXCIuL29uX3J1blwiO1xuaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50Q29kZSwgaW5zdHJ1Y3RvckNvZGUsIHF1aWNrLCBpc1NhZmUpIHtcbiAgICBsZXQgc2FmZUNvZGUgPSBKU09OLnN0cmluZ2lmeShzdHVkZW50Q29kZSk7XG4gICAgbGV0IGluZGVudGVkQ29kZSA9IGluZGVudChpbmRlbnQoaXNTYWZlID8gc3R1ZGVudENvZGUgOiBcIk5vbmVcIikpO1xuXG4gICAgcmV0dXJuIGBcbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbiMgQmFja3VwIHRoZSBmZWVkYmFja1xub25fcnVuX2ZlZWRiYWNrID0gW11cbmZvciBmZWVkYmFjayBpbiBNQUlOX1JFUE9SVC5mZWVkYmFjazpcbiAgICBvbl9ydW5fZmVlZGJhY2suYXBwZW5kKGZlZWRiYWNrKVxuTUFJTl9SRVBPUlQuZmVlZGJhY2suY2xlYXIoKVxuXG5mcm9tIHBlZGFsLmVudmlyb25tZW50cy5ibG9ja3B5IGltcG9ydCBzZXR1cF9lbnZpcm9ubWVudFxuIyBBZGQgaW4gZXZhbHVhdGVkIHN0dWZmIGZyb20gbGFzdCB0aW1lXG5zdHVkZW50ID0gZ2V0X3NhbmRib3goKVxuIyBUT0RPOiBXaGF0IGFib3V0IG5ldyBpbnB1dHMgc2luY2Ugd2UgbGFzdCByYW4vZXZhbGVkP1xuTUFJTl9SRVBPUlQuc3VibWlzc2lvbi5maWxlc1snZXZhbHVhdGlvbiddID0gJHtzYWZlQ29kZX1cbmV2YWx1YXRlKCR7c2FmZUNvZGV9KVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4jIFJ1biB0aGUgYWN0dWFsIGluc3RydWN0b3IgY29kZVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiX2luc3RydWN0b3Iub25fZXZhbFwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSB8fCBcIlwiO1xuXG4gICAgICAgIGxldCBkaXNhYmxlVGlmYSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaWZhKCk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgbGV0IHN0dWRlbnRDb2RlU2FmZSA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50LmV2YWx1YXRpb24gfHwgXCJOb25lXCI7XG4gICAgICAgIHRoaXMuZHVtbXlPdXRTYW5kYm94KCk7XG4gICAgICAgIGxldCBpbnN0cnVjdG9yQ29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBpbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRDb2RlU2FmZSwgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsaW5lT2Zmc2V0ID0gaW5zdHJ1Y3RvckNvZGUuc3BsaXQoTkVXX0xJTkVfUkVHRVgpLmxlbmd0aCAtIGxpbmVPZmZzZXQ7XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7XG4gICAgICAgICAgICBcImNvbXBsaW1lbnRzXCI6IFtdLFxuICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBcIi4vX2luc3RydWN0b3Ivb25fZXZhbC5weVwiLFxuICAgICAgICAgICAgXCJjb2RlXCI6IGluc3RydWN0b3JDb2RlLFxuICAgICAgICAgICAgXCJsaW5lT2Zmc2V0XCI6IGxpbmVPZmZzZXRcbiAgICAgICAgICAgIC8vJ2NvbXBsZXRlJzogZmFsc2UgLy8gQWN0dWFsbHksIGxldCdzIHVzZSB1bmRlZmluZWQgZm9yIG5vdy5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG5cbiAgICAgICAgLy9Tay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3IuZ2xvYmFscztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9uRXZhbCBzdWNjZXNzXCIpO1xuICAgICAgICAvLyBUT0RPOiBBY3R1YWxseSBwYXJzZSByZXN1bHRzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzID0gU2suZ2xvYmFscztcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLnN5c21vZHVsZXMgPSBTay5zeXNtb2R1bGVzO1xuICAgICAgICBjb25zb2xlLmxvZyhtb2R1bGUpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG1vZHVsZS4kZC5vbl9ldmFsLiRkO1xuICAgICAgICBjb25zb2xlLmxvZyhtb2R1bGUuJGQpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBzY29yZSkpO1xuICAgICAgICBsZXQgb2xkU2NvcmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZShNYXRoLm1heChvbGRTY29yZSwgc2NvcmUpKTtcbiAgICAgICAgLy8gSGlkZSBzdGF0dXNcbiAgICAgICAgbGV0IGhpZGUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuSElERSk7XG4gICAgICAgIC8vIEFuZCBmaXJlIHRoZSByZXN1bHQhXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNjb3JlLCBzdWNjZXNzLCBoaWRlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAvL2FmdGVyKG1vZHVsZSk7XG5cbiAgICAgICAgLyppZiAoc3VjY2VzcyAmJiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3ModGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaWQoKSk7XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmICghU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufSIsImltcG9ydCB7aW5kZW50fSBmcm9tIFwiLi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBORVdfTElORV9SRUdFWCA9IC9cXHJcXG58XFxyfFxcbi87XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFdSQVBfSU5TVFJVQ1RPUl9DT0RFID0gZnVuY3Rpb24gKHN0dWRlbnRDb2RlLCBpbnN0cnVjdG9yQ29kZSwgcXVpY2ssIGlzU2FmZSkge1xuICAgIGxldCBzYWZlQ29kZSA9IEpTT04uc3RyaW5naWZ5KHN0dWRlbnRDb2RlKTtcbiAgICBsZXQgaW5kZW50ZWRDb2RlID0gaW5kZW50KGluZGVudChpc1NhZmUgPyBzdHVkZW50Q29kZSA6IFwicGFzc1wiKSk7XG4gICAgbGV0IHRpZmFBbmFseXNpcyA9IFwiXCI7XG4gICAgaWYgKCFxdWljaykge1xuICAgICAgICB0aWZhQW5hbHlzaXMgPSBcImZyb20gcGVkYWwudGlmYSBpbXBvcnQgdGlmYV9hbmFseXNpc1xcbnRpZmFfYW5hbHlzaXMoRmFsc2UpXCI7XG4gICAgfVxuICAgIGxldCBza2lwX3RpZmEgPSBxdWljayA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCI7XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gU2sucXVldWVkSW5wdXQgdG8gYmUgcGFzc2VkIGluXG5cbiAgICByZXR1cm4gYFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbmZyb20gcGVkYWwuY29yZS5yZXBvcnQgaW1wb3J0IE1BSU5fUkVQT1JUXG5NQUlOX1JFUE9SVC5jbGVhcigpXG5cbmZyb20gY2lzYzEwOCBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBTZXQgdGhlIHNlZWQgdG8gdGhlIHN1Ym1pc3Npb24gSUQgYnkgZGVmYXVsdD9cbmZyb20gcGVkYWwucXVlc3Rpb25zIGltcG9ydCBzZXRfc2VlZFxuc2V0X3NlZWQoc3RyKGdldF9tb2RlbF9pbmZvKFwic3VibWlzc2lvbi5pZFwiKSkpXG5cbiMgSW5pdGlhbGl6ZSB0aGUgQmxvY2tQeSBlbnZpcm9ubWVudFxucGVkYWwgPSBzZXR1cF9lbnZpcm9ubWVudChza2lwX3RpZmE9JHtza2lwX3RpZmF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3J1bj1za2lwX3J1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzPWlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9maWxlPSdhbnN3ZXIucHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluX2NvZGU9JHtzYWZlQ29kZX0pXG5zdHVkZW50ID0gcGVkYWwuZmllbGRzWydzdHVkZW50J11cblxuIyBUT0RPOiBSZWZhY3RvciByZXNvbHZlciB0byByZXR1cm4gaW5zdHJ1Y3Rpb25zXG4jIE1vbmtleS1wYXRjaCBxdWVzdGlvbnNcbiNmcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbiNxdWVzdGlvbnMuc2hvd19xdWVzdGlvbiA9IHNldF9pbnN0cnVjdGlvbnNcblxuIyBSdW4gdGhlIGFjdHVhbCBpbnN0cnVjdG9yIGNvZGVcbiR7aW5zdHJ1Y3RvckNvZGV9XG5cbiMgUmVzb2x2ZSBldmVyeXRoaW5nXG5mcm9tIHBlZGFsLnJlc29sdmVycy5zaW1wbGUgaW1wb3J0IHJlc29sdmVcbmZpbmFsID0gcmVzb2x2ZSgpXG5TVUNDRVNTID0gZmluYWwuc3VjY2Vzc1xuU0NPUkUgPSBmaW5hbC5zY29yZVxuQ0FURUdPUlkgPSBmaW5hbC5jYXRlZ29yeVxuTEFCRUwgPSBmaW5hbC50aXRsZVxuTUVTU0FHRSA9IGZpbmFsLm1lc3NhZ2VcbkRBVEEgPSBmaW5hbC5kYXRhXG5ISURFID0gZmluYWwuaGlkZV9jb3JyZWN0bmVzc1xuXG4jIEhhbmRsZSBxdWVzdGlvbnNcbmlmIGZpbmFsLmluc3RydWN0aW9uczpcbiAgICBzZXRfaW5zdHJ1Y3Rpb25zKGZpbmFsLmluc3RydWN0aW9uc1stMV0ubWVzc2FnZSlcbiAgICBcbiMgSGFuZGxlIHBvc2l0aXZlIGZlZWRiYWNrXG5QT1NJVElWRSA9IFtdXG5mb3IgcG9zaXRpdmUgaW4gZmluYWwucG9zaXRpdmVzOlxuICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5tZXNzYWdlXG4gICAgaWYgbm90IHBvc2l0aXZlOlxuICAgICAgICBtZXNzYWdlID0gcG9zaXRpdmUuZWxzZV9tZXNzYWdlXG4gICAgUE9TSVRJVkUuYXBwZW5kKHtcbiAgICAgICAgXCJ0aXRsZVwiOiBwb3NpdGl2ZS50aXRsZSxcbiAgICAgICAgXCJsYWJlbFwiOiBwb3NpdGl2ZS5sYWJlbCxcbiAgICAgICAgXCJtZXNzYWdlXCI6IG1lc3NhZ2VcbiAgICB9KVxuICAgIFxuIyBIYW5kbGUgc3lzdGVtIG1lc3NhZ2VzXG5mb3Igc3lzdGVtIGluIGZpbmFsLnN5c3RlbXM6XG4gICAgaWYgc3lzdGVtLmxhYmVsID09ICdsb2cnOlxuICAgICAgICBjb25zb2xlX2xvZyhzeXN0ZW0udGl0bGUsIHN5c3RlbS5tZXNzYWdlKTtcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2RlYnVnJzpcbiAgICAgICAgY29uc29sZV9kZWJ1ZyhzeXN0ZW0udGl0bGUsIHN5c3RlbS5tZXNzYWdlKTtcblxuYDtcbn07XG5cbmV4cG9ydCBjbGFzcyBPblJ1bkNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiX2luc3RydWN0b3Iub25fcnVuXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuKCk7XG5cbiAgICAgICAgbGV0IGRpc2FibGVUaWZhID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpZmEoKTtcblxuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICAvL2xldCBzdHVkZW50Q29kZVNhZmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIGxldCBzdHVkZW50Q29kZVNhZmUgPSB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKTtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGluc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGg7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudENvZGVTYWZlLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGxpbmVPZmZzZXQgPSAwOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGggLSBsaW5lT2Zmc2V0IC0gNDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIC8vIFRPRE8gTG9nZ2luZyEhISFcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk9uUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtb2R1bGUuJGQub25fcnVuLiRkO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgob2xkU2NvcmUsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc2NvcmUpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk9uUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufVxuXG5cbi8qXG4jIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG9sZCBpbnN0cnVjdG9yIGNvZGUsIGxlYXZpbmcgaXQgaGVyZSBmb3Igbm93LlxuXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbk1BSU5fUkVQT1JULmNsZWFyKClcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgY29udGV4dHVhbGl6ZV9yZXBvcnRcbmNvbnRleHR1YWxpemVfcmVwb3J0KCR7c2FmZUNvZGV9LCBcImFuc3dlci5weVwiKVxuJHt0aWZhQW5hbHlzaXN9XG5mcm9tIHBlZGFsLnNhbmRib3guc2FuZGJveCBpbXBvcnQgU2FuZGJveFxuZnJvbSBwZWRhbC5zYW5kYm94IGltcG9ydCBjb21wYXRpYmlsaXR5XG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcbnN0dWRlbnQgPSBNQUlOX1JFUE9SVFsnc2FuZGJveCddWydydW4nXSA9IFNhbmRib3goKVxuc3R1ZGVudC5yZXBvcnRfZXhjZXB0aW9uc19tb2RlID0gVHJ1ZVxubG9nKGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbnN0dWRlbnQuc2V0X2lucHV0KGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbmlmIG5vdCBnZXRfbW9kZWxfaW5mbygnYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlSW5zdHJ1Y3RvclJ1bicpOlxuICAgIGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnQocmFpc2VfZXhjZXB0aW9ucz1GYWxzZSlcbiNsb2coc3R1ZGVudC5kYXRhKVxuI3N0dWRlbnQgPSBnZXRfc3R1ZGVudF9kYXRhKClcbiNlcnJvciwgcG9zaXRpb24gPSBnZXRfc3R1ZGVudF9lcnJvcigpXG4jY29tcGF0aWJpbGl0eS5yYWlzZV9leGNlcHRpb24oZXJyb3IsIHBvc2l0aW9uKVxucnVuX3N0dWRlbnQgPSBjb21wYXRpYmlsaXR5LnJ1bl9zdHVkZW50XG5yZXNldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LnJlc2V0X291dHB1dFxucXVldWVfaW5wdXQgPSBjb21wYXRpYmlsaXR5LnF1ZXVlX2lucHV0XG5nZXRfb3V0cHV0ID0gY29tcGF0aWJpbGl0eS5nZXRfb3V0cHV0XG5nZXRfcGxvdHMgPSBjb21wYXRpYmlsaXR5LmdldF9wbG90c1xuY29tcGF0aWJpbGl0eS50cmFjZV9saW5lcyA9IHRyYWNlX2xpbmVzXG5mcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbnF1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuIyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgZm9yIHRoaXMgaGFjayFcbmRlZiBjYXB0dXJlX291dHB1dChmdW5jLCAqYXJncyk6XG4gICByZXNldF9vdXRwdXQoKVxuICAgc3R1ZGVudC5jYWxsKGZ1bmMuX19uYW1lX18sICphcmdzKVxuICAgcmV0dXJuIGdldF9vdXRwdXQoKVxuY29tcGF0aWJpbGl0eS5jYXB0dXJlX291dHB1dCA9IGNhcHR1cmVfb3V0cHV0XG5cbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuJHtpbnN0cnVjdG9yQ29kZX1cbmZyb20gcGVkYWwucmVzb2x2ZXJzIGltcG9ydCBzaW1wbGVcbmZpbmFsID0gc2ltcGxlLnJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuICovIiwiaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL29uX3J1blwiO1xuXG5leHBvcnQgY2xhc3MgT25TYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgT25SdW5Db25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9ydW4ucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuXG5leHBvcnQgY2xhc3MgUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKTtcbiAgICAgICAgLy90aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlRmlsZShcImFuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCksIG51bGwpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuY29kZSk7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIGVuZ2luZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnNlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1widmVyaWZpZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogQm9vbGVhbih0aGlzLmNvZGUudHJpbSgpKSxcbiAgICAgICAgICAgIFwiY29kZVwiOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBcImlucHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICAgIFwib3V0cHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCgpLm1hcChsaW5lID0+IGxpbmUuY29udGVudCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJcIiwgXCJcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmZpbmlzaFR1cnRsZXMoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKFNrLmdsb2JhbHMpO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5yZXN1bHRzID0gbW9kdWxlO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmJlZ2luRXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnQucGFyc2VyLnN1Y2Nlc3MgJiYgcmVwb3J0LnZlcmlmaWVyLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJSdW4uUHJvZ3JhbVwiLCBcIlByb2dyYW1FcnJvck91dHB1dFwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVhbExpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5maWx0ZXIoeCA9PiAheC5pc0RvY3N0cmluZykubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcImlucHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgXCJjYWxsc1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY2FsbHMsXG4gICAgICAgICAgICAgICAgXCJ0cmFjaW5nXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBUT0RPOiBGaXggdG8gYmUgdGhlIGN1cnJlbnQgc2FtcGxlIHN1Ym1pc3Npb25cbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyLnB5XCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwicHJpbnQoJ05vdCByZWFkeSB5ZXQhJylcIjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtDb25maWd1cmF0aW9uLCBFTVBUWV9NT0RVTEV9IGZyb20gXCIuL2NvbmZpZ3VyYXRpb25zXCI7XG5cbmV4cG9ydCBjbGFzcyBTdHVkZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIExpbWl0IGV4ZWN1dGlvbiB0byA0IHNlY29uZHNcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdGhpcy5tYWluLm1vZGVsLnNldHRpbmdzO1xuICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiA1MDAwO1xuICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAvLyBTdGVwcGVyISBFeGVjdXRlZCBhZnRlciBldmVyeSBzdGF0ZW1lbnQuXG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gdGhpcy5zdGVwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gVW5tdXRlIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoZmFsc2UpO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZWFjaCBzdGVwXG4gICAgICAgIC8vIGFmdGVyU2luZ2xlRXhlY3V0aW9uXG5cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gRU1QVFlfTU9EVUxFO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9wZW5GaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coZmlsZW5hbWUsIGZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogXCIrZmlsZW5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9yYmlkZGVuKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJGaWxlIG5vdCBhY2Nlc3NpYmxlOiAnXCIgKyBmaWxlbmFtZSArIFwiJ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJCdWlsdC1pbiBtb2R1bGVzIG5vdCBhY2Nlc3NpYmxlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogJ1wiK2ZpbGVuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuaW5wdXQocHJvbXB0TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJzcmMvbGliL3V0aWxpdHkvXCIpIHx8XG4gICAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwic3JjL2xpYi9wZWRhbC9cIikgfHxcbiAgICAgICAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIuL19pbnN0cnVjdG9yL1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcIlN0ZXBzXCIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY29kZSwgbWVhbnQgdG8gYmUgdXNlZCBhcyBhIGNhbGxiYWNrIHRvIHRoZSBTa3VscHRcbiAgICAgKiBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGdsb2JhbCB2YXJpYWJsZXMgKFN0cmluZ3MpIHRvIHRoZWlyIFNrdWxwdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGxvY2FsIHZhcmlhYmxlcyAoU3RyaW5ncykgdG8gdGhlaXIgU2t1bHB0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lTnVtYmVyIC0gVGhlIGNvcnJlc3BvbmRpbmcgbGluZSBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbk51bWJlciAtIFRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaW5rIG9mIGl0IGFzIHRoZSBcIlhcIiBwb3NpdGlvbiB0byB0aGUgbGluZU51bWJlcidzIFwiWVwiIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBweXRob24gZmlsZSBiZWluZyBleGVjdXRlZCAoZS5nLiwgXCJfX21haW5fXy5weVwiKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRG9jc3RyaW5nIC0gV2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhY3R1YWwgbGluZSBvciBhIGRvY3N0cmluZy5cbiAgICAgKi9cbiAgICBzdGVwKGdsb2JhbHMsIGxvY2FscywgbGluZU51bWJlciwgY29sdW1uTnVtYmVyLCBmaWxlbmFtZSwgaXNEb2NzdHJpbmcpIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcDtcbiAgICAgICAgICAgIGdsb2JhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMoZ2xvYmFscyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBUcmFjZSBsb2NhbCB2YXJpYWJsZXMgcHJvcGVybHlcbiAgICAgICAgICAgIC8vbGV0IGxvY2FscyA9IHRoaXMubWFpbi5jb21wb25lbnRzLnRyYWNlLnBhcnNlR2xvYmFscyhsb2NhbHMpO1xuICAgICAgICAgICAgLy9PYmplY3QuYXNzaWduKGdsb2JhbHMsIGxvY2Fscyk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJzdGVwXCI6IGN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgICAgIFwiZmlsZW5hbWVcIjogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgLy8nYmxvY2snOiBoaWdobGlnaHRNYXBbbGluZU51bWJlci0xXSxcbiAgICAgICAgICAgICAgICBcImxpbmVcIjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBcImNvbHVtblwiOiBjb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IGdsb2JhbHMucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBcIm1vZHVsZXNcIjogZ2xvYmFscy5tb2R1bGVzLFxuICAgICAgICAgICAgICAgIFwiaXNEb2NzdHJpbmdcIjogaXNEb2NzdHJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAgPSBjdXJyZW50U3RlcCArIDE7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBTa3VscHQgZXhlY3V0aW9uIHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uQnVmZmVyXG4gICAgICogYW5kIGhhbmQgaXQgb2ZmIHRvIHRoZSBleGVjdXRpb24gdHJhY2UgaW4gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGxhc3RTdGVwKCkge1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0TGluZSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgIH07XG5cbiAgICBnZXRMaW5lcyhhc3QpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWRMaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHZpc2l0Qm9keSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5saW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRMaW5lcy5hZGQobm9kZS5saW5lbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYm9keS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9yZWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUub3JlbHNlLmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZmluYWxib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maW5hbGJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0Qm9keShhc3QpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpdGVkTGluZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZSBwYXJzZSBpbmZvcm1hdGlvbiBpcyB1cC10by1kYXRlXG4gICAgICovXG4gICAgdXBkYXRlUGFyc2UoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIC8vIEhvbGQgYWxsIHRoZSBhY3R1YWxseSBkaXNjb3ZlcmVkIGxpbmVzIGZyb20gdGhlIHBhcnNlXG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAvLyBBdHRlbXB0IGEgcGFyc2VcbiAgICAgICAgbGV0IGFzdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwYXJzZSA9IFNrLnBhcnNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICBhc3QgPSBTay5hc3RGcm9tUGFyc2UocGFyc2UuY3N0LCB0aGlzLmZpbGVuYW1lLCBwYXJzZS5mbGFncyk7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ2V0TGluZXMoYXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlcG9ydCB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImVtcHR5XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5maWxlbmFtZSwgdGhpcy5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWNjZXNzZnVsIHBhcnNlXG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJhc3RcIjogYXN0LFxuICAgICAgICAgICAgXCJlbXB0eVwiOiBhc3QuYm9keS5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBcImxpbmVzXCI6IGxpbmVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNob3dFcnJvcnMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZVNlY3JldEVycm9yKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgaWYgKCFyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckJ1dHRvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZmVlZGJhY2sucHJlc2VudFJ1bkVycm9yKHJlcG9ydC5zdHVkZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLmF0dHIoXCJ0aXRsZVwiLCBcIkNsaWNrIHRvIHNlZSBPcmlnaW5hbCBFcnJvclwiKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnRvb2x0aXAoe1widHJpZ2dlclwiOiBcImhvdmVyXCIsIFwiY29udGFpbmVyXCI6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludH0pO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uY2xpY2soKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUihtZXNzYWdlKSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IGxldCBGRUVEQkFDS19IVE1MID0gYFxuXG48c3BhbiBjbGFzcz0nYmxvY2tweS1mbG9hdGluZy1mZWVkYmFjayB0ZXh0LW11dGVkLWxlc3MgcHVsbC1yaWdodCBwb3NpdGlvbi1zdGlja3kgc3RpY2t5LXRvcCdcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1sYWJlbD1cIk5ldyBGZWVkYmFjayBBbGVydFwiPlxuICAgIE5ldyBmZWVkYmFjayAmdWFycjtcbjwvc3Bhbj5cblxuPGRpdiBjbGFzcz0nYmxvY2tweS1mZWVkYmFjayBjb2wtbWQtNiBibG9ja3B5LXBhbmVsJ1xuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJGZWVkYmFja1wiXG4gICAgICAgICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIj5cblxuICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0J1xuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuc2Vjb25kUm93LnN3aXRjaExhYmVsXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIFxuICAgIDwhLS0gUG9zaXRpdmUgRmVlZGJhY2sgUmVnaW9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlIGZsb2F0LXJpZ2h0XCI+XG4gICAgICAgIFxuICAgIFxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBBY3R1YWwgRmVlZGJhY2sgUmVnaW9uIC0tPiAgICBcbiAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nPkZlZWRiYWNrOiA8L3N0cm9uZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2JhZGdlIGJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnkgZmVlZGJhY2stYmFkZ2UnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHVpLmZlZWRiYWNrLmJhZGdlLFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5mZWVkYmFjay5jYXRlZ29yeVwiPkZlZWRiYWNrIEtpbmQ8L3NwYW4+XG4gICAgICAgIDxzbWFsbCBkYXRhLWJpbmQ9XCJ0ZXh0OiAoMTAwKnN1Ym1pc3Npb24uc2NvcmUoKSkrJyUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBkaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKVwiXG4gICAgICAgICAgICBjbGFzcz1cInRleHQtbXV0ZWRcIj48L3NtYWxsPlxuICAgIDwvZGl2PlxuICAgIDxkaXY+XG4gICAgICAgIDxzdHJvbmcgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInRleHQ6IGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbFwiPjwvc3Ryb25nPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IGV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj4gICAgICAgICAgICBcbmA7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmVlZGJhY2sge1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgZmVlZGJhY2sgYXJlYSwgd2hlcmUgdXNlcnMgYXJlIHRvbGQgdGhlIHN0YXRlIG9mIHRoZWlyXG4gICAgICogcHJvZ3JhbSdzIGV4ZWN1dGlvbiBhbmQgZ2l2ZW4gZ3VpZGFuY2UuIEFsc28gbWFuYWdlcyB0aGUgY3JlYXRpb24gb2YgdGhlIFRyYWNlIFRhYmxlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRoaXMge0Jsb2NrUHlGZWVkYmFja31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjaztcblxuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWNhdGVnb3J5XCIpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbWVzc2FnZVwiKTtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZVwiKTtcblxuICAgICAgICAvLyBUT0RPOiBJZiB0aGV5IGNoYW5nZSB0aGUgc3R1ZGVudCBleHRyYSBmaWxlcywgYWxzbyB1cGRhdGUgdGhlIGRpcnR5IGZsYWdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNjcmVlbiAodGFrZXMgMSBzZWNvbmQpIHRvIG1ha2UgdGhlIEZlZWRiYWNrIGFyZWEgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgJChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMudGFnLm9mZnNldCgpLnRvcFxuICAgICAgICB9LCAxMDAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZmVlZGJhY2sgYXJlYSBpcyBjdXJyZW50bHkgdmlzaWJsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRmVlZGJhY2tWaXNpYmxlKCkge1xuICAgICAgICBsZXQgdmlzaWJpbGl0eUJ1ZmZlciA9IDEwMDtcbiAgICAgICAgbGV0IHRvcE9mRWxlbWVudCA9IHRoaXMudGFnLm9mZnNldCgpLnRvcDtcbiAgICAgICAgLy9sZXQgYm90dG9tT2ZFbGVtZW50ID0gdGhpcy50YWcub2Zmc2V0KCkudG9wICsgdGhpcy50YWcub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgbGV0IGJvdHRvbU9mRWxlbWVudCA9IHRvcE9mRWxlbWVudCArIHZpc2liaWxpdHlCdWZmZXI7XG4gICAgICAgIGxldCBib3R0b21PZlNjcmVlbiA9ICQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKTtcbiAgICAgICAgbGV0IHRvcE9mU2NyZWVuID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgICAgICAvL2JvdHRvbV9vZl9lbGVtZW50IC09IDQwOyAvLyBVc2VyIGZyaWVuZGx5IHBhZGRpbmdcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0b3BPZkVsZW1lbnQgPCBib3R0b21PZlNjcmVlbikgJiZcbiAgICAgICAgICAgICh0b3BPZlNjcmVlbiA8IGJvdHRvbU9mRWxlbWVudCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYW55IG91dHB1dCBjdXJyZW50bHkgaW4gdGhlIGZlZWRiYWNrIGFyZWEuIEFsc28gcmVzZXRzIHRoZSBwcmludGVyIGFuZFxuICAgICAqIGFueSBoaWdobGlnaHRlZCBsaW5lcyBpbiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShcIipSZWFkeSpcIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5jYXRlZ29yeShudWxsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuaGlkZGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZC5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5jbGVhclBvc2l0aXZlRmVlZGJhY2soKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGZpbmRGaXJzdEVycm9yTGluZShmZWVkYmFja0RhdGEpIHtcbiAgICAgICAgaWYgKGZlZWRiYWNrRGF0YS5xdWljayRsb29rdXApIHtcbiAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IGZlZWRiYWNrRGF0YS5xdWljayRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKFwibG9jYXRpb25cIikpO1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBsb2NhdGlvbi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcImxpbmVcIikpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb0pzKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLypmb3IgKGxldCBpID0gZmVlZGJhY2tEYXRhLmxlbmd0aC0xOyBpID49IDA7IGktPSAxKSB7XG4gICAgICAgICAgICBpZiAoXCJwb3NpdGlvblwiIGluIGZlZWRiYWNrRGF0YVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWVkYmFja0RhdGFbaV0ucG9zaXRpb24ubGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDsqL1xuICAgIH07XG5cbiAgICB1cGRhdGVSZWd1bGFyRmVlZGJhY2soKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtb2RlbCB3aXRoIHRoZXNlIG5ldyBleGVjdXRpb24gcmVzdWx0c1xuICAgICAqIEBwYXJhbSBleGVjdXRpb25SZXN1bHRzXG4gICAgICovXG4gICAgdXBkYXRlRmVlZGJhY2soZXhlY3V0aW9uUmVzdWx0cykge1xuICAgICAgICAvLyBQYXJzZSBvdXQgZGF0YVxuICAgICAgICBsZXQgbWVzc2FnZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5NRVNTQUdFKTtcbiAgICAgICAgbGV0IGNhdGVnb3J5ID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLkNBVEVHT1JZKTtcbiAgICAgICAgbGV0IGxhYmVsID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLkxBQkVMKTtcbiAgICAgICAgbGV0IGhpZGUgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuSElERSk7XG4gICAgICAgIGxldCBkYXRhID0gZXhlY3V0aW9uUmVzdWx0cy5EQVRBO1xuICAgICAgICBsZXQgcG9zaXRpdmVzID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLlBPU0lUSVZFKTtcblxuICAgICAgICAvLyBPdmVycmlkZSBiYXNlZCBvbiBhc3NpZ25tZW50cycgc2V0dGluZ3NcbiAgICAgICAgbGV0IGhpZGVTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpO1xuICAgICAgICBpZiAoaGlkZVNjb3JlICYmIGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICAgICAgbGFiZWwgPSBcIk5vIGVycm9yc1wiO1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTm8gZXJyb3JzIHJlcG9ydGVkLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtYXAgdG8gZXhwZWN0ZWQgQmxvY2tQeSBsYWJlbHNcbiAgICAgICAgaWYgKGNhdGVnb3J5LnRvTG93ZXJDYXNlKCkgPT09IFwiaW5zdHJ1Y3RvclwiICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkgPT09IFwiZXhwbGFpblwiKSB7XG4gICAgICAgICAgICBsYWJlbCA9IFwiSW5zdHJ1Y3RvciBGZWVkYmFja1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgcHJlc2VudCBhIGxhY2sgb2YgZXJyb3IgYXMgYmVpbmcgaW5jb3JyZWN0XG4gICAgICAgIGlmIChjYXRlZ29yeSA9PT0gXCJJbnN0cnVjdG9yXCIgJiYgbGFiZWwgPT09IFwiTm8gZXJyb3JzXCIpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gXCJubyBlcnJvcnNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBtb2RlbCBhY2NvcmRpbmdseVxuICAgICAgICBtZXNzYWdlID0gdGhpcy5tYWluLnV0aWxpdGllcy5tYXJrZG93bihtZXNzYWdlKS5yZXBsYWNlKC88cHJlPlxcbi9nLCBcIjxwcmU+XFxuXFxuXCIpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgLy9sZXQgaGlnaGxpZ2h0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm1lc3NhZ2UuZmluZChcInByZSBjb2RlXCIpLm1hcCggKGksIGJsb2NrKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgIH0pO1xuICAgICAgICAvL30sIDQwMCk7XG4gICAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdHJhY2tpbmcgc3R1ZGVudCBmaWxlLCBsZXQncyB0cmFjayB0aGUgaW5zdHJ1Y3RvciBmaWxlXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkludGVydmVudGlvblwiLCBjYXRlZ29yeSwgbGFiZWwsIG1lc3NhZ2UsIFwiYW5zd2VyLnB5XCIpO1xuXG4gICAgICAgIC8vIENsZWFyIG91dCBhbnkgcHJldmlvdXNseSBoaWdobGlnaHRlZCBsaW5lc1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3Igb24gYSBsaW5lIGFuZCByZXBvcnQgdGhhdFxuICAgICAgICBsZXQgbGluZSA9IEJsb2NrUHlGZWVkYmFjay5maW5kRmlyc3RFcnJvckxpbmUoZGF0YSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAobGluZSAhPT0gbnVsbCAmJiBsaW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnQgdGhlIHNldCBvZiB0cmFjZWQgbGluZXNcbiAgICAgICAgbGV0IHN0dWRlbnRSZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkLnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAoc3R1ZGVudFJlcG9ydC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgdW5jb3ZlcmVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5wYXJzZXIubGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHVkZW50UmVwb3J0LmxpbmVzLmluZGV4T2YobGluZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuY292ZXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQodW5jb3ZlcmVkTGluZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBvc2l0aXZlcy5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGl2ZURhdGEgPSBwb3NpdGl2ZXNbaV07XG4gICAgICAgICAgICB0aGlzLmFkZFBvc2l0aXZlRmVlZGJhY2socG9zaXRpdmVEYXRhLm1lc3NhZ2UsIFwic3RhclwiLCBcImdyZWVuXCIsICgpID0+IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5QT1NJVElWRV9GRUVEQkFDS19GVUxMKHBvc2l0aXZlRGF0YS50aXRsZSwgcG9zaXRpdmVEYXRhLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyUG9zaXRpdmVGZWVkYmFjaygpIHtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LXN0dWRlbnQtZXJyb3JcIikuaGlkZSgpO1xuICAgIH1cblxuICAgIGFkZFBvc2l0aXZlRmVlZGJhY2sodGV4dCwgaWNvbiwgY29sb3IsIG9uY2xpY2ssIHRvRW5kKSB7XG4gICAgICAgIGxldCBwb3NpdGl2ZSA9ICQoXCI8c3Bhbj48L3NwYW4+XCIpO1xuICAgICAgICBwb3NpdGl2ZS5hZGRDbGFzcyhcImJsb2NrcHktZmVlZGJhY2stcG9zaXRpdmUtaWNvbiBmYXMgZmEtXCIraWNvbik7XG4gICAgICAgIHBvc2l0aXZlLmNzcyhcImNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgcG9zaXRpdmUuYXR0cihcInRpdGxlXCIsIHRleHQpO1xuICAgICAgICBpZiAodG9FbmQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpdmUuYXBwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpdmUucHJlcGVuZChwb3NpdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUudG9vbHRpcCh7XCJ0cmlnZ2VyXCI6IFwiaG92ZXJcIiwgXCJjb250YWluZXJcIjogdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYXR0YWNobWVudFBvaW50fSk7XG4gICAgICAgIGlmIChvbmNsaWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvc2l0aXZlLmNsaWNrKG9uY2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aXZlLmhvdmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmVlZGJhY2tcIiwgXCJwb3NpdGl2ZVwiLCBcImhvdmVyXCIsIHRleHQsIFwiXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVzZW50IGFueSBhY2N1bXVsYXRlZCBmZWVkYmFja1xuICAgICAqL1xuICAgIHByZXNlbnRGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmVlZGJhY2soZXhlY3V0aW9uUmVzdWx0cyk7XG5cbiAgICAgICAgLy8gVE9ETzogTG9nZ2luZ1xuICAgICAgICAvL3RoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcImZlZWRiYWNrXCIsIGNhdGVnb3J5K1wifFwiK2xhYmVsLCBtZXNzYWdlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUZlZWRiYWNrVXBkYXRlKCk7XG4gICAgfTtcblxuICAgIG5vdGlmeUZlZWRiYWNrVXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNGZWVkYmFja1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZsb2F0aW5nLWZlZWRiYWNrXCIpLnNob3coKS5mYWRlT3V0KDcwMDApO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByZXNlbnRSdW5FcnJvcihlcnJvciwganVzdF9yZXR1cm4pIHtcbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGp1c3RfcmV0dXJuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UsIGxhYmVsLCBjYXRlZ29yeSwgbGluZW5vO1xuICAgICAgICBsYWJlbCA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGNhdGVnb3J5ID0gXCJydW50aW1lXCI7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvcik7XG5cbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCAmJiBsaW5lbm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZW5vKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWxkVHJhY2ViYWNrKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvci50cmFjZWJhY2subWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lbm8gPSBmcmFtZS5saW5lbm87XG4gICAgICAgICAgICBpZiAoZnJhbWUuZmlsZW5hbWUuc2xpY2UoMCwgLTMpID09PSBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgbGluZW5vIC09IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5pbnN0cnVjdG9yLmxpbmVPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlsZSA9IGBGaWxlIDxjb2RlIGNsYXNzPVwiZmlsZW5hbWVcIj5cIiR7ZnJhbWUuZmlsZW5hbWV9XCI8L2NvZGU+LCBgO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBgb24gbGluZSA8Y29kZSBjbGFzcz1cImxpbmVub1wiPiR7bGluZW5vfTwvY29kZT4sIGA7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSAoZnJhbWUuc2NvcGUgIT09IFwiPG1vZHVsZT5cIiAmJlxuICAgICAgICAgICAgZnJhbWUuc2NvcGUgIT09IHVuZGVmaW5lZCkgPyBgaW4gc2NvcGUgJHtmcmFtZS5zY29wZX1gIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGZyYW1lLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gYFxcbjxwcmU+PGNvZGU+JHtmcmFtZS5zb3VyY2V9PC9jb2RlPjwvcHJlPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZSArIGxpbmUgKyBzY29wZSArIHNvdXJjZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udmVydFNrdWxwdEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkLCBpc0luc3RydWN0b3IpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBlcnJvci50cCRuYW1lO1xuICAgICAgICBsZXQgYXJncyA9IFNrLmZmaS5yZW1hcFRvSnMoZXJyb3IuYXJncyk7XG4gICAgICAgIGxldCB0b3AgPSBgJHtuYW1lfTogJHthcmdzWzBdfVxcbjxicj5cXG48YnI+YDtcbiAgICAgICAgbGV0IHRyYWNlYmFjayA9IFwiXCI7XG4gICAgICAgIGlmIChuYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyICYmIGVycm9yLmVyci50cmFjZWJhY2sgJiYgZXJyb3IuZXJyLnRyYWNlYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxGcmFtZXMgPSB0aGlzLmJ1aWxkVHJhY2ViYWNrKGVycm9yLmVyciwgZmlsZW5hbWVFeGVjdXRlZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW1wiVHJhY2ViYWNrOlwiXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRnJhbWVzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsRnJhbWVzLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLi4uIEhpZGluZyAke2FsbEZyYW1lcy5sZW5ndGggLSAzfSBvdGhlciBzdGFjayBmcmFtZXMgLi4uLGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFsbEZyYW1lcy5zbGljZSgtMywgLTIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5hbGxGcmFtZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjZWJhY2sgPSByZXN1bHQuam9pbihcIlxcbjxicj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gXCJFcnJvciBpbiBpbnN0cnVjdG9yIGZlZWRiYWNrLiBQbGVhc2Ugc2hvdyB0aGUgZm9sbG93aW5nIHRvIGFuIGluc3RydWN0b3I6PGJyPlxcblwiK3RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci50cmFjZWJhY2sgJiYgZXJyb3IudHJhY2ViYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRyYWNlYmFjayA9IFwiVHJhY2ViYWNrOjxicj5cXG5cIiArIHRoaXMuYnVpbGRUcmFjZWJhY2soZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpLmpvaW4oXCJcXG48YnI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3ArXCJcXG5cIit0cmFjZWJhY2s7XG4gICAgfVxuXG4gICAgcHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoXCJydW50aW1lXCIpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbChcIlRpbWVvdXQgRXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KFwiaW50ZXJuYWxcIik7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKFwiSW50ZXJuYWwgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUZlZWRiYWNrVXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1TeXN0ZW0uRXJyb3JcIiwgXCJpbnRlcm5hbFwiLCBcIkludGVybmFsIEVycm9yXCIsIG1lc3NhZ2UsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQge2ZpcnN0RGVmaW5lZFZhbHVlfSBmcm9tIFwidXRpbGl0aWVzLmpzXCI7XG5cbi8vICR7bWFrZVRhYihcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIlVSTCBEYXRhXCIsIHRydWUpfVxuXG5jb25zdCBtYWtlVGFiID0gZnVuY3Rpb24oZmlsZW5hbWUsIGZyaWVuZGx5TmFtZSwgaGlkZUlmRW1wdHksIG5vdEluc3RydWN0b3IpIHtcbiAgICBpZiAoZnJpZW5kbHlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJpZW5kbHlOYW1lID0gZmlsZW5hbWU7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJcIjtcbiAgICBsZXQgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwidHJ1ZVwiO1xuICAgIGlmICghbm90SW5zdHJ1Y3Rvcikge1xuICAgICAgICBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiO1xuICAgICAgICBoaWRlSWZOb3RJbnN0cnVjdG9yID0gXCJkaXNwbGF5Lmluc3RydWN0b3IoKVwiO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtICR7aW5zdHJ1Y3RvckZpbGVDbGFzc31cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5maWxlbmFtZSgpID09PSAnJHtmaWxlbmFtZX0nfSxcbiAgICAgICAgICAgICAgICBjbGljazogZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCAnJHtmaWxlbmFtZX0nKSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAoISR7aGlkZUlmRW1wdHl9IHx8IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCcke2ZpbGVuYW1lfScpKSAmJiAke2hpZGVJZk5vdEluc3RydWN0b3J9XCI+XG4gICAgICAgICAgICAke2ZyaWVuZGx5TmFtZX08L2E+XG4gICAgPC9saT5gO1xufTtcblxuZXhwb3J0IGxldCBGSUxFU19IVE1MID0gYFxuPGRpdiBjbGFzcz1cImNvbC1tZC0xMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktZmlsZXNcIlxuICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmZpbGVzLnZpc2libGVcIj5cbjx1bCBjbGFzcz1cIm5hdiBuYXYtdGFic1wiIHJvbGU9XCJ0YWJsaXN0XCI+XG5cbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICA8c3Ryb25nPlZpZXc6IDwvc3Ryb25nPlxuICAgIDwvbGk+XG5cbiAgICAke21ha2VUYWIoXCJhbnN3ZXIucHlcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiFpbnN0cnVjdGlvbnMubWRcIiwgXCJJbnN0cnVjdGlvbnNcIil9XG4gICAgJHttYWtlVGFiKFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiLCBcIlNldHRpbmdzXCIpfVxuICAgICR7bWFrZVRhYihcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiU3RhcnRpbmcgQ29kZVwiKX1cbiAgICAke21ha2VUYWIoXCIhb25fcnVuLnB5XCIsIFwiT24gUnVuXCIpfVxuICAgICR7bWFrZVRhYihcIiFvbl9jaGFuZ2UucHlcIiwgXCJPbiBDaGFuZ2VcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIW9uX2V2YWwucHlcIiwgXCJPbiBFdmFsXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiLCBcIlNhbXBsZSBTdWJtaXNzaW9uc1wiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhdGFncy5ibG9ja3B5XCIsIFwiVGFnc1wiLCB0cnVlKX1cbiAgICBcbiAgICA8IS0tIGtvIGZvcmVhY2g6IGFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczogeydibG9ja3B5LWZpbGUtaW5zdHJ1Y3Rvcic6ICFmaWxlbmFtZSgpLnN0YXJ0c1dpdGgoJyYnKX0sXG4gICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpIHx8ICRyb290LmRpc3BsYXkuaW5zdHJ1Y3RvcigpIFwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVkaXRhYmxlOiBmaWxlbmFtZSgpLnN0YXJ0c1dpdGgoJyYnKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJHJvb3QudWkuZmlsZXMuZGlzcGxheUZpbGVuYW1lKGZpbGVuYW1lKCkpXCI+XG4gICAgICAgICAgICA8L2E+ICAgICAgICBcbiAgICAgICAgPC9saT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICA8IS0tIGtvIGZvcmVhY2g6IGFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiAkcm9vdC5kaXNwbGF5Lmluc3RydWN0b3IoKVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKCl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZpbGVuYW1lXCI+XG4gICAgICAgICAgICA8L2E+ICAgICAgICBcbiAgICAgICAgPC9saT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIGtvIGZvcmVhY2g6IHN1Ym1pc3Npb24uZXh0cmFGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAkcm9vdC51aS5maWxlcy5kaXNwbGF5RmlsZW5hbWUoZmlsZW5hbWUoKSlcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICBcbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBkcm9wZG93blwiPlxuICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rIGRyb3Bkb3duLXRvZ2dsZVwiIGhyZWY9XCIjXCIgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXG4gICAgICAgICByb2xlPVwiYnV0dG9uXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5BZGQgTmV3PC9hPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnP21vY2tfdXJscy5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/bW9ja191cmxzLmJsb2NrcHknKVwiPlVSTCBEYXRhPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz90b29sYm94LmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz90b29sYm94LmJsb2NrcHknKVwiPlRvb2xib3g8L2E+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchdGFncy5ibG9ja3B5JylcIj5UYWdzPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5JylcIj5TYW1wbGUgU3VibWlzc2lvbnM8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogYXNzaWdubWVudC5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9jaGFuZ2UucHknKVwiPk9uIENoYW5nZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25FdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIW9uX2V2YWwucHknKVwiPk9uIEV2YWw8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9wcmVmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfcHJlZml4LnB5JylcIj5BbnN3ZXIgUHJlZml4PC9hPlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9zdWZmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfc3VmZml4LnB5JylcIj5BbnN3ZXIgU3VmZml4PC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdzdGFydGluZycpXCI+U3RhcnRpbmcgRmlsZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdpbnN0cnVjdG9yJylcIj5JbnN0cnVjdG9yIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3R1ZGVudCcpXCI+U3R1ZGVudCBGaWxlPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICBcbjwvdWw+XG48L2Rpdj5cbmA7XG5cbmNvbnN0IE5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwgPSBgXG48Zm9ybT5cbjxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgIDwhLS0gRmlsZW5hbWUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiPkZpbGVuYW1lOjwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBGaWxldHlwZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIj5GaWxldHlwZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+PC9zcGFuPiAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIEluYWNjZXNzaWJsZSB0byBzdHVkZW50PyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+TmFtZXNwYWNlOiA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNFwiPlxuICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIVwiPkNvbXBsZXRlbHkgaW5hY2Nlc3NpYmxlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiP1wiPkhpZGRlbiBmcm9tIHN0dWRlbnQsIGFjY2Vzc2libGUgcHJvZ3JhbWF0aWNhbGx5PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJlwiPlZpc2libGUgdG8gc3R1ZGVudCwgYnV0IG5vdCBlZGl0YWJsZTwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPC9mb3JtPlxuYDtcblxuLyoqXG4gKiBGaWxlbmFtZXMgbGl2ZSBpbiBvbmUgb2YgZml2ZSBwb3NzaWJsZSBuYW1lc3BhY2VzOlxuICogIEluc3RydWN0b3IgKCEpOiBJbnZpc2libGUgdG8gdGhlIHN0dWRlbnQgdW5kZXIgYWxsIGNpcmN1bXN0YW5jZXNcbiAqICBTdGFydCBTcGFjZSAoXik6IFVzZWQgdG8gcmVzZXQgdGhlIHN0dWRlbnQgbmFtZXNwYWNlXG4gKiAgU3R1ZGVudCBTcGFjZSAoKTogVmlzaWJsZSB0byB0aGUgc3R1ZGVudCB3aGVuIGRpc3BsYXkuaGlkZUZpbGVzIGlzIG5vdCB0cnVlLCBhYmxlIHRvIGJlIGVkaXRlZFxuICogIEhpZGRlbiBTcGFjZSAoPyk6IE5vdCBkaXJlY3RseSB2aXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgYWNjZXNzaWJsZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiAgUmVhZC1vbmx5IFNwYWNlICgmKTogQW4gaW5zdHJ1Y3RvciBmaWxlIHR5cGUgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGlzIHVuZWRpdGFibGUgYnkgdGhlbVxuICogIFNlY3JldCBTcGFjZSAoJCk6IE5vdCB2aXNpYmxlIGZyb20gdGhlIG1lbnUgYXQgYWxsLCBzb21lIG90aGVyIG1lY2hhbmlzbSBjb250cm9scyBpdFxuICogIEdlbmVyYXRlZCBTcGFjZSAoKik6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBkZXN0cm95ZWQgYWZ0ZXIgRW5naW5lLkNsZWFyLiBDYW4gc2hhZG93IGFuIGFjdHVhbCBmaWxlLlxuICogIENvbmNhdGVuYXRlZCBTcGFjZSAoIyk6IFVzZWQgd2hlbiBidW5kbGluZyBhIHNwYWNlIGZvciB0aGUgc2VydmVyLlxuICovXG5cbmV4cG9ydCBsZXQgU1RBUlRJTkdfRklMRVMgPSBbXG4gICAgLy8gU3VibWlzc2lvblxuICAgIFwiYW5zd2VyLnB5XCIsXG4gICAgLy8gSW5zdHJ1Y3RvciBmaWxlc1xuICAgIFwiIWluc3RydWN0aW9ucy5tZFwiLFxuICAgIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIixcbiAgICBcIiFvbl9ydW4ucHlcIixcbiAgICBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQkFTSUNfTkVXX0ZJTEVTID0gW1xuICAgIFwiIW9uX2NoYW5nZS5weVwiLFxuICAgIFwiIW9uX2V2YWwucHlcIixcbiAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLFxuICAgIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgIFwiIXRhZ3MuYmxvY2tweVwiLFxuICAgIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsXG4gICAgXCIhYW5zd2VyX3ByZWZpeC5weVwiLFxuICAgIFwiIWFuc3dlcl9zdWZmaXgucHlcIlxuXTtcblxuY29uc3QgSU5TVFJVQ1RPUl9ESVJFQ1RPUlkgPSBcIl9pbnN0cnVjdG9yL1wiO1xuY29uc3QgU1RVREVOVF9ESVJFQ1RPUlkgPSBcIl9zdHVkZW50L1wiO1xuXG5jb25zdCBTZWFyY2hNb2RlcyA9IHtcbiAgICBFVkVSWVdIRVJFOiBcIkVWRVJZV0hFUkVcIixcbiAgICBTVEFSVF9XSVRIX0lOU1RSVUNUT1I6IFwiU1RBUlRfV0lUSF9JTlNUUlVDVE9SXCIsXG4gICAgT05MWV9TVFVERU5UX0ZJTEVTOiBcIk9OTFlfU1RVREVOVF9GSUxFU1wiXG59O1xuXG5jb25zdCBERUxFVEFCTEVfU0lNUExFX0ZJTEVTID0gW1wiIW9uX2NoYW5nZS5weVwiLCBcIiFvbl9ldmFsLnB5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5ERUxFVEFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5SRU5BTUFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhb25fY2hhbmdlLnB5XCIsIFwiIW9uX2V2YWwucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIj90b29sYm94LmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiF0YWdzLmJsb2NrcHlcIiwgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFhbnN3ZXJfcHJlZml4LnB5XCIsIFwiIWFuc3dlcl9zdWZmaXgucHlcIl07XG5cbmNsYXNzIEJsb2NrUHlGaWxlIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29udGVudHMgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5vd25lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgIHJldHVybiB7XCJmaWxlbmFtZVwiOiBrby5vYnNlcnZhYmxlKGZpbGVuYW1lKSwgY29udGVudHM6IGtvLm9ic2VydmFibGUoY29udGVudHMgfHwgXCJcIil9O1xufVxuXG5mdW5jdGlvbiBtYWtlTW9ja01vZGVsRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICByZXR1cm4geyBmaWxlbmFtZTogKCkgPT4gZmlsZW5hbWUsIGNvbnRlbnRzOiAoKSA9PiBjb250ZW50cyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZENvbmNhdGVuYXRlZEZpbGUoY29uY2F0ZW5hdGVkRmlsZSwgbW9kZWxGaWxlTGlzdCkge1xuICAgIGlmIChjb25jYXRlbmF0ZWRGaWxlKSB7XG4gICAgICAgIGxldCBmaWxlcyA9IEpTT04ucGFyc2UoY29uY2F0ZW5hdGVkRmlsZSk7XG4gICAgICAgIGxldCBtb2RlbEZpbGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxGaWxlcy5wdXNoKG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGZpbGVzW2ZpbGVuYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZmlsZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUsIGZpbGUuY29udGVudHMpKTtcbiAgICAgICAgbW9kZWxGaWxlTGlzdChtb2RlbEZpbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbEZpbGVMaXN0KFtdKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsRmlsZUxpc3QpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobW9kZWxGaWxlTGlzdCgpLm1hcChmaWxlID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLmZpbGVuYW1lKCksXG4gICAgICAgICAgICBjb250ZW50czogZmlsZS5jb250ZW50cygpXG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWxGaWxlTGlzdCkge1xuICAgIHJldHVybiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIG1vZGVsRmlsZUxpc3QoKS5mb3JFYWNoKGZpbGUgPT5cbiAgICAgICAgICAgIHJlc3VsdFtmaWxlLmZpbGVuYW1lKCldID0gZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgZGF0YWJhc2UgbG9naWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlGaWxlU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZXNfID0ge307XG4gICAgICAgIHRoaXMubW91bnRGaWxlcygpO1xuXG4gICAgICAgIHRoaXMud2F0Y2hNb2RlbCgpO1xuICAgICAgICB0aGlzLndhdGNoZXNfID0ge307XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3Rvci5zdWJzY3JpYmUoKHZpc2libGl0eSk9PiB7XG4gICAgICAgICAgICAkKFwiLmJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIpLnRvZ2dsZSh2aXNpYmxpdHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB3YXRjaEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKGZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHN0b3BXYXRjaGluZ0ZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIHdhdGNoTW9kZWwoKSB7XG4gICAgICAgIGxldCBmaWxlc3lzdGVtID0gdGhpcztcbiAgICAgICAgW3RoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlc10uZm9yRWFjaChmaWxlQXJyYXkgPT5cbiAgICAgICAgICAgIGZpbGVBcnJheS5zdWJzY3JpYmUoZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT0ggSEVZIElUIFVQREFURUQ6XCIsIGZpbGVBcnJheSwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiBzZWNvbmQuc3RhdHVzLmxvY2FsZUNvbXBhcmUoZmlyc3Quc3RhdHVzKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsRmlsZSA9IGNoYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayBuZXcgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXN5c3RlbS5uZXdGaWxlKG1vZGVsRmlsZS5maWxlbmFtZSgpLCBtb2RlbEZpbGUuY29udGVudHMoKSwgbW9kZWxGaWxlLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc3lzdGVtLm5vdGlmeVdhdGNoZXMoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5zdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzeXN0ZW0uZGVsZXRlRmlsZUxvY2FsbHlfKG1vZGVsRmlsZS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gbW9kZWxGaWxlLmZpbGVuYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMsIFwiYXJyYXlDaGFuZ2VcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhbnN3ZXIucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBmaXJzdCBlbGVtZW50IG9mIHN1Ym1pc3Npb24uY29kZSlcbiAgICAvLyAhb25fcnVuLnB5LCAhb25fY2hhbmdlLnB5LCAhb25fZXZhbC5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlbGV2YW50IGFzc2lnbm1lbnQuPHdoYXRldmVyPlxuICAgIC8vIF5zdGFydGluZ19jb2RlLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZmlyc3QgZWxlbWVudCBvZiBhc3NpZ25tZW50LnN0YXJ0aW5nQ29kZVxuICAgIC8vIF53aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlXG4gICAgLy8gIXdoYXRldmVyIG9yID93aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuZXh0cmFGaWxlc1xuICAgIC8vIE90aGVyd2lzZTpcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZXN0IG9mIHRoZSBlbGVtZW50cyBvZiBzdWJtaXNzaW9uLmNvZGVcbiAgICAvKipcbiAgICAgKiBOZXcgc3BlY2lhbCBmaWxlcyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgaGVyZVxuICAgICAqIEBwYXJhbSBmaWxlIHtCbG9ja1B5RmlsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ic2VydmVGaWxlXyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fcnVuLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW47XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fY2hhbmdlLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fZXZhbC5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbDtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFpbnN0cnVjdGlvbnMubWRcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCJec3RhcnRpbmdfY29kZS5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiF0YWdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50YWdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIkc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5O1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIl5cIikpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiIVwiKSB8fFxuICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIj9cIikgfHxcbiAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9ic2VydmVJbkFycmF5XyhmaWxlLCBhcnJheSkge1xuICAgICAgICBmaWxlLm93bmVyID0gYXJyYXk7XG4gICAgICAgIGxldCBjb2RlQnVuZGxlID0gZmlsZS5vd25lcigpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjb2RlQnVuZGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUJ1bmRsZVtpXS5maWxlbmFtZSgpID09PSBmaWxlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBjb2RlQnVuZGxlW2ldLmNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLmhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IG5ld0ZpbGUgPSBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBuZXdGaWxlLmNvbnRlbnRzO1xuICAgICAgICAgICAgYXJyYXkucHVzaChuZXdGaWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdW50RmlsZXMoKSB7XG4gICAgICAgIHRoaXMubmV3RmlsZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiXnN0YXJ0aW5nX2NvZGUucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFvbl9ydW4ucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIik7XG4gICAgfVxuXG4gICAgZGlzbW91bnRFeHRyYUZpbGVzKCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZmlsZXNfKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWxlc18uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoVU5ERUxFVEFCTEVfRklMRVMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNfW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53YXRjaGVzX1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VibWlzc2lvbi5jb2RlVE9ETzogU2hvdWxkbid0IHdlIG5vdGlmeSB0aGUgVUkgdGhhdCB0aGUgZmlsZSB3YXMgZGVsZXRlZD9cbiAgICB9XG5cbiAgICBuZXdGaWxlKGZpbGVuYW1lLCBjb250ZW50cywgbW9kZWxGaWxlKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzXykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBRERJTkcgRVhJU1RJTkcgRklMRVwiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzISBKdXN0IHVwZGF0ZSBpdHMgaGFuZGxlXG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdGaWxlID0gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICAgICAgaWYgKG1vZGVsRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlRmlsZV8oZXhpc3RpbmdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdGaWxlLmhhbmRsZSA9IG1vZGVsRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4aXN0aW5nRmlsZS5oYW5kbGUoY29udGVudHMgfHwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJORVcgRklMRVwiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAvLyBGaWxlIGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICBsZXQgbmV3RmlsZSA9IG5ldyBCbG9ja1B5RmlsZSh0aGlzLm1haW4sIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXSA9IG5ld0ZpbGU7XG4gICAgICAgICAgICBpZiAobW9kZWxGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVGaWxlXyhuZXdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZS5oYW5kbGUgPSBtb2RlbEZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKHRoaXMuZmlsZXNfKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3RmlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgY29udGVudHMgPSBjb250ZW50cyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmZpbGVzX1tmaWxlbmFtZV0uaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICByZWFkRmlsZShmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlc19bZmlsZW5hbWVdLmhhbmRsZSgpO1xuICAgIH1cblxuICAgIGdldEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufG9iamVjdH0gVGhlIGluZm8gYWJvdXQgdGhlIGZpbGUsIG9yIGZhbHNlIGlmIGl0IGNvdWxkIG5vdCBiZSBkZWxldGVkXG4gICAgICovXG4gICAgZGVsZXRlRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoREVMRVRBQkxFX1NJTVBMRV9GSUxFUy5pbmRleE9mKGZpbGVuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaWxlID0gdGhpcy5kZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2sgdG8gZXZlbnR1YWxseSBjYWxsIGRlbGV0ZUZpbGVMb2NhbGx5X1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyLnJlbW92ZShtb2RlbEZpbGUgPT4gbW9kZWxGaWxlLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZUZpbGVMb2NhbGx5XyhmaWxlbmFtZSkge1xuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICAgICAgY29uc29sZS5sb2coXCJETEVFVElOR1wiLCBmaWxlbmFtZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmRlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgbm90aWZ5V2F0Y2hlcyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZS5maWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay51cGRhdGVkKGZpbGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGUobmFtZSwgc3R1ZGVudFNlYXJjaCkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiBUaGlzIGlzIGNhbGxlZCBxdWl0ZSBhIGJpdCBieSB0aGUgSW1wb3J0IG1lY2hhbmlzbSwgbWlnaHQgbmVlZFxuICAgICAgICAgICAgICB0byBvcHRpbWl6ZSBpdCBzb21lIG1vcmUuIERvIHRpbWluZyB0ZXN0cy5cblxuICAgICAgICBmaWxlcy4qXG4gICAgICAgIF9pbnN0cnVjdG9yL2ZpbGVzLipcbiAgICAgICAgX3N0dWRlbnQvZmlsZXMuKlxuXG4gICAgICAgIElmIGEgc3R1ZGVudCBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgdGhlIFwiP1wiLCBcIiZcIiwgXCIqXCIsIFwiXCIgbmFtZXNwYWNlc1xuICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgIElmIGFuIGluc3RydWN0b3Igc2VhcmNoZXMgZm9yIGEgZmlsZSwgaXQgY2hlY2tzIFwiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBUbyBleHBsaWNpdGx5IHNlYXJjaCBpbnN0cnVjdG9yIG5hbWVzcGFjZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBpbXBvcnQgX2luc3RydWN0b3IuaGVscGVyID0+IFwiLi9pbnN0cnVjdG9yL2hlbHBlci5weVwiXG4gICAgICAgICAgICAgICAgb3BlbihcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIikgPT4gXCJfaW5zdHJ1Y3Rvci9leHRlcm5hbC5qc29uXCJcbiAgICAgICAgICAgIHRvIGFsbG93IHN0dWRlbnQgZmlsZXMgdG8gb3ZlcnJpZGU6XG4gICAgICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiZXh0ZXJuYWwuanNvblwiKSA9PiBcImV4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gb25seSBjaGVjayBzdHVkZW50IGZpbGVzLCBwcmVwZW5kIHdpdGggX3N0dWRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIENob3Agb2ZmIHN0YXJ0aW5nIFwiLi9cIlxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRTtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBzZWFyY2ggYmUgc3RhcnQgd2l0aCBpbnN0cnVjdG9yIHNpZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoSU5TVFJVQ1RPUl9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShJTlNUUlVDVE9SX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBsaW1pdGVkIHRvIHRoZSBzdHVkZW50IG1vZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoU1RVREVOVF9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShTVFVERU5UX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUztcbiAgICAgICAgfSBlbHNlIGlmIChzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBpbnN0cnVjdG9yIHZlcnNpb25zXG4gICAgICAgIGxldCBleHRyYVN0dWRlbnRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhSW5zdHJ1Y3RvckZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhU3RhcnRpbmdGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpO1xuICAgICAgICAvLyBDaGVjayBzcGVjaWFsIGZpbGVzIChUT0RPOiBob3cgd291bGQgYW4gaW5zdHJ1Y3RvciBhY2Nlc3MgXCIuL19pbnN0cnVjdG9yL2Fuc3dlci5weVwiP1xuICAgICAgICBsZXQgc3BlY2lhbEZpbGUgPSB0aGlzLnNlYXJjaEZvclNwZWNpYWxGaWxlc18obmFtZSwgc2VhcmNoTW9kZSk7XG4gICAgICAgIGlmIChzcGVjaWFsRmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lhbEZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgbG9va2luZyB0aHJvdWdoIHBvc3NpYmxlIGZpbGVzXG4gICAgICAgIGxldCBzdHVkZW50VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIG5hbWUpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIFwiKlwiK25hbWUpO1xuICAgICAgICBsZXQgZGVmYXVsdFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiZcIituYW1lKTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc3RydWN0b3JWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCIhXCIrbmFtZSk7XG4gICAgICAgIGxldCBoaWRkZW5WZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCI/XCIrbmFtZSk7XG4gICAgICAgIGxldCBzdGFydGluZ1ZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3RhcnRpbmdGaWxlcywgXCJeXCIrbmFtZSk7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5TVEFSVF9XSVRIX0lOU1RSVUNUT1IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGVJbkxpc3RfKG1vZGVsTGlzdCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9kZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0W2ldLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNlYXJjaEZvclNwZWNpYWxGaWxlc18oZmlsZW5hbWUsIHNlYXJjaE1vZGUpIHtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9ydW4ucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fY2hhbmdlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ldmFsLm1kXCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnMubWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9pbnN0cnVjdGlvbnMubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpO1xuICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nX2NvZGUucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9zdGFydGluZ19jb2RlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5ld0ZpbGVEaWFsb2coa2luZCkge1xuICAgICAgICBsZXQgYm9keSA9ICQoTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCk7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIik7XG4gICAgICAgIGxldCBmaWxldHlwZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIik7XG4gICAgICAgIGxldCBuYW1lc3BhY2UgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiKTtcbiAgICAgICAgbGV0IGV4dGVuc2lvblJlZ2V4ID0gLyg/OlxcLihbXi5dKykpPyQvO1xuICAgICAgICBmaWxlbmFtZS5vbihcImlucHV0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbnNpb25SZWdleC5leGVjKGZpbGVuYW1lLnZhbCgpKVsxXTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJObyBleHRlbnNpb25cIiA6IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3JGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgICAgICAgICBmaWxldHlwZS50ZXh0KGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJpbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBuYW1lc3BhY2UudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwic3RhcnRpbmdcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUudmFsKCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHByZWZpeCtmaWxlbmFtZS52YWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0ZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBib2R5LnN1Ym1pdCgoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgeWVzKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jb25maXJtKFwiTWFrZSBOZXcgRmlsZVwiLCBib2R5LCB5ZXMsICgpPT57fSwgXCJBZGRcIik7XG4gICAgfVxufSIsIi8vVE9ETzogTW92ZSBnZXQgbGluayBkb3duIHRvIGZvb3RlciwgcmVtb3ZlIHZlcnRpY2FsIGJhciBmcm9tIHF1aWNrLW1lbnVcbmV4cG9ydCBsZXQgRk9PVEVSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1zdGF0dXNcIj5cbiAgICA8ZGl2PlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkQXNzaWdubWVudCcpXCI+TG9hZCBBc3NpZ25tZW50XG4gICAgICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5Lmluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LWZvcmNlLWxvYWQtYXNzaWdubWVudC1maWxlIGJsb2NrcHktaGlkZGVuLWZpbGVcIlxuICAgICAgICAgICAgYWNjZXB0PVwiYXBwbGljYXRpb24vSlNPTlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuc2VydmVyLmZvcmNlLmxvYWRBc3NpZ25tZW50fVwiPlxuICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwvbGFiZWw+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdzYXZlQXNzaWdubWVudCcpXCI+U2F2ZSBBc3NpZ25tZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZEZpbGUnKVwiPkxvYWQgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVGaWxlJylcIj5TYXZlIEZpbGU8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRGF0YXNldCcpXCI+TG9hZCBEYXRhc2V0PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9nRXZlbnQnKVwiPkxvZyBFdmVudDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3VwZGF0ZVN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuc2VydmVyLmZvcmNlLnVwZGF0ZVN1Ym1pc3Npb25cIj5VcGRhdGUgU3VibWlzc2lvbjwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ29uRXhlY3V0aW9uJylcIj5FeGVjdXRpb248L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZXJ2ZXIubWVzc2FnZXNcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHNwYW4+VXNlcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5pZFwiPjwvc3Bhbj4gKDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIubmFtZVwiPjwvc3Bhbj4sIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIucm9sZVwiPjwvc3Bhbj4pPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuPkNvdXJzZTogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5jb3Vyc2VJZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Hcm91cDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5ncm91cElkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkFzc2lnbm1lbnQ6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQuaWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudCBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBhc3NpZ25tZW50LnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbjogXG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLmlkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIChPd25lciBJRDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkKClcIj48L3NwYW4+KVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbiBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+RWRpdG9yIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGRpc3BsYXkuZWRpdG9yVmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7IiwiLy8gVE9ETzogU2hvdWxkIGRpc2FibGUgYnV0dG9ucyBpZiB3ZSBjYW4ndCBhY3RpdmF0ZSB0aGVtLlxuXG5leHBvcnQgY29uc3QgSElTVE9SWV9UT09MQkFSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXRvb2xiYXIgY29sLW1kLTEyXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5oaXN0b3J5TW9kZVwiPlxuXG4gICAgPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXN0YXJ0IGJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3Rvcnkuc3RhcnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPiBTdGFydFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkucHJldmlvdXNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj4gUHJldmlvdXNcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3IgZm9ybS1jb250cm9sIGN1c3RvbS1zZWxlY3QgbXItMlwiIGFyaWEtdGl0bGU9XCJIaXN0b3J5IFNlbGVjdG9yXCI+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS51c2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZmlsZS1pbXBvcnQnPjwvc3Bhbj4gVXNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5uZXh0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj4gTmV4dFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm1vc3RSZWNlbnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+IE1vc3QgUmVjZW50XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuYDtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGRpc3BsYXlpbmcgdGhlIHVzZXIncyBjb2RpbmcgbG9ncyAodGhlaXIgaGlzdG9yeSkuXG4gKiBBIGxpZ2h0d2VpZ2h0IGNvbXBvbmVudCwgaXRzIG9ubHkgam9iIGlzIHRvIG9wZW4gYSBkaWFsb2cuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUhpc3Rvcnl9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGxvYWQoaGlzdG9yeSkge1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICB0aGlzLmVkaXRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICQoXCIuYmxvY2tweS1oaXN0b3J5LXNlbGVjdG9yXCIpLmVtcHR5KCk7XG4gICAgICAgIGxldCBlZGl0SWQgPSAwO1xuICAgICAgICBoaXN0b3J5XG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gKFxuICAgICAgICAgICAgICAgICFlbnRyeS5maWxlX3BhdGguc3RhcnRzV2l0aChcIl9pbnN0cnVjdG9yLlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkNvbXBpbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkludGVydmVudGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJYLVN1Ym1pc3Npb24uTE1TXCIpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldmVudF90eXBlID0gUkVNQVBfRVZFTlRfVFlQRVNbZW50cnkuZXZlbnRfdHlwZV0gfHwgZW50cnkuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzcGxheWVkID0gcHJldHR5UHJpbnREYXRlVGltZShlbnRyeS5jbGllbnRfdGltZXN0YW1wKSArXCIgLSBcIitldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlID0gKGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiRmlsZS5FZGl0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSAkKFwiPG9wdGlvbj48L29wdGlvbj5cIiwge3RleHQ6IGRpc3BsYXllZCwgZGlzYWJsZWQ6IGRpc2FibGV9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VkaXRFdmVudChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmF0dHIoXCJ2YWx1ZVwiLCBlZGl0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRFdmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRJZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGVkaXRJZC0xKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuY2hhbmdlKChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vdmVUb1N0YXJ0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCgwKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlUHJldmlvdXMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGN1cnJlbnRJZC0xKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWluKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSwgY3VycmVudElkKzEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlVG9Nb3N0UmVjZW50KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCh0aGlzLmVkaXRFdmVudHMubGVuZ3RoLTEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uc2V0Q29kZSh0aGlzLmVkaXRFdmVudHNbY3VycmVudElkXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuZmlsZS5oYW5kbGUoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VkaXRFdmVudChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKChlbnRyeS5ldmVudF90eXBlID09PSBcIkZpbGUuRWRpdFwiIHx8XG4gICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5DcmVhdGVcIikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBlbnRyeS5maWxlX3BhdGgpO1xuICAgIH1cblxufVxuXG5jb25zdCBSRU1BUF9FVkVOVF9UWVBFUyA9IHtcbiAgICBcIlNlc3Npb24uU3RhcnRcIjogXCJCZWdhbiBzZXNzaW9uXCIsXG4gICAgXCJYLUlQLkNoYW5nZVwiOiBcIkNoYW5nZWQgSVAgYWRkcmVzc1wiLFxuICAgIFwiRmlsZS5FZGl0XCI6IFwiRWRpdGVkIGNvZGVcIixcbiAgICBcIkZpbGUuQ3JlYXRlXCI6IFwiU3RhcnRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJSdW4uUHJvZ3JhbVwiOiBcIlJhbiBwcm9ncmFtXCIsXG4gICAgXCJDb21waWxlLkVycm9yXCI6IFwiU3ludGF4IGVycm9yXCIsXG4gICAgXCJYLVN1Ym1pc3Npb24uTE1TXCI6IFwiVXBkYXRlZCBncmFkZVwiXG59O1xuXG5jb25zdCBtb250aE5hbWVzID0gW1xuICAgIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsXG4gICAgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLFxuICAgIFwiQXVnXCIsIFwiU2VwdFwiLCBcIk9jdFwiLFxuICAgIFwiTm92XCIsIFwiRGVjXCJcbl07XG5jb25zdCB3ZWVrRGF5cyA9IFtcbiAgICBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLFxuICAgIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsXG4gICAgXCJTYXRcIlxuXTtcblxuZnVuY3Rpb24gaXNTYW1lRGF5KGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QuZ2V0RGF0ZSgpID09PSBzZWNvbmQuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGZpcnN0LmdldE1vbnRoKCkgPT09IHNlY29uZC5nZXRNb250aCgpICYmXG4gICAgICAgIGZpcnN0LmdldEZ1bGxZZWFyKCkgPT09IHNlY29uZC5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBhIGRhdGUvdGltZSBzdHJpbmcgYW5kIHJld3JpdGUgaXQgYXMgc29tZXRoaW5nXG4gKiBtb3JlIGh1bWFuIHJlYWRhYmxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHRpbWVTdHJpbmcgLSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgKFwiWVlZWU1NREQgSEhNTVNTXCIpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgaHVtYW4tcmVhZGFibGUgdGltZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByZXR0eVByaW50RGF0ZVRpbWUodGltZVN0cmluZykge1xuICAgIC8qbGV0IHllYXIgPSB0aW1lU3RyaW5nLnNsaWNlKDAsIDQpLFxuICAgICAgICBtb250aCA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoNCwgNiksIDEwKS0xLFxuICAgICAgICBkYXkgPSB0aW1lU3RyaW5nLnNsaWNlKDYsIDgpLFxuICAgICAgICBob3VyID0gdGltZVN0cmluZy5zbGljZSg5LCAxMSksXG4gICAgICAgIG1pbnV0ZXMgPSB0aW1lU3RyaW5nLnNsaWNlKDExLCAxMyksXG4gICAgICAgIHNlY29uZHMgPSB0aW1lU3RyaW5nLnNsaWNlKDEzLCAxNSk7Ki9cbiAgICAvLyBUT0RPOiBIYW5kbGUgdGltZXpvbmVzIGNvcnJlY3RseVxuICAgIGlmICh0aW1lU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5kZWZpbmVkIFRpbWVcIjtcbiAgICB9XG4gICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHBhc3QgPSBuZXcgRGF0ZShwYXJzZUludCh0aW1lU3RyaW5nLCAxMCkpO1xuICAgIGlmIChpc1NhbWVEYXkobm93LCBwYXN0KSkge1xuICAgICAgICByZXR1cm4gXCJUb2RheSBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXlTdHIgPSB3ZWVrRGF5c1twYXN0LmdldERheSgpXTtcbiAgICAgICAgbGV0IG1vbnRoU3RyID0gbW9udGhOYW1lc1twYXN0LmdldE1vbnRoKCldO1xuICAgICAgICBsZXQgZGF0ZSA9IGRheVN0ciArIFwiLCBcIiArIG1vbnRoU3RyICsgXCIgXCIgKyBwYXN0LmdldERhdGUoKTtcbiAgICAgICAgaWYgKG5vdy5nZXRGdWxsWWVhcigpID09PSBwYXN0LmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIsIFwiK3Bhc3QuZ2V0RnVsbFllYXIoKSArIFwiIGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBPcGVucyB0aGUgaGlzdG9yeSBkaWFsb2cgYm94LiBUaGlzIHJlcXVpcmVzIGEgdHJpcCB0byB0aGUgc2VydmVyIGFuZFxuICogb2NjdXJzIGFzeW5jaHJvbm91c2x5LiBUaGUgdXNlcnMnIGNvZGUgaXMgc2hvd24gaW4gcHJlZm9ybWF0dGVkIHRleHRcbiAqIHRhZ3MgKG5vIGNvZGUgaGlnaGxpZ2h0aW5nIGN1cnJlbnRseSkgYWxvbmcgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovXG5CbG9ja1B5SGlzdG9yeS5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFsb2cgPSB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2c7XG4gICAgdmFyIGJvZHkgPSBcIjxwcmU+YSA9IDA8L3ByZT5cIjtcbiAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuZ2V0SGlzdG9yeShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBib2R5ID0gZGF0YS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChjb21wbGV0ZSwgZWxlbSkgeyBcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZV9zdHIgPSBwcmV0dHlQcmludERhdGVUaW1lKGVsZW0udGltZSk7XG4gICAgICAgICAgICB2YXIgbmV3X2xpbmUgPSBcIjxiPlwiK2NvbXBsZXRlX3N0citcIjwvYj48YnI+PHByZT5cIitlbGVtLmNvZGUrXCI8L3ByZT5cIjtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZStcIlxcblwiK25ld19saW5lO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgZGlhbG9nLnNob3coXCJXb3JrIEhpc3RvcnlcIiwgYm9keSwgZnVuY3Rpb24oKSB7fSk7XG4gICAgfSk7XG59OyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBtYWluIEhUTUwgb2YgQmxvY2tQeSBpbnRlcmZhY2UsIGFuZCBoZWxwZXIgZnVuY3Rpb25zLlxuICogQ29tYmluZXMgYSBsb3Qgb2YgSFRNTCBmcm9tIGNvbXBvbmVudHMuXG4gKlxuICogSGVyZSdzIHRoZSBsYXlvdXQ6XG4gKiAgUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudVxuICogIFJvdyAyOiBDb25zb2xlIGFuZCBGZWVkYmFja1xuICogIFJvdyAzOiBGaWxlIE5hdmlnYXRpb25cbiAqICBSb3cgNDogVmlldyBSb3dcbiAqICBSb3cgNTogRm9vdGVyIFJvd1xuICovXG5cbmltcG9ydCB7VFJBQ0VfSFRNTH0gZnJvbSBcInRyYWNlLmpzXCI7XG5pbXBvcnQge0RJQUxPR19IVE1MfSBmcm9tIFwiZGlhbG9nLmpzXCI7XG5pbXBvcnQge0ZFRURCQUNLX0hUTUx9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtGSUxFU19IVE1MfSBmcm9tIFwiZmlsZXMuanNcIjtcbmltcG9ydCB7Rk9PVEVSX0hUTUx9IGZyb20gXCJmb290ZXIuanNcIjtcbmltcG9ydCB7RURJVE9SU19IVE1MfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtDT05TT0xFX0hUTUx9IGZyb20gXCJjb25zb2xlLmpzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBsYXlvdXQgb3B0aW9ucyBvZiB0aGUgcGFuZXMgaW4gdGhlIHNlY29uZCByb3cgb2YgdGhlIGxheW91dC5cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zID0ge1xuICAgIEZFRURCQUNLOiBcImZlZWRiYWNrXCIsXG4gICAgVFJBQ0U6IFwidHJhY2VcIixcbiAgICBOT05FOiBcIm5vbmVcIlxufTtcblxuLyoqXG4gKiBTZXR1cCBhbnkgYWRkaXRpb25hbCBLbm9ja291dCBzdWJzY3JpcHRpb25zIHRvIGZpcmUgb24gaW50ZXJmYWNlIGNoYW5nZXMuXG4gKiBAcGFyYW0gc2VsZlxuICogQHBhcmFtIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zKHNlbGYsIG1vZGVsKSB7XG4gICAgLy8gSGlnaGxpZ2h0IE1hcmtkb3duIHdoZW4gaW5zdHJ1Y3Rpb25zIHVwZGF0ZVxuICAgIGxldCBoaWdobGlnaHRUaW1lb3V0ID0gbnVsbDtcbiAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuY3VycmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdGlvbnMgcHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICB9KTtcbiAgICAvLyBQcm92aWRlIEZ1bGxzY3JlZW4gc3VwcG9ydFxuICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbi5zdWJzY3JpYmUoKGlzRnVsbHNjcmVlbikgPT4ge1xuICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uUmVxdWVzdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLy8gTk9URTogbmF2aWdhdGlvblVJIGNvdWxkIGFsbG93IHVzIHRvIGZvcmNlIGNvbnRyb2xzIHRvIHNob3dcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLnBhcmVudCgpWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXJyb3JcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsICBcIlwiKTtcbiAgICAgICAgICAgICAgICBhbGVydChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5TdWNjZXNzXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuY3NzKFwib3ZlcmZsb3cteVwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLkV4aXRcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8gVE9ETzogR2V0IHNoYXJlYWJsZSBsaW5rIGJ1dHRvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludGVyZmFjZShtYWluKSB7XG4gICAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9J2Jsb2NrcHktY29udGVudCBjb250YWluZXItZmx1aWQnPlxuXG4gICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgJHtESUFMT0dfSFRNTH1cbiAgICBcbiAgICA8IS0tIEhpZGRlbiBDYXB0dXJlIENhbnZhcyAtLT5cbiAgICA8Y2FudmFzIGlkPSdjYXB0dXJlLWNhbnZhcycgY2xhc3M9J2Qtbm9uZScgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2FudmFzPlxuICAgIFxuICAgIDwhLS0gUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIERlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTEwIGJsb2NrcHktcGFuZWwgYmxvY2tweS1oZWFkZXInXG4gICAgICAgICAgICAgICByb2xlPSdoZWFkaW5nJyBhcmlhLWxhYmVsPSdBc3NpZ25tZW50IERlc2NyaXB0aW9uJz5cbiAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBBc3NpZ25tZW50IE5hbWUgLS0+XG4gICAgICAgICAgICA8c3BhbiByb2xlPSdoZWFkaW5nJyBhcmlhLWxldmVsPScxJ1xuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LW5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPkJsb2NrUHk6IDwvc3Ryb25nPiBcbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGFzc2lnbm1lbnQubmFtZSc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIFJlc2V0IEluc3RydWN0aW9ucyBCdXR0b24gLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdGlvbnMtcmVzZXRcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmluc3RydWN0aW9ucy5pc0NoYW5nZWRcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImZsb2F0LXJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmluc3RydWN0aW9ucy5yZXNldFwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgUmVzZXQgaW5zdHJ1Y3Rpb25zPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gSW5zdHJ1Y3Rpb25zIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1pbnN0cnVjdGlvbnMnXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IHVpLmluc3RydWN0aW9ucy5jdXJyZW50XCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktcXVpY2stbWVudSdcbiAgICAgICAgICAgICByb2xlPSdtZW51YmFyJyBhcmlhLWxhYmVsPSdRdWljayBNZW51JyB0aXRsZT1cIlF1aWNrIE1lbnVcIj5cbiAgICAgICAgICAgIDwhLS0gR2V0IFNoYXJlYWJsZSBMaW5rIC0tPlxuICAgICAgICAgICAgPCEtLTxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiPlxuICAgICAgICAgICAgICAgIEdldCBzaGFyZWFibGUgbGluazwvYnV0dG9uPi0tPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidmlzaWJsZTogdWkubWVudS5pc1N1Ym1pdHRlZFwiPlxuICAgICAgICAgICAgICAgIFlvdXIgc3VibWlzc2lvbiBpcyByZWFkeSB0byBiZSByZXZpZXdlZCE8L3NwYW4+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLm1lbnUuY2FuTWFya1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVpLm1lbnUudGV4dE1hcmtTdWJtaXR0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkubWVudS5jbGlja01hcmtTdWJtaXR0ZWRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gVmlldyBhcyBpbnN0cnVjdG9yIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5yb2xlLmlzR3JhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiXCIgaWQ9XCJibG9ja3B5LWFzLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5Lmluc3RydWN0b3JcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIFZpZXcgYXMgaW5zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gUmVhZG9ubHkgbW9kZSBmb3Igc3B5aW5nIC0tPlxuICAgICAgICAgICAgPGRpdiBkYXRhLWJpbmQ9XCJpZjogc3VibWlzc2lvbi5vd25lcklkKCkgIT0gdXNlci5pZCgpXCI+XG4gICAgICAgICAgICAgICAgT3duZXI6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24ub3duZXJJZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJibG9ja3B5LXJlYWQtb25seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5LnJlYWRPbmx5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlYWQtb25seVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZG9ubHk/XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LmNsaWNrRnVsbHNjcmVlblwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsIFNjcmVlblwiXG4gICAgICAgICAgICA+PHNwYW4gY2xhc3M9J2ZhcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGFzczogdWkubWVudS50ZXh0RnVsbHNjcmVlblwiXG4gICAgICAgICAgICA+PC9zcGFuPjwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS5lZGl0SW5wdXRzLCB2aXNpYmxlOiB1aS5tZW51LnNob3dRdWV1ZWRJbnB1dHNcIiB0aXRsZT1cIkVkaXQgSW5wdXRzXCJcbiAgICAgICAgICAgID48c3BhbiBjbGFzcz0nZmFzIGZhLWxpc3QtYWx0Jz48L3NwYW4+PC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktc3R1ZGVudC1lcnJvciBmYXMgZmEtYnVnXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgIDwvZGl2PlxuICAgIFxuICAgIDwhLS0gUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrIC0tPlxuICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc0FsbFZpc2libGUgLS0+XG4gICAgPGRpdiBjbGFzcz0ncm93Jz5cbiAgICBcbiAgICAgICAgPCEtLSBDb25zb2xlIC0tPlxuICAgICAgICAke0NPTlNPTEVfSFRNTH1cbiAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIFxuICAgICAgICA8IS0tIFRyYWNlIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUgLS0+XG4gICAgICAgICR7VFJBQ0VfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICAke0ZJTEVTX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgNDogVmlldyBSb3cgLS0+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAke0VESVRPUlNfSFRNTH1cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gUm93IDU6IEZvb3RlciBSb3cgLS0+ICAgIFxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgJHtGT09URVJfSFRNTH1cbiAgICA8L2Rpdj5cbiAgICBcbjwvZGl2PlxuICAgIGA7XG59IiwiaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQge2xvYWRBc3NpZ25tZW50U2V0dGluZ3MsIHNhdmVBc3NpZ25tZW50U2V0dGluZ3N9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5cbi8qKlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU3RhdHVzU3RhdGUgPSB7XG4gICAgUkVBRFk6IFwicmVhZHlcIixcbiAgICBBQ1RJVkU6IFwiYWN0aXZlXCIsXG4gICAgUkVUUllJTkc6IFwicmV0cnlpbmdcIixcbiAgICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG4gICAgT0ZGTElORTogXCJvZmZsaW5lXCJcbn07XG5cbi8qKlxuICogT2JqZWN0IGZvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIGV4dGVybmFsIHNlcnZlcnMuIFRoaXMgaW5jbHVkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbiAqIHNhdmluZyBhbmQgbG9hZGluZyBmaWxlcywgbG9nZ2luZyBldmVudHMsIHNhdmluZyBjb21wbGV0aW9ucywgYW5kIHJldHJpZXZpbmcgaGlzdG9yeS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5U2VydmVyfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5U2VydmVyKG1haW4pIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuXG4gICAgLy8gU2F2ZSBVUkxzIGxvY2FsbHkgZm9yIHF1aWNrZXIgYWNjZXNzXG4gICAgdGhpcy51cmxzID0gbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHM7XG5cbiAgICAvLyBBZGQgdGhlIExvY2FsU3RvcmFnZSBjb25uZWN0aW9uXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoXCJCTE9DS1BZXCIpO1xuXG4gICAgLy8gRmF1bHRSZXNpc3RhbnRDYWNoZVxuICAgIHRoaXMucXVldWUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcImxvZ0V2ZW50XCIsIFwiW11cIikpLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcInVwZGF0ZVN1Ym1pc3Npb25cIiwgXCJbXVwiKSlcbiAgICB9O1xuICAgIHRoaXMuTUFYX1FVRVVFX1NJWkUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogMjAwLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogNTBcbiAgICB9O1xuXG4gICAgdGhpcy5USU1FUl9ERUxBWSA9IDEwMDA7XG4gICAgdGhpcy5GQUlMX0RFTEFZID0gMjAwMDtcblxuICAgIHRoaXMudGltZXJzID0ge307XG5cbiAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xuICAgIHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA9IDA7XG5cbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcyA9IFtdO1xuICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHRoaXMuY2hlY2tDYWNoZXMoKTtcblxuICAgIHRoaXMuYWx0TG9nRW50cnkgPSBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBJUCBhZGRyZXNzIGhhcyBjaGFuZ2VkLCBsb2dnaW5nIGFuIGV2ZW50IGlmIHRoYXQgb2NjdXJzLlxuICogQHBhcmFtIHJlc3BvbnNlXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNoZWNrSVAgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcIklQXCIpKSB7XG4gICAgICAgICAgICBsZXQgb2xkSVAgPSB0aGlzLnN0b3JhZ2UuZ2V0KFwiSVBcIik7XG4gICAgICAgICAgICBpZiAob2xkSVAgIT09IHJlc3BvbnNlLmlwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIFwib2xkXCI6IG9sZElQLFxuICAgICAgICAgICAgICAgICAgICBcIm5ld1wiOiByZXNwb25zZS5pcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsdExvZ0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWx0TG9nRW50cnkoXCJYLUlQLkNoYW5nZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dFdmVudChcIlgtSVAuQ2hhbmdlXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChcIklQXCIsIHJlc3BvbnNlLmlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXCJJUFwiLCByZXNwb25zZS5pcCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlcmUgaGF2ZSBiZWVuIHByZXZpb3VzIGZhaWx1cmVzIGNhY2hlZCwgYW5kIGlmIHNvIHJldHJpZXMgdGhlbS5cbiAqIFRPRE86IHVwZGF0ZVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jaGVja0NhY2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcInNhdmVBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0KFwic2F2ZUFzc2lnbm1lbnRcIikpO1xuICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgXCJhc3NpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNhdmVBc3NpZ25tZW50XCIsIHRoaXMuVElNRVJfREVMQVkpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcy5mb3JFYWNoKChmaWxlbmFtZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcInNhdmVGaWxlXCIgKyBmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0KFwic2F2ZUZpbGVcIiArIGZpbGVuYW1lKSk7XG4gICAgICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIFwic2F2ZUZpbGVcIiwgdGhpcy5USU1FUl9ERUxBWSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VydmVyID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXVlKS5mb3JFYWNoKGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAoZnVuY3Rpb24gcHVzaEFueVF1ZXVlZChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyLnF1ZXVlW2VuZHBvaW50XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHNlcnZlci5xdWV1ZVtlbmRwb2ludF0ucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2VydmVyLnVybHNbZW5kcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuX3Bvc3RSZXRyeShkYXRhLCBlbmRwb2ludCwgMTAwMCwgcHVzaEFueVF1ZXVlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSh7XCJzdWNjZXNzXCI6IHRydWV9KTtcbiAgICB9KTtcbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAobW9kZWwsIGZpbGVuYW1lKSB7XG4gICAgbW9kZWwuc3Vic2NyaWJlKChjb250ZW50cykgPT5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuYXV0b1NhdmUoKSA/IHRoaXMuc2F2ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSA6IGZhbHNlLCB0aGlzKTtcbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcy5wdXNoKGZpbGVuYW1lKTtcbn07XG5cbi8qKlxuICogVE9ETzogZml4XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5zdWJtaXNzaW9uLmNvZGUsIFwiYW5zd2VyLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uUnVuLCBcIiFvbl9ydW4ucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25FdmFsLCBcIiFvbl9ldmFsLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlLCBcIiFvbl9jaGFuZ2UucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zLCBcIiFpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlLCBcIl5zdGFydGluZ19jb2RlLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYVN0dWRlbnRGaWxlcywgXCIjZXh0cmFfc3R1ZGVudF9maWxlcy5ibG9ja3B5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYVN0YXJ0aW5nRmlsZXMsIFwiI2V4dHJhX3N0YXJ0aW5nX2ZpbGVzLmJsb2NrcHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiNleHRyYV9pbnN0cnVjdG9yX2ZpbGVzLmJsb2NrcHlcIik7XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVFdmVudExvZ3MgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cub25ibHVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiU2Vzc2lvbi5FbmRcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICB3aW5kb3cub25mb2N1cyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2dFdmVudChcIlNlc3Npb24uU3RhcnRcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IEFkZCBpbiBiZWFjb24/XG59O1xuXG4vKipcbiAqXG4gKiBTb21lIHN1YnNjcmlwdGlvbnMgaGF2ZSB0byBoYXBwZW4gYWZ0ZXIgb3RoZXIgdGhpbmdzIGhhdmUgYmVlbiBsb2FkZWQuXG4gKiBSaWdodCBub3cgdGhpcyBpcyBqdXN0IGFmdGVyIENPUkdJUyBsaWJyYXJpZXMgaGF2ZSBiZWVuIGxvYWRlZCwgYnV0IG1heWJlXG4gKiB3ZSdsbCBhZGQgbW9yZSBsYXRlciBhbmQgdGhpcyB3aWxsIG5lZWQgdG8gYmUgcmVmYWN0b3JlZC5cbiAqXG4gKiBUT0RPOiBmaXhcbiAqXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmZpbmFsaXplU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL3RoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzLnN1YnNjcmliZSh0aGlzLnNhdmVBc3NpZ25tZW50LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWZhdWx0IHBheWxvYWQgZm9yIGFueSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHNlcnZlciBBUElcbiAqIEByZXR1cm5zIHt7YXNzaWdubWVudF9pZDogKiwgY291cnNlX2lkOiAqLCBncm91cF9pZDogKiwgdXNlcl9pZDogKiwgdGltZXpvbmU6ICosIHZlcnNpb246ICosIHRpbWVzdGFtcDogKn19XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZVNlcnZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFzc2lnbm1lbnQgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudDtcbiAgICBsZXQgdXNlciA9IHRoaXMubWFpbi5tb2RlbC51c2VyO1xuICAgIGxldCBzdWJtaXNzaW9uID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb247XG4gICAgbGV0IGRpc3BsYXkgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheTtcbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gbm93LmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImFzc2lnbm1lbnRfaWRcIjogYXNzaWdubWVudC5pZCgpLFxuICAgICAgICBcImFzc2lnbm1lbnRfZ3JvdXBfaWRcIjogdXNlci5ncm91cElkKCksXG4gICAgICAgIFwiY291cnNlX2lkXCI6IHVzZXIuY291cnNlSWQoKSxcbiAgICAgICAgXCJzdWJtaXNzaW9uX2lkXCI6IHN1Ym1pc3Npb24uaWQoKSxcbiAgICAgICAgXCJ1c2VyX2lkXCI6IHVzZXIuaWQoKSxcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IGFzc2lnbm1lbnQudmVyc2lvbigpLFxuICAgICAgICBcInRpbWVzdGFtcFwiOiBtaWNyb3NlY29uZHMsXG4gICAgICAgIFwidGltZXpvbmVcIjogbm93LmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgIFwicGFzc2NvZGVcIjogZGlzcGxheS5wYXNzY29kZSgpXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdHVzIGFuZCBtZXNzYWdlIGZvciB0aGUgcmVsZXZhbnQgZW5kcG9pbnQuXG4gKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gb25lIG9mIHRoZSBVUkwgZW5kcG9pbnRzXG4gKiBAcGFyYW0gc3RhdHVzIHtTdGF0dXNTdGF0ZX1cbiAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmc/fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIHN0YXR1cywgbWVzc2FnZSkge1xuICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXNbZW5kcG9pbnRdKHN0YXR1cyk7XG4gICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludCArIFwiTWVzc2FnZVwiXShtZXNzYWdlIHx8IFwiXCIpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGFuIG92ZXJsYXkgb24gdGhlIHNjcmVlbiB0aGF0IGJsb2NrcyBvcGVyYXRpb24gdW50aWwgdGhlIHN5c3RlbSBpcyByZWFkeS5cbiAqIFRoZSBvdmVybGF5IGdldHMgcHJvZ3Jlc3NpdmVseSBkYXJrZXIgdG8gaW5kaWNhdGUgcmVwZWF0ZWQgZmFpbHVyZXMuXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNob3dPdmVybGF5ID0gZnVuY3Rpb24gKGF0dGVtcHQpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgKz0gMTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJibG9ja3B5LW92ZXJsYXlcIikubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9ICQoJzxkaXYgY2xhc3M9XCJibG9ja3B5LW92ZXJsYXlcIj4gPC9kaXY+Jyk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gICAgc3dpdGNoIChhdHRlbXB0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzk4OFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM2NTVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjMzMzXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImJsYWNrXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVbmRvIGEgbGV2ZWwgb2Ygb3ZlcmxheTsgaWYgdGhpcyB3YXMgdGhlIGxhc3QgbGV2ZWwsIHJlbW92ZXMgaXQgZnJvbSB0aGUgc2NyZWVuLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5oaWRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgLT0gMTtcbiAgICBpZiAodGhpcy5ibG9ja2luZ0F0dGVtcHRzIDw9IDApIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9lbnF1ZXVlRGF0YSA9IGZ1bmN0aW9uIChjYWNoZSwgZGF0YSkge1xuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIG5vdCBvdmVyZmlsbGVkIHRoZSBxdWV1ZVxuICAgIGxldCBsZW5ndGggPSB0aGlzLnF1ZXVlW2NhY2hlXS5sZW5ndGg7XG4gICAgbGV0IG1heCA9IHRoaXMuTUFYX1FVRVVFX1NJWkVbY2FjaGVdO1xuICAgIGlmIChsZW5ndGggPiBtYXgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtjYWNoZV0gPSB0aGlzLnF1ZXVlW2NhY2hlXS5zbGljZShsZW5ndGggLSBtYXgsIG1heCk7XG4gICAgfVxuICAgIC8vIE9ubHkgYWRkIHRoZSBlbGVtZW50IGlmIGl0J3MgbmV3XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldChjYWNoZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5xdWV1ZVtjYWNoZV0pKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZGVxdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5xdWV1ZVtjYWNoZV0uaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnNwbGljZShpbmRleCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGVuZHBvaW50LCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICBsZXQgcG9zdFJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgcG9zdFxuICAgICAgICB0aGlzLl9lbnF1ZXVlRGF0YShlbmRwb2ludCwgZGF0YSk7XG4gICAgICAgICQucG9zdCh0aGlzLnVybHNbZW5kcG9pbnRdLCBkYXRhKVxuICAgICAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICBwb3N0UmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocG9zdFJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBBSkFYIHJlcXVlc3QgdGhhdCwgdXBvbiBmYWlsdXJlLCB3aWxsIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHdhcyB0aGVcbiAqIGxhdGVzdCBhdHRlbXB0IGZvciB0aGlzIGBjYWNoZWAgbWFya2VyLiBJZiBzbywgaXQgd2lsbCBhdHRlbXB0IGFnYWluIHVudGlsXG4gKiBzdWNjZXNzZnVsOyBvdGhlcndpc2UsIGl0IGdpdmVzIHVwIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIEFKQVgtcmVhZHkgZGF0YSB0byBiZSBwb3N0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgdGltZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludCAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgY2FjaGUgZW50cnlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXkgLSBUaGUgY3VycmVudCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gdHJ5aW5nIHRoZSByZXF1ZXN0IGFnYWluLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdExhdGVzdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXksIGZhaWx1cmVGdW5jdGlvbiwgZG9uZUZ1bmN0aW9uKSB7XG4gICAgbGV0IGNhY2hlID0gZW5kcG9pbnQgKyBmaWxlbmFtZTtcbiAgICBsZXQgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgJC5wb3N0KHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGEpXG4gICAgICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgY2xlYXIgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb25uZWN0ZWQgYnV0IGZhaWxlZCwgZG9uJ3QgdHJ5IGFnYWluIGJ1dCBsZXQgdGhlIHVzZXIga25vdyB3aHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUZ1bmN0aW9uKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoZXJyb3IsIHRleHRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIHRoZW4gbGV0J3MgdHJ5IGl0IGFnYWluIGluIGEgYml0XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIGVuZHBvaW50LCBkZWxheSArIHRoaXMuRkFJTF9ERUxBWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGRvbmVGdW5jdGlvbik7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbY2FjaGVdKTtcbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVyc1tjYWNoZV0gPSBzZXRUaW1lb3V0KHJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdEJsb2NraW5nID0gZnVuY3Rpb24gKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIHRoaXMuc2hvd092ZXJsYXkoYXR0ZW1wdHMpO1xuICAgIHJldHVybiAkLnBvc3QodGhpcy51cmxzW2VuZHBvaW50XSwgZGF0YSlcbiAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAuZmFpbCgoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZShlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhlbmRwb2ludCwgZGF0YSwgYXR0ZW1wdHMgLSAxLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoYXNzaWdubWVudF9pZCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiYXNzaWdubWVudF9pZFwiXSA9IGFzc2lnbm1lbnRfaWQ7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxvYWRBc3NpZ25tZW50XCIsIGRhdGEsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubG9hZEFzc2lnbm1lbnREYXRhXyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVChyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVBc3NpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiaGlkZGVuXCJdID0gbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKTtcbiAgICAgICAgZGF0YVtcInJldmlld2VkXCJdID0gbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpO1xuICAgICAgICBkYXRhW1wicHVibGljXCJdID0gbW9kZWwuYXNzaWdubWVudC5wdWJsaWMoKTtcbiAgICAgICAgZGF0YVtcInVybFwiXSA9IG1vZGVsLmFzc2lnbm1lbnQudXJsKCk7XG4gICAgICAgIGRhdGFbXCJwb2ludHNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnBvaW50cygpO1xuICAgICAgICBkYXRhW1wiaXBfcmFuZ2VzXCJdID0gbW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcygpO1xuICAgICAgICBkYXRhW1wibmFtZVwiXSA9IG1vZGVsLmFzc2lnbm1lbnQubmFtZSgpO1xuICAgICAgICBkYXRhW1wic2V0dGluZ3NcIl0gPSBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKTtcblxuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJzYXZlQXNzaWdubWVudFwiLCBkYXRhLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc3NpYmxlRm9yay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFNhdmUgQXNzaWdubWVudClcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEhpc3RvcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkSGlzdG9yeVwiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50X3R5cGUsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgZmlsZV9wYXRoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9nRXZlbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImV2ZW50X3R5cGVcIl0gPSBldmVudF90eXBlO1xuICAgICAgICBkYXRhW1wiY2F0ZWdvcnlcIl0gPSBjYXRlZ29yeTtcbiAgICAgICAgZGF0YVtcImxhYmVsXCJdID0gbGFiZWw7XG4gICAgICAgIGRhdGFbXCJtZXNzYWdlXCJdID0gbWVzc2FnZTtcbiAgICAgICAgZGF0YVtcImZpbGVfcGF0aFwiXSA9IGZpbGVfcGF0aDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIFwibG9nRXZlbnRcIiwgMCwgKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVJbWFnZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGltYWdlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVJbWFnZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcInR1cnRsZV9vdXRwdXRcIiwgXCJzYXZlSW1hZ2VcIiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvblN0YXR1cyA9IGZ1bmN0aW9uKG5ld1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wic3RhdHVzXCJdID0gbmV3U3RhdHVzO1xuICAgICAgICBsZXQgcG9zdFN0YXR1c0NoYW5nZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIGRhdGEsIDIsIHBvc3RTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBsb2FkIGZpbGVzIGFuZCB3ZWIgcmVzb3VyY2VzLlxuICpcbiAqIERFUFJFQ0FURURcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHR5cGUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRfZmlsZVwiKSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcInR5cGVcIl0gPSB0eXBlO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcodGhpcy51cmxzLmxvYWRfZmlsZSwgZGF0YSwgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKFwiU2VydmVyIGZhaWx1cmUhIFJlcG9ydCB0byBpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhcIk5vIGZpbGUgc2VydmVyIGF2YWlsYWJsZS5cIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKExvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNvbnRlbnRzLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5ID0gdGhpcy5USU1FUl9ERUxBWTtcbiAgICB9XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvZGVcIl0gPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIGRlbGF5LCB0aGlzLnN0YXJ0UG9zc2libGVGb3JrLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnN0YXJ0UG9zc2libGVGb3JrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmZvcmthYmxlKSB7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5PRkZFUl9GT1JLKCk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvbiA9IGZ1bmN0aW9uIChzY29yZSwgY29ycmVjdCwgaGlkZGVuT3ZlcnJpZGUsIGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzY29yZVwiXSA9IHNjb3JlO1xuICAgICAgICBkYXRhW1wiY29ycmVjdFwiXSA9IGNvcnJlY3Q7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5fb3ZlcnJpZGVcIl0gPSBoaWRkZW5PdmVycmlkZTtcbiAgICAgICAgZGF0YVtcImZvcmNlX3VwZGF0ZVwiXSA9IGZvcmNlVXBkYXRlO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuZ2V0UG5nRnJvbUJsb2NrcygocG5nRGF0YSwgaW1nKSA9PiB7XG4gICAgICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBwbmdEYXRhO1xuICAgICAgICAgICAgaWYgKGltZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBpbWcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoaWRkZW5PdmVycmlkZSAmJiBjb3JyZWN0ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhW1wiYXNzaWdubWVudF9pZFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJleHBvcnQgY29uc3QgJHNrX21vZF9jb3ZlcmFnZSA9IGBcblwiXCJcIlxuSGlkZW91cyBmaWxsLWluIHJlcGxhY2VtZW50IGZvciBDb3ZlcmFnZSwgbGV2ZXJhZ2luZyBzb21lIG1hZ2ljIGZyb20gdGhlXG5VdGlsaXR5IGZ1bmN0aW9uLiBUaGUgZGF0YSB0aGlzIHJldHVybnMgaXMgZmFsc2UgLSBpdCBkb2Vzbid0IGFjdHVhbGx5XG5kZXNjcmliZSB0aGUgbWlzc2luZyBsaW5lcyBhbmQgYWxsIGxpbmVzOyBpdCBqdXN0IGRlc2NyaWJlcyB0aGUgdHJhY2VkIGxpbmVzLlxuQnV0IHNpbmNlIFBlZGFsIGRvZXNuJ3QgbmVlZCB0aGUgb3RoZXIgdHdvLCBpdCB3b3JrcyBvdXQgZmluZSB3aGVuIHlvdSBkbzpcblxuc3RhdGVtZW50cyAtIG1pc3NpbmdcblwiXCJcIlxuXG5pbXBvcnQgdXRpbGl0eVxuXG5jbGFzcyBDb3ZlcmFnZTpcbiAgICBkZWYgc3RhcnQoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzdG9wKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgc2F2ZShzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIF9hbmFseXplKHNlbGYsIGZpbGVuYW1lOiBzdHIpOlxuICAgICAgICBsaW5lcyA9IHNldCh1dGlsaXR5LnRyYWNlX2xpbmVzKCkpXG4gICAgICAgICMgbGluZXMgd2lsbCBiZSB0aGUgbGluZXMgdGhhdCB3ZXJlIGFjdHVhbGx5IGV4ZWN1dGVkXG4gICAgICAgIHJldHVybiBBbmFseXNpcyhOb25lLCBsZW4obGluZXMpLCBOb25lLCBzZXQoKSwgbGluZXMpXG5cblxuY2xhc3MgTnVtYmVyczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpOlxuICAgICAgICBzZWxmLm5fbWlzc2luZyA9IG5fbWlzc2luZ1xuICAgICAgICBzZWxmLm5fc3RhdGVtZW50cyA9IG5fc3RhdGVtZW50c1xuICAgICAgICBzZWxmLnBjX2NvdmVyZWQgPSBwY19jb3ZlcmVkXG5cblxuY2xhc3MgQW5hbHlzaXM6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkLCBtaXNzaW5nLCBzdGF0ZW1lbnRzKTpcbiAgICAgICAgc2VsZi5taXNzaW5nID0gbWlzc2luZ1xuICAgICAgICBzZWxmLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYubnVtYmVycyA9IE51bWJlcnMobl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpXG5cblxuY2xhc3MgcHl0aG9uOlxuICAgIGRlZiBnZXRfcHl0aG9uX3NvdXJjZShzZWxmKTpcbiAgICAgICAgcmV0dXJuIE5vbmVcbmA7IiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbW9kLCBzYW1wbGVXcmFwcGVyO1xuICAgIG1vZCA9IHtfX25hbWVfXzogXCJpbWFnZVwifTtcblxuICAgIGlmICghU2suUElMKSB7XG4gICAgICAgIFNrLlBJTCA9IHthc3NldHM6IHt9fTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50UHJvbWlzZSBpcyBhIHdvcmthcm91bmQgdG8gYWxsb3cgdXNhZ2Ugb2YgdGhlIGNsZWFuIHByb21pc2Utc3R5bGVcbiAgICAvLyB0aGVuL2NhdGNoIHN5bnRheCBidXQgdG8gaW5zdGFudGx5IGNhbGwgcmVzb2x2ZSB0aGUgdGhlbi9jYXRjaCBjaGFpbiBzbyB3ZVxuICAgIC8vIGNhbiBhdm9pZCBjcmVhdGluZyBTdXNwZW5zaW9ucyBpbiB1bm5lY2Vzc2FyeSBjYXNlcy4gIFRoaXMgaXMgZGVzaXJhYmxlXG4gICAgLy8gYmVjYXVzZSBTdXNwZW5zaW9ucyBoYXZlIGEgZmFpcmx5IGxhcmdlIG5lZ2F0aXZlIGltcGFjdCBvbiBvdmVyYWxsXG4gICAgLy8gcGVyZm9ybWFuY2UuICBUaGVzZSAnaW5zdGFudCBwcm9taXNlcycgY29tZSBpbnRvIHBsYXkgd2hlbiBhIHRyYWNlcigpXG4gICAgLy8gY2FsbCBpcyBtYWRlIHdpdGggYSB2YWx1ZSBvdGhlciB0aGFuIDEuICBXaGVuIHRyYWNlciBpcyAwIG9yIGdyZWF0ZXIgdGhhbiAxXG4gICAgLy8gLCB3ZSBjYW4gYnlwYXNzIHRoZSBjcmVhdGlvbiBvZiBhIFN1c3BlbnNpb24gYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgbGluZSBvZlxuICAgIC8vIGNvZGUgaW1tZWRpYXRlbHkgaWYgdGhlIGN1cnJlbnQgbGluZSBpcyBub3QgZ29pbmcgdG8gaW52b2x2ZSBhIHNjcmVlblxuICAgIC8vIHVwZGF0ZS4gV2UgZGV0ZXJtaW5lIGlmIGEgcmVhbCBwcm9taXNlIG9yIEluc3RhbnRQcm9taXNlIGlzIG5lY2Vzc2FyeSBieVxuICAgIC8vIGNoZWNraW5nIEZyYW1lTWFuYWdlci53aWxsUmVuZGVyTmV4dCgpXG4gICAgZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlcnI7XG4gICAgfVxuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlID8gdGhpcy5sYXN0UmVzdWx0IDogdGhpcztcbiAgICB9O1xuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgYnVpbGRJbWFnZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKFNrLlBJTC5hc3NldHNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFNrLlBJTC5hc3NldHNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShTay5QSUwuYXNzZXRzW25hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU2suUElMLmFzc2V0c1tuYW1lXSA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXNzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgIC8vIG9wZW4oZmlsZW5hbWUpIG9yIG9wZW4odXJsKVxuICAgICAgICAvLyBzaG93KClcblxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZmlsZV9vcl91cmwpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImZpbGVfb3JfdXJsXCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsZV9vcl91cmwpKTtcbiAgICAgICAgICAgIHNlbGYuZmlsZV9vcl91cmwgPSBmaWxlX29yX3VybDtcbiAgICAgICAgICAgIC8vIFRPRE86IENoYW5nZSB0byBzdXNwZW5zaW9uXG4gICAgICAgICAgICB2YXIgaW1hZ2VQcm9taXNlID0gZ2V0QXNzZXQoU2suZmZpLnJlbWFwVG9KcyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgdmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpO1xuICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgICAgIHN1c3AucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3AuZGF0YVtcImVycm9yXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihzdXNwLmRhdGFbXCJlcnJvclwiXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3VzcC5kYXRhW1wiZXJyb3JcIl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gc2VsZi5pbWFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3VzcC5kYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IGltYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy53aWR0aCA9IHNlbGYuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmhlaWdodCA9IHNlbGYuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHNlbGYuaW1hZ2UsIDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5waXhlbHMgPSBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3VzcDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5zaG93ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBpZiAoU2suY29uc29sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIGRyYXdpbmcgYXJlYS4gU2suY29uc29sZSBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29uc29sZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHNlbGYuaW1hZ2UsXG4gICAgICAgICAgICAgICAgZmlsZV9vcl91cmw6IHNlbGYuZmlsZV9vcl91cmxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNrLmNvbnNvbGUucHJpbnRQSUxJbWFnZShjb25zb2xlRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZmxpcCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgtMSlcIjtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtb2QuSW1hZ2UgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgaW1hZ2UsIFwiSW1hZ2VcIiwgW10pO1xuXG4gICAgcmV0dXJuIG1vZDtcbn07IiwiZXhwb3J0IGNvbnN0ICRwZWRhbF90cmFjZXIgPSBgXHJcblxyXG5cIlwiXCJcclxuV3JhcHMgdGhlIHRyYWNlciBtb2R1bGUgaW4gUGVkYWxcclxuXCJcIlwiXHJcblxyXG5pbXBvcnQgb3NcclxuaW1wb3J0IHV0aWxpdHlcclxuICAgICAgICBcclxuY2xhc3MgU2FuZGJveEJhc2ljVHJhY2VyOlxyXG4gICAgXCJcIlwiXHJcblxyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgc2VsZi5maWxlbmFtZSA9IFwic3R1ZGVudC5weVwiXHJcbiAgICAgICAgc2VsZi5jb2RlID0gTm9uZVxyXG5cclxuICAgIGRlZiBhc19maWxlbmFtZShzZWxmLCBmaWxlbmFtZSwgY29kZSk6XHJcbiAgICAgICAgaWYgb3MucGF0aC5pc2FicyhmaWxlbmFtZSk6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBmaWxlbmFtZVxyXG4gICAgICAgIGVsc2U6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBvcy5wYXRoLmFic3BhdGgoZmlsZW5hbWUpXHJcbiAgICAgICAgc2VsZi5jb2RlID0gY29kZVxyXG4gICAgICAgIHJldHVybiBzZWxmXHJcblxyXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcclxuICAgICAgICBwYXNzXHJcblxyXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsLCB0cmFjZWJhY2spOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbmNsYXNzIFNhbmRib3hOYXRpdmVUcmFjZXIoU2FuZGJveEJhc2ljVHJhY2VyKTpcclxuICAgIFwiXCJcIlxyXG4gICAgVHJhY2tzIGxpbmVzIGNvdmVyZWQgYW5kIGZ1bmN0aW9uIGNhbGxzLiBQb3NzaWJseSBvdGhlciB0aGluZ3M/IFdlIGNvdWxkIHRyYWNrIHZhcmlhYmxlcywgaWYgdGhhdFxyXG4gICAgd2FzIHNvbWV0aGluZyBwZW9wbGUgd2FudGVkLlxyXG5cclxuICAgIFRPRE86IEhhbmRsZSBtdWx0aXBsZSBzdWJtaXNzaW9uIGZpbGVzP1xyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgI3NlbGYuY2FsbHMgPSB1dGlsaXR5LnRyYWNlX2NhbGxzKClcclxuICAgICAgICBzZWxmLmxpbmVzID0gdXRpbGl0eS50cmFjZV9saW5lcygpXHJcbiAgICAgICAgc2VsZi5zdGVwX2luZGV4ID0gbGVuKHV0aWxpdHkudHJhY2VfbGluZXMoKSlcclxuICAgIFxyXG4gICAgZGVmIGdldF9jYWxscyhzZWxmKTpcclxuICAgICAgICByZXR1cm4gdXRpbGl0eS50cmFjZV9jYWxscygpXHJcbiAgICBcclxuICAgIGNhbGxzID0gcHJvcGVydHkoZ2V0X2NhbGxzKVxyXG4gICAgXHJcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxyXG4gICAgICAgIHV0aWxpdHkuc3RhcnRfdHJhY2Uoc2VsZilcclxuXHJcbiAgICBkZWYgX19leGl0X18oc2VsZiwgZXhjX3R5cGUsIGV4Y192YWwsIHRyYWNlYmFjayk6XHJcbiAgICAgICAgdXRpbGl0eS5zdG9wX3RyYWNlKHNlbGYpXHJcblxyXG5UUkFDRVJfU1RZTEVTID0ge1xyXG4gICAgJ25vbmUnOiBTYW5kYm94QmFzaWNUcmFjZXIsXHJcbiAgICAnbmF0aXZlJzogU2FuZGJveE5hdGl2ZVRyYWNlclxyXG59XHJcblxyXG5gOyIsIi8qKlxuICogU2t1bHB0IE1vZHVsZSBmb3IgaG9sZGluZyB0aGUgSW5zdHJ1Y3RvciBBUEkuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgbG9hZGVkIGluIGJ5IGdldHRpbmcgdGhlIGZ1bmN0aW9ucycgc291cmNlIGNvZGUgZnJvbSB0b1N0cmluZy5cbiAqIElzbid0IHRoYXQgY3Jhenk/XG4gKlxuICpcbiAqL1xuZXhwb3J0IGxldCAkc2tfbW9kX2luc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBNYWluIG1vZHVsZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIGF0IHRoZSBlbmQuXG4gICAgbGV0IG1vZCA9IHt9O1xuICAgIGxldCBub25lID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIFxuICAgIGxldCBwcmlvciA9IG51bGw7XG4gICAgbW9kLnRpbWVpdCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwidGltZWl0XCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBkaWZmZXJlbmNlO1xuICAgICAgICBpZiAocHJpb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IERhdGUubm93KCkgLSBwcmlvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhTay5mZmkucmVtYXBUb0pzKG5hbWUpLCBkaWZmZXJlbmNlLzEwMDApO1xuICAgICAgICBwcmlvciA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBmZWVkYmFjayB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9sb2cgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygoWy4uLmFyZ3VtZW50c10pLm1hcChTay5mZmkucmVtYXBUb0pzKSk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBkZWJ1ZyB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9kZWJ1ZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvdmVydHMgdGhlIG91dHB1dCBpbiB0aGUgc3R1ZGVudCByZXBvcnQgdG8gYSBweXRob24gXG4gICAgICogbGlzdCBhbmQgcmV0dXJucyBpdC5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X291dHB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfb3V0cHV0XCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS50b1NrdWxwdCgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlc2V0cyB0aGUgb3V0cHV0LCBwYXJ0aWN1bGFybHkgdXNlZnVsIGlmIHRoZSBzdHVkZW50XG4gICAgICogY29kZSBpcyBnb2luZyB0byBiZSByZXJ1bi5cbiAgICAgKi9cbiAgICBtb2QucmVzZXRfb3V0cHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJlc2V0X291dHB1dFwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ub3V0cHV0LnJlbW92ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgfSk7XG4gICAgXG4gICAgLyptb2QucXVldWVfaW5wdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicXVldWVfaW5wdXRcIiwgYXJndW1lbnRzLCAxLCBJbmZpbml0eSk7XG4gICAgICAgIGxldCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gYXJncy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGFyZ3NbaV07XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiaW5wdXRcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhpbnB1dCkpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaChTay5mZmkucmVtYXBUb0pzKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9KTsqL1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9wcm9ncmFtID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wcm9ncmFtXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJ2ZXJpZmllclwiXS5jb2RlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9ldmFsdWF0aW9uID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9ldmFsdWF0aW9uXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmV2YWx1YXRpb24gfHwgXCJcIik7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnRyYWNlX2xpbmVzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnJlYWxMaW5lcztcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KGxpbmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kLnRyYWNlX2NhbGxzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIi0tXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNIRUNLSU5HIENBTExTXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbJ3N0dWRlbnQnXS5zdWNjZXNzKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBjYWxscyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmNhbGxzO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtcbiAgICB9KTtcblxuICAgIG1vZC5zdGFydF90cmFjZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIGlmIChTay5iZWZvcmVDYWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBTay5iZWZvcmVDYWxsID0gU2suYmVmb3JlQ2FsbEJhY2t1cDtcbiAgICAgICAgfVxuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLnB1c2godHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9FTkRcIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgIH0pO1xuXG4gICAgbW9kLnN0b3BfdHJhY2UgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RPUC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcucG9wKCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUT1AvRU5EXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG1vZC5nZXRfc3R1ZGVudF9lcnJvciA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtub25lLCBub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvcixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLnRyYWNlYmFjayAmJiBlcnJvci50cmFjZWJhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uW1wibGluZVwiXSA9IGVycm9yLnRyYWNlYmFja1swXS5saW5lbm87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uID0gU2suZmZpLnJlbWFwVG9QeShwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Vycm9yLCBwb3NpdGlvbl0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcbiAgICBtb2QuaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImhhZF9leGVjdXRpb25fdGltZV9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gIVNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MgJiYgXG4gICAgICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXJyb3IgJiZcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvci50cCRuYW1lID09PSBcIlRpbWVMaW1pdEVycm9yXCI7XG4gICAgfSk7XG4gICAgXG4gICAgbGV0IGJhY2t1cFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgbW9kLmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGJhY2t1cFRpbWUgPSBTay5leGVjTGltaXQ7XG4gICAgICAgIGlmIChTay5leGVjTGltaXRGdW5jdGlvbikge1xuICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtb2QudW5saW1pdF9leGVjdXRpb25fdGltZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ1bmxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IGJhY2t1cFRpbWU7XG4gICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnN1cHByZXNzX3Njcm9sbGluZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJzdXBwcmVzc19zY3JvbGxpbmdcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBcbiAgICAvKlxuICAgIGRlZiBoaXN0KHNlbGYsIGRhdGEsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0hpc3RvZ3JhbScsICd2YWx1ZXMnOiBkYXRhLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHBsb3Qoc2VsZiwgeHMsIHlzPU5vbmUsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIGlmIHlzID09IE5vbmU6XG4gICAgICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdMaW5lJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd4JzogcmFuZ2UobGVuKHhzKSksICd5JzogeHMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHNjYXR0ZXIoc2VsZiwgeHMsIHlzLCAqKmt3YXJncyk6XG4gICAgICAgIGxhYmVsID0ga3dhcmdzLmdldCgnbGFiZWwnLCBOb25lKVxuICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdTY2F0dGVyJywgJ3gnOiB4cywgJ3knOiB5cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICovXG4gICAgbW9kLmdldF9wbG90cyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfcGxvdHNcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dHMgPSBvdXRwdXRzLmZpbHRlcihmdW5jdGlvbihvdXRwdXQpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50eXBlID09PSBcInBsb3RcIjtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XCJkYXRhXCI6IGdyYXBoLmNvbnRlbnQubWFwKGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bsb3QgPSB7IFwidHlwZVwiOiBwbG90LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCI6IFwiXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsb3QudHlwZSA9PT0gXCJsaW5lXCIgfHwgcGxvdC50eXBlID09PSBcInNjYXR0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGxvdFtcInhcIl0gPSBwbG90LmRhdGEubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYueDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieVwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi55OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbG90LnR5cGUgPT09IFwiaGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1widmFsdWVzXCJdID0gcGxvdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdQbG90O1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBcInhsYWJlbFwiOiBcIlwiLCBcInlsYWJlbFwiOiBcIlwiLCBcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiXCIsIFwibGVnZW5kXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkob3V0cHV0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIC8vIFByb3ZpZGVzIGBzdHVkZW50YCBhcyBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIGRhdGEgdGhhdCB0aGUgc3R1ZGVudCBkZWNsYXJlZC5cbiAgICBtb2QuU3R1ZGVudERhdGEgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgZnVuY3Rpb24oJGdibCwgJGxvYykge1xuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICAvL3NlbGYuZGF0YSA9IFNrLmJ1aWx0aW4uZGljdCgpO1xuICAgICAgICAgICAgbGV0IG5ld0RpY3QgPSBuZXcgU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBTay5hYnN0ci5zYXR0cihzZWxmLCBuZXcgU2suYnVpbHRpbi5zdHIoXCJkYXRhXCIpLCBuZXdEaWN0LCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYubW9kdWxlID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ucmVzdWx0cztcbiAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBzZWxmLm1vZHVsZS4kZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLmFic3RyLm9iamVjdFNldEl0ZW0obmV3RGljdCwgU2suZmZpLnJlbWFwVG9QeShTay51bmZpeFJlc2VydmVkKGtleSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FsbF9mID0gZnVuY3Rpb24oa3dhKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFwiY2FsbFwiLCBhcmd1bWVudHMubGVuZ3RoLCAxLCBJbmZpbml0eSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIga3dhcmdzID0gbmV3IFNrLmJ1aWx0aW5zLmRpY3Qoa3dhKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSBhcmdzWzBdO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgyKTtcblxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGt3YXJncy5tcCRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKFwiaW5wdXRzXCIpKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFNrLmZmaS5yZW1hcFRvSnMoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIikpO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uT2JqZWN0ID0gZGF0YS5tcCRsb29rdXAoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbk9iamVjdC50cCRjYWxsKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbF9mLmNvX2t3YXJncyA9IHRydWU7XG4gICAgICAgIC8vY2FsbF9mLmNvX3Zhcm5hbWVzID0gW1wic2VsZlwiLCBcImZ1bmN0aW9uXCJdO1xuICAgICAgICBjYWxsX2YuY29fbmFtZT0gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiY2FsbFwiKTtcbiAgICAgICAgJGxvY1tcImNhbGxfJHJuJFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoY2FsbF9mKTtcblxuICAgICAgICAkbG9jW1wiX19yZXByX19cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZ2V0X25hbWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfbmFtZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQocHJvcGVydHkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgJGxvYy5nZXRfdmFsdWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfdmFsdWVzX2J5X3R5cGVcIiwgYXJndW1lbnRzLCAyLCAzKTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImV4Y2x1ZGVfYnVpbHRpbnNcIiwgXCJib29sZWFuXCIsIFNrLmJ1aWx0aW4uY2hlY2tCb29sKGV4Y2x1ZGVfYnVpbHRpbnMpKTtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gU2suZmZpLnJlbWFwVG9KcyhleGNsdWRlX2J1aWx0aW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHNlbGYubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGVbcHJvcGVydHldLnRwJG5hbWUgPT09IHR5cGUudHAkbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSwgXCJTdHVkZW50RGF0YVwiKTtcbiAgICBtb2Quc3R1ZGVudCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQobW9kLlN0dWRlbnREYXRhKTtcbiAgICBcbiAgICBtb2QuZ2V0X3N0dWRlbnRfZGF0YSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9kYXRhXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBtb2Quc3R1ZGVudDtcbiAgICB9KTtcblxuICAgIG1vZC5zZXRfaW5zdHJ1Y3Rpb25zID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihuZXdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInNldF9pbnN0cnVjdGlvbnNcIiwgYXJndW1lbnRzLCAxLCAyKTtcbiAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gU2suZmZpLnJlbWFwVG9KcyhuZXdJbnN0cnVjdGlvbnMpO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wibW9kZWxcIl0uZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG5ld0luc3RydWN0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBtb2QuZ2V0X21vZGVsX2luZm8gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9tb2RlbF9pbmZvXCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBtb2RlbCA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXTtcbiAgICAgICAga2V5cyA9IFNrLmZmaS5yZW1hcFRvSnMoa2V5cykuc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KG1vZGVsKCkpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBtb2Q7XG59O1xuIiwibGV0IExPQ0FMX1NUT1JBR0VfUkVGO1xudHJ5IHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRiA9IGxvY2FsU3RvcmFnZTtcbiAgICBsZXQgbW9kID0gXCJCTE9DS1BZX0xPQ0FMU1RPUkFHRV9URVNUXCI7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbShtb2QpO1xufSBjYXRjaChlKSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYgPSB7XG4gICAgICAgIF9kYXRhICAgICAgIDoge30sXG4gICAgICAgIHNldEl0ZW0gICAgIDogZnVuY3Rpb24oaWQsIHZhbCkgeyByZXR1cm4gdGhpcy5fZGF0YVtpZF0gPSBTdHJpbmcodmFsKTsgfSxcbiAgICAgICAgZ2V0SXRlbSAgICAgOiBmdW5jdGlvbihpZCkgeyByZXR1cm4gdGhpcy5fZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgPyB0aGlzLl9kYXRhW2lkXSA6IG51bGw7IH0sXG4gICAgICAgIHJlbW92ZUl0ZW0gIDogZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGRlbGV0ZSB0aGlzLl9kYXRhW2lkXTsgfSxcbiAgICAgICAgY2xlYXIgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGEgPSB7fTsgfVxuICAgIH07XG59XG5cbi8qKlxuICogSGVscGVyIG9iamVjdCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgTG9jYWxTdG9yYWdlLiBUaGUgTG9jYWxTdG9yYWdlXG4gKiBicm93c2VyIEFQSSBhbGxvd3MgZm9yIG9mZmxpbmUgc3RvcmFnZS4gVGhhdCBBUEkgaXMgdmVyeSB1bnNvcGhpc3RpY2F0ZWQsXG4gKiBhbmQgaXMgZXNzZW50aWFsbHkgYSBsYW1lIGtleS12YWx1ZSBzdG9yZS4gVGhpcyBvYmplY3Qgc2l0cyBvbiB0b3BcbiAqIGFuZCBwcm92aWRlcyBhIG51bWJlciBvZiB1c2VmdWwgdXRpbGl0aWVzLCBpbmNsdWRpbmcgcnVkaW1lbnRhcnljYWNoZVxuICogY2FjaGUgZXhwaXJhdGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtMb2NhbFN0b3JhZ2VXcmFwcGVyfVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIEEgbmFtZXNwYWNlIHRvIHVzZSBpbiBncm91cGluZyBhY2Nlc3MgdG8gbG9jYWxzdG9yYWdlLiBUaGlzIGtlZXBzIGFjY2VzcyBjbGVhbiBhbmQgb3JnYW5pemVkLCB3aGlsZSBhbHNvIG1ha2luZyBpdCBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIExvY2FsU3RvcmFnZSBjb25uZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIExvY2FsU3RvcmFnZVdyYXBwZXIobmFtZXNwYWNlKSB7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG59XG4vKipcbiAqIEEgbWV0aG9kIGZvciBhZGRpbmcgYSBrZXkvdmFsdWUgcGFpciB0byBMb2NhbFN0b3JhZ2UuXG4gKiBOb3RlIHRoYXQgYm90aCBwYXJhbWV0ZXJzIG11c3QgYmUgc3RyaW5ncyAoSlNPTi5zdHJpbmdpZnkgaXMgeW91ciBmcmllbmQpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXQgPSAgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIsIHZhbHVlKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIiwgJC5ub3coKSk7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZW1vdmluZyBhIGtleSBmcm9tIExvY2FsU3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZW1vdmUuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmb3IuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHRpbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHRpbWUgZm9yLlxuICogQHJldHVybnMge0ludGVnZXJ9IC0gVGhlIHRpbWVzdGFtcCAobG9jYWwgZXBvY2gpIHdoZW4gdGhlIGtleSB3YXMgbGFzdCBzZXQuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICogSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCwgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSBpcyB1c2VkIGluc3RlYWQuXG4gKiBUaGlzIGRlZmF1bHQgd2lsbCBiZSBzZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UuIE11c3QgYmUgYSBzdHJpbmcuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgdGVzdCBmb3Igd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIGluIExvY2FsU3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB0ZXN0IGV4aXN0ZW5jZSBmb3IuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKSAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogQSB0ZXN0IGZvciB3aGV0aGVyIHRoZSBzZXJ2ZXIgaGFzIHRoZSBuZXdlciB2ZXJzaW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBhc3N1bWVzIHRoYXQgdGhlIHNlcnZlciB0cmlwIHRha2VzIGFib3V0IDUgc2Vjb25kcy4gVGhpcyBtZXRob2RcbiAqIGlzIGxhcmdlbHkgZGVwcmVjYXRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gc2VydmVyX3RpbWUgLSBUaGUgc2VydmVyJ3MgdGltZSBhcyBhbiBlcG9jaCAoaW4gbWlsbGlzZWNvbmRzKVxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pc19uZXcgPSBmdW5jdGlvbihrZXksIHNlcnZlcl90aW1lKSB7XG4gICAgdmFyIHN0b3JlZF90aW1lID0gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpO1xuICAgIHJldHVybiAoc2VydmVyX3RpbWUgPj0gc3RvcmVkX3RpbWUrNTAwMCk7XG59O1xuIiwiZXhwb3J0IGNvbnN0IFRSQUNFX0hUTUwgPSBgXG5cbjxkaXYgY2xhc3M9XCJibG9ja3B5LXRyYWNlIGNvbC1tZC02IGJsb2NrcHktcGFuZWxcIlxuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJUcmFjZVwiPlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPlxuICAgICAgICA8c3Ryb25nPlRyYWNlOiA8L3N0cm9uZz5cbiAgICAgICAgXG4gICAgICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbidcbiAgICAgICAgICAgICAgICBjbGFzcz0nYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgZmxvYXQtcmlnaHQgYmxvY2tweS1oaWRlLXRyYWNlJ1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPiBIaWRlIFRyYWNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIG1iLTMgYmxvY2tweS10cmFjZS1jb250cm9sc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtcHJlcGVuZFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5maXJzdFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmJhY2t3YXJkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1iYWNrd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5TdGVwOjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCc+PC9zcGFuPlxuICAgICAgICAgICAgICAgIC8gPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBleGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5mb3J3YXJkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1mb3J3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UubGFzdFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogdWkudHJhY2UubGluZSc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8dGFibGUgY2xhc3M9J3RhYmxlIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWQgdGFibGUtaG92ZXInPlxuICAgICAgICA8Y2FwdGlvbj5DdXJyZW50IHZhcmlhYmxlcyBhdCB0aGlzIHN0ZXA8L2NhcHRpb24+XG4gICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgIDx0cj48dGg+TmFtZTwvdGg+PHRoPlR5cGU8L3RoPjx0aD5WYWx1ZTwvdGg+PC90cj5cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5IGRhdGEtYmluZD1cImZvcmVhY2g6IHVpLnRyYWNlLmRhdGEoKS5wcm9wZXJ0aWVzXCI+XG4gICAgICAgICAgICA8dHIgZGF0YS1iaW5kPVwidmlzaWJsZTogbmFtZSAhPSAnX19maWxlX18nICYmIG5hbWUgIT0gJ19fcGF0aF9fJ1wiPlxuICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgZGF0YS1iaW5kPVwidGV4dDogdHlwZVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICA8Y29kZSBkYXRhLWJpbmQ9XCJ0ZXh0OiB2YWx1ZVwiPjwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBrbyBpZjogdHlwZSA9PSBcIkxpc3RcIiAtLT5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJcIiBkYXRhLWJpbmQ9XCJjbGljazogLy8kcm9vdC52aWV3RXhhY3RWYWx1ZSh0eXBlLCBleGFjdF92YWx1ZSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2dseXBoaWNvbiBnbHlwaGljb24tbmV3LXdpbmRvdyc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICAgXG48L2Rpdj5cbmA7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5VHJhY2Uge1xuXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgICAgIHRoaXMuSUdOT1JFRF9HTE9CQUxTID0gW1wiX19uYW1lX19cIiwgXCJfX2RvY19fXCIsIFwiX19wYWNrYWdlX19cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc21ldGhvZFwiLCBcInByb3BlcnR5XCIsIFwic3RhdGljbWV0aG9kXCJdO1xuXG4gICAgICAgIC8vIHRoaXMudHJhY2UuY2xpY2sodGhpcy5idWlsZFRyYWNlVGFibGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3VtZSBhIHNldCBvZiB2YXJpYWJsZXMgdHJhY2VkIGZyb20gdGhlIGV4ZWN1dGlvbiBhbmQgcGFyc2Ugb3V0IGFueVxuICAgICAqIGdsb2JhbCB2YXJpYWJsZXMgYW5kIG1vZHVsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFyaWFibGVzIC0gYSBtYXBwaW5nIG9mIHZhcmlhYmxlIG5hbWVzIHRvIHRoZWlyIFNrdXB0IHZhbHVlLlxuICAgICAqL1xuICAgIHBhcnNlR2xvYmFscyh2YXJpYWJsZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbW9kdWxlcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnRyYWNlRXhlY3V0aW9uKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhcmlhYmxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSUdOT1JFRF9HTE9CQUxTLmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoXCJfJHJ3JFwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJfJHJuJFwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEJsb2NrUHlUcmFjZS5wYXJzZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0ge1wibmFtZVwiOiBwcm9wZXJ0eSwgXCJ0eXBlXCI6IFwiVW5rbm93blwiLCBcInZhbHVlXCI6IHZhbHVlLnRvU3RyaW5nKCl9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4ubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLnB1c2godmFsdWUuJGQuX19uYW1lX18udik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcInByb3BlcnRpZXNcIjogcmVzdWx0LCBcIm1vZHVsZXNcIjogbW9kdWxlc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBTa3VscHQgdmFsdWUgaW50byBhIG1vcmUgZWFzaWx5IHByaW50YWJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgc2t1bHB0IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlLCBmdWxsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJVbmtub3duXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlVuZGVmaW5lZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5mdW5jOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIEFyZ3VtZW50czogXCIrdmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzLmpvaW4oXCIsIFwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgTm8gYXJndW1lbnRzXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5tb2R1bGU6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnN0cjpcbiAgICAgICAgICAgICAgICBpZiAoZnVsbExlbmd0aCB8fCB2YWx1ZS52Lmxlbmd0aCA8PSAzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIltcIit2YWx1ZS5zcSRsZW5ndGgoKStcIiBjaGFyYWN0ZXJzIG5vdCBzaG93bl1cIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5ub25lOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJOb25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJOb25lXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmJvb2w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5tYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRcIiA9PT0gdmFsdWUuc2tUeXBlID8gXCJJbnRlZ2VyXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmludF86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZsb2F0XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnR1cGxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJUdXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubGlzdDpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudi5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJbLi4uIFwiK3ZhbHVlLnYubGVuZ3RoK1wiIGVsZW1lbnRzIC4uLl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZGljdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHZhbHVlICUgMSA9PT0gMCA/IFwiSW50ZWdlclwiIDogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiAodmFsdWUgPyBcIlRydWVcIjogXCJGYWxzZVwiKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUudHAkbmFtZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiB2YWx1ZS50cCRuYW1lLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUT0RPOiB2aWV3RXhhY3RWYWx1ZSIsIi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7YW55dGhpbmd9IG5lZWRsZSAtIFRoZSBlbGVtZW50IHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtBcnJheX0gaGF5c3RhY2sgLSBUaGUgbGlzdCB0byBzZWFyY2guXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IGV4aXN0c1xuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID4gLTE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheSwgcHJlc2VydmluZyBvcmRlci5cbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXksIHNvIGlzIG5vbi1kZXN0cnVjdGl2ZS5cbiAqIENvdXJ0ZXN5OlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU4NDM3MC9ob3ctdG8tbWVyZ2UtdHdvLWFycmF5cy1pbi1qYXZhc2NyaXB0LWFuZC1kZS1kdXBsaWNhdGUtaXRlbXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB1bmlxdWlmeS4gRWxlbWVudHMgY29tcGFyZWQgd2l0aCA9PT0uXG4gKi9cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgdmFyIGEgPSBhcnJheS5jb25jYXQoKTtcbiAgICBmb3IodmFyIGk9MDsgaTxhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYoYVtpXSA9PT0gYVtqXSkge2Euc3BsaWNlKGotLSwgMSk7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4dGVuZGluZyBhbiBhcnJheSBiYXNlZFxuICogb24gYW4gXCJhZGRBcnJheVwiIGFuZCBcInJlbW92ZUFycmF5XCIuIEFueSBlbGVtZW50XG4gKiBmb3VuZCBpbiByZW1vdmVBcnJheSBpcyByZW1vdmVkIGZyb20gdGhlIGZpcnN0IGFycmF5XG4gKiBhbmQgYWxsIHRoZSBlbGVtZW50cyBvZiBhZGRBcnJheSBhcmUgYWRkZWQuXG4gKiBBbnkgZHVwbGljYXRlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIG1hbmlwdWxhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFkZEFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZUFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBtb2RpZmllZCBhcnJheVxuICovXG5mdW5jdGlvbiBleHBhbmRBcnJheShhcnJheSwgYWRkQXJyYXksIHJlbW92ZUFycmF5KSB7XG4gICAgdmFyIGNvcHlBcnJheSA9IGFycmF5LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVBcnJheS5pbmRleE9mKGl0ZW0pID09PSAtMTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29weUFycmF5LmNvbmNhdChhZGRBcnJheSkpO1xufVxuXG4vKipcbiAqIERlZXBseSBjbG9uZXMgYSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQSBub2RlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHtOb2RlfSBBIGNsb25lIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbGwgaXRzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUsIHRoZW4gcmUtY3JlYXRlIGl0IHJhdGhlciB0aGFuIGNsb25lIGl0XG4gICAgdmFyIGNsb25lID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuIFxuICAgIC8vIFJlY3Vyc2UgICAgIFxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjaGlsZCkge1xuICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChjbG9uZU5vZGUoY2hpbGQpKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gICAgIFxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBJbmRlbnRzIHRoZSBnaXZlbiBzdHJpbmcgYnkgNCBzcGFjZXMuIFRoaXMgY29ycmVjdGx5IGhhbmRsZXMgbXVsdGktbGluZSBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyB3aXRoIGZvdXIgc3BhY2VzIGFkZGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuZXcgbGluZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oPz0uKS9nbSwgXCIgICAgXCIpO1xufVxuXG4vKipcbiAqIFR1cm5zIHNwYWNlcyBpbnRvIHVuZGVyc2NvcmVzIGluIHRoZSBzdHJpbmcsIG1ha2VzIGl0IGxvd2VyY2FzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSB0aGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2x1ZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccy9nLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gYmUgY2FwaXRhbGl6ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbYG1pbmAsIGBtYXhgXS5cbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBsb3dlc3QgcG9zc2libGUgaW50ZWdlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgaGlnaGVzdCBwb3NzaWJsZSBpbnRlZ2VyIChpbmNsdXNpdmUpLlxuICogQHJldHVybnMge251bWJlcn0gQSByYW5kb20gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50ZWdlcihtaW4sbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWF4LW1pbisxKSttaW4pO1xufVxuXG4vKipcbiAqIEVuY29kZXMgc29tZSB0ZXh0IHNvIHRoYXQgaXQgY2FuIGJlIHNhZmVseSB3cml0dGVuIGludG8gYW4gSFRNTCBib3guXG4gKiBUaGlzIGluY2x1ZGVzIHJlcGxhY2luZyBzcGVjaWFsIEhUTUwgY2hhcmFjdGVycyAoJiwgPCwgPiwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0ZXh0IHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEhUTUwtc2FmZSB0ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSFRNTChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKTtcbn1cblxuLyoqXG4gKiBTaHVmZmxlIHRoZSBibG9ja3MgaW4gdGhlIHdvcmtzcGFjZVxuICovXG5pZiAodHlwZW9mIEJsb2NrbHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBCbG9ja2x5LldvcmtzcGFjZVN2Zy5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMuZ2V0TWV0cmljcygpO1xuICAgICAgICB2YXIgd2lkdGggPSBtZXRyaWNzLnZpZXdXaWR0aCAvIDIsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZXRyaWNzLnZpZXdIZWlnaHQ7XG4gICAgICAgIHZhciBibG9ja3MgPSB0aGlzLmdldFRvcEJsb2NrcyhmYWxzZSk7XG4gICAgICAgIHZhciB5ID0gNSwgeCA9IDAsXG4gICAgICAgICAgICBtYXhpbWFsX2luY3JlYXNlID0gaGVpZ2h0L2Jsb2Nrcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCBhIGJsb2NrXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IGJsb2NrLmdldFJlbGF0aXZlVG9TdXJmYWNlWFkoKTtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC1wcm9wZXJ0aWVzLngrcmFuZG9tSW50ZWdlcigxMCwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2subW92ZUJ5KHgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIC1wcm9wZXJ0aWVzLnkreSk7XG4gICAgICAgICAgICB5ID0geSArIHJhbmRvbUludGVnZXIoNSwgbWF4aW1hbF9pbmNyZWFzZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE1vdmUgZWxlbWVudHMgZnJvbSBvbmUgYXJyYXkgdG8gYW5vdGhlciBiYXNlZCBvbiBhIGNvbmRpdGlvbmFsIGNoZWNrLlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzE4ODc5NjcvamF2YXNjcmlwdC1tb3ZlLW9iamVjdHMtZnJvbS1vbmUtYXJyYXktdG8tYW5vdGhlci1iZXN0LWFwcHJvYWNoXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50cyhzb3VyY2UsIHRhcmdldCwgbW92ZUNoZWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChtb3ZlQ2hlY2soZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH0gXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIG9iamVjdHNcbiAqIFRPRE86IG1ha2UgdGhpcyBzbyB3ZSBkb24ndCBoYXZlIHRvIGV4cGxpY2l0bHkgcHV0IG91dCBldmVyeSBvcHRpb25cbiAqICAgICAgICAgIG9uZSBwb3NzaWJsZSB0aGluZyB3ZSBjb3VsZCBkbyBpcyBnZXQgYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgXG4gKiAgICAgICAgICBvZiB0aGUgY29uc3RydWN0b3IgYW5kIGxvb2sgZm9yIHRoZSBzdWJzdHJpbmcgXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIlxuICogICAgICAgICAgQnV0IEkgZG9uJ3Qga25vdyBob3cgcmVsaWFibGUgdGhhdCBpcy4gIFJhdGhlciwgaXQncyBraW5kIG9mIGhhY2tpc2guXG4gKiAgICAgICAgICBTaG91bGQgdGVob3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBleGFtaW5lZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG9uZSBvZiB0aGUgU2suYnVpbHRpbiB0eXBlc1xuKiovXG5mdW5jdGlvbiBpc1NrQnVpbHRpbihvYmope1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbCkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyk7XG4gICAgLy92YXIgY29uc19zdHIgPSBvYmouY29uc3RydWN0b3IgKyBcIlwiO1xuICAgIC8vcmV0dXJuIGNvbnNfc3RyLmluZGV4T2YoXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0FzdE5vZGUob2JqKXtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmIFwiX2FzdG5hbWVcIiBpbiBvYmo7XG59XG5cbi8qKlxuICogU2hvdWxkIHRoZW9yZXRpY2FsbHkgYmVsb25nIGluIFNrLmZmaSwgYnV0IEkgcHV0IGl0IGhlcmUgaW5zdGVhZCB0byBub3QgbWVzcyB1cCB0aGUgc2t1bHB0IGZpbGVzXG4gKiBsaWtlIHRoZSBub3JtYWwgU2suZmZpLnJlbWFwVG9QeSwgaXQgZG9lc24ndCB3b3JrIGZvciBmdW5jdGlvbnMgb3IgbW9yZSBjb21wbGV4IG9iamVjdHMsIGJ1dCBpdCBoYW5kbGVzXG4gKiBjYXNlcyB3aGVyZSB0aGUgdHlwZXMgaW4gb2JqIGFyZSBhIG1peCBvZiBweXRob24gU0lNUExFIG9iamVjdHMgYW5kIFNJTVBMRSBub3JtYWwgamF2YXNjcmlwdCBvYmplY3RzXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge1NrLmJ1aWx0aW4uPz8/fSAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcHl0aG9uIG9iamVjdCwgZHJvcHBpbmcgYWxsIGZ1bmN0aW9ucyBhbmQgdGhpbmdzIGl0IGNhbid0IGNvbnZlcnRcbioqL1xuZnVuY3Rpb24gbWl4ZWRSZW1hcFRvUHkob2JqKXtcbiAgICB2YXIgaztcbiAgICB2YXIga3ZzO1xuICAgIHZhciBpO1xuICAgIHZhciBhcnI7XG4gICAgLy9AVE9ETzogc2hvdWxkIHRoZW9yZXRpY2FsbHkgY2hlY2sgaWYgdGhlIG9iamVjdCBpcyBhIHB5aG9uIGRpY3Qgb3IgYXJyYXkgd2l0aCBqcyBvYmplY3RzXG4gICAgaWYgKGlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAvL29iamVjdCBpcyBhbHJlYWR5IHB5dGhvbiByZWFkeVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAvL29iamVjdCBpcyBhY3R1YWxseSBhIGphdmFzY3JpcHQgYXJyYXlcbiAgICAgICAgYXJyID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggb2JqZWN0LCBjb252ZXJ0IGl0IHRvIGEgcHl0aG9uIG9iamVjdCBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgdmFyIHN1YnZhbCA9IG9ialtpXTtcbiAgICAgICAgICAgIGlmKCFpc1NrQnVpbHRpbihzdWJ2YWwpKXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChtaXhlZFJlbWFwVG9QeShzdWJ2YWwpKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHN1YnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYXJyKTtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkgey8vbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYoIWlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAgICAgLy9hc3N1bWluZyBpdCdzIGEgc3RhbmRhcmQgZGljdGlvbmFyeVxuICAgICAgICAgICAga3ZzID0gW107Ly9Tay5idWlsdGluLmRpY3QgdXNlcyBhbiBhcnJheSBvZiBrZXktdmFsdWUsa2V5LXZhbHVlLi4uXG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBrZXkgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkoaykpO1xuICAgICAgICAgICAgICAgIC8vY292ZXJ0IGNvcnJlc3BvbmRpbmcgdmFsdWUgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkob2JqW2tdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgbmV3IGRpY3Rpb25hcnlcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KGt2cyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLmFzc2skKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChvYmopO1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihvYmoubmFtZSk7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fOyJdLCJzb3VyY2VSb290IjoiIn0=