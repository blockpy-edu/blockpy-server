(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var skulpt_modules_weakref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! skulpt_modules/weakref */ "./src/skulpt_modules/weakref.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */




 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_5__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration;
      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray(Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(configuration["assignment.extra_instructor_files"]) || []),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(configuration["submission.code"] || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_7__["DisplayModes"].SPLIT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK),
          previousSecondRowSecondPanel: ko.observable(null),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),

          /**
           * Whether or not images should be rendered (true), or just stay as text code (false).
           */
          renderImages: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true"),

          /**
           * Uploaded files are ones that have been listed by the remote
           */
          uploadedFiles: ko.observable(null)
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          listUploadedFiles: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          listUploadedFilesMessage: ko.observable(""),
          // @type {ServerStatus}
          downloadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          downloadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          uploadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          uploadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {}
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.submission.code(submission.code);
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status);
      this.model.submission.submissionStatus(submission.submission_status);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.log(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          toggleImages: function toggleImages() {
            if (model.display.renderImages()) {
              self.components.pythonEditor.bm.textEditor.disableImages();
            } else {
              self.components.pythonEditor.bm.textEditor.enableImages();
            }

            model.display.renderImages(!model.display.renderImages());
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          })
        },
        secondRow: {
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            }
          },
          makeWide: function makeWide() {
            var currentPanel = model.display.secondRowSecondPanel;
            model.display.previousSecondRowSecondPanel(currentPanel());
            currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
          },
          restorePanel: function restorePanel() {
            var oldPanel = model.display.previousSecondRowSecondPanel;

            if (oldPanel() !== null) {
              model.display.secondRowSecondPanel(oldPanel());
              oldPanel(null);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          })
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + (traceData[step].line - 1);
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?images.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?images.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?images.blockpy":
                self.components.fileSystem.newFile(path, "{}");
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          rename: function rename(newName) {
            return self.components.fileSystem.renameFile(model.display.filename(), newName);
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?images.blockpy") {
              return "Images";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideEditors() ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_10__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          images: {
            reloadImages: function reloadImages() {
              return self.components.editors.byName("image").reloadImages();
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          }),
          runLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run";
          }),
          run: function run() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun();
            }
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/weakref.js"] = weakrefModule.toString();
      //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_16__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_15__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_13__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_14__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_12__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_10__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_6__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_8__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_18__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_19__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='col-md-6 blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.position().top; //$('html').scrollTop(top);

        $("html").scrollTop(0); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.position().top;
        $("html").scrollTop(0);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};

      this.main.model.ui.secondRow.restorePanel();
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();
      console.log(inputIndex, this.main.model.execution.input().length);

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "handlePygameResize",
    value: function handlePygameResize(newWidth, newHeight) {
      // If the user hasn't changed the console size, and the newHeight is bigger than default, we'll change it
      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height() && newHeight > this.DEFAULT_HEIGHT) {
        this.printerTag.height(30 + newHeight);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      } // If the pygame window is wider than the console, we'll expand temporarily.


      if (newWidth > this.printerTag.width()) {
        this.main.model.ui.secondRow.makeWide();
      }
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else if (this.pygameLine) {
          var _canvas = this.pygameLine.canvas;

          var _dataUrl = _canvas.toDataURL("image/png");

          this.main.components.server.saveImage("turtle_output", _dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_LISTING_UPLOADED_FILES = function (reason) {
  this.show("Error Listing Uploaded Files", "BlockPy encountered an error while listing the uploaded files.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_UPLOADING_FILE = function (reason) {
  this.show("Error Uploaded File", "BlockPy encountered an error while uploading the file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle (and pygame) output is saved whenever the program uses it."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/images.js":
/*!******************************!*\
  !*** ./src/editor/images.js ***!
  \******************************/
/*! exports provided: IMAGE_EDITOR_HTML, ImageEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_EDITOR_HTML", function() { return IMAGE_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageEditor", function() { return ImageEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var IMAGE_EDITOR_HTML = "\n     <div>\n        <h3>Available Images</h3>\n        \n        <button data-bind=\"click: ui.editors.images.reloadImages\">Reload Available Images</button>\n        <!-- ko if: display.uploadedFiles() !== null -->\n            <ul>\n                <!-- ko foreach: { data: Object.keys(display.uploadedFiles()), as: 'placement' } -->\n                <li>\n                    <strong data-bind=\"text: $data\"></strong>:\n                    <ul>\n                    <!-- ko foreach: { data: $root.display.uploadedFiles()[placement], as: 'filename' } -->\n                        <li>\n                            <span data-bind=\"text: filename[0]\"></span>:\n                            <img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                width=\"30px\" height=\"30px\"/>\n                        </li>\n                    <!-- /ko -->\n                    </ul>\n                </li>\n                <!-- /ko -->\n            </ul>\n        <!-- /ko -->\n    </div>\n";

var ImageEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ImageEditorView, _AbstractEditor);

  var _super = _createSuper(ImageEditorView);

  function ImageEditorView(main, tag) {
    _classCallCheck(this, ImageEditorView);

    return _super.call(this, main, tag);
  }

  _createClass(ImageEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ImageEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      var uploadedFiles = this.main.model.display.uploadedFiles();

      if (uploadedFiles === null) {
        this.reloadImages();
      }

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      /*
      this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
        // Notify relevant file of changes to BM
      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);*/
    }
  }, {
    key: "reloadImages",
    value: function reloadImages() {
      var _this = this;

      this.main.components.server.listUploadedFiles(function (response) {
        if (response.success) {
          _this.main.model.display.uploadedFiles(response.files);
        } else {
          _this.main.components.dialogs.ERROR_LISTING_UPLOADED_FILES(response.message);
        }
      });
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {}
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      /*this.dirty = !this.dirty;
      if (this.dirty) {
          this.dirty = true;
          this.file.handle(this.codeMirror.getValue());
          this.dirty = false;
      }*/
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();

      _get(_getPrototypeOf(ImageEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ImageEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ImageEditor = {
  name: "Image",
  extensions: ["?images.blockpy"],
  constructor: ImageEditorView,
  template: IMAGE_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */


var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> <span data-bind=\"text: ui.execute.runLabel\"></span>\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() -->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHook: function imageDownloadHook(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        //const uuid = window.URL.createObjectURL(new Blob([])).substring(31);
        return new Promise(function (resolve, reject) {
          var submissionId = main.model.submission.id();
          main.components.server.uploadFile("submission", submissionId, blob.name, blob, function (response) {
            resolve(JSON.stringify(response.endpoint)); //resolve(JSON.stringify(main.model.configuration.urls["downloadFile"] + `?placement=submission&directory=${submissionId}&filename=${blob.name}`));
          }); //return Promise.resolve("Image("+JSON.stringify(URL.createObjectURL(blob))+")");
          //return Promise.resolve(JSON.stringify(URL.createObjectURL(blob)));
        });
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        //return `Image("${oldUrl}")`;
        return "\"".concat(oldUrl, "\"");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      });
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
/* harmony import */ var _editor_images__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./editor/images */ "./src/editor/images.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */










/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"], _editor_images__WEBPACK_IMPORTED_MODULE_9__["ImageEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"col-md-12 blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "'\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback()) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          _this2.configuration.provideSecretError();

          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // TODO: Make this set by the system so we can use our own servers in practice
        emojiProxy: function emojiProxy(part) {
          return "https://twemoji.maxcdn.com/v/13.1.0/svg/".concat(part.toLowerCase(), ".svg");
        },
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../files */ "./src/files.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found, but not __main__ modules

      this.sysmodules = this.clearExistingStudentImports(); // Horrific hack, to prevent Tifa from caching a bad version of the students' import

      Sk.clearExistingStudentImports = this.clearExistingStudentImports;
      return this;
    }
  }, {
    key: "clearExistingStudentImports",
    value: function clearExistingStudentImports() {
      var sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      if (sysmodules !== undefined) {
        var _iterator = _createForOfIteratorHelper(this.getAllFilenames()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var filename = _step.value;
            var skFilename = new Sk.builtin.str(filename);

            if (sysmodules.quick$lookup(skFilename)) {
              sysmodules.del$item(skFilename);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return sysmodules;
    }
  }, {
    key: "getAllStudentFiles",
    value: function getAllStudentFiles() {
      var files = {
        "answer.py": this.main.model.ui.files.getStudentCode()
      }; // Skip special instructor files

      this.main.model.assignment.extraInstructorFiles().forEach(function (file) {
        if (!"!^$#".includes(file.filename()[0])) {
          files[file.filename()] = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(file.contents());
        }
      }); // Include normal student extra files

      this.main.model.submission.extraFiles().forEach(function (file) {
        files[file.filename()] = file.contents();
      });
      return files;
    }
  }, {
    key: "getAllFilenames",
    value: function getAllFilenames() {
      function clean(filename) {
        filename = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(filename);

        if (filename.endsWith(".py")) {
          filename = filename.slice(0, -3);
        }

        return filename;
      }

      return ["__main__", "_instructor"].concat(_toConsumableArray(this.main.model.assignment.extraInstructorFiles().map(function (file) {
        return "_instructor." + clean(file.filename());
      })), _toConsumableArray(this.main.model.submission.extraFiles().map(function (file) {
        return clean(file.filename());
      })));
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      console.log(">>>", this.main.model.execution.input(), this.main.model.execution.inputIndex());

      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\n# MAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, "['evaluation'])\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(_on_run__WEBPACK_IMPORTED_MODULE_2__["INSTRUCTOR_MARKER"], "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";

      var studentFiles = this.getAllStudentFiles();
      studentFiles["evaluation"] = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      console.log(">>>", instructorCode);
      var lineOffset = Object(_on_run__WEBPACK_IMPORTED_MODULE_2__["findActualInstructorOffset"])(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: findActualInstructorOffset, INSTRUCTOR_MARKER, NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findActualInstructorOffset", function() { return findActualInstructorOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSTRUCTOR_MARKER", function() { return INSTRUCTOR_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function findActualInstructorOffset(instructorCode) {
  var index = instructorCode.indexOf(INSTRUCTOR_MARKER);
  var before = instructorCode.slice(0, index);
  var match = before.match(NEW_LINE_REGEX);
  return match ? 1 + match.length : 0;
}
var INSTRUCTOR_MARKER = "###Run the actual instructor code###";
var NEW_LINE_REGEX = /\n/g;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentFiles);
  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom cisc108 import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          files=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(INSTRUCTOR_MARKER, "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa(); // Put the input index back to the front, so we can replay inputs

      this.main.model.execution.inputIndex(1);
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentFiles = this.getAllStudentFiles();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      var lineOffset = findActualInstructorOffset(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;
      //lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode();

      if (this.main.model.assignment.settings.disableStudentRun()) {
        this.code = "";
      } //this.code = this.main.model.submission.code();


      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        if (Sk.builtinFiles && Sk.builtinFiles["files"][filename] !== undefined) {
          return Sk.builtinFiles["files"][filename];
        } else {
          throw new Sk.builtin.OSError("File not found: " + filename);
        }
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring) {
      if (filename === "answer.py") {
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(globals); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear();
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback col-md-6 blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 1000);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      this.feedbackModel.message("*Ready*");
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);
        this.scrollIntoView();
      }
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this4 = this;

      return error.traceback.map(function (frame) {
        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, chompSpecialFile, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chompSpecialFile", function() { return chompSpecialFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?images.blockpy'),\n                           click: ui.files.add.bind($data, '?images.blockpy')\">Images</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
function chompSpecialFile(filename) {
  if ("!^?&$*#".includes(filename[0])) {
    return filename.slice(1);
  } else {
    return filename;
  }
}
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(filename, _contents) {
  return {
    filename: function (_filename) {
      function filename() {
        return _filename.apply(this, arguments);
      }

      filename.toString = function () {
        return _filename.toString();
      };

      return filename;
    }(function () {
      return filename;
    }),
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var _filename2 in files) {
      if (files.hasOwnProperty(_filename2)) {
        modelFiles.push(makeModelFile(_filename2, files[_filename2]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    if (modelFileList) {
      modelFileList(modelFiles);
    } else {
      return modelFiles;
    }
  } else {
    if (modelFileList) {
      modelFileList([]);
    } else {
      return [];
    }
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.main.model.display.instructor.subscribe(function (visiblity) {
      $(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "renameFile",
    value: function renameFile(source, destination) {
      if (UNRENAMABLE_FILES.indexOf(source) !== -1) {
        return false;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(hiddenVersion, defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row'>\n         \n         <!-- Description -->\n         <div class='col-md-9 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-3 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <!-- Fullscreen button -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\">\n                <span class='fas' data-bind=\"class: ui.menu.textFullscreen\"></span>\n            </button>\n            <!-- Edit Queued Inputs -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\">\n                <span class='fas fa-list-alt'></span>\n            </button>\n            <!-- Toggle Image Rendering -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-toggle=\"button\"\n                data-bind=\"click: ui.menu.toggleImages\" title=\"Toggle Images\">\n                <span class=\"fas fa-images\"></span>\n            </button>\n            <!-- Pink Bug for actual errors -->\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div class='row'>\n    \n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n         \n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        \n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n         \n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible -->\n    <div class='row'>\n        ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    <div class=\"row\">\n        ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    </div>\n\n    <!-- Row 5: Footer Row -->    \n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  var extraSettings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  this.showOverlay(attempts);
  return $.ajax(_objectSpread({
    type: "POST",
    url: this.urls[endpoint],
    data: data
  }, extraSettings)).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.listUploadedFiles = function (callback) {
  var _this10 = this;

  if (this.main.model.ui.server.isEndpointConnected("listUploadedFiles")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("listUploadedFiles", data, 2, callback, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_LISTING_UPLOADED_FILES(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.uploadFile = function (placement, directory, filename, contents, callback) {
  var _this11 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("uploadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    data["contents"] = contents;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("uploadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this11.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this12 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this12.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this12.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this13 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this13._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this13.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this13.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  mod.clear_existing_student_imports = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    Sk.clearExistingStudentImports();
  });
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/weakref.js":
/*!***************************************!*\
  !*** ./src/skulpt_modules/weakref.js ***!
  \***************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "weakref"
  };
  /*mod.WeakSet = Sk.abstr.buildNativeClass("weakref.WeakSet", {
      constructor: function WeakSet()
  });*/

  var WeakSet = function WeakSet($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, data) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("data", "iterable", Sk.builtin.checkIterable(data));
      self.data = [];
      var iter = Sk.abstr.iter(data);
      var next;

      do {
        next = Sk.abstr.iternext(iter);

        if (next !== undefined) {
          self.data.push(new WeakRef(next));
        }
      } while (next !== undefined);

      return Sk.builtin.none.none$;
    });
    $loc.__iter__ = new Sk.builtin.func(function (self) {
      var viewOfData = [];

      for (var i = 0; i < self.data.length; i++) {
        var item = self.data[i].deref();

        if (item !== undefined) {
          viewOfData.push(item);
        }
      }

      self.data = viewOfData;
      return Sk.abstr.iter(new Sk.builtin.list(viewOfData));
    });
    /*$loc.next$ = new Sk.builtin.func(function (self) {
        return self.tp$iter();
    });*/

    $loc.add = new Sk.builtin.func(function (self, item) {
      self.data.push(new WeakRef(item));
    });
  };

  mod.WeakSet = Sk.misceval.buildClass(mod, WeakSet, "WeakSet", []);
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    \n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <caption>Current variables at this step</caption>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = [];

      if (!this.main.model.display.traceExecution()) {
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Arguments: " + value.func_code.co_varnames.join(", ") : " No arguments"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/


function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9qc29uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL21hcmtkb3duLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3B5dGhvbi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9xdWl6LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy93ZWFrcmVmLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3RyYWNlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwia29cIiJdLCJuYW1lcyI6WyJFRElUT1JfVkVSU0lPTiIsIkJsb2NrUHkiLCJjb25maWd1cmF0aW9uIiwiYXNzaWdubWVudCIsInN1Ym1pc3Npb24iLCJpbml0TW9kZWwiLCJ1bmRlZmluZWQiLCJzZXRBc3NpZ25tZW50IiwiaW5pdE1haW4iLCJpbml0VXRpbGl0aWVzIiwiaW5pdE1vZGVsTWV0aG9kcyIsInR1cm5PbkhhY2tzIiwiaW5pdEludGVyZmFjZSIsImFwcGx5TW9kZWwiLCJpbml0Q29tcG9uZW50cyIsIm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMiLCJzdGFydCIsImtleSIsImRlZmF1bHRWYWx1ZSIsImluaXRpYWxDb25maWd1cmF0aW9uXyIsImxvY2FsU2V0dGluZ3NfIiwiaGFzIiwiZ2V0IiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsIm1vZGVsIiwidXNlciIsImlkIiwia28iLCJvYnNlcnZhYmxlIiwibmFtZSIsInJvbGUiLCJnZXRTZXR0aW5nIiwiY291cnNlSWQiLCJncm91cElkIiwiaW5zdHJ1Y3Rpb25zIiwidXJsIiwidHlwZSIsIkFzc2lnbWVudFR5cGUiLCJCTE9DS1BZIiwicG9pbnRzIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYVN0YXJ0aW5nRmlsZXMiLCJmb3JrZWRJZCIsImZvcmtlZFZlcnNpb24iLCJvd25lcklkIiwidmVyc2lvbiIsInRhZ3MiLCJzYW1wbGVTdWJtaXNzaW9ucyIsInJldmlld2VkIiwiaGlkZGVuIiwiaXBSYW5nZXMiLCJzZXR0aW5ncyIsIm1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbCIsImNvZGUiLCJleHRyYUZpbGVzIiwiZW5kcG9pbnQiLCJzY29yZSIsImNvcnJlY3QiLCJzdWJtaXNzaW9uU3RhdHVzIiwiZ3JhZGluZ1N0YXR1cyIsImRpc3BsYXkiLCJmaWxlbmFtZSIsImluc3RydWN0b3IiLCJtdXRlUHJpbnRlciIsInB5dGhvbk1vZGUiLCJEaXNwbGF5TW9kZXMiLCJTUExJVCIsImhpc3RvcnlNb2RlIiwiYXV0b1NhdmUiLCJiaWdDb25zb2xlIiwicHJldmlvdXNDb25zb2xlSGVpZ2h0IiwiY3VycmVudENvbnNvbGVIZWlnaHQiLCJzZWNvbmRSb3dTZWNvbmRQYW5lbCIsIlNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucyIsIkZFRURCQUNLIiwicHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbCIsInRyYWNlRXhlY3V0aW9uIiwibG9hZGluZ0RhdGFzZXRzIiwiY2hhbmdlZEluc3RydWN0aW9ucyIsInRyaWdnZXJPbkNoYW5nZSIsImRpcnR5U3VibWlzc2lvbiIsImZ1bGxzY3JlZW4iLCJwYXNzY29kZSIsImNsZWFySW5wdXRzIiwicmVuZGVySW1hZ2VzIiwiZWRpdG9yVmVyc2lvbiIsInJlYWRPbmx5IiwidG9TdHJpbmciLCJ1cGxvYWRlZEZpbGVzIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsImxpc3RVcGxvYWRlZEZpbGVzIiwibGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlIiwiZG93bmxvYWRGaWxlIiwiZG93bmxvYWRGaWxlTWVzc2FnZSIsInVwbG9hZEZpbGUiLCJ1cGxvYWRGaWxlTWVzc2FnZSIsIm9uRXhlY3V0aW9uIiwiZXhlY3V0aW9uIiwicmVwb3J0cyIsIm91dHB1dCIsImlucHV0IiwiaW5wdXRJbmRleCIsInN0dWRlbnQiLCJjdXJyZW50U3RlcCIsImxhc3RTdGVwIiwiY3VycmVudExpbmUiLCJsYXN0TGluZSIsImN1cnJlbnRUcmFjZURhdGEiLCJjdXJyZW50VHJhY2VTdGVwIiwicmVzdWx0cyIsImdsb2JhbHMiLCJjYWxscyIsInN5c21vZHVsZXMiLCJmZWVkYmFjayIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxhYmVsIiwibGluZXNFcnJvciIsImxpbmVzVW5jb3ZlcmVkIiwiY2FsbGJhY2tzIiwic2VydmVyQ29ubmVjdGVkIiwiYmxvY2tseVBhdGgiLCJhdHRhY2htZW50UG9pbnQiLCJjb250YWluZXIiLCJ1cmxzIiwiY29uc3RhbnRzIiwiZ3VpIiwibWFrZUludGVyZmFjZSIsIiQiLCJodG1sIiwiYXNzaWdubWVudF9pZCIsImNvbXBvbmVudHMiLCJzZXJ2ZXIiLCJzYW1wbGVzIiwic3RhcnRpbmdfY29kZSIsImV4dHJhX3N0YXJ0aW5nX2ZpbGVzIiwibG9hZE5vU3VibWlzc2lvbiIsImdyYWRpbmdfc3RhdHVzIiwic3VibWlzc2lvbl9zdGF0dXMiLCJ1c2VyX2lkIiwiY291cnNlX2lkIiwiZXh0cmFfZmlsZXMiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsInJlc2V0SW50ZXJmYWNlIiwiZmlsZVN5c3RlbSIsImRpc21vdW50RXh0cmFGaWxlcyIsIndhc1NlcnZlckNvbm5lY3RlZCIsImZvcmtlZF9pZCIsImZvcmtlZF92ZXJzaW9uIiwiaXBfcmFuZ2VzIiwib25fY2hhbmdlIiwibmV3RmlsZSIsIm9uX2V2YWwiLCJvbl9ydW4iLCJvd25lcl9pZCIsImxvYWRUYWdzIiwibG9hZFNhbXBsZVN1Ym1pc3Npb25zIiwic2FtcGxlX3N1Ym1pc3Npb25zIiwiZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcyIsImxvYWRBc3NpZ25tZW50U2V0dGluZ3MiLCJsb2FkU3VibWlzc2lvbiIsImNvcmdpcyIsImxvYWREYXRhc2V0cyIsInB5dGhvbkVkaXRvciIsImJtIiwicmVmcmVzaCIsInNldFN0YXR1cyIsInNlbGYiLCJ1aSIsImlzR3JhZGVyIiwicHVyZUNvbXB1dGVkIiwiaXNDaGFuZ2VkIiwiY3VycmVudCIsInV0aWxpdGllcyIsIm1hcmtkb3duIiwicmVzZXQiLCJtZW51IiwidGV4dEZ1bGxzY3JlZW4iLCJjbGlja0Z1bGxzY3JlZW4iLCJlZGl0SW5wdXRzIiwiZGlhbG9nIiwiRURJVF9JTlBVVFMiLCJ0b2dnbGVJbWFnZXMiLCJ0ZXh0RWRpdG9yIiwiZGlzYWJsZUltYWdlcyIsImVuYWJsZUltYWdlcyIsImNhbk1hcmtTdWJtaXR0ZWQiLCJjYW5DbG9zZSIsInRleHRNYXJrU3VibWl0dGVkIiwiaXNDb21wbGV0ZWQiLCJpc1N1Ym1pdHRlZCIsImNsaWNrTWFya1N1Ym1pdHRlZCIsImFsZXJ0IiwiZW5naW5lIiwiZGVsYXllZFJ1biIsInRvTG93ZXJDYXNlIiwic2hvd1F1ZXVlZElucHV0cyIsImhpZGVRdWV1ZWRJbnB1dHMiLCJzZWNvbmRSb3ciLCJpc0FsbFZpc2libGUiLCJoaWRlTWlkZGxlUGFuZWwiLCJpc0ZlZWRiYWNrVmlzaWJsZSIsImlzVHJhY2VWaXNpYmxlIiwiVFJBQ0UiLCJpc0NvbnNvbGVTaG93VmlzaWJsZSIsInN3aXRjaExhYmVsIiwiYWR2YW5jZVN0YXRlIiwiY3VycmVudFBhbmVsIiwiTk9ORSIsIm1ha2VXaWRlIiwicmVzdG9yZVBhbmVsIiwib2xkUGFuZWwiLCJzaXplIiwiaGlkZUV2YWx1YXRlIiwiQUNUSVZFIiwiYmFkZ2UiLCJ0cmFjZSIsImxpbmUiLCJzdGVwIiwidHJhY2VEYXRhIiwiZmlyc3QiLCJiYWNrd2FyZCIsInByZXZpb3VzIiwiTWF0aCIsIm1heCIsImZvcndhcmQiLCJuZXh0IiwibWluIiwibGFzdCIsImZpbGVzIiwidmlzaWJsZSIsImhpZGVGaWxlcyIsImhhc0NvbnRlbnRzIiwicGF0aCIsInNvbWUiLCJmaWxlIiwibGVuZ3RoIiwiYWRkIiwibm9ybWFsVG9vbGJveCIsImJsb2NrRWRpdG9yIiwiVE9PTEJPWEVTIiwiSlNPTiIsInN0cmluZ2lmeSIsIlNhbXBsZVN1Ym1pc3Npb24iLCJCbGFuayIsIm5ld0ZpbGVEaWFsb2ciLCJkZWxldGVGaWxlIiwicmVuYW1lIiwibmV3TmFtZSIsInJlbmFtZUZpbGUiLCJnZXRTdHVkZW50Q29kZSIsInByZWZpeFB5IiwiZ2V0RmlsZSIsInN1ZmZpeFB5IiwiaGFuZGxlIiwiZXh0cmFTdHVkZW50RmlsZXMiLCJvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZSIsImRpc3BsYXlGaWxlbmFtZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImVkaXRvcnMiLCJnZXRFZGl0b3IiLCJ2aWV3IiwiaGlkZUVkaXRvcnMiLCJtYXAiLCJzdWJzdHIiLCJtYWtlTW9kZWxGaWxlIiwiY29udGVudHMiLCJjYW5TYXZlIiwiY2FuRGVsZXRlIiwiVU5ERUxFVEFCTEVfRklMRVMiLCJpbmRleE9mIiwiY2FuUmVuYW1lIiwiVU5SRU5BTUFCTEVfRklMRVMiLCJ1cGxvYWQiLCJiaW5kIiwiZG93bmxvYWQiLCJpbXBvcnREYXRhc2V0Iiwib3BlbkRpYWxvZyIsInB5dGhvbiIsImNvZGVNaXJyb3IiLCJzZXRPcHRpb24iLCJnZXRPcHRpb24iLCJ1cGRhdGVNb2RlIiwibmV3TW9kZSIsIm9sZFB5dGhvbk1vZGUiLCJpc0hpc3RvcnlBdmFpbGFibGUiLCJpc0VuZHBvaW50Q29ubmVjdGVkIiwidHVybk9mZkhpc3RvcnlNb2RlIiwidXBkYXRlRWRpdG9yIiwic2V0UmVhZE9ubHkiLCJ0dXJuT25IaXN0b3J5TW9kZSIsInJlc3BvbnNlIiwic3VjY2VzcyIsImhpc3RvcnkiLCJsb2FkIiwiRVJST1JfTE9BRElOR19ISVNUT1JZIiwidG9nZ2xlSGlzdG9yeU1vZGUiLCJtb3ZlVG9TdGFydCIsIm1vdmVQcmV2aW91cyIsIm1vdmVOZXh0IiwibW9zdFJlY2VudCIsIm1vdmVUb01vc3RSZWNlbnQiLCJ1c2UiLCJpbWFnZXMiLCJyZWxvYWRJbWFnZXMiLCJieU5hbWUiLCJzYXZlIiwiYnVpbGRFZGl0b3IiLCJuZXdET00iLCJpbmRleCIsIm5ld0VsZW1lbnQiLCJlZGl0b3IiLCJleGVjdXRlIiwiaXNSdW5uaW5nIiwicnVuTGFiZWwiLCJydW4iLCJQeWdhbWVMaWIiLCJydW5uaW5nIiwiU3RvcFB5Z2FtZSIsImV2YWx1YXRlIiwibWVzc2FnZXMiLCJjYXBpdGFsaXplIiwiZm9yY2UiLCJldmVudCIsImFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b24iLCJ0YXJnZXQiLCJwYXJlbnQiLCJmYWRlT3V0IiwiZmFkZUluIiwiZnIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsImFzc2lnbm1lbnRTdWJtaXNzaW9uIiwicGFyc2UiLCJyZXN1bHQiLCJsb2FkQXNzaWdubWVudERhdGFfIiwiZmlsZU5hbWUiLCJyZWFkQXNUZXh0IiwidmFsIiwibWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyIsIlNrIiwiYnVpbHRpbkZpbGVzIiwiaW1hZ2VNb2R1bGUiLCJhcHBseUJpbmRpbmdzIiwibWFpbiIsInRleHQiLCJFYXN5TURFIiwicHJvdG90eXBlIiwiQmxvY2tQeURpYWxvZyIsImZpbmQiLCJCbG9ja1B5RmVlZGJhY2siLCJCbG9ja1B5VHJhY2UiLCJCbG9ja1B5Q29uc29sZSIsIkJsb2NrUHlFbmdpbmUiLCJCbG9ja1B5RmlsZVN5c3RlbSIsIkVkaXRvcnMiLCJCbG9ja1B5U2VydmVyIiwiQmxvY2tQeUNvcmdpcyIsIkJsb2NrUHlIaXN0b3J5Iiwic2hvdyIsImhpZGUiLCJzdWJzY3JpYmUiLCJjaGFuZ2VkIiwiYWx0TG9nRW50cnkiLCJ1c2VyU3VwcGxpZWRQYXNzY29kZSIsInByb21wdCIsIlNUQVJUX0VWQUxfSFRNTCIsIk5FV19DT05TT0xFX0xJTkVfSFRNTCIsIkNPTlNPTEVfSFRNTCIsIkNvbnNvbGVMaW5lVHlwZSIsIlRFWFQiLCJIVE1MIiwiUExPVCIsIklNQUdFIiwiUFlHQU1FIiwiVFVSVExFIiwiRVZBTCIsIlNUQVJUX0VWQUwiLCJWQUxVRSIsIklOUFVUIiwiVEVTVF9DQVNFIiwiQ29uc29sZUxpbmUiLCJjb250ZW50Iiwib3JpZ2luIiwiY3VyckZpbGVuYW1lIiwiZXhlY3V0aW9uQnVmZmVyIiwiZmZpIiwicmVtYXBUb1B5IiwicmVtb3ZlIiwiQ29uc29sZUxpbmVUdXJ0bGUiLCJhZGRDbGFzcyIsIndoZXJlIiwicHJlcGVuZCIsInRvcCIsInBvc2l0aW9uIiwic2Nyb2xsVG9wIiwiQ29uc29sZUxpbmVQeWdhbWUiLCJweWdhbWVPYmoiLCJpbml0aWFsaXplZCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsImNsZWFudXAiLCJjbGVhbnVwRnVuY3Rpb24iLCJsaXN0ZW5lcnMiLCJDb25zb2xlTGluZUltYWdlIiwiQ29uc29sZUxpbmVQbG90IiwiQ29uc29sZUxpbmVUZXh0IiwiZW5jb2RlZFRleHQiLCJlbmNvZGVIVE1MIiwidHJpbSIsImxpbmVEYXRhIiwidG9vbHRpcCIsIkNvbnNvbGVMaW5lVmFsdWUiLCJDb25zb2xlTGluZUlucHV0IiwicHJvbXB0TWVzc2FnZSIsImlucHV0Rm9ybSIsImlucHV0QnRuIiwiaW5wdXRHcm91cCIsImlucHV0Qm94IiwiaW5wdXRNc2ciLCJtYWtlSW50ZXJhY3RpdmUiLCJidXR0b24iLCJyZXNvbHZlT25DbGljayIsInN1Ym1pdHRlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN1Ym1pdEZvcm0iLCJ1c2VySW5wdXR0ZWRWYWx1ZSIsInF1ZXVlZElucHV0IiwicHVzaCIsInByb3AiLCJjbGljayIsImtleXVwIiwia2V5Q29kZSIsImZvY3VzIiwiQ29uc29sZUxpbmVFdmFsdWF0ZSIsIkNvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSIsInRhZyIsInByaW50ZXJUYWciLCJNSU5JTVVNX1dJRFRIIiwiTUlOSU1VTV9IRUlHSFQiLCJERUZBVUxUX0hFSUdIVCIsImhlaWdodCIsImNsZWFyIiwicmVtb3ZlQWxsIiwibGluZUJ1ZmZlciIsInBsb3RCdWZmZXIiLCJlbXB0eSIsInR1cnRsZUxpbmUiLCJUdXJ0bGVHcmFwaGljcyIsImdldFR1cnRsZUxpbmUiLCJ3aWR0aCIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiYXNzZXRzIiwibG9hZEFzc2V0IiwicHlnYW1lTGluZSIsInJlbmRlciIsImN1cnJlbnRQcmludGVyRGltZW5zaW9uIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJzYXZlVHVydGxlT3V0cHV0IiwiZGF0YVVybCIsInRvRGF0YVVSTCIsInBhZ2UiLCJlYWNoIiwiYXR0ciIsImxpbmVUZXh0IiwiZmx1c2giLCJjaGFyQXQiLCJzcGxpdExpbmVzIiwic3BsaXQiLCJhZGRDb250ZW50IiwiaSIsInBsb3RzIiwiaW1hZ2VEYXRhIiwiaW1hZ2UiLCJpbWFnZUJ1ZmZlciIsInZhbHVlIiwicHJpbnRlZFZhbHVlIiwiaW5wdXRCdWZmZXIiLCJzdGFydEV2YWx1YXRpb24iLCJhbmltYXRlIiwiX0lNUE9SVEVEX0RBVEFTRVRTIiwiX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTIiwic2V0QnV0dG9uTG9hZGVkIiwiYnRuIiwicmVtb3ZlQ2xhc3MiLCJsb2FkZWREYXRhc2V0cyIsInNpbGVudGx5IiwiaW1wb3J0cyIsImRhdGFzZXRzIiwiZm9yRWFjaCIsIkJsb2NrTWlycm9yQmxvY2tFZGl0b3IiLCJFWFRSQV9UT09MUyIsImFwcGx5Iiwic2x1ZyIsIndoZW4iLCJkb25lIiwiZm9yY2VCbG9ja1JlZnJlc2giLCJyZW1ha2VUb29sYm94IiwiZmFpbCIsImFyZ3VtZW50cyIsImVycm9yIiwiYWx3YXlzIiwiZmluYWxpemVTdWJzY3JpcHRpb25zIiwidXJsX3JldHJpZXZhbHMiLCJyb290IiwiaW1wb3J0RGF0YXNldHMiLCJnZXREYXRhc2V0IiwiZ2V0U2NyaXB0IiwiZ2V0Q29tcGxldGUiLCJnZXRTa3VscHQiLCJnZXRCbG9ja2x5IiwidGV4dFRvQmxvY2tzIiwiaGlkZGVuSW1wb3J0cyIsImdldEpTT04iLCJibG9ja3B5IiwiZG9jdW1lbnRhdGlvbiIsImJvZHkiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsInNsdWdnZWROYW1lIiwidGl0bGVOYW1lIiwiaW1nU3JjIiwidGl0bGUiLCJvdmVydmlldyIsImFwcGVuZFRvIiwiRElBTE9HX0hUTUwiLCJ0aXRsZVRhZyIsImJvZHlUYWciLCJmb290ZXJUYWciLCJva2F5QnV0dG9uIiwiY2xvc2VCdXR0b24iLCJ5ZXMiLCJubyIsIm1vZGFsIiwiY2xvc2UiLCJvbmNsb3NlIiwiZHJhZ2dhYmxlIiwib24iLCJjb25maXJtIiwieWVzVGV4dCIsIkFTU0lHTk1FTlRfVkVSU0lPTl9DSEFOR0VEIiwiRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCIsInJlYXNvbiIsIkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMiLCJFUlJPUl9VUExPQURJTkdfRklMRSIsIkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCIsIkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUiIsIlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwiLCJTQ1JFRU5TSE9UX0JMT0NLUyIsIkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTIiwiT0ZGRVJfRk9SSyIsInNldHVwVXJsIiwiaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwIiwiaW5wdXRUZXh0Iiwiam9pbiIsImNoZWNrZWQiLCJpbnB1dHMiLCJmaWxlUmVhZGVyIiwic2x1Z2dpZnkiLCJyZXBsYWNlIiwiZXh0ZW5zaW9uIiwibWltZXR5cGUiLCJibG9iIiwiQmxvYiIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm1zU2F2ZU9yT3BlbkJsb2IiLCJtc1NhdmVCbG9iIiwidGVtcG9yYXJ5RG93bmxvYWRMaW5rIiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJBYnN0cmFjdEVkaXRvciIsImNoYW5nZUVkaXRvciIsIndhdGNoRmlsZSIsInVwZGF0ZWQiLCJvbkZpbGVVcGRhdGVkIiwiZGVsZXRlZCIsIm9uRmlsZURlbGV0ZWQiLCJuZXdGaWxlbmFtZSIsIm9sZEVkaXRvciIsInRyYWNrQ3VycmVudEZpbGUiLCJuZXdFZGl0b3IiLCJzdG9wV2F0Y2hpbmdGaWxlIiwicGFyc2VGaWxlbmFtZSIsIkFTU0lHTk1FTlRfU0VUVElOR1MiLCJNQVpFIiwiUVVJWiIsIlJFQURJTkciLCJnZXREb2N1bWVudGF0aW9uIiwibWFrZVN0YXJ0Vmlld1RhYiIsImljb24iLCJtb2RlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19CT09MRUFOX0NPTVBPTkVOVFNfSFRNTCIsImZpbHRlciIsInNldHRpbmciLCJwcmV0dHlOYW1lIiwid29yZCIsInRvVXBwZXJDYXNlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCIsIkJMT0NLIiwic2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyIsImNsaWVudE5hbWUiLCJzZXJ2ZXJOYW1lIiwic3RhcnRfdmlldyIsImZpZWxkVHlwZSIsImNvbmZpZ1ZhbHVlIiwiQXNzaWdubWVudFNldHRpbmdzVmlldyIsImRpcnR5IiwiY3VycmVudExpc3RlbmVyIiwidXBkYXRlSGFuZGxlIiwibmV3Q29udGVudHMiLCJBc3NpZ25tZW50U2V0dGluZ3MiLCJleHRlbnNpb25zIiwiY29uc3RydWN0b3IiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRfaGVhZGVyIiwiSU1BR0VfRURJVE9SX0hUTUwiLCJJbWFnZUVkaXRvclZpZXciLCJjdXJyZW50U3Vic2NyaXB0aW9uIiwiZGlhbG9ncyIsImRpc3Bvc2UiLCJJbWFnZUVkaXRvciIsIkpTT05fRURJVE9SX0hUTUwiLCJKc29uRWRpdG9yVmlldyIsIkNvZGVNaXJyb3IiLCJmcm9tVGV4dEFyZWEiLCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZyIsImxpbmVOdW1iZXJzIiwiZmlyc3RMaW5lTnVtYmVyIiwiaW5kZW50VW5pdCIsInRhYlNpemUiLCJpbmRlbnRXaXRoVGFicyIsImV4dHJhS2V5cyIsImNtIiwiYmx1ciIsInNldFRpbWVvdXQiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwib2ZmIiwiSnNvbkVkaXRvciIsIk1BUktET1dOX0VESVRPUl9IVE1MIiwiTWFya2Rvd25FZGl0b3JWaWV3IiwibWRlIiwiZWxlbWVudCIsImF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lIiwiZm9yY2VTeW5jIiwibWluSGVpZ2h0IiwicmVuZGVyaW5nQ29uZmlnIiwiY29kZVN5bnRheEhpZ2hsaWdodGluZyIsImNvZGVtaXJyb3IiLCJNYXJrZG93bkVkaXRvciIsIm1ha2VUYWIiLCJQWVRIT05fRURJVE9SX0hUTUwiLCJISVNUT1JZX1RPT0xCQVJfSFRNTCIsImNvbnZlcnRJcHluYlRvUHl0aG9uIiwiaXB5bmIiLCJpc1VzYWJsZSIsImNlbGwiLCJjZWxsX3R5cGUiLCJzb3VyY2UiLCJtYWtlUHl0aG9uIiwiY2VsbHMiLCJQeXRob25FZGl0b3JWaWV3IiwiQmxvY2tseSIsInNldFBhcmVudENvbnRhaW5lciIsIkJsb2NrTWlycm9yIiwidG9vbGJveCIsImltYWdlRG93bmxvYWRIb29rIiwib2xkVXJsIiwiaW1hZ2VVcGxvYWRIb29rIiwicmVqZWN0Iiwic3VibWlzc2lvbklkIiwiaW1hZ2VMaXRlcmFsSG9vayIsIm1ha2VTdWJzY3JpcHRpb25zIiwibGluZUVycm9yU3Vic2NyaXB0aW9uIiwibGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiIsIm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucyIsIndvcmtzcGFjZSIsImNvbmZpZ3VyZUNvbnRleHRNZW51Iiwib3B0aW9ucyIsImVuYWJsZWQiLCJjYWxsYmFjayIsIm9sZEZpbGVuYW1lIiwiY3VycmVudEJNTGlzdGVuZXIiLCJhZGRDaGFuZ2VMaXN0ZW5lciIsImlzUGFyc29ucyIsImxpbmVzIiwic2V0SGlnaGxpZ2h0ZWRMaW5lcyIsImRlbGV0ZUZpbGVMb2NhbGx5XyIsInNldENvZGUiLCJjbGVhckhpZ2hsaWdodGVkTGluZXMiLCJnZXRDb2RlIiwicmVtb3ZlQ2hhbmdlTGlzdGVuZXIiLCJjbGVhckxpbmVTdWJzY3JpcHRpb25zIiwic2V0TW9kZSIsImVuYWJsZUJsb2NrcyIsInJlbG9hZFRvb2xib3giLCJpbWFnZU1vZGUiLCJzZXRJbWFnZU1vZGUiLCJjdXN0b21Ub29sYm94IiwiZGVjaWRlSWZOb3RFZGl0YWJsZSIsIm9ubHlVcGxvYWRzIiwiaXNSZWFkT25seSIsImVuZHNXaXRoIiwiUHl0aG9uRWRpdG9yIiwiUVVJWl9FRElUT1JfSFRNTCIsIlF1aXpFZGl0b3JWaWV3IiwiUXVpekVkaXRvciIsIlN1Ym1pc3Npb25TdGF0dXNlcyIsIlVOS05PV04iLCJQQVNTRUQiLCJGQUlMRUQiLCJFUlJPUiIsIlNLSVBQRUQiLCJjb3VudCIsIlNBTVBMRV9TVUJNSVNTSU9OU19IVE1MIiwiYmluZGluZ0hhbmRsZXJzIiwiY29kZU1pcnJvckluc3RhbmNlIiwiaW5pdCIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0Iiwic2V0U2l6ZSIsInVwZGF0ZSIsIlNhbXBsZVN1Ym1pc3Npb25zVmlldyIsImNvZGVNaXJyb3JzIiwiU2FtcGxlU3VibWlzc2lvbnMiLCJUQUdTX0VESVRPUl9IVE1MIiwiVGFnc0VkaXRvclZpZXciLCJUYWdzRWRpdG9yIiwiVEVYVF9FRElUT1JfSFRNTCIsIlRleHRFZGl0b3JWaWV3IiwiVGV4dEVkaXRvciIsIlRPT0xCT1hfRURJVE9SX0hUTUwiLCJUb29sYm94RWRpdG9yVmlldyIsIlRvb2xib3hFZGl0b3IiLCJFZGl0b3JzRW51bSIsIlNVQk1JU1NJT04iLCJBU1NJR05NRU5UIiwiSU5TVFJVQ1RJT05TIiwiT05fUlVOIiwiT05fQ0hBTkdFIiwiT05fRVZBTCIsIlNUQVJUSU5HX0NPREUiLCJTQU1QTEVfU1VCTUlTU0lPTlMiLCJJTlNUUlVDVE9SX0ZJTEUiLCJTUEVDSUFMX05BTUVTUEFDRVMiLCJBVkFJTEFCTEVfRURJVE9SUyIsIkVESVRPUlNfSFRNTCIsInJlZ2lzdGVyZWRfIiwiZXh0ZW5zaW9uc18iLCJieU5hbWVfIiwicmVnaXN0ZXJFZGl0b3IiLCJpbnN0YW5jZSIsImV4aXQiLCJlbnRlciIsInNwYWNlIiwiYXNzaWdubWVudFR5cGUiLCJBc3NpZ25tZW50VHlwZSIsImxhc3RJbmRleE9mIiwiZXhlY3V0aW9uTW9kZWwiLCJjb25maWd1cmF0aW9ucyIsIlJ1bkNvbmZpZ3VyYXRpb24iLCJldmFsIiwiRXZhbENvbmZpZ3VyYXRpb24iLCJPblJ1bkNvbmZpZ3VyYXRpb24iLCJPbkNoYW5nZUNvbmZpZ3VyYXRpb24iLCJPbkV2YWxDb25maWd1cmF0aW9uIiwiY29uZmlndXJlIiwiZ2V0U2t1bHB0T3B0aW9ucyIsIm9uRXhlY3V0aW9uQmVnaW4iLCJvbkV4ZWN1dGlvbkVuZCIsInJlcG9ydCIsInRyYWNpbmciLCJyZXNldFN0dWRlbnRNb2RlbCIsInJlc2V0UmVwb3J0cyIsInJlc2V0RXhlY3V0aW9uQnVmZmVyIiwidGhlbiIsImZhaWx1cmUiLCJkaXNhYmxlRmVlZGJhY2siLCJwcm92aWRlU2VjcmV0RXJyb3IiLCJzaG93RXJyb3JzIiwiZXhlY3V0aW9uRW5kXyIsImV2YWx1YXRpb25JbnB1dCIsInVzZXJJbnB1dCIsIm1pc2NldmFsIiwiYXN5bmNUb1Byb21pc2UiLCJpbXBvcnRNYWluV2l0aEJvZHkiLCJGSUxFTkFNRSIsInByb2dyYW1zIiwic2F2ZUNvZGUiLCJ2ZXJpZnlDb2RlIiwidXBkYXRlUGFyc2UiLCJydW5JbnN0cnVjdG9yQ29kZSIsIm1vZHVsZSIsImV4ZWN1dGlvblJlcG9ydHMiLCJwcmVzZW50RmVlZGJhY2siLCIkZCIsIkVNUFRZX01PRFVMRSIsIkNvbmZpZ3VyYXRpb24iLCJpbkJyb3dzZXIiLCJvcGVuRmlsZSIsInJlcXVlc3RzR2V0IiwidGltZW91dCIsIm9wZW5VUkwiLCJ0aW1lb3V0SGFuZGxlciIsInRpbWVQYXNzZWQiLCJleGVjTGltaXQiLCJkaXNhYmxlVGltZW91dCIsImdldFRpbWVvdXRQcm9tcHQiLCJkZWxheSIsInBhcnNlSW50IiwiZXhlY0xpbWl0RnVuY3Rpb24iLCJJbmZpbml0eSIsImJlZm9yZUNhbGwiLCJsb25nVGltZW91dCIsIl9fZnV0dXJlX18iLCJweXRob24zIiwicmVhZCIsImltcG9ydEZpbGUiLCJmaWxld3JpdGUiLCJ3cml0ZUZpbGUiLCJwcmludCIsImlucHV0ZnVuIiwiaW5wdXRmdW5UYWtlc1Byb21wdCIsImltYWdlUHJveHkiLCJnZXRJbWFnZVByb3h5IiwiZW1vamlQcm94eSIsInBhcnQiLCJyZXRhaW5HbG9iYWxzIiwid2FybiIsIm1vY2tVcmxEYXRhIiwiYnVpbHRpbiIsIklPRXJyb3IiLCJoYXNPd25Qcm9wZXJ0eSIsImZpbGVEYXRhIiwicmVhZEZpbGUiLCJFcnJvciIsInN0b3AiLCJmdW5jdGlvbk5hbWUiLCJwb3NhcmdzIiwia3dhcmdzIiwic3R1ZGVudE1vZGVsIiwiYXJncyIsInBvcCIsImFmdGVyU2luZ2xlRXhlY3V0aW9uIiwicHJpbnRWYWx1ZSIsInJlbWFwVG9KcyIsIl8iLCIkciIsIngiLCJpc0RvY3N0cmluZyIsIlN0dWRlbnRDb25maWd1cmF0aW9uIiwiVVRJTElUWV9NT0RVTEVfQ09ERSIsIiRza19tb2RfaW5zdHJ1Y3RvciIsIkNPVkVSQUdFX01PRFVMRV9DT0RFIiwiJHNrX21vZF9jb3ZlcmFnZSIsIkluc3RydWN0b3JDb25maWd1cmF0aW9uIiwiYmVmb3JlQ2FsbEJhY2t1cCIsIiRwZWRhbF90cmFjZXIiLCJjbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMiLCJnZXRBbGxGaWxlbmFtZXMiLCJza0ZpbGVuYW1lIiwic3RyIiwicXVpY2skbG9va3VwIiwiZGVsJGl0ZW0iLCJpbmNsdWRlcyIsImNob21wU3BlY2lhbEZpbGUiLCJjbGVhbiIsImZvdW5kIiwic2VhcmNoRm9yRmlsZSIsIk9TRXJyb3IiLCJuZXh0SW5wdXQiLCJjbGVhclRpbWVvdXQiLCJXUkFQX0lOU1RSVUNUT1JfQ09ERSIsInN0dWRlbnRDb2RlIiwiaW5zdHJ1Y3RvckNvZGUiLCJxdWljayIsImlzU2FmZSIsInNhZmVDb2RlIiwiSU5TVFJVQ1RPUl9NQVJLRVIiLCJkaXNhYmxlVGlmYSIsInN0dWRlbnRGaWxlcyIsImdldEFsbFN0dWRlbnRGaWxlcyIsImV2YWx1YXRpb24iLCJkdW1teU91dFNhbmRib3giLCJsaW5lT2Zmc2V0IiwiZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQiLCJTVUNDRVNTIiwiU0NPUkUiLCJvbGRTY29yZSIsIkhJREUiLCJzY3JvbGxpbmciLCJzY3JvbGxUb0JvdHRvbSIsInRwJG5hbWUiLCJwcmVzZW50SW50ZXJuYWxFcnJvciIsImJlZm9yZSIsIm1hdGNoIiwiTkVXX0xJTkVfUkVHRVgiLCJza2lwX3RpZmEiLCJPblNhbXBsZUNvbmZpZ3VyYXRpb24iLCJkaXNhYmxlU3R1ZGVudFJ1biIsIkJvb2xlYW4iLCJjbGVhcklucHV0IiwiZmluaXNoVHVydGxlcyIsImJlZ2luRXZhbCIsInBhcnNlciIsInZlcmlmaWVyIiwiU2FtcGxlQ29uZmlndXJhdGlvbiIsImlzRm9yYmlkZGVuIiwibG9jYWxzIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsInBhcnNlR2xvYmFscyIsInByb3BlcnRpZXMiLCJtb2R1bGVzIiwiYXN0IiwidmlzaXRlZExpbmVzIiwiU2V0IiwidmlzaXRCb2R5Iiwibm9kZSIsImxpbmVubyIsInN0YXRlbWVudCIsIm9yZWxzZSIsImZpbmFsYm9keSIsIkFycmF5IiwiZnJvbSIsImFzdEZyb21QYXJzZSIsImNzdCIsImZsYWdzIiwiZ2V0TGluZXMiLCJwcmVzZW50UnVuRXJyb3IiLCJlcnJvckJ1dHRvbiIsIkZFRURCQUNLX0hUTUwiLCJmZWVkYmFja01vZGVsIiwicG9zaXRpdmUiLCJvZmZzZXQiLCJ2aXNpYmlsaXR5QnVmZmVyIiwidG9wT2ZFbGVtZW50IiwiYm90dG9tT2ZFbGVtZW50IiwiYm90dG9tT2ZTY3JlZW4iLCJ0b3BPZlNjcmVlbiIsImNsZWFyUG9zaXRpdmVGZWVkYmFjayIsImV4ZWN1dGlvblJlc3VsdHMiLCJNRVNTQUdFIiwiQ0FURUdPUlkiLCJMQUJFTCIsIkRBVEEiLCJwb3NpdGl2ZXMiLCJQT1NJVElWRSIsImhpZGVTY29yZSIsImJsb2NrIiwiaGxqcyIsImhpZ2hsaWdodEJsb2NrIiwiZmluZEZpcnN0RXJyb3JMaW5lIiwic3R1ZGVudFJlcG9ydCIsInVuY292ZXJlZExpbmVzIiwicG9zaXRpdmVEYXRhIiwiYWRkUG9zaXRpdmVGZWVkYmFjayIsImNvbG9yIiwib25jbGljayIsInRvRW5kIiwiY3NzIiwiaG92ZXIiLCJ1cGRhdGVGZWVkYmFjayIsIm5vdGlmeUZlZWRiYWNrVXBkYXRlIiwic2Nyb2xsSW50b1ZpZXciLCJqdXN0X3JldHVybiIsImNvbnZlcnRTa3VscHRFcnJvciIsImZpbGVuYW1lRXhlY3V0ZWQiLCJ0cmFjZWJhY2siLCJmcmFtZSIsInNjb3BlIiwiaXNJbnN0cnVjdG9yIiwiZXJyIiwiYWxsRnJhbWVzIiwiYnVpbGRUcmFjZWJhY2siLCJmZWVkYmFja0RhdGEiLCJsb2NhdGlvbiIsInRwJGdldGF0dHIiLCJmcmllbmRseU5hbWUiLCJoaWRlSWZFbXB0eSIsIm5vdEluc3RydWN0b3IiLCJpbnN0cnVjdG9yRmlsZUNsYXNzIiwiaGlkZUlmTm90SW5zdHJ1Y3RvciIsIkZJTEVTX0hUTUwiLCJORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MIiwiU1RBUlRJTkdfRklMRVMiLCJCQVNJQ19ORVdfRklMRVMiLCJJTlNUUlVDVE9SX0RJUkVDVE9SWSIsIlNUVURFTlRfRElSRUNUT1JZIiwiU2VhcmNoTW9kZXMiLCJFVkVSWVdIRVJFIiwiU1RBUlRfV0lUSF9JTlNUUlVDVE9SIiwiT05MWV9TVFVERU5UX0ZJTEVTIiwiREVMRVRBQkxFX1NJTVBMRV9GSUxFUyIsIkJsb2NrUHlGaWxlIiwib3duZXIiLCJtYWtlTW9ja01vZGVsRmlsZSIsImNvbmNhdGVuYXRlZEZpbGUiLCJtb2RlbEZpbGVMaXN0IiwibW9kZWxGaWxlcyIsImNyZWF0ZUNvbmNhdGVuYXRlZEZpbGUiLCJmaWxlc18iLCJtb3VudEZpbGVzIiwid2F0Y2hNb2RlbCIsIndhdGNoZXNfIiwidmlzaWJsaXR5IiwidG9nZ2xlIiwiZmlsZXN5c3RlbSIsImZpbGVBcnJheSIsImNoYW5nZXMiLCJzZWNvbmQiLCJsb2NhbGVDb21wYXJlIiwiY2hhbmdlIiwibW9kZWxGaWxlIiwibm90aWZ5V2F0Y2hlcyIsIm9ic2VydmVJbkFycmF5XyIsImFycmF5IiwiY29kZUJ1bmRsZSIsImV4aXN0aW5nRmlsZSIsIm9ic2VydmVGaWxlXyIsImRlc3RpbmF0aW9uIiwic3R1ZGVudFNlYXJjaCIsInNlYXJjaE1vZGUiLCJzcGVjaWFsRmlsZSIsInNlYXJjaEZvclNwZWNpYWxGaWxlc18iLCJzdHVkZW50VmVyc2lvbiIsInNlYXJjaEZvckZpbGVJbkxpc3RfIiwiZ2VuZXJhdGVkVmVyc2lvbiIsImRlZmF1bHRWZXJzaW9uIiwiaGlkZGVuVmVyc2lvbiIsImZpcnN0RGVmaW5lZFZhbHVlIiwiaW5zdHJ1Y3RvclZlcnNpb24iLCJzdGFydGluZ1ZlcnNpb24iLCJtb2RlbExpc3QiLCJraW5kIiwiZmlsZXR5cGUiLCJuYW1lc3BhY2UiLCJleHRlbnNpb25SZWdleCIsImV4ZWMiLCJwcmVmaXgiLCJzdWJtaXQiLCJwcmV2ZW50RGVmYXVsdCIsIkZPT1RFUl9IVE1MIiwiY3VycmVudElkIiwiZWRpdEV2ZW50cyIsInNlbGVjdG9yIiwiZWRpdElkIiwiZW50cnkiLCJmaWxlX3BhdGgiLCJldmVudF90eXBlIiwiUkVNQVBfRVZFTlRfVFlQRVMiLCJkaXNwbGF5ZWQiLCJwcmV0dHlQcmludERhdGVUaW1lIiwiY2xpZW50X3RpbWVzdGFtcCIsImRpc2FibGUiLCJvcHRpb24iLCJkaXNhYmxlZCIsImlzRWRpdEV2ZW50IiwiZXZ0IiwibW9udGhOYW1lcyIsIndlZWtEYXlzIiwiaXNTYW1lRGF5IiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwiZ2V0RnVsbFllYXIiLCJ0aW1lU3RyaW5nIiwibm93IiwiRGF0ZSIsInBhc3QiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJkYXlTdHIiLCJnZXREYXkiLCJtb250aFN0ciIsImRhdGUiLCJnZXRIaXN0b3J5IiwicmV2ZXJzZSIsInJlZHVjZSIsImNvbXBsZXRlIiwiZWxlbSIsImNvbXBsZXRlX3N0ciIsInRpbWUiLCJuZXdfbGluZSIsImhpZ2hsaWdodFRpbWVvdXQiLCJpc0Z1bGxzY3JlZW4iLCJyZXF1ZXN0RnVsbHNjcmVlbiIsImV4aXRGdWxsc2NyZWVuIiwiVFJBQ0VfSFRNTCIsIlJFVFJZSU5HIiwiT0ZGTElORSIsInN0b3JhZ2UiLCJxdWV1ZSIsImdldERlZmF1bHQiLCJNQVhfUVVFVUVfU0laRSIsIlRJTUVSX0RFTEFZIiwiRkFJTF9ERUxBWSIsInRpbWVycyIsIm92ZXJsYXkiLCJibG9ja2luZ0F0dGVtcHRzIiwiY2FjaGVkRmlsZW5hbWVzIiwiY3JlYXRlU3Vic2NyaXB0aW9ucyIsImNoZWNrQ2FjaGVzIiwiY2hlY2tJUCIsIm9sZElQIiwiaXAiLCJzZXQiLCJfcG9zdExhdGVzdFJldHJ5IiwicHVzaEFueVF1ZXVlZCIsIl9wb3N0UmV0cnkiLCJjcmVhdGVGaWxlU3Vic2NyaXB0aW9uIiwiY3JlYXRlRXZlbnRMb2dzIiwib25ibHVyIiwib25mb2N1cyIsImNyZWF0ZVNlcnZlckRhdGEiLCJtaWNyb3NlY29uZHMiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzaG93T3ZlcmxheSIsImF0dGVtcHQiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaGlkZU92ZXJsYXkiLCJfZW5xdWV1ZURhdGEiLCJjYWNoZSIsIl9kZXF1ZXVlRGF0YSIsInNwbGljZSIsInBvc3RSZXF1ZXN0IiwicG9zdCIsInRleHRTdGF0dXMiLCJmYWlsdXJlRnVuY3Rpb24iLCJkb25lRnVuY3Rpb24iLCJyZXF1ZXN0IiwiY2FjaGVkVGltZSIsIl9wb3N0QmxvY2tpbmciLCJhdHRlbXB0cyIsImV4dHJhU2V0dGluZ3MiLCJhamF4IiwiZXJyb3JUaHJvd24iLCJzdGFydFBvc3NpYmxlRm9yayIsInBsYWNlbWVudCIsImRpcmVjdG9yeSIsImZkIiwiZW50cmllcyIsImQiLCJGb3JtRGF0YSIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJuZXdTdGF0dXMiLCJwb3N0U3RhdHVzQ2hhbmdlIiwiZXJyb3JDYWxsYmFjayIsImxvYWRfZmlsZSIsImZvcmthYmxlIiwiaGlkZGVuT3ZlcnJpZGUiLCJmb3JjZVVwZGF0ZSIsImdldFBuZ0Zyb21CbG9ja3MiLCJwbmdEYXRhIiwiaW1nIiwiJGJ1aWx0aW5tb2R1bGUiLCJtb2QiLCJzYW1wbGVXcmFwcGVyIiwiX19uYW1lX18iLCJQSUwiLCJJbnN0YW50UHJvbWlzZSIsImxhc3RSZXN1bHQiLCJsYXN0RXJyb3IiLCJjYiIsImJ1aWxkSW1hZ2UiLCJnZXRBc3NldCIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmVycm9yIiwic3JjIiwiJGdibCIsIiRsb2MiLCJfX2luaXRfXyIsImZ1bmMiLCJmaWxlX29yX3VybCIsInB5Q2hlY2tBcmdzIiwicHlDaGVja1R5cGUiLCJjaGVja1N0cmluZyIsImltYWdlUHJvbWlzZSIsInN1c3AiLCJTdXNwZW5zaW9uIiwibm9uZSIsIm5vbmUkIiwicmVzdW1lIiwicHJvbWlzZSIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJwaXhlbHMiLCJnZXRJbWFnZURhdGEiLCJOYW1lRXJyb3IiLCJjb25zb2xlRGF0YSIsInByaW50UElMSW1hZ2UiLCJmbGlwIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJidWlsZENsYXNzIiwicHJpb3IiLCJ0aW1laXQiLCJkaWZmZXJlbmNlIiwiY29uc29sZV9sb2ciLCJjb25zb2xlX2RlYnVnIiwiZ2V0X291dHB1dCIsIml0ZW0iLCJ0b1NrdWxwdCIsImxpc3QiLCJyZXNldF9vdXRwdXQiLCJnZXRfcHJvZ3JhbSIsImdldF9ldmFsdWF0aW9uIiwidHJhY2VfbGluZXMiLCJyZWFsTGluZXMiLCJ0cmFjZV9jYWxscyIsImRpY3QiLCJzdGFydF90cmFjZSIsInN0b3BfdHJhY2UiLCJnZXRfc3R1ZGVudF9lcnJvciIsInR1cGxlIiwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yIiwiYmFja3VwVGltZSIsImxpbWl0X2V4ZWN1dGlvbl90aW1lIiwiZXhlY1N0YXJ0IiwidW5saW1pdF9leGVjdXRpb25fdGltZSIsInN1cHByZXNzX3Njcm9sbGluZyIsImdldF9wbG90cyIsIm91dHB1dHMiLCJncmFwaCIsInBsb3QiLCJuZXdQbG90IiwidiIsInkiLCJTdHVkZW50RGF0YSIsIm5ld0RpY3QiLCJhYnN0ciIsInNhdHRyIiwib2JqZWN0U2V0SXRlbSIsInVuZml4UmVzZXJ2ZWQiLCJjYWxsX2YiLCJrd2EiLCJweUNoZWNrQXJnc0xlbiIsImNhbGwiLCJidWlsdGlucyIsIm1wJGxvb2t1cCIsImZ1bmN0aW9uT2JqZWN0IiwidHAkY2FsbCIsImNvX2t3YXJncyIsImNvX25hbWUiLCJnZXRfbmFtZXNfYnlfdHlwZSIsImV4Y2x1ZGVfYnVpbHRpbnMiLCJjaGVja0Jvb2wiLCJwcm9wZXJ0eSIsImdldF92YWx1ZXNfYnlfdHlwZSIsImNhbGxzaW1PclN1c3BlbmQiLCJnZXRfc3R1ZGVudF9kYXRhIiwic2V0X2luc3RydWN0aW9ucyIsIm5ld0luc3RydWN0aW9ucyIsImdldF9tb2RlbF9pbmZvIiwiY2xlYXJfZXhpc3Rpbmdfc3R1ZGVudF9pbXBvcnRzIiwiV2Vha1NldCIsImNoZWNrSXRlcmFibGUiLCJpdGVyIiwiaXRlcm5leHQiLCJXZWFrUmVmIiwiX19pdGVyX18iLCJ2aWV3T2ZEYXRhIiwiZGVyZWYiLCJMT0NBTF9TVE9SQUdFX1JFRiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiX2RhdGEiLCJTdHJpbmciLCJnZXRJdGVtIiwiaXNfbmV3Iiwic2VydmVyX3RpbWUiLCJzdG9yZWRfdGltZSIsIklHTk9SRURfR0xPQkFMUyIsInZhcmlhYmxlcyIsInBhcnNlZCIsInBhcnNlVmFsdWUiLCJmdWxsTGVuZ3RoIiwiZnVuY19jb2RlIiwiY29fdmFybmFtZXMiLCJzcSRsZW5ndGgiLCJib29sIiwibm1iZXIiLCJza1R5cGUiLCJpbnRfIiwiZmxvYXRfIiwiTnVtYmVyIiwiYXJyYXlDb250YWlucyIsIm5lZWRsZSIsImhheXN0YWNrIiwiYXJyYXlVbmlxdWUiLCJhIiwiY29uY2F0IiwiaiIsImV4cGFuZEFycmF5IiwiYWRkQXJyYXkiLCJyZW1vdmVBcnJheSIsImNvcHlBcnJheSIsImNsb25lTm9kZSIsImNsb25lIiwibm9kZVR5cGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsImNoaWxkIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiaW5kZW50IiwicyIsInJhbmRvbUludGVnZXIiLCJmbG9vciIsInJhbmRvbSIsIldvcmtzcGFjZVN2ZyIsInNodWZmbGUiLCJtZXRyaWNzIiwiZ2V0TWV0cmljcyIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJibG9ja3MiLCJnZXRUb3BCbG9ja3MiLCJtYXhpbWFsX2luY3JlYXNlIiwiZ2V0UmVsYXRpdmVUb1N1cmZhY2VYWSIsIm1vdmVCeSIsIm1vdmVFbGVtZW50cyIsIm1vdmVDaGVjayIsImlzU2tCdWlsdGluIiwib2JqIiwibG5nIiwiaXNBc3ROb2RlIiwibWl4ZWRSZW1hcFRvUHkiLCJrIiwia3ZzIiwiYXJyIiwic3VidmFsIiwiYXNzayQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0NBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBLElBQU1BLGNBQWMsR0FBRyxPQUF2QjtBQUVBOzs7Ozs7Ozs7O0FBU08sSUFBTUMsT0FBYjtBQUNJOzs7OztBQUtBLG1CQUFZQyxhQUFaLEVBQTJCQyxVQUEzQixFQUF1Q0MsVUFBdkMsRUFBbUQ7QUFBQTs7QUFDL0MsU0FBS0MsU0FBTCxDQUFlSCxhQUFmOztBQUNBLFFBQUlDLFVBQVUsS0FBS0csU0FBbkIsRUFBOEI7QUFDMUIsV0FBS0MsYUFBTCxDQUFtQkwsYUFBbkIsRUFBa0NDLFVBQWxDLEVBQThDQyxVQUE5QztBQUNIOztBQUNELFNBQUtJLFFBQUw7QUFDSDtBQUVEOzs7Ozs7O0FBZEo7QUFBQTtBQUFBLCtCQW1CZTtBQUNQLFdBQUtDLGFBQUw7QUFDQSxXQUFLQyxnQkFBTDtBQUNBLFdBQUtDLFdBQUw7QUFDQSxXQUFLQyxhQUFMO0FBQ0EsV0FBS0MsVUFBTDtBQUNBLFdBQUtDLGNBQUw7QUFDQSxXQUFLQyxzQkFBTDtBQUNBLFdBQUtDLEtBQUw7QUFDSDtBQTVCTDtBQUFBOztBQThCSTs7Ozs7QUE5QkosK0JBbUNlQyxHQW5DZixFQW1Db0JDLFlBbkNwQixFQW1Da0M7QUFDMUIsVUFBSUQsR0FBRyxJQUFJLEtBQUtFLHFCQUFoQixFQUF1QztBQUNuQyxlQUFPLEtBQUtBLHFCQUFMLENBQTJCRixHQUEzQixDQUFQO0FBQ0gsT0FGRCxNQUVPLElBQUksS0FBS0csY0FBTCxDQUFvQkMsR0FBcEIsQ0FBd0JKLEdBQXhCLENBQUosRUFBa0M7QUFDckMsZUFBTyxLQUFLRyxjQUFMLENBQW9CRSxHQUFwQixDQUF3QkwsR0FBeEIsQ0FBUDtBQUNILE9BRk0sTUFFQTtBQUNILGVBQU9DLFlBQVA7QUFDSDtBQUNKO0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUE3Q0o7QUFBQTtBQUFBLDhCQXlEY2hCLGFBekRkLEVBeUQ2QjtBQUNyQjtBQUNBLFdBQUtrQixjQUFMLEdBQXNCLElBQUlHLDhEQUFKLENBQXdCLGVBQXhCLENBQXRCO0FBQ0EsV0FBS0oscUJBQUwsR0FBNkJqQixhQUE3QjtBQUVBLFdBQUtzQixLQUFMLEdBQWE7QUFDVEMsWUFBSSxFQUFFO0FBQ0ZDLFlBQUUsRUFBRUMsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsU0FBRCxDQUEzQixDQURGO0FBRUYyQixjQUFJLEVBQUVGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLFdBQUQsQ0FBM0IsQ0FGSjs7QUFHRjs7Ozs7QUFLQTRCLGNBQUksRUFBRUgsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBS0csVUFBTCxDQUFnQixXQUFoQixFQUE2QixPQUE3QixDQUFkLENBUko7O0FBU0Y7OztBQUdBQyxrQkFBUSxFQUFFTCxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxnQkFBRCxDQUEzQixDQVpSOztBQWFGOzs7QUFHQStCLGlCQUFPLEVBQUVOLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLGVBQUQsQ0FBM0I7QUFoQlAsU0FERztBQW1CVEMsa0JBQVUsRUFBRTtBQUNSdUIsWUFBRSxFQUFFQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBREk7QUFFUkMsY0FBSSxFQUFFRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxnQkFBZCxDQUZFO0FBR1JNLHNCQUFZLEVBQUVQLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLDZEQUFkLENBSE47O0FBSVI7OztBQUdBTyxhQUFHLEVBQUVSLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FQRztBQVFSO0FBQ0FRLGNBQUksRUFBRVQsRUFBRSxDQUFDQyxVQUFILENBQWNTLDBFQUFhLENBQUNDLE9BQTVCLENBVEU7QUFVUkMsZ0JBQU0sRUFBRVosRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQVZBO0FBV1JZLHNCQUFZLEVBQUViLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLDBCQUFELENBQWIsSUFBNkMsRUFBM0QsQ0FYTjtBQVlSdUMsZUFBSyxFQUFFZCxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUFiLElBQXNDLEVBQXBELENBWkM7QUFhUndDLGtCQUFRLEVBQUVmLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLHNCQUFELENBQWIsSUFBeUMsSUFBdkQsQ0FiRjtBQWNSeUMsZ0JBQU0sRUFBRWhCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLG9CQUFELENBQWIsSUFBdUMsSUFBckQsQ0FkQTtBQWVSMEMsOEJBQW9CLEVBQUVqQixFQUFFLENBQUNrQixlQUFILENBQW1CQyxvRUFBb0IsQ0FBQzVDLGFBQWEsQ0FBQyxtQ0FBRCxDQUFkLENBQXBCLElBQTRFLEVBQS9GLENBZmQ7QUFnQlI2Qyw0QkFBa0IsRUFBRXBCLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FoQlo7QUFpQlJHLGtCQUFRLEVBQUVyQixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBakJGO0FBa0JScUIsdUJBQWEsRUFBRXRCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FsQlA7QUFtQlJzQixpQkFBTyxFQUFFdkIsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQW5CRDtBQW9CUkksa0JBQVEsRUFBRUwsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXBCRjtBQXFCUnVCLGlCQUFPLEVBQUV4QixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBckJEO0FBc0JSd0IsY0FBSSxFQUFFekIsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQXRCRTtBQXVCUlEsMkJBQWlCLEVBQUUxQixFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBdkJYO0FBd0JSUyxrQkFBUSxFQUFFM0IsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMscUJBQUQsQ0FBM0IsQ0F4QkY7QUF5QlIsb0JBQVF5QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUEzQixDQXpCQTtBQTBCUnFELGdCQUFNLEVBQUU1QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUEzQixDQTFCQTtBQTJCUnNELGtCQUFRLEVBQUU3QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxzQkFBRCxDQUEzQixDQTNCRjtBQTRCUnVELGtCQUFRLEVBQUVDLGdHQUEyQixDQUFDeEQsYUFBRDtBQTVCN0IsU0FuQkg7QUFpRFRFLGtCQUFVLEVBQUU7QUFDUnNCLFlBQUUsRUFBRUMsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQURJO0FBRVIrQixjQUFJLEVBQUVoQyxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxpQkFBRCxDQUFiLElBQW9DLEVBQWxELENBRkU7QUFHUjBELG9CQUFVLEVBQUVqQyxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBSEo7QUFJUlYsYUFBRyxFQUFFUixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBSkc7QUFLUmlDLGtCQUFRLEVBQUVsQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBTEY7QUFNUmtDLGVBQUssRUFBRW5DLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FOQztBQU9SbUMsaUJBQU8sRUFBRXBDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FQRDtBQVFSO0FBQ0E7QUFDQTtBQUNBO0FBQ0F1QixpQkFBTyxFQUFFeEIsRUFBRSxDQUFDQyxVQUFILENBQWMsQ0FBZCxDQVpEO0FBYVJvQywwQkFBZ0IsRUFBRXJDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLFNBQWQsQ0FiVjtBQWNScUMsdUJBQWEsRUFBRXRDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLFVBQWQsQ0FkUDtBQWVSc0IsaUJBQU8sRUFBRXZCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQ7QUFmRCxTQWpESDtBQWtFVHNDLGVBQU8sRUFBRTtBQUNMOzs7O0FBSUFDLGtCQUFRLEVBQUV4QyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBTEw7O0FBTUw7Ozs7QUFJQXdDLG9CQUFVLEVBQUV6QyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFHLEtBQUtHLFVBQUwsQ0FBZ0Isb0JBQWhCLEVBQXNDLE9BQXRDLENBQUgsS0FBb0QsTUFBbEUsQ0FWUDs7QUFXTDs7O0FBR0FzQyxxQkFBVyxFQUFFMUMsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQWRSOztBQWVMOzs7O0FBSUEwQyxvQkFBVSxFQUFFM0MsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBS0csVUFBTCxDQUFnQixxQkFBaEIsRUFBdUN3Qyw2REFBWSxDQUFDQyxLQUFwRCxDQUFkLENBbkJQOztBQW9CTDs7OztBQUlBQyxxQkFBVyxFQUFFOUMsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQXhCUjs7QUF5Qkw7Ozs7OztBQU1BOEMsa0JBQVEsRUFBRS9DLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0EvQkw7O0FBZ0NMOzs7QUFHQStDLG9CQUFVLEVBQUVoRCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkLENBbkNQOztBQW9DTDs7Ozs7QUFLQWdELCtCQUFxQixFQUFFakQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXpDbEI7QUEwQ0xpRCw4QkFBb0IsRUFBRWxELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0ExQ2pCOztBQTJDTDs7OztBQUlBa0QsOEJBQW9CLEVBQUVuRCxFQUFFLENBQUNDLFVBQUgsQ0FBY21ELHdFQUEyQixDQUFDQyxRQUExQyxDQS9DakI7QUFnRExDLHNDQUE0QixFQUFFdEQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQWhEekI7O0FBaURMOzs7QUFHQXNELHdCQUFjLEVBQUV2RCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkLENBcERYOztBQXFETDs7OztBQUlBdUQseUJBQWUsRUFBRXhELEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0F6RFo7O0FBMERMOzs7QUFHQXVDLDZCQUFtQixFQUFFekQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQTdEaEI7O0FBOERMOzs7QUFHQXlELHlCQUFlLEVBQUUsSUFqRVo7O0FBa0VMOzs7Ozs7QUFNQUMseUJBQWUsRUFBRTNELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0F4RVo7O0FBeUVMOzs7O0FBSUEyRCxvQkFBVSxFQUFFNUQsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQTdFUDs7QUE4RUw7OztBQUdBNEQsa0JBQVEsRUFBRTdELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FqRkw7O0FBa0ZMOzs7QUFHQTZELHFCQUFXLEVBQUU5RCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBckZSOztBQXNGTDs7O0FBR0E4RCxzQkFBWSxFQUFFL0QsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXpGVDtBQTBGTCtELHVCQUFhLEVBQUUzRixjQTFGVjtBQTJGTDRGLGtCQUFRLEVBQUVqRSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFLRyxVQUFMLENBQWdCLG1CQUFoQixFQUFxQyxPQUFyQyxFQUE4QzhELFFBQTlDLE9BQTJELE1BQXpFLENBM0ZMOztBQTRGTDs7O0FBR0FDLHVCQUFhLEVBQUVuRSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkO0FBL0ZWLFNBbEVBO0FBbUtUbUUsY0FBTSxFQUFFO0FBQ0o7QUFDQUMsd0JBQWMsRUFBRXJFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FGWjtBQUdKQywrQkFBcUIsRUFBRXhFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FIbkI7QUFJSjtBQUNBd0UscUJBQVcsRUFBRXpFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FMVDtBQU1KRyw0QkFBa0IsRUFBRTFFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FOaEI7QUFPSjtBQUNBMEUsa0JBQVEsRUFBRTNFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FSTjtBQVNKSyx5QkFBZSxFQUFFNUUsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQVRiO0FBVUo7QUFDQTRFLHFCQUFXLEVBQUU3RSxFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCLENBWFQ7QUFZSk8sNEJBQWtCLEVBQUU5RSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBWmhCO0FBYUo7QUFDQThFLGtCQUFRLEVBQUUvRSxFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCLENBZE47QUFlSlMseUJBQWUsRUFBRWhGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FmYjtBQWdCSjtBQUNBZ0YsbUJBQVMsRUFBRWpGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FqQlA7QUFrQkpXLDBCQUFnQixFQUFFbEYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWxCZDtBQW1CSjtBQUNBa0Ysa0JBQVEsRUFBRW5GLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FwQk47QUFxQkphLHlCQUFlLEVBQUVwRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBckJiO0FBc0JKO0FBQ0FvRix3QkFBYyxFQUFFckYsRUFBRSxDQUFDQyxVQUFILENBQWNxRSxxREFBVyxDQUFDQyxLQUExQixDQXZCWjtBQXdCSmUsK0JBQXFCLEVBQUV0RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBeEJuQjtBQXlCSjtBQUNBc0YsMEJBQWdCLEVBQUV2RixFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCLENBMUJkO0FBMkJKaUIsaUNBQXVCLEVBQUV4RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBM0JyQjtBQTRCSjtBQUNBd0YsZ0NBQXNCLEVBQUV6RixFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCLENBN0JwQjtBQThCSm1CLHVDQUE2QixFQUFFMUYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQTlCM0I7QUErQko7QUFDQTBGLDJCQUFpQixFQUFFM0YsRUFBRSxDQUFDQyxVQUFILENBQWNxRSxxREFBVyxDQUFDQyxLQUExQixDQWhDZjtBQWlDSnFCLGtDQUF3QixFQUFFNUYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWpDdEI7QUFrQ0o7QUFDQTRGLHNCQUFZLEVBQUU3RixFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCLENBbkNWO0FBb0NKdUIsNkJBQW1CLEVBQUU5RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBcENqQjtBQXFDSjtBQUNBOEYsb0JBQVUsRUFBRS9GLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjcUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0F0Q1I7QUF1Q0p5QiwyQkFBaUIsRUFBRWhHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0F2Q2Y7QUF3Q0o7QUFDQWdHLHFCQUFXLEVBQUVqRyxFQUFFLENBQUNDLFVBQUgsQ0FBY3FFLHFEQUFXLENBQUNDLEtBQTFCO0FBekNULFNBbktDO0FBOE1UMkIsaUJBQVMsRUFBRTtBQUNQO0FBQ0FDLGlCQUFPLEVBQUUsRUFGRjtBQUdQO0FBQ0FDLGdCQUFNLEVBQUVwRyxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBSkQ7QUFLUDtBQUNBbUYsZUFBSyxFQUFFckcsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQU5BO0FBT1BvRixvQkFBVSxFQUFFdEcsRUFBRSxDQUFDQyxVQUFILENBQWMsQ0FBZCxDQVBMO0FBUVA7QUFDQXNHLGlCQUFPLEVBQUU7QUFDTDtBQUNBL0Qsb0JBQVEsRUFBRXhDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FGTDtBQUdMO0FBQ0F1Ryx1QkFBVyxFQUFFeEcsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQUpSO0FBS0w7QUFDQXdHLG9CQUFRLEVBQUV6RyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBTkw7QUFPTDtBQUNBeUcsdUJBQVcsRUFBRTFHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FSUjtBQVNMMEcsb0JBQVEsRUFBRTNHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FUTDtBQVVMO0FBQ0EyRyw0QkFBZ0IsRUFBRTVHLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FYYjtBQVlMO0FBQ0EyRiw0QkFBZ0IsRUFBRTdHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FiYjtBQWNMO0FBQ0E2RyxtQkFBTyxFQUFFLElBZko7QUFnQkxDLG1CQUFPLEVBQUUvRyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBaEJKO0FBaUJMK0csaUJBQUssRUFBRTtBQWpCRixXQVRGO0FBNEJQdkUsb0JBQVUsRUFBRTtBQUNSc0UsbUJBQU8sRUFBRSxJQUREO0FBRVJFLHNCQUFVLEVBQUV0STtBQUZKLFdBNUJMO0FBZ0NQO0FBQ0F1SSxrQkFBUSxFQUFFO0FBQ047QUFDQUMsbUJBQU8sRUFBRW5ILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLE9BQWQsQ0FGSDtBQUdObUgsb0JBQVEsRUFBRXBILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FISjtBQUlOb0gsaUJBQUssRUFBRXJILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FKRDtBQUtOMkIsa0JBQU0sRUFBRTVCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FMRjtBQU1OcUgsc0JBQVUsRUFBRXRILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FOTjtBQU9OcUcsMEJBQWMsRUFBRXZILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FQVjtBQVFOO0FBQ0E0RixtQkFBTyxFQUFFO0FBVEg7QUFqQ0gsU0E5TUY7QUEyUFR2SSxxQkFBYSxFQUFFO0FBQ1g7OztBQUdBaUosbUJBQVMsRUFBRTtBQUNQOzs7QUFHQSx1QkFBVyxLQUFLaEkscUJBQUwsQ0FBMkIsa0JBQTNCO0FBSkosV0FKQTs7QUFVWDs7OztBQUlBaUkseUJBQWUsRUFBRXpILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQUtHLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDLENBQWQsQ0FkTjtBQWVYO0FBQ0FzSCxxQkFBVyxFQUFFLEtBQUtsSSxxQkFBTCxDQUEyQixjQUEzQixDQWhCRjtBQWlCWDtBQUNBbUkseUJBQWUsRUFBRSxLQUFLbkkscUJBQUwsQ0FBMkIsa0JBQTNCLENBbEJOO0FBbUJYO0FBQ0FvSSxtQkFBUyxFQUFFLElBcEJBO0FBcUJYO0FBQ0FDLGNBQUksRUFBRSxLQUFLckkscUJBQUwsQ0FBMkIsTUFBM0IsS0FBc0M7QUF0QmpDO0FBM1BOLE9BQWI7QUFvUkg7QUFsVkw7QUFBQTs7QUFvVkk7OztBQXBWSixvQ0F1Vm9CO0FBQ1osVUFBSXNJLFNBQVMsR0FBRyxLQUFLakksS0FBTCxDQUFXdEIsYUFBM0I7QUFDQSxVQUFJd0osR0FBRyxHQUFHQyxrRUFBYSxDQUFDLElBQUQsQ0FBdkI7QUFDQUYsZUFBUyxDQUFDRixTQUFWLEdBQXNCSyw2Q0FBQyxDQUFDSCxTQUFTLENBQUNILGVBQVgsQ0FBRCxDQUE2Qk8sSUFBN0IsQ0FBa0NELDZDQUFDLENBQUNGLEdBQUQsQ0FBbkMsQ0FBdEI7QUFDSDtBQTNWTDtBQUFBO0FBQUEsbUNBNlZtQkksYUE3Vm5CLEVBNlZrQztBQUMxQixXQUFLQyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QmhFLGNBQXZCLENBQXNDOEQsYUFBdEM7QUFDSDtBQS9WTDtBQUFBO0FBQUEsNkJBaVdhMUcsSUFqV2IsRUFpV21CLENBQ1g7QUFDSDtBQW5XTDtBQUFBO0FBQUEsMENBcVcwQjZHLE9BclcxQixFQXFXbUMsQ0FDM0I7QUFDSDtBQXZXTDtBQUFBO0FBQUEscUNBeVdxQjlKLFVBeldyQixFQXlXaUM7QUFDekIsV0FBS3FCLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0J1RCxJQUF0QixDQUEyQnhELFVBQVUsQ0FBQytKLGFBQXRDO0FBQ0FwSCwwRUFBb0IsQ0FBQzNDLFVBQVUsQ0FBQ2dLLG9CQUFaLEVBQWtDLEtBQUszSSxLQUFMLENBQVdwQixVQUFYLENBQXNCd0QsVUFBeEQsQ0FBcEI7QUFDSDtBQTVXTDtBQUFBO0FBQUEsbUNBOFdtQnhELFVBOVduQixFQThXK0JELFVBOVcvQixFQThXMkM7QUFDbkMsVUFBSSxDQUFDQyxVQUFMLEVBQWlCO0FBQ2I7QUFDQSxhQUFLZ0ssZ0JBQUwsQ0FBc0JqSyxVQUF0QjtBQUNBLGVBQU8sS0FBUDtBQUNILE9BTGtDLENBTW5DOzs7QUFDQSxXQUFLcUIsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnNCLEVBQXRCLENBQXlCdEIsVUFBVSxDQUFDc0IsRUFBcEM7QUFDQSxXQUFLRixLQUFMLENBQVdwQixVQUFYLENBQXNCdUQsSUFBdEIsQ0FBMkJ2RCxVQUFVLENBQUN1RCxJQUF0QztBQUNBLFdBQUtuQyxLQUFMLENBQVdwQixVQUFYLENBQXNCMkQsT0FBdEIsQ0FBOEIzRCxVQUFVLENBQUMyRCxPQUF6QztBQUNBLFdBQUt2QyxLQUFMLENBQVdwQixVQUFYLENBQXNCMEQsS0FBdEIsQ0FBNEIxRCxVQUFVLENBQUMwRCxLQUF2QztBQUNBLFdBQUt0QyxLQUFMLENBQVdwQixVQUFYLENBQXNCeUQsUUFBdEIsQ0FBK0J6RCxVQUFVLENBQUN5RCxRQUExQztBQUNBLFdBQUtyQyxLQUFMLENBQVdwQixVQUFYLENBQXNCK0IsR0FBdEIsQ0FBMEIvQixVQUFVLENBQUMrQixHQUFyQztBQUNBLFdBQUtYLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IrQyxPQUF0QixDQUE4Qi9DLFVBQVUsQ0FBQytDLE9BQXpDO0FBQ0EsV0FBSzNCLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I2RCxhQUF0QixDQUFvQzdELFVBQVUsQ0FBQ2lLLGNBQS9DO0FBQ0EsV0FBSzdJLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I0RCxnQkFBdEIsQ0FBdUM1RCxVQUFVLENBQUNrSyxpQkFBbEQ7QUFDQSxXQUFLOUksS0FBTCxDQUFXcEIsVUFBWCxDQUFzQjhDLE9BQXRCLENBQThCOUMsVUFBVSxDQUFDbUssT0FBekM7QUFDQSxXQUFLL0ksS0FBTCxDQUFXQyxJQUFYLENBQWdCTyxRQUFoQixDQUF5QjVCLFVBQVUsQ0FBQ29LLFNBQXBDO0FBQ0ExSCwwRUFBb0IsQ0FBQzFDLFVBQVUsQ0FBQ3FLLFdBQVosRUFBeUIsS0FBS2pKLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0J3RCxVQUEvQyxDQUFwQjtBQUNIO0FBallMO0FBQUE7QUFBQSx3Q0FtWXdCOEcsSUFuWXhCLEVBbVk4QjtBQUN0QkMsYUFBTyxDQUFDQyxHQUFSLENBQVlGLElBQVo7QUFDQSxXQUFLRyxjQUFMO0FBQ0EsV0FBS2QsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJDLGtCQUEzQjtBQUNBLFVBQUlDLGtCQUFrQixHQUFHLEtBQUt4SixLQUFMLENBQVd0QixhQUFYLENBQXlCa0osZUFBekIsRUFBekI7QUFDQSxXQUFLNUgsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QmtKLGVBQXpCLENBQXlDLEtBQXpDO0FBQ0EsVUFBSWpKLFVBQVUsR0FBR3VLLElBQUksQ0FBQ3ZLLFVBQXRCO0FBQ0EsV0FBS3FCLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0J1QixFQUF0QixDQUF5QnZCLFVBQVUsQ0FBQ3VCLEVBQXBDO0FBQ0EsV0FBS0YsS0FBTCxDQUFXckIsVUFBWCxDQUFzQmdELE9BQXRCLENBQThCaEQsVUFBVSxDQUFDZ0QsT0FBekM7QUFDQSxXQUFLM0IsS0FBTCxDQUFXckIsVUFBWCxDQUFzQjZCLFFBQXRCLENBQStCN0IsVUFBVSxDQUFDcUssU0FBMUM7QUFDQSxXQUFLaEosS0FBTCxDQUFXckIsVUFBWCxDQUFzQjZDLFFBQXRCLENBQStCN0MsVUFBVSxDQUFDOEssU0FBMUM7QUFDQSxXQUFLekosS0FBTCxDQUFXckIsVUFBWCxDQUFzQjhDLGFBQXRCLENBQW9DOUMsVUFBVSxDQUFDK0ssY0FBL0M7QUFDQSxXQUFLMUosS0FBTCxDQUFXckIsVUFBWCxDQUFzQm9ELE1BQXRCLENBQTZCcEQsVUFBVSxDQUFDb0QsTUFBeEM7QUFDQSxXQUFLL0IsS0FBTCxDQUFXckIsVUFBWCxDQUFzQm1ELFFBQXRCLENBQStCbkQsVUFBVSxDQUFDbUQsUUFBMUM7QUFDQSxXQUFLOUIsS0FBTCxDQUFXckIsVUFBWCxXQUE2QkEsVUFBVSxVQUF2QztBQUNBLFdBQUtxQixLQUFMLENBQVdyQixVQUFYLENBQXNCaUMsSUFBdEIsQ0FBMkJqQyxVQUFVLENBQUNpQyxJQUF0QztBQUNBLFdBQUtaLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JnQyxHQUF0QixDQUEwQmhDLFVBQVUsQ0FBQ2dDLEdBQXJDO0FBQ0EsV0FBS1gsS0FBTCxDQUFXckIsVUFBWCxDQUFzQm9DLE1BQXRCLENBQTZCcEMsVUFBVSxDQUFDb0MsTUFBeEM7QUFDQSxXQUFLZixLQUFMLENBQVdyQixVQUFYLENBQXNCcUQsUUFBdEIsQ0FBK0JyRCxVQUFVLENBQUNnTCxTQUExQztBQUNBLFdBQUszSixLQUFMLENBQVdyQixVQUFYLENBQXNCK0IsWUFBdEIsQ0FBbUMvQixVQUFVLENBQUMrQixZQUE5QztBQUNBLFdBQUtWLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0IwQixJQUF0QixDQUEyQjFCLFVBQVUsQ0FBQzBCLElBQXRDO0FBQ0EsV0FBS0wsS0FBTCxDQUFXckIsVUFBWCxDQUFzQnVDLFFBQXRCLENBQStCdkMsVUFBVSxDQUFDaUwsU0FBWCxJQUF3QixJQUF2RDs7QUFDQSxVQUFJakwsVUFBVSxDQUFDaUwsU0FBZixFQUEwQjtBQUN0QixhQUFLckIsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DLGVBQW5DLEVBQW9EbEwsVUFBVSxDQUFDaUwsU0FBL0Q7QUFDSDs7QUFDRCxXQUFLNUosS0FBTCxDQUFXckIsVUFBWCxDQUFzQndDLE1BQXRCLENBQTZCeEMsVUFBVSxDQUFDbUwsT0FBWCxJQUFzQixJQUFuRDs7QUFDQSxVQUFJbkwsVUFBVSxDQUFDbUwsT0FBZixFQUF3QjtBQUNwQixhQUFLdkIsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DLGFBQW5DLEVBQWtEbEwsVUFBVSxDQUFDbUwsT0FBN0Q7QUFDSDs7QUFDRCxXQUFLOUosS0FBTCxDQUFXckIsVUFBWCxDQUFzQnNDLEtBQXRCLENBQTRCdEMsVUFBVSxDQUFDb0wsTUFBdkM7QUFDQSxXQUFLL0osS0FBTCxDQUFXckIsVUFBWCxDQUFzQnFDLFlBQXRCLENBQW1DckMsVUFBVSxDQUFDK0osYUFBOUM7QUFDQSxXQUFLMUksS0FBTCxDQUFXckIsVUFBWCxDQUFzQitDLE9BQXRCLENBQThCL0MsVUFBVSxDQUFDcUwsUUFBekM7QUFDQSxXQUFLQyxRQUFMLENBQWN0TCxVQUFVLENBQUNpRCxJQUF6QjtBQUNBLFdBQUtzSSxxQkFBTCxDQUEyQnZMLFVBQVUsQ0FBQ3dMLGtCQUF0QztBQUNBN0ksMEVBQW9CLENBQUMzQyxVQUFVLENBQUN5TCxzQkFBWixFQUFvQyxLQUFLcEssS0FBTCxDQUFXckIsVUFBWCxDQUFzQnlDLG9CQUExRCxDQUFwQjtBQUNBRSwwRUFBb0IsQ0FBQzNDLFVBQVUsQ0FBQ2dLLG9CQUFaLEVBQWtDLEtBQUszSSxLQUFMLENBQVdyQixVQUFYLENBQXNCNEMsa0JBQXhELENBQXBCO0FBQ0E4SSxpR0FBc0IsQ0FBQyxLQUFLckssS0FBTixFQUFhckIsVUFBVSxDQUFDc0QsUUFBeEIsQ0FBdEI7QUFDQSxXQUFLcUksY0FBTCxDQUFvQnBCLElBQUksQ0FBQ3RLLFVBQXpCLEVBQXFDRCxVQUFyQztBQUNBLFdBQUtxQixLQUFMLENBQVcwQyxPQUFYLENBQW1Cb0IsZUFBbkIsQ0FBbUMsSUFBbkM7QUFDQSxXQUFLOUQsS0FBTCxDQUFXMEMsT0FBWCxDQUFtQmtCLG1CQUFuQixDQUF1QyxJQUF2QztBQUNBLFdBQUs1RCxLQUFMLENBQVd0QixhQUFYLENBQXlCa0osZUFBekIsQ0FBeUM0QixrQkFBekM7QUFDQSxXQUFLakIsVUFBTCxDQUFnQmdDLE1BQWhCLENBQXVCQyxZQUF2QixDQUFvQyxJQUFwQztBQUNBLFdBQUtqQyxVQUFMLENBQWdCa0MsWUFBaEIsQ0FBNkJDLEVBQTdCLENBQWdDQyxPQUFoQztBQUVBLFdBQUtwQyxVQUFMLENBQWdCQyxNQUFoQixDQUF1Qm9DLFNBQXZCLENBQWlDLFVBQWpDLEVBQTZDbkcscURBQVcsQ0FBQ0MsS0FBekQ7QUFDSDtBQWhiTDtBQUFBO0FBQUEsdUNBa2J1QjtBQUFBOztBQUNmLFVBQUltRyxJQUFJLEdBQUcsSUFBWDtBQUNBLFVBQUk3SyxLQUFLLEdBQUcsS0FBS0EsS0FBakI7QUFDQUEsV0FBSyxDQUFDOEssRUFBTixHQUFXO0FBQ1B4SyxZQUFJLEVBQUU7QUFDRnlLLGtCQUFRLEVBQUU1SyxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3RCaEwsS0FBSyxDQUFDQyxJQUFOLENBQVdLLElBQVgsT0FBc0IsT0FBdEIsSUFBaUNOLEtBQUssQ0FBQ0MsSUFBTixDQUFXSyxJQUFYLE9BQXNCLFFBRGpDO0FBQUEsV0FBaEI7QUFEUixTQURDO0FBS1BJLG9CQUFZLEVBQUU7QUFDVnVLLG1CQUFTLEVBQUU5SyxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3ZCaEwsS0FBSyxDQUFDMEMsT0FBTixDQUFja0IsbUJBQWQsT0FBd0MsSUFEakI7QUFBQSxXQUFoQixDQUREO0FBSVZzSCxpQkFBTyxFQUFFL0ssRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUNyQmhMLEtBQUssQ0FBQzhLLEVBQU4sQ0FBU3BLLFlBQVQsQ0FBc0J1SyxTQUF0QixLQUNJSixJQUFJLENBQUNNLFNBQUwsQ0FBZUMsUUFBZixDQUF3QnBMLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY2tCLG1CQUFkLEVBQXhCLENBREosR0FFSWlILElBQUksQ0FBQ00sU0FBTCxDQUFlQyxRQUFmLENBQXdCcEwsS0FBSyxDQUFDckIsVUFBTixDQUFpQitCLFlBQWpCLEVBQXhCLENBSGlCO0FBQUEsV0FBaEIsQ0FKQztBQVNWMkssZUFBSyxFQUFFO0FBQUEsbUJBQ0hyTCxLQUFLLENBQUMwQyxPQUFOLENBQWNrQixtQkFBZCxDQUFrQyxJQUFsQyxDQURHO0FBQUE7QUFURyxTQUxQO0FBaUJQMEgsWUFBSSxFQUFFO0FBQ0ZDLHdCQUFjLEVBQUVwTCxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQzNCaEwsS0FBSyxDQUFDMEMsT0FBTixDQUFjcUIsVUFBZCxFQUFELEdBQStCLHdCQUEvQixHQUEwRCxzQkFEOUI7QUFBQSxXQUFoQixDQURkO0FBSUZ5SCx5QkFBZSxFQUFFLDJCQUFLO0FBQ2xCeEwsaUJBQUssQ0FBQzBDLE9BQU4sQ0FBY3FCLFVBQWQsQ0FBeUIsQ0FBQy9ELEtBQUssQ0FBQzBDLE9BQU4sQ0FBY3FCLFVBQWQsRUFBMUI7QUFDSCxXQU5DO0FBT0YwSCxvQkFBVSxFQUFFLHNCQUFNO0FBQ2QsaUJBQUksQ0FBQ2xELFVBQUwsQ0FBZ0JtRCxNQUFoQixDQUF1QkMsV0FBdkI7QUFDSCxXQVRDO0FBVUZDLHNCQUFZLEVBQUUsd0JBQU07QUFDaEIsZ0JBQUk1TCxLQUFLLENBQUMwQyxPQUFOLENBQWN3QixZQUFkLEVBQUosRUFBa0M7QUFDOUIyRyxrQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmtDLFlBQWhCLENBQTZCQyxFQUE3QixDQUFnQ21CLFVBQWhDLENBQTJDQyxhQUEzQztBQUNILGFBRkQsTUFFTztBQUNIakIsa0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JrQyxZQUFoQixDQUE2QkMsRUFBN0IsQ0FBZ0NtQixVQUFoQyxDQUEyQ0UsWUFBM0M7QUFDSDs7QUFDRC9MLGlCQUFLLENBQUMwQyxPQUFOLENBQWN3QixZQUFkLENBQTJCLENBQUNsRSxLQUFLLENBQUMwQyxPQUFOLENBQWN3QixZQUFkLEVBQTVCO0FBQ0gsV0FqQkM7QUFrQkY4SCwwQkFBZ0IsRUFBRTdMLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDOUJoTCxLQUFLLENBQUNyQixVQUFOLENBQWlCb0QsTUFBakIsTUFBNkIvQixLQUFLLENBQUNyQixVQUFOLENBQWlCbUQsUUFBakIsRUFBN0IsSUFDQTlCLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmdLLFFBQTFCLEVBRjhCO0FBQUEsV0FBaEIsQ0FsQmhCO0FBc0JGQywyQkFBaUIsRUFBRS9MLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0IsWUFBTTtBQUNyQyxnQkFBSWhMLEtBQUssQ0FBQzhLLEVBQU4sQ0FBU1EsSUFBVCxDQUFjYSxXQUFkLEVBQUosRUFBaUM7QUFDN0IscUJBQU9uTSxLQUFLLENBQUNDLElBQU4sQ0FBV1EsT0FBWCxLQUF1QixnQkFBdkIsR0FBMEMsbUJBQWpEO0FBQ0gsYUFGRCxNQUVPLElBQUlULEtBQUssQ0FBQzhLLEVBQU4sQ0FBU1EsSUFBVCxDQUFjYyxXQUFkLEVBQUosRUFBaUM7QUFDcEMscUJBQU8sb0JBQVA7QUFDSCxhQUZNLE1BRUEsSUFBSXBNLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY29CLGVBQWQsRUFBSixFQUFxQztBQUN4QyxxQkFBTyxLQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0gsa0JBQUksQ0FBQzlELEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJvRCxNQUFqQixFQUFELElBQThCL0IsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjJELE9BQWpCLEVBQWxDLEVBQThEO0FBQzFELHVCQUFPLFFBQVA7QUFDSCxlQUZELE1BRU87QUFDSCx1QkFBTyxjQUFQO0FBQ0g7QUFDSjtBQUNKLFdBZGtCLENBdEJqQjtBQXFDRjhKLDRCQUFrQixFQUFFLDhCQUFNO0FBQ3RCLGdCQUFJck0sS0FBSyxDQUFDOEssRUFBTixDQUFTUSxJQUFULENBQWNhLFdBQWQsRUFBSixFQUFpQztBQUM3QkcsbUJBQUssQ0FBQyx5REFBRCxDQUFMO0FBQ0gsYUFGRCxNQUVPLElBQUl0TSxLQUFLLENBQUM4SyxFQUFOLENBQVNRLElBQVQsQ0FBY2MsV0FBZCxFQUFKLEVBQWlDO0FBQ3BDdkIsa0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCNUMsc0JBQXZCLENBQThDLFlBQTlDO0FBQ0gsYUFGTSxNQUVBLElBQUk1RixLQUFLLENBQUMwQyxPQUFOLENBQWNvQixlQUFkLEVBQUosRUFBcUM7QUFDeEMrRyxrQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmdFLE1BQWhCLENBQXVCQyxVQUF2QjtBQUNILGFBRk0sTUFFQTtBQUNIM0Isa0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCNUMsc0JBQXZCLENBQThDLFdBQTlDO0FBQ0g7QUFDSixXQS9DQztBQWdERndHLHFCQUFXLEVBQUVqTSxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3pCLENBQUNoTCxLQUFLLENBQUNyQixVQUFOLENBQWlCbUQsUUFBakIsTUFBK0I5QixLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJnSyxRQUExQixFQUFoQyxLQUNBak0sS0FBSyxDQUFDcEIsVUFBTixDQUFpQjRELGdCQUFqQixHQUFvQ2lLLFdBQXBDLE9BQXNELFdBRjdCO0FBQUEsV0FBaEIsQ0FoRFg7QUFvREZOLHFCQUFXLEVBQUVoTSxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3pCaEwsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjRELGdCQUFqQixHQUFvQ2lLLFdBQXBDLE9BQXNELFdBRDdCO0FBQUEsV0FBaEIsQ0FwRFg7QUF1REZDLDBCQUFnQixFQUFFdk0sRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUM5QixDQUFDaEwsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMEssZ0JBQTFCLEVBRDZCO0FBQUEsV0FBaEI7QUF2RGhCLFNBakJDO0FBNEVQQyxpQkFBUyxFQUFFO0FBQ1BDLHNCQUFZLEVBQUUxTSxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQzFCLENBQUNoTCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI2SyxlQUExQixFQUR5QjtBQUFBLFdBQWhCLENBRFA7QUFJUEMsMkJBQWlCLEVBQUU1TSxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQy9CaEwsS0FBSyxDQUFDMEMsT0FBTixDQUFjWSxvQkFBZCxPQUF5Q0Msd0VBQTJCLENBQUNDLFFBRHRDO0FBQUEsV0FBaEIsQ0FKWjtBQU9Qd0osd0JBQWMsRUFBRTdNLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDNUJoTCxLQUFLLENBQUMwQyxPQUFOLENBQWNZLG9CQUFkLE9BQXlDQyx3RUFBMkIsQ0FBQzBKLEtBRHpDO0FBQUEsV0FBaEIsQ0FQVDtBQVVQQyw4QkFBb0IsRUFBRS9NLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDbENoTCxLQUFLLENBQUM4SyxFQUFOLENBQVM4QixTQUFULENBQW1CRyxpQkFBbkIsTUFBMEMvTSxLQUFLLENBQUM4SyxFQUFOLENBQVM4QixTQUFULENBQW1CSSxjQUFuQixFQURSO0FBQUEsV0FBaEIsQ0FWZjtBQWFQRyxxQkFBVyxFQUFFaE4sRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUN6QmhMLEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixPQUF1QyxJQUF2QyxHQUNJLFlBREosR0FDbUIsRUFGTTtBQUFBLFdBQWhCLENBYk47QUFpQlB3RyxzQkFBWSxFQUFFLHdCQUFZO0FBQ3RCLGdCQUFJQyxZQUFZLEdBQUdyTixLQUFLLENBQUMwQyxPQUFOLENBQWNZLG9CQUFqQzs7QUFDQSxnQkFBSStKLFlBQVksT0FBTzlKLHdFQUEyQixDQUFDK0osSUFBbkQsRUFBeUQ7QUFDckRELDBCQUFZLENBQUM5Six3RUFBMkIsQ0FBQ0MsUUFBN0IsQ0FBWjtBQUNILGFBRkQsTUFFTyxJQUFJNkosWUFBWSxPQUFPOUosd0VBQTJCLENBQUMwSixLQUFuRCxFQUEwRDtBQUM3REksMEJBQVksQ0FBQzlKLHdFQUEyQixDQUFDK0osSUFBN0IsQ0FBWjtBQUNILGFBRk0sTUFFQSxJQUFJdE4sS0FBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JFLFFBQXhCLE9BQXVDLElBQTNDLEVBQWlEO0FBQ3BEeUcsMEJBQVksQ0FBQzlKLHdFQUEyQixDQUFDMEosS0FBN0IsQ0FBWjtBQUNILGFBRk0sTUFFQTtBQUNISSwwQkFBWSxDQUFDOUosd0VBQTJCLENBQUMrSixJQUE3QixDQUFaO0FBQ0g7QUFDSixXQTVCTTtBQTZCUEMsa0JBQVEsRUFBRSxvQkFBWTtBQUNsQixnQkFBTUYsWUFBWSxHQUFHck4sS0FBSyxDQUFDMEMsT0FBTixDQUFjWSxvQkFBbkM7QUFDQXRELGlCQUFLLENBQUMwQyxPQUFOLENBQWNlLDRCQUFkLENBQTJDNEosWUFBWSxFQUF2RDtBQUNBQSx3QkFBWSxDQUFDOUosd0VBQTJCLENBQUMrSixJQUE3QixDQUFaO0FBQ0gsV0FqQ007QUFrQ1BFLHNCQUFZLEVBQUUsd0JBQVc7QUFDckIsZ0JBQU1DLFFBQVEsR0FBR3pOLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY2UsNEJBQS9COztBQUNBLGdCQUFJZ0ssUUFBUSxPQUFPLElBQW5CLEVBQXlCO0FBQ3JCek4sbUJBQUssQ0FBQzBDLE9BQU4sQ0FBY1ksb0JBQWQsQ0FBbUNtSyxRQUFRLEVBQTNDO0FBQ0FBLHNCQUFRLENBQUMsSUFBRCxDQUFSO0FBQ0g7QUFDSjtBQXhDTSxTQTVFSjtBQXNIUHRFLGVBQU8sRUFBRTtBQUNMdUUsY0FBSSxFQUFFdk4sRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUNsQmhMLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY1ksb0JBQWQsT0FBeUNDLHdFQUEyQixDQUFDK0osSUFBckUsR0FDSSxXQURKLEdBRUksVUFIYztBQUFBLFdBQWhCLENBREQ7QUFNTEssc0JBQVksRUFBRXhOLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBaUI7QUFBQSxtQkFDM0JoTCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIwTCxZQUExQixNQUE0QyxDQUFDM04sS0FBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JRLE9BQXhCLEVBQTdDLElBQ0FsSCxLQUFLLENBQUN1RSxNQUFOLENBQWE2QixXQUFiLE9BQStCM0IscURBQVcsQ0FBQ21KLE1BRmhCO0FBQUEsV0FBakI7QUFOVCxTQXRIRjtBQWlJUHZHLGdCQUFRLEVBQUU7QUFDTndHLGVBQUssRUFBRTFOLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0IsWUFBWTtBQUMvQixnQkFBSWhMLEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkUsUUFBekIsT0FBd0MsSUFBNUMsRUFBa0Q7QUFDOUMscUJBQU8sWUFBUDtBQUNIOztBQUNELG9CQUFRdkgsS0FBSyxDQUFDcUcsU0FBTixDQUFnQmdCLFFBQWhCLENBQXlCRSxRQUF6QixHQUFvQ2tGLFdBQXBDLEVBQVI7QUFDSTtBQUNBLG1CQUFLLE1BQUw7QUFDSSx1QkFBTyxZQUFQOztBQUNKLG1CQUFLLFNBQUw7QUFDSSx1QkFBTyxxQkFBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sb0JBQVA7O0FBQ0osbUJBQUssUUFBTDtBQUNJLHVCQUFPLG9CQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxzQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0EsbUJBQUssVUFBTDtBQUNJLHVCQUFPLHNCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDQSxtQkFBSyxZQUFMO0FBQ0ksdUJBQU8sc0JBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNJLHVCQUFPLHdCQUFQOztBQUNKLG1CQUFLLGNBQUw7QUFDSSx1QkFBTyxvQkFBUDs7QUFDSixtQkFBSyxXQUFMO0FBQ0ksdUJBQU8saUJBQVA7QUF2QlI7QUF5QkgsV0E3Qk0sQ0FERDtBQStCTmxGLGtCQUFRLEVBQUVwSCxFQUFFLENBQUM2SyxZQUFILENBQWdCLFlBQVk7QUFDbEMsZ0JBQUloTCxLQUFLLENBQUNxRyxTQUFOLENBQWdCZ0IsUUFBaEIsQ0FBeUJFLFFBQXpCLE9BQXdDLElBQTVDLEVBQWtEO0FBQzlDLHFCQUFPLEVBQVA7QUFDSDs7QUFDRCxvQkFBUXZILEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkUsUUFBekIsR0FBb0NrRixXQUFwQyxFQUFSO0FBQ0k7QUFDQSxtQkFBSyxNQUFMO0FBQ0ksdUJBQU8sRUFBUDs7QUFDSixtQkFBSyxTQUFMO0FBQ0ksdUJBQU8sZUFBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sY0FBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sY0FBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0ksdUJBQU8sZ0JBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNBLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxpQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0EsbUJBQUssY0FBTDtBQUNJLHVCQUFPLGNBQVA7O0FBQ0osbUJBQUssWUFBTDtBQUNJLHVCQUFPLGtCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxVQUFQOztBQUNKLG1CQUFLLFdBQUw7QUFDSSx1QkFBTyxXQUFQO0FBdkJSO0FBeUJILFdBN0JTO0FBL0JKLFNBaklIO0FBK0xQcUIsYUFBSyxFQUFFO0FBQ0hqTyxhQUFHLEVBQUVNLEVBQUUsQ0FBQzZLLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDakJoTCxLQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLE9BQStDLElBRDlCO0FBQUEsV0FBaEIsQ0FERjtBQUlIZ0gsY0FBSSxFQUFFNU4sRUFBRSxDQUFDNkssWUFBSCxDQUFnQixZQUFZO0FBQzlCLGdCQUFJZ0QsSUFBSSxHQUFHaE8sS0FBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixFQUFYO0FBQ0EsZ0JBQUlKLFFBQVEsR0FBRzVHLEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUFmO0FBQ0EsZ0JBQUlxSCxTQUFTLEdBQUdqTyxLQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLEVBQWhCOztBQUNBLGdCQUFJLENBQUNrSCxTQUFELElBQWNELElBQUksS0FBSyxJQUEzQixFQUFpQztBQUM3QixxQkFBTyxVQUFQO0FBQ0g7O0FBQ0QsZ0JBQUlBLElBQUksS0FBSyxDQUFiLEVBQWdCO0FBQ1oscUJBQU8sWUFBUDtBQUNILGFBRkQsTUFFTyxJQUFJQSxJQUFJLEtBQUtwSCxRQUFiLEVBQXVCO0FBQzFCLHFCQUFPLGNBQVA7QUFDSCxhQUZNLE1BRUE7QUFDSDtBQUNBLHFCQUFPLFdBQVNxSCxTQUFTLENBQUNELElBQUQsQ0FBVCxDQUFnQkQsSUFBaEIsR0FBcUIsQ0FBOUIsQ0FBUDtBQUNIO0FBQ0osV0FmSyxDQUpIO0FBb0JIRyxlQUFLLEVBQUUsaUJBQVk7QUFDZmxPLGlCQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLENBQXlDLENBQXpDO0FBQ0gsV0F0QkU7QUF1QkhtSCxrQkFBUSxFQUFFLG9CQUFZO0FBQ2xCLGdCQUFJQyxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWXRPLEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsS0FBNkMsQ0FBekQsQ0FBZjtBQUNBaEgsaUJBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsQ0FBeUNvSCxRQUF6QztBQUNILFdBMUJFO0FBMkJIRyxpQkFBTyxFQUFFLG1CQUFZO0FBQ2pCLGdCQUFJQyxJQUFJLEdBQUdILElBQUksQ0FBQ0ksR0FBTCxDQUFTek8sS0FBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JFLFFBQXhCLEVBQVQsRUFBNkM1RyxLQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLEtBQTZDLENBQTFGLENBQVg7QUFDQWhILGlCQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLENBQXlDd0gsSUFBekM7QUFDSCxXQTlCRTtBQStCSEUsY0FBSSxFQUFFLGdCQUFZO0FBQ2QxTyxpQkFBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixDQUF5Q2hILEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUF6QztBQUNILFdBakNFO0FBa0NIc0MsY0FBSSxFQUFFL0ksRUFBRSxDQUFDNkssWUFBSCxDQUFnQixZQUFZO0FBQzlCLGdCQUFJZ0QsSUFBSSxHQUFHaE8sS0FBSyxDQUFDcUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixFQUFYO0FBQ0EsZ0JBQUlKLFFBQVEsR0FBRzVHLEtBQUssQ0FBQ3FHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUFmO0FBQ0EsZ0JBQUlxSCxTQUFTLEdBQUdqTyxLQUFLLENBQUNxRyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLEVBQWhCOztBQUNBLGdCQUFJLENBQUNrSCxTQUFMLEVBQWdCO0FBQ1oscUJBQU8sRUFBUDtBQUNIOztBQUNELG9CQUFRRCxJQUFSO0FBQ0ksbUJBQUssQ0FBTDtBQUNJLHVCQUFPLEVBQVA7O0FBQ0osbUJBQUtwSCxRQUFMO0FBQ0ksdUJBQU9xSCxTQUFTLENBQUNELElBQUksR0FBRyxDQUFSLENBQWhCOztBQUNKO0FBQ0ksdUJBQU9DLFNBQVMsQ0FBQ0QsSUFBRCxDQUFoQjtBQU5SO0FBUUgsV0FmSztBQWxDSCxTQS9MQTtBQWtQUFcsYUFBSyxFQUFFO0FBQ0hDLGlCQUFPLEVBQUV6TyxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3JCaEwsS0FBSyxDQUFDMEMsT0FBTixDQUFjRSxVQUFkLE1BQThCLENBQUM1QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI0TSxTQUExQixFQURWO0FBQUEsV0FBaEIsQ0FETjtBQUlIQyxxQkFBVyxFQUFFLHFCQUFTQyxJQUFULEVBQWU7QUFDeEIsb0JBQVFBLElBQVI7QUFDSSxtQkFBSyxXQUFMO0FBQWtCLHVCQUFPL08sS0FBSyxDQUFDcEIsVUFBTixDQUFpQnVELElBQWpCLEVBQVA7O0FBQ2xCLG1CQUFLLGtCQUFMO0FBQXlCLHVCQUFPbkMsS0FBSyxDQUFDckIsVUFBTixDQUFpQitCLFlBQWpCLEVBQVA7O0FBQ3pCLG1CQUFLLGVBQUw7QUFBc0IsdUJBQU9WLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ1QyxRQUFqQixPQUFnQyxJQUF2Qzs7QUFDdEIsbUJBQUssYUFBTDtBQUFvQix1QkFBT2xCLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ3QyxNQUFqQixPQUE4QixJQUFyQzs7QUFDcEIsbUJBQUssb0JBQUw7QUFBMkIsdUJBQU9uQixLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDNE4sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUMvRUEsSUFBSSxDQUFDdE0sUUFBTCxPQUFvQixvQkFEMkQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFM0IsbUJBQUssaUJBQUw7QUFBd0IsdUJBQU8zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDNE4sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM1RUEsSUFBSSxDQUFDdE0sUUFBTCxPQUFvQixpQkFEd0Q7QUFBQSxpQkFBakQsQ0FBUDs7QUFFeEIsbUJBQUssbUJBQUw7QUFBMEIsdUJBQU8zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDNE4sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM5RUEsSUFBSSxDQUFDdE0sUUFBTCxPQUFvQixtQkFEMEQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFMUIsbUJBQUssbUJBQUw7QUFBMEIsdUJBQU8zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDNE4sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM5RUEsSUFBSSxDQUFDdE0sUUFBTCxPQUFvQixtQkFEMEQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFMUIsbUJBQUssa0JBQUw7QUFBeUIsdUJBQU8zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDNE4sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM3RUEsSUFBSSxDQUFDdE0sUUFBTCxPQUFvQixrQkFEeUQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFekIsbUJBQUssZUFBTDtBQUFzQix1QkFBTzNDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJpRCxJQUFqQixHQUF3QnNOLE1BQS9COztBQUN0QixtQkFBSyw2QkFBTDtBQUFvQyx1QkFBT2xQLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJrRCxpQkFBakIsR0FBcUNxTixNQUE1Qzs7QUFDcEM7QUFBUyx1QkFBTyxLQUFQO0FBakJiO0FBbUJILFdBeEJFO0FBeUJIQyxhQUFHLEVBQUUsYUFBU0osSUFBVCxFQUFlO0FBQ2hCLG9CQUFRQSxJQUFSO0FBQ0ksbUJBQUssb0JBQUw7QUFDQSxtQkFBSyxtQkFBTDtBQUNBLG1CQUFLLG1CQUFMO0FBQ0EsbUJBQUssZUFBTDtBQUNBLG1CQUFLLG1CQUFMO0FBQ0lsRSxvQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1Da0YsSUFBbkM7QUFDQTs7QUFDSixtQkFBSyxpQkFBTDtBQUNJbEUsb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JlLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQ2tGLElBQW5DLEVBQXlDLElBQXpDO0FBQ0E7O0FBQ0osbUJBQUssa0JBQUw7QUFDSSxvQkFBSUssYUFBYSxHQUFHdkUsSUFBSSxDQUFDdEMsVUFBTCxDQUFnQmtDLFlBQWhCLENBQTZCQyxFQUE3QixDQUFnQzJFLFdBQWhDLENBQTRDQyxTQUE1QyxDQUFzRCxRQUF0RCxDQUFwQjtBQUNBRiw2QkFBYSxHQUFHRyxJQUFJLENBQUNDLFNBQUwsQ0FBZUosYUFBZixFQUE4QixJQUE5QixFQUFvQyxDQUFwQyxDQUFoQjtBQUNBdkUsb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JlLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQ2tGLElBQW5DLEVBQXlDSyxhQUF6QztBQUNBOztBQUNKLG1CQUFLLDZCQUFMO0FBQ0lwUCxxQkFBSyxDQUFDckIsVUFBTixDQUFpQmtELGlCQUFqQixDQUFtQyxDQUFDNE4sNEVBQWdCLENBQUNDLEtBQWpCLEVBQUQsQ0FBbkM7QUFDQTdFLG9CQUFJLENBQUN0QyxVQUFMLENBQWdCZSxVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUNrRixJQUFuQztBQUNBOztBQUNKLG1CQUFLLGVBQUw7QUFDSS9PLHFCQUFLLENBQUNyQixVQUFOLENBQWlCdUMsUUFBakIsQ0FBMEIsRUFBMUI7QUFDQTJKLG9CQUFJLENBQUN0QyxVQUFMLENBQWdCZSxVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUNrRixJQUFuQztBQUNBO0FBQ0E7O0FBQ0osbUJBQUssYUFBTDtBQUNJL08scUJBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ3QyxNQUFqQixDQUF3QixFQUF4QjtBQUNBMEosb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JlLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQ2tGLElBQW5DO0FBQ0E7O0FBQ0osbUJBQUssWUFBTDtBQUNJbEUsb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JlLFVBQWhCLENBQTJCcUcsYUFBM0IsQ0FBeUMsWUFBekM7QUFDQTs7QUFDSixtQkFBSyxTQUFMO0FBQ0k5RSxvQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJxRyxhQUEzQixDQUF5QyxTQUF6QztBQUNBOztBQUNKLG1CQUFLLFVBQUw7QUFDSTlFLG9CQUFJLENBQUN0QyxVQUFMLENBQWdCZSxVQUFoQixDQUEyQnFHLGFBQTNCLENBQXlDLFVBQXpDO0FBQ0E7O0FBQ0o7QUF0Q0o7O0FBeUNBM1AsaUJBQUssQ0FBQzBDLE9BQU4sQ0FBY0MsUUFBZCxDQUF1Qm9NLElBQXZCO0FBQ0gsV0FwRUU7QUFxRUgsb0JBQVEsbUJBQVc7QUFDZixtQkFBT2xFLElBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JlLFVBQWhCLENBQTJCc0csVUFBM0IsQ0FBc0M1UCxLQUFLLENBQUMwQyxPQUFOLENBQWNDLFFBQWQsRUFBdEMsQ0FBUDtBQUNILFdBdkVFO0FBd0VIa04sZ0JBQU0sRUFBRSxnQkFBQ0MsT0FBRCxFQUFhO0FBQ2pCLG1CQUFPakYsSUFBSSxDQUFDdEMsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkJ5RyxVQUEzQixDQUFzQy9QLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY0MsUUFBZCxFQUF0QyxFQUFnRW1OLE9BQWhFLENBQVA7QUFDSCxXQTFFRTtBQTJFSEUsd0JBQWMsRUFBRSwwQkFBVztBQUN2QixnQkFBSUMsUUFBUSxHQUFHcEYsSUFBSSxDQUFDdEMsVUFBTCxDQUFnQmUsVUFBaEIsQ0FBMkI0RyxPQUEzQixDQUFtQyxtQkFBbkMsQ0FBZjtBQUNBLGdCQUFJQyxRQUFRLEdBQUd0RixJQUFJLENBQUN0QyxVQUFMLENBQWdCZSxVQUFoQixDQUEyQjRHLE9BQTNCLENBQW1DLG1CQUFuQyxDQUFmO0FBQ0EsZ0JBQUkvTixJQUFJLEdBQUcwSSxJQUFJLENBQUM3SyxLQUFMLENBQVdwQixVQUFYLENBQXNCdUQsSUFBdEIsRUFBWDs7QUFDQSxnQkFBSThOLFFBQVEsSUFBSUEsUUFBUSxDQUFDRyxNQUFyQixJQUErQkgsUUFBUSxDQUFDRyxNQUFULEVBQW5DLEVBQXNEO0FBQ2xEak8sa0JBQUksR0FBRzhOLFFBQVEsQ0FBQ0csTUFBVCxLQUFvQmpPLElBQTNCO0FBQ0g7O0FBQ0QsZ0JBQUlnTyxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsTUFBckIsSUFBK0JELFFBQVEsQ0FBQ0MsTUFBVCxFQUFuQyxFQUFzRDtBQUNsRGpPLGtCQUFJLEdBQUdBLElBQUksR0FBR2dPLFFBQVEsQ0FBQ0MsTUFBVCxFQUFkO0FBQ0g7O0FBQ0QsbUJBQU9qTyxJQUFQO0FBQ0gsV0F0RkU7QUF1RkhrTywyQkFBaUIsRUFBRUMsdUVBQXVCLENBQUN0USxLQUFLLENBQUNwQixVQUFOLENBQWlCd0QsVUFBbEIsQ0F2RnZDO0FBd0ZIaEIsOEJBQW9CLEVBQUVrUCx1RUFBdUIsQ0FBQ3RRLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBbEIsQ0F4RjFDO0FBeUZIRyw0QkFBa0IsRUFBRStPLHVFQUF1QixDQUFDdFEsS0FBSyxDQUFDckIsVUFBTixDQUFpQjRDLGtCQUFsQixDQXpGeEM7QUEwRkhnUCx5QkFBZSxFQUFFLHlCQUFTeEIsSUFBVCxFQUFlO0FBQzVCLGdCQUFJQSxJQUFJLEtBQUssb0JBQWIsRUFBbUM7QUFDL0IscUJBQU8sVUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssaUJBQWIsRUFBZ0M7QUFDNUIscUJBQU8sUUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssbUJBQWIsRUFBa0M7QUFDOUIscUJBQU8sZUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssbUJBQWIsRUFBa0M7QUFDOUIscUJBQU8sZUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssa0JBQWIsRUFBaUM7QUFDN0IscUJBQU8sU0FBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLENBQUN5QixVQUFMLENBQWdCLEdBQWhCLENBQUosRUFBMEI7QUFDdEIscUJBQU96QixJQUFJLENBQUMwQixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0g7O0FBQ0QsbUJBQU8xQixJQUFQO0FBQ0g7QUE5R0UsU0FsUEE7QUFrV1AyQixlQUFPLEVBQUU7QUFDTHhGLGlCQUFPLEVBQUUvSyxFQUFFLENBQUM2SyxZQUFILENBQWlCO0FBQUEsbUJBQ3RCSCxJQUFJLENBQUN0QyxVQUFMLENBQWdCbUksT0FBaEIsQ0FBd0JDLFNBQXhCLENBQWtDM1EsS0FBSyxDQUFDMEMsT0FBTixDQUFjQyxRQUFkLEVBQWxDLENBRHNCO0FBQUEsV0FBakIsQ0FESjtBQUlMaU8sY0FBSSxFQUFFelEsRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUNqQixDQUFDaEwsS0FBSyxDQUFDMEMsT0FBTixDQUFjRSxVQUFkLEVBQUQsSUFBK0I1QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI0TyxXQUExQixFQUFoQyxHQUEyRSxNQUEzRSxHQUNBN1EsS0FBSyxDQUFDMEMsT0FBTixDQUFjQyxRQUFkLEtBQTJCM0MsS0FBSyxDQUFDOEssRUFBTixDQUFTNEYsT0FBVCxDQUFpQnhGLE9BQWpCLEVBQTNCLEdBQXdELE1BRnRDO0FBQUEsV0FBaEIsQ0FKRDtBQVFMRyxlQUFLLEVBQUUsaUJBQVc7QUFDZFIsZ0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCdEQsUUFBdkIsQ0FBZ0MsY0FBaEMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0QsRUFBeEQsRUFBNEQsV0FBNUQ7QUFDQWxGLGlCQUFLLENBQUNwQixVQUFOLENBQWlCdUQsSUFBakIsQ0FBc0JuQyxLQUFLLENBQUNyQixVQUFOLENBQWlCcUMsWUFBakIsRUFBdEI7QUFDQWhCLGlCQUFLLENBQUNwQixVQUFOLENBQWlCd0QsVUFBakIsQ0FBNEJwQyxLQUFLLENBQUNyQixVQUFOLENBQWlCNEMsa0JBQWpCLEdBQXNDdVAsR0FBdEMsQ0FDeEIsVUFBQTdCLElBQUksRUFBSTtBQUNKLGtCQUFJdE0sUUFBUSxHQUFHc00sSUFBSSxDQUFDdE0sUUFBTCxHQUFnQm9PLE1BQWhCLENBQXVCLENBQXZCLENBQWY7QUFDQSxxQkFBT0MsNkRBQWEsQ0FBQ3JPLFFBQUQsRUFBV3NNLElBQUksQ0FBQ2dDLFFBQUwsRUFBWCxDQUFwQjtBQUNILGFBSnVCLENBQTVCO0FBTUgsV0FqQkk7QUFrQkxDLGlCQUFPLEVBQUUvUSxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3JCLENBQUNoTCxLQUFLLENBQUMwQyxPQUFOLENBQWNRLFFBQWQsRUFEb0I7QUFBQSxXQUFoQixDQWxCSjtBQW9CTGlPLG1CQUFTLEVBQUVoUixFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3ZCLENBQUMsQ0FBQ2hMLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjRNLFNBQTFCLEVBQUQsSUFBMEM3TyxLQUFLLENBQUMwQyxPQUFOLENBQWNFLFVBQWQsRUFBM0MsS0FDQXdPLHlEQUFpQixDQUFDQyxPQUFsQixDQUEwQnJSLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY0MsUUFBZCxFQUExQixNQUF3RCxDQUFDLENBRmxDO0FBQUEsV0FBaEIsQ0FwQk47QUF1QkwyTyxtQkFBUyxFQUFFblIsRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUN2QixDQUFDLENBQUNoTCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI0TSxTQUExQixFQUFELElBQTBDN08sS0FBSyxDQUFDMEMsT0FBTixDQUFjRSxVQUFkLEVBQTNDLEtBQ0EyTyx5REFBaUIsQ0FBQ0YsT0FBbEIsQ0FBMEJyUixLQUFLLENBQUMwQyxPQUFOLENBQWNDLFFBQWQsRUFBMUIsTUFBd0QsQ0FBQyxDQUZsQztBQUFBLFdBQWhCLENBdkJOO0FBMEJMNk8sZ0JBQU0sRUFBRXRMLG1FQUFVLENBQUN1TCxJQUFYLENBQWdCNUcsSUFBaEIsQ0ExQkg7QUEyQkw2RyxrQkFBUSxFQUFFMUwscUVBQVksQ0FBQ3lMLElBQWIsQ0FBa0I1RyxJQUFsQixDQTNCTDtBQTRCTDhHLHVCQUFhLEVBQUUseUJBQU07QUFDakI5RyxnQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmdDLE1BQWhCLENBQXVCcUgsVUFBdkI7QUFDSCxXQTlCSTtBQStCTEMsZ0JBQU0sRUFBRTtBQUNKOU4sc0JBQVUsRUFBRSxzQkFBTTtBQUNkLGtCQUFJK04sVUFBVSxHQUFHakgsSUFBSSxDQUFDdEMsVUFBTCxDQUFnQmtDLFlBQWhCLENBQTZCQyxFQUE3QixDQUFnQ21CLFVBQWhDLENBQTJDaUcsVUFBNUQ7QUFDQSxxQkFBT0EsVUFBVSxDQUFDQyxTQUFYLENBQXFCLFlBQXJCLEVBQW1DLENBQUNELFVBQVUsQ0FBQ0UsU0FBWCxDQUFxQixZQUFyQixDQUFwQyxDQUFQO0FBQ0gsYUFKRztBQUtKQyxzQkFBVSxFQUFFLG9CQUFDQyxPQUFELEVBQWE7QUFDckJySCxrQkFBSSxDQUFDdEMsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJ0RCxRQUF2QixDQUFnQyxlQUFoQyxFQUFpRCxFQUFqRCxFQUFxRCxFQUFyRCxFQUF5RGdOLE9BQXpELEVBQWtFbFMsS0FBSyxDQUFDMEMsT0FBTixDQUFjQyxRQUFkLEVBQWxFO0FBQ0EzQyxtQkFBSyxDQUFDMEMsT0FBTixDQUFjSSxVQUFkLENBQXlCb1AsT0FBekI7O0FBQ0Esa0JBQUlsUyxLQUFLLENBQUMwQyxPQUFOLENBQWNDLFFBQWQsT0FBNkIsV0FBakMsRUFBOEM7QUFDMUNrSSxvQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmtDLFlBQWhCLENBQTZCMEgsYUFBN0IsR0FBNkNELE9BQTdDO0FBQ0g7QUFDSixhQVhHO0FBWUpFLDhCQUFrQixFQUFFalMsRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLHFCQUNoQ2hMLEtBQUssQ0FBQzhLLEVBQU4sQ0FBU3RDLE1BQVQsQ0FBZ0I2SixtQkFBaEIsQ0FBb0MsYUFBcEMsQ0FEZ0M7QUFBQSxhQUFoQixDQVpoQjtBQWNKQyw4QkFBa0IsRUFBRSw4QkFBTTtBQUN0QnpILGtCQUFJLENBQUN0QyxVQUFMLENBQWdCa0MsWUFBaEIsQ0FBNkI4SCxZQUE3QjtBQUNBMUgsa0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JrQyxZQUFoQixDQUE2QitILFdBQTdCLENBQXlDLEtBQXpDO0FBQ0F4UyxtQkFBSyxDQUFDMEMsT0FBTixDQUFjTyxXQUFkLENBQTBCLEtBQTFCO0FBQ0gsYUFsQkc7QUFtQkp3UCw2QkFBaUIsRUFBRSw2QkFBTTtBQUNyQjVILGtCQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFdBQXZCLENBQW1DLFVBQUM4TixRQUFELEVBQWE7QUFDNUMsb0JBQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQjlILHNCQUFJLENBQUN0QyxVQUFMLENBQWdCcUssT0FBaEIsQ0FBd0JDLElBQXhCLENBQTZCSCxRQUFRLENBQUNFLE9BQXRDO0FBQ0E1Uyx1QkFBSyxDQUFDMEMsT0FBTixDQUFjTyxXQUFkLENBQTBCLElBQTFCO0FBQ0E0SCxzQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmtDLFlBQWhCLENBQTZCK0gsV0FBN0IsQ0FBeUMsSUFBekM7QUFDSCxpQkFKRCxNQUlPO0FBQ0gzSCxzQkFBSSxDQUFDdEMsVUFBTCxDQUFnQm1ELE1BQWhCLENBQXVCb0gscUJBQXZCO0FBQ0g7QUFDSixlQVJEO0FBU0gsYUE3Qkc7QUE4QkpDLDZCQUFpQixFQUFFLDZCQUFNO0FBQ3JCLGtCQUFJL1MsS0FBSyxDQUFDMEMsT0FBTixDQUFjTyxXQUFkLEVBQUosRUFBaUM7QUFDN0JqRCxxQkFBSyxDQUFDOEssRUFBTixDQUFTNEYsT0FBVCxDQUFpQm1CLE1BQWpCLENBQXdCUyxrQkFBeEI7QUFDSCxlQUZELE1BRU87QUFDSHRTLHFCQUFLLENBQUM4SyxFQUFOLENBQVM0RixPQUFULENBQWlCbUIsTUFBakIsQ0FBd0JZLGlCQUF4QjtBQUNIO0FBQ0osYUFwQ0c7QUFxQ0pHLG1CQUFPLEVBQUU7QUFDTHBULG1CQUFLLEVBQUUsaUJBQUk7QUFBRXFMLG9CQUFJLENBQUN0QyxVQUFMLENBQWdCcUssT0FBaEIsQ0FBd0JJLFdBQXhCO0FBQXdDLGVBRGhEO0FBRUw1RSxzQkFBUSxFQUFFLG9CQUFJO0FBQUV2RCxvQkFBSSxDQUFDdEMsVUFBTCxDQUFnQnFLLE9BQWhCLENBQXdCSyxZQUF4QjtBQUF5QyxlQUZwRDtBQUdMekUsa0JBQUksRUFBRSxnQkFBSTtBQUFFM0Qsb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JxSyxPQUFoQixDQUF3Qk0sUUFBeEI7QUFBcUMsZUFINUM7QUFJTEMsd0JBQVUsRUFBRSxzQkFBSTtBQUFFdEksb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JxSyxPQUFoQixDQUF3QlEsZ0JBQXhCO0FBQTZDLGVBSjFEO0FBS0xDLGlCQUFHLEVBQUUsZUFBSTtBQUFFeEksb0JBQUksQ0FBQ3RDLFVBQUwsQ0FBZ0JxSyxPQUFoQixDQUF3QlMsR0FBeEI7QUFBZ0M7QUFMdEM7QUFyQ0wsV0EvQkg7QUE0RUxDLGdCQUFNLEVBQUU7QUFDSkMsd0JBQVksRUFBRTtBQUFBLHFCQUFNMUksSUFBSSxDQUFDdEMsVUFBTCxDQUFnQm1JLE9BQWhCLENBQXdCOEMsTUFBeEIsQ0FBK0IsT0FBL0IsRUFBd0NELFlBQXhDLEVBQU47QUFBQTtBQURWLFdBNUVIO0FBK0VMdFIsa0JBQVEsRUFBRTtBQUNOd1IsZ0JBQUksRUFBRTtBQUFBLHFCQUFNNUksSUFBSSxDQUFDdEMsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJoRCxjQUF2QixFQUFOO0FBQUE7QUFEQSxXQS9FTDtBQWtGTDNELDJCQUFpQixFQUFFO0FBQ2Y2Uix1QkFBVyxFQUFFLHFCQUFDQyxNQUFELEVBQVNDLEtBQVQsRUFBZ0JDLFVBQWhCLEVBQStCO0FBQ3hDLGtCQUFJQyxNQUFNLEdBQUdqSixJQUFJLENBQUN0QyxVQUFMLENBQWdCbUksT0FBaEIsQ0FBd0I4QyxNQUF4QixDQUErQixvQkFBL0IsQ0FBYjtBQUNBTSxvQkFBTSxDQUFDSixXQUFQLENBQW1CQyxNQUFuQixFQUEyQkMsS0FBM0IsRUFBa0NDLFVBQWxDO0FBQ0g7QUFKYztBQWxGZCxTQWxXRjtBQTJiUEUsZUFBTyxFQUFFO0FBQ0xDLG1CQUFTLEVBQUU3VCxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3ZCaEwsS0FBSyxDQUFDdUUsTUFBTixDQUFhNkIsV0FBYixPQUErQjNCLHFEQUFXLENBQUNtSixNQURwQjtBQUFBLFdBQWhCLENBRE47QUFJTHFHLGtCQUFRLEVBQUU5VCxFQUFFLENBQUM2SyxZQUFILENBQWdCO0FBQUEsbUJBQ3RCaEwsS0FBSyxDQUFDdUUsTUFBTixDQUFhNkIsV0FBYixPQUErQjNCLHFEQUFXLENBQUNtSixNQUEzQyxHQUFvRCxNQUFwRCxHQUE2RCxLQUR2QztBQUFBLFdBQWhCLENBSkw7QUFPTHNHLGFBQUcsRUFBRSxlQUFNO0FBQ1AsZ0JBQUlsVSxLQUFLLENBQUN1RSxNQUFOLENBQWE2QixXQUFiLE9BQStCM0IscURBQVcsQ0FBQ21KLE1BQS9DLEVBQXVEO0FBQ25ELGtCQUFJLE9BQU91RyxTQUFQLEtBQXFCLFdBQXJCLElBQW9DQSxTQUFTLENBQUNDLE9BQWxELEVBQTJEO0FBQ3ZERCx5QkFBUyxDQUFDRSxVQUFWO0FBQ0g7O0FBQ0RyVSxtQkFBSyxDQUFDdUUsTUFBTixDQUFhNkIsV0FBYixDQUF5QjNCLHFEQUFXLENBQUNDLEtBQXJDO0FBQ0gsYUFMRCxNQUtPO0FBQ0htRyxrQkFBSSxDQUFDdEMsVUFBTCxDQUFnQmdFLE1BQWhCLENBQXVCQyxVQUF2QjtBQUNIO0FBQ0osV0FoQkk7QUFpQkw4SCxrQkFBUSxFQUFFO0FBQUEsbUJBQ056SixJQUFJLENBQUN0QyxVQUFMLENBQWdCZ0UsTUFBaEIsQ0FBdUIrSCxRQUF2QixFQURNO0FBQUE7QUFqQkwsU0EzYkY7QUErY1A5TCxjQUFNLEVBQUU7QUFDSmpFLGdCQUFNLEVBQUcsZ0JBQUFsQyxRQUFRO0FBQUEsbUJBQ2IsbUJBQW1CckMsS0FBSyxDQUFDdUUsTUFBTixDQUFhbEMsUUFBYixHQUROO0FBQUEsV0FEYjtBQUlKZ1EsNkJBQW1CLEVBQUUsNkJBQUNoUSxRQUFEO0FBQUEsbUJBQ2pCckMsS0FBSyxDQUFDdEIsYUFBTixDQUFvQmtKLGVBQXBCLE1BQ0E1SCxLQUFLLENBQUN0QixhQUFOLENBQW9Cc0osSUFBcEIsS0FBNkJsSixTQUQ3QixJQUVBa0IsS0FBSyxDQUFDdEIsYUFBTixDQUFvQnNKLElBQXBCLENBQXlCM0YsUUFBekIsTUFBdUN2RCxTQUh0QjtBQUFBLFdBSmpCO0FBUUp5VixrQkFBUSxFQUFFcFUsRUFBRSxDQUFDNkssWUFBSCxDQUFnQjtBQUFBLG1CQUN0QndKLDhEQUFVLENBQUN4VSxLQUFLLENBQUN1RSxNQUFOLENBQWFJLHFCQUFiLE1BQ1AzRSxLQUFLLENBQUN1RSxNQUFOLENBQWFrQixxQkFBYixFQURPLElBRVB6RixLQUFLLENBQUN1RSxNQUFOLENBQWFNLGtCQUFiLEVBRk8sSUFHUDdFLEtBQUssQ0FBQ3VFLE1BQU4sQ0FBYVEsZUFBYixFQUhPLElBSVAvRSxLQUFLLENBQUN1RSxNQUFOLENBQWFnQixlQUFiLEVBSk8sSUFLUHZGLEtBQUssQ0FBQ3VFLE1BQU4sQ0FBYVUsa0JBQWIsRUFMTyxJQU1QakYsS0FBSyxDQUFDdUUsTUFBTixDQUFhWSxlQUFiLEVBTk8sSUFPUG5GLEtBQUssQ0FBQ3VFLE1BQU4sQ0FBYWEsU0FBYixFQVBPLElBUVBwRixLQUFLLENBQUN1RSxNQUFOLENBQWFvQix1QkFBYixFQVJPLElBU1AzRixLQUFLLENBQUN1RSxNQUFOLENBQWFzQiw2QkFBYixFQVRPLElBU3lDLEVBVDFDLENBRFk7QUFBQSxXQUFoQixDQVJOO0FBb0JKNE8sZUFBSyxFQUFFO0FBQ0hqUSwwQkFBYyxFQUFFLHdCQUFDMEUsSUFBRCxFQUFPd0wsS0FBUCxFQUFpQjtBQUM3QjtBQUNBLGtCQUFJQyx5QkFBeUIsR0FBR3ZNLDZDQUFDLENBQUNzTSxLQUFLLENBQUNFLE1BQVAsQ0FBakMsQ0FGNkIsQ0FHN0I7O0FBQ0F4TSwyREFBQyxDQUFDc00sS0FBSyxDQUFDRSxNQUFQLENBQUQsQ0FBZ0JDLE1BQWhCLEdBQXlCQyxPQUF6QixDQUFpQyxHQUFqQyxFQUFzQ0MsTUFBdEMsQ0FBNkMsR0FBN0MsRUFKNkIsQ0FLN0I7O0FBQ0Esa0JBQUlDLEVBQUUsR0FBRyxJQUFJQyxVQUFKLEVBQVQ7QUFDQSxrQkFBSXRHLEtBQUssR0FBR2dHLHlCQUF5QixDQUFDLENBQUQsQ0FBekIsQ0FBNkJoRyxLQUF6Qzs7QUFDQXFHLGdCQUFFLENBQUNFLE1BQUgsR0FBWSxVQUFTQyxDQUFULEVBQVk7QUFDcEIsb0JBQUlDLG9CQUFvQixHQUFHN0YsSUFBSSxDQUFDOEYsS0FBTCxDQUFXRixDQUFDLENBQUNQLE1BQUYsQ0FBU1UsTUFBcEIsQ0FBM0I7QUFDQXpLLG9CQUFJLENBQUMwSyxtQkFBTCxDQUF5Qkgsb0JBQXpCO0FBQ0gsZUFIRDs7QUFJQUosZ0JBQUUsQ0FBQ1EsUUFBSCxHQUFjN0csS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTdE8sSUFBdkI7QUFDQTJVLGdCQUFFLENBQUNTLFVBQUgsQ0FBYzlHLEtBQUssQ0FBQyxDQUFELENBQW5CO0FBQ0FnRyx1Q0FBeUIsQ0FBQ2UsR0FBMUIsQ0FBOEIsRUFBOUI7QUFDSCxhQWhCRTtBQWlCSGhRLDRCQUFnQixFQUFFLDBCQUFDd0QsSUFBRCxFQUFPd0wsS0FBUCxFQUFpQjtBQUMvQnZMLHFCQUFPLENBQUNDLEdBQVIsQ0FBWXNMLEtBQVo7QUFDQTdKLGtCQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjlDLGdCQUF2QixDQUF3Q21GLElBQUksQ0FBQzdLLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IwRCxLQUF0QixFQUF4QyxFQUN3Q3VJLElBQUksQ0FBQzdLLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IyRCxPQUF0QixFQUR4QyxFQUV3QyxLQUZ4QyxFQUUrQyxJQUYvQztBQUdBNkYsMkRBQUMsQ0FBQ3NNLEtBQUssQ0FBQ0UsTUFBUCxDQUFELENBQWdCRSxPQUFoQixDQUF3QixHQUF4QixFQUE2QkMsTUFBN0IsQ0FBb0MsR0FBcEM7QUFDSDtBQXZCRTtBQXBCSDtBQS9jRCxPQUFYO0FBOGZBWSwwRkFBK0IsQ0FBQzlLLElBQUQsRUFBTzdLLEtBQVAsQ0FBL0I7QUFDSDtBQXA3Qkw7QUFBQTtBQUFBLGtDQXM3QmtCO0FBQ1Y7QUFDQTRWLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQmxILEtBQWhCLENBQXNCLGtCQUF0QixJQUE0Q21ILG1FQUFXLENBQUN6UixRQUFaLEVBQTVDLENBRlUsQ0FHVjtBQUNBO0FBQ0g7QUFFRDs7Ozs7QUE3N0JKO0FBQUE7QUFBQSxpQ0FpOEJpQjtBQUNUbEUsUUFBRSxDQUFDNFYsYUFBSCxDQUFpQixLQUFLL1YsS0FBdEIsRUFBNkIsS0FBS0EsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QnFKLFNBQXpCLENBQW1DLENBQW5DLENBQTdCO0FBQ0g7QUFuOEJMO0FBQUE7QUFBQSxvQ0FxOEJvQjtBQUNaLFVBQUlpTyxJQUFJLEdBQUcsSUFBWDtBQUNBLFdBQUs3SyxTQUFMLEdBQWlCO0FBQ2JDLGdCQUFRLEVBQUUsa0JBQUM2SyxJQUFEO0FBQUEsaUJBQVVBLElBQUksR0FBR0MsT0FBTyxDQUFDQyxTQUFSLENBQWtCL0ssUUFBbEIsQ0FBMkI2SyxJQUEzQixDQUFILEdBQXNDLFNBQXBEO0FBQUE7QUFERyxPQUFqQjtBQUdIO0FBMThCTDtBQUFBO0FBQUEscUNBNDhCcUI7QUFDYixVQUFJbE8sU0FBUyxHQUFHLEtBQUsvSCxLQUFMLENBQVd0QixhQUFYLENBQXlCcUosU0FBekM7QUFDQSxVQUFJUSxVQUFVLEdBQUcsS0FBS0EsVUFBTCxHQUFrQixFQUFuQztBQUNBLFVBQUl5TixJQUFJLEdBQUcsSUFBWCxDQUhhLENBSWI7QUFDQTs7QUFDQXpOLGdCQUFVLENBQUNtRCxNQUFYLEdBQW9CLElBQUkwSyxzREFBSixDQUFrQkosSUFBbEIsRUFBd0JqTyxTQUFTLENBQUNzTyxJQUFWLENBQWUsaUJBQWYsQ0FBeEIsQ0FBcEI7QUFDQTlOLGdCQUFVLENBQUNsQixRQUFYLEdBQXNCLElBQUlpUCw0REFBSixDQUFvQk4sSUFBcEIsRUFBMEJqTyxTQUFTLENBQUNzTyxJQUFWLENBQWUsbUJBQWYsQ0FBMUIsQ0FBdEI7QUFDQTlOLGdCQUFVLENBQUN1RixLQUFYLEdBQW1CLElBQUl5SSxvREFBSixDQUFpQlAsSUFBakIsQ0FBbkI7QUFDQXpOLGdCQUFVLENBQUNZLE9BQVgsR0FBcUIsSUFBSXFOLHdEQUFKLENBQW1CUixJQUFuQixFQUF5QmpPLFNBQVMsQ0FBQ3NPLElBQVYsQ0FBZSxrQkFBZixDQUF6QixDQUFyQjtBQUNBOU4sZ0JBQVUsQ0FBQ2dFLE1BQVgsR0FBb0IsSUFBSWtLLHdEQUFKLENBQWtCVCxJQUFsQixDQUFwQjtBQUNBek4sZ0JBQVUsQ0FBQ2UsVUFBWCxHQUF3QixJQUFJb04seURBQUosQ0FBc0JWLElBQXRCLENBQXhCO0FBQ0F6TixnQkFBVSxDQUFDbUksT0FBWCxHQUFxQixJQUFJaUcsa0RBQUosQ0FBWVgsSUFBWixFQUFrQmpPLFNBQVMsQ0FBQ3NPLElBQVYsQ0FBZSxpQkFBZixDQUFsQixDQUFyQixDQVphLENBYWI7O0FBQ0E5TixnQkFBVSxDQUFDa0MsWUFBWCxHQUEwQixLQUFLbEMsVUFBTCxDQUFnQm1JLE9BQWhCLENBQXdCOEMsTUFBeEIsQ0FBK0IsUUFBL0IsQ0FBMUI7QUFDQWpMLGdCQUFVLENBQUNDLE1BQVgsR0FBb0IsSUFBSW9PLHVEQUFKLENBQWtCWixJQUFsQixDQUFwQjtBQUNBek4sZ0JBQVUsQ0FBQ2dDLE1BQVgsR0FBb0IsSUFBSXNNLHNEQUFKLENBQWtCYixJQUFsQixDQUFwQjtBQUNBek4sZ0JBQVUsQ0FBQ3FLLE9BQVgsR0FBcUIsSUFBSWtFLHdEQUFKLENBQW1CZCxJQUFuQixFQUF5QmpPLFNBQVMsQ0FBQ3NPLElBQVYsQ0FBZSwwQkFBZixDQUF6QixDQUFyQjtBQUNIO0FBOTlCTDtBQUFBO0FBQUEsMkJBZytCVztBQUNILFdBQUtyVyxLQUFMLENBQVd0QixhQUFYLENBQXlCcUosU0FBekIsQ0FBbUNnUCxJQUFuQztBQUNIO0FBbCtCTDtBQUFBO0FBQUEsMkJBbytCVztBQUNILFdBQUsvVyxLQUFMLENBQVd0QixhQUFYLENBQXlCcUosU0FBekIsQ0FBbUNpUCxJQUFuQztBQUNIO0FBdCtCTDtBQUFBO0FBQUEsNkNBdytCNkI7QUFBQTs7QUFDckIsV0FBS2hYLEtBQUwsQ0FBVzBDLE9BQVgsQ0FBbUJrQixtQkFBbkIsQ0FBdUNxVCxTQUF2QyxDQUFpRCxVQUFDQyxPQUFELEVBQWE7QUFDMUQsY0FBSSxDQUFDM08sVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJ0RCxRQUF2QixDQUFnQyx1QkFBaEMsRUFBeUQsRUFBekQsRUFBNkQsRUFBN0QsRUFDZ0NnUyxPQURoQyxFQUN5QyxpQkFEekM7QUFFSCxPQUhEO0FBSUg7QUE3K0JMO0FBQUE7QUFBQSw0QkErK0JZO0FBQ0osV0FBS2xYLEtBQUwsQ0FBVzBDLE9BQVgsQ0FBbUJDLFFBQW5CLENBQTRCLFdBQTVCO0FBQ0g7QUFqL0JMO0FBQUE7QUFBQSxxQ0FtL0JxQjtBQUNiLFdBQUs0RixVQUFMLENBQWdCZ0UsTUFBaEIsQ0FBdUJsQixLQUF2QixHQURhLENBRWI7O0FBQ0EsV0FBSzlDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCMk8sV0FBdkIsR0FBcUMsSUFBckM7QUFDSDtBQXYvQkw7QUFBQTtBQUFBLHNDQXkvQnNCO0FBQ2QsVUFBSUMsb0JBQW9CLEdBQUdDLE1BQU0sQ0FBQyw0QkFBRCxDQUFqQztBQUNBLFdBQUtyWCxLQUFMLENBQVcwQyxPQUFYLENBQW1Cc0IsUUFBbkIsQ0FBNEJvVCxvQkFBNUI7QUFDSDtBQTUvQkw7O0FBQUE7QUFBQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbERBO0FBRUE7Ozs7O0FBSUEsSUFBTUUsZUFBZSxzSEFBckI7QUFLQTs7Ozs7QUFJQSxJQUFNQyxxQkFBcUIsR0FBRyxhQUE5QjtBQUVBOzs7OztBQUlPLElBQU1DLFlBQVksd3FCQUFsQjtBQW1CUDs7Ozs7QUFJTyxJQUFJQyxlQUFlLEdBQUc7QUFDekJDLE1BQUksRUFBRSxNQURtQjtBQUV6QkMsTUFBSSxFQUFFLE1BRm1CO0FBR3pCQyxNQUFJLEVBQUUsTUFIbUI7QUFJekJDLE9BQUssRUFBRSxPQUprQjtBQUt6QkMsUUFBTSxFQUFFLFFBTGlCO0FBTXpCQyxRQUFNLEVBQUUsUUFOaUI7QUFPekJDLE1BQUksRUFBRSxNQVBtQjtBQVF6QkMsWUFBVSxFQUFFLFlBUmE7QUFTekJDLE9BQUssRUFBRSxPQVRrQjtBQVV6QkMsT0FBSyxFQUFFLE9BVmtCO0FBV3pCQyxXQUFTLEVBQUU7QUFYYyxDQUF0QjtBQWNQOzs7OztJQUlNQyxXO0FBQ0YsdUJBQVlyQyxJQUFaLEVBQWtCcFYsSUFBbEIsRUFBd0IwWCxPQUF4QixFQUFpQztBQUFBOztBQUM3Qjs7Ozs7QUFLQSxTQUFLdEMsSUFBTCxHQUFZQSxJQUFaO0FBQ0E7Ozs7O0FBSUEsU0FBS3BWLElBQUwsR0FBWUEsSUFBWjtBQUNBOzs7OztBQUlBLFNBQUswWCxPQUFMLEdBQWVBLE9BQWY7QUFDQTs7Ozs7QUFJQSxTQUFLQyxNQUFMLEdBQWM7QUFDVjVWLGNBQVEsRUFBRWlULEVBQUUsQ0FBQzRDLFlBREg7QUFFVnhLLFVBQUksRUFBRWdJLElBQUksQ0FBQ3pOLFVBQUwsQ0FBZ0JnRSxNQUFoQixDQUF1QmtNLGVBQXZCLENBQXVDekssSUFGbkM7QUFHVkQsVUFBSSxFQUFFaUksSUFBSSxDQUFDek4sVUFBTCxDQUFnQmdFLE1BQWhCLENBQXVCa00sZUFBdkIsQ0FBdUMxSztBQUhuQyxLQUFkO0FBS0E7Ozs7OztBQUtBLFNBQUsxRixJQUFMLEdBQVlELENBQUMsQ0FBQyxhQUFELEVBQWdCO0FBQ3pCLGVBQVUsd0JBRGU7QUFFekIsd0JBQWtCNE4sSUFBSSxDQUFDaFcsS0FBTCxDQUFXdEIsYUFBWCxDQUF5Qm9KLGVBRmxCO0FBR3pCLHFCQUFlLFNBSFU7QUFJekIsd0JBQWtCLE1BSk87QUFLekIsbUJBQWEsS0FBS3lRLE1BQUwsQ0FBWXZLLElBTEE7QUFNekIsZUFBUyxVQUFVLEtBQUt1SyxNQUFMLENBQVl2SyxJQUF0QixHQUE2QixTQUE3QixHQUF5QyxLQUFLdUssTUFBTCxDQUFZeEs7QUFOckMsS0FBaEIsQ0FBYjtBQVFBOzs7OztBQUlBLFNBQUthLE9BQUwsR0FBZSxDQUFDb0gsSUFBSSxDQUFDaFcsS0FBTCxDQUFXMEMsT0FBWCxDQUFtQkcsV0FBbkIsRUFBaEI7QUFDQTs7Ozs7QUFJQSxTQUFLK1EsS0FBTCxHQUFhLENBQWI7QUFDSDtBQUVEOzs7Ozs7OzsrQkFJVztBQUNQLGFBQU9nQyxFQUFFLENBQUM4QyxHQUFILENBQU9DLFNBQVAsQ0FBaUIsS0FBS0wsT0FBdEIsQ0FBUDtBQUNIO0FBRUQ7Ozs7Ozs4QkFHUztBQUNMLFdBQUtqUSxJQUFMLENBQVV1USxNQUFWO0FBQ0g7Ozs7OztJQUdDQyxpQjs7Ozs7QUFDRjtBQUNBLDZCQUFZN0MsSUFBWixFQUFrQjtBQUFBOztBQUFBOztBQUNkLDhCQUFNQSxJQUFOLEVBQVl5QixlQUFlLENBQUNNLE1BQTVCOztBQUNBLFVBQUsxUCxJQUFMLENBQVV5USxRQUFWLENBQW1CLCtCQUFuQjs7QUFGYztBQUdqQjs7OzsyQkFFTUMsSyxFQUFPO0FBQ1YsVUFBSSxLQUFLbkssT0FBVCxFQUFrQjtBQUNkbUssYUFBSyxDQUFDQyxPQUFOLENBQWMsS0FBSzNRLElBQW5CLEVBRGMsQ0FFZDs7QUFDQSxZQUFJNFEsR0FBRyxHQUFHLEtBQUs1USxJQUFMLENBQVU2USxRQUFWLEdBQXFCRCxHQUEvQixDQUhjLENBSWQ7O0FBQ0E3USxTQUFDLENBQUMsTUFBRCxDQUFELENBQVUrUSxTQUFWLENBQW9CLENBQXBCLEVBTGMsQ0FNZDtBQUNIO0FBQ0o7Ozs7RUFoQjJCZCxXOztJQW1CMUJlLGlCOzs7OztBQUNGLDZCQUFZcEQsSUFBWixFQUFrQnRJLElBQWxCLEVBQXdCM0osVUFBeEIsRUFBb0NzVixTQUFwQyxFQUErQztBQUFBOztBQUFBOztBQUMzQyxnQ0FBTXJELElBQU4sRUFBWXlCLGVBQWUsQ0FBQ0ssTUFBNUI7O0FBQ0EsV0FBS3pQLElBQUwsQ0FBVXlRLFFBQVYsQ0FBbUIsK0JBQW5COztBQUNBLFdBQUtwTCxJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLM0osVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxXQUFLc1YsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxXQUFLQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsV0FBS0MsTUFBTCxHQUFjQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZCxDQVAyQyxDQVEzQzs7QUFSMkM7QUFTOUM7Ozs7MkJBRU1WLEssRUFBTztBQUNWLFVBQUksS0FBS25LLE9BQVQsRUFBa0I7QUFDZCxhQUFLdkcsSUFBTCxDQUFVcVIsTUFBVixDQUFpQixLQUFLSCxNQUF0QjtBQUNBUixhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLM1EsSUFBbkI7QUFDQSxZQUFJNFEsR0FBRyxHQUFHLEtBQUs1USxJQUFMLENBQVU2USxRQUFWLEdBQXFCRCxHQUEvQjtBQUNBN1EsU0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVK1EsU0FBVixDQUFvQixDQUFwQjtBQUNIO0FBQ0o7Ozs4QkFFUyxDQUNOO0FBQ0g7OzsyQkFFTTtBQUNILFdBQUtRLE9BQUwsR0FBZSxZQUFNLENBQUUsQ0FBdkI7O0FBQ0EsV0FBSzNELElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0I4SyxFQUFoQixDQUFtQjhCLFNBQW5CLENBQTZCWSxZQUE3QjtBQUNIOzs7NkJBRVFvTSxlLEVBQWlCQyxTLEVBQVc7QUFBQTs7QUFDakMsV0FBS1AsV0FBTCxHQUFtQixJQUFuQjs7QUFDQSxXQUFLSyxPQUFMLEdBQWU7QUFBQSxlQUFNQyxlQUFlLENBQUMsTUFBSSxDQUFDUCxTQUFOLEVBQWlCUSxTQUFqQixDQUFyQjtBQUFBLE9BQWY7QUFDSDs7OztFQWpDMkJ4QixXOztJQXFDMUJ5QixnQjs7Ozs7QUFDRiw0QkFBWTlELElBQVosRUFBa0JzQyxPQUFsQixFQUEyQjtBQUFBOztBQUFBOztBQUN2QixnQ0FBTXRDLElBQU4sRUFBWXlCLGVBQWUsQ0FBQ0ksS0FBNUIsRUFBbUNTLE9BQW5DOztBQUNBLFdBQUtqUSxJQUFMLENBQVV5USxRQUFWLENBQW1CLDhCQUFuQjs7QUFGdUI7QUFHMUI7Ozs7MkJBRU1DLEssRUFBTztBQUNWLFVBQUksS0FBS25LLE9BQVQsRUFBa0I7QUFDZHpGLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUtrUCxPQUFqQjtBQUNBLGFBQUtqUSxJQUFMLENBQVVxUixNQUFWLENBQWlCLEtBQUtwQixPQUF0QjtBQUNBUyxhQUFLLENBQUNXLE1BQU4sQ0FBYSxLQUFLclIsSUFBbEIsRUFIYyxDQUlkO0FBQ0g7QUFDSjs7OztFQWIwQmdRLFc7O0lBZ0J6QjBCLGU7Ozs7O0FBQ0YsMkJBQVkvRCxJQUFaLEVBQWtCc0MsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQTs7QUFDdkIsZ0NBQU10QyxJQUFOLEVBQVl5QixlQUFlLENBQUNHLElBQTVCLEVBQWtDVSxPQUFsQzs7QUFDQSxXQUFLalEsSUFBTCxDQUFVeVEsUUFBVixDQUFtQiw2QkFBbkI7O0FBRnVCO0FBRzFCOzs7OzJCQUVNQyxLLEVBQU87QUFDVixVQUFJLEtBQUtuSyxPQUFULEVBQWtCO0FBQ2RtSyxhQUFLLENBQUNXLE1BQU4sQ0FBYSxLQUFLclIsSUFBbEIsRUFEYyxDQUVkO0FBQ0g7QUFDSjs7OztFQVh5QmdRLFc7O0lBY3hCMkIsZTs7Ozs7Ozs7Ozs7OzsrQkFFUzFCLE8sRUFBUztBQUNoQixXQUFLQSxPQUFMLEdBQWUsS0FBS0EsT0FBTCxHQUFlQSxPQUE5QjtBQUNIOzs7MkJBRU1TLEssRUFBTztBQUNWLFVBQUksS0FBS25LLE9BQVQsRUFBa0I7QUFDZCxZQUFJcUwsV0FBVyxHQUFHQyw2REFBVSxDQUFDLEtBQUs1QixPQUFOLENBQTVCOztBQUNBLFlBQUksQ0FBQzJCLFdBQUQsSUFBZ0JBLFdBQVcsQ0FBQ0UsSUFBWixHQUFtQmpMLE1BQW5CLElBQTZCLENBQWpELEVBQW9EO0FBQ2hEK0sscUJBQVcsR0FBRyxJQUFkO0FBQ0g7O0FBQ0QsWUFBSUcsUUFBUSxHQUFHaFMsQ0FBQyxDQUFDLGVBQUQsRUFBa0I7QUFBRSxrQkFBUTZSO0FBQVYsU0FBbEIsQ0FBaEI7QUFDQSxhQUFLNVIsSUFBTCxDQUFVcVIsTUFBVixDQUFpQlUsUUFBakI7QUFDQXJCLGFBQUssQ0FBQ1csTUFBTixDQUFhLEtBQUtyUixJQUFsQjtBQUNBLGFBQUtBLElBQUwsQ0FBVWdTLE9BQVY7QUFDSDtBQUNKOzs7O0VBakJ5QmhDLFc7O0lBb0J4QmlDLGdCOzs7OztBQUVGLDRCQUFZdEUsSUFBWixFQUFrQnNDLE9BQWxCLEVBQTJCO0FBQUE7O0FBQUEsOEJBQ2pCdEMsSUFEaUIsRUFDWHlCLGVBQWUsQ0FBQ1MsS0FETCxFQUNZSSxPQURaO0FBRTFCOzs7OzJCQUVNUyxLLEVBQU87QUFDVixVQUFJLEtBQUtuSyxPQUFULEVBQWtCO0FBQ2QsWUFBSXFMLFdBQVcsR0FBR0MsNkRBQVUsQ0FBQyxLQUFLNUIsT0FBTixDQUE1QjtBQUNBLFlBQUk4QixRQUFRLEdBQUdoUyxDQUFDLENBQUMsZUFBRCxFQUFrQjtBQUFFLGtCQUFRNlI7QUFBVixTQUFsQixDQUFoQjtBQUNBLGFBQUs1UixJQUFMLENBQVVxUixNQUFWLENBQWlCVSxRQUFqQjtBQUNBckIsYUFBSyxDQUFDVyxNQUFOLENBQWEsS0FBS3JSLElBQWxCO0FBQ0EsYUFBS0EsSUFBTCxDQUFVZ1MsT0FBVjtBQUNIO0FBQ0o7Ozs7RUFkMEJoQyxXOztJQWlCekJrQyxnQjs7Ozs7QUFDRiw0QkFBWXZFLElBQVosRUFBa0J3RSxhQUFsQixFQUFpQztBQUFBOztBQUFBOztBQUM3QixnQ0FBTXhFLElBQU4sRUFBWXlCLGVBQWUsQ0FBQ1UsS0FBNUIsRUFBbUNxQyxhQUFuQztBQUNBLFdBQUs1TCxPQUFMLEdBQWUsSUFBZjtBQUY2QjtBQUdoQztBQUVEOzs7Ozs7OzsyQkFJT21LLEssRUFBTztBQUNWO0FBQ0EsVUFBSSxLQUFLbkssT0FBVCxFQUFrQjtBQUNkO0FBQ0EsWUFBSTZMLFNBQVMsR0FBR3JTLENBQUMsQ0FBQyx1QkFBRCxDQUFqQixDQUZjLENBR2Q7O0FBQ0EsWUFBSXNTLFFBQVEsR0FBR3RTLENBQUMsQ0FBQyxtQkFBRCxFQUFzQjtBQUFDLGtCQUFRO0FBQVQsU0FBdEIsQ0FBaEIsQ0FKYyxDQUtkOztBQUNBLFlBQUl1UyxVQUFVLEdBQUd2UyxDQUFDLENBQUMsYUFBRCxFQUFnQjtBQUFDLG1CQUFTO0FBQVYsU0FBaEIsQ0FBbEI7QUFDQXVTLGtCQUFVLENBQUNqQixNQUFYLENBQWtCZSxTQUFsQjtBQUNBRSxrQkFBVSxDQUFDakIsTUFBWCxDQUFrQmdCLFFBQWxCLEVBUmMsQ0FTZDs7QUFDQSxZQUFJRSxRQUFRLEdBQUd4UyxDQUFDLENBQUMsYUFBRCxDQUFoQjs7QUFDQSxZQUFJLEtBQUtrUSxPQUFMLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCLGNBQUkyQixXQUFXLEdBQUdDLDZEQUFVLENBQUMsS0FBSzVCLE9BQU4sQ0FBNUI7QUFDQSxjQUFJdUMsUUFBUSxHQUFHelMsQ0FBQyxDQUFDLGVBQUQsRUFBbUI7QUFBQyxvQkFBUTZSO0FBQVQsV0FBbkIsQ0FBaEI7QUFDQVcsa0JBQVEsQ0FBQ2xCLE1BQVQsQ0FBZ0JtQixRQUFoQjtBQUNIOztBQUNERCxnQkFBUSxDQUFDbEIsTUFBVCxDQUFnQnRSLENBQUMsQ0FBQyxNQUFELENBQWpCLEVBQ0tzUixNQURMLENBQ1lpQixVQURaLEVBaEJjLENBa0JkOztBQUNBLGFBQUt0UyxJQUFMLENBQVVxUixNQUFWLENBQWlCa0IsUUFBakI7QUFDQTdCLGFBQUssQ0FBQ1csTUFBTixDQUFhLEtBQUtyUixJQUFsQixFQXBCYyxDQXFCZDs7QUFDQSxlQUFPLEtBQUt5UyxlQUFMLENBQXFCTCxTQUFyQixFQUFnQ0MsUUFBaEMsQ0FBUDtBQUNIOztBQUNELGFBQU8sRUFBUDtBQUNIOzs7b0NBRWVsVSxLLEVBQU91VSxNLEVBQVE7QUFBQTs7QUFDM0IsVUFBSUMsY0FBSjtBQUNBLFVBQUlDLGdCQUFnQixHQUFHLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQWE7QUFDNUNILHNCQUFjLEdBQUdHLE9BQWpCO0FBQ0gsT0FGc0IsQ0FBdkI7QUFHQSxVQUFJMVUsVUFBVSxHQUFHLEtBQUt1UCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJJLFVBQTFCLEVBQWpCOztBQUNBLFVBQUkyVSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxHQUFNO0FBQ25CLFlBQUlDLGlCQUFpQixHQUFHN1UsS0FBSyxDQUFDa1AsR0FBTixFQUF4QjtBQUNBRSxVQUFFLENBQUMwRixXQUFILENBQWVDLElBQWYsQ0FBb0JGLGlCQUFwQjs7QUFDQSxjQUFJLENBQUNyRixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJJLFVBQTFCLENBQXFDQSxVQUFVLEdBQUMsQ0FBaEQ7O0FBQ0EsY0FBSSxDQUFDdVAsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQytVLElBQWxDLENBQXVDRixpQkFBdkM7O0FBQ0FMLHNCQUFjLENBQUNLLGlCQUFELENBQWQ7QUFDQTdVLGFBQUssQ0FBQ2dWLElBQU4sQ0FBVyxVQUFYLEVBQXVCLElBQXZCO0FBQ0FULGNBQU0sQ0FBQ1MsSUFBUCxDQUFZLFVBQVosRUFBd0IsSUFBeEI7O0FBQ0EsY0FBSSxDQUFDblQsSUFBTCxDQUFVZ1MsT0FBVjtBQUNILE9BVEQ7O0FBVUFVLFlBQU0sQ0FBQ1UsS0FBUCxDQUFhTCxVQUFiO0FBQ0E1VSxXQUFLLENBQUNrVixLQUFOLENBQVksVUFBQ3ZHLENBQUQsRUFBTztBQUNmLFlBQUlBLENBQUMsQ0FBQ3dHLE9BQUYsS0FBYyxFQUFsQixFQUFzQjtBQUNsQlAsb0JBQVU7QUFDYjtBQUNKLE9BSkQ7QUFLQTVVLFdBQUssQ0FBQ29WLEtBQU47QUFDQXpTLGFBQU8sQ0FBQ0MsR0FBUixDQUFZM0MsVUFBWixFQUF3QixLQUFLdVAsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQzBJLE1BQTFEOztBQUNBLFVBQUl6SSxVQUFVLEdBQUcsS0FBS3VQLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0MwSSxNQUFuRCxFQUEyRDtBQUN2RCxZQUFJbU0saUJBQWlCLEdBQUcsS0FBS3JGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NDLFVBQWxDLENBQXhCO0FBQ0FELGFBQUssQ0FBQ2tQLEdBQU4sQ0FBVTJGLGlCQUFWO0FBQ0EsYUFBS3JGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkksVUFBMUIsQ0FBcUNBLFVBQVUsR0FBQyxDQUFoRDtBQUNBLGVBQU8sSUFBSXlVLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQWE7QUFDNUIzVSxlQUFLLENBQUNnVixJQUFOLENBQVcsVUFBWCxFQUF1QixJQUF2QjtBQUNBVCxnQkFBTSxDQUFDUyxJQUFQLENBQVksVUFBWixFQUF3QixJQUF4Qjs7QUFDQSxnQkFBSSxDQUFDblQsSUFBTCxDQUFVZ1MsT0FBVjs7QUFDQWMsaUJBQU8sQ0FBQ0UsaUJBQUQsQ0FBUDtBQUNILFNBTE0sQ0FBUDtBQU1IOztBQUNELGFBQU9KLGdCQUFQO0FBQ0g7Ozs7RUEzRTBCNUMsVzs7SUE4RXpCd0QsbUI7Ozs7O0FBQ0YsK0JBQVk3RixJQUFaLEVBQWtCO0FBQUE7O0FBQUEsOEJBQ1JBLElBRFEsRUFDRixXQURFO0FBRWpCOzs7RUFINkJ1RSxnQjs7SUFNNUJ1Qix3Qjs7Ozs7QUFDRixvQ0FBWTlGLElBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDZCxnQ0FBTUEsSUFBTixFQUFZeUIsZUFBZSxDQUFDUSxVQUE1Qjs7QUFDQSxXQUFLNVAsSUFBTCxDQUFVcVIsTUFBVixDQUFpQnRSLENBQUMsQ0FBQ2tQLGVBQUQsQ0FBbEI7O0FBQ0EsV0FBS2pQLElBQUwsQ0FBVW9ULEtBQVYsQ0FBZ0IsWUFBTTtBQUNsQixhQUFLekYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1CaUosT0FBbkIsQ0FBMkJPLFFBQTNCOztBQUNBO0FBQ0gsS0FIRDs7QUFIYztBQU9qQjs7OzsyQkFFTXlFLEssRUFBTztBQUNWQSxXQUFLLENBQUNXLE1BQU4sQ0FBYSxLQUFLclIsSUFBbEI7QUFDSDs7OztFQVprQ2dRLFc7O0FBZWhDLElBQU03QixjQUFiO0FBRUk7Ozs7Ozs7O0FBUUEsMEJBQWFSLElBQWIsRUFBbUIrRixHQUFuQixFQUF3QjtBQUFBOztBQUNwQixTQUFLL0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSytGLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtDLFVBQUwsR0FBa0JELEdBQUcsQ0FBQzFGLElBQUosQ0FBUyxrQkFBVCxDQUFsQjtBQUVBLFNBQUs0RixhQUFMLEdBQXFCLEdBQXJCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixHQUF0QjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsS0FBS0gsVUFBTCxDQUFnQkksTUFBaEIsRUFBdEIsQ0FQb0IsQ0FPNEI7O0FBQ2hELFNBQUtwRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLK1ksY0FBbkQ7QUFFQSxTQUFLNVYsTUFBTCxHQUFjLEtBQUt5UCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJFLE1BQXhDLENBVm9CLENBV3BCOztBQUNBLFNBQUt0RSxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBS29hLEtBQUwsR0Fib0IsQ0FlcEI7QUFDSDs7QUExQkw7QUFBQTs7QUE0Qkk7Ozs7QUE1QkosNEJBZ0NZO0FBQ0osV0FBSzlWLE1BQUwsQ0FBWStWLFNBQVo7QUFFQSxXQUFLQyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFdBQUtSLFVBQUwsQ0FBZ0JTLEtBQWhCLEdBTEksQ0FNSjs7QUFDQSxVQUFJLEtBQUt6RyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JVLHFCQUF4QixPQUFvRCxLQUFLNFksVUFBTCxDQUFnQkksTUFBaEIsRUFBeEQsRUFBa0Y7QUFDOUUsYUFBS0osVUFBTCxDQUFnQkksTUFBaEIsQ0FBdUIsS0FBS0QsY0FBNUI7QUFDQSxhQUFLbkcsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCVSxxQkFBeEIsQ0FBOEMsS0FBSzRZLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQTlDO0FBQ0g7O0FBRUQsV0FBS00sVUFBTCxHQUFrQixJQUFsQjtBQUNBOUcsUUFBRSxDQUFDK0csY0FBSCxHQUFvQjtBQUNoQi9ILGNBQU0sRUFBRSxLQUFLZ0ksYUFBTCxDQUFtQm5MLElBQW5CLENBQXdCLElBQXhCLENBRFE7QUFFaEJvTCxhQUFLLEVBQUUsS0FBS0MsUUFBTCxFQUZTO0FBR2hCVixjQUFNLEVBQUUsS0FBS1csU0FBTCxFQUhRO0FBSWhCQyxjQUFNLEVBQUUsS0FBS0MsU0FBTCxDQUFleEwsSUFBZixDQUFvQixJQUFwQjtBQUpRLE9BQXBCO0FBT0EsV0FBS3lMLFVBQUwsR0FBa0IsSUFBbEI7QUFDSDtBQXJETDtBQUFBO0FBQUEsOEJBdURjN2MsSUF2RGQsRUF1RG9CO0FBQ1osYUFBT0EsSUFBUDtBQUNIO0FBekRMO0FBQUE7QUFBQSxvQ0EyRG9CO0FBQ1osVUFBSSxLQUFLcWMsVUFBTCxLQUFvQixJQUF4QixFQUE4QjtBQUMxQixhQUFLQSxVQUFMLEdBQWtCLElBQUk3RCxpQkFBSixDQUFzQixLQUFLN0MsSUFBM0IsQ0FBbEI7QUFDQSxhQUFLMEcsVUFBTCxDQUFnQlMsTUFBaEIsQ0FBdUIsS0FBS25CLFVBQTVCLEVBRjBCLENBRzFCOztBQUNBLFlBQUksS0FBS2hHLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QlUscUJBQXhCLE9BQW9ELEtBQUs0WSxVQUFMLENBQWdCSSxNQUFoQixFQUF4RCxFQUFrRjtBQUM5RSxjQUFJZ0IsdUJBQXVCLEdBQUcsS0FBS3BCLFVBQUwsQ0FBZ0JhLEtBQWhCLEVBQTlCO0FBQ0EsZUFBS2IsVUFBTCxDQUFnQkksTUFBaEIsQ0FBdUJnQix1QkFBdkI7QUFDQSxlQUFLcEgsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCVSxxQkFBeEIsQ0FBOEMsS0FBSzRZLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQTlDO0FBQ0F4RyxZQUFFLENBQUMrRyxjQUFILENBQWtCUCxNQUFsQixHQUEyQmdCLHVCQUF1QixHQUFDLEVBQW5EO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLEtBQUtWLFVBQUwsQ0FBZ0JyVSxJQUFoQixDQUFxQixDQUFyQixDQUFQO0FBQ0g7QUF4RUw7QUFBQTtBQUFBLHVDQTBFdUJnVixRQTFFdkIsRUEwRWlDQyxTQTFFakMsRUEwRTRDO0FBQ3BDO0FBQ0EsVUFBSSxLQUFLdEgsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCVSxxQkFBeEIsT0FBb0QsS0FBSzRZLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQXBELElBQ0FrQixTQUFTLEdBQUcsS0FBS25CLGNBRHJCLEVBQ3FDO0FBQ2pDLGFBQUtILFVBQUwsQ0FBZ0JJLE1BQWhCLENBQXVCLEtBQUdrQixTQUExQjtBQUNBLGFBQUt0SCxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLNFksVUFBTCxDQUFnQkksTUFBaEIsRUFBOUM7QUFDSCxPQU5tQyxDQU9wQzs7O0FBQ0EsVUFBSWlCLFFBQVEsR0FBRyxLQUFLckIsVUFBTCxDQUFnQmEsS0FBaEIsRUFBZixFQUF3QztBQUNwQyxhQUFLN0csSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1COEIsU0FBbkIsQ0FBNkJXLFFBQTdCO0FBQ0g7QUFDSjtBQXJGTDtBQUFBO0FBQUEsb0NBdUZvQjtBQUNaLFVBQUksS0FBS3lJLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Dc2IsZ0JBQXBDLEVBQUosRUFBNEQ7QUFDeEQsWUFBSSxLQUFLYixVQUFULEVBQXFCO0FBQ2pCLGNBQUluRCxNQUFNLEdBQUcsS0FBS21ELFVBQUwsQ0FBZ0JyVSxJQUFoQixDQUFxQmdPLElBQXJCLENBQTBCLFFBQTFCLEVBQW9DM0gsSUFBcEMsR0FBMkMsQ0FBM0MsQ0FBYjtBQUNBLGNBQUk4TyxPQUFPLEdBQUdqRSxNQUFNLENBQUNrRSxTQUFQLENBQWlCLFdBQWpCLENBQWQ7QUFDQSxlQUFLekgsSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJwRCxTQUE1QixDQUFzQyxlQUF0QyxFQUF1RG9ZLE9BQXZEO0FBQ0gsU0FKRCxNQUlPLElBQUksS0FBS04sVUFBVCxFQUFxQjtBQUN4QixjQUFJM0QsT0FBTSxHQUFHLEtBQUsyRCxVQUFMLENBQWdCM0QsTUFBN0I7O0FBQ0EsY0FBSWlFLFFBQU8sR0FBR2pFLE9BQU0sQ0FBQ2tFLFNBQVAsQ0FBaUIsV0FBakIsQ0FBZDs7QUFDQSxlQUFLekgsSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJwRCxTQUE1QixDQUFzQyxlQUF0QyxFQUF1RG9ZLFFBQXZEO0FBQ0gsU0FKTSxNQUlBLENBQ0g7QUFDSDtBQUNKO0FBQ0osS0FyR0wsQ0F1R0k7O0FBdkdKO0FBQUE7QUFBQSxnQ0F3R2dCO0FBQ1IsYUFBTyxJQUFQO0FBQ0g7QUExR0w7QUFBQTtBQUFBLCtCQTRHZTtBQUNQLGFBQU9uUCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxLQUFLMk4sYUFBZCxFQUE2QixLQUFLRCxVQUFMLENBQWdCYSxLQUFoQixLQUF3QixFQUFyRCxDQUFQO0FBQ0g7QUE5R0w7QUFBQTtBQUFBLGdDQWdIZ0I7QUFDUixhQUFPeE8sSUFBSSxDQUFDQyxHQUFMLENBQVMsS0FBSzROLGNBQWQsRUFBOEIsS0FBS0YsVUFBTCxDQUFnQkksTUFBaEIsS0FBeUIsRUFBdkQsQ0FBUDtBQUNIO0FBbEhMO0FBQUE7QUFBQSw4QkFvSGM7QUFDTixhQUFPLEtBQUtwRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JHLFdBQXhCLEVBQVA7QUFDSDtBQUVEOzs7Ozs7OztBQXhISjtBQUFBO0FBQUEsZ0NBK0hnQm1MLElBL0hoQixFQStIc0IwUCxJQS9IdEIsRUErSDRCO0FBQ3BCLFdBQUsxQixVQUFMLENBQWdCM0YsSUFBaEIsQ0FBcUIseUJBQXJCLEVBQWdEc0gsSUFBaEQsQ0FBcUQsWUFBVztBQUM1RCxZQUFJdlYsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRd1YsSUFBUixDQUFhLFdBQWIsS0FBNkI1UCxJQUFqQyxFQUF1QztBQUNuQzVGLFdBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUTJPLElBQVI7QUFDSCxTQUZELE1BRU87QUFDSDNPLFdBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUTRPLElBQVI7QUFDSDtBQUNKLE9BTkQ7QUFPSDtBQXZJTDtBQUFBOztBQXlJSTs7OztBQXpJSiwwQkE2SVU2RyxRQTdJVixFQTZJb0I7QUFDWjtBQUNBO0FBQ0EsVUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDWDtBQUNIOztBQUNELFVBQUlDLEtBQUssR0FBRyxLQUFaOztBQUNBLFVBQUlELFFBQVEsQ0FBQ0UsTUFBVCxDQUFnQkYsUUFBUSxDQUFDM08sTUFBVCxHQUFnQixDQUFoQyxNQUF1QyxJQUEzQyxFQUFpRDtBQUM3QzRPLGFBQUssR0FBRyxJQUFSO0FBQ0g7O0FBQ0QsVUFBSUUsVUFBVSxHQUFHSCxRQUFRLENBQUNJLEtBQVQsQ0FBZSxJQUFmLENBQWpCOztBQUNBLFVBQUksS0FBSzFCLFVBQUwsS0FBb0IsSUFBeEIsRUFBOEI7QUFDMUIsYUFBS0EsVUFBTCxHQUFrQixJQUFJdkMsZUFBSixDQUFvQixLQUFLaEUsSUFBekIsRUFBK0J5QixlQUFlLENBQUNDLElBQS9DLEVBQXFEc0csVUFBVSxDQUFDLENBQUQsQ0FBL0QsQ0FBbEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLekIsVUFBTCxDQUFnQjJCLFVBQWhCLENBQTJCRixVQUFVLENBQUMsQ0FBRCxDQUFyQztBQUNIOztBQUNELFdBQUssSUFBSUcsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHSCxVQUFVLENBQUM5TyxNQUFYLEdBQWtCLENBQXBDLEVBQXVDaVAsQ0FBQyxFQUF4QyxFQUE0QztBQUN4QyxhQUFLNVgsTUFBTCxDQUFZZ1YsSUFBWixDQUFpQixLQUFLZ0IsVUFBdEI7QUFDQSxhQUFLQSxVQUFMLENBQWdCWSxNQUFoQixDQUF1QixLQUFLbkIsVUFBNUI7QUFDQSxhQUFLTyxVQUFMLEdBQWtCLElBQUl2QyxlQUFKLENBQW9CLEtBQUtoRSxJQUF6QixFQUErQnlCLGVBQWUsQ0FBQ0MsSUFBL0MsRUFBcURzRyxVQUFVLENBQUNHLENBQUQsQ0FBL0QsQ0FBbEI7QUFDSDs7QUFDRCxVQUFJTCxLQUFKLEVBQVc7QUFDUCxhQUFLdlgsTUFBTCxDQUFZZ1YsSUFBWixDQUFpQixLQUFLZ0IsVUFBdEI7QUFDQSxhQUFLQSxVQUFMLENBQWdCWSxNQUFoQixDQUF1QixLQUFLbkIsVUFBNUI7QUFDQSxhQUFLTyxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFDSjtBQXZLTDtBQUFBO0FBQUEseUJBMEtTNkIsS0ExS1QsRUEwS2dCO0FBQ1IsV0FBSzVCLFVBQUwsR0FBa0IsSUFBSXpDLGVBQUosQ0FBb0IsS0FBSy9ELElBQXpCLEVBQStCb0ksS0FBL0IsQ0FBbEI7QUFDQSxXQUFLNUIsVUFBTCxDQUFnQlcsTUFBaEIsQ0FBdUIsS0FBS25CLFVBQTVCO0FBQ0EsYUFBTyxLQUFLUSxVQUFaO0FBQ0g7QUE5S0w7QUFBQTtBQUFBLDJCQWdMVzlPLElBaExYLEVBZ0xpQjNKLFVBaExqQixFQWdMNkJzVixTQWhMN0IsRUFnTHdDO0FBQ2hDLFVBQUksS0FBSzZELFVBQUwsS0FBb0IsSUFBeEIsRUFBOEI7QUFDMUIsYUFBS0EsVUFBTCxHQUFrQixJQUFJOUQsaUJBQUosQ0FBc0IsS0FBS3BELElBQTNCLEVBQWlDdEksSUFBakMsRUFBdUMzSixVQUF2QyxFQUFtRHNWLFNBQW5ELENBQWxCO0FBQ0EsYUFBSzZELFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCLEtBQUtuQixVQUE1QjtBQUNIOztBQUNELGFBQU8sS0FBS2tCLFVBQVo7QUFDSDtBQXRMTDtBQUFBO0FBQUEsa0NBd0xrQm1CLFNBeExsQixFQXdMNkI7QUFDckJsVixhQUFPLENBQUNDLEdBQVIsQ0FBWSxNQUFaLEVBQW9CaVYsU0FBUyxDQUFDQyxLQUE5QjtBQUNBLFdBQUtDLFdBQUwsR0FBbUIsSUFBSXpFLGdCQUFKLENBQXFCLEtBQUs5RCxJQUExQixFQUFnQ3FJLFNBQVMsQ0FBQ0MsS0FBMUMsQ0FBbkI7QUFDQSxXQUFLQyxXQUFMLENBQWlCcEIsTUFBakIsQ0FBd0IsS0FBS25CLFVBQTdCO0FBQ0EsYUFBTyxLQUFLdUMsV0FBWjtBQUNIO0FBN0xMO0FBQUE7QUFBQSwrQkErTGVDLEtBL0xmLEVBK0xzQjtBQUNkLFVBQUlDLFlBQVksR0FBRyxJQUFJbkUsZ0JBQUosQ0FBcUIsS0FBS3RFLElBQTFCLEVBQWdDd0ksS0FBaEMsQ0FBbkI7QUFDQUMsa0JBQVksQ0FBQ3RCLE1BQWIsQ0FBb0IsS0FBS25CLFVBQXpCO0FBQ0EsYUFBT3lDLFlBQVA7QUFDSDtBQUVEOzs7Ozs7QUFyTUo7QUFBQTtBQUFBLDBCQTBNVWpFLGFBMU1WLEVBME15QjtBQUNqQixXQUFLa0UsV0FBTCxHQUFtQixJQUFJbkUsZ0JBQUosQ0FBcUIsS0FBS3ZFLElBQTFCLEVBQWdDd0UsYUFBaEMsQ0FBbkI7QUFDQSxhQUFPLEtBQUtrRSxXQUFMLENBQWlCdkIsTUFBakIsQ0FBd0IsS0FBS25CLFVBQTdCLENBQVA7QUFDSDtBQTdNTDtBQUFBO0FBQUEsK0JBZ05lO0FBQ1AsV0FBSzBDLFdBQUwsR0FBbUIsSUFBSTdDLG1CQUFKLENBQXdCLEtBQUs3RixJQUE3QixDQUFuQjtBQUNBLGFBQU8sS0FBSzBJLFdBQUwsQ0FBaUJ2QixNQUFqQixDQUF3QixLQUFLbkIsVUFBN0IsQ0FBUDtBQUNIO0FBbk5MO0FBQUE7QUFBQSxnQ0FxTmdCO0FBQ1IsVUFBSTJDLGVBQWUsR0FBRyxJQUFJN0Msd0JBQUosQ0FBNkIsS0FBSzlGLElBQWxDLENBQXRCO0FBQ0EsYUFBTzJJLGVBQWUsQ0FBQ3hCLE1BQWhCLENBQXVCLEtBQUtuQixVQUE1QixDQUFQO0FBQ0g7QUFFRDs7Ozs7QUExTko7QUFBQTtBQUFBLHFDQThOcUI7QUFDYixXQUFLRCxHQUFMLENBQVM2QyxPQUFULENBQWlCO0FBQ2J6RixpQkFBUyxFQUFFLEtBQUs0QyxHQUFMLENBQVNQLElBQVQsQ0FBYyxjQUFkLElBQWdDLEtBQUtPLEdBQUwsQ0FBU1AsSUFBVCxDQUFjLGNBQWQ7QUFEOUIsT0FBakIsRUFFRyxHQUZIO0FBR0g7QUFsT0w7O0FBQUE7QUFBQSxJOzs7Ozs7Ozs7Ozs7O0FDaFdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FFQTs7QUFFTyxJQUFJcUQsa0JBQWtCLEdBQUcsRUFBekI7QUFDQSxJQUFJQywyQkFBMkIsR0FBRyxFQUFsQztBQUVQOzs7Ozs7O0FBTUEsSUFBSUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFVQyxHQUFWLEVBQWU7QUFDakNBLEtBQUcsQ0FBQ2xHLFFBQUosQ0FBYSxRQUFiLEVBQ0tBLFFBREwsQ0FDYyxhQURkLEVBRUttRyxXQUZMLENBRWlCLGFBRmpCLEVBR0t6RCxJQUhMLENBR1UsVUFIVixFQUdzQixJQUh0QixFQUlLdkYsSUFKTCxDQUlVLFFBSlYsRUFLSzJILElBTEwsQ0FLVSxjQUxWLEVBSzBCLE1BTDFCO0FBTUgsQ0FQRDtBQVVBOzs7Ozs7Ozs7OztBQVNPLFNBQVMvRyxhQUFULENBQXVCYixJQUF2QixFQUE2QjtBQUNoQyxPQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFFQSxPQUFLa0osY0FBTCxHQUFzQixFQUF0QjtBQUNBLE9BQUsxVSxZQUFMO0FBQ0g7O0FBRURxTSxhQUFhLENBQUNWLFNBQWQsQ0FBd0IzTCxZQUF4QixHQUF1QyxVQUFVMlUsUUFBVixFQUFvQjtBQUFBOztBQUN2RDtBQUNBLE1BQUluZixLQUFLLEdBQUcsS0FBS2dXLElBQUwsQ0FBVWhXLEtBQXRCO0FBQUEsTUFDSThULE1BQU0sR0FBRyxLQUFLa0MsSUFBTCxDQUFVek4sVUFBVixDQUFxQmtDLFlBRGxDO0FBQUEsTUFFSWpDLE1BQU0sR0FBRyxLQUFLd04sSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFGbEM7QUFHQSxNQUFJNFcsT0FBTyxHQUFHLEVBQWQ7QUFDQXBmLE9BQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQm9kLFFBQTFCLEdBQXFDcEIsS0FBckMsQ0FBMkMsR0FBM0MsRUFBZ0RxQixPQUFoRCxDQUF3RCxVQUFDamYsSUFBRCxFQUFVO0FBQzlELFFBQUlBLElBQUksSUFBSSxFQUFFQSxJQUFJLElBQUlrZixzQkFBc0IsQ0FBQ0MsV0FBakMsQ0FBWixFQUEyRDtBQUN2REosYUFBTyxDQUFDN0QsSUFBUixDQUFha0UsS0FBYixDQUFtQkwsT0FBbkIsRUFBNEIsS0FBSSxDQUFDek4sYUFBTCxDQUFtQitOLHVEQUFJLENBQUNyZixJQUFELENBQXZCLEVBQStCQSxJQUEvQixFQUFxQzhlLFFBQXJDLENBQTVCO0FBQ0g7QUFDSixHQUpELEVBTnVELENBWXZEOztBQUNBL1csR0FBQyxDQUFDdVgsSUFBRixDQUFPRixLQUFQLENBQWFyWCxDQUFiLEVBQWdCZ1gsT0FBaEIsRUFBeUJRLElBQXpCLENBQThCLFlBQVk7QUFDdEM7QUFDQTlMLFVBQU0sQ0FBQ3BKLEVBQVAsQ0FBVW1WLGlCQUFWO0FBQ0EvTCxVQUFNLENBQUNwSixFQUFQLENBQVUyRSxXQUFWLENBQXNCeVEsYUFBdEI7QUFDSCxHQUpELEVBSUdDLElBSkgsQ0FJUSxVQUFVNUssQ0FBVixFQUFhO0FBQ2pCaE0sV0FBTyxDQUFDQyxHQUFSLENBQVk0VyxTQUFaO0FBQ0E3VyxXQUFPLENBQUM4VyxLQUFSLENBQWM5SyxDQUFkO0FBQ0gsR0FQRCxFQU9HK0ssTUFQSCxDQU9VLFlBQVk7QUFDbEIxWCxVQUFNLENBQUMyWCxxQkFBUDtBQUNILEdBVEQ7QUFVSCxDQXZCRDtBQXlCQTs7Ozs7Ozs7Ozs7Ozs7QUFZQXRKLGFBQWEsQ0FBQ1YsU0FBZCxDQUF3QnhFLGFBQXhCLEdBQXdDLFVBQVUrTixJQUFWLEVBQWdCcmYsSUFBaEIsRUFBc0I7QUFBQTs7QUFDMUQsTUFBSStmLGNBQWMsR0FBRyxFQUFyQjs7QUFDQSxNQUFJLEtBQUtwSyxJQUFMLENBQVVoVyxLQUFWLENBQWdCOEssRUFBaEIsQ0FBbUJ0QyxNQUFuQixDQUEwQjZKLG1CQUExQixDQUE4QyxnQkFBOUMsQ0FBSixFQUFxRTtBQUNqRSxRQUFJZ08sSUFBSSxHQUFHLEtBQUtySyxJQUFMLENBQVVoVyxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJzSixJQUE5QixDQUFtQ3NZLGNBQW5DLEdBQW9ELFVBQXBELEdBQWlFWixJQUFqRSxHQUF3RSxHQUF4RSxHQUE4RUEsSUFBekY7QUFDQSxTQUFLMUosSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCaUIsZUFBeEIsQ0FBd0M0WCxJQUF4QyxDQUE2Q2xiLElBQTdDLEVBRmlFLENBR2pFOztBQUNBLFFBQUlrZ0IsVUFBVSxHQUFHblksQ0FBQyxDQUFDb1ksU0FBRixDQUFZSCxJQUFJLEdBQUcsYUFBbkIsQ0FBakIsQ0FKaUUsQ0FLakU7O0FBQ0EsUUFBSUksV0FBVyxHQUFHclksQ0FBQyxDQUFDb1ksU0FBRixDQUFZSCxJQUFJLEdBQUcsY0FBbkIsQ0FBbEI7QUFDQSxRQUFJSyxTQUFTLEdBQUd0WSxDQUFDLENBQUN0SSxHQUFGLENBQU11Z0IsSUFBSSxHQUFHLFlBQWIsRUFBMkIsVUFBVW5YLElBQVYsRUFBZ0I7QUFDdkQwTSxRQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIsYUFBYTZKLElBQWIsR0FBb0IsY0FBN0MsSUFBK0R4VyxJQUEvRDtBQUNILEtBRmUsQ0FBaEI7QUFHQSxRQUFJeVgsVUFBVSxHQUFHdlksQ0FBQyxDQUFDb1ksU0FBRixDQUFZSCxJQUFJLEdBQUcsYUFBbkIsQ0FBakIsQ0FWaUUsQ0FXakU7O0FBQ0FqWSxLQUFDLENBQUN1WCxJQUFGLENBQU9ZLFVBQVAsRUFBbUJHLFNBQW5CLEVBQThCQyxVQUE5QixFQUEwQ2YsSUFBMUMsQ0FBK0MsWUFBTTtBQUNqRCxZQUFJLENBQUNWLGNBQUwsQ0FBb0IzRCxJQUFwQixDQUF5Qm1FLElBQXpCOztBQUNBLFlBQUksQ0FBQzFKLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJrQyxZQUFyQixDQUFrQ0MsRUFBbEMsQ0FBcUNrVyxZQUFyQyxDQUFrREMsYUFBbEQsQ0FBZ0V0RixJQUFoRSxDQUFxRW1FLElBQXJFOztBQUNBLFlBQUksQ0FBQzFKLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJrQyxZQUFyQixDQUFrQ0MsRUFBbEMsQ0FBcUNtVixpQkFBckM7O0FBQ0EsWUFBSSxDQUFDN0osSUFBTCxDQUFVek4sVUFBVixDQUFxQmtDLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQzJFLFdBQXJDLENBQWlEeVEsYUFBakQ7O0FBQ0EsWUFBSSxDQUFDOUosSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCaUIsZUFBeEIsQ0FBd0NpVixNQUF4QyxDQUErQ3ZZLElBQS9DO0FBQ0gsS0FORDtBQU9BK2Ysa0JBQWMsQ0FBQzdFLElBQWYsQ0FBb0JnRixVQUFwQixFQUFnQ0csU0FBaEMsRUFBMkNDLFVBQTNDO0FBQ0g7O0FBQ0QsU0FBT1AsY0FBUDtBQUNILENBeEJEO0FBMEJBOzs7Ozs7Ozs7QUFPQXZKLGFBQWEsQ0FBQ1YsU0FBZCxDQUF3QnZFLFVBQXhCLEdBQXFDLFlBQVk7QUFBQTs7QUFDN0MsTUFBSSxLQUFLb0UsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1CdEMsTUFBbkIsQ0FBMEI2SixtQkFBMUIsQ0FBOEMsZ0JBQTlDLENBQUosRUFBcUU7QUFDakUsUUFBSWdPLElBQUksR0FBRyxLQUFLckssSUFBTCxDQUFVaFcsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCc0osSUFBOUIsQ0FBbUNzWSxjQUE5QztBQUNBbFksS0FBQyxDQUFDMFksT0FBRixDQUFVVCxJQUFJLEdBQUcsWUFBakIsRUFBZ0MsVUFBQ25YLElBQUQsRUFBVTtBQUN0QztBQUNBLFVBQUltVyxRQUFRLEdBQUduVyxJQUFJLENBQUM2WCxPQUFwQjtBQUNBLFVBQUlDLGFBQWEsR0FBR1gsSUFBSSxHQUFDLG9CQUF6QjtBQUNBLFVBQUk3Z0IsS0FBSyxHQUFHNEksQ0FBQyxxREFBOEM0WSxhQUE5QyxpQ0FBYjtBQUNBLFVBQUlDLElBQUksR0FBRzdZLENBQUMsQ0FBQyxpQkFBRCxFQUFvQjtBQUFDLGlCQUFTO0FBQVYsT0FBcEIsQ0FBWjtBQUNBOFksWUFBTSxDQUFDQyxJQUFQLENBQVk5QixRQUFaLEVBQXNCK0IsSUFBdEIsR0FBNkJ0USxHQUE3QixDQUFpQyxVQUFDelEsSUFBRCxFQUFVO0FBQ3ZDLFlBQUlnaEIsV0FBVyxHQUFHM0IsdURBQUksQ0FBQ0wsUUFBUSxDQUFDaGYsSUFBRCxDQUFSLENBQWVBLElBQWhCLENBQXRCO0FBQ0EsWUFBSWloQixTQUFTLEdBQUdqaEIsSUFBaEI7QUFDQSxZQUFJMmUsR0FBRyxHQUFHNVcsQ0FBQyxDQUFDLDBIQUFELENBQVg7QUFDQSxZQUFJbVosTUFBTSxHQUFHbEIsSUFBSSxHQUFDLHFCQUFMLEdBQTJCaGdCLElBQTNCLEdBQWdDLFdBQTdDOztBQUNBLFlBQUksTUFBSSxDQUFDNmUsY0FBTCxDQUFvQjdOLE9BQXBCLENBQTRCZ1EsV0FBNUIsSUFBMkMsQ0FBQyxDQUFoRCxFQUFtRDtBQUMvQ3RDLHlCQUFlLENBQUNDLEdBQUQsQ0FBZjtBQUNILFNBRkQsTUFFTztBQUNIQSxhQUFHLENBQUN2RCxLQUFKLENBQVcsWUFBTTtBQUNiLGtCQUFJLENBQUM5SixhQUFMLENBQW1CMFAsV0FBbkIsRUFBZ0MsWUFBWWhDLFFBQVEsQ0FBQ2hmLElBQUQsQ0FBUixDQUFlbWhCLEtBQTNEOztBQUNBekMsMkJBQWUsQ0FBQ0MsR0FBRCxDQUFmO0FBQ0gsV0FIRDtBQUlILFNBWnNDLENBYXZDOzs7QUFDQTVXLFNBQUMsQ0FBQyxXQUFELENBQUQsQ0FDSTtBQURKLFNBRUtzUixNQUZMLENBRVl0UixDQUFDLENBQUMsU0FBU2lYLFFBQVEsQ0FBQ2hmLElBQUQsQ0FBUixDQUFlbWhCLEtBQXhCLEdBQWdDLE9BQWpDLENBRmIsRUFHSzlILE1BSEwsQ0FHWXRSLENBQUMsQ0FBQyxTQUFTaVgsUUFBUSxDQUFDaGYsSUFBRCxDQUFSLENBQWVvaEIsUUFBeEIsR0FBbUMsT0FBcEMsQ0FIYixFQUlLL0gsTUFKTCxDQUlZdFIsQ0FBQyxDQUFDLFdBQUQsQ0FBRCxDQUFlc1IsTUFBZixDQUFzQnNGLEdBQXRCLENBSlosRUFLSzBDLFFBTEwsQ0FLY1QsSUFMZDtBQU1ILE9BcEJEO0FBcUJBQSxVQUFJLENBQUNTLFFBQUwsQ0FBY2xpQixLQUFkLEVBM0JzQyxDQTRCdEM7O0FBQ0EsWUFBSSxDQUFDd1csSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCcUwsSUFBNUIsQ0FBaUMsaUJBQWpDLEVBQW9EdlgsS0FBcEQsRUFBMkQsSUFBM0Q7QUFDSCxLQTlCRDtBQStCSDtBQUNKLENBbkNELEM7Ozs7Ozs7Ozs7OztBQzdHQTtBQUNBLE9BQU8sS0FBVSxFQUFFLGtCQUtkOzs7Ozs7Ozs7Ozs7QUNOTDtBQUNBLE9BQU8sS0FBVSxFQUFFLGtCQUtkOzs7Ozs7Ozs7Ozs7O0FDTkw7QUFBQTtBQUFBO0FBQUE7QUFFTyxJQUFJbWlCLFdBQVcsNGtDQUFmO0FBeUJQOzs7Ozs7Ozs7Ozs7QUFXTyxTQUFTdkwsYUFBVCxDQUF1QkosSUFBdkIsRUFBNkIrRixHQUE3QixFQUFrQztBQUFBOztBQUNyQyxPQUFLL0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsT0FBSytGLEdBQUwsR0FBV0EsR0FBWDtBQUVBLE9BQUs2RixRQUFMLEdBQWdCN0YsR0FBRyxDQUFDMUYsSUFBSixDQUFTLGNBQVQsQ0FBaEI7QUFDQSxPQUFLd0wsT0FBTCxHQUFlOUYsR0FBRyxDQUFDMUYsSUFBSixDQUFTLGFBQVQsQ0FBZjtBQUNBLE9BQUt5TCxTQUFMLEdBQWlCL0YsR0FBRyxDQUFDMUYsSUFBSixDQUFTLGVBQVQsQ0FBakI7QUFDQSxPQUFLMEwsVUFBTCxHQUFrQmhHLEdBQUcsQ0FBQzFGLElBQUosQ0FBUyxhQUFULENBQWxCO0FBQ0EsT0FBSzJMLFdBQUwsR0FBbUJqRyxHQUFHLENBQUMxRixJQUFKLENBQVMsY0FBVCxDQUFuQjs7QUFFQSxPQUFLNEwsR0FBTCxHQUFXLFlBQU0sQ0FBRSxDQUFuQjs7QUFDQSxPQUFLQyxFQUFMLEdBQVUsWUFBTSxDQUFFLENBQWxCOztBQUNBLE9BQUtILFVBQUwsQ0FBZ0J0RyxLQUFoQixDQUFzQixZQUFNO0FBQ3hCLFNBQUksQ0FBQ3dHLEdBQUw7O0FBQ0EsU0FBSSxDQUFDbEcsR0FBTCxDQUFTb0csS0FBVCxDQUFlLE1BQWY7QUFDSCxHQUhEO0FBSUEsT0FBS0gsV0FBTCxDQUFpQnZHLEtBQWpCLENBQXVCLFlBQU07QUFDekIsU0FBSSxDQUFDeUcsRUFBTCxHQUR5QixDQUV6Qjs7QUFDSCxHQUhEO0FBSUg7O0FBRUQ5TCxhQUFhLENBQUNELFNBQWQsQ0FBd0JpTSxLQUF4QixHQUFnQyxZQUFZO0FBQ3hDLE9BQUtyRyxHQUFMLENBQVNvRyxLQUFULENBQWUsTUFBZjtBQUNILENBRkQ7QUFJQTs7Ozs7Ozs7OztBQVFBL0wsYUFBYSxDQUFDRCxTQUFkLENBQXdCWSxJQUF4QixHQUErQixVQUFVeUssS0FBVixFQUFpQlAsSUFBakIsRUFBdUJvQixPQUF2QixFQUFnQztBQUMzRCxPQUFLVCxRQUFMLENBQWN2WixJQUFkLENBQW1CbVosS0FBbkI7QUFDQSxPQUFLSyxPQUFMLENBQWF4WixJQUFiLENBQWtCNFksSUFBbEI7QUFDQSxPQUFLbEYsR0FBTCxDQUFTb0csS0FBVCxDQUFlLE1BQWY7QUFDQSxPQUFLSixVQUFMLENBQWdCL0ssSUFBaEI7QUFDQSxPQUFLK0UsR0FBTCxDQUFTdUcsU0FBVCxDQUFtQjtBQUNmLGNBQVU7QUFESyxHQUFuQjtBQUlBLE9BQUt2RyxHQUFMLENBQVN3RyxFQUFULENBQVksaUJBQVosRUFBK0IsVUFBVXBOLENBQVYsRUFBYTtBQUN4QyxRQUFJa04sT0FBTyxLQUFLdmpCLFNBQVosSUFBeUJ1akIsT0FBTyxLQUFLLElBQXpDLEVBQStDO0FBQzNDQSxhQUFPO0FBQ1Y7QUFDSixHQUpEO0FBS0gsQ0FkRDs7QUFnQkFqTSxhQUFhLENBQUNELFNBQWQsQ0FBd0JxTSxPQUF4QixHQUFrQyxVQUFVaEIsS0FBVixFQUFpQlAsSUFBakIsRUFBdUJnQixHQUF2QixFQUE0QkMsRUFBNUIsRUFBZ0NPLE9BQWhDLEVBQXlDO0FBQ3ZFLE1BQUlBLE9BQU8sS0FBSzNqQixTQUFoQixFQUEyQjtBQUN2QjJqQixXQUFPLEdBQUcsTUFBVjtBQUNIOztBQUNELE9BQUsxTCxJQUFMLENBQVV5SyxLQUFWLEVBQWlCUCxJQUFqQixFQUF1QmlCLEVBQXZCO0FBQ0EsT0FBS0QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS0MsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBS0gsVUFBTCxDQUFnQmhMLElBQWhCLEdBQXVCMU8sSUFBdkIsQ0FBNEJvYSxPQUE1QixFQVB1RSxDQVF2RTtBQUNILENBVEQ7O0FBV0FyTSxhQUFhLENBQUNELFNBQWQsQ0FBd0J1TSwwQkFBeEIsR0FBcUQsWUFBWTtBQUM3RCxPQUFLRixPQUFMLENBQWEsb0JBQWIsRUFBbUMsOEdBQW5DO0FBQ0gsQ0FGRDs7QUFJQXBNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QndNLHlCQUF4QixHQUFvRCxVQUFVQyxNQUFWLEVBQWtCO0FBQ2xFLE9BQUs3TCxJQUFMLENBQVUsMEJBQVYsdUpBQ3lFNkwsTUFEekU7QUFFSCxDQUhEOztBQUtBeE0sYUFBYSxDQUFDRCxTQUFkLENBQXdCME0sNEJBQXhCLEdBQXVELFVBQVVELE1BQVYsRUFBa0I7QUFDckUsT0FBSzdMLElBQUwsQ0FBVSw4QkFBViwySkFDeUU2TCxNQUR6RTtBQUVILENBSEQ7O0FBS0F4TSxhQUFhLENBQUNELFNBQWQsQ0FBd0IyTSxvQkFBeEIsR0FBK0MsVUFBVUYsTUFBVixFQUFrQjtBQUM3RCxPQUFLN0wsSUFBTCxDQUFVLHFCQUFWLCtIQUNxRDZMLE1BRHJEO0FBRUgsQ0FIRDs7QUFLQXhNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QjRNLHdCQUF4QixHQUFtRCxVQUFVSCxNQUFWLEVBQWtCO0FBQ2pFLE9BQUs3TCxJQUFMLENBQVUseUJBQVYsc0pBQ3lFNkwsTUFEekU7QUFFSCxDQUhEOztBQUtBeE0sYUFBYSxDQUFDRCxTQUFkLENBQXdCNk0sd0JBQXhCLEdBQW1ELFVBQVUvQyxLQUFWLEVBQWlCO0FBQ2hFLE9BQUtsSixJQUFMLENBQVUsZ0JBQVYsaUhBQWtJa0osS0FBbEk7QUFDSCxDQUZEOztBQUlBN0osYUFBYSxDQUFDRCxTQUFkLENBQXdCOE0sc0JBQXhCLEdBQWlELFVBQVV6QixLQUFWLEVBQWlCbGEsT0FBakIsRUFBMEI7QUFDdkUsT0FBS3lQLElBQUwsQ0FBVXlLLEtBQVYsRUFBaUJsYSxPQUFqQjtBQUNILENBRkQ7O0FBSUE4TyxhQUFhLENBQUNELFNBQWQsQ0FBd0IrTSxpQkFBeEIsR0FBNEMsWUFBWSxDQUNwRDtBQUNILENBRkQ7O0FBSUE5TSxhQUFhLENBQUNELFNBQWQsQ0FBd0JnTixnQ0FBeEIsR0FBMkQsWUFBWTtBQUNuRSxPQUFLcE0sSUFBTCxDQUFVLGtDQUFWO0FBRUgsQ0FIRDs7QUFLQVgsYUFBYSxDQUFDRCxTQUFkLENBQXdCckQscUJBQXhCLEdBQWdELFlBQVk7QUFDeEQsT0FBS2lFLElBQUwsQ0FBVSx1QkFBVjtBQUVILENBSEQ7O0FBS0FYLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QmlOLFVBQXhCLEdBQXFDLFlBQVk7QUFDN0MsTUFBSUMsUUFBUSxHQUFHLEtBQUtyTixJQUFMLENBQVVoVyxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJzSixJQUE5QixDQUFtQ3NiLDJCQUFsRDtBQUNBRCxVQUFRLEdBQUdBLFFBQVEseUJBQWlCQSxRQUFqQixtREFBc0UsRUFBekY7QUFDQSxPQUFLdE0sSUFBTCxDQUFVLDZCQUFWLHNhQVErRXNNLFFBUi9FLDB5QkF1QnlELEtBQUtyTixJQUFMLENBQVVoVyxLQUFWLENBQWdCQyxJQUFoQixDQUFxQk8sUUFBckIsRUF2QnpEO0FBMEJILENBN0JEOztBQStCQTRWLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QnhLLFdBQXhCLEdBQXNDLFlBQVk7QUFBQTs7QUFDOUMsTUFBSTRYLFNBQVMsR0FBRyxLQUFLdk4sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ2dkLElBQWxDLENBQXVDLElBQXZDLENBQWhCO0FBQ0EsTUFBSXZmLFdBQVcsR0FBRyxLQUFLK1IsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCdUIsV0FBeEIsS0FBd0MsRUFBeEMsR0FBNkMsU0FBL0Q7O0FBQ0EsTUFBSWdlLEdBQUcsR0FBRyxTQUFOQSxHQUFNLEdBQU07QUFDWixRQUFJd0IsT0FBTyxHQUFHLE1BQUksQ0FBQzFILEdBQUwsQ0FBUzFGLElBQVQsQ0FBYywwQkFBZCxFQUEwQ21GLElBQTFDLENBQStDLFNBQS9DLENBQWQ7O0FBQ0EsUUFBSWtJLE1BQU0sR0FBRyxNQUFJLENBQUMzSCxHQUFMLENBQVMxRixJQUFULENBQWMscUJBQWQsRUFBcUNYLEdBQXJDLEdBQTJDdUksS0FBM0MsQ0FBaUQsSUFBakQsQ0FBYjs7QUFDQSxVQUFJLENBQUNqSSxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0J1QixXQUF4QixDQUFvQyxDQUFDd2YsT0FBckM7O0FBQ0EsVUFBSSxDQUFDek4sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixDQUFnQ2tkLE1BQWhDO0FBQ0gsR0FMRDs7QUFNQSxPQUFLbEIsT0FBTCxDQUFhLHdCQUFiLGtLQUlxQ3ZlLFdBSnJDLG9NQVF5RHNmLFNBUnpELDhNQWFEdEIsR0FiQyxFQWFJLEtBQUtDLEVBYlQsRUFhYSxNQWJiLEVBVDhDLENBdUI5QztBQUNILENBeEJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hMQTtBQUVPLFNBQVNoYyxVQUFULENBQW9CbEcsS0FBcEIsRUFBMkIwVSxLQUEzQixFQUFrQztBQUNyQyxNQUFJaVAsVUFBVSxHQUFHLElBQUkxTyxVQUFKLEVBQWpCO0FBQ0EsTUFBSXRHLEtBQUssR0FBRytGLEtBQUssQ0FBQ0UsTUFBTixDQUFhakcsS0FBekI7O0FBQ0FnVixZQUFVLENBQUN6TyxNQUFYLEdBQXFCLFVBQUFDLENBQUM7QUFBQSxXQUNsQm5WLEtBQUssQ0FBQzhLLEVBQU4sQ0FBUzRGLE9BQVQsQ0FBaUJ4RixPQUFqQixHQUEyQmhGLFVBQTNCLENBQXNDaVAsQ0FBdEMsQ0FEa0I7QUFBQSxHQUF0Qjs7QUFHQXdPLFlBQVUsQ0FBQ25PLFFBQVgsR0FBc0I3RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVN0TyxJQUEvQjtBQUNBc2pCLFlBQVUsQ0FBQ2xPLFVBQVgsQ0FBc0I5RyxLQUFLLENBQUMsQ0FBRCxDQUEzQjtBQUNBK0YsT0FBSyxDQUFDRSxNQUFOLENBQWE0SixLQUFiLEdBQXFCLEVBQXJCO0FBQ0g7QUFFTSxTQUFTb0YsUUFBVCxDQUFrQjNOLElBQWxCLEVBQXdCO0FBQzNCLFNBQU9BLElBQUksQ0FBQzROLE9BQUwsQ0FBYSxhQUFiLEVBQTRCLEdBQTVCLEVBQWlDcFgsV0FBakMsRUFBUDtBQUNIO0FBRU0sU0FBU3pHLFlBQVQsQ0FBc0JoRyxLQUF0QixFQUE2QjBVLEtBQTdCLEVBQW9DO0FBQUEsOEJBQ0sxVSxLQUFLLENBQUM4SyxFQUFOLENBQVM0RixPQUFULENBQWlCeEYsT0FBakIsR0FBMkJsRixZQUEzQixFQURMO0FBQUEsTUFDbEMzRixJQURrQyx5QkFDbENBLElBRGtDO0FBQUEsTUFDNUJ5akIsU0FENEIseUJBQzVCQSxTQUQ0QjtBQUFBLE1BQ2pCN1MsUUFEaUIseUJBQ2pCQSxRQURpQjtBQUFBLE1BQ1A4UyxRQURPLHlCQUNQQSxRQURPLEVBRXZDOzs7QUFDQTFqQixNQUFJLEdBQUd1akIsUUFBUSxDQUFDdmpCLElBQUQsQ0FBZjtBQUNBQSxNQUFJLEdBQUdBLElBQUksR0FBR3lqQixTQUFkLENBSnVDLENBS3ZDOztBQUNBLE1BQUlFLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVMsQ0FBQ2hULFFBQUQsQ0FBVCxFQUFxQjtBQUFDclEsUUFBSSxFQUFFbWpCO0FBQVAsR0FBckIsQ0FBWDs7QUFDQSxNQUFJRyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGdCQUFyQixFQUF1QztBQUNuQ0YsVUFBTSxDQUFDQyxTQUFQLENBQWlCRSxVQUFqQixDQUE0QkwsSUFBNUIsRUFBa0MzakIsSUFBbEM7QUFDSCxHQUZELE1BRU07QUFDRixRQUFJaWtCLHFCQUFxQixHQUFHSixNQUFNLENBQUMxSyxRQUFQLENBQWdCQyxhQUFoQixDQUE4QixHQUE5QixDQUE1QjtBQUNBNksseUJBQXFCLENBQUNDLElBQXRCLEdBQTZCTCxNQUFNLENBQUNNLEdBQVAsQ0FBV0MsZUFBWCxDQUEyQlQsSUFBM0IsQ0FBN0I7QUFDQU0seUJBQXFCLENBQUM1UyxRQUF0QixHQUFpQ3JSLElBQWpDO0FBQ0FtWixZQUFRLENBQUN5SCxJQUFULENBQWN5RCxXQUFkLENBQTBCSixxQkFBMUI7QUFDQUEseUJBQXFCLENBQUM3SSxLQUF0QjtBQUNBakMsWUFBUSxDQUFDeUgsSUFBVCxDQUFjMEQsV0FBZCxDQUEwQkwscUJBQTFCO0FBQ0g7QUFDSjtBQUVNLElBQU1NLGNBQWI7QUFDSSwwQkFBWTVPLElBQVosRUFBa0IrRixHQUFsQixFQUF1QjtBQUFBOztBQUNuQixTQUFLL0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSytGLEdBQUwsR0FBV0EsR0FBWDtBQUVBLFNBQUt6UyxVQUFMLEdBQWtCME0sSUFBSSxDQUFDek4sVUFBTCxDQUFnQmUsVUFBbEM7QUFDQSxTQUFLM0csUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUtzTSxJQUFMLEdBQVksSUFBWjtBQUNIOztBQVJMO0FBQUE7QUFBQSxpQ0FVaUI7QUFDVCxXQUFLM0YsVUFBTCxDQUFnQnNHLFVBQWhCLENBQTJCLEtBQUtqTixRQUFoQztBQUNBLFdBQUtxVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JDLFFBQXhCLENBQWlDLFdBQWpDO0FBQ0EsV0FBS3FULElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtSSxPQUFyQixDQUE2Qm1VLFlBQTdCLENBQTBDLFdBQTFDO0FBQ0g7QUFkTDtBQUFBO0FBQUEsb0NBZ0JvQjtBQUNaO0FBQ0EsV0FBSzdPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkMsUUFBeEIsQ0FBaUMsV0FBakM7QUFDQSxXQUFLcVQsSUFBTCxDQUFVek4sVUFBVixDQUFxQm1JLE9BQXJCLENBQTZCbVUsWUFBN0IsQ0FBMEMsV0FBMUM7QUFDSDtBQXBCTDtBQUFBO0FBQUEsa0NBc0JrQjVWLElBdEJsQixFQXNCd0I7QUFDaEIsVUFBSUEsSUFBSSxDQUFDdE0sUUFBTCxLQUFrQixLQUFLQSxRQUEzQixFQUFxQztBQUNqQztBQUNBLGFBQUtxVCxJQUFMLENBQVV6TixVQUFWLENBQXFCbUksT0FBckIsQ0FBNkJtVSxZQUE3QixDQUEwQyxLQUFLbGlCLFFBQS9DLEVBRmlDLENBR2pDO0FBQ0E7QUFDSDtBQUNKO0FBN0JMO0FBQUE7QUFBQSx1Q0ErQnVCO0FBQ2YsV0FBSzJHLFVBQUwsQ0FBZ0J3YixTQUFoQixDQUEwQixLQUFLbmlCLFFBQS9CLEVBQXlDO0FBQ3JDb2lCLGVBQU8sRUFBRSxLQUFLQyxhQUFMLENBQW1CdlQsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FENEI7QUFFckN3VCxlQUFPLEVBQUUsS0FBS0MsYUFBTCxDQUFtQnpULElBQW5CLENBQXdCLElBQXhCO0FBRjRCLE9BQXpDO0FBSUg7QUFwQ0w7QUFBQTtBQUFBLDBCQXNDVTBULFdBdENWLEVBc0N1QkMsU0F0Q3ZCLEVBc0NrQztBQUMxQixXQUFLemlCLFFBQUwsR0FBZ0J3aUIsV0FBaEI7QUFDQSxXQUFLbFcsSUFBTCxHQUFZLEtBQUszRixVQUFMLENBQWdCNEcsT0FBaEIsQ0FBd0JpVixXQUF4QixDQUFaO0FBQ0EsV0FBS0UsZ0JBQUw7QUFDSDtBQUVEOzs7Ozs7O0FBNUNKO0FBQUE7QUFBQSx5QkFrRFNGLFdBbERULEVBa0RzQkMsU0FsRHRCLEVBa0RpQ0UsU0FsRGpDLEVBa0Q0QztBQUNwQyxXQUFLaGMsVUFBTCxDQUFnQmljLGdCQUFoQixDQUFpQyxLQUFLNWlCLFFBQXRDO0FBQ0EsV0FBS3NNLElBQUwsR0FBWSxJQUFaO0FBQ0EsV0FBS3RNLFFBQUwsR0FBZ0IsSUFBaEI7QUFDSDtBQXRETDtBQUFBO0FBQUEsK0JBd0RlK1IsS0F4RGYsRUF3RHNCO0FBQ2QsVUFBSS9SLFFBQVEsR0FBRytSLEtBQUssQ0FBQ0UsTUFBTixDQUFhWSxRQUE1QjtBQUNBLFVBQUl2RSxRQUFRLEdBQUd5RCxLQUFLLENBQUNFLE1BQU4sQ0FBYVUsTUFBNUI7QUFDQSxXQUFLckcsSUFBTCxDQUFVbUIsTUFBVixDQUFpQmEsUUFBakI7QUFDSDtBQTVETDtBQUFBO0FBQUEsbUNBOERtQjtBQUNYLFVBQUl0TyxRQUFRLEdBQUdnVSxnREFBTyxDQUFDNk8sYUFBUixDQUFzQixLQUFLN2lCLFFBQTNCLENBQWY7QUFDQSxhQUFPO0FBQ0h0QyxZQUFJLEVBQUVzQyxRQUFRLENBQUN0QyxJQURaO0FBRUh5akIsaUJBQVMsRUFBRW5oQixRQUFRLENBQUMvQixJQUZqQjtBQUdIcVEsZ0JBQVEsRUFBRSxLQUFLaEMsSUFBTCxDQUFVbUIsTUFBVixFQUhQO0FBSUgyVCxnQkFBUSxFQUFFO0FBSlAsT0FBUDtBQU1IO0FBdEVMOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUVBLElBQU0wQixtQkFBbUIsR0FBRyxDQUN4QixDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFFBQXZCLEVBQWlDLFNBQWpDLEVBQTRDLHNEQUE1QyxDQUR3QixFQUV4QixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLFNBQWpCLEVBQTRCLE1BQTVCLEVBQW9DLDJJQUFwQyxDQUZ3QixFQUd4QixDQUFDLFVBQUQsRUFBYSxVQUFiLEVBQXlCLEVBQXpCLEVBQTZCLFFBQTdCLEVBQXVDLGtHQUF2QyxDQUh3QixFQUl4QjtBQUNBLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIxaUIsb0RBQVksQ0FBQ0MsS0FBekMsRUFBZ0RELG9EQUFoRCxFQUE4RCx5RUFBOUQsQ0FMd0IsRUFNeEIsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixFQUF6QixFQUE2QixRQUE3QixFQUF1Qyw2RUFBdkMsQ0FOd0IsRUFPeEIsQ0FBQyxnQkFBRCxFQUFtQixpQkFBbkIsRUFBc0MsS0FBdEMsRUFBNkMsTUFBN0MsRUFBcUQsMEdBQXJELENBUHdCLEVBUXhCLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIsS0FBNUIsRUFBbUMsTUFBbkMsRUFBMkMsK0RBQTNDLENBUndCLEVBU3hCLENBQUMsaUJBQUQsRUFBb0Isa0JBQXBCLEVBQXdDLEtBQXhDLEVBQStDLE1BQS9DLEVBQXVELDRFQUF2RCxDQVR3QixFQVV4QixDQUFDLHNCQUFELEVBQXlCLHdCQUF6QixFQUFtRCxLQUFuRCxFQUEwRCxNQUExRCxFQUFrRSwyTkFBbEUsQ0FWd0IsRUFXeEIsQ0FBQyxtQkFBRCxFQUFzQixxQkFBdEIsRUFBNkMsS0FBN0MsRUFBb0QsTUFBcEQsRUFBNEQsNEhBQTVELENBWHdCLEVBWXhCLENBQUMsYUFBRCxFQUFnQixjQUFoQixFQUFnQyxLQUFoQyxFQUF1QyxNQUF2QyxFQUErQyxxRUFBL0MsQ0Fad0IsRUFheEIsQ0FBQyxjQUFELEVBQWlCLGVBQWpCLEVBQWtDLEtBQWxDLEVBQXlDLE1BQXpDLEVBQWlELHFIQUFqRCxDQWJ3QixFQWN4QixDQUFDLGFBQUQsRUFBZ0IsY0FBaEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsMkRBQS9DLENBZHdCLEVBZXhCLENBQUMsY0FBRCxFQUFpQixXQUFqQixFQUE4QixLQUE5QixFQUFxQyxNQUFyQyxFQUE2Qyw2RUFBN0MsQ0Fmd0IsRUFnQnhCLENBQUMsY0FBRCxFQUFpQixZQUFqQixFQUErQixJQUEvQixFQUFxQyxNQUFyQyxFQUE2QywwR0FBN0MsQ0FoQndCLEVBaUJ4QixDQUFDLFVBQUQsRUFBYSxXQUFiLEVBQTBCLEtBQTFCLEVBQWlDLE1BQWpDLEVBQXlDLHdMQUF6QyxDQWpCd0IsRUFrQnhCLENBQUMsaUJBQUQsRUFBb0Isa0JBQXBCLEVBQXdDLEtBQXhDLEVBQStDLE1BQS9DLEVBQXVELDRIQUF2RCxDQWxCd0IsRUFtQnhCLENBQUMsYUFBRCxFQUFnQixjQUFoQixFQUFnQyxLQUFoQyxFQUF1QyxNQUF2QyxFQUErQywyR0FBL0MsQ0FuQndCLEVBb0J4QjtBQUNBLENBQUMsZ0JBQUQsRUFBbUIsaUJBQW5CLEVBQXNDLEtBQXRDLEVBQTZDLE1BQTdDLEVBQXFELGlHQUFyRCxDQXJCd0IsRUFzQnhCLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIsSUFBNUIsRUFBa0MsTUFBbEMsRUFBMEMsZ0VBQTFDLENBdEJ3QixFQXVCeEIsQ0FBQyxrQkFBRCxFQUFxQixvQkFBckIsRUFBMkMsS0FBM0MsRUFBa0QsTUFBbEQsRUFBMEQsNkhBQTFELENBdkJ3QixFQXdCeEIsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDLEVBQStDLGlEQUEvQyxDQXhCd0IsRUF5QnhCLENBQUMsaUJBQUQsRUFBb0IsbUJBQXBCLEVBQXlDLEtBQXpDLEVBQWdELE1BQWhELEVBQXdELDREQUF4RCxDQXpCd0IsRUEwQnhCLENBQUMsU0FBRCxFQUFZLFVBQVosRUFBd0IsS0FBeEIsRUFBK0IsTUFBL0IsRUFBdUMsOERBQXZDLENBMUJ3QixFQTJCeEIsQ0FBQyxjQUFELEVBQWlCLGVBQWpCLEVBQWtDLEtBQWxDLEVBQXlDLE1BQXpDLEVBQWlELG1FQUFqRCxDQTNCd0IsRUE0QnhCLENBQUMsMEJBQUQsRUFBNkIsNkJBQTdCLEVBQTRELEtBQTVELEVBQW1FLE1BQW5FLEVBQTJFLGtFQUEzRSxDQTVCd0IsRUE2QnhCO0FBQ0EsQ0FBQyxzQkFBRCxFQUF5Qix3QkFBekIsRUFBbUQsS0FBbkQsRUFBMEQsTUFBMUQsRUFBa0UsaUlBQWxFLENBOUJ3QixFQStCeEIsQ0FBQyxvQkFBRCxFQUF1QixzQkFBdkIsRUFBK0MsS0FBL0MsRUFBc0QsTUFBdEQsRUFBOEQsMkRBQTlELENBL0J3QixFQWdDeEIsQ0FBQyxrQkFBRCxFQUFxQixvQkFBckIsRUFBMkMsS0FBM0MsRUFBa0QsTUFBbEQsRUFBMEQsb0ZBQTFELENBaEN3QixDQUE1QjtBQW1DTyxJQUFJbEMsYUFBYSxHQUFHO0FBQ3ZCQyxTQUFPLEVBQUUsU0FEYztBQUV2QjRrQixNQUFJLEVBQUUsTUFGaUI7QUFHdkJDLE1BQUksRUFBRSxNQUhpQjtBQUl2QkMsU0FBTyxFQUFFO0FBSmMsQ0FBcEI7O0FBT1AsU0FBU0MsZ0JBQVQsQ0FBMEJ4bEIsSUFBMUIsRUFBZ0M7QUFDNUIsT0FBSyxJQUFJOGQsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHc0gsbUJBQW1CLENBQUN2VyxNQUF0QyxFQUE4Q2lQLENBQUMsRUFBL0MsRUFBbUQ7QUFDL0MsUUFBSXNILG1CQUFtQixDQUFDdEgsQ0FBRCxDQUFuQixDQUF1QixDQUF2QixNQUE4QjlkLElBQWxDLEVBQXdDO0FBQ3BDLGFBQU9vbEIsbUJBQW1CLENBQUN0SCxDQUFELENBQW5CLENBQXVCLENBQXZCLENBQVA7QUFDSDtBQUNKOztBQUNELFNBQU8sbUNBQVA7QUFDSDs7QUFFRCxTQUFTMkgsZ0JBQVQsQ0FBMEJ6bEIsSUFBMUIsRUFBZ0MwbEIsSUFBaEMsRUFBc0NDLElBQXRDLEVBQTRDO0FBQ3hDLHNLQUM0RUEsSUFENUUsK0ZBRTJFQSxJQUYzRSx3REFHa0NELElBSGxDLDRIQUk0RjFsQixJQUo1RjtBQU1IOztBQUVELElBQU00bEIsMkNBQTJDLEdBQUdSLG1CQUFtQixDQUNuRTtBQURtRSxDQUVsRVMsTUFGK0MsQ0FFeEMsVUFBQ0MsT0FBRDtBQUFBLFNBQWFBLE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZSxNQUE1QjtBQUFBLENBRndDLEVBRy9DclYsR0FIK0MsQ0FHM0MsVUFBQ3FWLE9BQUQsRUFBYTtBQUNkLE1BQUlDLFVBQVUsR0FBR0QsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXbEksS0FBWCxDQUFpQixHQUFqQixFQUFzQm5OLEdBQXRCLENBQTBCLFVBQUF1VixJQUFJO0FBQUEsV0FBR0EsSUFBSSxDQUFDdEksTUFBTCxDQUFZLENBQVosRUFBZXVJLFdBQWYsS0FBNkJELElBQUksQ0FBQzVWLEtBQUwsQ0FBVyxDQUFYLENBQWhDO0FBQUEsR0FBOUIsRUFBOEUrUyxJQUE5RSxDQUFtRixHQUFuRixDQUFqQjtBQUNBLHVMQUdnRTJDLE9BQU8sQ0FBQyxDQUFELENBSHZFLGdCQUcrRUMsVUFIL0UsMk5BT21GRCxPQUFPLENBQUMsQ0FBRCxDQVAxRiw4RUFRc0RBLE9BQU8sQ0FBQyxDQUFELENBUjdELDhMQWFjQSxPQUFPLENBQUMsQ0FBRCxDQWJyQjtBQWtCSCxDQXZCK0MsRUF1QjdDM0MsSUF2QjZDLENBdUJ4QyxNQXZCd0MsQ0FBcEQ7QUF5Qk8sSUFBTStDLCtCQUErQixtMEpBdUd0QlQsZ0JBQWdCLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIvaUIsb0RBQVksQ0FBQ3lqQixLQUFwQyxDQXZHTSxtQ0F3R3RCVixnQkFBZ0IsQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQi9pQixvREFBWSxDQUFDQyxLQUFsQyxDQXhHTSxtQ0F5R3RCOGlCLGdCQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCL2lCLG9EQUFZLENBQUMyVSxJQUFwQyxDQXpHTSwwTEE4R3RCbU8sZ0JBQWdCLENBQUMsV0FBRCxDQTlHTSxxNENBdUl0QkEsZ0JBQWdCLENBQUMsVUFBRCxDQXZJTSxtaEJBa0p0QkEsZ0JBQWdCLENBQUMsVUFBRCxDQWxKTSx3NkJBb0t0QkEsZ0JBQWdCLENBQUMsU0FBRCxDQXBLTSxzd0JBb0x0QkEsZ0JBQWdCLENBQUMsTUFBRCxDQXBMTSwrRkF5TGxDSSwyQ0F6TGtDLHNDQUFyQztBQStMQSxTQUFTUSxzQkFBVCxDQUFnQ3ptQixLQUFoQyxFQUF1QztBQUMxQyxNQUFJaUMsUUFBUSxHQUFHLEVBQWY7QUFDQXdqQixxQkFBbUIsQ0FBQ25HLE9BQXBCLENBQTRCLFVBQUE2RyxPQUFPLEVBQUk7QUFDbkMsUUFBSU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFFBQTZCUSxVQUFVLEdBQUdSLE9BQU8sQ0FBQyxDQUFELENBQWpEO0FBQUEsUUFBc0R6bUIsWUFBWSxHQUFHeW1CLE9BQU8sQ0FBQyxDQUFELENBQTVFO0FBQ0EsUUFBSTNILEtBQUssR0FBR3hlLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQnlrQixVQUExQixHQUFaLENBRm1DLENBR25DOztBQUNBLFFBQUlsSSxLQUFLLEtBQUs5ZSxZQUFkLEVBQTRCO0FBQ3hCdUMsY0FBUSxDQUFDMGtCLFVBQUQsQ0FBUixHQUF1Qm5JLEtBQXZCO0FBQ0g7QUFDSixHQVBEO0FBUUEsU0FBT2pQLElBQUksQ0FBQ0MsU0FBTCxDQUFldk4sUUFBZixDQUFQO0FBQ0g7QUFFTSxTQUFTb0ksc0JBQVQsQ0FBZ0NySyxLQUFoQyxFQUF1Q2lDLFFBQXZDLEVBQWlEO0FBQ3BELE1BQUlBLFFBQUosRUFBYztBQUNWQSxZQUFRLEdBQUdzTixJQUFJLENBQUM4RixLQUFMLENBQVdwVCxRQUFYLENBQVg7QUFDQXdqQix1QkFBbUIsQ0FBQ25HLE9BQXBCLENBQTRCLFVBQUE2RyxPQUFPLEVBQUk7QUFDbkMsVUFBSU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFVBQTZCUSxVQUFVLEdBQUdSLE9BQU8sQ0FBQyxDQUFELENBQWpEOztBQUNBLFVBQUlRLFVBQVUsSUFBSTFrQixRQUFsQixFQUE0QjtBQUN4QmpDLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQnlrQixVQUExQixFQUFzQ3prQixRQUFRLENBQUMwa0IsVUFBRCxDQUE5QztBQUNILE9BRkQsTUFFTztBQUNIM21CLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQnlrQixVQUExQixFQUFzQ1AsT0FBTyxDQUFDLENBQUQsQ0FBN0M7QUFDSDtBQUNKLEtBUEQ7O0FBU0EsUUFBSWxrQixRQUFRLENBQUMya0IsVUFBYixFQUF5QjtBQUNyQjVtQixXQUFLLENBQUMwQyxPQUFOLENBQWNJLFVBQWQsQ0FBeUJiLFFBQVEsQ0FBQzJrQixVQUFsQztBQUNIO0FBQ0o7QUFDSjtBQUVNLFNBQVMxa0IsMkJBQVQsQ0FBcUN4RCxhQUFyQyxFQUFvRDtBQUN2RCxNQUFJdUQsUUFBUSxHQUFHLEVBQWY7QUFDQXdqQixxQkFBbUIsQ0FBQ25HLE9BQXBCLENBQTRCLFVBQUE2RyxPQUFPLEVBQUk7QUFDbkMsUUFBSU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFFBQTZCUSxVQUFVLEdBQUdSLE9BQU8sQ0FBQyxDQUFELENBQWpEO0FBQUEsUUFBc0R6bUIsWUFBWSxHQUFHeW1CLE9BQU8sQ0FBQyxDQUFELENBQTVFO0FBQUEsUUFDSVUsU0FBUyxHQUFHVixPQUFPLENBQUMsQ0FBRCxDQUR2Qjs7QUFFQSxRQUFJem5CLGFBQWEsQ0FBQyx5QkFBdUJpb0IsVUFBeEIsQ0FBYixLQUFxRDduQixTQUF6RCxFQUFvRTtBQUNoRW1ELGNBQVEsQ0FBQ3lrQixVQUFELENBQVIsR0FBdUJ2bUIsRUFBRSxDQUFDQyxVQUFILENBQWNWLFlBQWQsQ0FBdkI7QUFDSCxLQUZELE1BRU87QUFDSCxVQUFJb25CLFdBQVcsR0FBR3BvQixhQUFhLENBQUMseUJBQXVCaW9CLFVBQXhCLENBQS9COztBQUNBLFVBQUlFLFNBQVMsS0FBSyxNQUFsQixFQUEwQjtBQUN0QkMsbUJBQVcsR0FBR0EsV0FBVyxDQUFDcmEsV0FBWixPQUE4QixNQUE1QztBQUNIOztBQUNEeEssY0FBUSxDQUFDeWtCLFVBQUQsQ0FBUixHQUF1QnZtQixFQUFFLENBQUNDLFVBQUgsQ0FBYzBtQixXQUFkLENBQXZCO0FBQ0g7QUFDSixHQVpEO0FBY0EsU0FBTzdrQixRQUFQO0FBQ0g7O0lBRUs4a0Isc0I7Ozs7O0FBQ0Ysa0NBQVkvUSxJQUFaLEVBQWtCK0YsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU0vRixJQUFOLEVBQVkrRixHQUFaO0FBQ0EsVUFBS2lMLEtBQUwsR0FBYSxLQUFiO0FBRm1CO0FBR3RCOzs7OzBCQUVLN0IsVyxFQUFhQyxTLEVBQVc7QUFDMUIsd0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs0QixLQUFMLEdBQWEsS0FBYixDQUYwQixDQUcxQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFLQyxlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0J6VixJQUFsQixDQUF1QixJQUF2QixDQUF2QixDQVAwQixDQVMxQjtBQUNIOzs7aUNBRVkwVixXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWIsQ0FEWSxDQUVaOztBQUVBLGFBQUtBLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZdFMsSyxFQUFPO0FBQ2hCLFdBQUtzUyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYixDQURZLENBRVo7QUFDQTs7QUFDQSxhQUFLQSxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBV0gsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQTVDZ0NSLCtEOztBQStDOUIsSUFBTXdDLGtCQUFrQixHQUFHO0FBQzlCL21CLE1BQUksRUFBRSxxQkFEd0I7QUFFOUJnbkIsWUFBVSxFQUFFLENBQUMsOEJBQUQsQ0FGa0I7QUFHOUJDLGFBQVcsRUFBRVAsc0JBSGlCO0FBSTlCUSxVQUFRLEVBQUVoQjtBQUpvQixDQUEzQixDOzs7Ozs7Ozs7Ozs7O0FDdFhQO0FBQUE7QUFBTyxJQUFNaUIsY0FBYyxnNUNBQXBCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZQO0FBRU8sSUFBTUMsaUJBQWlCLHNnQ0FBdkI7O0lBMEJEQyxlOzs7OztBQUNGLDJCQUFZMVIsSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUEsNkJBQ2IvRixJQURhLEVBQ1ArRixHQURPO0FBRXRCOzs7OzBCQUVLb0osVyxFQUFhQyxTLEVBQVc7QUFDMUIsaUZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUVBLFVBQUk5Z0IsYUFBYSxHQUFHLEtBQUswUixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0I0QixhQUF4QixFQUFwQjs7QUFDQSxVQUFJQSxhQUFhLEtBQUssSUFBdEIsRUFBNEI7QUFDeEIsYUFBS2lQLFlBQUw7QUFDSDs7QUFFRCxXQUFLb1UsbUJBQUwsR0FBMkIsS0FBSzFZLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUI2RyxTQUFqQixDQUEyQixLQUFLMUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0I7QUFDQTs7Ozs7O0FBT0g7OzttQ0FFYztBQUFBOztBQUNYLFdBQUt1RSxJQUFMLENBQVV6TixVQUFWLENBQXFCQyxNQUFyQixDQUE0QjFDLGlCQUE1QixDQUE4QyxVQUFDNE0sUUFBRCxFQUFjO0FBQ3hELFlBQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQixlQUFJLENBQUNxRCxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0I0QixhQUF4QixDQUFzQ29PLFFBQVEsQ0FBQy9ELEtBQS9DO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZUFBSSxDQUFDcUgsSUFBTCxDQUFVek4sVUFBVixDQUFxQnFmLE9BQXJCLENBQTZCL0UsNEJBQTdCLENBQTBEblEsUUFBUSxDQUFDcEwsT0FBbkU7QUFDSDtBQUNKLE9BTkQ7QUFPSDs7O2lDQUVZNmYsVyxFQUFhLENBRXpCOzs7aUNBRVl6UyxLLEVBQU87QUFDaEI7Ozs7OztBQU1IOzs7eUJBRUl5USxXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3FDLG1CQUFMLENBQXlCRSxPQUF6Qjs7QUFDQSxnRkFBVzFDLFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUFsRHlCUiwrRDs7QUFxRHZCLElBQU1rRCxXQUFXLEdBQUc7QUFDdkJ6bkIsTUFBSSxFQUFFLE9BRGlCO0FBRXZCZ25CLFlBQVUsRUFBRSxDQUFDLGlCQUFELENBRlc7QUFHdkJDLGFBQVcsRUFBRUksZUFIVTtBQUl2QkgsVUFBUSxFQUFFRTtBQUphLENBQXBCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRlA7QUFDQTtBQUVPLElBQU1NLGdCQUFnQixtQkFDdkJQLDhEQUR1Qiw0RkFBdEI7O0lBT0RRLGM7Ozs7O0FBQ0YsMEJBQVloUyxJQUFaLEVBQWtCK0YsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU0vRixJQUFOLEVBQVkrRixHQUFaO0FBQ0EsVUFBS2pLLFVBQUwsR0FBa0JtVyxVQUFVLENBQUNDLFlBQVgsQ0FBd0JuTSxHQUFHLENBQUMxRixJQUFKLENBQVMsc0JBQVQsRUFBaUMsQ0FBakMsQ0FBeEIsRUFBNkQ7QUFDM0U4Uiw2QkFBdUIsRUFBRSxJQURrRDtBQUUzRUMsaUJBQVcsRUFBRSxJQUY4RDtBQUczRUMscUJBQWUsRUFBRSxDQUgwRDtBQUkzRUMsZ0JBQVUsRUFBRSxDQUorRDtBQUszRUMsYUFBTyxFQUFFLENBTGtFO0FBTTNFQyxvQkFBYyxFQUFFLEtBTjJEO0FBTzNFeEMsVUFBSSxFQUFFLE1BUHFFO0FBUTNFeUMsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUIwVyxjQUFFLENBQUMzVyxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIMlcsY0FBRSxDQUFDaG1CLE9BQUgsQ0FBVzhELEtBQVgsQ0FBaUJtaUIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDM1csU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQzJXLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVJnRSxLQUE3RCxDQUFsQjtBQXVCQSxVQUFLZ1YsS0FBTCxHQUFhLEtBQWI7QUF6Qm1CO0FBMEJ0Qjs7OzswQkFFSzdCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLGdGQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNEIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLelUsWUFBTCxDQUFrQixLQUFLdEQsSUFBTCxDQUFVbUIsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLdVgsbUJBQUwsR0FBMkIsS0FBSzFZLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUI2RyxTQUFqQixDQUEyQixLQUFLMUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS3dWLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnpWLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBS0ssVUFBTCxDQUFnQnlRLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLEtBQUswRSxlQUFsQzs7QUFDQSxVQUFJN0IsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F3RCxrQkFBVSxDQUFDLEtBQUs5VyxVQUFMLENBQWdCbkgsT0FBaEIsQ0FBd0I4RyxJQUF4QixDQUE2QixLQUFLSyxVQUFsQyxDQUFELEVBQWdELENBQWhELENBQVY7QUFDSCxPQVp5QixDQWExQjs7O0FBQ0EsV0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0NvVCxXQUFXLENBQUMzVSxVQUFaLENBQXVCLEdBQXZCLEtBQStCLENBQUMsS0FBS3dGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBdEU7QUFFSDs7O2lDQUVZdWtCLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUtsVixVQUFMLENBQWdCK1csUUFBaEIsQ0FBeUIxQixXQUF6QjtBQUNBLGFBQUtyVixVQUFMLENBQWdCbkgsT0FBaEI7QUFDQSxhQUFLcWMsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVl0UyxLLEVBQU87QUFDaEIsV0FBS3NTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSy9YLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUIsS0FBSzBCLFVBQUwsQ0FBZ0JnWCxRQUFoQixFQUFqQjtBQUNBLGFBQUs5QixLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLcUMsbUJBQUwsQ0FBeUJFLE9BQXpCO0FBQ0EsV0FBSy9WLFVBQUwsQ0FBZ0JpWCxHQUFoQixDQUFvQixRQUFwQixFQUE4QixLQUFLOUIsZUFBbkM7QUFDQSxXQUFLblYsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEM7O0FBQ0EsK0VBQVdvVCxXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBeEV3QlIsK0Q7O0FBMkV0QixJQUFNb0UsVUFBVSxHQUFHO0FBQ3RCM29CLE1BQUksRUFBRSxNQURnQjtBQUV0QmduQixZQUFVLEVBQUUsQ0FBQyxPQUFELENBRlU7QUFHdEJDLGFBQVcsRUFBRVUsY0FIUztBQUl0QlQsVUFBUSxFQUFFUTtBQUpZLENBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRlA7QUFDQTtBQUVPLElBQU1rQixvQkFBb0IsbUJBQzNCekIsOERBRDJCLHdFQUExQjs7SUFNRDBCLGtCOzs7OztBQUNGLDhCQUFZbFQsSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNL0YsSUFBTixFQUFZK0YsR0FBWjtBQUNBLFVBQUtvTixHQUFMLEdBQVcsSUFBSWpULE9BQUosQ0FBWTtBQUNuQmtULGFBQU8sRUFBRXJOLEdBQUcsQ0FBQzFGLElBQUosQ0FBUywwQkFBVCxFQUFxQyxDQUFyQyxDQURVO0FBRW5CZ1QsNkJBQXVCLEVBQUUsS0FGTjtBQUduQkMsZUFBUyxFQUFFLElBSFE7QUFJbkJDLGVBQVMsRUFBRSxPQUpRO0FBS25CO0FBQ0E7QUFDQUMscUJBQWUsRUFBRTtBQUNiQyw4QkFBc0IsRUFBRTtBQURYLE9BUEU7QUFVbkJqQixvQkFBYyxFQUFFLEtBVkc7QUFXbkJELGFBQU8sRUFBRTtBQVhVLEtBQVosQ0FBWDtBQWFBLFVBQUt2QixLQUFMLEdBQWEsS0FBYjtBQWZtQjtBQWdCdEI7Ozs7MEJBRUs3QixXLEVBQWFDLFMsRUFBVztBQUMxQixvRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzRCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS3pVLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBS3VYLG1CQUFMLEdBQTJCLEtBQUsxWSxJQUFMLENBQVVtQixNQUFWLENBQWlCNkcsU0FBakIsQ0FBMkIsS0FBSzFFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUt3VixlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0J6VixJQUFsQixDQUF1QixJQUF2QixDQUF2QjtBQUNBLFdBQUswWCxHQUFMLENBQVNPLFVBQVQsQ0FBb0JuSCxFQUFwQixDQUF1QixRQUF2QixFQUFpQyxLQUFLMEUsZUFBdEM7O0FBQ0EsVUFBSTdCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBd0Qsa0JBQVUsQ0FBQyxLQUFLTyxHQUFMLENBQVNPLFVBQVQsQ0FBb0IvZSxPQUFwQixDQUE0QjhHLElBQTVCLENBQWlDLEtBQUswWCxHQUFMLENBQVNPLFVBQTFDLENBQUQsRUFBd0QsQ0FBeEQsQ0FBVjtBQUNIO0FBQ0o7OztpQ0FFWXZDLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUttQyxHQUFMLENBQVMzSyxLQUFULENBQWUySSxXQUFmO0FBQ0EsYUFBS2dDLEdBQUwsQ0FBU08sVUFBVCxDQUFvQi9lLE9BQXBCO0FBQ0EsYUFBS3FjLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZdFMsSyxFQUFPO0FBQ2hCLFdBQUtzUyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUsvWCxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUsrWSxHQUFMLENBQVMzSyxLQUFULEVBQWpCO0FBQ0EsYUFBS3dJLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJN0IsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUtxQyxtQkFBTCxDQUF5QkUsT0FBekI7QUFDQSxXQUFLc0IsR0FBTCxDQUFTTyxVQUFULENBQW9CWCxHQUFwQixDQUF3QixRQUF4QixFQUFrQyxLQUFLOUIsZUFBdkM7O0FBQ0EsbUZBQVc5QixXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBMUQ0QlIsK0Q7O0FBNkQxQixJQUFNK0UsY0FBYyxHQUFHO0FBQzFCdHBCLE1BQUksRUFBRSxVQURvQjtBQUUxQmduQixZQUFVLEVBQUUsQ0FBQyxLQUFELENBRmM7QUFHMUJDLGFBQVcsRUFBRTRCLGtCQUhhO0FBSTFCM0IsVUFBUSxFQUFFMEI7QUFKZ0IsQ0FBdkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RVA7Ozs7OztBQU1BOzs7O0FBSUE7QUFDQTtBQUVPLElBQUlsbUIsWUFBWSxHQUFHO0FBQ3RCeWpCLE9BQUssRUFBRSxPQURlO0FBRXRCeGpCLE9BQUssRUFBRSxPQUZlO0FBR3RCMFUsTUFBSSxFQUFFO0FBSGdCLENBQW5COztBQU1QLFNBQVNrUyxPQUFULENBQWlCdnBCLElBQWpCLEVBQXVCMGxCLElBQXZCLEVBQTZCQyxJQUE3QixFQUFtQztBQUMvQiwySkFDaUVBLElBRGpFLDhGQUUwRUEsSUFGMUUsd0RBR2tDRCxJQUhsQyxzSEFJc0YxbEIsSUFKdEY7QUFNSDs7QUFFTSxJQUFNd3BCLGtCQUFrQiw4dkJBZWpCRCxPQUFPLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUI3bUIsWUFBWSxDQUFDeWpCLEtBQXBDLENBZlUsMkJBZ0JqQm9ELE9BQU8sQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQjdtQixZQUFZLENBQUNDLEtBQWxDLENBaEJVLDJCQWlCakI0bUIsT0FBTyxDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCN21CLFlBQVksQ0FBQzJVLElBQXBDLENBakJVLGdpSUF3R3pCb1MsNkRBeEd5QiwwSEFBeEI7O0FBa0hQLFNBQVNDLG9CQUFULENBQThCNW5CLElBQTlCLEVBQW9DO0FBQ2hDLE1BQUk2bkIsS0FBSyxHQUFHemEsSUFBSSxDQUFDOEYsS0FBTCxDQUFXbFQsSUFBWCxDQUFaOztBQUNBLE1BQUk4bkIsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBU0MsSUFBVCxFQUFlO0FBQzFCLFFBQUlBLElBQUksQ0FBQ0MsU0FBTCxLQUFtQixNQUF2QixFQUErQjtBQUMzQixhQUFPRCxJQUFJLENBQUNFLE1BQUwsQ0FBWWxiLE1BQVosR0FBcUIsQ0FBckIsSUFDSCxDQUFDZ2IsSUFBSSxDQUFDRSxNQUFMLENBQVksQ0FBWixFQUFlNVosVUFBZixDQUEwQixHQUExQixDQURMO0FBRUgsS0FIRCxNQUdPO0FBQ0gsYUFBTzBaLElBQUksQ0FBQ0MsU0FBTCxLQUFtQixVQUFuQixJQUNIRCxJQUFJLENBQUNDLFNBQUwsS0FBbUIsS0FEdkI7QUFFSDtBQUNKLEdBUkQ7O0FBU0EsTUFBSUUsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBU0gsSUFBVCxFQUFlO0FBQzVCLFFBQUlBLElBQUksQ0FBQ0MsU0FBTCxLQUFtQixNQUF2QixFQUErQjtBQUMzQixhQUFPRCxJQUFJLENBQUNFLE1BQUwsQ0FBWTVHLElBQVosQ0FBaUIsSUFBakIsQ0FBUDtBQUNILEtBRkQsTUFFTyxJQUFJMEcsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLFVBQW5CLElBQ1BELElBQUksQ0FBQ0MsU0FBTCxLQUFtQixLQURoQixFQUN1QjtBQUMxQixhQUFPLFFBQU1ELElBQUksQ0FBQ0UsTUFBTCxDQUFZNUcsSUFBWixDQUFpQixJQUFqQixDQUFOLEdBQTZCLEtBQXBDO0FBQ0g7QUFDSixHQVBEOztBQVFBLFNBQU93RyxLQUFLLENBQUNNLEtBQU4sQ0FBWXBFLE1BQVosQ0FBbUIrRCxRQUFuQixFQUE2Qm5aLEdBQTdCLENBQWlDdVosVUFBakMsRUFBNkM3RyxJQUE3QyxDQUFrRCxJQUFsRCxDQUFQO0FBQ0g7O0lBRUsrRyxnQjs7Ozs7QUFDRiw0QkFBWXZVLElBQVosRUFBa0IrRixHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTS9GLElBQU4sRUFBWStGLEdBQUcsQ0FBQzFGLElBQUosQ0FBUyw2QkFBVCxDQUFaO0FBQ0FtVSxXQUFPLENBQUNDLGtCQUFSLENBQTJCelUsSUFBSSxDQUFDaFcsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QnFKLFNBQXpCLENBQW1DLENBQW5DLENBQTNCO0FBQ0EsVUFBSzJDLEVBQUwsR0FBVSxJQUFJZ2dCLFdBQUosQ0FBZ0I7QUFDdEIsbUJBQWEsTUFBSzNPLEdBQUwsQ0FBUyxDQUFULENBRFM7QUFFdEIsYUFBTy9GLElBQUksQ0FBQ3pOLFVBQUwsQ0FBZ0JnRSxNQUFoQixDQUF1QjJILEdBQXZCLENBQTJCekMsSUFBM0IsQ0FBZ0N1RSxJQUFJLENBQUN6TixVQUFMLENBQWdCZ0UsTUFBaEQsQ0FGZTtBQUd0QixvQkFBYyxJQUhRO0FBSXRCLDBCQUFvQnlKLElBQUksQ0FBQ2hXLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUJtSixXQUp2QjtBQUt0QixpQkFBV21PLElBQUksQ0FBQ2hXLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JzRCxRQUF0QixDQUErQjBvQixPQUEvQixFQUxXO0FBTXRCLG1CQUFhLElBTlM7QUFPdEJDLHVCQUFpQixFQUFFLDJCQUFDQyxNQUFELEVBQVk7QUFDM0IsZUFBT0EsTUFBUDtBQUNILE9BVHFCO0FBVXRCQyxxQkFBZSxFQUFFLHlCQUFDOUcsSUFBRCxFQUFVO0FBQ3ZCO0FBQ0EsZUFBTyxJQUFJOUksT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVTRQLE1BQVYsRUFBcUI7QUFDcEMsY0FBTUMsWUFBWSxHQUFHaFYsSUFBSSxDQUFDaFcsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnNCLEVBQXRCLEVBQXJCO0FBQ0E4VixjQUFJLENBQUN6TixVQUFMLENBQWdCQyxNQUFoQixDQUF1QnRDLFVBQXZCLENBQWtDLFlBQWxDLEVBQWdEOGtCLFlBQWhELEVBQThEaEgsSUFBSSxDQUFDM2pCLElBQW5FLEVBQXlFMmpCLElBQXpFLEVBQStFLFVBQUN0UixRQUFELEVBQWM7QUFDekZ5SSxtQkFBTyxDQUFDNUwsSUFBSSxDQUFDQyxTQUFMLENBQWVrRCxRQUFRLENBQUNyUSxRQUF4QixDQUFELENBQVAsQ0FEeUYsQ0FFekY7QUFDSCxXQUhELEVBRm9DLENBTXBDO0FBQ0E7QUFDSCxTQVJNLENBQVA7QUFTSCxPQXJCcUI7QUFzQnRCNG9CLHNCQUFnQixFQUFFLDBCQUFDSixNQUFELEVBQVk7QUFDMUI7QUFDQSwyQkFBV0EsTUFBWDtBQUNILE9BekJxQixDQTBCdEI7O0FBMUJzQixLQUFoQixDQUFWO0FBNkJBLFVBQUs3RCxLQUFMLEdBQWEsS0FBYjtBQUNBLFVBQUs1aUIsUUFBTCxHQUFnQixLQUFoQjs7QUFDQSxVQUFLOG1CLGlCQUFMOztBQUNBLFVBQUtDLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0EsVUFBS0MseUJBQUwsR0FBaUMsSUFBakM7QUFDQSxVQUFLalosYUFBTCxHQUFxQixNQUFLNkQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCSSxVQUF4QixFQUFyQjs7QUFFQSxVQUFLdW9CLDhCQUFMOztBQXZDbUI7QUF3Q3RCOzs7OzRDQUV1QjtBQUFBOztBQUNwQixXQUFLM2dCLEVBQUwsQ0FBUTJFLFdBQVIsQ0FBb0JpYyxTQUFwQixDQUE4QkMsb0JBQTlCLEdBQXFELFVBQUNDLE9BQUQsRUFBYTtBQUM5REEsZUFBTyxDQUFDalEsSUFBUixDQUFhO0FBQ1RrUSxpQkFBTyxFQUFFLElBREE7QUFFVHhWLGNBQUksRUFBRSxZQUZHO0FBR1R5VixrQkFBUSxFQUFFO0FBQUEsbUJBQU0sTUFBSSxDQUFDMVYsSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCd1gsaUJBQWxDO0FBQUE7QUFIRCxTQUFiO0FBS0gsT0FORDtBQU9IOzs7MEJBRUtpQyxXLEVBQWFDLFMsRUFBVztBQUFBOztBQUMxQixVQUFJdUcsV0FBVyxHQUFHLEtBQUtocEIsUUFBdkI7O0FBQ0Esa0ZBQVl3aUIsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzRCLEtBQUwsR0FBYSxLQUFiOztBQUVBLFVBQUk3QixXQUFXLEtBQUssV0FBcEIsRUFBaUM7QUFDN0IsWUFBSXdHLFdBQVcsS0FBSyxXQUFwQixFQUFpQztBQUM3QixlQUFLeFosYUFBTCxHQUFxQixLQUFLNkQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCSSxVQUF4QixFQUFyQjtBQUNIOztBQUNELGFBQUtrVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JJLFVBQXhCLENBQW1DQyxZQUFZLENBQUMyVSxJQUFoRDtBQUNILE9BTEQsTUFLTztBQUNILGFBQUsxQixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JJLFVBQXhCLENBQW1DLEtBQUtxUCxhQUF4QztBQUNIOztBQUVELFdBQUtJLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFkMEIsQ0FnQjFCOztBQUNBLFdBQUt1WCxtQkFBTCxHQUEyQixLQUFLMVksSUFBTCxDQUFVbUIsTUFBVixDQUFpQjZHLFNBQWpCLENBQTJCLEtBQUsxRSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQWpCMEIsQ0FtQjFCOztBQUNBLFdBQUttYSxpQkFBTCxHQUF5QixLQUFLMUUsWUFBTCxDQUFrQnpWLElBQWxCLENBQXVCLElBQXZCLENBQXpCO0FBQ0EsV0FBSy9HLEVBQUwsQ0FBUW1oQixpQkFBUixDQUEwQixLQUFLRCxpQkFBL0I7O0FBRUEsVUFBSXpHLFdBQVcsS0FBSyxXQUFwQixFQUFpQztBQUM3QixhQUFLemEsRUFBTCxDQUFRb2hCLFNBQVIsR0FBb0I7QUFBQSxpQkFBTSxLQUFOO0FBQUEsU0FBcEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLcGhCLEVBQUwsQ0FBUW9oQixTQUFSLEdBQW9CLEtBQUs5VixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQzZwQixTQUF4RDtBQUVBLGFBQUtYLHFCQUFMLEdBQTZCLEtBQUtuVixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0ksVUFBbkMsQ0FBOEN3UCxTQUE5QyxDQUF3RCxVQUFDOFUsS0FBRCxFQUFVO0FBQzNGLGlCQUFPLE1BQUksQ0FBQ3JoQixFQUFMLENBQVFzaEIsbUJBQVIsQ0FBNEJELEtBQTVCLEVBQW1DLG1CQUFuQyxDQUFQO0FBQ0gsU0FGNEIsQ0FBN0I7QUFHQSxhQUFLWCx5QkFBTCxHQUFpQyxLQUFLcFYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNLLGNBQW5DLENBQWtEdVAsU0FBbEQsQ0FBNEQsVUFBQzhVLEtBQUQ7QUFBQSxpQkFDekYsTUFBSSxDQUFDcmhCLEVBQUwsQ0FBUXNoQixtQkFBUixDQUE0QkQsS0FBNUIsRUFBbUMsdUJBQW5DLENBRHlGO0FBQUEsU0FBNUQsQ0FBakM7QUFHSCxPQWxDeUIsQ0FxQzFCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQW5ELGdCQUFVLENBQUM7QUFBQSxlQUFNLE1BQUksQ0FBQ2xlLEVBQUwsQ0FBUUMsT0FBUixFQUFOO0FBQUEsT0FBRCxFQUEwQixDQUExQixDQUFWO0FBQ0g7OztpQ0FFWXdjLFcsRUFBYTtBQUN0QixVQUFJQSxXQUFXLEtBQUtyb0IsU0FBcEIsRUFBK0I7QUFDM0IsWUFBSSxLQUFLbVEsSUFBTCxLQUFjLElBQWxCLEVBQXdCO0FBQ3BCa1kscUJBQVcsR0FBRyxLQUFLbFksSUFBTCxDQUFVbUIsTUFBVixFQUFkO0FBQ0gsU0FGRCxNQUVPO0FBQ0g7QUFDQStXLHFCQUFXLEdBQUcsRUFBZDtBQUNIO0FBQ0osT0FQRCxNQU9PLElBQUlBLFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUM3QjtBQUNBLGFBQUtuUixJQUFMLENBQVV6TixVQUFWLENBQXFCZSxVQUFyQixDQUFnQzJpQixrQkFBaEMsQ0FBbUQsS0FBS3RwQixRQUF4RDtBQUNBO0FBQ0g7O0FBQ0QsV0FBS3FrQixLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUt0YyxFQUFMLENBQVF3aEIsT0FBUixDQUFnQi9FLFdBQWhCLEVBRlksQ0FHWjs7QUFDQSxhQUFLSCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWXRTLEssRUFBTztBQUNoQixXQUFLaEssRUFBTCxDQUFReWhCLHFCQUFSO0FBRUEsV0FBS25GLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiOztBQUNBLFlBQUksQ0FBQyxLQUFLaFIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCTyxXQUF4QixFQUFMLEVBQTRDO0FBQ3hDLGVBQUtnTSxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUsxRixFQUFMLENBQVEwaEIsT0FBUixFQUFqQjtBQUNIOztBQUNELGFBQUtwRixLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLMEIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLVyxtQkFBTCxDQUF5QkUsT0FBekI7QUFDQSxXQUFLbmQsRUFBTCxDQUFRMmhCLG9CQUFSLENBQTZCLEtBQUtULGlCQUFsQzs7QUFDQSxVQUFJLEtBQUs1VixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JPLFdBQXhCLEVBQUosRUFBMkM7QUFDdkMsYUFBSytTLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0I4SyxFQUFoQixDQUFtQjRGLE9BQW5CLENBQTJCbUIsTUFBM0IsQ0FBa0NTLGtCQUFsQztBQUNIOztBQUNELFdBQUtnYSxzQkFBTDs7QUFDQSxpRkFBV25ILFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs2Q0FFd0I7QUFDckIsV0FBSzFhLEVBQUwsQ0FBUXloQixxQkFBUjs7QUFDQSxVQUFJLEtBQUtoQixxQkFBVCxFQUFnQztBQUM1QixhQUFLQSxxQkFBTCxDQUEyQnRELE9BQTNCO0FBQ0EsYUFBS3NELHFCQUFMLEdBQTZCLElBQTdCO0FBQ0g7O0FBQ0QsVUFBSSxLQUFLQyx5QkFBVCxFQUFvQztBQUNoQyxhQUFLQSx5QkFBTCxDQUErQnZELE9BQS9CO0FBQ0EsYUFBS3VELHlCQUFMLEdBQWlDLElBQWpDO0FBQ0g7QUFDSjs7O3dDQUVtQjtBQUFBOztBQUNoQixXQUFLMWdCLEVBQUwsQ0FBUTZoQixPQUFSLENBQWdCLEtBQUt2VyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JJLFVBQXhCLEVBQWhCO0FBQ0EsV0FBS2tULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkksVUFBeEIsQ0FBbUNtVSxTQUFuQyxDQUE2QyxVQUFBK08sSUFBSSxFQUFJO0FBQ2pELGNBQUksQ0FBQ3RiLEVBQUwsQ0FBUTZoQixPQUFSLENBQWdCdkcsSUFBaEI7QUFDSCxPQUZEO0FBR0EsV0FBS2hRLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DdXFCLFlBQXBDLENBQWlEdlYsU0FBakQsQ0FBMkQsVUFBQXdVLE9BQU8sRUFBSTtBQUNsRSxZQUFJLENBQUNBLE9BQUwsRUFBYztBQUNWLGdCQUFJLENBQUMvZ0IsRUFBTCxDQUFRNmhCLE9BQVIsQ0FBZ0J4cEIsWUFBWSxDQUFDMlUsSUFBN0I7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBSSxDQUFDaE4sRUFBTCxDQUFRNmhCLE9BQVIsQ0FBZ0IsTUFBSSxDQUFDdlcsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCSSxVQUF4QixFQUFoQjtBQUNIO0FBQ0osT0FORDtBQU9BLFdBQUtrVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQzBvQixPQUFwQyxDQUE0QzFULFNBQTVDLENBQXNELEtBQUt3VixhQUFMLENBQW1CaGIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBdEQ7QUFDQSxXQUFLdUUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0M4SixZQUFwQyxDQUFpRGtMLFNBQWpELENBQTJELFVBQUF5VixTQUFTLEVBQUk7QUFDcEUsY0FBSSxDQUFDaGlCLEVBQUwsQ0FBUWlpQixZQUFSLENBQXFCRCxTQUFyQjtBQUNILE9BRkQ7QUFHSDs7O2tDQUVhL0IsTyxFQUFTO0FBQ25CLFVBQUlBLE9BQU8sS0FBSyxRQUFoQixFQUEwQjtBQUN0QixZQUFJaUMsYUFBYSxHQUFHLEtBQUs1VyxJQUFMLENBQVV6TixVQUFWLENBQXFCZSxVQUFyQixDQUFnQzRHLE9BQWhDLENBQXdDLGtCQUF4QyxDQUFwQjs7QUFDQSxZQUFJMGMsYUFBYSxJQUFJLElBQXJCLEVBQTJCO0FBQ3ZCakMsaUJBQU8sR0FBRyxPQUFWO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSTtBQUNBQSxtQkFBTyxHQUFHcGIsSUFBSSxDQUFDOEYsS0FBTCxDQUFXdVgsYUFBYSxDQUFDeGMsTUFBZCxFQUFYLENBQVY7QUFDSCxXQUZELENBRUUsT0FBTytFLENBQVAsRUFBVTtBQUNSaE0sbUJBQU8sQ0FBQzhXLEtBQVIsQ0FBYzlLLENBQWQsRUFEUSxDQUNVOztBQUNsQndWLG1CQUFPLEdBQUcsU0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxXQUFLamdCLEVBQUwsQ0FBUWhNLGFBQVIsQ0FBc0Jpc0IsT0FBdEIsR0FBZ0NBLE9BQWhDLENBZG1CLENBZW5COztBQUNBLFVBQUk7QUFDQSxhQUFLamdCLEVBQUwsQ0FBUTJFLFdBQVIsQ0FBb0J5USxhQUFwQjtBQUNILE9BRkQsQ0FFRSxPQUFPM0ssQ0FBUCxFQUFVO0FBQ1JoTSxlQUFPLENBQUM4VyxLQUFSLENBQWM5SyxDQUFkO0FBQ0EsYUFBS3pLLEVBQUwsQ0FBUWhNLGFBQVIsQ0FBc0Jpc0IsT0FBdEIsR0FBZ0MsT0FBaEM7QUFDQSxhQUFLamdCLEVBQUwsQ0FBUTJFLFdBQVIsQ0FBb0J5USxhQUFwQjtBQUNIO0FBQ0o7OztxREFFZ0M7QUFBQTs7QUFDN0IsV0FBSzlKLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkUsVUFBeEIsQ0FBbUNxVSxTQUFuQyxDQUE2QyxVQUFDQyxPQUFELEVBQWE7QUFDdEQsY0FBSSxDQUFDMUUsV0FBTCxDQUFpQixNQUFJLENBQUNxYSxtQkFBTCxFQUFqQjtBQUNILE9BRkQ7QUFHQSxXQUFLN1csSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0M2cUIsV0FBcEMsQ0FBZ0Q3VixTQUFoRCxDQUEwRCxVQUFDQyxPQUFELEVBQWE7QUFDbkUsY0FBSSxDQUFDMUUsV0FBTCxDQUFpQixNQUFJLENBQUNxYSxtQkFBTCxFQUFqQjtBQUNILE9BRkQ7QUFHSDs7OzBDQUVxQjtBQUNsQixVQUFJN3NCLEtBQUssR0FBRyxLQUFLZ1csSUFBTCxDQUFVaFcsS0FBdEI7QUFDQSxhQUFPQSxLQUFLLENBQUMwQyxPQUFOLENBQWNPLFdBQWQsTUFDSGpELEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjZxQixXQUExQixNQUEyQyxDQUFDOXNCLEtBQUssQ0FBQzBDLE9BQU4sQ0FBY0UsVUFBZCxFQURoRDtBQUdIOzs7Z0NBRVdtcUIsVSxFQUFZO0FBQ3BCLFdBQUszb0IsUUFBTCxHQUFnQjJvQixVQUFoQjtBQUNBLFdBQUtyaUIsRUFBTCxDQUFROEgsV0FBUixDQUFvQnVhLFVBQXBCO0FBQ0g7OzsrQkFFVXJZLEssRUFBTztBQUNkLFVBQUkvUixRQUFRLEdBQUcrUixLQUFLLENBQUNFLE1BQU4sQ0FBYVksUUFBNUI7QUFDQSxVQUFJclQsSUFBSSxHQUFHdVMsS0FBSyxDQUFDRSxNQUFOLENBQWFVLE1BQXhCOztBQUNBLFVBQUkzUyxRQUFRLENBQUNxcUIsUUFBVCxDQUFrQixRQUFsQixDQUFKLEVBQWlDO0FBQzdCN3FCLFlBQUksR0FBRzRuQixvQkFBb0IsQ0FBQzVuQixJQUFELENBQTNCO0FBQ0g7O0FBQ0QsV0FBSzZULElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsZUFBckMsRUFBc0QsRUFBdEQsRUFBMEQsRUFBMUQsRUFBOEQvQyxJQUE5RCxFQUFvRSxLQUFLUSxRQUF6RTtBQUNBLFdBQUtzTSxJQUFMLENBQVVtQixNQUFWLENBQWlCak8sSUFBakI7QUFDQSxXQUFLNlQsSUFBTCxDQUFVek4sVUFBVixDQUFxQmdFLE1BQXJCLENBQTRCMkgsR0FBNUIsR0FSYyxDQVNkO0FBQ0g7OzttQ0FFYztBQUNYLFVBQUlvQixNQUFNLHFGQUFWOztBQUNBLFVBQUlBLE1BQU0sQ0FBQ2pWLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEJpVixNQUFNLENBQUN3TyxTQUFQLEtBQXFCLEtBQXJELEVBQTREO0FBQ3hEeE8sY0FBTSxDQUFDalYsSUFBUCxHQUFjdWpCLGlFQUFRLENBQUMsS0FBSzVOLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjBCLElBQTNCLEVBQUQsQ0FBdEI7QUFDSDs7QUFDRGlWLFlBQU0sQ0FBQ3lPLFFBQVAsR0FBa0IsZUFBbEI7QUFDQSxXQUFLL04sSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ0RCxRQUE1QixDQUFxQyxpQkFBckMsRUFBd0QsRUFBeEQsRUFBNEQsRUFBNUQsRUFBZ0UsRUFBaEUsRUFBb0VvUSxNQUFNLENBQUNqVixJQUEzRTtBQUNBLGFBQU9pVixNQUFQO0FBQ0g7Ozs7RUFoUDBCc1AsK0Q7O0FBb1B4QixJQUFNcUksWUFBWSxHQUFHO0FBQ3hCNXNCLE1BQUksRUFBRSxRQURrQjtBQUV4QmduQixZQUFVLEVBQUUsQ0FBQyxLQUFELENBRlk7QUFHeEJDLGFBQVcsRUFBRWlELGdCQUhXO0FBSXhCaEQsVUFBUSxFQUFFc0M7QUFKYyxDQUFyQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4WlA7QUFFTyxJQUFNcUQsZ0JBQWdCLHVGQUF0Qjs7SUFNREMsYzs7Ozs7QUFDRiwwQkFBWW5YLElBQVosRUFBa0IrRixHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTS9GLElBQU4sRUFBWStGLEdBQVo7QUFDQSxVQUFLakssVUFBTCxHQUFrQm1XLFVBQVUsQ0FBQ0MsWUFBWCxDQUF3Qm5NLEdBQUcsQ0FBQzFGLElBQUosQ0FBUyxzQkFBVCxFQUFpQyxDQUFqQyxDQUF4QixFQUE2RDtBQUMzRThSLDZCQUF1QixFQUFFLElBRGtEO0FBRTNFQyxpQkFBVyxFQUFFLElBRjhEO0FBRzNFQyxxQkFBZSxFQUFFLENBSDBEO0FBSTNFQyxnQkFBVSxFQUFFLENBSitEO0FBSzNFQyxhQUFPLEVBQUUsQ0FMa0U7QUFNM0VDLG9CQUFjLEVBQUUsS0FOMkQ7QUFPM0VDLGVBQVMsRUFBRTtBQUNQLGVBQU8sWUFEQTtBQUVQLHFCQUFhLFlBRk47QUFHUCxlQUFPLGFBQVVDLEVBQVYsRUFBYztBQUNqQixjQUFJQSxFQUFFLENBQUMxVyxTQUFILENBQWEsWUFBYixDQUFKLEVBQWdDO0FBQzVCMFcsY0FBRSxDQUFDM1csU0FBSCxDQUFhLFlBQWIsRUFBMkIsS0FBM0I7QUFDSCxXQUZELE1BRU87QUFDSDJXLGNBQUUsQ0FBQ2htQixPQUFILENBQVc4RCxLQUFYLENBQWlCbWlCLElBQWpCO0FBQ0g7QUFDSixTQVRNO0FBVVAsZUFBTyxhQUFVRCxFQUFWLEVBQWM7QUFDakJBLFlBQUUsQ0FBQzNXLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLENBQUMyVyxFQUFFLENBQUMxVyxTQUFILENBQWEsWUFBYixDQUE1QjtBQUNIO0FBWk07QUFQZ0UsS0FBN0QsQ0FBbEI7QUFzQkEsVUFBS2dWLEtBQUwsR0FBYSxLQUFiO0FBeEJtQjtBQXlCdEI7Ozs7MEJBRUs3QixXLEVBQWFDLFMsRUFBVztBQUMxQixnRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzRCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS3pVLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBS3VYLG1CQUFMLEdBQTJCLEtBQUsxWSxJQUFMLENBQVVtQixNQUFWLENBQWlCNkcsU0FBakIsQ0FBMkIsS0FBSzFFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUt3VixlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0J6VixJQUFsQixDQUF1QixJQUF2QixDQUF2QjtBQUNBLFdBQUtLLFVBQUwsQ0FBZ0J5USxFQUFoQixDQUFtQixRQUFuQixFQUE2QixLQUFLMEUsZUFBbEM7O0FBQ0EsVUFBSTdCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBd0Qsa0JBQVUsQ0FBQyxLQUFLOVcsVUFBTCxDQUFnQm5ILE9BQWhCLENBQXdCOEcsSUFBeEIsQ0FBNkIsS0FBS0ssVUFBbEMsQ0FBRCxFQUFnRCxDQUFoRCxDQUFWO0FBQ0gsT0FaeUIsQ0FhMUI7OztBQUNBLFdBQUtBLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDb1QsV0FBVyxDQUFDM1UsVUFBWixDQUF1QixHQUF2QixLQUErQixDQUFDLEtBQUt3RixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JFLFVBQXhCLEVBQXRFO0FBQ0g7OztpQ0FFWXVrQixXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLbFYsVUFBTCxDQUFnQitXLFFBQWhCLENBQXlCMUIsV0FBekI7QUFDQSxhQUFLclYsVUFBTCxDQUFnQm5ILE9BQWhCO0FBQ0EsYUFBS3FjLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZdFMsSyxFQUFPO0FBQ2hCLFdBQUtzUyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUsvWCxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUswQixVQUFMLENBQWdCZ1gsUUFBaEIsRUFBakI7QUFDQSxhQUFLOUIsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7eUJBRUk3QixXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3FDLG1CQUFMLENBQXlCRSxPQUF6QjtBQUNBLFdBQUsvVixVQUFMLENBQWdCaVgsR0FBaEIsQ0FBb0IsUUFBcEIsRUFBOEIsS0FBSzlCLGVBQW5DO0FBQ0EsV0FBS25WLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDLEtBQXRDOztBQUNBLCtFQUFXb1QsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQXRFd0JSLCtEOztBQXlFdEIsSUFBTXdJLFVBQVUsR0FBRztBQUN0Qi9zQixNQUFJLEVBQUUsTUFEZ0I7QUFFdEJnbkIsWUFBVSxFQUFFLENBQUMsT0FBRCxDQUZVO0FBR3RCQyxhQUFXLEVBQUU2RixjQUhTO0FBSXRCNUYsVUFBUSxFQUFFMkY7QUFKWSxDQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pGUDs7OztBQUtBO0FBRU8sSUFBTUcsa0JBQWtCLEdBQUc7QUFDOUJDLFNBQU8sRUFBRSxTQURxQjtBQUU5QkMsUUFBTSxFQUFFLFFBRnNCO0FBRzlCQyxRQUFNLEVBQUUsUUFIc0I7QUFJOUJDLE9BQUssRUFBRSxPQUp1QjtBQUs5QkMsU0FBTyxFQUFFO0FBTHFCLENBQTNCO0FBUUEsSUFBTWplLGdCQUFiO0FBQ0ksNEJBQVlwUCxJQUFaLEVBQWtCa0UsTUFBbEIsRUFBMEJwQyxJQUExQixFQUFnQztBQUFBOztBQUM1QixTQUFLOUIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS2tFLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtwQyxJQUFMLEdBQVlBLElBQVo7QUFDSDs7QUFMTDtBQUFBO0FBQUEsZ0NBZ0JnQjtBQUNSLGFBQU87QUFDSDlCLFlBQUksRUFBRSxLQUFLQSxJQURSO0FBRUhrRSxjQUFNLEVBQUUsS0FBS0EsTUFGVjtBQUdIcEMsWUFBSSxFQUFFLEtBQUtBO0FBSFIsT0FBUDtBQUtIO0FBdEJMO0FBQUE7QUFBQSwwQkFPaUJ3ckIsS0FQakIsRUFPd0I7QUFDaEIsYUFBTyxJQUFJbGUsZ0JBQUosQ0FBcUIsY0FBWWtlLEtBQUssSUFBSSxDQUFyQixDQUFyQixFQUNxQk4sa0JBQWtCLENBQUNDLE9BRHhDLEVBQ2lELEtBRGpELENBQVA7QUFFSDtBQVZMO0FBQUE7QUFBQSxnQ0FZdUJwa0IsSUFadkIsRUFZNkI7QUFDckIsYUFBTyxJQUFJdUcsZ0JBQUosQ0FBcUJ2RyxJQUFJLENBQUM3SSxJQUExQixFQUFnQzZJLElBQUksQ0FBQzNFLE1BQXJDLEVBQTZDMkUsSUFBSSxDQUFDL0csSUFBbEQsQ0FBUDtBQUNIO0FBZEw7O0FBQUE7QUFBQTtBQXlCTyxJQUFNeXJCLHVCQUF1QixrZUFBN0I7QUFnQlB6dEIsRUFBRSxDQUFDMHRCLGVBQUgsQ0FBbUJDLGtCQUFuQixHQUF3QztBQUNwQ0MsTUFBSSxFQUFFLGNBQVMzRSxPQUFULEVBQWtCNEUsYUFBbEIsRUFBaUNDLFdBQWpDLEVBQThDQyxTQUE5QyxFQUF5REMsY0FBekQsRUFBeUU7QUFDM0U7QUFDQTtBQUNBaGxCLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLE1BQVo7QUFDQSxRQUFJc2YsRUFBRSxHQUFHVCxVQUFVLENBQUNDLFlBQVgsQ0FBd0JrQixPQUF4QixFQUFpQztBQUN0Q2pCLDZCQUF1QixFQUFFLElBRGE7QUFFdENDLGlCQUFXLEVBQUUsSUFGeUI7QUFHdENDLHFCQUFlLEVBQUUsQ0FIcUI7QUFJdENDLGdCQUFVLEVBQUUsQ0FKMEI7QUFLdENDLGFBQU8sRUFBRSxDQUw2QjtBQU10Q0Msb0JBQWMsRUFBRSxLQU5zQjtBQU90Q0MsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUIwVyxjQUFFLENBQUMzVyxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIMlcsY0FBRSxDQUFDaG1CLE9BQUgsQ0FBVzhELEtBQVgsQ0FBaUJtaUIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDM1csU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQzJXLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVAyQixLQUFqQyxDQUFUO0FBc0JBMFcsTUFBRSxDQUFDMEYsT0FBSCxDQUFXLE1BQVgsRUFBbUIsT0FBbkI7QUFDQSxXQUFPMUYsRUFBUDtBQUNILEdBN0JtQztBQThCcEMyRixRQUFNLEVBQUUsZ0JBQVNqRixPQUFULEVBQWtCNEUsYUFBbEIsRUFBaUNDLFdBQWpDLEVBQThDQyxTQUE5QyxFQUF5REMsY0FBekQsRUFBeUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0FobEIsV0FBTyxDQUFDQyxHQUFSLENBQVksUUFBWjtBQUNIO0FBbkNtQyxDQUF4Qzs7SUFzQ01rbEIscUI7Ozs7O0FBQ0YsaUNBQVl0WSxJQUFaLEVBQWtCK0YsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU0vRixJQUFOLEVBQVkrRixHQUFaO0FBQ0EsVUFBS0EsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsVUFBS3dTLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxVQUFLdkgsS0FBTCxHQUFhLEtBQWI7QUFKbUI7QUFLdEI7Ozs7Z0NBRVdyVCxNLEVBQVFDLEssRUFBT0MsVSxFQUFZLENBRXRDOzs7cUNBRWdCO0FBQ2IxSyxhQUFPLENBQUNDLEdBQVIsQ0FBWSxvQkFBWjtBQUNIOzs7MEJBRUsrYixXLEVBQWFDLFMsRUFBVztBQUFBOztBQUMxQix1RkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzRCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS3pVLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBS3VYLG1CQUFMLEdBQTJCLEtBQUsxWSxJQUFMLENBQVVtQixNQUFWLENBQWlCNkcsU0FBakIsQ0FBMkIsS0FBSzFFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUt3VixlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0J6VixJQUFsQixDQUF1QixJQUF2QixDQUF2QixDQVAwQixDQVExQjtBQUNBOztBQUNBLFVBQUkyVCxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEJqYyxlQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFLMlMsR0FBakI7QUFDQTVTLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUsyUyxHQUFMLENBQVMxRixJQUFULENBQWMsYUFBZCxDQUFaO0FBQ0FsTixlQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFLMlMsR0FBTCxDQUFTMUYsSUFBVCxDQUFjLGFBQWQsRUFBNkJ2RixHQUE3QixDQUFpQyxVQUFDcU4sQ0FBRCxFQUFHdUssRUFBSDtBQUFBLGlCQUFVdmYsT0FBTyxDQUFDQyxHQUFSLENBQVksS0FBWixFQUFtQnNmLEVBQUUsQ0FBQ1QsVUFBdEIsQ0FBVjtBQUFBLFNBQWpDLENBQVo7QUFDQSxhQUFLbE0sR0FBTCxDQUFTMUYsSUFBVCxDQUFjLGFBQWQsRUFBNkJ2RixHQUE3QixDQUFpQyxVQUFDcU4sQ0FBRCxFQUFJdUssRUFBSjtBQUFBLGlCQUFXQSxFQUFFLENBQUNULFVBQUgsQ0FBY3RkLE9BQWQsRUFBWDtBQUFBLFNBQWpDO0FBQ0F4QixlQUFPLENBQUNDLEdBQVIsQ0FBWSxTQUFaLEVBTG9CLENBTXBCOztBQUNBd2Ysa0JBQVUsQ0FBQztBQUFBLGlCQUFNLE1BQUksQ0FBQzdNLEdBQUwsQ0FBUzFGLElBQVQsQ0FBYyxhQUFkLEVBQTZCdkYsR0FBN0IsQ0FBaUMsVUFBQ3FOLENBQUQsRUFBSXVLLEVBQUo7QUFBQSxtQkFBV0EsRUFBRSxDQUFDVCxVQUFILENBQWN0ZCxPQUFkLEVBQVg7QUFBQSxXQUFqQyxDQUFOO0FBQUEsU0FBRCxFQUE2RSxDQUE3RSxDQUFWO0FBQ0gsT0FsQnlCLENBbUIxQjtBQUNBOztBQUNIOzs7aUNBRVl3YyxXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQTdkLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUttbEIsV0FBakIsRUFGWSxDQUdaO0FBQ0E7O0FBQ0EsYUFBS3ZILEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZdFMsSyxFQUFPO0FBQ2hCLFdBQUtzUyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUsvWCxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUttZSxXQUFMLENBQWlCemQsR0FBakIsQ0FBcUIsVUFBQTRYLEVBQUU7QUFBQSxpQkFBSUEsRUFBRSxDQUFDSSxRQUFILEVBQUo7QUFBQSxTQUF2QixDQUFqQjtBQUNBLGFBQUs5QixLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLcUMsbUJBQUwsQ0FBeUJFLE9BQXpCO0FBQ0EsV0FBSzBHLFdBQUwsR0FBbUIsRUFBbkIsQ0FIb0MsQ0FJcEM7QUFDQTs7QUFDQSxzRkFBV3BKLFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUFsRStCUiwrRDs7QUFxRTdCLElBQU00SixpQkFBaUIsR0FBRztBQUM3Qm51QixNQUFJLEVBQUUsb0JBRHVCO0FBRTdCZ25CLFlBQVUsRUFBRSxDQUFDLDZCQUFELENBRmlCO0FBRzdCQyxhQUFXLEVBQUVnSCxxQkFIZ0I7QUFJN0IvRyxVQUFRLEVBQUVxRztBQUptQixDQUExQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25LUDtBQUVPLElBQU1hLGdCQUFnQixpT0FBdEI7O0lBa0JEQyxjOzs7OztBQUNGLDBCQUFZMVksSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUEsNkJBQ2IvRixJQURhLEVBQ1ArRixHQUFHLENBQUMxRixJQUFKLENBQVMsc0JBQVQsQ0FETztBQUV0Qjs7O0VBSHdCdU8sK0Q7O0FBTXRCLElBQU0rSixVQUFVLEdBQUc7QUFDdEJ0dUIsTUFBSSxFQUFFLE1BRGdCO0FBRXRCZ25CLFlBQVUsRUFBRSxDQUFDLGVBQUQsQ0FGVTtBQUd0QkMsYUFBVyxFQUFFb0gsY0FIUztBQUl0Qm5ILFVBQVEsRUFBRWtIO0FBSlksQ0FBbkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCUDtBQUNBO0FBRU8sSUFBTUcsZ0JBQWdCLG1CQUN2QnBILDhEQUR1Qix1RkFBdEI7O0lBT0RxSCxjOzs7OztBQUNGLDBCQUFZN1ksSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNL0YsSUFBTixFQUFZK0YsR0FBWjtBQUNBLFVBQUtqSyxVQUFMLEdBQWtCbVcsVUFBVSxDQUFDQyxZQUFYLENBQXdCbk0sR0FBRyxDQUFDMUYsSUFBSixDQUFTLHNCQUFULEVBQWlDLENBQWpDLENBQXhCLEVBQTZEO0FBQzNFOFIsNkJBQXVCLEVBQUUsSUFEa0Q7QUFFM0VDLGlCQUFXLEVBQUUsSUFGOEQ7QUFHM0VDLHFCQUFlLEVBQUUsQ0FIMEQ7QUFJM0VDLGdCQUFVLEVBQUUsQ0FKK0Q7QUFLM0VDLGFBQU8sRUFBRSxDQUxrRTtBQU0zRUMsb0JBQWMsRUFBRSxLQU4yRDtBQU8zRUMsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUIwVyxjQUFFLENBQUMzVyxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIMlcsY0FBRSxDQUFDaG1CLE9BQUgsQ0FBVzhELEtBQVgsQ0FBaUJtaUIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDM1csU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQzJXLEVBQUUsQ0FBQzFXLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVBnRSxLQUE3RCxDQUFsQjtBQXNCQSxVQUFLZ1YsS0FBTCxHQUFhLEtBQWI7QUF4Qm1CO0FBeUJ0Qjs7OzswQkFFSzdCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLGdGQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNEIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLelUsWUFBTCxDQUFrQixLQUFLdEQsSUFBTCxDQUFVbUIsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLdVgsbUJBQUwsR0FBMkIsS0FBSzFZLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUI2RyxTQUFqQixDQUEyQixLQUFLMUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS3dWLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnpWLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBS0ssVUFBTCxDQUFnQnlRLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLEtBQUswRSxlQUFsQzs7QUFDQSxVQUFJN0IsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F3RCxrQkFBVSxDQUFDLEtBQUs5VyxVQUFMLENBQWdCbkgsT0FBaEIsQ0FBd0I4RyxJQUF4QixDQUE2QixLQUFLSyxVQUFsQyxDQUFELEVBQWdELENBQWhELENBQVY7QUFDSCxPQVp5QixDQWExQjs7O0FBQ0EsV0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0NvVCxXQUFXLENBQUMzVSxVQUFaLENBQXVCLEdBQXZCLEtBQStCLENBQUMsS0FBS3dGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBdEU7QUFDSDs7O2lDQUVZdWtCLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUtsVixVQUFMLENBQWdCK1csUUFBaEIsQ0FBeUIxQixXQUF6QjtBQUNBLGFBQUtyVixVQUFMLENBQWdCbkgsT0FBaEI7QUFDQSxhQUFLcWMsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVl0UyxLLEVBQU87QUFDaEIsV0FBS3NTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSy9YLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUIsS0FBSzBCLFVBQUwsQ0FBZ0JnWCxRQUFoQixFQUFqQjtBQUNBLGFBQUs5QixLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLcUMsbUJBQUwsQ0FBeUJFLE9BQXpCO0FBQ0EsV0FBSy9WLFVBQUwsQ0FBZ0JpWCxHQUFoQixDQUFvQixRQUFwQixFQUE4QixLQUFLOUIsZUFBbkM7QUFDQSxXQUFLblYsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEM7O0FBQ0EsK0VBQVdvVCxXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBdEV3QlIsK0Q7O0FBeUV0QixJQUFNa0ssVUFBVSxHQUFHO0FBQ3RCenVCLE1BQUksRUFBRSxNQURnQjtBQUV0QmduQixZQUFVLEVBQUUsQ0FBQyxNQUFELENBRlU7QUFHdEJDLGFBQVcsRUFBRXVILGNBSFM7QUFJdEJ0SCxVQUFRLEVBQUVxSDtBQUpZLENBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25GUDtBQUVPLElBQU1HLG1CQUFtQiw2ZkFBekI7O0lBY0RDLGlCOzs7OztBQUNGLDZCQUFZaFosSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNL0YsSUFBTixFQUFZK0YsR0FBWjtBQUNBLFVBQUtqSyxVQUFMLEdBQWtCbVcsVUFBVSxDQUFDQyxZQUFYLENBQXdCbk0sR0FBRyxDQUFDMUYsSUFBSixDQUFTLHlCQUFULEVBQW9DLENBQXBDLENBQXhCLEVBQWdFO0FBQzlFOFIsNkJBQXVCLEVBQUUsSUFEcUQ7QUFFOUVDLGlCQUFXLEVBQUUsSUFGaUU7QUFHOUVDLHFCQUFlLEVBQUUsQ0FINkQ7QUFJOUVDLGdCQUFVLEVBQUUsQ0FKa0U7QUFLOUVDLGFBQU8sRUFBRSxDQUxxRTtBQU05RUMsb0JBQWMsRUFBRSxLQU44RDtBQU85RXhDLFVBQUksRUFBRSxNQVB3RTtBQVE5RXlDLGVBQVMsRUFBRTtBQUNQLGVBQU8sWUFEQTtBQUVQLHFCQUFhLFlBRk47QUFHUCxlQUFPLGFBQVVDLEVBQVYsRUFBYztBQUNqQixjQUFJQSxFQUFFLENBQUMxVyxTQUFILENBQWEsWUFBYixDQUFKLEVBQWdDO0FBQzVCMFcsY0FBRSxDQUFDM1csU0FBSCxDQUFhLFlBQWIsRUFBMkIsS0FBM0I7QUFDSCxXQUZELE1BRU87QUFDSDJXLGNBQUUsQ0FBQ2htQixPQUFILENBQVc4RCxLQUFYLENBQWlCbWlCLElBQWpCO0FBQ0g7QUFDSixTQVRNO0FBVVAsZUFBTyxhQUFVRCxFQUFWLEVBQWM7QUFDakJBLFlBQUUsQ0FBQzNXLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLENBQUMyVyxFQUFFLENBQUMxVyxTQUFILENBQWEsWUFBYixDQUE1QjtBQUNIO0FBWk07QUFSbUUsS0FBaEUsQ0FBbEI7QUF1QkEsVUFBS2dWLEtBQUwsR0FBYSxLQUFiO0FBekJtQjtBQTBCdEI7Ozs7MEJBRUs3QixXLEVBQWFDLFMsRUFBVztBQUMxQixtRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzRCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS3pVLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBS3VYLG1CQUFMLEdBQTJCLEtBQUsxWSxJQUFMLENBQVVtQixNQUFWLENBQWlCNkcsU0FBakIsQ0FBMkIsS0FBSzFFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUt3VixlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0J6VixJQUFsQixDQUF1QixJQUF2QixDQUF2QjtBQUNBLFdBQUtzSyxHQUFMLENBQVMxRixJQUFULENBQWMsdUJBQWQsRUFBdUNrTSxFQUF2QyxDQUEwQyxPQUExQyxFQUFtRCxLQUFLMEUsZUFBeEQsRUFSMEIsQ0FTMUI7O0FBQ0EsVUFBSTdCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBd0Qsa0JBQVUsQ0FBQyxLQUFLOVcsVUFBTCxDQUFnQm5ILE9BQWhCLENBQXdCOEcsSUFBeEIsQ0FBNkIsS0FBS0ssVUFBbEMsQ0FBRCxFQUFnRCxDQUFoRCxDQUFWO0FBQ0gsT0FieUIsQ0FjMUI7OztBQUNBLFdBQUtBLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDb1QsV0FBVyxDQUFDM1UsVUFBWixDQUF1QixHQUF2QixLQUErQixDQUFDLEtBQUt3RixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JFLFVBQXhCLEVBQXRFO0FBRUg7OztpQ0FFWXVrQixXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLbFYsVUFBTCxDQUFnQitXLFFBQWhCLENBQXlCMUIsV0FBekI7QUFDQSxhQUFLclYsVUFBTCxDQUFnQm5ILE9BQWhCO0FBQ0EsYUFBS3FjLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZdFMsSyxFQUFPO0FBQ2hCLFdBQUtzUyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUsvWCxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUswQixVQUFMLENBQWdCZ1gsUUFBaEIsRUFBakI7O0FBQ0EsWUFBSSxLQUFLOVMsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0Mwb0IsT0FBcEMsT0FBa0QsUUFBdEQsRUFBZ0U7QUFDNUQsZUFBSzNVLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJrQyxZQUFyQixDQUFrQ2dpQixhQUFsQyxDQUFnRCxRQUFoRDtBQUNIOztBQUNELGFBQUt6RixLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTdCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLcUMsbUJBQUwsQ0FBeUJFLE9BQXpCO0FBQ0EsV0FBSzlMLEdBQUwsQ0FBUzFGLElBQVQsQ0FBYywwQkFBZCxFQUEwQzBTLEdBQTFDLENBQThDLE9BQTlDLEVBQXVELEtBQUs5QixlQUE1RCxFQUhvQyxDQUlwQzs7QUFDQSxXQUFLblYsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEM7O0FBQ0Esa0ZBQVdvVCxXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBN0UyQlIsK0Q7O0FBZ0Z6QixJQUFNcUssYUFBYSxHQUFHO0FBQ3pCNXVCLE1BQUksRUFBRSxTQURtQjtBQUV6QmduQixZQUFVLEVBQUUsQ0FBQyxrQkFBRCxDQUZhO0FBR3pCQyxhQUFXLEVBQUUwSCxpQkFIWTtBQUl6QnpILFVBQVEsRUFBRXdIO0FBSmUsQ0FBdEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoR1A7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlPLElBQUlHLFdBQVcsR0FBRztBQUNyQkMsWUFBVSxFQUFFLFlBRFM7QUFFckJDLFlBQVUsRUFBRSxZQUZTO0FBR3JCQyxjQUFZLEVBQUUsY0FITztBQUlyQkMsUUFBTSxFQUFFLFFBSmE7QUFLckJDLFdBQVMsRUFBRSxXQUxVO0FBTXJCQyxTQUFPLEVBQUUsU0FOWTtBQU9yQkMsZUFBYSxFQUFFLGVBUE07QUFRckJDLG9CQUFrQixFQUFFLG9CQVJDO0FBU3JCQyxpQkFBZSxFQUFFO0FBVEksQ0FBbEI7QUFZUCxJQUFNQyxrQkFBa0IsR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUEzQjtBQUVBLElBQU1DLGlCQUFpQixHQUFHLENBQ3RCZix1REFEc0IsRUFDVjdCLDJEQURVLEVBQ0k3Riw4RUFESixFQUN3QnVILHVEQUR4QixFQUNvQ2hGLCtEQURwQyxFQUV0QjZFLDRFQUZzQixFQUVIeEYsdURBRkcsRUFFU2lHLDZEQUZULEVBRXdCN0IsdURBRnhCLEVBRW9DdEYsMERBRnBDLENBQTFCO0FBS08sSUFBTWdJLFlBQVksR0FBR0QsaUJBQWlCLENBQUMvZSxHQUFsQixDQUFzQixVQUFBZ0QsTUFBTTtBQUFBLG1JQUVEQSxNQUFNLENBQUN6VCxJQUZOLGtDQUlsRHlULE1BQU0sQ0FBQ3lULFFBSjJDO0FBQUE7QUFRcEQ7Ozs7O0FBUndCLEVBYTFCL0QsSUFiMEIsQ0FhckIsSUFicUIsQ0FBckI7QUFlQSxJQUFNN00sT0FBYjtBQUNJLG1CQUFZWCxJQUFaLEVBQWtCK0YsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsU0FBSy9GLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUsrRixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLN1EsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLNmtCLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQUoscUJBQWlCLENBQUN2USxPQUFsQixDQUEwQixVQUFBeEwsTUFBTTtBQUFBLGFBQUksS0FBSSxDQUFDb2MsY0FBTCxDQUFvQnBjLE1BQXBCLENBQUo7QUFBQSxLQUFoQztBQUNBLFNBQUtrQyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JDLFFBQXhCLENBQWlDc1UsU0FBakMsQ0FBMkMsS0FBSzROLFlBQWhELEVBQThELElBQTlEO0FBQ0g7O0FBVkw7QUFBQTtBQUFBLG1DQVltQjNiLElBWm5CLEVBWXlCO0FBQ2pCLFVBQUltZSxVQUFVLEdBQUduZSxJQUFJLENBQUNtZSxVQUF0QjtBQUNBLFVBQUk4SSxRQUFRLEdBQUcsSUFBSWpuQixJQUFJLENBQUNvZSxXQUFULENBQXFCLEtBQUt0UixJQUExQixFQUFnQyxLQUFLK0YsR0FBckMsQ0FBZjtBQUNBb1UsY0FBUSxDQUFDOXZCLElBQVQsR0FBZ0I2SSxJQUFJLENBQUM3SSxJQUFyQjtBQUNBLFdBQUswdkIsV0FBTCxDQUFpQnhVLElBQWpCLENBQXNCNFUsUUFBdEI7QUFDQSxXQUFLRixPQUFMLENBQWEvbUIsSUFBSSxDQUFDN0ksSUFBTCxDQUFVb00sV0FBVixFQUFiLElBQXdDMGpCLFFBQXhDOztBQUNBLFdBQUssSUFBSWhTLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR2tKLFVBQVUsQ0FBQ25ZLE1BQTdCLEVBQXFDaVAsQ0FBQyxFQUF0QyxFQUEwQztBQUN0QyxhQUFLNlIsV0FBTCxDQUFpQjNJLFVBQVUsQ0FBQ2xKLENBQUQsQ0FBM0IsSUFBa0NnUyxRQUFsQztBQUNIO0FBQ0o7QUFyQkw7QUFBQTtBQUFBLDJCQXVCVzl2QixJQXZCWCxFQXVCaUI7QUFDVCxhQUFPLEtBQUs0dkIsT0FBTCxDQUFhNXZCLElBQUksQ0FBQ29NLFdBQUwsRUFBYixDQUFQO0FBQ0g7QUF6Qkw7QUFBQTtBQUFBLGlDQTJCaUIwWSxXQTNCakIsRUEyQjhCO0FBQ3RCLFVBQUlDLFNBQVMsR0FBRyxLQUFLbGEsT0FBckI7QUFDQSxVQUFJb2EsU0FBUyxHQUFHLEtBQUszVSxTQUFMLENBQWV3VSxXQUFmLEVBQTRCQyxTQUE1QixDQUFoQjs7QUFDQSxVQUFJQSxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEJBLGlCQUFTLENBQUNnTCxJQUFWLENBQWVqTCxXQUFmLEVBQTRCQyxTQUE1QixFQUF1Q0UsU0FBdkM7QUFDSDs7QUFDRCxXQUFLcGEsT0FBTCxHQUFlb2EsU0FBZjtBQUNBLFdBQUtwYSxPQUFMLENBQWFtbEIsS0FBYixDQUFtQmxMLFdBQW5CLEVBQWdDQyxTQUFoQztBQUNIO0FBbkNMO0FBQUE7QUFBQSw4QkFpRGNyVyxJQWpEZCxFQWlEb0I7QUFBQSxrQ0FDYzRILE9BQU8sQ0FBQzZPLGFBQVIsQ0FBc0J6VyxJQUF0QixDQURkO0FBQUEsVUFDUHVoQixLQURPLHlCQUNQQSxLQURPO0FBQUEsVUFDQWp3QixJQURBLHlCQUNBQSxJQURBO0FBQUEsVUFDTU8sSUFETix5QkFDTUEsSUFETjs7QUFFWixVQUFJQSxJQUFJLEtBQUssVUFBVCxJQUF1Qm1PLElBQUksSUFBSSxLQUFLaWhCLFdBQXhDLEVBQXFEO0FBQ2pELGVBQU8sS0FBS0EsV0FBTCxDQUFpQmpoQixJQUFqQixDQUFQO0FBQ0g7O0FBQ0QsVUFBSXdoQixjQUFjLEdBQUcsS0FBS3ZhLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQmlDLElBQTNCLEVBQXJCOztBQUNBLFVBQUkydkIsY0FBYyxLQUFLQyx5RUFBYyxDQUFDMXZCLE9BQXRDLEVBQStDO0FBQzNDLFlBQUlULElBQUksS0FBSyxRQUFULElBQXFCTyxJQUFJLEtBQUssS0FBbEMsRUFBeUM7QUFDckMsY0FBSSxNQUFJMnZCLGNBQUosSUFBc0IsS0FBS1AsV0FBL0IsRUFBNEM7QUFDeEMsbUJBQU8sS0FBS0EsV0FBTCxDQUFpQixNQUFJTyxjQUFyQixDQUFQO0FBQ0gsV0FGRCxNQUVPO0FBQ0hwbkIsbUJBQU8sQ0FBQzhXLEtBQVIsQ0FBYywyQ0FBZCxFQUEyRHNRLGNBQTNEO0FBQ0EsbUJBQU8sS0FBS1IsV0FBTCxDQUFpQixDQUFqQixDQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUNELFVBQUludkIsSUFBSSxJQUFJLEtBQUtvdkIsV0FBakIsRUFBOEI7QUFDMUIsZUFBTyxLQUFLQSxXQUFMLENBQWlCcHZCLElBQWpCLENBQVA7QUFDSCxPQUZELE1BRU87QUFDSCxlQUFPLEtBQUttdkIsV0FBTCxDQUFpQixDQUFqQixDQUFQO0FBQ0gsT0FwQlcsQ0FxQlo7O0FBQ0g7QUF2RUw7QUFBQTtBQUFBLGtDQXFDeUJoaEIsSUFyQ3pCLEVBcUMrQjtBQUN2QixVQUFJdWhCLEtBQUssR0FBR3ZoQixJQUFJLENBQUNnUCxNQUFMLENBQVksQ0FBWixDQUFaOztBQUNBLFVBQUk2UixrQkFBa0IsQ0FBQ3ZlLE9BQW5CLENBQTJCaWYsS0FBM0IsTUFBc0MsQ0FBQyxDQUEzQyxFQUE4QztBQUMxQ3ZoQixZQUFJLEdBQUdBLElBQUksQ0FBQ2dDLE1BQUwsQ0FBWSxDQUFaLENBQVA7QUFDSCxPQUZELE1BRU87QUFDSHVmLGFBQUssR0FBRyxFQUFSO0FBQ0g7O0FBQ0QsVUFBSWp3QixJQUFJLEdBQUcwTyxJQUFJLENBQUNnQyxNQUFMLENBQVksQ0FBWixFQUFlaEMsSUFBSSxDQUFDMGhCLFdBQUwsQ0FBaUIsR0FBakIsQ0FBZixDQUFYO0FBQ0EsVUFBSTd2QixJQUFJLEdBQUdtTyxJQUFJLENBQUNnQyxNQUFMLENBQVloQyxJQUFJLENBQUMwaEIsV0FBTCxDQUFpQixHQUFqQixDQUFaLENBQVg7QUFDQSxhQUFPO0FBQUMsaUJBQVNILEtBQVY7QUFBaUIsZ0JBQVFqd0IsSUFBekI7QUFBK0IsZ0JBQVFPO0FBQXZDLE9BQVA7QUFDSDtBQS9DTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBWU8sSUFBTTZWLGFBQWI7QUFDSSx5QkFBWVQsSUFBWixFQUFrQjtBQUFBOztBQUNkLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUswYSxjQUFMLEdBQXNCLEtBQUsxYSxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBdEM7QUFFQSxTQUFLc3FCLGNBQUwsR0FBc0I7QUFDbEJ6YyxTQUFHLEVBQUUsSUFBSTBjLDREQUFKLENBQXFCNWEsSUFBckIsQ0FEYTtBQUVsQjZhLFVBQUksRUFBRSxJQUFJQyw4REFBSixDQUFzQjlhLElBQXRCLENBRlk7QUFHbEIvVSxXQUFLLEVBQUUsSUFBSTh2QixpRUFBSixDQUF1Qi9hLElBQXZCLENBSFc7QUFJbEI5VSxjQUFRLEVBQUUsSUFBSTh2Qix1RUFBSixDQUEwQmhiLElBQTFCLENBSlE7QUFLbEI3VSxZQUFNLEVBQUUsSUFBSTh2QixtRUFBSixDQUF3QmpiLElBQXhCO0FBTFUsS0FBdEIsQ0FKYyxDQVlkOztBQUNBSixNQUFFLENBQUNzYixTQUFILENBQWEsS0FBS1AsY0FBTCxDQUFvQnpjLEdBQXBCLENBQXdCaWQsZ0JBQXhCLEVBQWIsRUFiYyxDQWVkOztBQUNBLFNBQUsxWSxlQUFMLEdBQXVCLEVBQXZCO0FBRUE7Ozs7O0FBSUEsU0FBSzJZLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixJQUF0QjtBQUNIO0FBRUQ7Ozs7O0FBM0JKO0FBQUE7QUFBQSxtQ0E4Qm1CO0FBQ1gsVUFBSUMsTUFBTSxHQUFHLEtBQUtaLGNBQUwsQ0FBb0JwcUIsT0FBakM7QUFDQWdyQixZQUFNLENBQUMsVUFBRCxDQUFOLEdBQXFCLEVBQXJCO0FBQ0FBLFlBQU0sQ0FBQyxRQUFELENBQU4sR0FBbUIsRUFBbkI7QUFDQUEsWUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQixFQUFwQjtBQUNBQSxZQUFNLENBQUMsWUFBRCxDQUFOLEdBQXVCLEVBQXZCO0FBQ0FBLFlBQU0sQ0FBQyxPQUFELENBQU4sR0FBa0IsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQTVCO0FBQ0g7QUFyQ0w7QUFBQTtBQUFBLHdDQXVDd0I7QUFDaEIsVUFBSTBHLE9BQU8sR0FBRyxLQUFLZ3FCLGNBQUwsQ0FBb0JocUIsT0FBbEM7QUFDQUEsYUFBTyxDQUFDUyxLQUFSLEdBQWdCLEVBQWhCO0FBQ0FULGFBQU8sQ0FBQ0MsV0FBUixDQUFvQixJQUFwQjtBQUNBRCxhQUFPLENBQUNNLGdCQUFSLENBQXlCLENBQXpCO0FBQ0FOLGFBQU8sQ0FBQ0UsUUFBUixDQUFpQixDQUFqQjtBQUNBRixhQUFPLENBQUNHLFdBQVIsQ0FBb0IsSUFBcEI7QUFDQUgsYUFBTyxDQUFDSyxnQkFBUixDQUF5QnVWLFNBQXpCO0FBQ0E1VixhQUFPLENBQUNPLE9BQVIsR0FBa0IsSUFBbEI7QUFDQVAsYUFBTyxDQUFDNnFCLE9BQVIsR0FBa0IsRUFBbEI7QUFDSDtBQWpETDtBQUFBO0FBQUEsMkNBbUQyQjtBQUNuQixXQUFLOVksZUFBTCxHQUF1QjtBQUNuQixpQkFBUyxFQURVO0FBRW5CLGdCQUFRLENBRlc7QUFHbkIsZ0JBQVE7QUFIVyxPQUF2QjtBQUtIO0FBekRMO0FBQUE7O0FBMkRJOzs7QUEzREosNEJBOERZO0FBQ0o7QUFDQTtBQUNBLFdBQUsrWSxpQkFBTCxHQUhJLENBSUo7O0FBQ0EsV0FBS0MsWUFBTCxHQUxJLENBTUo7O0FBQ0EsV0FBS0Msb0JBQUwsR0FQSSxDQVFKOztBQUNBLFdBQUsxYixJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFyQixDQUE2QmtULEtBQTdCLEdBVEksQ0FVSjs7QUFDQSxXQUFLckcsSUFBTCxDQUFVek4sVUFBVixDQUFxQmxCLFFBQXJCLENBQThCZ1YsS0FBOUI7QUFDSDtBQTFFTDtBQUFBO0FBQUEsaUNBNEVpQjtBQUNUO0FBQ0E7QUFDQSxXQUFLbkksR0FBTCxHQUhTLENBSVQ7QUFDSDtBQWpGTDtBQUFBO0FBQUEsMkJBbUZXLENBRU47QUFyRkw7QUFBQTtBQUFBLDBCQXVGVTtBQUFBOztBQUNGLFdBQUt4VixhQUFMLEdBQXFCLEtBQUtpeUIsY0FBTCxDQUFvQnpjLEdBQXBCLENBQXdCYixHQUF4QixDQUE0QixJQUE1QixDQUFyQjtBQUNBLFVBQUloTixTQUFTLEdBQUcsS0FBSzBOLE9BQUwsR0FBZTRkLElBQWYsQ0FDWixLQUFLanpCLGFBQUwsQ0FBbUJpVSxPQUFuQixDQUEyQmxCLElBQTNCLENBQWdDLEtBQUsvUyxhQUFyQyxDQURZLEVBRVosS0FBS0EsYUFBTCxDQUFtQmt6QixPQUFuQixDQUEyQm5nQixJQUEzQixDQUFnQyxLQUFLL1MsYUFBckMsQ0FGWSxDQUFoQjs7QUFJQSxVQUFJLENBQUMsS0FBS3NYLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DNHZCLGVBQXBDLEVBQUwsRUFBNEQ7QUFDeER4ckIsaUJBQVMsQ0FBQ3NyQixJQUFWLENBQWUsWUFBTTtBQUNqQixlQUFJLENBQUNqekIsYUFBTCxDQUFtQm96QixrQkFBbkI7O0FBQ0EsaUJBQU8sS0FBSSxDQUFDN3dCLEtBQUwsRUFBUDtBQUNILFNBSEQ7QUFJSCxPQUxELE1BS087QUFDSG9GLGlCQUFTLENBQUNzckIsSUFBVixDQUFlLEtBQUtqekIsYUFBTCxDQUFtQnF6QixVQUFuQixDQUE4QnRnQixJQUE5QixDQUFtQyxLQUFLL1MsYUFBeEMsQ0FBZjtBQUNIOztBQUNEMkgsZUFBUyxDQUFDc3JCLElBQVYsQ0FBZSxLQUFLanpCLGFBQUwsWUFBMkIrUyxJQUEzQixDQUFnQyxLQUFLL1MsYUFBckMsQ0FBZjtBQUNIO0FBdEdMO0FBQUE7QUFBQSw0QkF3R1k7QUFDSixXQUFLQSxhQUFMLEdBQXFCLEtBQUtpeUIsY0FBTCxDQUFvQjF2QixLQUFwQixDQUEwQm9TLEdBQTFCLENBQThCLElBQTlCLENBQXJCO0FBQ0EsV0FBS1UsT0FBTCxHQUFlNGQsSUFBZixDQUNJLEtBQUtqekIsYUFBTCxDQUFtQmlVLE9BQW5CLENBQTJCbEIsSUFBM0IsQ0FBZ0MsS0FBSy9TLGFBQXJDLENBREosRUFFSSxLQUFLQSxhQUFMLENBQW1Ca3pCLE9BQW5CLENBQTJCbmdCLElBQTNCLENBQWdDLEtBQUsvUyxhQUFyQyxDQUZKLEVBSUtpekIsSUFKTCxDQUlVLEtBQUtqekIsYUFBTCxZQUEyQitTLElBQTNCLENBQWdDLEtBQUsvUyxhQUFyQyxDQUpWLEVBS0tpekIsSUFMTCxDQUtVLEtBQUtLLGFBQUwsQ0FBbUJ2Z0IsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FMVjtBQU1IO0FBaEhMO0FBQUE7QUFBQSwrQkFrSGU7QUFBQTs7QUFDUCxXQUFLdUUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDbUosTUFBL0M7QUFDQSxVQUFJcWtCLGVBQWUsR0FBRyxLQUFLamMsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkJtTCxRQUE3QixFQUF0QjtBQUNBbkwsYUFBTyxDQUFDQyxHQUFSLENBQVk2b0IsZUFBWjtBQUNBQSxxQkFBZSxDQUFDTixJQUFoQixDQUFxQixVQUFDTyxTQUFELEVBQWU7QUFDaEMsY0FBSSxDQUFDeHpCLGFBQUwsR0FBcUIsTUFBSSxDQUFDaXlCLGNBQUwsQ0FBb0JFLElBQXBCLENBQXlCeGQsR0FBekIsQ0FBNkIsTUFBN0IsRUFBbUM2ZSxTQUFuQyxDQUFyQjs7QUFDQSxZQUFJN3JCLFNBQVMsR0FBRyxNQUFJLENBQUMwTixPQUFMLEdBQWU0ZCxJQUFmLENBQ1osTUFBSSxDQUFDanpCLGFBQUwsQ0FBbUJpVSxPQUFuQixDQUEyQmxCLElBQTNCLENBQWdDLE1BQUksQ0FBQy9TLGFBQXJDLENBRFksRUFFWixNQUFJLENBQUNBLGFBQUwsQ0FBbUJrekIsT0FBbkIsQ0FBMkJuZ0IsSUFBM0IsQ0FBZ0MsTUFBSSxDQUFDL1MsYUFBckMsQ0FGWSxDQUFoQjs7QUFJQSxZQUFJLENBQUMsTUFBSSxDQUFDc1gsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0M0dkIsZUFBcEMsRUFBRCxJQUNBLE1BQUksQ0FBQzdiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQTNCLEVBREosRUFDeUM7QUFDckMsZ0JBQUksQ0FBQ3pDLGFBQUwsQ0FBbUJvekIsa0JBQW5COztBQUNBenJCLG1CQUFTLENBQUNzckIsSUFBVixDQUFlLE1BQUksQ0FBQ3h3QixNQUFMLENBQVlzUSxJQUFaLENBQWlCLE1BQWpCLENBQWY7QUFDSCxTQUpELE1BSU87QUFDSHBMLG1CQUFTLENBQUNzckIsSUFBVixDQUFlLE1BQUksQ0FBQ2p6QixhQUFMLENBQW1CcXpCLFVBQW5CLENBQThCdGdCLElBQTlCLENBQW1DLE1BQUksQ0FBQy9TLGFBQXhDLENBQWYsRUFDS2l6QixJQURMLENBQ1UsTUFBSSxDQUFDcmQsUUFBTCxDQUFjN0MsSUFBZCxDQUFtQixNQUFuQixDQURWO0FBRUg7O0FBQ0RwTCxpQkFBUyxDQUFDc3JCLElBQVYsQ0FBZSxNQUFJLENBQUNqekIsYUFBTCxZQUEyQitTLElBQTNCLENBQWdDLE1BQUksQ0FBQy9TLGFBQXJDLENBQWY7QUFDSCxPQWZEO0FBZ0JIO0FBdElMO0FBQUE7QUFBQSw2QkF3SWE7QUFDTCxXQUFLQSxhQUFMLEdBQXFCLEtBQUtpeUIsY0FBTCxDQUFvQnh2QixNQUFwQixDQUEyQmtTLEdBQTNCLENBQStCLElBQS9CLENBQXJCO0FBQ0EsV0FBS1UsT0FBTCxHQUFlNGQsSUFBZixDQUNJLEtBQUtqekIsYUFBTCxDQUFtQmlVLE9BQW5CLENBQTJCbEIsSUFBM0IsQ0FBZ0MsS0FBSy9TLGFBQXJDLENBREosRUFFSSxLQUFLQSxhQUFMLENBQW1Ca3pCLE9BQW5CLENBQTJCbmdCLElBQTNCLENBQWdDLEtBQUsvUyxhQUFyQyxDQUZKLEVBSUtpekIsSUFKTCxDQUlVLEtBQUtyZCxRQUFMLENBQWM3QyxJQUFkLENBQW1CLElBQW5CLENBSlYsRUFLS2tnQixJQUxMLENBS1UsS0FBS2p6QixhQUFMLFlBQTJCK1MsSUFBM0IsQ0FBZ0MsS0FBSy9TLGFBQXJDLENBTFY7QUFNSDtBQWhKTDtBQUFBO0FBQUEsK0JBa0plO0FBQ1AsV0FBS0EsYUFBTCxHQUFxQixLQUFLaXlCLGNBQUwsQ0FBb0J6dkIsUUFBcEIsQ0FBNkJtUyxHQUE3QixDQUFpQyxJQUFqQyxDQUFyQjtBQUNIO0FBcEpMO0FBQUE7QUFBQSw4QkFzSmM7QUFBQTs7QUFDTixXQUFLMkMsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDbUosTUFBL0M7QUFDQSxhQUFPZ0ksRUFBRSxDQUFDdWMsUUFBSCxDQUFZQyxjQUFaLENBQTJCO0FBQUEsZUFDOUJ4YyxFQUFFLENBQUN5YyxrQkFBSCxDQUFzQixNQUFJLENBQUMzekIsYUFBTCxDQUFtQmlFLFFBQXpDLEVBQW1ELEtBQW5ELEVBQ3NCLE1BQUksQ0FBQ2pFLGFBQUwsQ0FBbUJ5RCxJQUR6QyxFQUMrQyxJQUQvQyxFQUVzQixNQUFJLENBQUN6RCxhQUFMLENBQW1CMEksVUFGekMsQ0FEOEI7QUFBQSxPQUEzQixDQUFQO0FBS0g7QUFFRDs7OztBQS9KSjtBQUFBO0FBQUEsZ0NBa0tnQjtBQUNSLFVBQUlrckIsUUFBUSxHQUFHLFdBQWYsQ0FEUSxDQUVSOztBQUNBLFVBQUksQ0FBQyxLQUFLdGMsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnV5QixRQUFoQixDQUF5QkQsUUFBekIsSUFBcUNuWSxJQUFyQyxFQUFMLEVBQWtEO0FBQzlDLGVBQU8sS0FBUDtBQUNIOztBQUNELFdBQUtuRSxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEI5QixNQUExQixDQUFpQyxVQUFqQztBQUNBLFdBQUt5UixJQUFMLENBQVV6TixVQUFWLENBQXFCQyxNQUFyQixDQUE0QmdxQixRQUE1QixHQVBRLENBUVI7O0FBQ0EsVUFBSWptQixNQUFNLEdBQUcsSUFBYjtBQUNBLFVBQUlsRixRQUFRLEdBQUcsS0FBSzJPLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJsQixRQUFwQztBQUNBa0YsWUFBTSxDQUFDa2xCLFlBQVA7QUFDQWxsQixZQUFNLENBQUNrbUIsVUFBUDtBQUNBbG1CLFlBQU0sQ0FBQ21tQixXQUFQO0FBQ0FubUIsWUFBTSxDQUFDb21CLGlCQUFQLENBQXlCTCxRQUF6QixFQUFtQyxJQUFuQyxFQUF5QyxVQUFVTSxNQUFWLEVBQWtCO0FBQ3ZELFlBQUloZCxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixZQUFwQixFQUFrQyxTQUFsQyxDQUFKLEVBQWtEO0FBQzlDO0FBQ0E7QUFDQSxjQUFJLENBQUNsZ0IsT0FBRCxJQUNBLEVBQUVwTCxRQUFRLEtBQUssWUFBYixJQUE2QkMsS0FBSyxLQUFLLFdBQXpDLENBREosRUFDMkQ7QUFDdkRILG9CQUFRLENBQUN5ckIsZUFBVCxDQUF5QnZyQixRQUF6QixFQUFtQ0MsS0FBbkMsRUFBMENGLE9BQTFDLEVBQW1EeUcsSUFBbkQ7QUFDSDs7QUFDRHhCLGdCQUFNLENBQUN5SixJQUFQLENBQVl6TixVQUFaLENBQXVCbEIsUUFBdkIsQ0FBZ0N5ckIsZUFBaEMsQ0FBZ0RGLE1BQU0sQ0FBQ0csRUFBdkQ7QUFDQXhtQixnQkFBTSxDQUFDeUosSUFBUCxDQUFZaFcsS0FBWixDQUFrQnFHLFNBQWxCLENBQTRCOUIsTUFBNUIsQ0FBbUMsVUFBbkM7QUFDSDtBQUNKLE9BWEQ7QUFZQWdJLFlBQU0sQ0FBQ3lKLElBQVAsQ0FBWXpOLFVBQVosQ0FBdUJDLE1BQXZCLENBQThCdEQsUUFBOUIsQ0FBdUMsUUFBdkMsRUFBaUQsV0FBakQ7QUFDSDtBQTdMTDtBQUFBOztBQWdNSTs7OztBQWhNSixvQ0FvTW9CO0FBQ1osVUFBSSxLQUFLbXNCLGNBQUwsS0FBd0IsSUFBNUIsRUFBa0M7QUFDOUIsYUFBS0EsY0FBTDtBQUNIO0FBQ0o7QUFFRDs7OztBQTFNSjtBQUFBO0FBQUEsc0NBNk1zQjtBQUNkLFVBQUksS0FBS0QsZ0JBQUwsS0FBMEIsSUFBOUIsRUFBb0M7QUFDaEMsYUFBS0EsZ0JBQUw7QUFDSDtBQUNKO0FBak5MOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJPLElBQU00QixZQUFZLEdBQUcsbURBQXJCO0FBRVA7Ozs7O0FBSU8sSUFBTUMsYUFBYjtBQUVJLHlCQUFZamQsSUFBWixFQUFrQjtBQUFBOztBQUNkLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtyVCxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS1IsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLaUYsVUFBTCxHQUFrQnRJLFNBQWxCO0FBQ0g7O0FBUEw7QUFBQTtBQUFBLHdCQVNReU4sTUFUUixFQVNnQjtBQUFBOztBQUNSO0FBQ0EsV0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0FxSixRQUFFLENBQUNpZCxnQkFBSCxHQUFzQixLQUFLN2MsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUFoRDtBQUNBc1AsUUFBRSxDQUFDek0sT0FBSCxHQUFhLEtBQUs2TSxJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFsQztBQUNBeU0sUUFBRSxDQUFDMEYsV0FBSCxHQUFpQixFQUFqQjtBQUNBMUYsUUFBRSxDQUFDc2IsU0FBSCxDQUFhLEtBQUtDLGdCQUFMLEVBQWIsRUFOUSxDQU9SOztBQUNBdmIsUUFBRSxDQUFDc2QsU0FBSCxHQUFlLEtBQUtDLFFBQUwsQ0FBYzFoQixJQUFkLENBQW1CLElBQW5CLENBQWYsQ0FSUSxDQVNSOztBQUNBbUUsUUFBRSxDQUFDd2QsV0FBSCxHQUFpQixVQUFDenlCLEdBQUQsRUFBTXVJLElBQU4sRUFBWW1xQixPQUFaO0FBQUEsZUFBd0IsS0FBSSxDQUFDQyxPQUFMLENBQWEzeUIsR0FBYixFQUFrQnVJLElBQWxCLEVBQXdCbXFCLE9BQXhCLENBQXhCO0FBQUEsT0FBakIsQ0FWUSxDQVdSOzs7QUFDQXpkLFFBQUUsQ0FBQzJkLGNBQUgsR0FBb0IsVUFBQ0MsVUFBRCxFQUFhQyxTQUFiLEVBQTJCO0FBQzNDLFlBQUksS0FBSSxDQUFDemQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0N5eEIsY0FBcEMsRUFBSixFQUEwRDtBQUN0RCxpQkFBTyxJQUFQO0FBQ0g7O0FBQ0QsWUFBSWxaLGFBQWEsR0FBRyxLQUFJLENBQUNtWixnQkFBTCxDQUFzQkgsVUFBVSxHQUFDLElBQVgsR0FBa0IsRUFBeEMsQ0FBcEI7O0FBQ0EsWUFBSUksS0FBSyxHQUFHdmMsTUFBTSxDQUFDbUQsYUFBRCxFQUFnQjVFLEVBQUUsQ0FBQzZkLFNBQUgsR0FBYSxJQUE3QixDQUFsQjs7QUFDQSxZQUFJRyxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxJQUFFLENBQTdCLEVBQWdDO0FBQzVCQSxlQUFLLEdBQUdoZSxFQUFFLENBQUM2ZCxTQUFILEdBQWVJLFFBQVEsQ0FBQ0QsS0FBRCxFQUFRLEVBQVIsQ0FBUixHQUFzQixJQUE3QztBQUNBaGUsWUFBRSxDQUFDNmQsU0FBSCxHQUFlRyxLQUFmOztBQUNBaGUsWUFBRSxDQUFDa2UsaUJBQUgsR0FBdUI7QUFBQSxtQkFDbkIsS0FBSSxDQUFDOWQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0N5eEIsY0FBcEMsS0FBdURLLFFBQXZELEdBQWtFSCxLQUQvQztBQUFBLFdBQXZCO0FBRUg7O0FBQ0QsZUFBT0EsS0FBUDtBQUNILE9BYkQsQ0FaUSxDQTBCUjs7O0FBQ0FoZSxRQUFFLENBQUNvZSxVQUFILEdBQWdCLEtBQUtBLFVBQUwsQ0FBZ0J2aUIsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBaEI7QUFDQSxhQUFPLElBQVA7QUFDSDtBQXRDTDtBQUFBO0FBQUEscUNBd0NxQndpQixXQXhDckIsRUF3Q2tDO0FBQzFCLFVBQUlBLFdBQUosRUFBaUI7QUFDYixlQUFPLGlLQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxxRkFBUDtBQUNIO0FBQ0o7QUE5Q0w7QUFBQTtBQUFBLHVDQWdEdUI7QUFDZixhQUFPO0FBQ0hDLGtCQUFVLEVBQUV0ZSxFQUFFLENBQUN1ZSxPQURaO0FBRUg7QUFDQUMsWUFBSSxFQUFFLEtBQUtDLFVBQUwsQ0FBZ0I1aUIsSUFBaEIsQ0FBcUIsSUFBckIsQ0FISDtBQUlIO0FBQ0E7QUFDQTtBQUNBNmlCLGlCQUFTLEVBQUUsS0FBS0MsU0FBTCxDQUFlOWlCLElBQWYsQ0FBb0IsSUFBcEIsQ0FQUjtBQVFIO0FBQ0FsTCxjQUFNLEVBQUUsS0FBS2l1QixLQUFMLENBQVcvaUIsSUFBWCxDQUFnQixJQUFoQixDQVRMO0FBVUg7QUFDQWdqQixnQkFBUSxFQUFFLEtBQUtqdUIsS0FBTCxDQUFXaUwsSUFBWCxDQUFnQixJQUFoQixDQVhQO0FBWUhpakIsMkJBQW1CLEVBQUUsSUFabEI7QUFhSDtBQUNBQyxrQkFBVSxFQUFFLEtBQUtDLGFBQUwsQ0FBbUJuakIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FkVDtBQWVIO0FBQ0FvakIsa0JBQVUsRUFBRSxvQkFBQ0MsSUFBRDtBQUFBLG1FQUFxREEsSUFBSSxDQUFDcm9CLFdBQUwsRUFBckQ7QUFBQSxTQWhCVDtBQWlCSDtBQUNBc29CLHFCQUFhLEVBQUU7QUFsQlosT0FBUDtBQW9CSDtBQUVEOzs7Ozs7Ozs7QUF2RUo7QUFBQTtBQUFBLCtCQStFZXB5QixRQS9FZixFQStFeUI7QUFDakJ3RyxhQUFPLENBQUM2ckIsSUFBUixDQUFhLHVCQUFiLEVBRGlCLENBRWpCO0FBQ0g7QUFsRkw7QUFBQTtBQUFBLDRCQW9GWXIwQixHQXBGWixFQW9GaUJ1SSxJQXBGakIsRUFvRnVCbXFCLE9BcEZ2QixFQW9GZ0M7QUFDeEI7QUFDQSxVQUFJNEIsV0FBVyxHQUFHLEtBQUtqZixJQUFMLENBQVV6TixVQUFWLENBQXFCZSxVQUFyQixDQUFnQzRHLE9BQWhDLENBQXdDLG9CQUF4QyxDQUFsQjs7QUFDQSxVQUFJK2tCLFdBQVcsSUFBSSxJQUFuQixFQUF5QjtBQUNyQixjQUFPLElBQUlyZixFQUFFLENBQUNzZixPQUFILENBQVdDLE9BQWYsQ0FBdUIsd0VBQXZCLENBQVA7QUFDSDs7QUFDREYsaUJBQVcsR0FBRzFsQixJQUFJLENBQUM4RixLQUFMLENBQVc0ZixXQUFXLENBQUM3a0IsTUFBWixFQUFYLENBQWQ7O0FBQ0EsV0FBSyxJQUFJek4sUUFBVCxJQUFxQnN5QixXQUFyQixFQUFrQztBQUM5QixZQUFJQSxXQUFXLENBQUNHLGNBQVosQ0FBMkJ6eUIsUUFBM0IsQ0FBSixFQUEwQztBQUN0QyxlQUFLLElBQUl3YixDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUc4VyxXQUFXLENBQUN0eUIsUUFBRCxDQUFYLENBQXNCdU0sTUFBeEMsRUFBZ0RpUCxDQUFDLElBQUcsQ0FBcEQsRUFBdUQ7QUFDbkQsZ0JBQUk4VyxXQUFXLENBQUN0eUIsUUFBRCxDQUFYLENBQXNCd2IsQ0FBdEIsTUFBNkJ4ZCxHQUFqQyxFQUFzQztBQUNsQyxrQkFBSTAwQixRQUFRLEdBQUcsS0FBS3JmLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJlLFVBQXJCLENBQWdDZ3NCLFFBQWhDLENBQXlDM3lCLFFBQXpDLENBQWY7QUFDQSxxQkFBUTB5QixRQUFSO0FBQ0g7QUFDSjtBQUNKO0FBQ0osT0FoQnVCLENBaUJ4Qjs7O0FBQ0EsWUFBTyxJQUFJemYsRUFBRSxDQUFDc2YsT0FBSCxDQUFXQyxPQUFmLENBQXVCLHdCQUFzQngwQixHQUF0QixHQUEwQiw2Q0FBakQsQ0FBUCxDQWxCd0IsQ0FtQnhCO0FBQ0g7QUF4R0w7QUFBQTtBQUFBLCtCQTBHZTtBQUNQd0ksYUFBTyxDQUFDNnJCLElBQVIsQ0FBYSx1QkFBYixFQURPLENBRVA7QUFDSDtBQTdHTDtBQUFBO0FBQUEsZ0NBK0dnQjtBQUNSN3JCLGFBQU8sQ0FBQzZyQixJQUFSLENBQWEsdUJBQWIsRUFEUSxDQUVSO0FBQ0g7QUFsSEw7QUFBQTtBQUFBLDBCQW9IVXhXLEtBcEhWLEVBb0hpQjtBQUNULFdBQUt4SSxJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFyQixDQUE2QnFyQixLQUE3QixDQUFtQ2hXLEtBQW5DO0FBQ0g7QUF0SEw7QUFBQTtBQUFBLDRCQXdIWTtBQUNKclYsYUFBTyxDQUFDNnJCLElBQVIsQ0FBYSx1QkFBYixFQURJLENBRUo7QUFDSDtBQTNITDtBQUFBO0FBQUEsaUNBNkhpQjtBQUNULFVBQUksS0FBS2hmLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QnVCLFdBQXhCLEVBQUosRUFBMkM7QUFDdkMsYUFBSytSLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkcsS0FBMUIsQ0FBZ0MsRUFBaEM7QUFDSDs7QUFDRCxXQUFLd1AsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSSxVQUExQixDQUFxQyxDQUFyQztBQUNIO0FBbElMO0FBQUE7QUFBQSxrQ0E0SWtCOUYsR0E1SWxCLEVBNEl1QjtBQUNmO0FBQ0EsYUFBT0EsR0FBUDtBQUNIO0FBL0lMO0FBQUE7QUFBQSwyQkFpSlcsQ0FFTjtBQW5KTDtBQUFBO0FBQUEsK0JBcUplLENBRVY7QUF2Skw7QUFBQTtBQUFBLGdDQXlKZ0JnQyxRQXpKaEIsRUF5SjBCO0FBQ2xCLGFBQU8sS0FBUDtBQUNIO0FBM0pMO0FBQUE7QUFBQSw0QkE2Sllpd0IsTUE3SlosRUE2Sm9CO0FBQ1osWUFBTSxJQUFJMkMsS0FBSixDQUFVLDRCQUFWLENBQU47QUFDSDtBQS9KTDtBQUFBO0FBQUEsNEJBaUtZdFYsS0FqS1osRUFpS21CO0FBQ1gsWUFBTSxJQUFJc1YsS0FBSixDQUFVLDRCQUFWLENBQU47QUFDSDtBQW5LTDtBQUFBO0FBQUEsNkJBcUtZamdCLE1BcktaLEVBcUtvQjtBQUNaO0FBQ0EsVUFBSSxLQUFLVSxJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFyQixDQUE2QitULFVBQWpDLEVBQTZDO0FBQ3pDLGFBQUtsSCxJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFyQixDQUE2QitULFVBQTdCLENBQXdDdkQsT0FBeEM7QUFDQSxhQUFLM0QsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkIrVCxVQUE3QixDQUF3Q3NZLElBQXhDO0FBQ0g7QUFDSjtBQTNLTDtBQUFBO0FBQUEsc0NBNktzQixDQUNkO0FBQ0g7QUEvS0w7QUFBQTtBQUFBLCtCQWlMZUMsWUFqTGYsRUFpTDZCQyxPQWpMN0IsRUFpTHNDQyxNQWpMdEMsRUFpTDhDO0FBQ3RDO0FBQ0E7QUFDQSxVQUFJQyxZQUFZLEdBQUcsS0FBSzVmLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NJLE9BQXJEOztBQUNBLFVBQUksRUFBRSxXQUFXa3ZCLFlBQWIsQ0FBSixFQUFnQztBQUM1QkEsb0JBQVksQ0FBQ3p1QixLQUFiLEdBQXFCLEVBQXJCO0FBQ0g7O0FBQ0QsVUFBSSxFQUFFc3VCLFlBQVksSUFBSUcsWUFBWSxDQUFDenVCLEtBQS9CLENBQUosRUFBMkM7QUFDdkN5dUIsb0JBQVksQ0FBQ3p1QixLQUFiLENBQW1Cc3VCLFlBQW5CLElBQW1DLEVBQW5DO0FBQ0g7O0FBQ0QsVUFBSUksSUFBSSxHQUFHLEVBQVgsQ0FWc0MsQ0FXdEM7O0FBQ0EsV0FBSyxJQUFJMVgsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHdVgsT0FBTyxDQUFDeG1CLE1BQTFCLEVBQWtDaVAsQ0FBQyxJQUFHLENBQXRDLEVBQXlDO0FBQ3JDMFgsWUFBSSxDQUFDLFVBQVExWCxDQUFULENBQUosR0FBa0J1WCxPQUFPLENBQUN2WCxDQUFELENBQXpCO0FBQ0g7O0FBQ0QsVUFBSXdYLE1BQU0sSUFBSUEsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhLElBQTNCLEVBQWlDO0FBQzdCRSxZQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCRixNQUFNLENBQUMsQ0FBRCxDQUF2QjtBQUNIOztBQUNELFVBQUlBLE1BQU0sSUFBSUEsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhLElBQTNCLEVBQWlDO0FBQzdCRSxZQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CRixNQUFNLENBQUMsQ0FBRCxDQUF6QjtBQUNILE9BcEJxQyxDQXFCdEM7OztBQUNBQyxrQkFBWSxDQUFDenVCLEtBQWIsQ0FBbUJzdUIsWUFBbkIsRUFBaUNsYSxJQUFqQyxDQUFzQ3NhLElBQXRDO0FBQ0g7QUF4TUw7QUFBQTtBQUFBLHdDQW9JK0I7QUFDdkIsVUFBSWpnQixFQUFFLENBQUMwRixXQUFILENBQWVwTSxNQUFuQixFQUEyQjtBQUN2QixlQUFPMEcsRUFBRSxDQUFDMEYsV0FBSCxDQUFld2EsR0FBZixFQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxFQUFQO0FBQ0g7QUFDSjtBQTFJTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFFTyxJQUFNaEYsaUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRdmtCLE1BRFIsRUFDZ0JwSyxJQURoQixFQUNzQjtBQUNkO0FBQ0EsV0FBSzZULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DQyxPQUFuQyxDQUEyQyxZQUEzQztBQUNBLFdBQUszRSxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsV0FBS1IsSUFBTCxHQUFZLFNBQVNBLElBQXJCO0FBQ0F5VCxRQUFFLENBQUNtZ0Isb0JBQUgsR0FBMEIsSUFBMUI7QUFDQW5nQixRQUFFLENBQUNvZSxVQUFILEdBQWdCLElBQWhCOztBQUVBLGlGQUFVem5CLE1BQVY7O0FBRUFxSixRQUFFLENBQUNtZixhQUFILEdBQW1CLElBQW5CO0FBQ0FuZixRQUFFLENBQUMxTyxPQUFILEdBQWEsS0FBSzhPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NRLE9BQWxDLEVBQWI7QUFFQSxXQUFLOE8sSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ0RCxRQUE1QixDQUFxQyxZQUFyQyxFQUFtRCxFQUFuRCxFQUF1RCxFQUF2RCxFQUEyRC9DLElBQTNELEVBQWlFLGFBQWpFO0FBQ0EsV0FBSzZULElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsU0FBckMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0QsS0FBSy9DLElBQTdELEVBQW1FLGFBQW5FO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFsQkw7QUFBQTtBQUFBLDRCQW9CWXl3QixNQXBCWixFQW9Cb0I7QUFBQTs7QUFDWnpwQixhQUFPLENBQUNDLEdBQVIsQ0FBWSxjQUFaO0FBQ0EsV0FBSzRNLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsb0JBQXJDLEVBQTJELEVBQTNELEVBQStELEVBQS9ELEVBQW1FLEVBQW5FLEVBQXVFLGFBQXZFO0FBQ0EsV0FBSzhRLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0J1RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ0MsS0FBL0M7QUFDQSxXQUFLc1IsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ1EsT0FBbEMsQ0FBMEMwTyxFQUFFLENBQUMxTyxPQUE3QztBQUNBME8sUUFBRSxDQUFDMU8sT0FBSCxHQUFhLEVBQWI7QUFDQSxVQUFJb3FCLE1BQU0sR0FBRyxLQUFLdGIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUF2QztBQUNBLFVBQUkzRCxRQUFRLEdBQUcsS0FBS0EsUUFBcEI7QUFDQSxXQUFLcVQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ08sT0FBbEMsR0FBNEMyckIsTUFBNUM7QUFDQSxXQUFLNWMsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkI2c0IsVUFBN0IsQ0FBd0NwZ0IsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQnJELE1BQU0sQ0FBQ0csRUFBUCxDQUFVbUQsQ0FBVixDQUFZQyxFQUFaLEVBQWpCLENBQXhDO0FBQ0EsYUFBTyxJQUFJamIsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVTRQLE1BQVYsRUFBcUI7QUFDcEM7QUFDQSxhQUFJLENBQUNua0IsUUFBTDs7QUFDQTBxQixjQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CO0FBQ2hCLHFCQUFXLElBREs7QUFFaEIsbUJBQVMsS0FBSSxDQUFDL2tCLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEIzSyxLQUZyQjtBQUdoQixtQkFBUyxLQUFJLENBQUN2QixNQUFMLENBQVlrTSxlQUFaLENBQTRCM0ssS0FBNUIsQ0FBa0NnRCxHQUFsQyxDQUFzQyxVQUFBc2xCLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDcm9CLElBQU47QUFBQSxXQUF2QyxDQUhPO0FBSWhCLHVCQUFhLEtBQUksQ0FBQ3hCLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEIzSyxLQUE1QixDQUFrQ29ZLE1BQWxDLENBQXlDLFVBQUFrUSxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxXQUFQO0FBQUEsV0FBMUMsRUFBOER2bEIsR0FBOUQsQ0FBa0UsVUFBQXNsQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ3JvQixJQUFOO0FBQUEsV0FBbkUsQ0FKRztBQUtoQixxQkFBVzZrQixNQUxLO0FBTWhCLG9CQUFVLEtBQUksQ0FBQzVjLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkUsTUFOcEI7QUFPaEIsd0JBQWMsS0FBSSxDQUFDcEUsSUFQSDtBQVFoQixtQkFBUyxLQUFJLENBQUM2VCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUyxLQVIzQjtBQVNoQixxQkFBVztBQVRLLFNBQXBCO0FBV0FnVSxlQUFPO0FBQ1YsT0FmTSxDQUFQO0FBZ0JIO0FBOUNMO0FBQUE7QUFBQSw0QkFnRFk4RSxLQWhEWixFQWdEbUI7QUFBQTs7QUFDWDlXLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLGNBQVosRUFBNEI2VyxLQUE1QjtBQUNBLFdBQUtqSyxJQUFMLENBQVVoVyxLQUFWLENBQWdCdUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUMrb0IsTUFBL0M7QUFDQSxVQUFJOEQsTUFBTSxHQUFHLEtBQUt0YixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsV0FBSzBQLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsZUFBckMsRUFBc0QsRUFBdEQsRUFBMEQsRUFBMUQsRUFBOEQrYSxLQUFLLENBQUM1YixRQUFOLEVBQTlELEVBQWdGLGFBQWhGO0FBQ0EsYUFBTyxJQUFJNlcsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVTRQLE1BQVYsRUFBcUI7QUFDcEN1RyxjQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CO0FBQ2hCLHFCQUFXLEtBREs7QUFFaEIsbUJBQVNyUixLQUZPO0FBR2hCLHdCQUFjLE1BQUksQ0FBQzlkLElBSEg7QUFJaEIscUJBQVc7QUFKSyxTQUFwQjtBQU1BZ1osZUFBTztBQUNWLE9BUk0sQ0FBUDtBQVNIO0FBOURMOztBQUFBO0FBQUEsRUFBdUNtYiw2REFBdkMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBTUMsbUJBQW1CLEdBQUcsMEJBQTBCQyxvRkFBa0IsQ0FBQ255QixRQUFuQixFQUF0RDtBQUNBLElBQU1veUIsb0JBQW9CLEdBQUdDLHlFQUE3QjtBQUVPLElBQU1DLHVCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUXBxQixNQURSLEVBQ2dCO0FBQUE7O0FBQ1IsdUZBQVVBLE1BQVYsRUFEUSxDQUVSOzs7QUFDQXFKLFFBQUUsQ0FBQ2tlLGlCQUFILEdBQXVCO0FBQUEsZUFDbkIsS0FBSSxDQUFDOWQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0N5eEIsY0FBcEMsS0FBdURLLFFBQXZELEdBQWtFLElBRC9DO0FBQUEsT0FBdkI7O0FBRUFuZSxRQUFFLENBQUM2ZCxTQUFILEdBQWU3ZCxFQUFFLENBQUNrZSxpQkFBSCxFQUFmLENBTFEsQ0FNUjs7QUFDQWxlLFFBQUUsQ0FBQ21nQixvQkFBSCxHQUEwQixJQUExQixDQVBRLENBT3dCO0FBQ2hDOztBQUNBLFdBQUsvZixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JHLFdBQXhCLENBQW9DLElBQXBDLEVBVFEsQ0FVUjs7QUFDQStTLFFBQUUsQ0FBQzBGLFdBQUgsR0FBaUIsRUFBakIsQ0FYUSxDQVlSO0FBQ0E7QUFDQTs7QUFDQTFGLFFBQUUsQ0FBQ2doQixnQkFBSCxHQUFzQmhoQixFQUFFLENBQUNvZSxVQUF6QjtBQUNBcGUsUUFBRSxDQUFDb2UsVUFBSCxHQUFnQixJQUFoQixDQWhCUSxDQWlCUjs7QUFDQXBlLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQmxILEtBQWhCLENBQXNCLDZCQUF0QixJQUF1RDRuQixtQkFBdkQ7QUFDQTNnQixRQUFFLENBQUNDLFlBQUgsQ0FBZ0JsSCxLQUFoQixDQUFzQixxQkFBdEIsSUFBK0M4bkIsb0JBQS9DLENBbkJRLENBb0JSO0FBQ0E7O0FBQ0E3Z0IsUUFBRSxDQUFDQyxZQUFILENBQWdCbEgsS0FBaEIsQ0FBc0IsaUNBQXRCLElBQTJEa29CLDBFQUEzRDtBQUNBLGFBQU9qaEIsRUFBRSxDQUFDQyxZQUFILENBQWdCbEgsS0FBaEIsQ0FBc0IsaUNBQXRCLENBQVAsQ0F2QlEsQ0F3QlI7O0FBQ0FpSCxRQUFFLENBQUNDLFlBQUgsQ0FBZ0JsSCxLQUFoQixDQUFzQiwyQkFBdEIsSUFBcURxa0IsK0RBQXJELENBekJRLENBMEJSOztBQUNBLFdBQUs1ckIsVUFBTCxHQUFrQixLQUFLMHZCLDJCQUFMLEVBQWxCLENBM0JRLENBNEJSOztBQUNBbGhCLFFBQUUsQ0FBQ2toQiwyQkFBSCxHQUFpQyxLQUFLQSwyQkFBdEM7QUFDQSxhQUFPLElBQVA7QUFDSDtBQWhDTDtBQUFBO0FBQUEsa0RBa0NrQztBQUMxQixVQUFJMXZCLFVBQVUsR0FBRyxLQUFLNE8sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCekQsVUFBMUIsQ0FBcUN3RSxVQUF0RCxDQUQwQixDQUUxQjs7QUFDQSxVQUFJQSxVQUFVLEtBQUt0SSxTQUFuQixFQUE4QjtBQUFBLG1EQUNMLEtBQUtpNEIsZUFBTCxFQURLO0FBQUE7O0FBQUE7QUFDMUIsOERBQTZDO0FBQUEsZ0JBQXBDcDBCLFFBQW9DO0FBQ3pDLGdCQUFJcTBCLFVBQVUsR0FBRyxJQUFJcGhCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUJ0MEIsUUFBbkIsQ0FBakI7O0FBQ0EsZ0JBQUl5RSxVQUFVLENBQUM4dkIsWUFBWCxDQUF3QkYsVUFBeEIsQ0FBSixFQUF5QztBQUNyQzV2Qix3QkFBVSxDQUFDK3ZCLFFBQVgsQ0FBb0JILFVBQXBCO0FBQ0g7QUFDSjtBQU55QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTzdCOztBQUNELGFBQU81dkIsVUFBUDtBQUNIO0FBOUNMO0FBQUE7QUFBQSx5Q0FnRHlCO0FBQ2pCLFVBQU11SCxLQUFLLEdBQUc7QUFDVixxQkFBYSxLQUFLcUgsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1CNkQsS0FBbkIsQ0FBeUJxQixjQUF6QjtBQURILE9BQWQsQ0FEaUIsQ0FJakI7O0FBQ0EsV0FBS2dHLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUEzQixHQUFrRGtlLE9BQWxELENBQTBELFVBQUFyUSxJQUFJLEVBQUk7QUFDOUQsWUFBSSxDQUFFLE9BQU9tb0IsUUFBUCxDQUFnQm5vQixJQUFJLENBQUN0TSxRQUFMLEdBQWdCLENBQWhCLENBQWhCLENBQU4sRUFBNEM7QUFDeENnTSxlQUFLLENBQUNNLElBQUksQ0FBQ3RNLFFBQUwsRUFBRCxDQUFMLEdBQXlCMDBCLCtEQUFnQixDQUFDcG9CLElBQUksQ0FBQ2dDLFFBQUwsRUFBRCxDQUF6QztBQUNIO0FBQ0osT0FKRCxFQUxpQixDQVVqQjs7QUFDQSxXQUFLK0UsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCd0QsVUFBM0IsR0FBd0NrZCxPQUF4QyxDQUFnRCxVQUFBclEsSUFBSSxFQUFJO0FBQ3BETixhQUFLLENBQUNNLElBQUksQ0FBQ3RNLFFBQUwsRUFBRCxDQUFMLEdBQXlCc00sSUFBSSxDQUFDZ0MsUUFBTCxFQUF6QjtBQUNILE9BRkQ7QUFHQSxhQUFPdEMsS0FBUDtBQUNIO0FBL0RMO0FBQUE7QUFBQSxzQ0FpRXNCO0FBQ2QsZUFBUzJvQixLQUFULENBQWUzMEIsUUFBZixFQUF5QjtBQUNyQkEsZ0JBQVEsR0FBRzAwQiwrREFBZ0IsQ0FBQzEwQixRQUFELENBQTNCOztBQUNBLFlBQUlBLFFBQVEsQ0FBQ3FxQixRQUFULENBQWtCLEtBQWxCLENBQUosRUFBOEI7QUFDMUJycUIsa0JBQVEsR0FBR0EsUUFBUSxDQUFDOE4sS0FBVCxDQUFlLENBQWYsRUFBa0IsQ0FBQyxDQUFuQixDQUFYO0FBQ0g7O0FBQ0QsZUFBTzlOLFFBQVA7QUFDSDs7QUFDRCxjQUNJLFVBREosRUFFSSxhQUZKLDRCQUdPLEtBQUtxVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBM0IsR0FBa0QwUCxHQUFsRCxDQUFzRCxVQUFBN0IsSUFBSTtBQUFBLGVBQUksaUJBQWlCcW9CLEtBQUssQ0FBQ3JvQixJQUFJLENBQUN0TSxRQUFMLEVBQUQsQ0FBMUI7QUFBQSxPQUExRCxDQUhQLHNCQUlPLEtBQUtxVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ3RCxVQUEzQixHQUF3QzBPLEdBQXhDLENBQTRDLFVBQUE3QixJQUFJO0FBQUEsZUFBSXFvQixLQUFLLENBQUNyb0IsSUFBSSxDQUFDdE0sUUFBTCxFQUFELENBQVQ7QUFBQSxPQUFoRCxDQUpQO0FBTUg7QUEvRUw7QUFBQTtBQUFBLHFDQWlGcUJzeEIsV0FqRnJCLEVBaUZrQztBQUMxQixVQUFJQSxXQUFKLEVBQWlCO0FBQ2IsZUFBTyxzTkFBUDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8sdUpBQVA7QUFDSDtBQUNKO0FBdkZMO0FBQUE7QUFBQSw2QkF5RmF0eEIsUUF6RmIsRUF5RnVCO0FBQ2YsVUFBSTQwQixLQUFLLEdBQUcsS0FBS3ZoQixJQUFMLENBQVV6TixVQUFWLENBQXFCZSxVQUFyQixDQUFnQ2t1QixhQUFoQyxDQUE4QzcwQixRQUE5QyxFQUF3RCxLQUF4RCxDQUFaOztBQUNBLFVBQUk0MEIsS0FBSyxLQUFLejRCLFNBQWQsRUFBeUI7QUFDckIsY0FBTSxJQUFJOFcsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixxQkFBbUI5MEIsUUFBMUMsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNILGVBQU80MEIsS0FBSyxDQUFDdG1CLFFBQU4sRUFBUDtBQUNIO0FBQ0o7QUFoR0w7QUFBQTtBQUFBLCtCQWtHZXRPLFFBbEdmLEVBa0d5QjtBQUNqQixVQUFJQSxRQUFRLEtBQUssYUFBakIsRUFBZ0M7QUFDNUIsZUFBTyxLQUFLcVQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCdUQsSUFBM0IsRUFBUDtBQUNILE9BRkQsTUFFTyxJQUFJUSxRQUFRLEtBQUsseUJBQWpCLEVBQTRDO0FBQy9DLGVBQU8sS0FBS3FULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNDLEtBQTNCLEVBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSTBCLFFBQVEsS0FBSywwQkFBakIsRUFBNkM7QUFDaEQsZUFBTyxLQUFLcVQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCd0MsTUFBM0IsTUFBdUMsRUFBOUM7QUFDSCxPQUZNLE1BRUEsSUFBSXdCLFFBQVEsS0FBSywyQkFBakIsRUFBOEM7QUFDakQsZUFBT3F3QiwrREFBUDtBQUNILE9BRk0sTUFFQSxJQUFJcGQsRUFBRSxDQUFDQyxZQUFILEtBQW9CL1csU0FBeEIsRUFBbUM7QUFDdEMsY0FBTSxJQUFJOFcsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixrQ0FBdkIsQ0FBTjtBQUNILE9BRk0sTUFFQSxJQUFJN2hCLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QmxULFFBQXpCLE1BQXVDN0QsU0FBM0MsRUFBc0Q7QUFDekQsZUFBTzhXLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QmxULFFBQXpCLENBQVA7QUFDSCxPQUZNLE1BRUE7QUFDSCxZQUFJNDBCLEtBQUssR0FBRyxLQUFLdmhCLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJlLFVBQXJCLENBQWdDa3VCLGFBQWhDLENBQThDNzBCLFFBQTlDLEVBQXdELEtBQXhELENBQVo7O0FBQ0EsWUFBSTQwQixLQUFLLEtBQUt6NEIsU0FBZCxFQUF5QjtBQUNyQixnQkFBTSxJQUFJOFcsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixzQkFBb0I5MEIsUUFBcEIsR0FBK0IsR0FBdEQsQ0FBTjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFPNDBCLEtBQUssQ0FBQ3RtQixRQUFOLEVBQVA7QUFDSDtBQUNKO0FBQ0o7QUF2SEw7QUFBQTtBQUFBLDBCQXlIVXVKLGFBekhWLEVBeUh5QjtBQUNqQjtBQUNBclIsYUFBTyxDQUFDQyxHQUFSLENBQVksS0FBWixFQUFtQixLQUFLNE0sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixFQUFuQixFQUFzRCxLQUFLd1AsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSSxVQUExQixFQUF0RDs7QUFDQSxVQUFJLEtBQUt1UCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJJLFVBQTFCLEtBQXlDLEtBQUt1UCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJHLEtBQTFCLEdBQWtDMEksTUFBL0UsRUFBdUY7QUFDbkYsWUFBSXpJLFVBQVUsR0FBRyxLQUFLdVAsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSSxVQUExQixFQUFqQjtBQUNBLFlBQUlpeEIsU0FBUyxHQUFHLEtBQUsxaEIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ0MsVUFBbEMsQ0FBaEI7QUFDQSxhQUFLdVAsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCSSxVQUExQixDQUFxQ0EsVUFBVSxHQUFDLENBQWhEO0FBQ0EsZUFBT2l4QixTQUFQO0FBQ0gsT0FMRCxNQUtPO0FBQ0gsZUFBTyxVQUFQO0FBQ0g7QUFDRDs7OztBQUdIO0FBdklMO0FBQUE7QUFBQSwrQkF5SWVqQyxZQXpJZixFQXlJNkJDLE9Bekk3QixFQXlJc0NDLE1Bekl0QyxFQXlJOEM7QUFDdEMsVUFBSUMsWUFBWSxHQUFHLEtBQUs1ZixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDSSxPQUFyRCxDQURzQyxDQUV0Qzs7QUFDQSxVQUFJa3ZCLFlBQVksQ0FBQ3JFLE9BQWIsSUFBd0JxRSxZQUFZLENBQUNyRSxPQUFiLENBQXFCcmlCLE1BQWpELEVBQXlEO0FBQ3JELGdHQUFpQnVtQixZQUFqQixFQUErQkMsT0FBL0IsRUFBd0NDLE1BQXhDO0FBQ0g7QUFDSjtBQS9JTDs7QUFBQTtBQUFBLEVBQTZDMUMsZ0VBQTdDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFFTyxJQUFNakMscUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRemtCLE1BRFIsRUFDZ0I7QUFDUixxRkFBVUEsTUFBVjs7QUFDQSxXQUFLNUosUUFBTCxHQUFnQixjQUFoQjtBQUNBLFdBQUtSLElBQUwsR0FBWSxLQUFLNlQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBM0IsRUFBWjtBQUVBeTJCLGtCQUFZLENBQUMsS0FBSzNoQixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JtQixlQUF6QixDQUFaO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFUTDs7QUFBQTtBQUFBLEVBQTJDOHlCLG1FQUEzQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR08sSUFBTWlCLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVUMsV0FBVixFQUF1QkMsY0FBdkIsRUFBdUNDLEtBQXZDLEVBQThDQyxNQUE5QyxFQUFzRDtBQUN0RixNQUFJQyxRQUFRLEdBQUcxb0IsSUFBSSxDQUFDQyxTQUFMLENBQWVxb0IsV0FBZixDQUFmO0FBRUEsMGtCQWtCNkNJLFFBbEI3Qyx3QkFtQk9BLFFBbkJQLHlMQTBCRkMseURBMUJFLGVBMkJGSixjQTNCRTtBQWdFSCxDQW5FTTtBQXFFQSxJQUFNN0csbUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRMWtCLE1BRFIsRUFDZ0I7QUFDUixtRkFBVUEsTUFBVjs7QUFDQSxXQUFLNUosUUFBTCxHQUFnQixxQkFBaEI7QUFDQSxXQUFLUixJQUFMLEdBQVksS0FBSzZULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQTNCLE1BQXVDLEVBQW5EO0FBRUEsVUFBSWczQixXQUFXLEdBQUcsS0FBS25pQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ2syQixXQUFwQyxFQUFsQjtBQUVBLFVBQUk3RyxNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FQUSxDQVFSOztBQUNBLFVBQUk4eEIsWUFBWSxHQUFHLEtBQUtDLGtCQUFMLEVBQW5CO0FBQ0FELGtCQUFZLENBQUMsWUFBRCxDQUFaLEdBQTZCLEtBQUtwaUIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQ0ksT0FBbEMsQ0FBMEM0eEIsVUFBMUMsSUFBd0QsTUFBckY7QUFDQSxXQUFLQyxlQUFMO0FBQ0EsVUFBSVQsY0FBYyxHQUFHLEtBQUszMUIsSUFBMUI7QUFDQSxVQUFJNjFCLE1BQU0sR0FBRyxDQUFDMUcsTUFBTSxDQUFDLFFBQUQsQ0FBTixDQUFpQjdVLEtBQWxCLElBQTJCNlUsTUFBTSxDQUFDLFVBQUQsQ0FBTixDQUFtQjNlLE9BQTNEO0FBQ0FtbEIsb0JBQWMsR0FBR0Ysb0JBQW9CLENBQUNRLFlBQUQsRUFBZU4sY0FBZixFQUErQkssV0FBL0IsRUFBNENILE1BQTVDLENBQXJDO0FBQ0E3dUIsYUFBTyxDQUFDQyxHQUFSLENBQVksS0FBWixFQUFtQjB1QixjQUFuQjtBQUNBLFVBQUlVLFVBQVUsR0FBR0MsMEVBQTBCLENBQUNYLGNBQUQsQ0FBM0MsQ0FoQlEsQ0FnQnFEOztBQUM3RHhHLFlBQU0sQ0FBQyxZQUFELENBQU4sR0FBdUI7QUFDbkIsdUJBQWUsRUFESTtBQUVuQixvQkFBWSwwQkFGTztBQUduQixnQkFBUXdHLGNBSFc7QUFJbkIsc0JBQWNVLFVBSkssQ0FLbkI7O0FBTG1CLE9BQXZCO0FBT0EsV0FBS3IyQixJQUFMLEdBQVkyMUIsY0FBWjs7QUFFQSxtRkFBVXZyQixNQUFWLEVBMUJRLENBNEJSOzs7QUFDQXFKLFFBQUUsQ0FBQzFPLE9BQUgsR0FBYSxLQUFLOE8sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCekQsVUFBMUIsQ0FBcUNzRSxPQUFsRDtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBakNMO0FBQUE7QUFBQSw0QkFtQ1kwckIsTUFuQ1osRUFtQ29CO0FBQ1p6cEIsYUFBTyxDQUFDQyxHQUFSLENBQVksZ0JBQVosRUFEWSxDQUVaOztBQUNBLFdBQUs0TSxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJ6RCxVQUExQixDQUFxQ3NFLE9BQXJDLEdBQStDME8sRUFBRSxDQUFDMU8sT0FBbEQ7QUFDQSxXQUFLOE8sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCekQsVUFBMUIsQ0FBcUN3RSxVQUFyQyxHQUFrRHdPLEVBQUUsQ0FBQ3hPLFVBQXJEO0FBQ0ErQixhQUFPLENBQUNDLEdBQVIsQ0FBWXdwQixNQUFaO0FBQ0EsVUFBSTNyQixPQUFPLEdBQUcyckIsTUFBTSxDQUFDRyxFQUFQLENBQVVqcEIsT0FBVixDQUFrQmlwQixFQUFoQztBQUNBNXBCLGFBQU8sQ0FBQ0MsR0FBUixDQUFZd3BCLE1BQU0sQ0FBQ0csRUFBbkI7QUFDQSxXQUFLL2MsSUFBTCxDQUFVek4sVUFBVixDQUFxQmxCLFFBQXJCLENBQThCeXJCLGVBQTlCLENBQThDN3JCLE9BQTlDO0FBQ0EsV0FBSytPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0MsWUFBbEMsRUFBZ0QsU0FBaEQsSUFBNkQsSUFBN0Q7QUFDQSxVQUFJcU0sT0FBTyxHQUFHaUQsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQmh2QixPQUFPLENBQUN5eEIsT0FBekIsQ0FBZDtBQUNBLFdBQUsxaUIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMkQsT0FBM0IsQ0FBbUNvUSxPQUFPLElBQUksS0FBS3FELElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjJELE9BQTNCLEVBQTlDLEVBWFksQ0FZWjs7QUFDQSxVQUFJRCxLQUFLLEdBQUdzVCxFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCaHZCLE9BQU8sQ0FBQzB4QixLQUF6QixDQUFaO0FBQ0FyMkIsV0FBSyxHQUFHK0wsSUFBSSxDQUFDQyxHQUFMLENBQVMsR0FBVCxFQUFjRCxJQUFJLENBQUNJLEdBQUwsQ0FBUyxHQUFULEVBQWNuTSxLQUFkLENBQWQsQ0FBUjtBQUNBLFVBQUlzMkIsUUFBUSxHQUFHLEtBQUs1aUIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMEQsS0FBM0IsRUFBZjtBQUNBLFdBQUswVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIwRCxLQUEzQixDQUFpQytMLElBQUksQ0FBQ0MsR0FBTCxDQUFTc3FCLFFBQVQsRUFBbUJ0MkIsS0FBbkIsQ0FBakMsRUFoQlksQ0FpQlo7O0FBQ0EsVUFBSTBVLElBQUksR0FBR3BCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJodkIsT0FBTyxDQUFDNHhCLElBQXpCLENBQVgsQ0FsQlksQ0FtQlo7O0FBQ0EsV0FBSzdpQixJQUFMLENBQVV6TixVQUFWLENBQXFCQyxNQUFyQixDQUE0QjlDLGdCQUE1QixDQUE2Q3BELEtBQTdDLEVBQW9EcVEsT0FBcEQsRUFBNkRxRSxJQUE3RCxFQUFtRSxLQUFuRTtBQUNBLFdBQUtoQixJQUFMLENBQVVoVyxLQUFWLENBQWdCdUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUNDLEtBQS9DLEVBckJZLENBc0JaOztBQUVBOzs7O0FBSUEsVUFBSSxDQUFDa1IsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0Jqd0IsVUFBcEIsQ0FBK0JrMkIsU0FBcEMsRUFBK0M7QUFDM0MsWUFBSTtBQUNBLGVBQUs5aUIsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkI0dkIsY0FBN0I7QUFDSCxTQUZELENBRUUsT0FBTzVqQixDQUFQLEVBQVUsQ0FDWDtBQUNKO0FBQ0o7QUFyRUw7QUFBQTtBQUFBLDRCQXVFWThLLEtBdkVaLEVBdUVtQjtBQUNYOVcsYUFBTyxDQUFDQyxHQUFSLENBQVksZ0JBQVosRUFBOEI2VyxLQUE5QjtBQUNBLFVBQUlxUixNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSTJaLEtBQUssQ0FBQytZLE9BQU4sS0FBa0IsY0FBdEIsRUFBc0M7QUFDbEMxSCxjQUFNLENBQUMsWUFBRCxDQUFOLENBQXFCLFNBQXJCLElBQWtDLElBQWxDO0FBQ0EsYUFBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0J1RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ0MsS0FBL0M7QUFDSCxPQUhELE1BR087QUFDSCxhQUFLc1IsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDK29CLE1BQS9DLEVBREcsQ0FFSDs7QUFDQSxhQUFLeFgsSUFBTCxDQUFVek4sVUFBVixDQUFxQmxCLFFBQXJCLENBQThCNHhCLG9CQUE5QixDQUFtRGhaLEtBQW5ELEVBQTBELEtBQUt0ZCxRQUEvRCxFQUhHLENBSUg7QUFDQTtBQUNBO0FBQ0gsT0FiVSxDQWNYOztBQUNIO0FBdEZMOztBQUFBO0FBQUEsRUFBeUNnMEIsbUVBQXpDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUVPLFNBQVM4QiwwQkFBVCxDQUFvQ1gsY0FBcEMsRUFBb0Q7QUFDdkQsTUFBTWxrQixLQUFLLEdBQUdra0IsY0FBYyxDQUFDem1CLE9BQWYsQ0FBdUI2bUIsaUJBQXZCLENBQWQ7QUFDQSxNQUFNZ0IsTUFBTSxHQUFHcEIsY0FBYyxDQUFDcm5CLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0JtRCxLQUF4QixDQUFmO0FBQ0EsTUFBTXVsQixLQUFLLEdBQUdELE1BQU0sQ0FBQ0MsS0FBUCxDQUFhQyxjQUFiLENBQWQ7QUFDQSxTQUFPRCxLQUFLLEdBQUksSUFBRUEsS0FBSyxDQUFDanFCLE1BQVosR0FBc0IsQ0FBbEM7QUFDSDtBQUVNLElBQU1ncEIsaUJBQWlCLEdBQUcsc0NBQTFCO0FBQ0EsSUFBTWtCLGNBQWMsR0FBRyxLQUF2QjtBQUNQOzs7O0FBR08sSUFBTXhCLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVVEsWUFBVixFQUF3Qk4sY0FBeEIsRUFBd0NDLEtBQXhDLEVBQStDQyxNQUEvQyxFQUF1RDtBQUN2RixNQUFJQyxRQUFRLEdBQUcxb0IsSUFBSSxDQUFDQyxTQUFMLENBQWU0b0IsWUFBZixDQUFmO0FBQ0EsTUFBSWlCLFNBQVMsR0FBR3RCLEtBQUssR0FBRyxNQUFILEdBQVcsT0FBaEMsQ0FGdUYsQ0FJdkY7O0FBRUEsMjBCQXlCa0NzQixTQXpCbEMsMExBNkI4QnBCLFFBN0I5Qiw4TUFxQ0ZDLGlCQXJDRSxlQXNDRkosY0F0Q0U7QUEyRUgsQ0FqRk07QUFtRkEsSUFBTS9HLGtCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUXhrQixNQURSLEVBQ2dCO0FBQ1Isa0ZBQVVBLE1BQVY7O0FBQ0EsV0FBSzVKLFFBQUwsR0FBZ0Isb0JBQWhCO0FBQ0EsV0FBS1IsSUFBTCxHQUFZLEtBQUs2VCxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUEzQixFQUFaO0FBRUEsVUFBSWszQixXQUFXLEdBQUcsS0FBS25pQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ2syQixXQUFwQyxFQUFsQixDQUxRLENBTVI7O0FBQ0EsV0FBS25pQixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJJLFVBQTFCLENBQXFDLENBQXJDO0FBRUEsVUFBSTZxQixNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FUUSxDQVVSOztBQUNBLFVBQUk4eEIsWUFBWSxHQUFHLEtBQUtDLGtCQUFMLEVBQW5CO0FBQ0EsV0FBS0UsZUFBTDtBQUNBLFVBQUlULGNBQWMsR0FBRyxLQUFLMzFCLElBQTFCO0FBQ0EsVUFBSTYxQixNQUFNLEdBQUcsQ0FBQzFHLE1BQU0sQ0FBQyxRQUFELENBQU4sQ0FBaUI3VSxLQUFsQixJQUEyQjZVLE1BQU0sQ0FBQyxVQUFELENBQU4sQ0FBbUIzZSxPQUEzRDtBQUNBbWxCLG9CQUFjLEdBQUdGLG9CQUFvQixDQUFDUSxZQUFELEVBQWVOLGNBQWYsRUFBK0JLLFdBQS9CLEVBQTRDSCxNQUE1QyxDQUFyQztBQUNBLFVBQUlRLFVBQVUsR0FBR0MsMEJBQTBCLENBQUNYLGNBQUQsQ0FBM0MsQ0FoQlEsQ0FnQnFEO0FBQzdEOztBQUNBeEcsWUFBTSxDQUFDLFlBQUQsQ0FBTixHQUF1QjtBQUNuQix1QkFBZSxFQURJO0FBRW5CLG9CQUFZLHlCQUZPO0FBR25CLGdCQUFRd0csY0FIVztBQUluQixzQkFBY1UsVUFKSyxDQUtuQjs7QUFMbUIsT0FBdkI7QUFRQSxXQUFLcjJCLElBQUwsR0FBWTIxQixjQUFaO0FBRUFsaUIsUUFBRSxDQUFDbWYsYUFBSCxHQUFtQixLQUFuQjtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBaENMO0FBQUE7QUFBQSw0QkFrQ1luQyxNQWxDWixFQWtDb0I7QUFDWjtBQUNBO0FBQ0E7QUFDQSxXQUFLNWMsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCekQsVUFBMUIsQ0FBcUNzRSxPQUFyQyxHQUErQzBPLEVBQUUsQ0FBQzFPLE9BQWxEO0FBQ0EsV0FBSzhPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQnpELFVBQTFCLENBQXFDd0UsVUFBckMsR0FBa0R3TyxFQUFFLENBQUN4TyxVQUFyRDtBQUNBd08sUUFBRSxDQUFDMU8sT0FBSCxHQUFhLEVBQWI7QUFDQSxVQUFJRCxPQUFPLEdBQUcyckIsTUFBTSxDQUFDRyxFQUFQLENBQVVocEIsTUFBVixDQUFpQmdwQixFQUEvQjtBQUNBLFdBQUsvYyxJQUFMLENBQVV6TixVQUFWLENBQXFCbEIsUUFBckIsQ0FBOEJ5ckIsZUFBOUIsQ0FBOEM3ckIsT0FBOUM7QUFDQSxXQUFLK08sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQyxZQUFsQyxFQUFnRCxTQUFoRCxJQUE2RCxJQUE3RDtBQUNBLFVBQUlxTSxPQUFPLEdBQUdpRCxFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCaHZCLE9BQU8sQ0FBQ3l4QixPQUF6QixDQUFkO0FBQ0EsV0FBSzFpQixJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIyRCxPQUEzQixDQUFtQ29RLE9BQU8sSUFBSSxLQUFLcUQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMkQsT0FBM0IsRUFBOUMsRUFYWSxDQVlaOztBQUNBLFVBQUlELEtBQUssR0FBR3NULEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJodkIsT0FBTyxDQUFDMHhCLEtBQXpCLENBQVo7QUFDQXIyQixXQUFLLEdBQUcrTCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlELElBQUksQ0FBQ0ksR0FBTCxDQUFTLENBQVQsRUFBWW5NLEtBQVosQ0FBWixDQUFSO0FBQ0EsVUFBSXMyQixRQUFRLEdBQUcsS0FBSzVpQixJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIwRCxLQUEzQixFQUFmO0FBQ0FBLFdBQUssR0FBRytMLElBQUksQ0FBQ0MsR0FBTCxDQUFTc3FCLFFBQVQsRUFBbUJ0MkIsS0FBbkIsQ0FBUjtBQUNBLFdBQUswVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIwRCxLQUEzQixDQUFpQ0EsS0FBakMsRUFqQlksQ0FrQlo7O0FBQ0EsVUFBSTBVLElBQUksR0FBR3BCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJodkIsT0FBTyxDQUFDNHhCLElBQXpCLENBQVgsQ0FuQlksQ0FvQlo7O0FBQ0EsV0FBSzdpQixJQUFMLENBQVV6TixVQUFWLENBQXFCQyxNQUFyQixDQUE0QjlDLGdCQUE1QixDQUE2Q3BELEtBQTdDLEVBQW9EcVEsT0FBcEQsRUFBNkRxRSxJQUE3RCxFQUFtRSxLQUFuRTtBQUNBLFdBQUtoQixJQUFMLENBQVVoVyxLQUFWLENBQWdCdUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUNDLEtBQS9DLEVBdEJZLENBdUJaOztBQUVBOzs7O0FBSUEsVUFBSSxDQUFDa1IsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0Jqd0IsVUFBcEIsQ0FBK0JrMkIsU0FBcEMsRUFBK0M7QUFDM0MsWUFBSTtBQUNBLGVBQUs5aUIsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkI0dkIsY0FBN0I7QUFDSCxTQUZELENBRUUsT0FBTzVqQixDQUFQLEVBQVUsQ0FDWDtBQUNKO0FBQ0o7QUFyRUw7QUFBQTtBQUFBLDRCQXVFWThLLEtBdkVaLEVBdUVtQjtBQUNYOVcsYUFBTyxDQUFDOFcsS0FBUixDQUFjLGVBQWQsRUFBK0JBLEtBQS9CO0FBQ0EsVUFBSXFSLE1BQU0sR0FBRyxLQUFLdGIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUF2Qzs7QUFDQSxVQUFJMlosS0FBSyxDQUFDK1ksT0FBTixLQUFrQixjQUF0QixFQUFzQztBQUNsQzFILGNBQU0sQ0FBQyxZQUFELENBQU4sQ0FBcUIsU0FBckIsSUFBa0MsSUFBbEM7QUFDQSxhQUFLdGIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDQyxLQUEvQztBQUNILE9BSEQsTUFHTztBQUNILGFBQUtzUixJQUFMLENBQVVoVyxLQUFWLENBQWdCdUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUMrb0IsTUFBL0MsRUFERyxDQUVIOztBQUNBLGFBQUt4WCxJQUFMLENBQVV6TixVQUFWLENBQXFCbEIsUUFBckIsQ0FBOEI0eEIsb0JBQTlCLENBQW1EaFosS0FBbkQsRUFBMEQsS0FBS3RkLFFBQS9ELEVBSEcsQ0FJSDtBQUNBO0FBQ0E7QUFDSCxPQWJVLENBY1g7O0FBQ0g7QUF0Rkw7O0FBQUE7QUFBQSxFQUF3Q2cwQixtRUFBeEM7QUEwRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdMQTtBQUVPLElBQU0yQyxxQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1Evc0IsTUFEUixFQUNnQjtBQUNSLHFGQUFVQSxNQUFWOztBQUNBLFdBQUs1SixRQUFMLEdBQWdCLFdBQWhCO0FBQ0EsV0FBS1IsSUFBTCxHQUFZLEtBQUs2VCxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUEzQixFQUFaO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFQTDs7QUFBQTtBQUFBLEVBQTJDOHZCLDBEQUEzQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBRU8sSUFBTUgsZ0JBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRcmtCLE1BRFIsRUFDZ0I7QUFDUixXQUFLeUosSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNDLE9BQW5DLENBQTJDLFlBQTNDO0FBQ0EsV0FBSzNFLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxXQUFLUixJQUFMLEdBQVksS0FBSzZULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0I4SyxFQUFoQixDQUFtQjZELEtBQW5CLENBQXlCcUIsY0FBekIsRUFBWjs7QUFDQSxVQUFJLEtBQUtnRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ3MzQixpQkFBcEMsRUFBSixFQUE2RDtBQUN6RCxhQUFLcDNCLElBQUwsR0FBWSxFQUFaO0FBQ0gsT0FOTyxDQU9SOzs7QUFDQSxXQUFLNlQsSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJsRCxRQUE1QixDQUFxQyxXQUFyQyxFQUFrRCxLQUFLMFEsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCdUQsSUFBM0IsRUFBbEQsRUFBcUYsSUFBckY7QUFDQSxXQUFLNlQsSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ0RCxRQUE1QixDQUFxQyxTQUFyQyxFQUFnRCxFQUFoRCxFQUFvRCxFQUFwRCxFQUF3RCxFQUF4RCxFQUE0RCxXQUE1RCxFQVRRLENBVVI7O0FBQ0EsZ0ZBQVVxSCxNQUFWOztBQUVBQSxZQUFNLENBQUNsQixLQUFQO0FBQ0EsV0FBS3FuQixXQUFMO0FBRUEsV0FBSzFjLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0MsVUFBbEMsSUFBZ0Q7QUFDNUMsbUJBQVdrekIsT0FBTyxDQUFDLEtBQUtyM0IsSUFBTCxDQUFVZ1ksSUFBVixFQUFELENBRDBCO0FBRTVDLGdCQUFRLEtBQUtoWTtBQUYrQixPQUFoRDtBQUtBeVQsUUFBRSxDQUFDbWYsYUFBSCxHQUFtQixLQUFuQjtBQUVBLFdBQUswRSxVQUFMO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUEzQkw7QUFBQTtBQUFBLDRCQTZCWTdHLE1BN0JaLEVBNkJvQjtBQUFBOztBQUNaenBCLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLGFBQVo7QUFDQSxVQUFJOUIsT0FBTyxHQUFHO0FBQ1Ysa0JBQVUsS0FBSzBPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NnZCxJQUFsQyxDQUF1QyxJQUF2QyxDQURBO0FBRVYsbUJBQVcsS0FBS3hOLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkUsTUFBMUIsR0FBbUN1SyxHQUFuQyxDQUF1QyxVQUFBL0MsSUFBSTtBQUFBLGlCQUFJQSxJQUFJLENBQUN1SyxPQUFUO0FBQUEsU0FBM0MsRUFBNkRrTCxJQUE3RCxDQUFrRSxJQUFsRTtBQUZELE9BQWQ7QUFJQSxXQUFLeE4sSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ0RCxRQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxFQUFwRCxFQUF3RCxFQUF4RCxFQUE0RHFLLElBQUksQ0FBQ0MsU0FBTCxDQUFlbEksT0FBZixDQUE1RCxFQUFxRixXQUFyRjtBQUNBLFdBQUswTyxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JvQixlQUF4QixDQUF3QyxLQUF4QztBQUNBLFdBQUtrUyxJQUFMLENBQVV6TixVQUFWLENBQXFCWSxPQUFyQixDQUE2QnV3QixhQUE3QjtBQUNBLFdBQUsxakIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDQyxLQUEvQztBQUNBLFdBQUtzUixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUSxPQUFsQyxDQUEwQzBPLEVBQUUsQ0FBQzFPLE9BQTdDO0FBQ0EwTyxRQUFFLENBQUMxTyxPQUFILEdBQWEsRUFBYjtBQUNBLFVBQUlvcUIsTUFBTSxHQUFHLEtBQUt0YixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsVUFBSTNELFFBQVEsR0FBRyxLQUFLQSxRQUFwQjtBQUNBLFdBQUtxVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDTyxPQUFsQyxHQUE0QzJyQixNQUE1Qzs7QUFDQSxVQUFJLENBQUMsS0FBSzVjLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DMEwsWUFBcEMsRUFBTCxFQUF5RDtBQUNyRCxhQUFLcUksSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkJ3d0IsU0FBN0I7QUFDSDs7QUFDRCxhQUFPLElBQUl6ZSxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVNFAsTUFBVixFQUFxQjtBQUNwQyxhQUFJLENBQUMvYyxJQUFMLENBQVU0a0IsTUFBTSxDQUFDRyxFQUFqQixFQUFxQkgsTUFBTSxDQUFDRyxFQUE1QixFQUErQixDQUFDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDcHdCLFFBQVEsR0FBRyxLQUFqRDs7QUFDQSxhQUFJLENBQUNpRSxRQUFMOztBQUNBMHFCLGNBQU0sQ0FBQyxTQUFELENBQU4sR0FBb0I7QUFDaEIscUJBQVcsSUFESztBQUVoQixtQkFBUyxLQUFJLENBQUMva0IsTUFBTCxDQUFZa00sZUFBWixDQUE0QjNLLEtBRnJCO0FBR2hCLG1CQUFTLEtBQUksQ0FBQ3ZCLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEIzSyxLQUE1QixDQUFrQ2dELEdBQWxDLENBQXNDLFVBQUFzbEIsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLENBQUNyb0IsSUFBTjtBQUFBLFdBQXZDLENBSE87QUFJaEIsdUJBQWEsS0FBSSxDQUFDeEIsTUFBTCxDQUFZa00sZUFBWixDQUE0QjNLLEtBQTVCLENBQWtDb1ksTUFBbEMsQ0FBeUMsVUFBQWtRLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFDLENBQUNDLFdBQVA7QUFBQSxXQUExQyxFQUE4RHZsQixHQUE5RCxDQUFrRSxVQUFBc2xCLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDcm9CLElBQU47QUFBQSxXQUFuRSxDQUpHO0FBS2hCLHFCQUFXNmtCLE1BTEs7QUFNaEIsb0JBQVUsS0FBSSxDQUFDNWMsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCRSxNQU5wQjtBQU9oQixtQkFBUyxLQUFJLENBQUN5UCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJHLEtBUG5CO0FBUWhCLG1CQUFTLEtBQUksQ0FBQ3dQLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NTLEtBUjNCO0FBU2hCLHFCQUFXO0FBVEssU0FBcEI7QUFXQWdVLGVBQU87QUFDVixPQWZNLENBQVA7QUFnQkg7QUEvREw7QUFBQTtBQUFBLDRCQWlFWThFLEtBakVaLEVBaUVtQjtBQUFBOztBQUNYOVcsYUFBTyxDQUFDOFcsS0FBUixDQUFjLGFBQWQsRUFBNkJBLEtBQTdCO0FBQ0EsV0FBS2pLLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0J1RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQytvQixNQUEvQztBQUNBLFVBQUk4RCxNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSWdyQixNQUFNLENBQUNzSSxNQUFQLENBQWNqbkIsT0FBZCxJQUF5QjJlLE1BQU0sQ0FBQ3VJLFFBQVAsQ0FBZ0JsbkIsT0FBN0MsRUFBc0Q7QUFDbEQsYUFBS3FELElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsZUFBckMsRUFBc0QsRUFBdEQsRUFBMEQsRUFBMUQsRUFBOEQrYSxLQUFLLENBQUM1YixRQUFOLEVBQTlELEVBQWdGLFdBQWhGO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBSzJSLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsYUFBckMsRUFBb0Qsb0JBQXBELEVBQTBFLEVBQTFFLEVBQThFK2EsS0FBSyxDQUFDNWIsUUFBTixFQUE5RSxFQUFnRyxXQUFoRztBQUNIOztBQUNELGFBQU8sSUFBSTZXLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVU0UCxNQUFWLEVBQXFCO0FBQ3BDdUcsY0FBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjtBQUNoQixxQkFBVyxLQURLO0FBRWhCLG1CQUFTclIsS0FGTztBQUdoQixtQkFBUyxNQUFJLENBQUMxVCxNQUFMLENBQVlrTSxlQUFaLENBQTRCM0ssS0FBNUIsQ0FBa0NnRCxHQUFsQyxDQUFzQyxVQUFBc2xCLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDcm9CLElBQU47QUFBQSxXQUF2QyxDQUhPO0FBSWhCLHVCQUFhLE1BQUksQ0FBQ3hCLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEIzSyxLQUE1QixDQUFrQ29ZLE1BQWxDLENBQXlDLFVBQUFrUSxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxXQUFQO0FBQUEsV0FBMUMsRUFBOER2bEIsR0FBOUQsQ0FBa0UsVUFBQXNsQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ3JvQixJQUFOO0FBQUEsV0FBbkUsQ0FKRztBQUtoQixtQkFBUyxNQUFJLENBQUNpSSxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJHLEtBTG5CO0FBTWhCLG1CQUFTLE1BQUksQ0FBQ3dQLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NTLEtBTjNCO0FBT2hCLHFCQUFXO0FBUEssU0FBcEI7QUFTQWdVLGVBQU87QUFDVixPQVhNLENBQVA7QUFZSDtBQXRGTDs7QUFBQTtBQUFBLEVBQXNDbWIsNkRBQXRDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFFTyxJQUFNd0QsbUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRdnRCLE1BRFIsRUFDZ0I7QUFDUixtRkFBVUEsTUFBVixFQURRLENBRVI7OztBQUNBLFdBQUs1SixRQUFMLEdBQWdCLFdBQWhCO0FBQ0EsV0FBS1IsSUFBTCxHQUFZLHlCQUFaO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFSTDs7QUFBQTtBQUFBLEVBQXlDbTBCLDZEQUF6QyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBRU8sSUFBTUEsb0JBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRL3BCLE1BRFIsRUFDZ0I7QUFBQTs7QUFDUixvRkFBVUEsTUFBVixFQURRLENBRVI7OztBQUNBLFVBQUl0SyxRQUFRLEdBQUcsS0FBSytULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JpQyxRQUEvQjs7QUFDQTJULFFBQUUsQ0FBQ2tlLGlCQUFILEdBQXVCO0FBQUEsZUFDbkIsS0FBSSxDQUFDOWQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0N5eEIsY0FBcEMsS0FBdURLLFFBQXZELEdBQWtFLElBRC9DO0FBQUEsT0FBdkI7O0FBRUFuZSxRQUFFLENBQUM2ZCxTQUFILEdBQWU3ZCxFQUFFLENBQUNrZSxpQkFBSCxFQUFmLENBTlEsQ0FPUjs7QUFDQWxlLFFBQUUsQ0FBQ21nQixvQkFBSCxHQUEwQixLQUFLL25CLElBQUwsQ0FBVXlELElBQVYsQ0FBZSxJQUFmLENBQTFCLENBUlEsQ0FVUjs7QUFDQSxXQUFLdUUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjBDLE9BQWhCLENBQXdCRyxXQUF4QixDQUFvQyxLQUFwQyxFQVhRLENBYVI7QUFDQTs7QUFFQStTLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQmxILEtBQWhCLENBQXNCLDZCQUF0QixJQUF1RHFrQiw0REFBdkQ7QUFFQSxhQUFPLElBQVA7QUFDSDtBQXBCTDtBQUFBO0FBQUEsNkJBc0JhcndCLFFBdEJiLEVBc0J1QjtBQUNmLFVBQUk0MEIsS0FBSyxHQUFHLEtBQUt2aEIsSUFBTCxDQUFVek4sVUFBVixDQUFxQmUsVUFBckIsQ0FBZ0NrdUIsYUFBaEMsQ0FBOEM3MEIsUUFBOUMsRUFBd0QsSUFBeEQsQ0FBWixDQURlLENBRWY7O0FBQ0EsVUFBSTQwQixLQUFLLEtBQUt6NEIsU0FBZCxFQUF5QjtBQUNyQixZQUFJOFcsRUFBRSxDQUFDQyxZQUFILElBQW1CRCxFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUJsVCxRQUF6QixNQUF1QzdELFNBQTlELEVBQXlFO0FBQ3JFLGlCQUFPOFcsRUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCbFQsUUFBekIsQ0FBUDtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFNLElBQUlpVCxFQUFFLENBQUNzZixPQUFILENBQVd1QyxPQUFmLENBQXVCLHFCQUFxQjkwQixRQUE1QyxDQUFOO0FBQ0g7QUFDSixPQU5ELE1BTU87QUFDSCxlQUFPNDBCLEtBQUssQ0FBQ3RtQixRQUFOLEVBQVA7QUFDSDtBQUNKO0FBbENMO0FBQUE7QUFBQSwrQkFvQ2V0TyxRQXBDZixFQW9DeUI7QUFDakIsVUFBSSxLQUFLbzNCLFdBQUwsQ0FBaUJwM0IsUUFBakIsQ0FBSixFQUFnQztBQUM1QixjQUFNLDJCQUEyQkEsUUFBM0IsR0FBc0MsR0FBNUM7QUFDSCxPQUZELE1BRU8sSUFBSUEsUUFBUSxLQUFLLGFBQWpCLEVBQWdDO0FBQ25DLGVBQU8sS0FBS3FULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLEVBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSXlULEVBQUUsQ0FBQ0MsWUFBSCxLQUFvQi9XLFNBQXhCLEVBQW1DO0FBQ3RDLGNBQU0sSUFBSThXLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VDLE9BQWYsQ0FBdUIsa0NBQXZCLENBQU47QUFDSCxPQUZNLE1BRUEsSUFBSTdoQixFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUJsVCxRQUF6QixNQUF1QzdELFNBQTNDLEVBQXNEO0FBQ3pELGVBQU84VyxFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUJsVCxRQUF6QixDQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsWUFBSTQwQixLQUFLLEdBQUcsS0FBS3ZoQixJQUFMLENBQVV6TixVQUFWLENBQXFCZSxVQUFyQixDQUFnQ2t1QixhQUFoQyxDQUE4QzcwQixRQUE5QyxFQUF3RCxJQUF4RCxDQUFaOztBQUNBLFlBQUk0MEIsS0FBSyxLQUFLejRCLFNBQWQsRUFBeUI7QUFDckIsZ0JBQU0sSUFBSThXLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VDLE9BQWYsQ0FBdUIsc0JBQW9COTBCLFFBQXBCLEdBQStCLEdBQXRELENBQU47QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBTzQwQixLQUFLLENBQUN0bUIsUUFBTixFQUFQO0FBQ0g7QUFDSjtBQUNKO0FBckRMO0FBQUE7QUFBQSwwQkF1RFV1SixhQXZEVixFQXVEeUI7QUFDakIsYUFBTyxLQUFLeEUsSUFBTCxDQUFVek4sVUFBVixDQUFxQlksT0FBckIsQ0FBNkIzQyxLQUE3QixDQUFtQ2dVLGFBQW5DLENBQVA7QUFDSDtBQXpETDtBQUFBO0FBQUEsZ0NBMkRnQjdYLFFBM0RoQixFQTJEMEI7QUFDbEIsYUFBT0EsUUFBUSxDQUFDNk4sVUFBVCxDQUFvQixrQkFBcEIsS0FDSDdOLFFBQVEsQ0FBQzZOLFVBQVQsQ0FBb0IsZ0JBQXBCLENBREcsSUFFSDdOLFFBQVEsQ0FBQzZOLFVBQVQsQ0FBb0IsZ0JBQXBCLENBRko7QUFHSDtBQUVEOzs7Ozs7Ozs7Ozs7O0FBakVKO0FBQUE7QUFBQSx5QkE2RVN0SixPQTdFVCxFQTZFa0I4eUIsTUE3RWxCLEVBNkUwQkMsVUE3RTFCLEVBNkVzQ0MsWUE3RXRDLEVBNkVvRHYzQixRQTdFcEQsRUE2RThEMHpCLFdBN0U5RCxFQTZFMkU7QUFDbkUsVUFBSTF6QixRQUFRLEtBQUssV0FBakIsRUFBOEI7QUFDMUIsWUFBSWdFLFdBQVcsR0FBRyxLQUFLNEYsTUFBTCxDQUFZa00sZUFBWixDQUE0QnpLLElBQTlDO0FBQ0E5RyxlQUFPLEdBQUcsS0FBSzhPLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJ1RixLQUFyQixDQUEyQnFzQixZQUEzQixDQUF3Q2p6QixPQUF4QyxDQUFWLENBRjBCLENBRzFCO0FBQ0E7QUFDQTs7QUFDQSxhQUFLcUYsTUFBTCxDQUFZa00sZUFBWixDQUE0QjNLLEtBQTVCLENBQWtDeU4sSUFBbEMsQ0FBdUM7QUFDbkMsa0JBQVE1VSxXQUQyQjtBQUVuQyxzQkFBWWhFLFFBRnVCO0FBR25DO0FBQ0Esa0JBQVFzM0IsVUFKMkI7QUFLbkMsb0JBQVVDLFlBTHlCO0FBTW5DLHdCQUFjaHpCLE9BQU8sQ0FBQ2t6QixVQU5hO0FBT25DLHFCQUFXbHpCLE9BQU8sQ0FBQ216QixPQVBnQjtBQVFuQyx5QkFBZWhFO0FBUm9CLFNBQXZDO0FBVUEsYUFBSzlwQixNQUFMLENBQVlrTSxlQUFaLENBQTRCekssSUFBNUIsR0FBbUNySCxXQUFXLEdBQUcsQ0FBakQ7QUFDQSxhQUFLNEYsTUFBTCxDQUFZa00sZUFBWixDQUE0QjFLLElBQTVCLEdBQW1Da3NCLFVBQW5DO0FBQ0g7QUFDSjtBQWpHTDtBQUFBOztBQXFHSTs7OztBQXJHSiwrQkF5R2U7QUFDUCxVQUFJNXpCLFNBQVMsR0FBRyxLQUFLMlAsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhDO0FBQ0FBLGVBQVMsQ0FBQ0ssT0FBVixDQUFrQkssZ0JBQWxCLENBQW1DLEtBQUt3RixNQUFMLENBQVlrTSxlQUFaLENBQTRCM0ssS0FBL0Q7QUFDQXpILGVBQVMsQ0FBQ0ssT0FBVixDQUFrQkMsV0FBbEIsQ0FBOEIsS0FBSzRGLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEJ6SyxJQUExRDtBQUNBM0gsZUFBUyxDQUFDSyxPQUFWLENBQWtCRSxRQUFsQixDQUEyQixLQUFLMkYsTUFBTCxDQUFZa00sZUFBWixDQUE0QnpLLElBQXZEO0FBQ0EzSCxlQUFTLENBQUNLLE9BQVYsQ0FBa0JHLFdBQWxCLENBQThCLEtBQUswRixNQUFMLENBQVlrTSxlQUFaLENBQTRCMUssSUFBMUQ7QUFDQTFILGVBQVMsQ0FBQ0ssT0FBVixDQUFrQkksUUFBbEIsQ0FBMkIsS0FBS3lGLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEIxSyxJQUF2RDtBQUNBMUgsZUFBUyxDQUFDSyxPQUFWLENBQWtCTSxnQkFBbEIsQ0FBbUMsS0FBS3VGLE1BQUwsQ0FBWWtNLGVBQVosQ0FBNEJ6SyxJQUEvRDtBQUNIO0FBakhMO0FBQUE7QUFBQSw2QkFtSGFzc0IsR0FuSGIsRUFtSGtCO0FBQ1YsVUFBSUMsWUFBWSxHQUFHLElBQUlDLEdBQUosRUFBbkI7O0FBQ0EsVUFBSUMsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBQ0MsSUFBRCxFQUFVO0FBQ3RCLFlBQUlBLElBQUksQ0FBQ0MsTUFBTCxLQUFnQjc3QixTQUFwQixFQUErQjtBQUMzQnk3QixzQkFBWSxDQUFDcHJCLEdBQWIsQ0FBaUJ1ckIsSUFBSSxDQUFDQyxNQUF0QjtBQUNIOztBQUNELFlBQUlELElBQUksQ0FBQ3paLElBQVQsRUFBZTtBQUNYeVosY0FBSSxDQUFDelosSUFBTCxDQUFVM0IsT0FBVixDQUFrQixVQUFDc2IsU0FBRDtBQUFBLG1CQUFlSCxTQUFTLENBQUNHLFNBQUQsQ0FBeEI7QUFBQSxXQUFsQjtBQUNIOztBQUNELFlBQUlGLElBQUksQ0FBQ0csTUFBVCxFQUFpQjtBQUNiSCxjQUFJLENBQUNHLE1BQUwsQ0FBWXZiLE9BQVosQ0FBb0IsVUFBQ3NiLFNBQUQ7QUFBQSxtQkFBZUgsU0FBUyxDQUFDRyxTQUFELENBQXhCO0FBQUEsV0FBcEI7QUFDSDs7QUFDRCxZQUFJRixJQUFJLENBQUNJLFNBQVQsRUFBb0I7QUFDaEJKLGNBQUksQ0FBQ0ksU0FBTCxDQUFleGIsT0FBZixDQUF1QixVQUFDc2IsU0FBRDtBQUFBLG1CQUFlSCxTQUFTLENBQUNHLFNBQUQsQ0FBeEI7QUFBQSxXQUF2QjtBQUNIO0FBQ0osT0FiRDs7QUFjQUgsZUFBUyxDQUFDSCxHQUFELENBQVQ7QUFDQSxhQUFPUyxLQUFLLENBQUNDLElBQU4sQ0FBV1QsWUFBWCxDQUFQO0FBQ0g7QUFFRDs7OztBQXZJSjtBQUFBO0FBQUEsa0NBMElrQjtBQUNWLFVBQUlqSixNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FEVSxDQUVWOztBQUNBLFVBQUl5bEIsS0FBSyxHQUFHLEVBQVosQ0FIVSxDQUlWOztBQUNBLFVBQUl1TyxHQUFKOztBQUNBLFVBQUk7QUFDQSxZQUFJamxCLEtBQUssR0FBR08sRUFBRSxDQUFDUCxLQUFILENBQVMsS0FBSzFTLFFBQWQsRUFBd0IsS0FBS1IsSUFBN0IsQ0FBWjtBQUNBbTRCLFdBQUcsR0FBRzFrQixFQUFFLENBQUNxbEIsWUFBSCxDQUFnQjVsQixLQUFLLENBQUM2bEIsR0FBdEIsRUFBMkIsS0FBS3Y0QixRQUFoQyxFQUEwQzBTLEtBQUssQ0FBQzhsQixLQUFoRCxDQUFOO0FBQ0FwUCxhQUFLLEdBQUcsS0FBS3FQLFFBQUwsQ0FBY2QsR0FBZCxDQUFSO0FBQ0gsT0FKRCxDQUlFLE9BQU9yYSxLQUFQLEVBQWM7QUFDWjtBQUNBcVIsY0FBTSxDQUFDLFFBQUQsQ0FBTixHQUFtQjtBQUNmLHFCQUFXLEtBREk7QUFFZixtQkFBU3JSLEtBRk07QUFHZixtQkFBUyxJQUhNO0FBSWYsbUJBQVM4TDtBQUpNLFNBQW5CO0FBTUE1aUIsZUFBTyxDQUFDOFcsS0FBUixDQUFjQSxLQUFkO0FBQ0E5VyxlQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFLekcsUUFBakIsRUFBMkIsS0FBS1IsSUFBaEM7QUFDQSxlQUFPLEtBQVA7QUFDSCxPQXJCUyxDQXNCVjs7O0FBQ0FtdkIsWUFBTSxDQUFDLFFBQUQsQ0FBTixHQUFtQjtBQUNmLG1CQUFXLElBREk7QUFFZixlQUFPZ0osR0FGUTtBQUdmLGlCQUFTQSxHQUFHLENBQUNyWixJQUFKLENBQVMvUixNQUFULEtBQW9CLENBSGQ7QUFJZixpQkFBUzZjO0FBSk0sT0FBbkI7QUFNQSxhQUFPLElBQVA7QUFDSDtBQXhLTDtBQUFBO0FBQUEsaUNBMEtpQjtBQUNULFVBQUl1RixNQUFNLEdBQUcsS0FBS3RiLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSWdyQixNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCM2UsT0FBdEIsRUFBK0I7QUFDM0IsYUFBS3FELElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJsQixRQUFyQixDQUE4QmdWLEtBQTlCO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBS3JHLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJsQixRQUFyQixDQUE4QmcwQixlQUE5QixDQUE4Qy9KLE1BQU0sQ0FBQzVxQixPQUFQLENBQWV1WixLQUE3RDtBQUNIO0FBQ0o7QUFqTEw7QUFBQTtBQUFBLHlDQW1MeUI7QUFBQTs7QUFDakIsVUFBSXFSLE1BQU0sR0FBRyxLQUFLdGIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCQyxPQUF2QztBQUNBLFVBQUllLFFBQVEsR0FBRyxLQUFLMk8sSUFBTCxDQUFVek4sVUFBVixDQUFxQmxCLFFBQXBDOztBQUNBLFVBQUksQ0FBQ2lxQixNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCM2UsT0FBdkIsRUFBZ0M7QUFDNUIsWUFBSTJvQixXQUFXLEdBQUcsS0FBS3RsQixJQUFMLENBQVVoVyxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJxSixTQUE5QixDQUF3Q3NPLElBQXhDLENBQTZDLHdCQUE3QyxDQUFsQjtBQUNBLFlBQUkvTyxPQUFPLEdBQUdELFFBQVEsQ0FBQ2cwQixlQUFULENBQXlCL0osTUFBTSxDQUFDNXFCLE9BQVAsQ0FBZXVaLEtBQXhDLEVBQStDLElBQS9DLENBQWQ7QUFDQXFiLG1CQUFXLENBQUMxZCxJQUFaLENBQWlCLE9BQWpCLEVBQTBCLDZCQUExQjtBQUNBMGQsbUJBQVcsQ0FBQ2poQixPQUFaLENBQW9CO0FBQUMscUJBQVcsT0FBWjtBQUFxQix1QkFBYSxLQUFLckUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCb0o7QUFBaEUsU0FBcEI7QUFDQXd6QixtQkFBVyxDQUFDN2YsS0FBWixDQUFrQjtBQUFBLGlCQUFNLE1BQUksQ0FBQ3pGLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFyQixDQUE0QnNYLHdCQUE1QixDQUFxRDFiLE9BQXJELENBQU47QUFBQSxTQUFsQjtBQUNBZzBCLG1CQUFXLENBQUN2a0IsSUFBWjtBQUNIO0FBQ0o7QUE5TEw7O0FBQUE7QUFBQSxFQUEwQ2tjLDZEQUExQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGTyxJQUFJc0ksYUFBYSwyakRBQWpCO0FBNENBLElBQU1qbEIsZUFBYjtBQUVJOzs7Ozs7Ozs7QUFTQSwyQkFBWU4sSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLFNBQUsvRixJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLK0YsR0FBTCxHQUFXQSxHQUFYO0FBRUEsU0FBS3lmLGFBQUwsR0FBcUIsS0FBS3hsQixJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJnQixRQUEvQztBQUVBLFNBQUtFLFFBQUwsR0FBZ0IsS0FBS3dVLEdBQUwsQ0FBUzFGLElBQVQsQ0FBYyw0QkFBZCxDQUFoQjtBQUNBLFNBQUs3TyxLQUFMLEdBQWEsS0FBS3VVLEdBQUwsQ0FBUzFGLElBQVQsQ0FBYyx5QkFBZCxDQUFiO0FBQ0EsU0FBSy9PLE9BQUwsR0FBZSxLQUFLeVUsR0FBTCxDQUFTMUYsSUFBVCxDQUFjLDJCQUFkLENBQWY7QUFDQSxTQUFLb2xCLFFBQUwsR0FBZ0IsS0FBSzFmLEdBQUwsQ0FBUzFGLElBQVQsQ0FBYyw0QkFBZCxDQUFoQixDQVRtQixDQVduQjs7QUFDQSxTQUFLTCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixDQUFnQzhVLFNBQWhDLENBQTBDO0FBQUEsYUFBTSxLQUFJLENBQUNqQixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JvQixlQUF4QixDQUF3QyxJQUF4QyxDQUFOO0FBQUEsS0FBMUM7QUFDSDs7QUF4Qkw7QUFBQTs7QUEwQkk7OztBQTFCSixxQ0E2QnFCO0FBQ2JzRSxPQUFDLENBQUMsWUFBRCxDQUFELENBQWdCd1csT0FBaEIsQ0FBd0I7QUFDcEJ6RixpQkFBUyxFQUFFLEtBQUs0QyxHQUFMLENBQVMyZixNQUFULEdBQWtCemlCO0FBRFQsT0FBeEIsRUFFRyxJQUZIO0FBR0g7QUFqQ0w7QUFBQTs7QUFtQ0k7Ozs7QUFuQ0osd0NBdUN3QjtBQUNoQixVQUFJMGlCLGdCQUFnQixHQUFHLEdBQXZCO0FBQ0EsVUFBSUMsWUFBWSxHQUFHLEtBQUs3ZixHQUFMLENBQVMyZixNQUFULEdBQWtCemlCLEdBQXJDLENBRmdCLENBR2hCOztBQUNBLFVBQUk0aUIsZUFBZSxHQUFHRCxZQUFZLEdBQUdELGdCQUFyQztBQUNBLFVBQUlHLGNBQWMsR0FBRzF6QixDQUFDLENBQUM4YixNQUFELENBQUQsQ0FBVS9LLFNBQVYsS0FBd0IvUSxDQUFDLENBQUM4YixNQUFELENBQUQsQ0FBVTlILE1BQVYsRUFBN0M7QUFDQSxVQUFJMmYsV0FBVyxHQUFHM3pCLENBQUMsQ0FBQzhiLE1BQUQsQ0FBRCxDQUFVL0ssU0FBVixFQUFsQixDQU5nQixDQU9oQjs7QUFDQSxhQUNLeWlCLFlBQVksR0FBR0UsY0FBaEIsSUFDQ0MsV0FBVyxHQUFHRixlQUZuQjtBQUdIO0FBbERMO0FBQUE7O0FBb0RJOzs7O0FBcERKLDRCQXdEWTtBQUNKLFdBQUtMLGFBQUwsQ0FBbUJsMEIsT0FBbkIsQ0FBMkIsU0FBM0I7QUFDQSxXQUFLazBCLGFBQUwsQ0FBbUJqMEIsUUFBbkIsQ0FBNEIsSUFBNUI7QUFDQSxXQUFLaTBCLGFBQUwsQ0FBbUJoMEIsS0FBbkIsQ0FBeUIsSUFBekI7QUFDQSxXQUFLZzBCLGFBQUwsQ0FBbUJ6NUIsTUFBbkIsQ0FBMEIsS0FBMUI7QUFDQSxXQUFLeTVCLGFBQUwsQ0FBbUIvekIsVUFBbkIsQ0FBOEI2VSxTQUE5QjtBQUNBLFdBQUtrZixhQUFMLENBQW1COXpCLGNBQW5CLENBQWtDNFUsU0FBbEM7QUFDQSxXQUFLMGYscUJBQUw7QUFDSDtBQWhFTDtBQUFBO0FBQUEsNENBcUY0QixDQUV2QjtBQUVEOzs7OztBQXpGSjtBQUFBO0FBQUEsbUNBNkZtQkMsZ0JBN0ZuQixFQTZGcUM7QUFBQTs7QUFDN0I7QUFDQSxVQUFJMzBCLE9BQU8sR0FBR3NPLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJnRyxnQkFBZ0IsQ0FBQ0MsT0FBbEMsQ0FBZDtBQUNBLFVBQUkzMEIsUUFBUSxHQUFHcU8sRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQmdHLGdCQUFnQixDQUFDRSxRQUFsQyxDQUFmO0FBQ0EsVUFBSTMwQixLQUFLLEdBQUdvTyxFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCZ0csZ0JBQWdCLENBQUNHLEtBQWxDLENBQVo7QUFDQSxVQUFJcGxCLElBQUksR0FBR3BCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJnRyxnQkFBZ0IsQ0FBQ3BELElBQWxDLENBQVg7QUFDQSxVQUFJM3ZCLElBQUksR0FBRyt5QixnQkFBZ0IsQ0FBQ0ksSUFBNUI7QUFDQSxVQUFJQyxTQUFTLEdBQUcxbUIsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQmdHLGdCQUFnQixDQUFDTSxRQUFsQyxDQUFoQixDQVA2QixDQVM3Qjs7QUFDQSxVQUFJQyxTQUFTLEdBQUcsS0FBS3htQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJvRCxNQUEzQixFQUFoQjs7QUFDQSxVQUFJeTZCLFNBQVMsSUFBSWoxQixRQUFRLENBQUNrRixXQUFULE9BQTJCLFVBQTVDLEVBQXdEO0FBQ3BEbEYsZ0JBQVEsR0FBRyxXQUFYO0FBQ0FDLGFBQUssR0FBRyxXQUFSO0FBQ0FGLGVBQU8sR0FBRyxxQkFBVjtBQUNILE9BZjRCLENBaUI3Qjs7O0FBQ0EsVUFBSUMsUUFBUSxDQUFDa0YsV0FBVCxPQUEyQixZQUEzQixJQUEyQ2pGLEtBQUssQ0FBQ2lGLFdBQU4sT0FBd0IsU0FBdkUsRUFBa0Y7QUFDOUVqRixhQUFLLEdBQUcscUJBQVI7QUFDSCxPQXBCNEIsQ0FzQjdCOzs7QUFDQSxVQUFJRCxRQUFRLEtBQUssWUFBYixJQUE2QkMsS0FBSyxLQUFLLFdBQTNDLEVBQXdEO0FBQ3BERCxnQkFBUSxHQUFHLFdBQVg7QUFDSCxPQXpCNEIsQ0EyQjdCOzs7QUFDQUQsYUFBTyxHQUFHLEtBQUswTyxJQUFMLENBQVU3SyxTQUFWLENBQW9CQyxRQUFwQixDQUE2QjlELE9BQTdCLEVBQXNDdWMsT0FBdEMsQ0FBOEMsVUFBOUMsRUFBMEQsV0FBMUQsQ0FBVjtBQUNBLFdBQUsyWCxhQUFMLENBQW1CbDBCLE9BQW5CLENBQTJCQSxPQUEzQjtBQUNBLFdBQUtrMEIsYUFBTCxDQUFtQmowQixRQUFuQixDQUE0QkEsUUFBNUI7QUFDQSxXQUFLaTBCLGFBQUwsQ0FBbUJoMEIsS0FBbkIsQ0FBeUJBLEtBQXpCLEVBL0I2QixDQWdDN0I7O0FBQ0EsV0FBS0YsT0FBTCxDQUFhK08sSUFBYixDQUFrQixVQUFsQixFQUE4QnZGLEdBQTlCLENBQW1DLFVBQUNxTixDQUFELEVBQUlzZSxLQUFKLEVBQWM7QUFDN0N2WSxjQUFNLENBQUN3WSxJQUFQLENBQVlDLGNBQVosQ0FBMkJGLEtBQTNCO0FBQ0gsT0FGRCxFQWpDNkIsQ0FvQzdCO0FBQ0E7O0FBQ0EsV0FBS3ptQixJQUFMLENBQVV6TixVQUFWLENBQXFCQyxNQUFyQixDQUE0QnRELFFBQTVCLENBQXFDLGNBQXJDLEVBQXFEcUMsUUFBckQsRUFBK0RDLEtBQS9ELEVBQXNFRixPQUF0RSxFQUErRSxXQUEvRSxFQXRDNkIsQ0F3QzdCOztBQUNBLFdBQUswTyxJQUFMLENBQVV6TixVQUFWLENBQXFCa0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDeWhCLHFCQUFyQyxHQXpDNkIsQ0EyQzdCOztBQUNBLFVBQUlwZSxJQUFJLEdBQUd1SSxlQUFlLENBQUNzbUIsa0JBQWhCLENBQW1DMXpCLElBQW5DLENBQVg7QUFDQSxXQUFLc3lCLGFBQUwsQ0FBbUIvekIsVUFBbkIsQ0FBOEI2VSxTQUE5Qjs7QUFDQSxVQUFJdk8sSUFBSSxLQUFLLElBQVQsSUFBaUJBLElBQUksS0FBS2pQLFNBQTlCLEVBQXlDO0FBQ3JDLGFBQUswOEIsYUFBTCxDQUFtQi96QixVQUFuQixDQUE4QjhULElBQTlCLENBQW1DeE4sSUFBbkM7QUFDSCxPQWhENEIsQ0FrRDdCOzs7QUFDQSxVQUFJOHVCLGFBQWEsR0FBRyxLQUFLN21CLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NJLE9BQXREO0FBQ0EsV0FBSzgwQixhQUFMLENBQW1COXpCLGNBQW5CLENBQWtDNFUsU0FBbEM7O0FBQ0EsVUFBSXVnQixhQUFhLENBQUNscUIsT0FBbEIsRUFBMkI7QUFDdkIsWUFBSW1xQixjQUFjLEdBQUcsRUFBckI7QUFDQSxhQUFLOW1CLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NzekIsTUFBbEMsQ0FBeUM3TixLQUF6QyxDQUErQ3pNLE9BQS9DLENBQXVELFVBQUN2UixJQUFELEVBQVU7QUFDN0QsY0FBSTh1QixhQUFhLENBQUM5USxLQUFkLENBQW9CMWEsT0FBcEIsQ0FBNEJ0RCxJQUE1QixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDK3VCLDBCQUFjLENBQUN2aEIsSUFBZixDQUFvQnhOLElBQXBCO0FBQ0g7QUFDSixTQUpEO0FBS0EsYUFBS3l0QixhQUFMLENBQW1COXpCLGNBQW5CLENBQWtDbzFCLGNBQWxDO0FBQ0g7O0FBN0Q0QixpQ0ErRHBCM2UsQ0EvRG9CO0FBZ0V6QixZQUFJNGUsWUFBWSxHQUFHVCxTQUFTLENBQUNuZSxDQUFELENBQTVCOztBQUNBLGNBQUksQ0FBQzZlLG1CQUFMLENBQXlCRCxZQUFZLENBQUN6MUIsT0FBdEMsRUFBK0MsTUFBL0MsRUFBdUQsT0FBdkQsRUFBZ0U7QUFBQSxpQkFBTSxNQUFJLENBQUMwTyxJQUFMLENBQVV6TixVQUFWLENBQXFCbUQsTUFBckIsQ0FBNEJ1WCxzQkFBNUIsQ0FBbUQ4WixZQUFZLENBQUN2YixLQUFoRSxFQUF1RXViLFlBQVksQ0FBQ3oxQixPQUFwRixDQUFOO0FBQUEsU0FBaEU7QUFqRXlCOztBQStEN0IsV0FBSyxJQUFJNlcsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFDbWUsU0FBUyxDQUFDcHRCLE1BQTFCLEVBQWtDaVAsQ0FBQyxJQUFFLENBQXJDLEVBQXdDO0FBQUEsY0FBL0JBLENBQStCO0FBR3ZDO0FBQ0o7QUFoS0w7QUFBQTtBQUFBLDRDQWtLNEI7QUFDcEIsV0FBS3NkLFFBQUwsQ0FBY2hmLEtBQWQ7QUFDQSxXQUFLekcsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCcUosU0FBOUIsQ0FBd0NzTyxJQUF4QyxDQUE2Qyx3QkFBN0MsRUFBdUVXLElBQXZFO0FBQ0g7QUFyS0w7QUFBQTtBQUFBLHdDQXVLd0JmLElBdkt4QixFQXVLOEI4UCxJQXZLOUIsRUF1S29Da1gsS0F2S3BDLEVBdUsyQ0MsT0F2SzNDLEVBdUtvREMsS0F2S3BELEVBdUsyRDtBQUFBOztBQUNuRCxVQUFJMUIsUUFBUSxHQUFHcnpCLENBQUMsQ0FBQyxlQUFELENBQWhCO0FBQ0FxekIsY0FBUSxDQUFDM2lCLFFBQVQsQ0FBa0IsMkNBQXlDaU4sSUFBM0Q7QUFDQTBWLGNBQVEsQ0FBQzJCLEdBQVQsQ0FBYSxPQUFiLEVBQXNCSCxLQUF0QjtBQUNBeEIsY0FBUSxDQUFDN2QsSUFBVCxDQUFjLE9BQWQsRUFBdUIzSCxJQUF2Qjs7QUFDQSxVQUFJa25CLEtBQUosRUFBVztBQUNQLGFBQUsxQixRQUFMLENBQWMvaEIsTUFBZCxDQUFxQitoQixRQUFyQjtBQUNILE9BRkQsTUFFTztBQUNILGFBQUtBLFFBQUwsQ0FBY3ppQixPQUFkLENBQXNCeWlCLFFBQXRCO0FBQ0g7O0FBQ0RBLGNBQVEsQ0FBQ3BoQixPQUFULENBQWlCO0FBQUMsbUJBQVcsT0FBWjtBQUFxQixxQkFBYSxLQUFLckUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCb0o7QUFBaEUsT0FBakI7O0FBQ0EsVUFBSW8xQixPQUFPLEtBQUtwK0IsU0FBaEIsRUFBMkI7QUFDdkIyOEIsZ0JBQVEsQ0FBQ2hnQixLQUFULENBQWV5aEIsT0FBZjtBQUNIOztBQUNEekIsY0FBUSxDQUFDNEIsS0FBVCxDQUFlLFlBQU07QUFDakIsY0FBSSxDQUFDcm5CLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsWUFBckMsRUFBbUQsVUFBbkQsRUFBK0QsT0FBL0QsRUFBd0UrUSxJQUF4RSxFQUE4RSxFQUE5RTtBQUNILE9BRkQ7QUFHSDtBQUVEOzs7O0FBMUxKO0FBQUE7QUFBQSxvQ0E2TG9CZ21CLGdCQTdMcEIsRUE2THNDO0FBQzlCLFdBQUtxQixjQUFMLENBQW9CckIsZ0JBQXBCLEVBRDhCLENBRzlCO0FBQ0E7O0FBRUEsV0FBS3NCLG9CQUFMO0FBQ0g7QUFwTUw7QUFBQTtBQUFBLDJDQXNNMkI7QUFDbkIsVUFBSSxDQUFDLEtBQUt4d0IsaUJBQUwsRUFBTCxFQUErQjtBQUMzQixhQUFLZ1AsR0FBTCxDQUFTMUYsSUFBVCxDQUFjLDRCQUFkLEVBQTRDVSxJQUE1QyxHQUFtRGpDLE9BQW5ELENBQTJELElBQTNEO0FBQ0EsYUFBSzBvQixjQUFMO0FBQ0g7QUFDSjtBQTNNTDtBQUFBO0FBQUEsb0NBNk1vQnZkLEtBN01wQixFQTZNMkJ3ZCxXQTdNM0IsRUE2TXdDO0FBQ2hDLFVBQUlBLFdBQVcsS0FBSzMrQixTQUFwQixFQUErQjtBQUMzQjIrQixtQkFBVyxHQUFHLEtBQWQ7QUFDSDs7QUFDRCxVQUFJbjJCLE9BQUosRUFBYUUsS0FBYixFQUFvQkQsUUFBcEIsRUFBOEJvekIsTUFBOUI7QUFDQW56QixXQUFLLEdBQUd5WSxLQUFLLENBQUMrWSxPQUFkO0FBQ0F6eEIsY0FBUSxHQUFHLFNBQVg7QUFDQUQsYUFBTyxHQUFHLEtBQUtvMkIsa0JBQUwsQ0FBd0J6ZCxLQUF4QixDQUFWOztBQUVBLFVBQUl3ZCxXQUFKLEVBQWlCO0FBQ2IsZUFBT24yQixPQUFQO0FBQ0g7O0FBQ0QsV0FBS2swQixhQUFMLENBQW1CbDBCLE9BQW5CLENBQTJCQSxPQUEzQjtBQUNBLFdBQUtrMEIsYUFBTCxDQUFtQmowQixRQUFuQixDQUE0QkEsUUFBNUI7QUFDQSxXQUFLaTBCLGFBQUwsQ0FBbUJoMEIsS0FBbkIsQ0FBeUJBLEtBQXpCO0FBQ0EsV0FBS2cwQixhQUFMLENBQW1CL3pCLFVBQW5CLENBQThCNlUsU0FBOUI7O0FBQ0EsVUFBSXFlLE1BQU0sS0FBSzc3QixTQUFYLElBQXdCNjdCLE1BQU0sS0FBSyxJQUF2QyxFQUE2QztBQUN6QyxhQUFLYSxhQUFMLENBQW1CL3pCLFVBQW5CLENBQThCOFQsSUFBOUIsQ0FBbUNvZixNQUFuQztBQUNIO0FBQ0o7QUFoT0w7QUFBQTtBQUFBLG1DQWtPbUIxYSxLQWxPbkIsRUFrTzBCMGQsZ0JBbE8xQixFQWtPNEM7QUFBQTs7QUFDcEMsYUFBTzFkLEtBQUssQ0FBQzJkLFNBQU4sQ0FBZ0I5c0IsR0FBaEIsQ0FBb0IsVUFBQStzQixLQUFLLEVBQUk7QUFDaEMsWUFBSWxELE1BQU0sR0FBR2tELEtBQUssQ0FBQ2xELE1BQW5COztBQUNBLFlBQUlrRCxLQUFLLENBQUNsN0IsUUFBTixDQUFlOE4sS0FBZixDQUFxQixDQUFyQixFQUF3QixDQUFDLENBQXpCLE1BQWdDa3RCLGdCQUFwQyxFQUFzRDtBQUNsRGhELGdCQUFNLElBQUksTUFBSSxDQUFDM2tCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0MxRCxVQUFsQyxDQUE2QzQxQixVQUF2RDtBQUNIOztBQUNELFlBQUl2cEIsSUFBSSw2Q0FBbUM0dUIsS0FBSyxDQUFDbDdCLFFBQXpDLGdCQUFSO0FBQ0EsWUFBSW9MLElBQUksNENBQW1DNHNCLE1BQW5DLGNBQVI7QUFDQSxZQUFJbUQsS0FBSyxHQUFJRCxLQUFLLENBQUNDLEtBQU4sS0FBZ0IsVUFBaEIsSUFDYkQsS0FBSyxDQUFDQyxLQUFOLEtBQWdCaC9CLFNBREosc0JBQzZCKytCLEtBQUssQ0FBQ0MsS0FEbkMsSUFDNkMsRUFEekQ7QUFFQSxZQUFJMVQsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsWUFBSXlULEtBQUssQ0FBQ3pULE1BQU4sS0FBaUJ0ckIsU0FBckIsRUFBZ0M7QUFDNUJzckIsZ0JBQU0sMEJBQW1CeVQsS0FBSyxDQUFDelQsTUFBekIsa0JBQU47QUFDSDs7QUFDRCxlQUFPbmIsSUFBSSxHQUFHbEIsSUFBUCxHQUFjK3ZCLEtBQWQsR0FBc0IxVCxNQUE3QjtBQUNILE9BZE0sQ0FBUDtBQWVIO0FBbFBMO0FBQUE7QUFBQSx1Q0FvUHVCbkssS0FwUHZCLEVBb1A4QjBkLGdCQXBQOUIsRUFvUGdESSxZQXBQaEQsRUFvUDhEO0FBQ3RELFVBQUkxOUIsSUFBSSxHQUFHNGYsS0FBSyxDQUFDK1ksT0FBakI7QUFDQSxVQUFJbkQsSUFBSSxHQUFHamdCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJoVyxLQUFLLENBQUM0VixJQUF2QixDQUFYO0FBQ0EsVUFBSTVjLEdBQUcsYUFBTTVZLElBQU4sZUFBZXcxQixJQUFJLENBQUMsQ0FBRCxDQUFuQixpQkFBUDtBQUNBLFVBQUkrSCxTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsVUFBSXY5QixJQUFJLEtBQUssY0FBYixFQUE2QjtBQUN6QixZQUFJNGYsS0FBSyxDQUFDK2QsR0FBTixJQUFhL2QsS0FBSyxDQUFDK2QsR0FBTixDQUFVSixTQUF2QixJQUFvQzNkLEtBQUssQ0FBQytkLEdBQU4sQ0FBVUosU0FBVixDQUFvQjF1QixNQUE1RCxFQUFvRTtBQUNoRSxjQUFNK3VCLFNBQVMsR0FBRyxLQUFLQyxjQUFMLENBQW9CamUsS0FBSyxDQUFDK2QsR0FBMUIsRUFBK0JMLGdCQUEvQixDQUFsQjtBQUNBLGNBQU1yb0IsTUFBTSxHQUFHLENBQUMsWUFBRCxDQUFmOztBQUNBLGNBQUkyb0IsU0FBUyxDQUFDL3VCLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEJvRyxrQkFBTSxDQUFDaUcsSUFBUCxPQUFBakcsTUFBTSxxQkFBUzJvQixTQUFTLENBQUN4dEIsS0FBVixDQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFULCtCQUNvQnd0QixTQUFTLENBQUMvdUIsTUFBVixHQUFtQixDQUR2QyxtREFFUyt1QixTQUFTLENBQUN4dEIsS0FBVixDQUFnQixDQUFDLENBQWpCLEVBQW9CLENBQUMsQ0FBckIsQ0FGVCxHQUFOO0FBR0gsV0FKRCxNQUlPO0FBQ0g2RSxrQkFBTSxDQUFDaUcsSUFBUCxPQUFBakcsTUFBTSxxQkFBUzJvQixTQUFULEVBQU47QUFDSDs7QUFDREwsbUJBQVMsR0FBR3RvQixNQUFNLENBQUNrTyxJQUFQLENBQVksUUFBWixDQUFaO0FBQ0g7QUFDSixPQWJELE1BYU87QUFDSCxZQUFJdWEsWUFBSixFQUFrQjtBQUNkOWtCLGFBQUcsR0FBRyxvRkFBa0ZBLEdBQXhGO0FBQ0g7O0FBQ0QsWUFBSWdILEtBQUssQ0FBQzJkLFNBQU4sSUFBbUIzZCxLQUFLLENBQUMyZCxTQUFOLENBQWdCMXVCLE1BQXZDLEVBQStDO0FBQzNDMHVCLG1CQUFTLEdBQUcscUJBQXFCLEtBQUtNLGNBQUwsQ0FBb0JqZSxLQUFwQixFQUEyQjBkLGdCQUEzQixFQUE2Q25hLElBQTdDLENBQWtELFFBQWxELENBQWpDO0FBQ0g7QUFDSjs7QUFDRCxhQUFPdkssR0FBRyxHQUFDLElBQUosR0FBUzJrQixTQUFoQjtBQUNIO0FBL1FMO0FBQUE7QUFBQSx5Q0FpUnlCM2QsS0FqUnpCLEVBaVJnQzBkLGdCQWpSaEMsRUFpUmtEO0FBQzFDLFVBQUkxZCxLQUFLLENBQUMrWSxPQUFOLEtBQWtCLGNBQXRCLEVBQXNDO0FBQ2xDLGFBQUtoakIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNFLFFBQW5DLENBQTRDLFNBQTVDO0FBQ0EsYUFBS3lPLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JxRyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DRyxLQUFuQyxDQUF5QyxlQUF6QztBQUNILE9BSEQsTUFHTztBQUNILGFBQUt3TyxJQUFMLENBQVVoVyxLQUFWLENBQWdCcUcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0UsUUFBbkMsQ0FBNEMsVUFBNUM7QUFDQSxhQUFLeU8sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNHLEtBQW5DLENBQXlDLGdCQUF6QztBQUNIOztBQUNELFVBQUlGLE9BQU8sR0FBRyxLQUFLbzJCLGtCQUFMLENBQXdCemQsS0FBeEIsRUFBK0IwZCxnQkFBL0IsRUFBaUQsSUFBakQsQ0FBZDtBQUNBLFdBQUszbkIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnFHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNDLE9BQW5DLENBQTJDQSxPQUEzQztBQUVBLFdBQUtpMkIsb0JBQUw7QUFFQSxXQUFLdm5CLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdEQsUUFBNUIsQ0FBcUMsZ0JBQXJDLEVBQXVELFVBQXZELEVBQW1FLGdCQUFuRSxFQUFxRm9DLE9BQXJGLEVBQThGcTJCLGdCQUE5RjtBQUNIO0FBL1JMO0FBQUE7QUFBQSx1Q0FrRThCUSxZQWxFOUIsRUFrRTRDO0FBQ3BDLFVBQUlBLFlBQVksQ0FBQ2pILFlBQWpCLEVBQStCO0FBQzNCLFlBQUlrSCxRQUFRLEdBQUdELFlBQVksQ0FBQ2pILFlBQWIsQ0FBMEIsSUFBSXRoQixFQUFFLENBQUNzZixPQUFILENBQVcrQixHQUFmLENBQW1CLFVBQW5CLENBQTFCLENBQWY7O0FBQ0EsWUFBSW1ILFFBQUosRUFBYztBQUNWLGNBQUlyd0IsSUFBSSxHQUFHcXdCLFFBQVEsQ0FBQ0MsVUFBVCxDQUFvQixJQUFJem9CLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUIsTUFBbkIsQ0FBcEIsQ0FBWDs7QUFDQSxjQUFJbHBCLElBQUosRUFBVTtBQUNOLG1CQUFPNkgsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQmxvQixJQUFqQixDQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNBOzs7Ozs7QUFNSDtBQW5GTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NDMUNBOztBQUVBLElBQU02YixPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFTam5CLFFBQVQsRUFBbUIyN0IsWUFBbkIsRUFBaUNDLFdBQWpDLEVBQThDQyxhQUE5QyxFQUE2RDtBQUN6RSxNQUFJRixZQUFZLEtBQUt4L0IsU0FBckIsRUFBZ0M7QUFDNUJ3L0IsZ0JBQVksR0FBRzM3QixRQUFmO0FBQ0g7O0FBQ0QsTUFBSTg3QixtQkFBbUIsR0FBRyxFQUExQjtBQUNBLE1BQUlDLG1CQUFtQixHQUFHLE1BQTFCOztBQUNBLE1BQUksQ0FBQ0YsYUFBTCxFQUFvQjtBQUNoQkMsdUJBQW1CLEdBQUcseUJBQXRCO0FBQ0FDLHVCQUFtQixHQUFHLHNCQUF0QjtBQUNIOztBQUNELDhDQUNzQkQsbUJBRHRCLDJKQUkyRDk3QixRQUozRCx1RUFLbURBLFFBTG5ELDZDQU15QjQ3QixXQU56Qix1Q0FNaUU1N0IsUUFOakUsb0JBTW1GKzdCLG1CQU5uRiw4QkFPVUosWUFQVjtBQVNILENBbkJEOztBQXFCTyxJQUFJSyxVQUFVLGtQQVNmL1UsT0FBTyxDQUFDLFdBQUQsRUFBYzlxQixTQUFkLEVBQXlCQSxTQUF6QixFQUFvQyxJQUFwQyxDQVRRLG1CQVVmOHFCLE9BQU8sQ0FBQyxrQkFBRCxFQUFxQixjQUFyQixDQVZRLG1CQVdmQSxPQUFPLENBQUMsOEJBQUQsRUFBaUMsVUFBakMsQ0FYUSxtQkFZZkEsT0FBTyxDQUFDLG1CQUFELEVBQXNCLGVBQXRCLENBWlEsbUJBYWZBLE9BQU8sQ0FBQyxZQUFELEVBQWUsUUFBZixDQWJRLG1CQWNmQSxPQUFPLENBQUMsZUFBRCxFQUFrQixXQUFsQixFQUErQixJQUEvQixDQWRRLG1CQWVmQSxPQUFPLENBQUMsYUFBRCxFQUFnQixTQUFoQixFQUEyQixJQUEzQixDQWZRLG1CQWdCZkEsT0FBTyxDQUFDLDZCQUFELEVBQWdDLG9CQUFoQyxFQUFzRCxJQUF0RCxDQWhCUSxtQkFpQmZBLE9BQU8sQ0FBQyxlQUFELEVBQWtCLE1BQWxCLEVBQTBCLElBQTFCLENBakJRLDJ3SkFBZDtBQXNHUCxJQUFNZ1YsK0JBQStCLDQyQ0FBckM7QUFtQ0E7Ozs7Ozs7Ozs7OztBQVlPLElBQUlDLGNBQWMsR0FBRyxDQUN4QjtBQUNBLFdBRndCLEVBR3hCO0FBQ0Esa0JBSndCLEVBS3hCLDhCQUx3QixFQU14QixtQkFOd0IsRUFPeEIsWUFQd0IsRUFReEIsbUJBUndCLENBQXJCO0FBV0EsSUFBTUMsZUFBZSxHQUFHLENBQzNCLGVBRDJCLEVBRTNCLGFBRjJCLEVBRzNCLG9CQUgyQixFQUkzQixrQkFKMkIsRUFLM0IsZUFMMkIsRUFNM0IsNkJBTjJCLEVBTzNCLG1CQVAyQixFQVEzQixtQkFSMkIsQ0FBeEI7QUFXQSxTQUFTekgsZ0JBQVQsQ0FBMEIxMEIsUUFBMUIsRUFBb0M7QUFDdkMsTUFBSSxVQUFVeTBCLFFBQVYsQ0FBbUJ6MEIsUUFBUSxDQUFDLENBQUQsQ0FBM0IsQ0FBSixFQUFxQztBQUNqQyxXQUFPQSxRQUFRLENBQUM4TixLQUFULENBQWUsQ0FBZixDQUFQO0FBQ0gsR0FGRCxNQUVPO0FBQ0gsV0FBTzlOLFFBQVA7QUFDSDtBQUNKO0FBRUQsSUFBTW84QixvQkFBb0IsR0FBRyxjQUE3QjtBQUNBLElBQU1DLGlCQUFpQixHQUFHLFdBQTFCO0FBRUEsSUFBTUMsV0FBVyxHQUFHO0FBQ2hCQyxZQUFVLEVBQUUsWUFESTtBQUVoQkMsdUJBQXFCLEVBQUUsdUJBRlA7QUFHaEJDLG9CQUFrQixFQUFFO0FBSEosQ0FBcEI7QUFNQSxJQUFNQyxzQkFBc0IsR0FBRyxDQUFDLGVBQUQsRUFBa0IsYUFBbEIsQ0FBL0I7QUFFTyxJQUFNanVCLGlCQUFpQixHQUFHLENBQUMsV0FBRCxFQUFjLGtCQUFkLEVBQWtDLHlCQUFsQyxFQUNDLG1CQURELEVBQ3NCLFlBRHRCLEVBQ29DLG1CQURwQyxDQUExQjtBQUdBLElBQU1HLGlCQUFpQixHQUFHLENBQUMsV0FBRCxFQUFjLGtCQUFkLEVBQWtDLHlCQUFsQyxFQUNDLG1CQURELEVBQ3NCLFlBRHRCLEVBQ29DLG1CQURwQyxFQUVDLGVBRkQsRUFFa0IsYUFGbEIsRUFHQyxvQkFIRCxFQUd1QixrQkFIdkIsRUFJQyxlQUpELEVBSWtCLDZCQUpsQixFQUtDLG1CQUxELEVBS3NCLG1CQUx0QixDQUExQjs7SUFPRCt0QixXLEdBQ0YscUJBQVl0cEIsSUFBWixFQUFrQnJULFFBQWxCLEVBQTRCc08sUUFBNUIsRUFBc0M7QUFBQTs7QUFDbEMsT0FBSytFLElBQUwsR0FBWUEsSUFBWjtBQUNBLE9BQUtyVCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUtzTyxRQUFMLEdBQWdCQSxRQUFRLElBQUksRUFBNUI7QUFDQSxPQUFLc3VCLEtBQUwsR0FBYSxJQUFiO0FBQ0EsT0FBS252QixNQUFMLEdBQWMsSUFBZDtBQUNILEM7O0FBR0UsU0FBU1ksYUFBVCxDQUF1QnJPLFFBQXZCLEVBQWlDc08sUUFBakMsRUFBMkM7QUFDOUMsU0FBTztBQUFDLGdCQUFZOVEsRUFBRSxDQUFDQyxVQUFILENBQWN1QyxRQUFkLENBQWI7QUFBc0NzTyxZQUFRLEVBQUU5USxFQUFFLENBQUNDLFVBQUgsQ0FBYzZRLFFBQVEsSUFBSSxFQUExQjtBQUFoRCxHQUFQO0FBQ0g7O0FBRUQsU0FBU3V1QixpQkFBVCxDQUEyQjc4QixRQUEzQixFQUFxQ3NPLFNBQXJDLEVBQStDO0FBQzNDLFNBQU87QUFBRXRPLFlBQVE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsTUFBRTtBQUFBLGFBQU1BLFFBQU47QUFBQSxLQUFGLENBQVY7QUFBNEJzTyxZQUFRLEVBQUU7QUFBQSxhQUFNQSxTQUFOO0FBQUE7QUFBdEMsR0FBUDtBQUNIOztBQUVNLFNBQVMzUCxvQkFBVCxDQUE4Qm0rQixnQkFBOUIsRUFBZ0RDLGFBQWhELEVBQStEO0FBQ2xFLE1BQUlELGdCQUFKLEVBQXNCO0FBQ2xCLFFBQUk5d0IsS0FBSyxHQUFHWSxJQUFJLENBQUM4RixLQUFMLENBQVdvcUIsZ0JBQVgsQ0FBWjtBQUNBLFFBQUlFLFVBQVUsR0FBRyxFQUFqQjs7QUFDQSxTQUFLLElBQUloOUIsVUFBVCxJQUFxQmdNLEtBQXJCLEVBQTRCO0FBQ3hCLFVBQUlBLEtBQUssQ0FBQ3ltQixjQUFOLENBQXFCenlCLFVBQXJCLENBQUosRUFBb0M7QUFDaENnOUIsa0JBQVUsQ0FBQ3BrQixJQUFYLENBQWdCdkssYUFBYSxDQUFDck8sVUFBRCxFQUFXZ00sS0FBSyxDQUFDaE0sVUFBRCxDQUFoQixDQUE3QjtBQUNIO0FBQ0osS0FQaUIsQ0FRbEI7OztBQUNBLFFBQUkrOEIsYUFBSixFQUFtQjtBQUNmQSxtQkFBYSxDQUFDQyxVQUFELENBQWI7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFPQSxVQUFQO0FBQ0g7QUFDSixHQWRELE1BY087QUFDSCxRQUFJRCxhQUFKLEVBQW1CO0FBQ2ZBLG1CQUFhLENBQUMsRUFBRCxDQUFiO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBTyxFQUFQO0FBQ0g7QUFDSjtBQUNKO0FBRU0sU0FBU0Usc0JBQVQsQ0FBZ0NGLGFBQWhDLEVBQStDO0FBQ2xELFNBQU9ud0IsSUFBSSxDQUFDQyxTQUFMLENBQWVrd0IsYUFBYSxHQUFHNXVCLEdBQWhCLENBQW9CLFVBQUE3QixJQUFJLEVBQUk7QUFDOUMsV0FBTztBQUNIdE0sY0FBUSxFQUFFc00sSUFBSSxDQUFDdE0sUUFBTCxFQURQO0FBRUhzTyxjQUFRLEVBQUVoQyxJQUFJLENBQUNnQyxRQUFMO0FBRlAsS0FBUDtBQUlILEdBTHFCLENBQWYsQ0FBUDtBQU1IO0FBRU0sU0FBU1gsdUJBQVQsQ0FBaUNvdkIsYUFBakMsRUFBZ0Q7QUFDbkQsU0FBT3YvQixFQUFFLENBQUM2SyxZQUFILENBQWdCLFlBQU07QUFDekIsUUFBSXNLLE1BQU0sR0FBRyxFQUFiO0FBQ0FvcUIsaUJBQWEsR0FBR3BnQixPQUFoQixDQUF3QixVQUFBclEsSUFBSTtBQUFBLGFBQ3hCcUcsTUFBTSxDQUFDckcsSUFBSSxDQUFDdE0sUUFBTCxFQUFELENBQU4sR0FBMEJzTSxJQUFJLENBQUNnQyxRQUFMLEVBREY7QUFBQSxLQUE1QjtBQUVBLFdBQU8xQixJQUFJLENBQUNDLFNBQUwsQ0FBZThGLE1BQWYsQ0FBUDtBQUNILEdBTE0sQ0FBUDtBQU1IO0FBRUQ7Ozs7QUFHTyxJQUFNb0IsaUJBQWI7QUFDSSw2QkFBWVYsSUFBWixFQUFrQjtBQUFBOztBQUNkLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUs2cEIsTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLQyxVQUFMO0FBRUEsU0FBS0MsVUFBTDtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7QUFFQSxTQUFLaHFCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QkUsVUFBeEIsQ0FBbUNxVSxTQUFuQyxDQUE2QyxVQUFDZ3BCLFNBQUQsRUFBYztBQUN2RDczQixPQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QjgzQixNQUE5QixDQUFxQ0QsU0FBckM7QUFDSCxLQUZEO0FBR0g7O0FBWkw7QUFBQTtBQUFBLDhCQWNjdDlCLFFBZGQsRUFjd0Irb0IsUUFkeEIsRUFja0M7QUFDMUIsVUFBSSxFQUFFL29CLFFBQVEsSUFBSSxLQUFLcTlCLFFBQW5CLENBQUosRUFBa0M7QUFDOUIsYUFBS0EsUUFBTCxDQUFjcjlCLFFBQWQsSUFBMEIsRUFBMUI7QUFDSDs7QUFDRCxXQUFLcTlCLFFBQUwsQ0FBY3I5QixRQUFkLEVBQXdCNFksSUFBeEIsQ0FBNkJtUSxRQUE3QjtBQUNIO0FBbkJMO0FBQUE7QUFBQSxxQ0FxQnFCL29CLFFBckJyQixFQXFCK0I7QUFDdkIsYUFBTyxLQUFLcTlCLFFBQUwsQ0FBY3I5QixRQUFkLENBQVA7QUFDSDtBQXZCTDtBQUFBO0FBQUEsaUNBeUJpQjtBQUFBOztBQUNULFVBQUl3OUIsVUFBVSxHQUFHLElBQWpCO0FBQ0EsT0FBQyxLQUFLbnFCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQndELFVBQTVCLEVBQ0MsS0FBSzRULElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjRDLGtCQUQ1QixFQUVDLEtBQUt5VSxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFGNUIsRUFFa0RrZSxPQUZsRCxDQUUwRCxVQUFBOGdCLFNBQVM7QUFBQSxlQUMvREEsU0FBUyxDQUFDbnBCLFNBQVYsQ0FBb0IsVUFBU29wQixPQUFULEVBQWtCO0FBQ2xDQSxpQkFBTyxDQUFDamYsSUFBUixDQUFhLFVBQUNsVCxLQUFELEVBQVFveUIsTUFBUjtBQUFBLG1CQUFtQkEsTUFBTSxDQUFDLzdCLE1BQVAsQ0FBY2c4QixhQUFkLENBQTRCcnlCLEtBQUssQ0FBQzNKLE1BQWxDLENBQW5CO0FBQUEsV0FBYixFQUNLK2EsT0FETCxDQUNhLFVBQVVraEIsTUFBVixFQUFrQjtBQUN2QixnQkFBSUMsU0FBUyxHQUFHRCxNQUFNLENBQUNoaUIsS0FBdkI7O0FBQ0EsZ0JBQUlnaUIsTUFBTSxDQUFDajhCLE1BQVAsS0FBa0IsT0FBdEIsRUFBK0I7QUFDM0I7QUFDQSxrQkFBSTBLLElBQUksR0FBR2t4QixVQUFVLENBQUN0MkIsT0FBWCxDQUFtQjQyQixTQUFTLENBQUM5OUIsUUFBVixFQUFuQixFQUF5Qzg5QixTQUFTLENBQUN4dkIsUUFBVixFQUF6QyxFQUErRHd2QixTQUFTLENBQUN4dkIsUUFBekUsQ0FBWDtBQUNBa3ZCLHdCQUFVLENBQUNPLGFBQVgsQ0FBeUJ6eEIsSUFBekI7QUFDSCxhQUpELE1BSU8sSUFBSXV4QixNQUFNLENBQUNqOEIsTUFBUCxLQUFrQixTQUF0QixFQUFpQztBQUNwQztBQUNBLGtCQUFJMEssS0FBSSxHQUFHa3hCLFVBQVUsQ0FBQ2xVLGtCQUFYLENBQThCd1UsU0FBUyxDQUFDOTlCLFFBQVYsRUFBOUIsQ0FBWDs7QUFDQSxrQkFBSXc5QixVQUFVLENBQUNucUIsSUFBWCxDQUFnQmhXLEtBQWhCLENBQXNCMEMsT0FBdEIsQ0FBOEJDLFFBQTlCLE9BQTZDODlCLFNBQVMsQ0FBQzk5QixRQUFWLEVBQWpELEVBQXVFO0FBQ25FdzlCLDBCQUFVLENBQUNucUIsSUFBWCxDQUFnQmhXLEtBQWhCLENBQXNCMEMsT0FBdEIsQ0FBOEJDLFFBQTlCLENBQXVDLFdBQXZDO0FBQ0g7QUFDSjtBQUNKLFdBZEw7QUFlSCxTQWhCRCxFQWdCRyxLQWhCSCxFQWdCUyxhQWhCVCxDQUQrRDtBQUFBLE9BRm5FO0FBcUJILEtBaERMLENBa0RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7Ozs7O0FBOURKO0FBQUE7QUFBQSxpQ0FtRWlCc00sSUFuRWpCLEVBbUV1QjtBQUNmLFVBQUlBLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0JzTSxZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBSzRGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQXpDO0FBQ0gsT0FGRCxNQUVPLElBQUk4TSxJQUFJLENBQUN0TSxRQUFMLEtBQWtCLFlBQXRCLEVBQW9DO0FBQ3ZDc00sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUs0RixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJZ08sSUFBSSxDQUFDdE0sUUFBTCxLQUFrQixlQUF0QixFQUF1QztBQUMxQ3NNLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLNEYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSStOLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsYUFBdEIsRUFBcUM7QUFDeENzTSxZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBSzRGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUk4TixJQUFJLENBQUN0TSxRQUFMLEtBQWtCLGtCQUF0QixFQUEwQztBQUM3Q3NNLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLNEYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCK0IsWUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSXVPLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsbUJBQXRCLEVBQTJDO0FBQzlDc00sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUs0RixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJxQyxZQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJaU8sSUFBSSxDQUFDdE0sUUFBTCxLQUFrQixvQkFBdEIsRUFBNEM7QUFDL0MsYUFBS2crQixlQUFMLENBQXFCMXhCLElBQXJCLEVBQTJCLEtBQUsrRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSTZOLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0Isa0JBQXRCLEVBQTBDO0FBQzdDLGFBQUtnK0IsZUFBTCxDQUFxQjF4QixJQUFyQixFQUEyQixLQUFLK0csSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQXREO0FBQ0gsT0FGTSxNQUVBLElBQUk2TixJQUFJLENBQUN0TSxRQUFMLEtBQWtCLG1CQUF0QixFQUEyQztBQUM5QyxhQUFLZytCLGVBQUwsQ0FBcUIxeEIsSUFBckIsRUFBMkIsS0FBSytHLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUF0RDtBQUNILE9BRk0sTUFFQSxJQUFJNk4sSUFBSSxDQUFDdE0sUUFBTCxLQUFrQixtQkFBdEIsRUFBMkM7QUFDOUMsYUFBS2crQixlQUFMLENBQXFCMXhCLElBQXJCLEVBQTJCLEtBQUsrRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSTZOLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsZUFBdEIsRUFBdUM7QUFDMUNzTSxZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBSzRGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQmlELElBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUlxTixJQUFJLENBQUN0TSxRQUFMLEtBQWtCLDhCQUF0QixFQUFzRDtBQUN6RHNNLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLNEYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSWdOLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsNkJBQXRCLEVBQXFEO0FBQ3hEc00sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUs0RixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJrRCxpQkFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSW9OLElBQUksQ0FBQ3RNLFFBQUwsS0FBa0IsbUJBQXRCLEVBQTJDO0FBQzlDc00sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUs0RixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBOUI7QUFDSCxPQUZNLE1BRUEsSUFBSXVNLElBQUksQ0FBQ3RNLFFBQUwsQ0FBYzZOLFVBQWQsQ0FBeUIsR0FBekIsQ0FBSixFQUFtQztBQUN0QyxhQUFLbXdCLGVBQUwsQ0FBcUIxeEIsSUFBckIsRUFBMkIsS0FBSytHLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjRDLGtCQUF0RDtBQUNILE9BRk0sTUFFQSxJQUFJME4sSUFBSSxDQUFDdE0sUUFBTCxDQUFjNk4sVUFBZCxDQUF5QixHQUF6QixLQUNBdkIsSUFBSSxDQUFDdE0sUUFBTCxDQUFjNk4sVUFBZCxDQUF5QixHQUF6QixDQURBLElBRUF2QixJQUFJLENBQUN0TSxRQUFMLENBQWM2TixVQUFkLENBQXlCLEdBQXpCLENBRkosRUFFbUM7QUFDdEMsYUFBS213QixlQUFMLENBQXFCMXhCLElBQXJCLEVBQTJCLEtBQUsrRyxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUpNLE1BSUE7QUFDSCxhQUFLdS9CLGVBQUwsQ0FBcUIxeEIsSUFBckIsRUFBMkIsS0FBSytHLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQndELFVBQXREO0FBQ0g7QUFDSjtBQXpHTDtBQUFBO0FBQUEsb0NBMkdvQjZNLElBM0dwQixFQTJHMEIyeEIsS0EzRzFCLEVBMkdpQztBQUN6QjN4QixVQUFJLENBQUNzd0IsS0FBTCxHQUFhcUIsS0FBYjtBQUNBLFVBQUlDLFVBQVUsR0FBRzV4QixJQUFJLENBQUNzd0IsS0FBTCxFQUFqQjs7QUFDQSxXQUFLLElBQUlwaEIsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHMGlCLFVBQVUsQ0FBQzN4QixNQUE3QixFQUFxQ2lQLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsWUFBSTBpQixVQUFVLENBQUMxaUIsQ0FBRCxDQUFWLENBQWN4YixRQUFkLE9BQTZCc00sSUFBSSxDQUFDdE0sUUFBdEMsRUFBZ0Q7QUFDNUNzTSxjQUFJLENBQUNtQixNQUFMLEdBQWN5d0IsVUFBVSxDQUFDMWlCLENBQUQsQ0FBVixDQUFjbE4sUUFBNUI7QUFDSDtBQUNKOztBQUNELFVBQUloQyxJQUFJLENBQUNtQixNQUFMLEtBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLFlBQUl2RyxPQUFPLEdBQUdtSCxhQUFhLENBQUMvQixJQUFJLENBQUN0TSxRQUFOLENBQTNCO0FBQ0FzTSxZQUFJLENBQUNtQixNQUFMLEdBQWN2RyxPQUFPLENBQUNvSCxRQUF0QjtBQUNBMnZCLGFBQUssQ0FBQ3JsQixJQUFOLENBQVcxUixPQUFYO0FBQ0g7QUFDSjtBQXhITDtBQUFBO0FBQUEsaUNBMEhpQjtBQUNULFdBQUtBLE9BQUwsQ0FBYSxXQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLG1CQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLFlBQWI7QUFDQSxXQUFLQSxPQUFMLENBQWEsa0JBQWI7QUFDQSxXQUFLQSxPQUFMLENBQWEsOEJBQWI7QUFDSDtBQWhJTDtBQUFBO0FBQUEseUNBa0l5QjtBQUNqQixXQUFLLElBQUl4SixJQUFULElBQWlCLEtBQUt3L0IsTUFBdEIsRUFBOEI7QUFDMUIsWUFBSSxLQUFLQSxNQUFMLENBQVl6SyxjQUFaLENBQTJCLzBCLElBQTNCLENBQUosRUFBc0M7QUFDbEMsY0FBSStRLGlCQUFpQixDQUFDQyxPQUFsQixDQUEwQmhSLElBQTFCLE1BQW9DLENBQUMsQ0FBekMsRUFBNEM7QUFDeEMsbUJBQU8sS0FBS3cvQixNQUFMLENBQVl4L0IsSUFBWixDQUFQO0FBQ0EsbUJBQU8sS0FBSzIvQixRQUFMLENBQWMzL0IsSUFBZCxDQUFQO0FBQ0g7QUFDSjtBQUNKLE9BUmdCLENBU2pCOztBQUNIO0FBNUlMO0FBQUE7QUFBQSw0QkE4SVlzQyxRQTlJWixFQThJc0JzTyxRQTlJdEIsRUE4SWdDd3ZCLFNBOUloQyxFQThJMkM7QUFDbkMsVUFBSTk5QixRQUFRLElBQUksS0FBS2s5QixNQUFyQixFQUE2QjtBQUN6QjtBQUNBLFlBQUlpQixZQUFZLEdBQUcsS0FBS2pCLE1BQUwsQ0FBWWw5QixRQUFaLENBQW5COztBQUNBLFlBQUk4OUIsU0FBUyxLQUFLM2hDLFNBQWxCLEVBQTZCO0FBQ3pCLGVBQUtpaUMsWUFBTCxDQUFrQkQsWUFBbEI7QUFDSCxTQUZELE1BRU87QUFDSEEsc0JBQVksQ0FBQzF3QixNQUFiLEdBQXNCcXdCLFNBQXRCO0FBQ0g7O0FBQ0RLLG9CQUFZLENBQUMxd0IsTUFBYixDQUFvQmEsUUFBUSxJQUFJLEVBQWhDO0FBQ0EsZUFBTzZ2QixZQUFQO0FBQ0gsT0FWRCxNQVVPO0FBQ0g7QUFDQSxZQUFJajNCLE9BQU8sR0FBRyxJQUFJeTFCLFdBQUosQ0FBZ0IsS0FBS3RwQixJQUFyQixFQUEyQnJULFFBQTNCLENBQWQ7QUFDQSxhQUFLazlCLE1BQUwsQ0FBWWw5QixRQUFaLElBQXdCa0gsT0FBeEI7O0FBQ0EsWUFBSTQyQixTQUFTLEtBQUszaEMsU0FBbEIsRUFBNkI7QUFDekIsZUFBS2lpQyxZQUFMLENBQWtCbDNCLE9BQWxCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLGlCQUFPLENBQUN1RyxNQUFSLEdBQWlCcXdCLFNBQWpCO0FBQ0g7O0FBQ0QsWUFBSXh2QixRQUFRLEtBQUtuUyxTQUFqQixFQUE0QjtBQUN4QitLLGlCQUFPLENBQUN1RyxNQUFSLENBQWVhLFFBQWY7QUFDSDs7QUFDRCxlQUFPcEgsT0FBUDtBQUNIO0FBQ0o7QUF2S0w7QUFBQTtBQUFBLDhCQXlLY2xILFFBektkLEVBeUt3QnNPLFFBekt4QixFQXlLa0M7QUFDMUJBLGNBQVEsR0FBR0EsUUFBUSxJQUFJLEVBQXZCO0FBQ0EsV0FBSzR1QixNQUFMLENBQVlsOUIsUUFBWixFQUFzQnlOLE1BQXRCLENBQTZCYSxRQUE3QjtBQUNIO0FBNUtMO0FBQUE7QUFBQSw2QkE4S2F0TyxRQTlLYixFQThLdUI7QUFDZixhQUFPLEtBQUtrOUIsTUFBTCxDQUFZbDlCLFFBQVosRUFBc0J5TixNQUF0QixFQUFQO0FBQ0g7QUFoTEw7QUFBQTtBQUFBLDRCQWtMWXpOLFFBbExaLEVBa0xzQjtBQUNkLGFBQU8sS0FBS2s5QixNQUFMLENBQVlsOUIsUUFBWixDQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBdExKO0FBQUE7QUFBQSwrQkEyTGVBLFFBM0xmLEVBMkx5QjtBQUNqQixVQUFJMDhCLHNCQUFzQixDQUFDaHVCLE9BQXZCLENBQStCMU8sUUFBL0IsTUFBNkMsQ0FBQyxDQUFsRCxFQUFxRDtBQUNqRCxZQUFJc00sSUFBSSxHQUFHLEtBQUtnZCxrQkFBTCxDQUF3QnRwQixRQUF4QixDQUFYO0FBQ0FzTSxZQUFJLENBQUNtQixNQUFMLENBQVksSUFBWjtBQUNBLGVBQU8sSUFBUDtBQUNILE9BSkQsTUFJTyxJQUFJLEtBQUt5dkIsTUFBTCxDQUFZbDlCLFFBQVosRUFBc0I0OEIsS0FBdEIsS0FBZ0MsSUFBcEMsRUFBMEM7QUFDN0MsZUFBTyxLQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0g7QUFDQSxZQUFJaEksS0FBSyxHQUFHLEtBQUtzSSxNQUFMLENBQVlsOUIsUUFBWixFQUFzQjQ4QixLQUF0QixDQUE0QjNtQixNQUE1QixDQUFtQyxVQUFBNm5CLFNBQVM7QUFBQSxpQkFBSUEsU0FBUyxDQUFDOTlCLFFBQVYsT0FBeUJBLFFBQTdCO0FBQUEsU0FBNUMsQ0FBWjtBQUNBLGVBQU80MEIsS0FBSyxJQUFJLEtBQWhCO0FBQ0g7QUFDSjtBQXZNTDtBQUFBO0FBQUEsdUNBeU11QjUwQixRQXpNdkIsRUF5TWlDO0FBQ3pCLFVBQUlzTSxJQUFJLEdBQUcsS0FBSzR3QixNQUFMLENBQVlsOUIsUUFBWixDQUFYO0FBQ0EsYUFBTyxLQUFLazlCLE1BQUwsQ0FBWWw5QixRQUFaLENBQVA7O0FBQ0EsVUFBSUEsUUFBUSxJQUFJLEtBQUtxOUIsUUFBckIsRUFBK0I7QUFDM0IsYUFBS0EsUUFBTCxDQUFjcjlCLFFBQWQsRUFBd0IyYyxPQUF4QixDQUFnQyxVQUFBb00sUUFBUTtBQUFBLGlCQUFJQSxRQUFRLENBQUN6RyxPQUFULEVBQUo7QUFBQSxTQUF4QztBQUNIOztBQUNELGFBQU9oVyxJQUFQO0FBQ0g7QUFoTkw7QUFBQTtBQUFBLCtCQWtOZW1iLE1BbE5mLEVBa051QjRXLFdBbE52QixFQWtOb0M7QUFDNUIsVUFBSXp2QixpQkFBaUIsQ0FBQ0YsT0FBbEIsQ0FBMEIrWSxNQUExQixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDLGVBQU8sS0FBUDtBQUNILE9BRkQsTUFFTyxJQUFJLEtBQUt5VixNQUFMLENBQVlsOUIsUUFBWixFQUFzQjQ4QixLQUF0QixLQUFnQyxJQUFwQyxFQUEwQztBQUM3QyxlQUFPLEtBQVA7QUFDSCxPQUZNLE1BRUE7QUFDSDtBQUNBLFlBQUloSSxLQUFLLEdBQUcsS0FBS3NJLE1BQUwsQ0FBWWw5QixRQUFaLEVBQXNCNDhCLEtBQXRCLENBQTRCM21CLE1BQTVCLENBQW1DLFVBQUE2bkIsU0FBUztBQUFBLGlCQUFJQSxTQUFTLENBQUM5OUIsUUFBVixPQUF5QkEsUUFBN0I7QUFBQSxTQUE1QyxDQUFaO0FBQ0EsZUFBTzQwQixLQUFLLElBQUksS0FBaEI7QUFDSDtBQUNKO0FBNU5MO0FBQUE7QUFBQSxrQ0E4TmtCdG9CLElBOU5sQixFQThOd0I7QUFDaEIsVUFBSUEsSUFBSSxDQUFDdE0sUUFBTCxJQUFpQixLQUFLcTlCLFFBQTFCLEVBQW9DO0FBQ2hDLGFBQUtBLFFBQUwsQ0FBYy93QixJQUFJLENBQUN0TSxRQUFuQixFQUE2QjJjLE9BQTdCLENBQXFDLFVBQUFvTSxRQUFRO0FBQUEsaUJBQUlBLFFBQVEsQ0FBQzNHLE9BQVQsQ0FBaUI5VixJQUFqQixDQUFKO0FBQUEsU0FBN0M7QUFDSDtBQUNKO0FBbE9MO0FBQUE7QUFBQSxrQ0FvT2tCNU8sSUFwT2xCLEVBb093QjRnQyxhQXBPeEIsRUFvT3VDO0FBQy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQSxVQUFJNWdDLElBQUksQ0FBQ21RLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN2Qm5RLFlBQUksR0FBR0EsSUFBSSxDQUFDb1EsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUNELFVBQUl5d0IsVUFBVSxHQUFHakMsV0FBVyxDQUFDQyxVQUE3QixDQXpCK0IsQ0EwQi9COztBQUNBLFVBQUk3K0IsSUFBSSxDQUFDbVEsVUFBTCxDQUFnQnV1QixvQkFBaEIsQ0FBSixFQUEyQztBQUN2QzErQixZQUFJLEdBQUdBLElBQUksQ0FBQ29RLEtBQUwsQ0FBV3N1QixvQkFBb0IsQ0FBQzd2QixNQUFoQyxDQUFQO0FBQ0FneUIsa0JBQVUsR0FBR2pDLFdBQVcsQ0FBQ0UscUJBQXpCO0FBQ0gsT0E5QjhCLENBK0IvQjs7O0FBQ0EsVUFBSTkrQixJQUFJLENBQUNtUSxVQUFMLENBQWdCd3VCLGlCQUFoQixDQUFKLEVBQXdDO0FBQ3BDMytCLFlBQUksR0FBR0EsSUFBSSxDQUFDb1EsS0FBTCxDQUFXdXVCLGlCQUFpQixDQUFDOXZCLE1BQTdCLENBQVA7QUFDQWd5QixrQkFBVSxHQUFHakMsV0FBVyxDQUFDRyxrQkFBekI7QUFDSCxPQUhELE1BR08sSUFBSTZCLGFBQUosRUFBbUI7QUFDdEJDLGtCQUFVLEdBQUdqQyxXQUFXLENBQUNHLGtCQUF6QjtBQUNILE9BckM4QixDQXNDL0I7OztBQUNBLFVBQUkvdUIsaUJBQWlCLEdBQUcsS0FBSzJGLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQndELFVBQTNCLEVBQXhCO0FBQ0EsVUFBSWhCLG9CQUFvQixHQUFHLEtBQUs0VSxJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBM0IsRUFBM0I7QUFDQSxVQUFJRyxrQkFBa0IsR0FBRyxLQUFLeVUsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCNEMsa0JBQTNCLEVBQXpCLENBekMrQixDQTBDL0I7O0FBQ0EsVUFBSTQvQixXQUFXLEdBQUcsS0FBS0Msc0JBQUwsQ0FBNEIvZ0MsSUFBNUIsRUFBa0M2Z0MsVUFBbEMsQ0FBbEI7O0FBQ0EsVUFBSUMsV0FBVyxLQUFLcmlDLFNBQXBCLEVBQStCO0FBQzNCLGVBQU9xaUMsV0FBUDtBQUNILE9BOUM4QixDQStDL0I7OztBQUNBLFVBQUlFLGNBQWMsR0FBRyxLQUFLQyxvQkFBTCxDQUEwQmp4QixpQkFBMUIsRUFBNkNoUSxJQUE3QyxDQUFyQjtBQUNBLFVBQUlraEMsZ0JBQWdCLEdBQUcsS0FBS0Qsb0JBQUwsQ0FBMEJqeEIsaUJBQTFCLEVBQTZDLE1BQUloUSxJQUFqRCxDQUF2QjtBQUNBLFVBQUltaEMsY0FBYyxHQUFHLEtBQUtGLG9CQUFMLENBQTBCbGdDLG9CQUExQixFQUFnRCxNQUFJZixJQUFwRCxDQUFyQjtBQUNBLFVBQUlvaEMsYUFBYSxHQUFHLEtBQUtILG9CQUFMLENBQTBCbGdDLG9CQUExQixFQUFnRCxNQUFJZixJQUFwRCxDQUFwQjs7QUFDQSxVQUFJNmdDLFVBQVUsS0FBS2pDLFdBQVcsQ0FBQ0csa0JBQS9CLEVBQW1EO0FBQy9DLGVBQU9zQyxzRUFBaUIsQ0FBQ0QsYUFBRCxFQUFnQkQsY0FBaEIsRUFBZ0NILGNBQWhDLEVBQWdERSxnQkFBaEQsQ0FBeEI7QUFDSDs7QUFDRCxVQUFJSSxpQkFBaUIsR0FBRyxLQUFLTCxvQkFBTCxDQUEwQmxnQyxvQkFBMUIsRUFBZ0QsTUFBSWYsSUFBcEQsQ0FBeEI7QUFDQSxVQUFJdWhDLGVBQWUsR0FBRyxLQUFLTixvQkFBTCxDQUEwQi8vQixrQkFBMUIsRUFBOEMsTUFBSWxCLElBQWxELENBQXRCOztBQUNBLFVBQUk2Z0MsVUFBVSxLQUFLakMsV0FBVyxDQUFDRSxxQkFBL0IsRUFBc0Q7QUFDbEQsZUFBT3VDLHNFQUFpQixDQUFDQyxpQkFBRCxFQUFvQkYsYUFBcEIsRUFBbUNHLGVBQW5DLEVBQ0NKLGNBREQsRUFDaUJILGNBRGpCLEVBQ2lDRSxnQkFEakMsQ0FBeEI7QUFFSCxPQUhELE1BR08sSUFBSUwsVUFBVSxLQUFLakMsV0FBVyxDQUFDQyxVQUEvQixFQUEyQztBQUM5QyxlQUFPd0Msc0VBQWlCLENBQUNGLGNBQUQsRUFBaUJILGNBQWpCLEVBQWlDRSxnQkFBakMsRUFDQ0ksaUJBREQsRUFDb0JGLGFBRHBCLEVBQ21DRyxlQURuQyxDQUF4QjtBQUVIO0FBQ0o7QUFwU0w7QUFBQTtBQUFBLHlDQXNTeUJDLFNBdFN6QixFQXNTb0NsL0IsUUF0U3BDLEVBc1M4QztBQUN0QyxXQUFLLElBQUl3YixDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUcwakIsU0FBUyxDQUFDM3lCLE1BQTVCLEVBQW9DaVAsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQyxZQUFJMGpCLFNBQVMsQ0FBQzFqQixDQUFELENBQVQsQ0FBYXhiLFFBQWIsT0FBNEJBLFFBQWhDLEVBQTBDO0FBQ3RDLGlCQUFPay9CLFNBQVMsQ0FBQzFqQixDQUFELENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxhQUFPcmYsU0FBUDtBQUNIO0FBN1NMO0FBQUE7QUFBQSwyQ0ErUzJCNkQsUUEvUzNCLEVBK1NxQ3UrQixVQS9TckMsRUErU2lEO0FBQ3pDLFVBQUlBLFVBQVUsS0FBS2pDLFdBQVcsQ0FBQ0csa0JBQS9CLEVBQW1EO0FBQy9DLFlBQUl6OEIsUUFBUSxLQUFLLFdBQWpCLEVBQThCO0FBQzFCLGlCQUFPNjhCLGlCQUFpQixDQUFDLHVCQUFELEVBQTBCLEtBQUt4cEIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCdUQsSUFBM0IsRUFBMUIsQ0FBeEI7QUFDSDs7QUFDRCxlQUFPckQsU0FBUDtBQUNIOztBQUNELGNBQVE2RCxRQUFSO0FBQ0ksYUFBSyxXQUFMO0FBQ0ksaUJBQU82OEIsaUJBQWlCLENBQUMsdUJBQUQsRUFBMEIsS0FBS3hwQixJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixFQUExQixDQUF4Qjs7QUFDSixhQUFLLFdBQUw7QUFDSSxpQkFBT3E5QixpQkFBaUIsQ0FBQyx1QkFBRCxFQUEwQixLQUFLeHBCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNDLEtBQTNCLEVBQTFCLENBQXhCOztBQUNKLGFBQUssY0FBTDtBQUNJLGlCQUFPdStCLGlCQUFpQixDQUFDLDBCQUFELEVBQTZCLEtBQUt4cEIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBM0IsRUFBN0IsQ0FBeEI7O0FBQ0osYUFBSyxZQUFMO0FBQ0ksaUJBQU9zK0IsaUJBQWlCLENBQUMsd0JBQUQsRUFBMkIsS0FBS3hwQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ3QyxNQUEzQixFQUEzQixDQUF4Qjs7QUFDSixhQUFLLGlCQUFMO0FBQ0ksaUJBQU9xK0IsaUJBQWlCLENBQUMsNkJBQUQsRUFBZ0MsS0FBS3hwQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkIrQixZQUEzQixFQUFoQyxDQUF4Qjs7QUFDSixhQUFLLGtCQUFMO0FBQ0ksaUJBQU84K0IsaUJBQWlCLENBQUMsOEJBQUQsRUFBaUMsS0FBS3hwQixJQUFMLENBQVVoVyxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJxQyxZQUEzQixFQUFqQyxDQUF4QjtBQVpSOztBQWNBLGFBQU9sQyxTQUFQO0FBQ0g7QUFyVUw7QUFBQTtBQUFBLGtDQXVVa0JnakMsSUF2VWxCLEVBdVV3QjtBQUFBOztBQUNoQixVQUFJN2dCLElBQUksR0FBRzdZLENBQUMsQ0FBQ3cyQiwrQkFBRCxDQUFaO0FBQ0EsVUFBSWo4QixRQUFRLEdBQUdzZSxJQUFJLENBQUM1SyxJQUFMLENBQVUsMENBQVYsQ0FBZjtBQUNBLFVBQUkwckIsUUFBUSxHQUFHOWdCLElBQUksQ0FBQzVLLElBQUwsQ0FBVSwwQ0FBVixDQUFmO0FBQ0EsVUFBSTJyQixTQUFTLEdBQUcvZ0IsSUFBSSxDQUFDNUssSUFBTCxDQUFVLDJDQUFWLENBQWhCO0FBQ0EsVUFBSTRyQixjQUFjLEdBQUcsaUJBQXJCO0FBQ0F0L0IsY0FBUSxDQUFDNGYsRUFBVCxDQUFZLE9BQVosRUFBcUIsWUFBTTtBQUN2QixZQUFJdUIsU0FBUyxHQUFHbWUsY0FBYyxDQUFDQyxJQUFmLENBQW9Cdi9CLFFBQVEsQ0FBQytTLEdBQVQsRUFBcEIsRUFBb0MsQ0FBcEMsQ0FBaEI7QUFDQW9PLGlCQUFTLEdBQUdBLFNBQVMsS0FBS2hsQixTQUFkLEdBQTBCLGNBQTFCLEdBQTJDZ2xCLFNBQXZELENBRnVCLENBR3ZCOztBQUNBaWUsZ0JBQVEsQ0FBQzlyQixJQUFULENBQWM2TixTQUFkO0FBQ0gsT0FMRDs7QUFNQSxVQUFJN0IsR0FBRyxHQUFHLFNBQU5BLEdBQU0sR0FBTTtBQUNaLFlBQUlrZ0IsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsWUFBSUwsSUFBSSxLQUFLLFlBQWIsRUFBMkI7QUFDdkJLLGdCQUFNLEdBQUdILFNBQVMsQ0FBQ3RzQixHQUFWLEVBQVQ7QUFDSCxTQUZELE1BRU8sSUFBSW9zQixJQUFJLEtBQUssVUFBYixFQUF5QjtBQUM1QkssZ0JBQU0sR0FBRyxHQUFUO0FBQ0g7O0FBRUQsWUFBSXgvQixRQUFRLENBQUMrUyxHQUFULEVBQUosRUFBb0I7QUFDaEIvUyxrQkFBUSxHQUFHdy9CLE1BQU0sR0FBQ3gvQixRQUFRLENBQUMrUyxHQUFULEVBQWxCOztBQUNBLGdCQUFJLENBQUM3TCxPQUFMLENBQWFsSCxRQUFiO0FBQ0g7QUFDSixPQVpEOztBQWFBc2UsVUFBSSxDQUFDbWhCLE1BQUwsQ0FBWSxVQUFDanRCLENBQUQsRUFBTztBQUNmQSxTQUFDLENBQUNrdEIsY0FBRjtBQUNBcGdCLFdBQUc7O0FBQ0gsY0FBSSxDQUFDak0sSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCMFcsS0FBNUI7QUFDSCxPQUpEO0FBS0EsV0FBS3BNLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFyQixDQUE0QjhXLE9BQTVCLENBQW9DLGVBQXBDLEVBQXFEdkIsSUFBckQsRUFBMkRnQixHQUEzRCxFQUFnRSxZQUFJLENBQUUsQ0FBdEUsRUFBd0UsS0FBeEU7QUFDSDtBQXRXTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7QUNoU0E7QUFBQTtBQUFBO0FBQ08sSUFBSXFnQixXQUFXLGszRUFBZixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEUDtBQUVPLElBQU14WSxvQkFBb0IsMDRDQUExQjtBQThCUDs7Ozs7Ozs7O0FBUU8sSUFBTWhULGNBQWI7QUFDSSwwQkFBWWQsSUFBWixFQUFrQitGLEdBQWxCLEVBQXVCO0FBQUE7O0FBQ25CLFNBQUsvRixJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLK0YsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBS3dtQixTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBSzN2QixPQUFMLEdBQWUsRUFBZjtBQUNBLFNBQUs0dkIsVUFBTCxHQUFrQixFQUFsQjtBQUNIOztBQVBMO0FBQUE7QUFBQSx5QkFTUzV2QixPQVRULEVBU2tCO0FBQUE7O0FBQ1YsV0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsV0FBSzR2QixVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsV0FBS0MsUUFBTCxHQUFnQnI2QixDQUFDLENBQUMsMkJBQUQsQ0FBRCxDQUErQnFVLEtBQS9CLEVBQWhCO0FBQ0EsVUFBSWltQixNQUFNLEdBQUcsQ0FBYjtBQUNBOXZCLGFBQU8sQ0FDRnNULE1BREwsQ0FDWSxVQUFDeWMsS0FBRDtBQUFBLGVBQ0osQ0FBQ0EsS0FBSyxDQUFDQyxTQUFOLENBQWdCcHlCLFVBQWhCLENBQTJCLGNBQTNCLENBQUQsSUFDSW15QixLQUFLLENBQUNFLFVBQU4sS0FBcUIsU0FEekIsSUFFSUYsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLGNBRnpCLEtBR0ssQ0FBQyxLQUFJLENBQUM3c0IsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCb0QsTUFBM0IsRUFBRCxJQUF3QzRnQyxLQUFLLENBQUNFLFVBQU4sS0FBcUIsa0JBSGxFLENBREk7QUFBQSxPQURaLEVBT0t2akIsT0FQTCxDQU9hLFVBQUNxakIsS0FBRCxFQUFRL3VCLEtBQVIsRUFBa0I7QUFDdkIsWUFBSWl2QixVQUFVLEdBQUdDLGlCQUFpQixDQUFDSCxLQUFLLENBQUNFLFVBQVAsQ0FBakIsSUFBdUNGLEtBQUssQ0FBQ0UsVUFBOUQ7QUFDQSxZQUFJRSxTQUFTLEdBQUdDLG1CQUFtQixDQUFDTCxLQUFLLENBQUNNLGdCQUFQLENBQW5CLEdBQTZDLEtBQTdDLEdBQW1ESixVQUFuRTtBQUNBLFlBQUlLLE9BQU8sR0FBSVAsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLFdBQXBDO0FBQ0EsWUFBSU0sTUFBTSxHQUFHLzZCLENBQUMsQ0FBQyxtQkFBRCxFQUFzQjtBQUFDNk4sY0FBSSxFQUFFOHNCLFNBQVA7QUFBa0JLLGtCQUFRLEVBQUVGO0FBQTVCLFNBQXRCLENBQWQ7O0FBQ0EsWUFBSSxLQUFJLENBQUNHLFdBQUwsQ0FBaUJWLEtBQWpCLENBQUosRUFBNkI7QUFDekJRLGdCQUFNLENBQUN2bEIsSUFBUCxDQUFZLE9BQVosRUFBcUI4a0IsTUFBckI7O0FBQ0EsZUFBSSxDQUFDRixVQUFMLENBQWdCam5CLElBQWhCLENBQXFCb25CLEtBQXJCOztBQUNBRCxnQkFBTSxJQUFJLENBQVY7QUFDSDs7QUFDRCxhQUFJLENBQUNELFFBQUwsQ0FBYy9vQixNQUFkLENBQXFCeXBCLE1BQXJCO0FBQ0gsT0FsQkw7QUFtQkEsV0FBS1YsUUFBTCxDQUFjL3NCLEdBQWQsQ0FBa0JySCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlvMEIsTUFBTSxHQUFDLENBQW5CLENBQWxCO0FBQ0EsV0FBS0QsUUFBTCxDQUFjakMsTUFBZCxDQUFxQixVQUFDOEMsR0FBRCxFQUFTO0FBQzFCLGFBQUksQ0FBQy93QixZQUFMO0FBQ0gsT0FGRDtBQUdIO0FBckNMO0FBQUE7QUFBQSxrQ0F1Q2tCO0FBQ1YsV0FBS2t3QixRQUFMLENBQWMvc0IsR0FBZCxDQUFrQixDQUFsQjtBQUNBLFdBQUtuRCxZQUFMO0FBQ0g7QUExQ0w7QUFBQTtBQUFBLG1DQTRDbUI7QUFDWCxVQUFJZ3dCLFNBQVMsR0FBRzFPLFFBQVEsQ0FBQyxLQUFLNE8sUUFBTCxDQUFjL3NCLEdBQWQsRUFBRCxFQUFzQixFQUF0QixDQUF4QjtBQUNBLFdBQUsrc0IsUUFBTCxDQUFjL3NCLEdBQWQsQ0FBa0JySCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlpMEIsU0FBUyxHQUFDLENBQXRCLENBQWxCO0FBQ0EsV0FBS2h3QixZQUFMO0FBQ0g7QUFoREw7QUFBQTtBQUFBLCtCQWtEZTtBQUNQLFVBQUlnd0IsU0FBUyxHQUFHMU8sUUFBUSxDQUFDLEtBQUs0TyxRQUFMLENBQWMvc0IsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsV0FBSytzQixRQUFMLENBQWMvc0IsR0FBZCxDQUFrQnJILElBQUksQ0FBQ0ksR0FBTCxDQUFTLEtBQUsrekIsVUFBTCxDQUFnQnR6QixNQUFoQixHQUF1QixDQUFoQyxFQUFtQ3F6QixTQUFTLEdBQUMsQ0FBN0MsQ0FBbEI7QUFDQSxXQUFLaHdCLFlBQUw7QUFDSDtBQXRETDtBQUFBO0FBQUEsdUNBd0R1QjtBQUNmLFdBQUtrd0IsUUFBTCxDQUFjL3NCLEdBQWQsQ0FBa0IsS0FBSzhzQixVQUFMLENBQWdCdHpCLE1BQWhCLEdBQXVCLENBQXpDO0FBQ0EsV0FBS3FELFlBQUw7QUFDSDtBQTNETDtBQUFBO0FBQUEsbUNBNkRtQjtBQUNYLFVBQUksS0FBS2l3QixVQUFMLENBQWdCdHpCLE1BQXBCLEVBQTRCO0FBQ3hCLFlBQUlxekIsU0FBUyxHQUFHMU8sUUFBUSxDQUFDLEtBQUs0TyxRQUFMLENBQWMvc0IsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsYUFBS00sSUFBTCxDQUFVek4sVUFBVixDQUFxQmtDLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQ3doQixPQUFyQyxDQUE2QyxLQUFLc1csVUFBTCxDQUFnQkQsU0FBaEIsRUFBMkJqN0IsT0FBeEU7QUFDSDtBQUNKO0FBbEVMO0FBQUE7QUFBQSwwQkFvRVU7QUFDRixVQUFJLEtBQUtrN0IsVUFBTCxDQUFnQnR6QixNQUFwQixFQUE0QjtBQUN4QixZQUFJcXpCLFNBQVMsR0FBRzFPLFFBQVEsQ0FBQyxLQUFLNE8sUUFBTCxDQUFjL3NCLEdBQWQsRUFBRCxFQUFzQixFQUF0QixDQUF4QjtBQUNBLFlBQUl2VCxJQUFJLEdBQUcsS0FBS3FnQyxVQUFMLENBQWdCRCxTQUFoQixFQUEyQmo3QixPQUF0QztBQUNBLGFBQUswTyxJQUFMLENBQVVoVyxLQUFWLENBQWdCOEssRUFBaEIsQ0FBbUI0RixPQUFuQixDQUEyQm1CLE1BQTNCLENBQWtDUyxrQkFBbEM7QUFDQSxhQUFLMEQsSUFBTCxDQUFVek4sVUFBVixDQUFxQmtDLFlBQXJCLENBQWtDd0UsSUFBbEMsQ0FBdUNtQixNQUF2QyxDQUE4Q2pPLElBQTlDO0FBQ0g7QUFDSjtBQTNFTDtBQUFBO0FBQUEsZ0NBNkVnQndnQyxLQTdFaEIsRUE2RXVCO0FBQ2YsYUFBUSxDQUFDQSxLQUFLLENBQUNFLFVBQU4sS0FBcUIsV0FBckIsSUFDQUYsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLGFBRHRCLEtBRUEsS0FBSzdzQixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JDLFFBQXhCLE9BQXVDZ2dDLEtBQUssQ0FBQ0MsU0FGckQ7QUFHSDtBQWpGTDs7QUFBQTtBQUFBO0FBcUZBLElBQU1FLGlCQUFpQixHQUFHO0FBQ3RCLG1CQUFpQixlQURLO0FBRXRCLGlCQUFlLG9CQUZPO0FBR3RCLGVBQWEsYUFIUztBQUl0QixpQkFBZSxvQkFKTztBQUt0QixpQkFBZSxhQUxPO0FBTXRCLG1CQUFpQixjQU5LO0FBT3RCLHNCQUFvQjtBQVBFLENBQTFCO0FBVUEsSUFBTVMsVUFBVSxHQUFHLENBQ2YsS0FEZSxFQUNSLEtBRFEsRUFDRCxLQURDLEVBRWYsS0FGZSxFQUVSLEtBRlEsRUFFRCxNQUZDLEVBRU8sTUFGUCxFQUdmLEtBSGUsRUFHUixNQUhRLEVBR0EsS0FIQSxFQUlmLEtBSmUsRUFJUixLQUpRLENBQW5CO0FBTUEsSUFBTUMsUUFBUSxHQUFHLENBQ2IsS0FEYSxFQUNOLEtBRE0sRUFDQyxLQURELEVBRWIsS0FGYSxFQUVOLEtBRk0sRUFFQyxLQUZELEVBR2IsS0FIYSxDQUFqQjs7QUFNQSxTQUFTQyxTQUFULENBQW1CdjFCLEtBQW5CLEVBQTBCb3lCLE1BQTFCLEVBQWtDO0FBQzlCLFNBQU9weUIsS0FBSyxDQUFDdzFCLE9BQU4sT0FBb0JwRCxNQUFNLENBQUNvRCxPQUFQLEVBQXBCLElBQ0h4MUIsS0FBSyxDQUFDeTFCLFFBQU4sT0FBcUJyRCxNQUFNLENBQUNxRCxRQUFQLEVBRGxCLElBRUh6MUIsS0FBSyxDQUFDMDFCLFdBQU4sT0FBd0J0RCxNQUFNLENBQUNzRCxXQUFQLEVBRjVCO0FBR0g7QUFFRDs7Ozs7Ozs7QUFNQSxTQUFTWixtQkFBVCxDQUE2QmEsVUFBN0IsRUFBeUM7QUFDckM7Ozs7OztBQU1BO0FBQ0EsTUFBSUEsVUFBVSxLQUFLL2tDLFNBQW5CLEVBQThCO0FBQzFCLFdBQU8sZ0JBQVA7QUFDSDs7QUFDRCxNQUFJZ2xDLEdBQUcsR0FBRyxJQUFJQyxJQUFKLEVBQVY7QUFDQSxNQUFJQyxJQUFJLEdBQUcsSUFBSUQsSUFBSixDQUFTbFEsUUFBUSxDQUFDZ1EsVUFBRCxFQUFhLEVBQWIsQ0FBakIsQ0FBWDs7QUFDQSxNQUFJSixTQUFTLENBQUNLLEdBQUQsRUFBTUUsSUFBTixDQUFiLEVBQTBCO0FBQ3RCLFdBQU8sY0FBWUEsSUFBSSxDQUFDQyxrQkFBTCxFQUFuQjtBQUNILEdBRkQsTUFFTztBQUNILFFBQUlDLE1BQU0sR0FBR1YsUUFBUSxDQUFDUSxJQUFJLENBQUNHLE1BQUwsRUFBRCxDQUFyQjtBQUNBLFFBQUlDLFFBQVEsR0FBR2IsVUFBVSxDQUFDUyxJQUFJLENBQUNMLFFBQUwsRUFBRCxDQUF6QjtBQUNBLFFBQUlVLElBQUksR0FBR0gsTUFBTSxHQUFHLElBQVQsR0FBZ0JFLFFBQWhCLEdBQTJCLEdBQTNCLEdBQWlDSixJQUFJLENBQUNOLE9BQUwsRUFBNUM7O0FBQ0EsUUFBSUksR0FBRyxDQUFDRixXQUFKLE9BQXNCSSxJQUFJLENBQUNKLFdBQUwsRUFBMUIsRUFBOEM7QUFDMUMsYUFBT1MsSUFBSSxHQUFHLE1BQVAsR0FBY0wsSUFBSSxDQUFDQyxrQkFBTCxFQUFyQjtBQUNILEtBRkQsTUFFTztBQUNILGFBQU9JLElBQUksR0FBRyxJQUFQLEdBQVlMLElBQUksQ0FBQ0osV0FBTCxFQUFaLEdBQWlDLE1BQWpDLEdBQXdDSSxJQUFJLENBQUNDLGtCQUFMLEVBQS9DO0FBQ0g7QUFDSjtBQUNKO0FBR0Q7Ozs7Ozs7QUFLQW50QixjQUFjLENBQUNYLFNBQWYsQ0FBeUJ2RSxVQUF6QixHQUFzQyxZQUFXO0FBQzdDLE1BQUlsRyxNQUFNLEdBQUcsS0FBS3NLLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFsQztBQUNBLE1BQUl1VixJQUFJLEdBQUcsa0JBQVg7QUFDQSxPQUFLakwsSUFBTCxDQUFVek4sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI4N0IsVUFBNUIsQ0FBdUMsVUFBVXA3QixJQUFWLEVBQWdCO0FBQ25EK1gsUUFBSSxHQUFHL1gsSUFBSSxDQUFDcTdCLE9BQUwsR0FBZUMsTUFBZixDQUFzQixVQUFVQyxRQUFWLEVBQW9CQyxJQUFwQixFQUEwQjtBQUNuRCxVQUFJQyxZQUFZLEdBQUczQixtQkFBbUIsQ0FBQzBCLElBQUksQ0FBQ0UsSUFBTixDQUF0QztBQUNBLFVBQUlDLFFBQVEsR0FBRyxRQUFNRixZQUFOLEdBQW1CLGVBQW5CLEdBQW1DRCxJQUFJLENBQUN2aUMsSUFBeEMsR0FBNkMsUUFBNUQ7QUFDQSxhQUFPc2lDLFFBQVEsR0FBQyxJQUFULEdBQWNJLFFBQXJCO0FBQ0gsS0FKTSxFQUlKLEVBSkksQ0FBUDtBQUtBbjVCLFVBQU0sQ0FBQ3FMLElBQVAsQ0FBWSxjQUFaLEVBQTRCa0ssSUFBNUIsRUFBa0MsWUFBVyxDQUFFLENBQS9DO0FBQ0gsR0FQRDtBQVFILENBWEQsQzs7Ozs7Ozs7Ozs7OztBQ2hNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJTyxJQUFJMWQsMkJBQTJCLEdBQUc7QUFDckNDLFVBQVEsRUFBRSxVQUQyQjtBQUVyQ3lKLE9BQUssRUFBRSxPQUY4QjtBQUdyQ0ssTUFBSSxFQUFFO0FBSCtCLENBQWxDO0FBTVA7Ozs7OztBQUtPLFNBQVNxSSwrQkFBVCxDQUF5QzlLLElBQXpDLEVBQStDN0ssS0FBL0MsRUFBc0Q7QUFDekQ7QUFDQSxNQUFJOGtDLGdCQUFnQixHQUFHLElBQXZCO0FBQ0E5a0MsT0FBSyxDQUFDOEssRUFBTixDQUFTcEssWUFBVCxDQUFzQndLLE9BQXRCLENBQThCK0wsU0FBOUIsQ0FBd0MsWUFBTTtBQUMxQyxRQUFJNnRCLGdCQUFnQixLQUFLLElBQXpCLEVBQStCO0FBQzNCbk4sa0JBQVksQ0FBQ21OLGdCQUFELENBQVo7QUFDSDs7QUFDREEsb0JBQWdCLEdBQUdsYyxVQUFVLENBQUMsWUFBTTtBQUNoQzVvQixXQUFLLENBQUN0QixhQUFOLENBQW9CcUosU0FBcEIsQ0FBOEJzTyxJQUE5QixDQUFtQyxnQ0FBbkMsRUFBcUV2RixHQUFyRSxDQUEwRSxVQUFDcU4sQ0FBRCxFQUFJc2UsS0FBSixFQUFjO0FBQ3BGdlksY0FBTSxDQUFDd1ksSUFBUCxDQUFZQyxjQUFaLENBQTJCRixLQUEzQjtBQUNILE9BRkQ7QUFHSCxLQUo0QixFQUkxQixHQUowQixDQUE3QjtBQUtILEdBVEQsRUFIeUQsQ0FhekQ7O0FBQ0F6OEIsT0FBSyxDQUFDMEMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QmtULFNBQXpCLENBQW1DLFVBQUM4dEIsWUFBRCxFQUFrQjtBQUNqRGw2QixRQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnRELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQzYvQixZQUFZLENBQUMxZ0MsUUFBYixFQURoQyxFQUN5RCxFQUR6RDs7QUFFQSxRQUFJMGdDLFlBQUosRUFBa0I7QUFDZDtBQUNBL2tDLFdBQUssQ0FBQ3RCLGFBQU4sQ0FBb0JxSixTQUFwQixDQUE4QjhNLE1BQTlCLEdBQXVDLENBQXZDLEVBQTBDbXdCLGlCQUExQyxZQUFvRSxVQUFBaEgsR0FBRyxFQUFJO0FBQ3ZFLFlBQUkxMkIsT0FBTywwREFBbUQwMkIsR0FBRyxDQUFDMTJCLE9BQXZELGVBQW1FMDJCLEdBQUcsQ0FBQzM5QixJQUF2RSxNQUFYO0FBQ0F3SyxZQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnRELFFBQXZCLENBQWdDLDRCQUFoQyxFQUE4RCxFQUE5RCxFQUFrRSxFQUFsRSxFQUNnQ29DLE9BRGhDLEVBQzBDLEVBRDFDO0FBRUFnRixhQUFLLENBQUNoRixPQUFELENBQUw7QUFDSCxPQUxELEVBS0dxcUIsSUFMSCxDQUtRLFlBQU07QUFDVjltQixZQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnRELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQyxFQURoQyxFQUNvQyxFQURwQztBQUVBbEYsYUFBSyxDQUFDMEMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixJQUF6QjtBQUNBL0QsYUFBSyxDQUFDdEIsYUFBTixDQUFvQnFKLFNBQXBCLENBQThCcTFCLEdBQTlCLENBQWtDLFlBQWxDLEVBQWdELE1BQWhEO0FBQ0gsT0FWRDtBQVdILEtBYkQsTUFhTztBQUNINWpCLGNBQVEsQ0FBQ3lyQixjQUFULEdBQTBCdFQsSUFBMUIsQ0FBK0IsWUFBTTtBQUNqQzltQixZQUFJLENBQUN0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnRELFFBQXZCLENBQWdDLDJCQUFoQyxFQUE2RCxFQUE3RCxFQUFpRSxFQUFqRSxFQUNnQzYvQixZQUFZLENBQUMxZ0MsUUFBYixFQURoQyxFQUN5RCxFQUR6RDtBQUVBckUsYUFBSyxDQUFDMEMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixLQUF6QjtBQUNILE9BSkQ7QUFLSDtBQUNKLEdBdkJEO0FBd0JILEMsQ0FFRDs7QUFFTyxTQUFTb0UsYUFBVCxDQUF1QjZOLElBQXZCLEVBQTZCO0FBQ2hDLCtGQUlFMkwscURBSkYsMHNJQW1HTW5LLHVEQW5HTixxSEF1R00rakIseURBdkdOLG9JQTRHTTJKLG1EQTVHTiw4TEFxSE12RyxtREFySE4sa0hBMkhNN08sdURBM0hOLGtHQWdJTXdTLHFEQWhJTjtBQXFJSCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25ORDtBQUNBO0FBRUE7Ozs7O0FBSU8sSUFBSTc5QixXQUFXLEdBQUc7QUFDckJDLE9BQUssRUFBRSxPQURjO0FBRXJCa0osUUFBTSxFQUFFLFFBRmE7QUFHckJ1M0IsVUFBUSxFQUFFLFVBSFc7QUFJckIzWCxRQUFNLEVBQUUsUUFKYTtBQUtyQjRYLFNBQU8sRUFBRTtBQUxZLENBQWxCO0FBUVA7Ozs7Ozs7OztBQVFPLFNBQVN4dUIsYUFBVCxDQUF1QlosSUFBdkIsRUFBNkI7QUFDaEMsT0FBS0EsSUFBTCxHQUFZQSxJQUFaLENBRGdDLENBR2hDOztBQUNBLE9BQUtoTyxJQUFMLEdBQVlnTyxJQUFJLENBQUNoVyxLQUFMLENBQVd0QixhQUFYLENBQXlCc0osSUFBckMsQ0FKZ0MsQ0FNaEM7O0FBQ0EsT0FBS3E5QixPQUFMLEdBQWUsSUFBSXRsQyw0REFBSixDQUF3QixTQUF4QixDQUFmLENBUGdDLENBU2hDOztBQUNBLE9BQUt1bEMsS0FBTCxHQUFhO0FBQ1QsZ0JBQVkvMUIsSUFBSSxDQUFDOEYsS0FBTCxDQUFXLEtBQUtnd0IsT0FBTCxDQUFhRSxVQUFiLENBQXdCLFVBQXhCLEVBQW9DLElBQXBDLENBQVgsQ0FESDtBQUVULHdCQUFvQmgyQixJQUFJLENBQUM4RixLQUFMLENBQVcsS0FBS2d3QixPQUFMLENBQWFFLFVBQWIsQ0FBd0Isa0JBQXhCLEVBQTRDLElBQTVDLENBQVg7QUFGWCxHQUFiO0FBSUEsT0FBS0MsY0FBTCxHQUFzQjtBQUNsQixnQkFBWSxHQURNO0FBRWxCLHdCQUFvQjtBQUZGLEdBQXRCO0FBS0EsT0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLE9BQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFFQSxPQUFLQyxNQUFMLEdBQWMsRUFBZDtBQUVBLE9BQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS0MsZ0JBQUwsR0FBd0IsQ0FBeEI7QUFFQSxPQUFLQyxlQUFMLEdBQXVCLEVBQXZCO0FBQ0EsT0FBS0MsbUJBQUw7QUFDQSxPQUFLQyxXQUFMO0FBRUEsT0FBSzd1QixXQUFMLEdBQW1CLElBQW5CO0FBQ0g7QUFFRDs7Ozs7QUFJQVAsYUFBYSxDQUFDVCxTQUFkLENBQXdCOHZCLE9BQXhCLEdBQWtDLFVBQVV2ekIsUUFBVixFQUFvQjtBQUNsRCxNQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEIsUUFBSSxLQUFLMHlCLE9BQUwsQ0FBYXhsQyxHQUFiLENBQWlCLElBQWpCLENBQUosRUFBNEI7QUFDeEIsVUFBSXFtQyxLQUFLLEdBQUcsS0FBS2IsT0FBTCxDQUFhdmxDLEdBQWIsQ0FBaUIsSUFBakIsQ0FBWjs7QUFDQSxVQUFJb21DLEtBQUssS0FBS3h6QixRQUFRLENBQUN5ekIsRUFBdkIsRUFBMkI7QUFDdkIsWUFBSTcrQixPQUFPLEdBQUdpSSxJQUFJLENBQUNDLFNBQUwsQ0FBZTtBQUN6QixpQkFBTzAyQixLQURrQjtBQUV6QixpQkFBT3h6QixRQUFRLENBQUN5ekI7QUFGUyxTQUFmLENBQWQ7O0FBSUEsWUFBSSxLQUFLaHZCLFdBQVQsRUFBc0I7QUFDbEIsZUFBS0EsV0FBTCxDQUFpQixhQUFqQixFQUFnQ3JZLFNBQWhDLEVBQTJDQSxTQUEzQyxFQUFzRHdJLE9BQXREO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZUFBS3BDLFFBQUwsQ0FBYyxhQUFkLEVBQTZCcEcsU0FBN0IsRUFBd0NBLFNBQXhDLEVBQW1Ed0ksT0FBbkQ7QUFDSDs7QUFDRCxhQUFLKzlCLE9BQUwsQ0FBYWUsR0FBYixDQUFpQixJQUFqQixFQUF1QjF6QixRQUFRLENBQUN5ekIsRUFBaEM7QUFDSDtBQUNKLEtBZEQsTUFjTztBQUNILFdBQUtkLE9BQUwsQ0FBYWUsR0FBYixDQUFpQixJQUFqQixFQUF1QjF6QixRQUFRLENBQUN5ekIsRUFBaEM7QUFDSDtBQUNKO0FBQ0osQ0FwQkQ7QUFzQkE7Ozs7OztBQUlBdnZCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QjZ2QixXQUF4QixHQUFzQyxZQUFZO0FBQUE7O0FBQzlDLE1BQUksS0FBS1gsT0FBTCxDQUFheGxDLEdBQWIsQ0FBaUIsZ0JBQWpCLENBQUosRUFBd0M7QUFDcEMsUUFBSXFKLElBQUksR0FBR3FHLElBQUksQ0FBQzhGLEtBQUwsQ0FBVyxLQUFLZ3dCLE9BQUwsQ0FBYXZsQyxHQUFiLENBQWlCLGdCQUFqQixDQUFYLENBQVg7O0FBQ0EsU0FBS3VtQyxnQkFBTCxDQUFzQm45QixJQUF0QixFQUE0QixZQUE1QixFQUNzQixnQkFEdEIsRUFDd0MsS0FBS3U4QixXQUQ3QztBQUVIOztBQUNELE9BQUtLLGVBQUwsQ0FBcUJ4bUIsT0FBckIsQ0FBNkIsVUFBQzNjLFFBQUQsRUFBYztBQUN2QyxRQUFJLEtBQUksQ0FBQzBpQyxPQUFMLENBQWF4bEMsR0FBYixDQUFpQixhQUFhOEMsUUFBOUIsQ0FBSixFQUE2QztBQUN6QyxVQUFJdUcsS0FBSSxHQUFHcUcsSUFBSSxDQUFDOEYsS0FBTCxDQUFXLEtBQUksQ0FBQ2d3QixPQUFMLENBQWF2bEMsR0FBYixDQUFpQixhQUFhNkMsUUFBOUIsQ0FBWCxDQUFYOztBQUNBLFdBQUksQ0FBQzBqQyxnQkFBTCxDQUFzQm45QixLQUF0QixFQUE0QnZHLFFBQTVCLEVBQXNDLFVBQXRDLEVBQWtELEtBQUksQ0FBQzhpQyxXQUF2RDtBQUNIO0FBQ0osR0FMRDtBQU1BLE1BQUlqOUIsTUFBTSxHQUFHLElBQWI7QUFDQTBZLFFBQU0sQ0FBQ0MsSUFBUCxDQUFZLEtBQUtta0IsS0FBakIsRUFBd0JobUIsT0FBeEIsQ0FBZ0MsVUFBVWpkLFFBQVYsRUFBb0I7QUFDaEQsS0FBQyxTQUFTaWtDLGFBQVQsQ0FBdUI1ekIsUUFBdkIsRUFBaUM7QUFDOUIsVUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLFlBQUluSyxNQUFNLENBQUM4OEIsS0FBUCxDQUFhampDLFFBQWIsRUFBdUI2TSxNQUEzQixFQUFtQztBQUMvQixjQUFJaEcsSUFBSSxHQUFHcUcsSUFBSSxDQUFDOEYsS0FBTCxDQUFXN00sTUFBTSxDQUFDODhCLEtBQVAsQ0FBYWpqQyxRQUFiLEVBQXVCeXpCLEdBQXZCLEVBQVgsQ0FBWDtBQUNBLGNBQUluMUIsR0FBRyxHQUFHNkgsTUFBTSxDQUFDUixJQUFQLENBQVkzRixRQUFaLENBQVY7O0FBQ0FtRyxnQkFBTSxDQUFDKzlCLFVBQVAsQ0FBa0JyOUIsSUFBbEIsRUFBd0I3RyxRQUF4QixFQUFrQyxJQUFsQyxFQUF3Q2lrQyxhQUF4QztBQUNIO0FBQ0o7QUFDSixLQVJELEVBUUc7QUFBQyxpQkFBVztBQUFaLEtBUkg7QUFTSCxHQVZEO0FBV0gsQ0F4QkQ7O0FBMEJBMXZCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnF3QixzQkFBeEIsR0FBaUQsVUFBVXhtQyxLQUFWLEVBQWlCMkMsUUFBakIsRUFBMkI7QUFBQTs7QUFDeEUzQyxPQUFLLENBQUNpWCxTQUFOLENBQWdCLFVBQUNoRyxRQUFEO0FBQUEsV0FDWixNQUFJLENBQUMrRSxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0JRLFFBQXhCLEtBQXFDLE1BQUksQ0FBQ29DLFFBQUwsQ0FBYzNDLFFBQWQsRUFBd0JzTyxRQUF4QixDQUFyQyxHQUF5RSxLQUQ3RDtBQUFBLEdBQWhCLEVBQ29GLElBRHBGO0FBRUEsT0FBSzYwQixlQUFMLENBQXFCdnFCLElBQXJCLENBQTBCNVksUUFBMUI7QUFDSCxDQUpEO0FBTUE7Ozs7O0FBR0FpVSxhQUFhLENBQUNULFNBQWQsQ0FBd0I0dkIsbUJBQXhCLEdBQThDLFlBQVk7QUFDdEQsTUFBSS9sQyxLQUFLLEdBQUcsS0FBS2dXLElBQUwsQ0FBVWhXLEtBQXRCO0FBQ0EsT0FBS3dtQyxzQkFBTCxDQUE0QnhtQyxLQUFLLENBQUNwQixVQUFOLENBQWlCdUQsSUFBN0MsRUFBbUQsV0FBbkQ7QUFDQSxPQUFLcWtDLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzQyxLQUE3QyxFQUFvRCxZQUFwRDtBQUNBLE9BQUt1bEMsc0JBQUwsQ0FBNEJ4bUMsS0FBSyxDQUFDckIsVUFBTixDQUFpQndDLE1BQTdDLEVBQXFELGFBQXJEO0FBQ0EsT0FBS3FsQyxzQkFBTCxDQUE0QnhtQyxLQUFLLENBQUNyQixVQUFOLENBQWlCdUMsUUFBN0MsRUFBdUQsZUFBdkQ7QUFDQSxPQUFLc2xDLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUIrQixZQUE3QyxFQUEyRCxrQkFBM0Q7QUFDQSxPQUFLOGxDLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJxQyxZQUE3QyxFQUEyRCxtQkFBM0Q7QUFDQSxPQUFLd2xDLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQzhLLEVBQU4sQ0FBUzZELEtBQVQsQ0FBZTBCLGlCQUEzQyxFQUE4RCw4QkFBOUQ7QUFDQSxPQUFLbTJCLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQzhLLEVBQU4sQ0FBUzZELEtBQVQsQ0FBZXBOLGtCQUEzQyxFQUErRCwrQkFBL0Q7QUFDQSxPQUFLaWxDLHNCQUFMLENBQTRCeG1DLEtBQUssQ0FBQzhLLEVBQU4sQ0FBUzZELEtBQVQsQ0FBZXZOLG9CQUEzQyxFQUFpRSxpQ0FBakU7QUFDSCxDQVhEOztBQWFBd1YsYUFBYSxDQUFDVCxTQUFkLENBQXdCc3dCLGVBQXhCLEdBQTBDLFlBQVc7QUFBQTs7QUFDakR2aUIsUUFBTSxDQUFDd2lCLE1BQVAsR0FBZ0IsWUFBTTtBQUNsQixVQUFJLENBQUN4aEMsUUFBTCxDQUFjLGFBQWQsRUFBNkJwRyxTQUE3QixFQUF3Q0EsU0FBeEMsRUFBbURBLFNBQW5EO0FBQ0gsR0FGRDs7QUFHQW9sQixRQUFNLENBQUN5aUIsT0FBUCxHQUFpQixZQUFNO0FBQ25CLFVBQUksQ0FBQ3poQyxRQUFMLENBQWMsZUFBZCxFQUErQnBHLFNBQS9CLEVBQTBDQSxTQUExQyxFQUFxREEsU0FBckQ7QUFDSCxHQUZELENBSmlELENBUWpEOztBQUNILENBVEQ7QUFXQTs7Ozs7Ozs7Ozs7QUFTQThYLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QmdLLHFCQUF4QixHQUFnRCxZQUFZLENBQ3hEO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7QUFJQXZKLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3Qnl3QixnQkFBeEIsR0FBMkMsWUFBWTtBQUNuRCxNQUFJam9DLFVBQVUsR0FBRyxLQUFLcVgsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnJCLFVBQWpDO0FBQ0EsTUFBSXNCLElBQUksR0FBRyxLQUFLK1YsSUFBTCxDQUFVaFcsS0FBVixDQUFnQkMsSUFBM0I7QUFDQSxNQUFJckIsVUFBVSxHQUFHLEtBQUtvWCxJQUFMLENBQVVoVyxLQUFWLENBQWdCcEIsVUFBakM7QUFDQSxNQUFJOEQsT0FBTyxHQUFHLEtBQUtzVCxJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBOUI7QUFDQSxNQUFJb2hDLEdBQUcsR0FBRyxJQUFJQyxJQUFKLEVBQVY7QUFDQSxNQUFJOEMsWUFBWSxHQUFHL0MsR0FBRyxDQUFDZ0QsT0FBSixFQUFuQjtBQUNBLFNBQU87QUFDSCxxQkFBaUJub0MsVUFBVSxDQUFDdUIsRUFBWCxFQURkO0FBRUgsMkJBQXVCRCxJQUFJLENBQUNRLE9BQUwsRUFGcEI7QUFHSCxpQkFBYVIsSUFBSSxDQUFDTyxRQUFMLEVBSFY7QUFJSCxxQkFBaUI1QixVQUFVLENBQUNzQixFQUFYLEVBSmQ7QUFLSCxlQUFXRCxJQUFJLENBQUNDLEVBQUwsRUFMUjtBQU1ILGVBQVd2QixVQUFVLENBQUNnRCxPQUFYLEVBTlI7QUFPSCxpQkFBYWtsQyxZQVBWO0FBUUgsZ0JBQVkvQyxHQUFHLENBQUNpRCxpQkFBSixFQVJUO0FBU0gsZ0JBQVlya0MsT0FBTyxDQUFDc0IsUUFBUjtBQVRULEdBQVA7QUFXSCxDQWxCRDtBQW9CQTs7Ozs7Ozs7QUFNQTRTLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnZMLFNBQXhCLEdBQW9DLFVBQVV2SSxRQUFWLEVBQW9Ca0MsTUFBcEIsRUFBNEIrQyxPQUE1QixFQUFxQztBQUNyRSxPQUFLME8sSUFBTCxDQUFVaFcsS0FBVixDQUFnQnVFLE1BQWhCLENBQXVCbEMsUUFBdkIsRUFBaUNrQyxNQUFqQztBQUNBLE9BQUt5UixJQUFMLENBQVVoVyxLQUFWLENBQWdCdUUsTUFBaEIsQ0FBdUJsQyxRQUFRLEdBQUcsU0FBbEMsRUFBNkNpRixPQUFPLElBQUksRUFBeEQ7QUFDSCxDQUhEO0FBS0E7Ozs7OztBQUlBc1AsYUFBYSxDQUFDVCxTQUFkLENBQXdCNndCLFdBQXhCLEdBQXNDLFVBQVVDLE9BQVYsRUFBbUI7QUFDckQsT0FBS3BCLGdCQUFMLElBQXlCLENBQXpCOztBQUNBLE1BQUksQ0FBQ3JzQixRQUFRLENBQUMwdEIsc0JBQVQsQ0FBZ0MsaUJBQWhDLEVBQW1EaDRCLE1BQXhELEVBQWdFO0FBQzVELFNBQUswMkIsT0FBTCxHQUFleDlCLENBQUMsQ0FBQyxzQ0FBRCxDQUFoQjtBQUNBLFNBQUt3OUIsT0FBTCxDQUFhbGtCLFFBQWIsQ0FBc0JsSSxRQUFRLENBQUN5SCxJQUEvQjtBQUNIOztBQUNELFVBQVFnbUIsT0FBUjtBQUNJLFNBQUssQ0FBTDtBQUNJLFdBQUtyQixPQUFMLENBQWF4SSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUt3SSxPQUFMLENBQWF4SSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUt3SSxPQUFMLENBQWF4SSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKO0FBQ0ksV0FBS3dJLE9BQUwsQ0FBYXhJLEdBQWIsQ0FBaUIsa0JBQWpCLEVBQXFDLE9BQXJDO0FBQ0E7QUFaUjtBQWNILENBcEJEO0FBc0JBOzs7OztBQUdBeG1CLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3Qmd4QixXQUF4QixHQUFzQyxZQUFZO0FBQzlDLE9BQUt0QixnQkFBTCxJQUF5QixDQUF6Qjs7QUFDQSxNQUFJLEtBQUtBLGdCQUFMLElBQXlCLENBQTdCLEVBQWdDO0FBQzVCLFNBQUtELE9BQUwsQ0FBYWh0QixNQUFiO0FBQ0g7QUFDSixDQUxEOztBQU9BaEMsYUFBYSxDQUFDVCxTQUFkLENBQXdCaXhCLFlBQXhCLEdBQXVDLFVBQVVDLEtBQVYsRUFBaUJuK0IsSUFBakIsRUFBdUI7QUFDMUQ7QUFDQSxNQUFJZ0csTUFBTSxHQUFHLEtBQUtvMkIsS0FBTCxDQUFXK0IsS0FBWCxFQUFrQm40QixNQUEvQjtBQUNBLE1BQUlaLEdBQUcsR0FBRyxLQUFLazNCLGNBQUwsQ0FBb0I2QixLQUFwQixDQUFWOztBQUNBLE1BQUluNEIsTUFBTSxHQUFHWixHQUFiLEVBQWtCO0FBQ2QsU0FBS2czQixLQUFMLENBQVcrQixLQUFYLElBQW9CLEtBQUsvQixLQUFMLENBQVcrQixLQUFYLEVBQWtCNTJCLEtBQWxCLENBQXdCdkIsTUFBTSxHQUFHWixHQUFqQyxFQUFzQ0EsR0FBdEMsQ0FBcEI7QUFDSCxHQU55RCxDQU8xRDs7O0FBQ0EsTUFBSTdPLEdBQUcsR0FBRzhQLElBQUksQ0FBQ0MsU0FBTCxDQUFldEcsSUFBZixDQUFWO0FBQ0EsTUFBSTBLLEtBQUssR0FBRyxLQUFLMHhCLEtBQUwsQ0FBVytCLEtBQVgsRUFBa0JoMkIsT0FBbEIsQ0FBMEI1UixHQUExQixDQUFaOztBQUNBLE1BQUltVSxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2QsU0FBSzB4QixLQUFMLENBQVcrQixLQUFYLEVBQWtCOXJCLElBQWxCLENBQXVCOWIsR0FBdkI7QUFDQSxTQUFLNGxDLE9BQUwsQ0FBYWUsR0FBYixDQUFpQmlCLEtBQWpCLEVBQXdCOTNCLElBQUksQ0FBQ0MsU0FBTCxDQUFlLEtBQUs4MUIsS0FBTCxDQUFXK0IsS0FBWCxDQUFmLENBQXhCO0FBQ0g7QUFDSixDQWREOztBQWdCQXp3QixhQUFhLENBQUNULFNBQWQsQ0FBd0JteEIsWUFBeEIsR0FBdUMsVUFBVUQsS0FBVixFQUFpQm4rQixJQUFqQixFQUF1QjtBQUMxRCxNQUFJekosR0FBRyxHQUFHOFAsSUFBSSxDQUFDQyxTQUFMLENBQWV0RyxJQUFmLENBQVY7QUFDQSxNQUFJMEssS0FBSyxHQUFHLEtBQUsweEIsS0FBTCxDQUFXK0IsS0FBWCxFQUFrQmgyQixPQUFsQixDQUEwQjVSLEdBQTFCLENBQVo7O0FBQ0EsTUFBSW1VLEtBQUssSUFBSSxDQUFiLEVBQWdCO0FBQ1osU0FBSzB4QixLQUFMLENBQVcrQixLQUFYLEVBQWtCRSxNQUFsQixDQUF5QjN6QixLQUF6QjtBQUNBLFNBQUt5eEIsT0FBTCxDQUFhZSxHQUFiLENBQWlCaUIsS0FBakIsRUFBd0I5M0IsSUFBSSxDQUFDQyxTQUFMLENBQWUsS0FBSzgxQixLQUFMLENBQVcrQixLQUFYLENBQWYsQ0FBeEI7QUFDSDtBQUNKLENBUEQ7O0FBVUF6d0IsYUFBYSxDQUFDVCxTQUFkLENBQXdCb3dCLFVBQXhCLEdBQXFDLFVBQVVyOUIsSUFBVixFQUFnQjdHLFFBQWhCLEVBQTBCdXhCLEtBQTFCLEVBQWlDbEksUUFBakMsRUFBMkM7QUFBQTs7QUFDNUU7QUFDQSxNQUFJOGIsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBTTtBQUNwQjtBQUNBLFVBQUksQ0FBQ0osWUFBTCxDQUFrQi9rQyxRQUFsQixFQUE0QjZHLElBQTVCOztBQUNBZCxLQUFDLENBQUNxL0IsSUFBRixDQUFPLE1BQUksQ0FBQ3ovQixJQUFMLENBQVUzRixRQUFWLENBQVAsRUFBNEI2RyxJQUE1QixFQUNLMFcsSUFETCxDQUNVLFVBQUNsTixRQUFELEVBQWM7QUFDaEIsWUFBSSxDQUFDNDBCLFlBQUwsQ0FBa0JqbEMsUUFBbEIsRUFBNEI2RyxJQUE1Qjs7QUFDQSxVQUFJd0osUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLGNBQUksQ0FBQy9ILFNBQUwsQ0FBZXZJLFFBQWYsRUFBeUJvQyxXQUFXLENBQUNDLEtBQXJDO0FBQ0gsT0FGRCxNQUVPO0FBQ0h5RSxlQUFPLENBQUM4VyxLQUFSLENBQWN2TixRQUFkOztBQUNBLGNBQUksQ0FBQzlILFNBQUwsQ0FBZXZJLFFBQWYsRUFBeUJvQyxXQUFXLENBQUMrb0IsTUFBckMsRUFBNkM5YSxRQUFRLENBQUNwTCxPQUF0RDtBQUNIOztBQUNELFVBQUlva0IsUUFBSixFQUFjO0FBQ1ZBLGdCQUFRLENBQUNoWixRQUFELENBQVI7QUFDSDs7QUFDRCxVQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEIsY0FBSSxDQUFDc3pCLE9BQUwsQ0FBYXZ6QixRQUFRLENBQUN5ekIsRUFBdEI7QUFDSDtBQUNKLEtBZkwsRUFnQkk7QUFoQkosS0FpQktwbUIsSUFqQkwsQ0FpQlUsVUFBQ0UsS0FBRCxFQUFReW5CLFVBQVIsRUFBdUI7QUFDekIsWUFBSSxDQUFDOThCLFNBQUwsQ0FBZXZJLFFBQWYsRUFBeUJvQyxXQUFXLENBQUMwZ0MsUUFBckMsRUFBK0N1QyxVQUFVLENBQUNyakMsUUFBWCxFQUEvQzs7QUFDQSxZQUFJLENBQUNraUMsVUFBTCxDQUFnQnI5QixJQUFoQixFQUFzQjdHLFFBQXRCLEVBQWdDdXhCLEtBQUssR0FBRyxNQUFJLENBQUM4UixVQUE3QyxFQUF5RGhhLFFBQXpEO0FBQ0gsS0FwQkw7QUFxQkgsR0F4QkQ7O0FBeUJBLE1BQUlrSSxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNoQjRULGVBQVc7QUFDZCxHQUZELE1BRU87QUFDSDVlLGNBQVUsQ0FBQzRlLFdBQUQsRUFBYzVULEtBQWQsQ0FBVjtBQUNIO0FBQ0osQ0FoQ0Q7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7QUFXQWhkLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3Qmt3QixnQkFBeEIsR0FBMkMsVUFBVW45QixJQUFWLEVBQWdCdkcsUUFBaEIsRUFBMEJOLFFBQTFCLEVBQW9DdXhCLEtBQXBDLEVBQTJDK1QsZUFBM0MsRUFBNERDLFlBQTVELEVBQTBFO0FBQUE7O0FBQ2pILE1BQUlQLEtBQUssR0FBR2hsQyxRQUFRLEdBQUdNLFFBQXZCOztBQUNBLE1BQUlrbEMsT0FBTyxHQUFHLFNBQVZBLE9BQVUsR0FBTTtBQUNoQjtBQUNBLFVBQUksQ0FBQ3hDLE9BQUwsQ0FBYWUsR0FBYixDQUFpQmlCLEtBQWpCLEVBQXdCOTNCLElBQUksQ0FBQ0MsU0FBTCxDQUFldEcsSUFBZixDQUF4Qjs7QUFDQSxRQUFJMDdCLElBQUksR0FBRyxNQUFJLENBQUNTLE9BQUwsQ0FBYXlCLE9BQWIsQ0FBcUJPLEtBQXJCLENBQVgsQ0FIZ0IsQ0FJaEI7OztBQUNBai9CLEtBQUMsQ0FBQ3EvQixJQUFGLENBQU8sTUFBSSxDQUFDei9CLElBQUwsQ0FBVTNGLFFBQVYsQ0FBUCxFQUE0QjZHLElBQTVCLEVBQ0swVyxJQURMLENBQ1UsVUFBQ2xOLFFBQUQsRUFBYztBQUNoQixVQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEIsY0FBSSxDQUFDc3pCLE9BQUwsQ0FBYXZ6QixRQUFiLEVBRGtCLENBRWxCOzs7QUFDQSxZQUFJbzFCLFVBQVUsR0FBRyxNQUFJLENBQUN6QyxPQUFMLENBQWF5QixPQUFiLENBQXFCTyxLQUFyQixDQUFqQjs7QUFDQSxZQUFJekMsSUFBSSxJQUFJa0QsVUFBWixFQUF3QjtBQUNwQixnQkFBSSxDQUFDekMsT0FBTCxDQUFhenNCLE1BQWIsQ0FBb0J5dUIsS0FBcEI7QUFDSDs7QUFDRCxjQUFJLENBQUN6OEIsU0FBTCxDQUFldkksUUFBZixFQUF5Qm9DLFdBQVcsQ0FBQ0MsS0FBckM7QUFDSCxPQVJELE1BUU87QUFDSDtBQUNBLGNBQUksQ0FBQ2tHLFNBQUwsQ0FBZXZJLFFBQWYsRUFBeUJvQyxXQUFXLENBQUMrb0IsTUFBckMsRUFBNkM5YSxRQUFRLENBQUNwTCxPQUF0RDs7QUFDQSxZQUFJb0wsUUFBUSxDQUFDQyxPQUFULEtBQXFCLEtBQXpCLEVBQWdDO0FBQzVCO0FBQ0EsY0FBSW0xQixXQUFVLEdBQUcsTUFBSSxDQUFDekMsT0FBTCxDQUFheUIsT0FBYixDQUFxQk8sS0FBckIsQ0FBakI7O0FBQ0EsY0FBSXpDLElBQUksSUFBSWtELFdBQVosRUFBd0I7QUFDcEIsa0JBQUksQ0FBQ3pDLE9BQUwsQ0FBYXpzQixNQUFiLENBQW9CeXVCLEtBQXBCO0FBQ0g7O0FBQ0QsY0FBSU0sZUFBSixFQUFxQjtBQUNqQkEsMkJBQWUsQ0FBQ2oxQixRQUFELENBQWY7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQXhCTCxFQXlCS3FOLElBekJMLENBeUJVLFVBQUNFLEtBQUQsRUFBUXluQixVQUFSLEVBQXVCO0FBQ3pCLFlBQUksQ0FBQzk4QixTQUFMLENBQWV2SSxRQUFmLEVBQXlCb0MsV0FBVyxDQUFDMGdDLFFBQXJDLEVBQStDdUMsVUFBVSxDQUFDcmpDLFFBQVgsRUFBL0MsRUFEeUIsQ0FFekI7OztBQUNBLFVBQUl5akMsVUFBVSxHQUFHLE1BQUksQ0FBQ3pDLE9BQUwsQ0FBYXlCLE9BQWIsQ0FBcUJPLEtBQXJCLENBQWpCOztBQUNBLFVBQUl6QyxJQUFJLElBQUlrRCxVQUFaLEVBQXdCO0FBQ3BCLGNBQUksQ0FBQ3pCLGdCQUFMLENBQXNCbjlCLElBQXRCLEVBQTRCdkcsUUFBNUIsRUFBc0NOLFFBQXRDLEVBQWdEdXhCLEtBQUssR0FBRyxNQUFJLENBQUM4UixVQUE3RDtBQUNIO0FBQ0osS0FoQ0wsRUFpQ0s5bEIsSUFqQ0wsQ0FpQ1Vnb0IsWUFqQ1Y7QUFrQ0gsR0F2Q0Q7O0FBd0NBalEsY0FBWSxDQUFDLEtBQUtnTyxNQUFMLENBQVkwQixLQUFaLENBQUQsQ0FBWjs7QUFDQSxNQUFJelQsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEIsV0FBT2lVLE9BQU8sRUFBZDtBQUNILEdBRkQsTUFFTztBQUNILFNBQUtsQyxNQUFMLENBQVkwQixLQUFaLElBQXFCemUsVUFBVSxDQUFDaWYsT0FBRCxFQUFValUsS0FBVixDQUEvQjtBQUNIO0FBQ0osQ0FoREQ7O0FBa0RBaGQsYUFBYSxDQUFDVCxTQUFkLENBQXdCNHhCLGFBQXhCLEdBQXdDLFVBQVUxbEMsUUFBVixFQUFvQjZHLElBQXBCLEVBQTBCOCtCLFFBQTFCLEVBQW9DcjFCLE9BQXBDLEVBQTZDaWYsT0FBN0MsRUFBd0U7QUFBQTs7QUFBQSxNQUFsQnFXLGFBQWtCLHVFQUFKLEVBQUk7QUFDNUcsT0FBS2pCLFdBQUwsQ0FBaUJnQixRQUFqQjtBQUNBLFNBQU81L0IsQ0FBQyxDQUFDOC9CLElBQUY7QUFDSHRuQyxRQUFJLEVBQUUsTUFESDtBQUVIRCxPQUFHLEVBQUUsS0FBS3FILElBQUwsQ0FBVTNGLFFBQVYsQ0FGRjtBQUdINkcsUUFBSSxFQUFFQTtBQUhILEtBSUErK0IsYUFKQSxHQU1Gcm9CLElBTkUsQ0FNRyxVQUFDbE4sUUFBRCxFQUFjO0FBQ2hCLFVBQUksQ0FBQ3kwQixXQUFMOztBQUNBLFVBQUksQ0FBQ3Y4QixTQUFMLENBQWV2SSxRQUFmLEVBQXlCb0MsV0FBVyxDQUFDQyxLQUFyQzs7QUFDQWlPLFdBQU8sQ0FBQ0QsUUFBRCxDQUFQOztBQUNBLFVBQUksQ0FBQ3V6QixPQUFMLENBQWF2ekIsUUFBYjtBQUNILEdBWEUsRUFZRnFOLElBWkUsQ0FZRyxVQUFDNUssQ0FBRCxFQUFJdXlCLFVBQUosRUFBZ0JTLFdBQWhCLEVBQWdDO0FBQ2xDLFFBQUlILFFBQVEsSUFBSSxDQUFoQixFQUFtQjtBQUNmLFlBQUksQ0FBQ2IsV0FBTDs7QUFDQSxZQUFJLENBQUN2OEIsU0FBTCxDQUFldkksUUFBZixFQUF5Qm9DLFdBQVcsQ0FBQytvQixNQUFyQyxFQUE2Q2thLFVBQVUsQ0FBQ3JqQyxRQUFYLEVBQTdDOztBQUNBLFVBQUl1dEIsT0FBSixFQUFhO0FBQ1RBLGVBQU8sQ0FBQ3pjLENBQUQsRUFBSXV5QixVQUFKLEVBQWdCUyxXQUFoQixDQUFQO0FBQ0g7QUFDSixLQU5ELE1BTU87QUFDSHZmLGdCQUFVLENBQUMsWUFBTTtBQUNiLGNBQUksQ0FBQ3VlLFdBQUw7O0FBQ0EsY0FBSSxDQUFDdjhCLFNBQUwsQ0FBZXZJLFFBQWYsRUFBeUJvQyxXQUFXLENBQUMwZ0MsUUFBckMsRUFBK0N1QyxVQUFVLENBQUNyakMsUUFBWCxFQUEvQzs7QUFDQSxjQUFJLENBQUMwakMsYUFBTCxDQUFtQjFsQyxRQUFuQixFQUE2QjZHLElBQTdCLEVBQW1DOCtCLFFBQVEsR0FBRyxDQUE5QyxFQUFpRHIxQixPQUFqRCxFQUEwRGlmLE9BQTFEO0FBQ0gsT0FKUyxFQUlQLE1BQUksQ0FBQzhULFVBSkUsQ0FBVjtBQUtIO0FBQ0osR0ExQkUsQ0FBUDtBQTJCSCxDQTdCRDs7QUFnQ0E5dUIsYUFBYSxDQUFDVCxTQUFkLENBQXdCM1IsY0FBeEIsR0FBeUMsVUFBVThELGFBQVYsRUFBeUI7QUFBQTs7QUFDOUQsTUFBSXRJLEtBQUssR0FBRyxLQUFLZ1csSUFBTCxDQUFVaFcsS0FBdEI7O0FBQ0EsTUFBSUEsS0FBSyxDQUFDOEssRUFBTixDQUFTdEMsTUFBVCxDQUFnQjZKLG1CQUFoQixDQUFvQyxnQkFBcEMsQ0FBSixFQUEyRDtBQUN2RCxRQUFJbkosSUFBSSxHQUFHLEtBQUswOUIsZ0JBQUwsRUFBWDtBQUNBMTlCLFFBQUksQ0FBQyxlQUFELENBQUosR0FBd0JaLGFBQXhCOztBQUNBLFNBQUt5L0IsYUFBTCxDQUFtQixnQkFBbkIsRUFBcUM3K0IsSUFBckMsRUFBMkMsQ0FBM0MsRUFDbUIsVUFBQ3dKLFFBQUQsRUFBYztBQUNWLFVBQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQixjQUFJLENBQUNxRCxJQUFMLENBQVVULG1CQUFWLENBQThCN0MsUUFBOUI7QUFDSCxPQUZELE1BRU87QUFDSCxjQUFJLENBQUM5SCxTQUFMLENBQWUsZ0JBQWYsRUFBaUNuRyxXQUFXLENBQUMrb0IsTUFBN0MsRUFBcUQ5YSxRQUFRLENBQUNwTCxPQUE5RDs7QUFDQSxjQUFJLENBQUMwTyxJQUFMLENBQVV6TixVQUFWLENBQXFCbUQsTUFBckIsQ0FBNEJpWCx5QkFBNUIsQ0FBc0RqUSxRQUFRLENBQUNwTCxPQUEvRDtBQUNIO0FBQ0osS0FScEIsRUFTbUIsVUFBQzZOLENBQUQsRUFBSXV5QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUM1QixZQUFJLENBQUNueUIsSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCaVgseUJBQTVCLENBQXNEK2tCLFVBQXREOztBQUNBditCLGFBQU8sQ0FBQzhXLEtBQVIsQ0FBYzlLLENBQWQsRUFBaUJ1eUIsVUFBakIsRUFBNkJTLFdBQTdCO0FBQ0gsS0FacEI7QUFhSCxHQWhCRCxNQWdCTztBQUNILFNBQUt2OUIsU0FBTCxDQUFlLGdCQUFmLEVBQWlDbkcsV0FBVyxDQUFDMmdDLE9BQTdDO0FBQ0g7QUFDSixDQXJCRDs7QUF1QkF4dUIsYUFBYSxDQUFDVCxTQUFkLENBQXdCM1EsY0FBeEIsR0FBeUMsWUFBWTtBQUFBOztBQUNqRCxNQUFJeEYsS0FBSyxHQUFHLEtBQUtnVyxJQUFMLENBQVVoVyxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUM4SyxFQUFOLENBQVN0QyxNQUFULENBQWdCNkosbUJBQWhCLENBQW9DLGdCQUFwQyxDQUFKLEVBQTJEO0FBQ3ZELFFBQUluSixJQUFJLEdBQUcsS0FBSzA5QixnQkFBTCxFQUFYO0FBQ0ExOUIsUUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQmxKLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJvRCxNQUFqQixFQUFqQjtBQUNBbUgsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQmxKLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJtRCxRQUFqQixFQUFuQjtBQUNBb0gsUUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQmxKLEtBQUssQ0FBQ3JCLFVBQU4sWUFBakI7QUFDQXVLLFFBQUksQ0FBQyxLQUFELENBQUosR0FBY2xKLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJnQyxHQUFqQixFQUFkO0FBQ0F1SSxRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCbEosS0FBSyxDQUFDckIsVUFBTixDQUFpQm9DLE1BQWpCLEVBQWpCO0FBQ0FtSSxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CbEosS0FBSyxDQUFDckIsVUFBTixDQUFpQnFELFFBQWpCLEVBQXBCO0FBQ0FrSCxRQUFJLENBQUMsTUFBRCxDQUFKLEdBQWVsSixLQUFLLENBQUNyQixVQUFOLENBQWlCMEIsSUFBakIsRUFBZjtBQUNBNkksUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQnVkLDBGQUFzQixDQUFDem1CLEtBQUQsQ0FBekM7O0FBRUEsU0FBSytuQyxhQUFMLENBQW1CLGdCQUFuQixFQUFxQzcrQixJQUFyQyxFQUEyQyxDQUEzQyxFQUNtQixLQUFLay9CLGlCQUFMLENBQXVCMzJCLElBQXZCLENBQTRCLElBQTVCLENBRG5CLEVBRW1CLFVBQUMwRCxDQUFELEVBQUl1eUIsVUFBSixFQUFnQlMsV0FBaEIsRUFBZ0M7QUFDNUIsWUFBSSxDQUFDbnlCLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFyQixDQUE0QnFYLHdCQUE1QixDQUFxRDJrQixVQUFyRDs7QUFDQXYrQixhQUFPLENBQUM4VyxLQUFSLENBQWM5SyxDQUFkLEVBQWlCdXlCLFVBQWpCLEVBQTZCUyxXQUE3QjtBQUNILEtBTHBCO0FBTUgsR0FqQkQsTUFpQk87QUFDSCxTQUFLdjlCLFNBQUwsQ0FBZSxnQkFBZixFQUFpQ25HLFdBQVcsQ0FBQzJnQyxPQUE3QyxFQUFzRCw0Q0FBdEQ7QUFDSDtBQUNKLENBdEJEOztBQXdCQXh1QixhQUFhLENBQUNULFNBQWQsQ0FBd0J2UixXQUF4QixHQUFzQyxVQUFVOG1CLFFBQVYsRUFBb0I7QUFBQTs7QUFDdEQsTUFBSSxLQUFLMVYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1CdEMsTUFBbkIsQ0FBMEI2SixtQkFBMUIsQ0FBOEMsYUFBOUMsQ0FBSixFQUFrRTtBQUM5RCxRQUFJclMsS0FBSyxHQUFHLEtBQUtnVyxJQUFMLENBQVVoVyxLQUF0QjtBQUNBLFFBQUlrSixJQUFJLEdBQUcsS0FBSzA5QixnQkFBTCxFQUFYOztBQUNBLFNBQUttQixhQUFMLENBQW1CLGFBQW5CLEVBQWtDNytCLElBQWxDLEVBQXdDLENBQXhDLEVBQTJDd2lCLFFBQTNDLEVBQ21CLFVBQUN2VyxDQUFELEVBQUl1eUIsVUFBSixFQUFnQlMsV0FBaEIsRUFBZ0M7QUFDNUIsWUFBSSxDQUFDbnlCLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFyQixDQUE0Qm9ILHFCQUE1Qjs7QUFDQTNKLGFBQU8sQ0FBQzhXLEtBQVIsQ0FBYzlLLENBQWQsRUFBaUJ1eUIsVUFBakIsRUFBNkJTLFdBQTdCO0FBQ0gsS0FKcEI7QUFLSDtBQUNKLENBVkQ7O0FBWUF2eEIsYUFBYSxDQUFDVCxTQUFkLENBQXdCclEsaUJBQXhCLEdBQTRDLFVBQVU0bEIsUUFBVixFQUFvQjtBQUFBOztBQUM1RCxNQUFJLEtBQUsxVixJQUFMLENBQVVoVyxLQUFWLENBQWdCOEssRUFBaEIsQ0FBbUJ0QyxNQUFuQixDQUEwQjZKLG1CQUExQixDQUE4QyxtQkFBOUMsQ0FBSixFQUF3RTtBQUNwRSxRQUFJclMsS0FBSyxHQUFHLEtBQUtnVyxJQUFMLENBQVVoVyxLQUF0QjtBQUNBLFFBQUlrSixJQUFJLEdBQUcsS0FBSzA5QixnQkFBTCxFQUFYOztBQUNBLFNBQUttQixhQUFMLENBQW1CLG1CQUFuQixFQUF3QzcrQixJQUF4QyxFQUE4QyxDQUE5QyxFQUFpRHdpQixRQUFqRCxFQUNtQixVQUFDdlcsQ0FBRCxFQUFJdXlCLFVBQUosRUFBZ0JTLFdBQWhCLEVBQWdDO0FBQzVCLGFBQUksQ0FBQ255QixJQUFMLENBQVV6TixVQUFWLENBQXFCbUQsTUFBckIsQ0FBNEJtWCw0QkFBNUIsQ0FBeUQ2a0IsVUFBekQ7O0FBQ0F2K0IsYUFBTyxDQUFDOFcsS0FBUixDQUFjOUssQ0FBZCxFQUFpQnV5QixVQUFqQixFQUE2QlMsV0FBN0I7QUFDSCxLQUpwQjtBQUtIO0FBQ0osQ0FWRDs7QUFZQXZ4QixhQUFhLENBQUNULFNBQWQsQ0FBd0JqUSxVQUF4QixHQUFxQyxVQUFVbWlDLFNBQVYsRUFBcUJDLFNBQXJCLEVBQWdDM2xDLFFBQWhDLEVBQTBDc08sUUFBMUMsRUFBb0R5YSxRQUFwRCxFQUE4RDtBQUFBOztBQUMvRixNQUFJMXJCLEtBQUssR0FBRyxLQUFLZ1csSUFBTCxDQUFVaFcsS0FBdEI7O0FBQ0EsTUFBSUEsS0FBSyxDQUFDOEssRUFBTixDQUFTdEMsTUFBVCxDQUFnQjZKLG1CQUFoQixDQUFvQyxZQUFwQyxDQUFKLEVBQXVEO0FBQ25ELFFBQUluSixJQUFJLEdBQUcsS0FBSzA5QixnQkFBTCxFQUFYO0FBQ0ExOUIsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQm0vQixTQUFwQjtBQUNBbi9CLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0JvL0IsU0FBcEI7QUFDQXAvQixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CdkcsUUFBbkI7QUFDQXVHLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUIrSCxRQUFuQjtBQUNBLFFBQUlzM0IsRUFBRSxHQUFHcm5CLE1BQU0sQ0FBQ3NuQixPQUFQLENBQWV0L0IsSUFBZixFQUFxQnM3QixNQUFyQixDQUE0QixVQUFDaUUsQ0FBRCxFQUFHdHpCLENBQUg7QUFBQSxhQUFVc3pCLENBQUMsQ0FBQy91QixNQUFGLE9BQUErdUIsQ0FBQyxxQkFBV3R6QixDQUFYLEVBQUQsRUFBZ0JzekIsQ0FBMUI7QUFBQSxLQUE1QixFQUEwRCxJQUFJQyxRQUFKLEVBQTFELENBQVQ7QUFDQSxXQUFPLEtBQUtYLGFBQUwsQ0FBbUIsWUFBbkIsRUFBaUNRLEVBQWpDLEVBQXFDLENBQXJDLEVBQ21CN2MsUUFEbkIsRUFFbUIsVUFBQ3ZXLENBQUQsRUFBSXV5QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUM1QixhQUFJLENBQUNueUIsSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCb1gsb0JBQTVCLENBQWlENGtCLFVBQWpEOztBQUNBditCLGFBQU8sQ0FBQzhXLEtBQVIsQ0FBYzlLLENBQWQsRUFBaUJ1eUIsVUFBakIsRUFBNkJTLFdBQTdCO0FBQ0gsS0FMcEIsRUFLc0I7QUFBQ1EsaUJBQVcsRUFBRSxLQUFkO0FBQXFCQyxpQkFBVyxFQUFFO0FBQWxDLEtBTHRCLENBQVA7QUFNSCxHQWJELE1BYU87QUFDSCxTQUFLaCtCLFNBQUwsQ0FBZSxZQUFmLEVBQTZCbkcsV0FBVyxDQUFDMmdDLE9BQXpDLEVBQWtELHdDQUFsRDtBQUNIO0FBQ0osQ0FsQkQ7O0FBb0JBeHVCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QmpSLFFBQXhCLEdBQW1DLFVBQVUyOUIsVUFBVixFQUFzQnQ3QixRQUF0QixFQUFnQ0MsS0FBaEMsRUFBdUNGLE9BQXZDLEVBQWdEczdCLFNBQWhELEVBQTJEO0FBQzFGLE1BQUksS0FBSzVzQixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0IwQixRQUF4QixFQUFKLEVBQXdDO0FBQ3BDLFNBQUt3RyxTQUFMLENBQWUsVUFBZixFQUEyQm5HLFdBQVcsQ0FBQzJnQyxPQUF2QztBQUNBO0FBQ0g7O0FBQ0QsTUFBSSxLQUFLcHZCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0I4SyxFQUFoQixDQUFtQnRDLE1BQW5CLENBQTBCNkosbUJBQTFCLENBQThDLFVBQTlDLENBQUosRUFBK0Q7QUFDM0QsUUFBSW5KLElBQUksR0FBRyxLQUFLMDlCLGdCQUFMLEVBQVg7QUFDQTE5QixRQUFJLENBQUMsWUFBRCxDQUFKLEdBQXFCMjVCLFVBQXJCO0FBQ0EzNUIsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQjNCLFFBQW5CO0FBQ0EyQixRQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCMUIsS0FBaEI7QUFDQTBCLFFBQUksQ0FBQyxTQUFELENBQUosR0FBa0I1QixPQUFsQjtBQUNBNEIsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQjA1QixTQUFwQjtBQUNBLFNBQUtoNEIsU0FBTCxDQUFlLFVBQWYsRUFBMkJuRyxXQUFXLENBQUNtSixNQUF2QyxFQVAyRCxDQVEzRDs7QUFDQSxTQUFLMjRCLFVBQUwsQ0FBZ0JyOUIsSUFBaEIsRUFBc0IsVUFBdEIsRUFBa0MsQ0FBbEMsRUFBcUMsWUFBTSxDQUMxQyxDQUREO0FBRUgsR0FYRCxNQVdPO0FBQ0gsU0FBSzBCLFNBQUwsQ0FBZSxVQUFmLEVBQTJCbkcsV0FBVyxDQUFDMmdDLE9BQXZDO0FBQ0g7QUFDSixDQW5CRDs7QUFxQkF4dUIsYUFBYSxDQUFDVCxTQUFkLENBQXdCL1EsU0FBeEIsR0FBb0MsVUFBVWtqQyxTQUFWLEVBQXFCaHFCLEtBQXJCLEVBQTRCO0FBQzVELE1BQUksS0FBS3RJLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QjBCLFFBQXhCLEVBQUosRUFBd0M7QUFDcEMsU0FBS3dHLFNBQUwsQ0FBZSxXQUFmLEVBQTRCbkcsV0FBVyxDQUFDMmdDLE9BQXhDO0FBQ0E7QUFDSDs7QUFDRCxNQUFJLEtBQUtwdkIsSUFBTCxDQUFVaFcsS0FBVixDQUFnQjhLLEVBQWhCLENBQW1CdEMsTUFBbkIsQ0FBMEI2SixtQkFBMUIsQ0FBOEMsV0FBOUMsQ0FBSixFQUFnRTtBQUM1RCxRQUFJbkosSUFBSSxHQUFHLEtBQUswOUIsZ0JBQUwsRUFBWDtBQUNBMTlCLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0JvL0IsU0FBcEI7QUFDQXAvQixRQUFJLENBQUMsT0FBRCxDQUFKLEdBQWdCb1YsS0FBaEI7QUFDQSxTQUFLMVQsU0FBTCxDQUFlLFdBQWYsRUFBNEJuRyxXQUFXLENBQUNtSixNQUF4QyxFQUo0RCxDQUs1RDs7QUFDQSxTQUFLeTRCLGdCQUFMLENBQXNCbjlCLElBQXRCLEVBQTRCLGVBQTVCLEVBQTZDLFdBQTdDLEVBQTBELENBQTFEO0FBQ0gsR0FQRCxNQU9PO0FBQ0gsU0FBSzBCLFNBQUwsQ0FBZSxXQUFmLEVBQTRCbkcsV0FBVyxDQUFDMmdDLE9BQXhDO0FBQ0g7QUFDSixDQWZEOztBQWlCQXh1QixhQUFhLENBQUNULFNBQWQsQ0FBd0J2USxzQkFBeEIsR0FBaUQsVUFBU2lqQyxTQUFULEVBQW9CO0FBQUE7O0FBQ2pFLE1BQUksS0FBSzd5QixJQUFMLENBQVVoVyxLQUFWLENBQWdCMEMsT0FBaEIsQ0FBd0IwQixRQUF4QixFQUFKLEVBQXdDO0FBQ3BDLFNBQUt3RyxTQUFMLENBQWUsd0JBQWYsRUFBeUNuRyxXQUFXLENBQUMyZ0MsT0FBckQ7QUFDQTtBQUNIOztBQUNELE1BQUksS0FBS3B2QixJQUFMLENBQVVoVyxLQUFWLENBQWdCOEssRUFBaEIsQ0FBbUJ0QyxNQUFuQixDQUEwQjZKLG1CQUExQixDQUE4Qyx3QkFBOUMsQ0FBSixFQUE2RTtBQUN6RSxRQUFJbkosSUFBSSxHQUFHLEtBQUswOUIsZ0JBQUwsRUFBWDtBQUNBMTlCLFFBQUksQ0FBQyxRQUFELENBQUosR0FBaUIyL0IsU0FBakI7O0FBQ0EsUUFBSUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFDNS9CLElBQUQsRUFBVTtBQUM3QixVQUFJQSxJQUFJLENBQUN5SixPQUFULEVBQWtCO0FBQ2QsZUFBSSxDQUFDcUQsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCNEQsZ0JBQTNCLENBQTRDcW1DLFNBQTVDO0FBQ0g7QUFDSixLQUpEOztBQUtBLFNBQUtkLGFBQUwsQ0FBbUIsd0JBQW5CLEVBQTZDNytCLElBQTdDLEVBQW1ELENBQW5ELEVBQXNENC9CLGdCQUF0RCxFQUNtQixVQUFDM3pCLENBQUQsRUFBSXV5QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUM1QixhQUFJLENBQUNueUIsSUFBTCxDQUFVek4sVUFBVixDQUFxQm1ELE1BQXJCLENBQTRCeVgsZ0NBQTVCOztBQUNBaGEsYUFBTyxDQUFDOFcsS0FBUixDQUFjOUssQ0FBZCxFQUFpQnV5QixVQUFqQixFQUE2QlMsV0FBN0I7QUFDSCxLQUpwQjtBQUtIO0FBQ0osQ0FuQkQ7QUFxQkE7Ozs7Ozs7QUFLQXZ4QixhQUFhLENBQUNULFNBQWQsQ0FBd0JyUixRQUF4QixHQUFtQyxVQUFVbkMsUUFBVixFQUFvQi9CLElBQXBCLEVBQTBCOHFCLFFBQTFCLEVBQW9DcWQsYUFBcEMsRUFBbUQ7QUFDbEYsTUFBSS9vQyxLQUFLLEdBQUcsS0FBS2dXLElBQUwsQ0FBVWhXLEtBQXRCO0FBQ0EsTUFBSXdJLE1BQU0sR0FBRyxJQUFiOztBQUNBLE1BQUl4SSxLQUFLLENBQUM4SyxFQUFOLENBQVN0QyxNQUFULENBQWdCNkosbUJBQWhCLENBQW9DLFdBQXBDLENBQUosRUFBc0Q7QUFDbEQsUUFBSW5KLElBQUksR0FBRyxLQUFLMDlCLGdCQUFMLEVBQVg7QUFDQTE5QixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CdkcsUUFBbkI7QUFDQXVHLFFBQUksQ0FBQyxNQUFELENBQUosR0FBZXRJLElBQWY7O0FBQ0EsU0FBS21uQyxhQUFMLENBQW1CLEtBQUsvL0IsSUFBTCxDQUFVZ2hDLFNBQTdCLEVBQXdDOS9CLElBQXhDLEVBQThDLENBQTlDLEVBQ21CLFVBQVV3SixRQUFWLEVBQW9CO0FBQ2hCLFVBQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQitZLGdCQUFRLENBQUNoWixRQUFRLENBQUN4SixJQUFWLENBQVI7QUFDSCxPQUZELE1BRU87QUFDSDYvQixxQkFBYSxDQUFDcjJCLFFBQVEsQ0FBQ3BMLE9BQVYsQ0FBYjtBQUNBa0IsY0FBTSxDQUFDb0MsU0FBUCxDQUFpQixVQUFqQixFQUE2Qm5HLFdBQVcsQ0FBQytvQixNQUF6QyxFQUFpRDlhLFFBQVEsQ0FBQ3BMLE9BQTFEO0FBQ0g7QUFDSixLQVJwQixFQVNtQixVQUFVNk4sQ0FBVixFQUFhdXlCLFVBQWIsRUFBeUJTLFdBQXpCLEVBQXNDO0FBQ2xDWSxtQkFBYSxDQUFDLHNDQUFELENBQWI7QUFDQTUvQixhQUFPLENBQUM4VyxLQUFSLENBQWNrb0IsV0FBZDtBQUNILEtBWnBCO0FBYUgsR0FqQkQsTUFpQk87QUFDSFksaUJBQWEsQ0FBQywyQkFBRCxDQUFiO0FBQ0EsU0FBS24rQixTQUFMLENBQWUsVUFBZixFQUEyQm5HLFdBQVcsQ0FBQzJnQyxPQUF2QyxFQUFnRCxzQ0FBaEQ7QUFDSDtBQUNKLENBeEJEOztBQTBCQXh1QixhQUFhLENBQUNULFNBQWQsQ0FBd0I3USxRQUF4QixHQUFtQyxVQUFVM0MsUUFBVixFQUFvQnNPLFFBQXBCLEVBQThCMmlCLEtBQTlCLEVBQXFDO0FBQ3BFLE1BQUlBLEtBQUssS0FBSzkwQixTQUFkLEVBQXlCO0FBQ3JCODBCLFNBQUssR0FBRyxLQUFLNlIsV0FBYjtBQUNIOztBQUNELE1BQUl6bEMsS0FBSyxHQUFHLEtBQUtnVyxJQUFMLENBQVVoVyxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUMwQyxPQUFOLENBQWMwQixRQUFkLEVBQUosRUFBOEI7QUFDMUIsU0FBS3dHLFNBQUwsQ0FBZSxVQUFmLEVBQTJCbkcsV0FBVyxDQUFDMmdDLE9BQXZDO0FBQ0E7QUFDSDs7QUFDRCxNQUFJcGxDLEtBQUssQ0FBQzhLLEVBQU4sQ0FBU3RDLE1BQVQsQ0FBZ0I2SixtQkFBaEIsQ0FBb0MsVUFBcEMsQ0FBSixFQUFxRDtBQUNqRCxRQUFJbkosSUFBSSxHQUFHLEtBQUswOUIsZ0JBQUwsRUFBWDtBQUNBMTlCLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUJ2RyxRQUFuQjtBQUNBdUcsUUFBSSxDQUFDLE1BQUQsQ0FBSixHQUFlK0gsUUFBZjtBQUNBLFNBQUtyRyxTQUFMLENBQWUsVUFBZixFQUEyQm5HLFdBQVcsQ0FBQ21KLE1BQXZDO0FBQ0EsV0FBTyxLQUFLeTRCLGdCQUFMLENBQXNCbjlCLElBQXRCLEVBQTRCdkcsUUFBNUIsRUFBc0MsVUFBdEMsRUFBa0RpeEIsS0FBbEQsRUFBeUQsS0FBS3dVLGlCQUFMLENBQXVCMzJCLElBQXZCLENBQTRCLElBQTVCLENBQXpELENBQVA7QUFDSCxHQU5ELE1BTU87QUFDSCxXQUFPLEtBQUs3RyxTQUFMLENBQWUsVUFBZixFQUEyQm5HLFdBQVcsQ0FBQzJnQyxPQUF2QyxDQUFQO0FBQ0g7QUFDSixDQWxCRDs7QUFvQkF4dUIsYUFBYSxDQUFDVCxTQUFkLENBQXdCaXlCLGlCQUF4QixHQUE0QyxVQUFVMTFCLFFBQVYsRUFBb0I7QUFDNUQsTUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQVYsSUFBcUJELFFBQVEsQ0FBQ3UyQixRQUFsQyxFQUE0QztBQUN4QyxTQUFLanpCLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJtRCxNQUFyQixDQUE0QjBYLFVBQTVCO0FBQ0g7QUFDSixDQUpEOztBQU1BeE0sYUFBYSxDQUFDVCxTQUFkLENBQXdCelEsZ0JBQXhCLEdBQTJDLFVBQVVwRCxLQUFWLEVBQWlCQyxPQUFqQixFQUEwQjJtQyxjQUExQixFQUEwQ0MsV0FBMUMsRUFBdUQ7QUFBQTs7QUFDOUYsTUFBSSxLQUFLbnpCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QjBCLFFBQXhCLEVBQUosRUFBd0M7QUFDcEMsU0FBS3dHLFNBQUwsQ0FBZSxrQkFBZixFQUFtQ25HLFdBQVcsQ0FBQzJnQyxPQUEvQztBQUNBO0FBQ0g7O0FBQ0QsTUFBSTFaLFFBQVEsR0FBRyxLQUFLMVYsSUFBTCxDQUFVaFcsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCaUosU0FBOUIsQ0FBd0NnTCxPQUF2RDs7QUFDQSxNQUFJLEtBQUtxRCxJQUFMLENBQVVoVyxLQUFWLENBQWdCOEssRUFBaEIsQ0FBbUJ0QyxNQUFuQixDQUEwQjZKLG1CQUExQixDQUE4QyxrQkFBOUMsQ0FBSixFQUF1RTtBQUNuRSxRQUFJbkosSUFBSSxHQUFHLEtBQUswOUIsZ0JBQUwsRUFBWDtBQUNBMTlCLFFBQUksQ0FBQyxPQUFELENBQUosR0FBZ0I1RyxLQUFoQjtBQUNBNEcsUUFBSSxDQUFDLFNBQUQsQ0FBSixHQUFrQjNHLE9BQWxCO0FBQ0EyRyxRQUFJLENBQUMsaUJBQUQsQ0FBSixHQUEwQmdnQyxjQUExQjtBQUNBaGdDLFFBQUksQ0FBQyxjQUFELENBQUosR0FBdUJpZ0MsV0FBdkI7QUFDQSxTQUFLbnpCLElBQUwsQ0FBVXpOLFVBQVYsQ0FBcUJrQyxZQUFyQixDQUFrQ0MsRUFBbEMsQ0FBcUMyRSxXQUFyQyxDQUFpRCs1QixnQkFBakQsQ0FBa0UsVUFBQ0MsT0FBRCxFQUFVQyxHQUFWLEVBQWtCO0FBQ2hGcGdDLFVBQUksQ0FBQyxPQUFELENBQUosR0FBZ0JtZ0MsT0FBaEI7O0FBQ0EsVUFBSUMsR0FBRyxDQUFDMXdCLE1BQVIsRUFBZ0I7QUFDWjB3QixXQUFHLENBQUMxd0IsTUFBSjtBQUNIOztBQUNELGFBQUksQ0FBQzJ0QixVQUFMLENBQWdCcjlCLElBQWhCLEVBQXNCLGtCQUF0QixFQUEwQyxDQUExQyxFQUNnQixVQUFDd0osUUFBRCxFQUFjO0FBQ1YsWUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLGlCQUFJLENBQUMvSCxTQUFMLENBQWUsa0JBQWYsRUFBbUNuRyxXQUFXLENBQUNDLEtBQS9DO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUksQ0FBQ2tHLFNBQUwsQ0FBZSxrQkFBZixFQUFtQ25HLFdBQVcsQ0FBQytvQixNQUEvQyxFQUF1RDlhLFFBQVEsQ0FBQ3BMLE9BQWhFO0FBQ0g7O0FBQ0QsWUFBSSxDQUFDNGhDLGNBQUQsSUFBbUIzbUMsT0FBbkIsSUFBOEJtcEIsUUFBbEMsRUFBNEM7QUFDeENBLGtCQUFRLENBQUN4aUIsSUFBSSxDQUFDLGVBQUQsQ0FBTCxDQUFSO0FBQ0g7QUFDSixPQVZqQjtBQVdILEtBaEJEO0FBaUJIO0FBQ0osQ0E5QkQsQzs7Ozs7Ozs7Ozs7OztBQzlrQkE7QUFBQTtBQUFPLElBQU13dEIsZ0JBQWdCLHNzQ0FBdEIsQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFPLElBQUk2UyxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQVNscEMsSUFBVCxFQUFlO0FBQ3ZDLE1BQUltcEMsR0FBSixFQUFTQyxhQUFUO0FBQ0FELEtBQUcsR0FBRztBQUFDRSxZQUFRLEVBQUU7QUFBWCxHQUFOOztBQUVBLE1BQUksQ0FBQzl6QixFQUFFLENBQUMrekIsR0FBUixFQUFhO0FBQ1QvekIsTUFBRSxDQUFDK3pCLEdBQUgsR0FBUztBQUFDM3NCLFlBQU0sRUFBRTtBQUFULEtBQVQ7QUFDSCxHQU5zQyxDQVF2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzRzQixjQUFULENBQXdCNUwsR0FBeEIsRUFBNkIxb0IsTUFBN0IsRUFBcUM7QUFDakMsU0FBS3UwQixVQUFMLEdBQWtCdjBCLE1BQWxCO0FBQ0EsU0FBS3cwQixTQUFMLEdBQWtCOUwsR0FBbEI7QUFDSDs7QUFFRDRMLGdCQUFjLENBQUN6ekIsU0FBZixDQUF5QndiLElBQXpCLEdBQWdDLFVBQVNvWSxFQUFULEVBQWE7QUFDekMsUUFBSSxLQUFLRCxTQUFULEVBQW9CO0FBQ2hCLGFBQU8sSUFBUDtBQUNIOztBQUVELFFBQUk7QUFDQSxXQUFLRCxVQUFMLEdBQWtCRSxFQUFFLENBQUMsS0FBS0YsVUFBTixDQUFwQjtBQUNILEtBRkQsQ0FFRSxPQUFNMTBCLENBQU4sRUFBUztBQUNQLFdBQUswMEIsVUFBTCxHQUFrQi9xQyxTQUFsQjtBQUNBLFdBQUtnckMsU0FBTCxHQUFrQjMwQixDQUFsQjtBQUNIOztBQUVELFdBQU8sS0FBSzAwQixVQUFMLFlBQTJCM3VCLE9BQTNCLEdBQXFDLEtBQUsydUIsVUFBMUMsR0FBdUQsSUFBOUQ7QUFDSCxHQWJEOztBQWVBRCxnQkFBYyxDQUFDenpCLFNBQWYsWUFBaUMsVUFBUzR6QixFQUFULEVBQWE7QUFDMUMsUUFBSSxLQUFLRCxTQUFULEVBQW9CO0FBQ2hCLFVBQUk7QUFDQSxhQUFLRCxVQUFMLEdBQWtCRSxFQUFFLENBQUMsS0FBS0QsU0FBTixDQUFwQjtBQUNBLGFBQUtBLFNBQUwsR0FBa0JockMsU0FBbEI7QUFDSCxPQUhELENBR0UsT0FBTXFXLENBQU4sRUFBUztBQUNQLGFBQUswMEIsVUFBTCxHQUFrQi9xQyxTQUFsQjtBQUNBLGFBQUtnckMsU0FBTCxHQUFpQjMwQixDQUFqQjtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxLQUFLMDBCLFVBQUwsWUFBMkIzdUIsT0FBM0IsR0FBcUMsS0FBSzJ1QixVQUExQyxHQUF1RCxJQUE5RDtBQUNILEdBWkQ7O0FBY0EsTUFBSUcsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBUzNyQixTQUFULEVBQW9CLENBRXBDLENBRkQ7O0FBSUEsV0FBUzRyQixRQUFULENBQWtCNXBDLElBQWxCLEVBQXdCO0FBQ3BCLFdBQU8sSUFBSTZhLE9BQUosQ0FBWSxVQUFTQyxPQUFULEVBQWtCNFAsTUFBbEIsRUFBMEI7QUFDekMsVUFBSW5WLEVBQUUsQ0FBQyt6QixHQUFILENBQU8zc0IsTUFBUCxDQUFjM2MsSUFBZCxNQUF3QnZCLFNBQTVCLEVBQXVDO0FBQ25DO0FBQ0FxYyxlQUFPLENBQUN2RixFQUFFLENBQUMrekIsR0FBSCxDQUFPM3NCLE1BQVAsQ0FBYzNjLElBQWQsQ0FBRCxDQUFQO0FBQ0gsT0FIRCxNQUdPO0FBQ0gsWUFBSWlwQyxHQUFHLEdBQUcsSUFBSVksS0FBSixFQUFWO0FBQ0FaLFdBQUcsQ0FBQ2EsV0FBSixHQUFrQixXQUFsQjs7QUFDQWIsV0FBRyxDQUFDcDBCLE1BQUosR0FBYSxZQUFZO0FBQ3JCVSxZQUFFLENBQUMrekIsR0FBSCxDQUFPM3NCLE1BQVAsQ0FBYzNjLElBQWQsSUFBc0JpcEMsR0FBdEI7QUFDQW51QixpQkFBTyxDQUFDbXVCLEdBQUQsQ0FBUDtBQUNILFNBSEQ7O0FBSUFBLFdBQUcsQ0FBQ2MsT0FBSixHQUFjLFlBQVk7QUFDdEI7QUFDQXJmLGdCQUFNLENBQUMxcUIsSUFBRCxDQUFOO0FBQ0gsU0FIRDs7QUFJQWlwQyxXQUFHLENBQUNlLEdBQUosR0FBVWhxQyxJQUFWO0FBQ0g7QUFDSixLQWpCTSxDQUFQO0FBa0JIOztBQUVELE1BQUlpZSxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFTZ3NCLElBQVQsRUFBZUMsSUFBZixFQUFxQjtBQUM3QjtBQUNBO0FBRUFBLFFBQUksQ0FBQ0MsUUFBTCxHQUFnQixJQUFJNTBCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VWLElBQWYsQ0FBb0IsVUFBVTUvQixJQUFWLEVBQWdCNi9CLFdBQWhCLEVBQTZCO0FBQzdEOTBCLFFBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsVUFBdkIsRUFBbUMzcUIsU0FBbkMsRUFBOEMsQ0FBOUMsRUFBaUQsQ0FBakQ7QUFDQXBLLFFBQUUsQ0FBQ3NmLE9BQUgsQ0FBVzBWLFdBQVgsQ0FBdUIsYUFBdkIsRUFBc0MsUUFBdEMsRUFBZ0RoMUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXMlYsV0FBWCxDQUF1QkgsV0FBdkIsQ0FBaEQ7QUFDQTcvQixVQUFJLENBQUM2L0IsV0FBTCxHQUFtQkEsV0FBbkIsQ0FINkQsQ0FJN0Q7O0FBQ0EsVUFBSUksWUFBWSxHQUFHYixRQUFRLENBQUNyMEIsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQnlVLFdBQWpCLENBQUQsQ0FBM0I7QUFDQSxVQUFJSyxJQUFJLEdBQUcsSUFBSW4xQixFQUFFLENBQUN1YyxRQUFILENBQVk2WSxVQUFoQixFQUFYO0FBQ0FuZ0MsVUFBSSxDQUFDeVQsS0FBTCxHQUFhMUksRUFBRSxDQUFDc2YsT0FBSCxDQUFXK1YsSUFBWCxDQUFnQkMsS0FBN0I7O0FBQ0FILFVBQUksQ0FBQ0ksTUFBTCxHQUFjLFlBQVc7QUFDckIsWUFBSUosSUFBSSxDQUFDN2hDLElBQUwsQ0FBVSxPQUFWLENBQUosRUFBd0I7QUFDcEI7QUFDQSxnQkFBTTZoQyxJQUFJLENBQUM3aEMsSUFBTCxDQUFVLE9BQVYsQ0FBTjtBQUNILFNBSEQsTUFHTyxDQUNIO0FBQ0g7QUFDSixPQVBEOztBQVFBNmhDLFVBQUksQ0FBQzdoQyxJQUFMLEdBQVk7QUFDUnRJLFlBQUksRUFBRSxZQURFO0FBRVJ3cUMsZUFBTyxFQUFFTixZQUFZLENBQUNuWixJQUFiLENBQWtCLFVBQVNuVCxLQUFULEVBQWdCO0FBQ3ZDM1QsY0FBSSxDQUFDeVQsS0FBTCxHQUFhRSxLQUFiO0FBQ0EzVCxjQUFJLENBQUMwTyxNQUFMLEdBQWNDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFkO0FBQ0E1TyxjQUFJLENBQUMwTyxNQUFMLENBQVlzRCxLQUFaLEdBQW9CaFMsSUFBSSxDQUFDeVQsS0FBTCxDQUFXekIsS0FBL0I7QUFDQWhTLGNBQUksQ0FBQzBPLE1BQUwsQ0FBWTZDLE1BQVosR0FBcUJ2UixJQUFJLENBQUN5VCxLQUFMLENBQVdsQyxNQUFoQztBQUNBdlIsY0FBSSxDQUFDME8sTUFBTCxDQUFZOHhCLFVBQVosQ0FBdUIsSUFBdkIsRUFBNkJDLFNBQTdCLENBQXVDemdDLElBQUksQ0FBQ3lULEtBQTVDLEVBQW1ELENBQW5ELEVBQXNELENBQXRELEVBQXlEelQsSUFBSSxDQUFDeVQsS0FBTCxDQUFXekIsS0FBcEUsRUFBMkVoUyxJQUFJLENBQUN5VCxLQUFMLENBQVdsQyxNQUF0RjtBQUNBdlIsY0FBSSxDQUFDMGdDLE1BQUwsR0FBYzFnQyxJQUFJLENBQUMwTyxNQUFMLENBQVk4eEIsVUFBWixDQUF1QixJQUF2QixFQUE2QkcsWUFBN0IsQ0FBMEMsQ0FBMUMsRUFBNkMsQ0FBN0MsRUFBZ0QzZ0MsSUFBSSxDQUFDeVQsS0FBTCxDQUFXekIsS0FBM0QsRUFBa0VoUyxJQUFJLENBQUN5VCxLQUFMLENBQVdsQyxNQUE3RSxFQUFxRmxULElBQW5HLENBTnVDLENBT3ZDO0FBQ0gsU0FSUSxFQVFOLFVBQVM4MEIsR0FBVCxFQUFjO0FBQ2JuekIsY0FBSSxDQUFDeVQsS0FBTCxHQUFhLEVBQWI7QUFDQSxnQkFBTTBmLEdBQU4sQ0FGYSxDQUdiO0FBQ0gsU0FaUTtBQUZELE9BQVo7QUFpQkEsYUFBTytNLElBQVA7QUFDSCxLQWxDZSxDQUFoQjtBQW9DQVIsUUFBSSxDQUFDeHpCLElBQUwsR0FBWSxJQUFJbkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFTNS9CLElBQVQsRUFBZTtBQUMzQyxVQUFJK0ssRUFBRSxDQUFDek0sT0FBSCxLQUFlckssU0FBbkIsRUFBOEI7QUFDMUIsY0FBTSxJQUFJOFcsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVcsU0FBZixDQUF5Qix3REFBekIsQ0FBTjtBQUNIOztBQUVELFVBQUlDLFdBQVcsR0FBRztBQUNkcHRCLGFBQUssRUFBRXpULElBQUksQ0FBQ3lULEtBREU7QUFFZG9zQixtQkFBVyxFQUFFNy9CLElBQUksQ0FBQzYvQjtBQUZKLE9BQWxCO0FBS0E5MEIsUUFBRSxDQUFDek0sT0FBSCxDQUFXd2lDLGFBQVgsQ0FBeUJELFdBQXpCO0FBQ0gsS0FYVyxDQUFaO0FBYUFuQixRQUFJLENBQUNxQixJQUFMLEdBQVksSUFBSWgyQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFVBQVM1L0IsSUFBVCxFQUFlO0FBQzNDQSxVQUFJLENBQUN5VCxLQUFMLENBQVd1dEIsS0FBWCxDQUFpQkMsU0FBakIsR0FBNkIsWUFBN0I7O0FBQ0EsVUFBSWwyQixFQUFFLENBQUN6TSxPQUFILEtBQWVySyxTQUFuQixFQUE4QjtBQUMxQixjQUFNLElBQUk4VyxFQUFFLENBQUNzZixPQUFILENBQVd1VyxTQUFmLENBQXlCLHdEQUF6QixDQUFOO0FBQ0g7O0FBQ0QsYUFBTzVnQyxJQUFQO0FBQ0gsS0FOVyxDQUFaO0FBT0gsR0E1REQ7O0FBNkRBMitCLEtBQUcsQ0FBQ1UsS0FBSixHQUFZdDBCLEVBQUUsQ0FBQ3VjLFFBQUgsQ0FBWTRaLFVBQVosQ0FBdUJ2QyxHQUF2QixFQUE0QmxyQixLQUE1QixFQUFtQyxPQUFuQyxFQUE0QyxFQUE1QyxDQUFaO0FBRUEsU0FBT2tyQixHQUFQO0FBQ0gsQ0E3SU0sQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFPLElBQU0zUyxhQUFhLDQ1Q0FBbkIsQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFBOzs7Ozs7OztBQVFPLElBQUlMLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsR0FBVztBQUN2QztBQUNBLE1BQUlnVCxHQUFHLEdBQUcsRUFBVjtBQUNBLE1BQUl5QixJQUFJLEdBQUdyMUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK1YsSUFBWCxDQUFnQkMsS0FBM0I7QUFFQSxNQUFJYyxLQUFLLEdBQUcsSUFBWjtBQUNBeEMsS0FBRyxDQUFDeUMsTUFBSixHQUFhLElBQUlyMkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFTcHFDLElBQVQsRUFBZTtBQUM1Q3VWLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsUUFBdkIsRUFBaUMzcUIsU0FBakMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0M7QUFDQSxRQUFJa3NCLFVBQUo7O0FBQ0EsUUFBSUYsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEJFLGdCQUFVLEdBQUcsQ0FBYjtBQUNILEtBRkQsTUFFTztBQUNIQSxnQkFBVSxHQUFHbkksSUFBSSxDQUFDRCxHQUFMLEtBQWFrSSxLQUExQjtBQUNIOztBQUNEN2lDLFdBQU8sQ0FBQ0MsR0FBUixDQUFZd00sRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQjUxQixJQUFqQixDQUFaLEVBQW9DNnJDLFVBQVUsR0FBQyxJQUEvQztBQUNBRixTQUFLLEdBQUdqSSxJQUFJLENBQUNELEdBQUwsRUFBUjtBQUNILEdBVlksQ0FBYjtBQVlBOzs7O0FBR0EwRixLQUFHLENBQUMyQyxXQUFKLEdBQWtCLElBQUl2MkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQzdDdGhDLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLDJCQUFLNFcsU0FBTCxFQUFpQmxQLEdBQWpCLENBQXFCOEUsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBNUIsQ0FBWjtBQUNILEdBRmlCLENBQWxCO0FBSUE7Ozs7QUFHQXVULEtBQUcsQ0FBQzRDLGFBQUosR0FBb0IsSUFBSXgyQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDL0N0aEMsV0FBTyxDQUFDQyxHQUFSLENBQVk0VyxTQUFaO0FBQ0gsR0FGbUIsQ0FBcEI7QUFJQTs7Ozs7QUFJQXdwQixLQUFHLENBQUM2QyxVQUFKLEdBQWlCLElBQUl6MkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQzVDNzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsWUFBdkIsRUFBcUMzcUIsU0FBckMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQ7O0FBQ0EsUUFBSXBLLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbGdCLE9BQW5DLEVBQTRDO0FBQ3hDLFVBQUlwTSxNQUFNLEdBQUdxUCxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQixRQUEvQixHQUFiO0FBQ0F0c0IsWUFBTSxHQUFHQSxNQUFNLENBQUN1SyxHQUFQLENBQVcsVUFBU3c3QixJQUFULEVBQWU7QUFBRSxlQUFPQSxJQUFJLENBQUNDLFFBQUwsRUFBUDtBQUF5QixPQUFyRCxDQUFUO0FBQ0EsYUFBTyxJQUFJMzJCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3NYLElBQWYsQ0FBb0JqbUMsTUFBcEIsQ0FBUDtBQUNILEtBSkQsTUFJTztBQUNILGFBQU8sSUFBSXFQLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3NYLElBQWYsQ0FBb0IsRUFBcEIsQ0FBUDtBQUNIO0FBQ0osR0FUZ0IsQ0FBakI7QUFXQTs7Ozs7QUFJQWhELEtBQUcsQ0FBQ2lELFlBQUosR0FBbUIsSUFBSTcyQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDOUM3MEIsTUFBRSxDQUFDc2YsT0FBSCxDQUFXeVYsV0FBWCxDQUF1QixjQUF2QixFQUF1QzNxQixTQUF2QyxFQUFrRCxDQUFsRCxFQUFxRCxDQUFyRDs7QUFDQSxRQUFJcEssRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JsZ0IsT0FBbkMsRUFBNEM7QUFDeENpRCxRQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQnRzQixNQUEvQixDQUFzQytWLFNBQXRDO0FBQ0g7O0FBQ0QsV0FBTzFHLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytWLElBQVgsQ0FBZ0JDLEtBQXZCO0FBQ0gsR0FOa0IsQ0FBbkI7QUFRQTs7Ozs7Ozs7OztBQVVBOzs7O0FBR0ExQixLQUFHLENBQUNrRCxXQUFKLEdBQWtCLElBQUk5MkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQzdDNzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsYUFBdkIsRUFBc0MzcUIsU0FBdEMsRUFBaUQsQ0FBakQsRUFBb0QsQ0FBcEQ7QUFDQSxXQUFPcEssRUFBRSxDQUFDOEMsR0FBSCxDQUFPQyxTQUFQLENBQWlCL0MsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsVUFBcEIsRUFBZ0Mxd0IsSUFBakQsQ0FBUDtBQUNILEdBSGlCLENBQWxCO0FBS0E7Ozs7QUFHQXFuQyxLQUFHLENBQUNtRCxjQUFKLEdBQXFCLElBQUkvMkIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQ2hENzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDM3FCLFNBQXpDLEVBQW9ELENBQXBELEVBQXVELENBQXZEO0FBQ0EsV0FBT3BLLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT0MsU0FBUCxDQUFpQi9DLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCeUYsVUFBL0IsSUFBNkMsRUFBOUQsQ0FBUDtBQUNILEdBSG9CLENBQXJCO0FBS0FrUixLQUFHLENBQUNvRCxXQUFKLEdBQWtCLElBQUloM0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQzdDLFFBQUk3MEIsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JsZ0IsT0FBbkMsRUFBNEM7QUFDeEMsVUFBSW9aLEtBQUssR0FBR25XLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCZ2EsU0FBM0M7QUFDQSxhQUFPajNCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT0MsU0FBUCxDQUFpQm9ULEtBQWpCLENBQVA7QUFDSCxLQUhELE1BR087QUFDSCxhQUFPLElBQUluVyxFQUFFLENBQUNzZixPQUFILENBQVdzWCxJQUFmLENBQW9CLEVBQXBCLENBQVA7QUFDSDtBQUNKLEdBUGlCLENBQWxCO0FBU0FoRCxLQUFHLENBQUNzRCxXQUFKLEdBQWtCLElBQUlsM0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQzdDO0FBQ0E7QUFDQSxRQUFJNzBCLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbGdCLE9BQW5DLEVBQTRDO0FBQ3hDLFVBQUl4TCxLQUFLLEdBQUd5TyxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjFyQixLQUEzQztBQUNBLGFBQU95TyxFQUFFLENBQUM4QyxHQUFILENBQU9DLFNBQVAsQ0FBaUJ4UixLQUFqQixDQUFQO0FBQ0g7O0FBQ0QsV0FBTyxJQUFJeU8sRUFBRSxDQUFDc2YsT0FBSCxDQUFXNlgsSUFBZixDQUFvQixFQUFwQixDQUFQO0FBQ0gsR0FSaUIsQ0FBbEI7QUFVQXZELEtBQUcsQ0FBQ3dELFdBQUosR0FBa0IsSUFBSXAzQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDN0M7QUFDQSxRQUFJNzBCLEVBQUUsQ0FBQ29lLFVBQUgsS0FBa0IsSUFBdEIsRUFBNEI7QUFDeEJwZSxRQUFFLENBQUNvZSxVQUFILEdBQWdCcGUsRUFBRSxDQUFDZ2hCLGdCQUFuQjtBQUNIOztBQUNEaGhCLE1BQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCdEIsT0FBL0IsQ0FBdUNoVyxJQUF2QyxDQUE0QyxJQUE1QyxFQUw2QyxDQU03QztBQUNILEdBUGlCLENBQWxCO0FBU0FpdUIsS0FBRyxDQUFDeUQsVUFBSixHQUFpQixJQUFJcjNCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VWLElBQWYsQ0FBb0IsWUFBVztBQUM1QztBQUNBNzBCLE1BQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCdEIsT0FBL0IsQ0FBdUN1RSxHQUF2Qzs7QUFDQSxRQUFJbGdCLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCdEIsT0FBL0IsQ0FBdUNyaUIsTUFBdkMsS0FBa0QsQ0FBdEQsRUFBeUQ7QUFDckQwRyxRQUFFLENBQUNvZSxVQUFILEdBQWdCLElBQWhCO0FBQ0gsS0FMMkMsQ0FNNUM7O0FBQ0gsR0FQZ0IsQ0FBakI7QUFTQTs7OztBQUdBd1YsS0FBRyxDQUFDMEQsaUJBQUosR0FBd0IsSUFBSXQzQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDbkQ3MEIsTUFBRSxDQUFDc2YsT0FBSCxDQUFXeVYsV0FBWCxDQUF1QixtQkFBdkIsRUFBNEMzcUIsU0FBNUMsRUFBdUQsQ0FBdkQsRUFBMEQsQ0FBMUQ7O0FBQ0EsUUFBSXBLLEVBQUUsQ0FBQ2lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbGdCLE9BQW5DLEVBQTRDO0FBQ3hDLGFBQU8sSUFBSWlELEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV2lZLEtBQWYsQ0FBcUIsQ0FBQ2xDLElBQUQsRUFBT0EsSUFBUCxDQUFyQixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSWhyQixLQUFLLEdBQUdySyxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjVTLEtBQTNDO0FBQUEsVUFDSS9HLFFBQVEsR0FBRyxFQURmOztBQUVBLFVBQUkrRyxLQUFLLElBQUlBLEtBQUssQ0FBQzJkLFNBQWYsSUFBNEIzZCxLQUFLLENBQUMyZCxTQUFOLENBQWdCMXVCLE1BQWhCLEdBQXlCLENBQXpELEVBQTREO0FBQ3hEZ0ssZ0JBQVEsQ0FBQyxNQUFELENBQVIsR0FBbUIrRyxLQUFLLENBQUMyZCxTQUFOLENBQWdCLENBQWhCLEVBQW1CakQsTUFBdEM7QUFDSCxPQUZELE1BRU87QUFDSDFhLGFBQUssR0FBR2dyQixJQUFSO0FBQ0g7O0FBQ0QveEIsY0FBUSxHQUFHdEQsRUFBRSxDQUFDOEMsR0FBSCxDQUFPQyxTQUFQLENBQWlCTyxRQUFqQixDQUFYO0FBQ0EsYUFBTyxJQUFJdEQsRUFBRSxDQUFDc2YsT0FBSCxDQUFXaVksS0FBZixDQUFxQixDQUFDbHRCLEtBQUQsRUFBUS9HLFFBQVIsQ0FBckIsQ0FBUDtBQUNIO0FBQ0osR0FmdUIsQ0FBeEI7QUFrQkFzd0IsS0FBRyxDQUFDNEQsd0JBQUosR0FBK0IsSUFBSXgzQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDMUQ3MEIsTUFBRSxDQUFDc2YsT0FBSCxDQUFXeVYsV0FBWCxDQUF1QiwwQkFBdkIsRUFBbUQzcUIsU0FBbkQsRUFBOEQsQ0FBOUQsRUFBaUUsQ0FBakU7QUFDQSxXQUFPLENBQUNwSyxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQmxnQixPQUFoQyxJQUNDaUQsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I1UyxLQURoQyxJQUVDckssRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I1UyxLQUEvQixDQUFxQytZLE9BQXJDLEtBQWlELGdCQUZ6RDtBQUdILEdBTDhCLENBQS9CO0FBT0EsTUFBSXFVLFVBQVUsR0FBR3Z1QyxTQUFqQjtBQUNBMHFDLEtBQUcsQ0FBQzhELG9CQUFKLEdBQTJCLElBQUkxM0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQ3RENzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsc0JBQXZCLEVBQStDM3FCLFNBQS9DLEVBQTBELENBQTFELEVBQTZELENBQTdEO0FBQ0FxdEIsY0FBVSxHQUFHejNCLEVBQUUsQ0FBQzZkLFNBQWhCOztBQUNBLFFBQUk3ZCxFQUFFLENBQUNrZSxpQkFBUCxFQUEwQjtBQUN0QmxlLFFBQUUsQ0FBQzZkLFNBQUgsR0FBZTdkLEVBQUUsQ0FBQ2tlLGlCQUFILEVBQWY7QUFDQWxlLFFBQUUsQ0FBQzIzQixTQUFILEdBQWV4SixJQUFJLENBQUNELEdBQUwsRUFBZjtBQUNIO0FBQ0osR0FQMEIsQ0FBM0I7QUFRQTBGLEtBQUcsQ0FBQ2dFLHNCQUFKLEdBQTZCLElBQUk1M0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQ3hENzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsd0JBQXZCLEVBQWlEM3FCLFNBQWpELEVBQTRELENBQTVELEVBQStELENBQS9EO0FBQ0FwSyxNQUFFLENBQUM2ZCxTQUFILEdBQWU0WixVQUFmO0FBQ0F6M0IsTUFBRSxDQUFDMjNCLFNBQUgsR0FBZXhKLElBQUksQ0FBQ0QsR0FBTCxFQUFmO0FBQ0gsR0FKNEIsQ0FBN0I7QUFNQTBGLEtBQUcsQ0FBQ2lFLGtCQUFKLEdBQXlCLElBQUk3M0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQ3BENzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsb0JBQXZCLEVBQTZDM3FCLFNBQTdDLEVBQXdELENBQXhELEVBQTJELENBQTNEO0FBQ0FwSyxNQUFFLENBQUNpZCxnQkFBSCxDQUFvQmp3QixVQUFwQixDQUErQmsyQixTQUEvQixHQUEyQyxJQUEzQztBQUNILEdBSHdCLENBQXpCO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTBRLEtBQUcsQ0FBQ2tFLFNBQUosR0FBZ0IsSUFBSTkzQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFlBQVc7QUFDM0M3MEIsTUFBRSxDQUFDc2YsT0FBSCxDQUFXeVYsV0FBWCxDQUF1QixXQUF2QixFQUFvQzNxQixTQUFwQyxFQUErQyxDQUEvQyxFQUFrRCxDQUFsRDs7QUFDQSxRQUFJcEssRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JsZ0IsT0FBbkMsRUFBNEM7QUFDeEMsVUFBSWc3QixPQUFPLEdBQUcvM0IsRUFBRSxDQUFDaWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0IsUUFBL0IsR0FBZDtBQUNBOGEsYUFBTyxHQUFHQSxPQUFPLENBQUN6bkIsTUFBUixDQUFlLFVBQVMzZixNQUFULEVBQWlCO0FBQ3RDLGVBQU9BLE1BQU0sQ0FBQzNGLElBQVAsS0FBZ0IsTUFBdkI7QUFDSCxPQUZTLEVBRVBrUSxHQUZPLENBRUgsVUFBUzg4QixLQUFULEVBQWdCO0FBQ25CLGVBQU87QUFBQyxrQkFBUUEsS0FBSyxDQUFDdDFCLE9BQU4sQ0FBY3hILEdBQWQsQ0FBa0IsVUFBUys4QixJQUFULEVBQWU7QUFDN0MsZ0JBQUlDLE9BQU8sR0FBRztBQUFFLHNCQUFRRCxJQUFJLENBQUNqdEMsSUFBZjtBQUNWLHVCQUFTO0FBREMsYUFBZDs7QUFFQSxnQkFBSWl0QyxJQUFJLENBQUNqdEMsSUFBTCxLQUFjLE1BQWQsSUFBd0JpdEMsSUFBSSxDQUFDanRDLElBQUwsS0FBYyxTQUExQyxFQUFxRDtBQUNqRGt0QyxxQkFBTyxDQUFDLEdBQUQsQ0FBUCxHQUFlRCxJQUFJLENBQUMza0MsSUFBTCxDQUFVNEgsR0FBVixDQUFjLFVBQVNpOUIsQ0FBVCxFQUFZO0FBQUUsdUJBQU9BLENBQUMsQ0FBQzNYLENBQVQ7QUFBYSxlQUF6QyxDQUFmO0FBQ0EwWCxxQkFBTyxDQUFDLEdBQUQsQ0FBUCxHQUFlRCxJQUFJLENBQUMza0MsSUFBTCxDQUFVNEgsR0FBVixDQUFjLFVBQVNpOUIsQ0FBVCxFQUFZO0FBQUUsdUJBQU9BLENBQUMsQ0FBQ0MsQ0FBVDtBQUFhLGVBQXpDLENBQWY7QUFDSCxhQUhELE1BR08sSUFBSUgsSUFBSSxDQUFDanRDLElBQUwsS0FBYyxNQUFsQixFQUEwQjtBQUM3Qmt0QyxxQkFBTyxDQUFDLFFBQUQsQ0FBUCxHQUFvQkQsSUFBSSxDQUFDM2tDLElBQXpCO0FBQ0g7O0FBQ0QsbUJBQU80a0MsT0FBUDtBQUNILFdBVmUsQ0FBVDtBQVdQLG9CQUFVLEVBWEg7QUFXTyxvQkFBVSxFQVhqQjtBQVlQLG1CQUFTLEVBWkY7QUFZTSxvQkFBVTtBQVpoQixTQUFQO0FBY0gsT0FqQlMsQ0FBVjtBQWtCQSxhQUFPbDRCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT0MsU0FBUCxDQUFpQmcxQixPQUFqQixDQUFQO0FBQ0gsS0FyQkQsTUFxQk87QUFDSCxhQUFPLzNCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT0MsU0FBUCxDQUFpQixFQUFqQixDQUFQO0FBQ0g7QUFDSixHQTFCZSxDQUFoQixDQTFMdUMsQ0F1TnZDOztBQUNBNndCLEtBQUcsQ0FBQ3lFLFdBQUosR0FBa0JyNEIsRUFBRSxDQUFDdWMsUUFBSCxDQUFZNFosVUFBWixDQUF1QnZDLEdBQXZCLEVBQTRCLFVBQVNjLElBQVQsRUFBZUMsSUFBZixFQUFxQjtBQUMvREEsUUFBSSxDQUFDQyxRQUFMLEdBQWdCLElBQUk1MEIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFTNS9CLElBQVQsRUFBZTtBQUMvQztBQUNBLFVBQUlxakMsT0FBTyxHQUFHLElBQUl0NEIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXNlgsSUFBZixFQUFkO0FBQ0FuM0IsUUFBRSxDQUFDdTRCLEtBQUgsQ0FBU0MsS0FBVCxDQUFldmpDLElBQWYsRUFBcUIsSUFBSStLLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUIsTUFBbkIsQ0FBckIsRUFBaURpWCxPQUFqRCxFQUEwRCxJQUExRDtBQUNBcmpDLFVBQUksQ0FBQytuQixNQUFMLEdBQWNoZCxFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjVyQixPQUE3Qzs7QUFDQSxVQUFJNEQsSUFBSSxDQUFDK25CLE1BQUwsS0FBZ0I5ekIsU0FBcEIsRUFBK0I7QUFDM0IrTCxZQUFJLENBQUMrbkIsTUFBTCxHQUFjL25CLElBQUksQ0FBQytuQixNQUFMLENBQVlHLEVBQTFCOztBQUNBLGFBQUssSUFBSXR6QixHQUFULElBQWdCb0wsSUFBSSxDQUFDK25CLE1BQXJCLEVBQTZCO0FBQ3pCLGNBQUkvbkIsSUFBSSxDQUFDK25CLE1BQUwsQ0FBWXdDLGNBQVosQ0FBMkIzMUIsR0FBM0IsQ0FBSixFQUFxQztBQUNqQ21XLGNBQUUsQ0FBQ3U0QixLQUFILENBQVNFLGFBQVQsQ0FBdUJILE9BQXZCLEVBQWdDdDRCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT0MsU0FBUCxDQUFpQi9DLEVBQUUsQ0FBQzA0QixhQUFILENBQWlCN3VDLEdBQWpCLENBQWpCLENBQWhDLEVBQ3VCb0wsSUFBSSxDQUFDK25CLE1BQUwsQ0FBWW56QixHQUFaLENBRHZCO0FBRUg7QUFDSjtBQUNKLE9BUkQsTUFRTztBQUNIb0wsWUFBSSxDQUFDK25CLE1BQUwsR0FBYyxFQUFkO0FBQ0g7O0FBQ0QsYUFBT2hkLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytWLElBQVgsQ0FBZ0JDLEtBQXZCO0FBQ0gsS0FqQmUsQ0FBaEI7O0FBa0JBLFFBQUlxRCxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFTQyxHQUFULEVBQWM7QUFDdkI1NEIsUUFBRSxDQUFDc2YsT0FBSCxDQUFXdVosY0FBWCxDQUEwQixNQUExQixFQUFrQ3p1QixTQUFTLENBQUM5USxNQUE1QyxFQUFvRCxDQUFwRCxFQUF1RDZrQixRQUF2RCxFQUFpRSxJQUFqRSxFQUF1RSxJQUF2RTtBQUNBLFVBQUk4QixJQUFJLEdBQUdrRixLQUFLLENBQUM1a0IsU0FBTixDQUFnQjFGLEtBQWhCLENBQXNCaStCLElBQXRCLENBQTJCMXVCLFNBQTNCLEVBQXNDLENBQXRDLENBQVg7QUFDQSxVQUFJMlYsTUFBTSxHQUFHLElBQUkvZixFQUFFLENBQUMrNEIsUUFBSCxDQUFZNUIsSUFBaEIsQ0FBcUJ5QixHQUFyQixDQUFiO0FBRUEsVUFBSTNqQyxJQUFJLEdBQUdnckIsSUFBSSxDQUFDLENBQUQsQ0FBZjtBQUNBLFVBQUlKLFlBQVksR0FBR0ksSUFBSSxDQUFDLENBQUQsQ0FBdkI7QUFDQUEsVUFBSSxHQUFHQSxJQUFJLENBQUNwbEIsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUVBLFVBQUlpVCxNQUFNLEdBQUdpUyxNQUFNLENBQUNpWixTQUFQLENBQWlCLElBQUloNUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK0IsR0FBZixDQUFtQixRQUFuQixDQUFqQixDQUFiOztBQUNBLFVBQUl2VCxNQUFNLEtBQUs1a0IsU0FBZixFQUEwQjtBQUN0QjRrQixjQUFNLEdBQUc5TixFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCdlMsTUFBakIsQ0FBVDs7QUFDQSxZQUFJQSxNQUFNLENBQUM0RCxXQUFQLEtBQXVCeVQsS0FBM0IsRUFBa0M7QUFDOUJyWCxnQkFBTSxDQUFDcEUsT0FBUCxDQUFlLFVBQVNndEIsSUFBVCxFQUFlO0FBQzFCMTJCLGNBQUUsQ0FBQzBGLFdBQUgsQ0FBZUMsSUFBZixDQUFvQit3QixJQUFwQjtBQUNILFdBRkQ7QUFHSCxTQUpELE1BSU87QUFDSDEyQixZQUFFLENBQUMwRixXQUFILENBQWVDLElBQWYsQ0FBb0IvVSxLQUFwQjtBQUNIO0FBQ0o7O0FBRUQsVUFBSTBDLElBQUksR0FBRzJCLElBQUksQ0FBQ3d6QixVQUFMLENBQWdCLElBQUl6b0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK0IsR0FBZixDQUFtQixNQUFuQixDQUFoQixDQUFYO0FBQ0EsVUFBSTRYLGNBQWMsR0FBRzNsQyxJQUFJLENBQUMwbEMsU0FBTCxDQUFlblosWUFBZixDQUFyQjtBQUNBLFVBQUluZ0IsTUFBTSxHQUFHdTVCLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QmpaLElBQXZCLENBQWI7QUFDQSxhQUFPdmdCLE1BQVA7QUFDSCxLQXpCRDs7QUEwQkFpNUIsVUFBTSxDQUFDUSxTQUFQLEdBQW1CLElBQW5CLENBN0MrRCxDQThDL0Q7O0FBQ0FSLFVBQU0sQ0FBQ1MsT0FBUCxHQUFnQixJQUFJcDVCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUIsTUFBbkIsQ0FBaEI7QUFDQXNULFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0IsSUFBSTMwQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9COEQsTUFBcEIsQ0FBcEI7QUFFQWhFLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUIsSUFBSTMwQixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFVBQVM1L0IsSUFBVCxFQUFlO0FBQ2xELGFBQU8sSUFBSStLLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUIsRUFBbkIsQ0FBUDtBQUNILEtBRmtCLENBQW5CO0FBSUFzVCxRQUFJLENBQUMwRSxpQkFBTCxHQUF5QixJQUFJcjVCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VWLElBQWYsQ0FBb0IsVUFBUzUvQixJQUFULEVBQWVqSyxJQUFmLEVBQXFCc3VDLGdCQUFyQixFQUF1QztBQUNoRnQ1QixRQUFFLENBQUNzZixPQUFILENBQVd5VixXQUFYLENBQXVCLG1CQUF2QixFQUE0QzNxQixTQUE1QyxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDs7QUFDQSxVQUFJa3ZCLGdCQUFnQixLQUFLcHdDLFNBQXpCLEVBQW9DO0FBQ2hDb3dDLHdCQUFnQixHQUFHLElBQW5CO0FBQ0gsT0FGRCxNQUVPO0FBQ0h0NUIsVUFBRSxDQUFDc2YsT0FBSCxDQUFXMFYsV0FBWCxDQUF1QixrQkFBdkIsRUFBMkMsU0FBM0MsRUFBc0RoMUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXaWEsU0FBWCxDQUFxQkQsZ0JBQXJCLENBQXREO0FBQ0FBLHdCQUFnQixHQUFHdDVCLEVBQUUsQ0FBQzhDLEdBQUgsQ0FBT3VkLFNBQVAsQ0FBaUJpWixnQkFBakIsQ0FBbkI7QUFDSDs7QUFDRCxVQUFJNTVCLE1BQU0sR0FBRyxFQUFiOztBQUNBLFdBQUssSUFBSTg1QixRQUFULElBQXFCdmtDLElBQUksQ0FBQytuQixNQUExQixFQUFrQztBQUM5QixZQUFJL25CLElBQUksQ0FBQytuQixNQUFMLENBQVl3QyxjQUFaLENBQTJCZ2EsUUFBM0IsQ0FBSixFQUEwQztBQUN0QyxjQUFJdmtDLElBQUksQ0FBQytuQixNQUFMLENBQVl3YyxRQUFaLEVBQXNCcFcsT0FBdEIsS0FBa0NwNEIsSUFBSSxDQUFDbzRCLE9BQTNDLEVBQW9EO0FBQ2hEO0FBQ0EsZ0JBQUlrVyxnQkFBZ0IsSUFBSUUsUUFBUSxDQUFDNStCLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeEIsRUFBbUQ7QUFDL0M7QUFDSDs7QUFDRDhFLGtCQUFNLENBQUNpRyxJQUFQLENBQVkzRixFQUFFLENBQUM4QyxHQUFILENBQU9DLFNBQVAsQ0FBaUIvQyxFQUFFLENBQUMwNEIsYUFBSCxDQUFpQmMsUUFBakIsQ0FBakIsQ0FBWjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxhQUFPLElBQUl4NUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXc1gsSUFBZixDQUFvQmwzQixNQUFwQixDQUFQO0FBQ0gsS0FyQndCLENBQXpCO0FBdUJBaTFCLFFBQUksQ0FBQzhFLGtCQUFMLEdBQTBCLElBQUl6NUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFTNS9CLElBQVQsRUFBZWpLLElBQWYsRUFBcUJzdUMsZ0JBQXJCLEVBQXVDO0FBQ2pGdDVCLFFBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsb0JBQXZCLEVBQTZDM3FCLFNBQTdDLEVBQXdELENBQXhELEVBQTJELENBQTNEOztBQUNBLFVBQUlrdkIsZ0JBQWdCLEtBQUtwd0MsU0FBekIsRUFBb0M7QUFDaENvd0Msd0JBQWdCLEdBQUcsSUFBbkI7QUFDSCxPQUZELE1BRU87QUFDSHQ1QixVQUFFLENBQUNzZixPQUFILENBQVcwVixXQUFYLENBQXVCLGtCQUF2QixFQUEyQyxTQUEzQyxFQUFzRGgxQixFQUFFLENBQUNzZixPQUFILENBQVdpYSxTQUFYLENBQXFCRCxnQkFBckIsQ0FBdEQ7QUFDQUEsd0JBQWdCLEdBQUd0NUIsRUFBRSxDQUFDOEMsR0FBSCxDQUFPdWQsU0FBUCxDQUFpQmlaLGdCQUFqQixDQUFuQjtBQUNIOztBQUNELFVBQUk1NUIsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsV0FBSyxJQUFJODVCLFFBQVQsSUFBcUJ2a0MsSUFBSSxDQUFDK25CLE1BQTFCLEVBQWtDO0FBQzlCLFlBQUkvbkIsSUFBSSxDQUFDK25CLE1BQUwsQ0FBWXdDLGNBQVosQ0FBMkJnYSxRQUEzQixDQUFKLEVBQTBDO0FBQ3RDLGNBQUl2a0MsSUFBSSxDQUFDK25CLE1BQUwsQ0FBWXdjLFFBQVosRUFBc0JwVyxPQUF0QixLQUFrQ3A0QixJQUFJLENBQUNvNEIsT0FBM0MsRUFBb0Q7QUFDaEQsZ0JBQUlrVyxnQkFBZ0IsSUFBSUUsUUFBUSxDQUFDNStCLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeEIsRUFBbUQ7QUFDL0M7QUFDSDs7QUFDRDhFLGtCQUFNLENBQUNpRyxJQUFQLENBQVkxUSxJQUFJLENBQUMrbkIsTUFBTCxDQUFZd2MsUUFBWixDQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sSUFBSXg1QixFQUFFLENBQUNzZixPQUFILENBQVdzWCxJQUFmLENBQW9CbDNCLE1BQXBCLENBQVA7QUFDSCxLQXBCeUIsQ0FBMUI7QUFxQkgsR0FsR2lCLEVBa0dmLGFBbEdlLENBQWxCO0FBbUdBazBCLEtBQUcsQ0FBQzlpQyxPQUFKLEdBQWNrUCxFQUFFLENBQUN1YyxRQUFILENBQVltZCxnQkFBWixDQUE2QjlGLEdBQUcsQ0FBQ3lFLFdBQWpDLENBQWQ7QUFFQXpFLEtBQUcsQ0FBQytGLGdCQUFKLEdBQXVCLElBQUkzNUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixZQUFXO0FBQ2xENzBCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsa0JBQXZCLEVBQTJDM3FCLFNBQTNDLEVBQXNELENBQXRELEVBQXlELENBQXpEO0FBQ0EsV0FBT3dwQixHQUFHLENBQUM5aUMsT0FBWDtBQUNILEdBSHNCLENBQXZCO0FBS0E4aUMsS0FBRyxDQUFDZ0csZ0JBQUosR0FBdUIsSUFBSTU1QixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFVBQVNnRixlQUFULEVBQTBCO0FBQ2pFNzVCLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsa0JBQXZCLEVBQTJDM3FCLFNBQTNDLEVBQXNELENBQXRELEVBQXlELENBQXpEO0FBQ0F5dkIsbUJBQWUsR0FBRzc1QixFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCd1osZUFBakIsQ0FBbEI7QUFDQTc1QixNQUFFLENBQUNpZCxnQkFBSCxDQUFvQixPQUFwQixFQUE2Qm53QixPQUE3QixDQUFxQ2tCLG1CQUFyQyxDQUF5RDZyQyxlQUF6RDtBQUNILEdBSnNCLENBQXZCO0FBTUFqRyxLQUFHLENBQUNrRyxjQUFKLEdBQXFCLElBQUk5NUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFTdHBCLElBQVQsRUFBZTtBQUNwRHZMLE1BQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDM3FCLFNBQXpDLEVBQW9ELENBQXBELEVBQXVELENBQXZEO0FBQ0EsUUFBSWhnQixLQUFLLEdBQUc0VixFQUFFLENBQUNpZCxnQkFBSCxDQUFvQixPQUFwQixDQUFaO0FBQ0ExUixRQUFJLEdBQUd2TCxFQUFFLENBQUM4QyxHQUFILENBQU91ZCxTQUFQLENBQWlCOVUsSUFBakIsRUFBdUJsRCxLQUF2QixDQUE2QixHQUE3QixDQUFQOztBQUNBLFNBQUssSUFBSUUsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHZ0QsSUFBSSxDQUFDalMsTUFBdkIsRUFBK0JpUCxDQUFDLEVBQWhDLEVBQW9DO0FBQ2hDbmUsV0FBSyxHQUFHQSxLQUFLLENBQUNtaEIsSUFBSSxDQUFDaEQsQ0FBRCxDQUFMLENBQWI7QUFDSDs7QUFDRCxXQUFPdkksRUFBRSxDQUFDOEMsR0FBSCxDQUFPQyxTQUFQLENBQWlCM1ksS0FBSyxFQUF0QixDQUFQO0FBQ0gsR0FSb0IsQ0FBckI7QUFVQXdwQyxLQUFHLENBQUNtRyw4QkFBSixHQUFxQyxJQUFJLzVCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VWLElBQWYsQ0FBb0IsWUFBVztBQUNoRTcwQixNQUFFLENBQUNzZixPQUFILENBQVd5VixXQUFYLENBQXVCLGtCQUF2QixFQUEyQzNxQixTQUEzQyxFQUFzRCxDQUF0RCxFQUF5RCxDQUF6RDtBQUNBcEssTUFBRSxDQUFDa2hCLDJCQUFIO0FBQ0gsR0FIb0MsQ0FBckM7QUFLQSxTQUFPMFMsR0FBUDtBQUNILENBeFZNLEM7Ozs7Ozs7Ozs7OztBQ1JQO0FBQUE7QUFBTyxJQUFJRCxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQVNscEMsSUFBVCxFQUFlO0FBQ3ZDLE1BQUltcEMsR0FBSixFQUFTQyxhQUFUO0FBQ0FELEtBQUcsR0FBRztBQUFDRSxZQUFRLEVBQUU7QUFBWCxHQUFOO0FBRUE7Ozs7QUFJQSxNQUFJa0csT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBU3RGLElBQVQsRUFBZUMsSUFBZixFQUFxQjtBQUMvQkEsUUFBSSxDQUFDQyxRQUFMLEdBQWdCLElBQUk1MEIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXdVYsSUFBZixDQUFvQixVQUFVNS9CLElBQVYsRUFBZ0IzQixJQUFoQixFQUFzQjtBQUN0RDBNLFFBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3lWLFdBQVgsQ0FBdUIsVUFBdkIsRUFBbUMzcUIsU0FBbkMsRUFBOEMsQ0FBOUMsRUFBaUQsQ0FBakQ7QUFDQXBLLFFBQUUsQ0FBQ3NmLE9BQUgsQ0FBVzBWLFdBQVgsQ0FBdUIsTUFBdkIsRUFBK0IsVUFBL0IsRUFBMkNoMUIsRUFBRSxDQUFDc2YsT0FBSCxDQUFXMmEsYUFBWCxDQUF5QjNtQyxJQUF6QixDQUEzQztBQUNBMkIsVUFBSSxDQUFDM0IsSUFBTCxHQUFZLEVBQVo7QUFDQSxVQUFJNG1DLElBQUksR0FBR2w2QixFQUFFLENBQUN1NEIsS0FBSCxDQUFTMkIsSUFBVCxDQUFjNW1DLElBQWQsQ0FBWDtBQUNBLFVBQUlzRixJQUFKOztBQUNBLFNBQUc7QUFDQ0EsWUFBSSxHQUFHb0gsRUFBRSxDQUFDdTRCLEtBQUgsQ0FBUzRCLFFBQVQsQ0FBa0JELElBQWxCLENBQVA7O0FBQ0EsWUFBSXRoQyxJQUFJLEtBQUsxUCxTQUFiLEVBQXdCO0FBQ3BCK0wsY0FBSSxDQUFDM0IsSUFBTCxDQUFVcVMsSUFBVixDQUFlLElBQUl5MEIsT0FBSixDQUFZeGhDLElBQVosQ0FBZjtBQUNIO0FBQ0osT0FMRCxRQUtTQSxJQUFJLEtBQUsxUCxTQUxsQjs7QUFNQSxhQUFPOFcsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK1YsSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxLQWJlLENBQWhCO0FBZUFYLFFBQUksQ0FBQzBGLFFBQUwsR0FBZ0IsSUFBSXI2QixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFmLENBQW9CLFVBQVM1L0IsSUFBVCxFQUFlO0FBQy9DLFVBQU1xbEMsVUFBVSxHQUFHLEVBQW5COztBQUNBLFdBQUssSUFBSS94QixDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUd0VCxJQUFJLENBQUMzQixJQUFMLENBQVVnRyxNQUE1QixFQUFvQ2lQLENBQUMsRUFBckMsRUFBeUM7QUFDckMsWUFBTW11QixJQUFJLEdBQUd6aEMsSUFBSSxDQUFDM0IsSUFBTCxDQUFVaVYsQ0FBVixFQUFhZ3lCLEtBQWIsRUFBYjs7QUFDQSxZQUFJN0QsSUFBSSxLQUFLeHRDLFNBQWIsRUFBd0I7QUFDcEJveEMsb0JBQVUsQ0FBQzMwQixJQUFYLENBQWdCK3dCLElBQWhCO0FBQ0g7QUFDSjs7QUFDRHpoQyxVQUFJLENBQUMzQixJQUFMLEdBQVlnbkMsVUFBWjtBQUNBLGFBQU90NkIsRUFBRSxDQUFDdTRCLEtBQUgsQ0FBUzJCLElBQVQsQ0FBYyxJQUFJbDZCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3NYLElBQWYsQ0FBb0IwRCxVQUFwQixDQUFkLENBQVA7QUFDSCxLQVZlLENBQWhCO0FBWUE7Ozs7QUFJQTNGLFFBQUksQ0FBQ3A3QixHQUFMLEdBQVcsSUFBSXlHLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3VWLElBQWYsQ0FBb0IsVUFBUzUvQixJQUFULEVBQWV5aEMsSUFBZixFQUFxQjtBQUNoRHpoQyxVQUFJLENBQUMzQixJQUFMLENBQVVxUyxJQUFWLENBQWUsSUFBSXkwQixPQUFKLENBQVkxRCxJQUFaLENBQWY7QUFDSCxLQUZVLENBQVg7QUFHSCxHQW5DRDs7QUFvQ0E5QyxLQUFHLENBQUNvRyxPQUFKLEdBQWNoNkIsRUFBRSxDQUFDdWMsUUFBSCxDQUFZNFosVUFBWixDQUF1QnZDLEdBQXZCLEVBQTRCb0csT0FBNUIsRUFBcUMsU0FBckMsRUFBZ0QsRUFBaEQsQ0FBZDtBQUVBLFNBQU9wRyxHQUFQO0FBQ0gsQ0EvQ00sQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFBLElBQUk0RyxpQkFBSjs7QUFDQSxJQUFJO0FBQ0FBLG1CQUFpQixHQUFHQyxZQUFwQjtBQUNBLE1BQUk3RyxHQUFHLEdBQUcsMkJBQVY7QUFDQTRHLG1CQUFpQixDQUFDRSxPQUFsQixDQUEwQjlHLEdBQTFCLEVBQStCQSxHQUEvQjtBQUNBNEcsbUJBQWlCLENBQUNHLFVBQWxCLENBQTZCL0csR0FBN0I7QUFDSCxDQUxELENBS0UsT0FBTXIwQixDQUFOLEVBQVM7QUFDUGk3QixtQkFBaUIsR0FBRztBQUNoQkksU0FBSyxFQUFTLEVBREU7QUFFaEJGLFdBQU8sRUFBTyxpQkFBU3B3QyxFQUFULEVBQWF3VixHQUFiLEVBQWtCO0FBQUUsYUFBTyxLQUFLODZCLEtBQUwsQ0FBV3R3QyxFQUFYLElBQWlCdXdDLE1BQU0sQ0FBQy82QixHQUFELENBQTlCO0FBQXNDLEtBRnhEO0FBR2hCZzdCLFdBQU8sRUFBTyxpQkFBU3h3QyxFQUFULEVBQWE7QUFBRSxhQUFPLEtBQUtzd0MsS0FBTCxDQUFXcGIsY0FBWCxDQUEwQmwxQixFQUExQixJQUFnQyxLQUFLc3dDLEtBQUwsQ0FBV3R3QyxFQUFYLENBQWhDLEdBQWlELElBQXhEO0FBQStELEtBSDVFO0FBSWhCcXdDLGNBQVUsRUFBSSxvQkFBU3J3QyxFQUFULEVBQWE7QUFBRSxhQUFPLE9BQU8sS0FBS3N3QyxLQUFMLENBQVd0d0MsRUFBWCxDQUFkO0FBQStCLEtBSjVDO0FBS2hCbWMsU0FBSyxFQUFTLGlCQUFXO0FBQUUsYUFBTyxLQUFLbTBCLEtBQUwsR0FBYSxFQUFwQjtBQUF5QjtBQUxwQyxHQUFwQjtBQU9IO0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFXTyxTQUFTendDLG1CQUFULENBQTZCaWlDLFNBQTdCLEVBQXdDO0FBQzNDLE9BQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0g7QUFDRDs7Ozs7Ozs7QUFPQWppQyxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCaXdCLEdBQTlCLEdBQXFDLFVBQVMzbUMsR0FBVCxFQUFjK2UsS0FBZCxFQUFxQjtBQUN0RDR4QixtQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEIsS0FBS3RPLFNBQUwsR0FBZSxHQUFmLEdBQW1CdmlDLEdBQW5CLEdBQXVCLFFBQWpELEVBQTJEK2UsS0FBM0Q7QUFDQTR4QixtQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEIsS0FBS3RPLFNBQUwsR0FBZSxHQUFmLEdBQW1CdmlDLEdBQW5CLEdBQXVCLFlBQWpELEVBQStEMkksQ0FBQyxDQUFDMDdCLEdBQUYsRUFBL0Q7QUFDSCxDQUhEO0FBS0E7Ozs7Ozs7QUFLQS9qQyxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCeUMsTUFBOUIsR0FBdUMsVUFBU25aLEdBQVQsRUFBYztBQUNqRDJ3QyxtQkFBaUIsQ0FBQ0csVUFBbEIsQ0FBNkIsS0FBS3ZPLFNBQUwsR0FBZSxHQUFmLEdBQW1CdmlDLEdBQW5CLEdBQXVCLFFBQXBEO0FBQ0Eyd0MsbUJBQWlCLENBQUNHLFVBQWxCLENBQTZCLEtBQUt2TyxTQUFMLEdBQWUsR0FBZixHQUFtQnZpQyxHQUFuQixHQUF1QixZQUFwRDtBQUNILENBSEQ7QUFLQTs7Ozs7OztBQUtBTSxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCclcsR0FBOUIsR0FBb0MsVUFBU0wsR0FBVCxFQUFjO0FBQzlDLFNBQU8yd0MsaUJBQWlCLENBQUNNLE9BQWxCLENBQTBCLEtBQUsxTyxTQUFMLEdBQWUsR0FBZixHQUFtQnZpQyxHQUFuQixHQUF1QixRQUFqRCxDQUFQO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7OztBQU1BTSxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCMndCLE9BQTlCLEdBQXdDLFVBQVNybkMsR0FBVCxFQUFjO0FBQ2xELFNBQU9vMEIsUUFBUSxDQUFDdWMsaUJBQWlCLENBQUNNLE9BQWxCLENBQTBCLEtBQUsxTyxTQUFMLEdBQWUsR0FBZixHQUFtQnZpQyxHQUFuQixHQUF1QixZQUFqRCxDQUFELENBQWY7QUFDSCxDQUZEO0FBSUE7Ozs7Ozs7Ozs7QUFRQU0sbUJBQW1CLENBQUNvVyxTQUFwQixDQUE4Qm92QixVQUE5QixHQUEyQyxVQUFTOWxDLEdBQVQsRUFBY0MsWUFBZCxFQUE0QjtBQUNuRSxNQUFJLEtBQUtHLEdBQUwsQ0FBU0osR0FBVCxDQUFKLEVBQW1CO0FBQ2YsV0FBTyxLQUFLSyxHQUFMLENBQVNMLEdBQVQsQ0FBUDtBQUNILEdBRkQsTUFFTztBQUNILFNBQUsybUMsR0FBTCxDQUFTM21DLEdBQVQsRUFBY0MsWUFBZDtBQUNBLFdBQU9BLFlBQVA7QUFDSDtBQUNKLENBUEQ7QUFTQTs7Ozs7OztBQUtBSyxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCdFcsR0FBOUIsR0FBb0MsVUFBU0osR0FBVCxFQUFjO0FBQzlDLFNBQU8yd0MsaUJBQWlCLENBQUNNLE9BQWxCLENBQTBCLEtBQUsxTyxTQUFMLEdBQWUsR0FBZixHQUFtQnZpQyxHQUFuQixHQUF1QixRQUFqRCxNQUErRCxJQUF0RTtBQUNILENBRkQ7QUFJQTs7Ozs7Ozs7OztBQVFBTSxtQkFBbUIsQ0FBQ29XLFNBQXBCLENBQThCdzZCLE1BQTlCLEdBQXVDLFVBQVNseEMsR0FBVCxFQUFjbXhDLFdBQWQsRUFBMkI7QUFDOUQsTUFBSUMsV0FBVyxHQUFHVCxpQkFBaUIsQ0FBQ00sT0FBbEIsQ0FBMEIsS0FBSzFPLFNBQUwsR0FBZSxHQUFmLEdBQW1CdmlDLEdBQW5CLEdBQXVCLFlBQWpELENBQWxCO0FBQ0EsU0FBUW14QyxXQUFXLElBQUlDLFdBQVcsR0FBQyxJQUFuQztBQUNILENBSEQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHTyxJQUFNM0wsVUFBVSwwMkZBQWhCO0FBd0VBLElBQU0zdUIsWUFBYjtBQUVJLHdCQUFZUCxJQUFaLEVBQWtCK0YsR0FBbEIsRUFBdUI7QUFBQTs7QUFDbkIsU0FBSy9GLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUsrRixHQUFMLEdBQVdBLEdBQVg7QUFFQSxTQUFLKzBCLGVBQUwsR0FBdUIsQ0FBQyxVQUFELEVBQWEsU0FBYixFQUF3QixhQUF4QixFQUNDLGFBREQsRUFDZ0IsVUFEaEIsRUFDNEIsY0FENUIsQ0FBdkIsQ0FKbUIsQ0FPbkI7QUFDSDtBQUVEOzs7Ozs7OztBQVpKO0FBQUE7QUFBQSxpQ0FrQmlCQyxTQWxCakIsRUFrQjRCO0FBQ3BCLFVBQUl6N0IsTUFBTSxHQUFHLEVBQWI7QUFDQSxVQUFJK2tCLE9BQU8sR0FBRyxFQUFkOztBQUNBLFVBQUksQ0FBQyxLQUFLcmtCLElBQUwsQ0FBVWhXLEtBQVYsQ0FBZ0IwQyxPQUFoQixDQUF3QmdCLGNBQXhCLEVBQUwsRUFBK0M7QUFDM0MsYUFBSyxJQUFJMHJDLFFBQVQsSUFBcUIyQixTQUFyQixFQUFnQztBQUM1QixjQUFJdnlCLEtBQUssR0FBR3V5QixTQUFTLENBQUMzQixRQUFELENBQXJCOztBQUNBLGNBQUksS0FBSzBCLGVBQUwsQ0FBcUJ6L0IsT0FBckIsQ0FBNkIrOUIsUUFBN0IsTUFBMkMsQ0FBQyxDQUFoRCxFQUFtRDtBQUMvQ0Esb0JBQVEsR0FBR0EsUUFBUSxDQUFDdnJCLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsRUFBMUIsRUFDTkEsT0FETSxDQUNFLE9BREYsRUFDVyxFQURYLENBQVg7QUFFQSxnQkFBSW10QixNQUFNLFNBQVY7O0FBQ0EsZ0JBQUk7QUFDQUEsb0JBQU0sR0FBR3o2QixZQUFZLENBQUMwNkIsVUFBYixDQUF3QjdCLFFBQXhCLEVBQWtDNXdCLEtBQWxDLENBQVQ7QUFDSCxhQUZELENBRUUsZ0JBQU07QUFDSnd5QixvQkFBTSxHQUFHO0FBQUMsd0JBQVE1QixRQUFUO0FBQW1CLHdCQUFRLFNBQTNCO0FBQXNDLHlCQUFTNXdCLEtBQUssQ0FBQ25hLFFBQU47QUFBL0MsZUFBVDtBQUNIOztBQUNELGdCQUFJMnNDLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ2pCMTdCLG9CQUFNLENBQUNpRyxJQUFQLENBQVl5MUIsTUFBWjtBQUNILGFBRkQsTUFFTyxJQUFJeHlCLEtBQUssQ0FBQzhJLFdBQU4sS0FBc0IxUixFQUFFLENBQUNzZixPQUFILENBQVd0QyxNQUFyQyxFQUE2QztBQUNoRHlILHFCQUFPLENBQUM5ZSxJQUFSLENBQWFpRCxLQUFLLENBQUN1VSxFQUFOLENBQVMyVyxRQUFULENBQWtCcUUsQ0FBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxhQUFPO0FBQUMsc0JBQWN6NEIsTUFBZjtBQUF1QixtQkFBVytrQjtBQUFsQyxPQUFQO0FBQ0g7QUExQ0w7QUFBQTs7QUE0Q0k7Ozs7OztBQTVDSiwrQkFrRHNCK1UsUUFsRHRCLEVBa0RnQzV3QixLQWxEaEMsRUFrRHVDMHlCLFVBbER2QyxFQWtEbUQ7QUFDM0MsVUFBSTF5QixLQUFLLEtBQUsxZixTQUFkLEVBQXlCO0FBQ3JCLGVBQU87QUFBQyxrQkFBUXN3QyxRQUFUO0FBQ0gsa0JBQVEsU0FETDtBQUVILG1CQUFTO0FBRk4sU0FBUDtBQUlIOztBQUNELGNBQVE1d0IsS0FBSyxDQUFDOEksV0FBZDtBQUNJLGFBQUsxUixFQUFFLENBQUNzZixPQUFILENBQVd1VixJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVEyRSxRQUFUO0FBQ0gsb0JBQVEsVUFETDtBQUVILHFCQUNLNXdCLEtBQUssQ0FBQzJ5QixTQUFOLENBQWdCQyxXQUFoQixLQUFnQ3R5QyxTQUFoQyxHQUNHLGlCQUFlMGYsS0FBSyxDQUFDMnlCLFNBQU4sQ0FBZ0JDLFdBQWhCLENBQTRCNXRCLElBQTVCLENBQWlDLElBQWpDLENBRGxCLEdBRUc7QUFMTCxXQUFQOztBQU9KLGFBQUs1TixFQUFFLENBQUNzZixPQUFILENBQVd0QyxNQUFoQjtBQUF3QixpQkFBTyxJQUFQOztBQUN4QixhQUFLaGQsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK0IsR0FBaEI7QUFDSSxjQUFJaWEsVUFBVSxJQUFJMXlCLEtBQUssQ0FBQ3V2QixDQUFOLENBQVE3K0IsTUFBUixJQUFrQixFQUFwQyxFQUF3QztBQUNwQyxtQkFBTztBQUFDLHNCQUFRa2dDLFFBQVQ7QUFDSCxzQkFBUSxRQURMO0FBRUgsdUJBQVM1d0IsS0FBSyxDQUFDMlgsRUFBTixHQUFXNFg7QUFGakIsYUFBUDtBQUlILFdBTEQsTUFLTztBQUNILG1CQUFPO0FBQUMsc0JBQVFxQixRQUFUO0FBQ0gsc0JBQVEsUUFETDtBQUVILHVCQUFTLE1BQUk1d0IsS0FBSyxDQUFDNnlCLFNBQU4sRUFBSixHQUFzQjtBQUY1QixhQUFQO0FBSUg7O0FBQ0wsYUFBS3o3QixFQUFFLENBQUNzZixPQUFILENBQVcrVixJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVFtRSxRQUFUO0FBQ0gsb0JBQVEsTUFETDtBQUVILHFCQUFTO0FBRk4sV0FBUDs7QUFJSixhQUFLeDVCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV29jLElBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUWxDLFFBQVQ7QUFDSCxvQkFBUSxTQURMO0FBRUgscUJBQVM1d0IsS0FBSyxDQUFDMlgsRUFBTixHQUFXNFg7QUFGakIsV0FBUDs7QUFJSixhQUFLbjRCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3FjLEtBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUW5DLFFBQVQ7QUFDSCxvQkFBUSxVQUFVNXdCLEtBQUssQ0FBQ2d6QixNQUFoQixHQUF5QixTQUF6QixHQUFvQyxPQUR6QztBQUVILHFCQUFTaHpCLEtBQUssQ0FBQzJYLEVBQU4sR0FBVzRYO0FBRmpCLFdBQVA7O0FBSUosYUFBS240QixFQUFFLENBQUNzZixPQUFILENBQVd1YyxJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVFyQyxRQUFUO0FBQ0gsb0JBQVEsU0FETDtBQUVILHFCQUFTNXdCLEtBQUssQ0FBQzJYLEVBQU4sR0FBVzRYO0FBRmpCLFdBQVA7O0FBSUosYUFBS240QixFQUFFLENBQUNzZixPQUFILENBQVd3YyxNQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVF0QyxRQUFUO0FBQ0gsb0JBQVEsT0FETDtBQUVILHFCQUFTNXdCLEtBQUssQ0FBQzJYLEVBQU4sR0FBVzRYO0FBRmpCLFdBQVA7O0FBSUosYUFBS240QixFQUFFLENBQUNzZixPQUFILENBQVdpWSxLQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVFpQyxRQUFUO0FBQ0gsb0JBQVEsT0FETDtBQUVILHFCQUFTNXdCLEtBQUssQ0FBQzJYLEVBQU4sR0FBVzRYO0FBRmpCLFdBQVA7O0FBSUosYUFBS240QixFQUFFLENBQUNzZixPQUFILENBQVdzWCxJQUFoQjtBQUNJLGNBQUlodUIsS0FBSyxDQUFDdXZCLENBQU4sQ0FBUTcrQixNQUFSLElBQWtCLEVBQXRCLEVBQTBCO0FBQ3RCLG1CQUFPO0FBQUMsc0JBQVFrZ0MsUUFBVDtBQUNILHNCQUFRLE1BREw7QUFFSCx1QkFBUzV3QixLQUFLLENBQUMyWCxFQUFOLEdBQVc0WCxDQUZqQjtBQUdILDZCQUFldnZCO0FBSFosYUFBUDtBQUtILFdBTkQsTUFNTztBQUNILG1CQUFPO0FBQUMsc0JBQVE0d0IsUUFBVDtBQUNILHNCQUFRLE1BREw7QUFFSCx1QkFBUyxVQUFRNXdCLEtBQUssQ0FBQ3V2QixDQUFOLENBQVE3K0IsTUFBaEIsR0FBdUIsZ0JBRjdCO0FBR0gsNkJBQWVzUDtBQUhaLGFBQVA7QUFLSDs7QUFDTCxhQUFLNUksRUFBRSxDQUFDc2YsT0FBSCxDQUFXNlgsSUFBaEI7QUFDSSxpQkFBTztBQUFDLG9CQUFRcUMsUUFBVDtBQUNILG9CQUFRLFlBREw7QUFFSCxxQkFBUzV3QixLQUFLLENBQUMyWCxFQUFOLEdBQVc0WDtBQUZqQixXQUFQOztBQUlKLGFBQUs0RCxNQUFMO0FBQ0ksaUJBQU87QUFBQyxvQkFBUXZDLFFBQVQ7QUFDSCxvQkFBUTV3QixLQUFLLEdBQUcsQ0FBUixLQUFjLENBQWQsR0FBa0IsU0FBbEIsR0FBOEIsT0FEbkM7QUFFSCxxQkFBU0E7QUFGTixXQUFQOztBQUlKLGFBQUtpeUIsTUFBTDtBQUNJLGlCQUFPO0FBQUMsb0JBQVFyQixRQUFUO0FBQ0gsb0JBQVEsUUFETDtBQUVILHFCQUFTNXdCO0FBRk4sV0FBUDs7QUFJSixhQUFLZ2IsT0FBTDtBQUNJLGlCQUFPO0FBQUMsb0JBQVE0VixRQUFUO0FBQ0gsb0JBQVEsU0FETDtBQUVILHFCQUFVNXdCLEtBQUssR0FBRyxNQUFILEdBQVc7QUFGdkIsV0FBUDs7QUFJSjtBQUNJLGlCQUFPO0FBQUMsb0JBQVE0d0IsUUFBVDtBQUNILG9CQUFRNXdCLEtBQUssQ0FBQ3dhLE9BQU4sS0FBa0JsNkIsU0FBbEIsR0FBOEIwZixLQUE5QixHQUFzQ0EsS0FBSyxDQUFDd2EsT0FEakQ7QUFFSCxxQkFBU3hhLEtBQUssQ0FBQzJYLEVBQU4sS0FBYXIzQixTQUFiLEdBQXlCMGYsS0FBekIsR0FBaUNBLEtBQUssQ0FBQzJYLEVBQU4sR0FBVzRYO0FBRmxELFdBQVA7QUF2RlI7QUE0Rkg7QUFySkw7O0FBQUE7QUFBQSxJLENBd0pBLHVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hPQTs7Ozs7O0FBTUEsU0FBUzZELGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxRQUEvQixFQUF5QztBQUNyQyxTQUFPQSxRQUFRLENBQUN6Z0MsT0FBVCxDQUFpQndnQyxNQUFqQixJQUEyQixDQUFDLENBQW5DO0FBQ0g7QUFFRDs7Ozs7Ozs7OztBQVFBLFNBQVNFLFdBQVQsQ0FBcUJuUixLQUFyQixFQUE0QjtBQUN4QixNQUFJb1IsQ0FBQyxHQUFHcFIsS0FBSyxDQUFDcVIsTUFBTixFQUFSOztBQUNBLE9BQUksSUFBSTl6QixDQUFDLEdBQUMsQ0FBVixFQUFhQSxDQUFDLEdBQUM2ekIsQ0FBQyxDQUFDOWlDLE1BQWpCLEVBQXlCLEVBQUVpUCxDQUEzQixFQUE4QjtBQUMxQixTQUFJLElBQUkrekIsQ0FBQyxHQUFDL3pCLENBQUMsR0FBQyxDQUFaLEVBQWUrekIsQ0FBQyxHQUFDRixDQUFDLENBQUM5aUMsTUFBbkIsRUFBMkIsRUFBRWdqQyxDQUE3QixFQUFnQztBQUM1QixVQUFHRixDQUFDLENBQUM3ekIsQ0FBRCxDQUFELEtBQVM2ekIsQ0FBQyxDQUFDRSxDQUFELENBQWIsRUFBa0I7QUFBQ0YsU0FBQyxDQUFDekssTUFBRixDQUFTMkssQ0FBQyxFQUFWLEVBQWMsQ0FBZDtBQUFrQjtBQUN4QztBQUNKOztBQUVELFNBQU9GLENBQVA7QUFDSDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTRyxXQUFULENBQXFCdlIsS0FBckIsRUFBNEJ3UixRQUE1QixFQUFzQ0MsV0FBdEMsRUFBbUQ7QUFDL0MsTUFBSUMsU0FBUyxHQUFHMVIsS0FBSyxDQUFDMWEsTUFBTixDQUFhLFVBQVNvbUIsSUFBVCxFQUFlO0FBQ3hDLFdBQU8rRixXQUFXLENBQUNoaEMsT0FBWixDQUFvQmk3QixJQUFwQixNQUE4QixDQUFDLENBQXRDO0FBQ0gsR0FGZSxDQUFoQjtBQUdBLFNBQU95RixXQUFXLENBQUNPLFNBQVMsQ0FBQ0wsTUFBVixDQUFpQkcsUUFBakIsQ0FBRCxDQUFsQjtBQUNIO0FBRUQ7Ozs7Ozs7QUFLQSxTQUFTRyxTQUFULENBQW1CN1gsSUFBbkIsRUFBeUI7QUFDckI7QUFDQSxNQUFJOFgsS0FBSyxHQUFHOVgsSUFBSSxDQUFDK1gsUUFBTCxJQUFpQixDQUFqQixHQUFxQmo1QixRQUFRLENBQUNrNUIsY0FBVCxDQUF3QmhZLElBQUksQ0FBQ2lZLFNBQTdCLENBQXJCLEdBQStEalksSUFBSSxDQUFDNlgsU0FBTCxDQUFlLEtBQWYsQ0FBM0UsQ0FGcUIsQ0FJckI7O0FBQ0EsTUFBSUssS0FBSyxHQUFHbFksSUFBSSxDQUFDbVksVUFBakI7O0FBQ0EsU0FBTUQsS0FBTixFQUFhO0FBQ1RKLFNBQUssQ0FBQzl0QixXQUFOLENBQWtCNnRCLFNBQVMsQ0FBQ0ssS0FBRCxDQUEzQjtBQUNBQSxTQUFLLEdBQUdBLEtBQUssQ0FBQ0UsV0FBZDtBQUNIOztBQUVELFNBQU9OLEtBQVA7QUFDSDtBQUVEOzs7Ozs7OztBQU1PLFNBQVNPLE1BQVQsQ0FBZ0I5YixHQUFoQixFQUFxQjtBQUN4QixTQUFPQSxHQUFHLENBQUNwVCxPQUFKLENBQVksVUFBWixFQUF3QixNQUF4QixDQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBS08sU0FBU25FLElBQVQsQ0FBY3VYLEdBQWQsRUFBbUI7QUFDdEIsU0FBT0EsR0FBRyxDQUFDcFQsT0FBSixDQUFZLEtBQVosRUFBbUIsR0FBbkIsRUFBd0JwWCxXQUF4QixFQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBS08sU0FBUytILFVBQVQsQ0FBb0J3K0IsQ0FBcEIsRUFBdUI7QUFDMUIsTUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDdkIsV0FBTyxFQUFQO0FBQ0g7O0FBQ0QsU0FBT0EsQ0FBQyxDQUFDajFCLE1BQUYsQ0FBUyxDQUFULEVBQVl1SSxXQUFaLEtBQTRCMHNCLENBQUMsQ0FBQ3ZpQyxLQUFGLENBQVEsQ0FBUixDQUFuQztBQUNIO0FBRUQ7Ozs7Ozs7O0FBT0EsU0FBU3dpQyxhQUFULENBQXVCeGtDLEdBQXZCLEVBQTJCSCxHQUEzQixFQUFnQztBQUM1QixTQUFPRCxJQUFJLENBQUM2a0MsS0FBTCxDQUFXN2tDLElBQUksQ0FBQzhrQyxNQUFMLE1BQWU3a0MsR0FBRyxHQUFDRyxHQUFKLEdBQVEsQ0FBdkIsSUFBMEJBLEdBQXJDLENBQVA7QUFDSDtBQUVEOzs7Ozs7Ozs7QUFPTyxTQUFTeUwsVUFBVCxDQUFvQitjLEdBQXBCLEVBQXlCO0FBQzVCLFNBQU9BLEdBQUcsQ0FBQ3BULE9BQUosQ0FBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQ0ZBLE9BREUsQ0FDTSxJQUROLEVBQ1ksTUFEWixFQUVGQSxPQUZFLENBRU0sSUFGTixFQUVZLE1BRlosRUFHRkEsT0FIRSxDQUdNLElBSE4sRUFHWSxRQUhaLEVBSUZBLE9BSkUsQ0FJTSxJQUpOLEVBSVksUUFKWixDQUFQO0FBS0g7QUFFRDs7OztBQUdBLElBQUksT0FBTzJHLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDaENBLFNBQU8sQ0FBQzRvQixZQUFSLENBQXFCajlCLFNBQXJCLENBQStCazlCLE9BQS9CLEdBQXlDLFlBQVc7QUFDaEQsUUFBSUMsT0FBTyxHQUFHLEtBQUtDLFVBQUwsRUFBZDtBQUNBLFFBQUkxMkIsS0FBSyxHQUFHeTJCLE9BQU8sQ0FBQ0UsU0FBUixHQUFvQixDQUFoQztBQUFBLFFBQ0lwM0IsTUFBTSxHQUFHazNCLE9BQU8sQ0FBQ0csVUFEckI7QUFFQSxRQUFJQyxNQUFNLEdBQUcsS0FBS0MsWUFBTCxDQUFrQixLQUFsQixDQUFiO0FBQ0EsUUFBSTNGLENBQUMsR0FBRyxDQUFSO0FBQUEsUUFBVzVYLENBQUMsR0FBRyxDQUFmO0FBQUEsUUFDSXdkLGdCQUFnQixHQUFHeDNCLE1BQU0sR0FBQ3MzQixNQUFNLENBQUN4a0MsTUFEckM7O0FBRUEsU0FBSyxJQUFJaVAsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3UxQixNQUFNLENBQUN4a0MsTUFBM0IsRUFBbUNpUCxDQUFDLEVBQXBDLEVBQXVDO0FBQ25DO0FBQ0EsVUFBSXNlLEtBQUssR0FBR2lYLE1BQU0sQ0FBQ3YxQixDQUFELENBQWxCO0FBQ0EsVUFBSWljLFVBQVUsR0FBR3FDLEtBQUssQ0FBQ29YLHNCQUFOLEVBQWpCOztBQUNBLFVBQUkxMUIsQ0FBQyxJQUFJLENBQVQsRUFBWTtBQUNSaVksU0FBQyxHQUFHLENBQUo7QUFDSCxPQUZELE1BRU87QUFDSEEsU0FBQyxHQUFHLENBQUNnRSxVQUFVLENBQUNoRSxDQUFaLEdBQWM2YyxhQUFhLENBQUMsRUFBRCxFQUFLcDJCLEtBQUwsQ0FBL0I7QUFDSDs7QUFDRDRmLFdBQUssQ0FBQ3FYLE1BQU4sQ0FBYTFkLENBQWIsRUFDYSxDQUFDZ0UsVUFBVSxDQUFDNFQsQ0FBWixHQUFjQSxDQUQzQjtBQUVBQSxPQUFDLEdBQUdBLENBQUMsR0FBR2lGLGFBQWEsQ0FBQyxDQUFELEVBQUlXLGdCQUFKLENBQXJCO0FBQ0g7QUFDSixHQXBCRDtBQXFCSDtBQUVEOzs7Ozs7QUFJQSxTQUFTRyxZQUFULENBQXNCM3BCLE1BQXRCLEVBQThCeFYsTUFBOUIsRUFBc0NvL0IsU0FBdEMsRUFBaUQ7QUFDN0MsT0FBSyxJQUFJNzFCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpTSxNQUFNLENBQUNsYixNQUEzQixFQUFtQ2lQLENBQUMsRUFBcEMsRUFBd0M7QUFDcEMsUUFBSWlMLE9BQU8sR0FBR2dCLE1BQU0sQ0FBQ2pNLENBQUQsQ0FBcEI7O0FBQ0EsUUFBSTYxQixTQUFTLENBQUM1cUIsT0FBRCxDQUFiLEVBQXdCO0FBQ3BCZ0IsWUFBTSxDQUFDbWQsTUFBUCxDQUFjcHBCLENBQWQsRUFBaUIsQ0FBakI7QUFDQXZKLFlBQU0sQ0FBQzJHLElBQVAsQ0FBWTZOLE9BQVo7QUFDQWpMLE9BQUM7QUFDSjtBQUNKO0FBQ0o7O0FBR00sU0FBU3VqQixpQkFBVCxHQUE2QjtBQUNoQyxPQUFLLElBQUl2akIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZCLFNBQVMsQ0FBQzlRLE1BQTlCLEVBQXNDaVAsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxRQUFJNkIsU0FBUyxDQUFDN0IsQ0FBRCxDQUFULElBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLGFBQU82QixTQUFTLENBQUM3QixDQUFELENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxTQUFPcmYsU0FBUDtBQUNIO0FBRUQ7Ozs7Ozs7Ozs7O0FBVUEsU0FBU20xQyxXQUFULENBQXFCQyxHQUFyQixFQUF5QjtBQUNyQixTQUFRQSxHQUFHLFlBQVl0K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXNlgsSUFBM0IsSUFDRm1ILEdBQUcsWUFBWXQrQixFQUFFLENBQUNzZixPQUFILENBQVdzWCxJQUR4QixJQUVGMEgsR0FBRyxZQUFZdCtCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV2lZLEtBRnhCLElBR0YrRyxHQUFHLFlBQVl0K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXb2MsSUFIeEIsSUFJRjRDLEdBQUcsWUFBWXQrQixFQUFFLENBQUNzZixPQUFILENBQVd1YyxJQUp4QixJQUtGeUMsR0FBRyxZQUFZdCtCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBV3djLE1BTHhCLElBTUZ3QyxHQUFHLFlBQVl0K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXK0IsR0FOeEIsSUFPRmlkLEdBQUcsWUFBWXQrQixFQUFFLENBQUNzZixPQUFILENBQVdpZixHQVAvQixDQURxQixDQVNyQjtBQUNBO0FBQ0g7O0FBRUQsU0FBU0MsU0FBVCxDQUFtQkYsR0FBbkIsRUFBdUI7QUFDbkIsU0FBT0EsR0FBRyxZQUFZaHpCLE1BQWYsSUFBeUIsY0FBY2d6QixHQUE5QztBQUNIO0FBRUQ7Ozs7Ozs7OztBQU9BLFNBQVNHLGNBQVQsQ0FBd0JILEdBQXhCLEVBQTRCO0FBQ3hCLE1BQUlJLENBQUo7QUFDQSxNQUFJQyxHQUFKO0FBQ0EsTUFBSXAyQixDQUFKO0FBQ0EsTUFBSXEyQixHQUFKLENBSndCLENBS3hCOztBQUNBLE1BQUlQLFdBQVcsQ0FBQ0MsR0FBRCxDQUFmLEVBQXFCO0FBQ2pCO0FBQ0EsV0FBT0EsR0FBUDtBQUNILEdBSEQsTUFHTyxJQUFJaHpCLE1BQU0sQ0FBQy9LLFNBQVAsQ0FBaUI5UixRQUFqQixDQUEwQnFxQyxJQUExQixDQUErQndGLEdBQS9CLE1BQXdDLGdCQUE1QyxFQUE4RDtBQUNqRTtBQUNBTSxPQUFHLEdBQUcsRUFBTjs7QUFDQSxTQUFLcjJCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRysxQixHQUFHLENBQUNobEMsTUFBcEIsRUFBNEIsRUFBRWlQLENBQTlCLEVBQWlDO0FBQzdCO0FBQ0EsVUFBSXMyQixNQUFNLEdBQUdQLEdBQUcsQ0FBQy8xQixDQUFELENBQWhCOztBQUNBLFVBQUcsQ0FBQzgxQixXQUFXLENBQUNRLE1BQUQsQ0FBZixFQUF3QjtBQUNwQkQsV0FBRyxDQUFDajVCLElBQUosQ0FBUzg0QixjQUFjLENBQUNJLE1BQUQsQ0FBdkI7QUFDSCxPQUZELE1BRUs7QUFDREQsV0FBRyxDQUFDajVCLElBQUosQ0FBU2s1QixNQUFUO0FBQ0g7QUFDSjs7QUFDRCxXQUFPLElBQUk3K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXc1gsSUFBZixDQUFvQmdJLEdBQXBCLENBQVA7QUFDSCxHQWJNLE1BYUEsSUFBSU4sR0FBRyxLQUFLLElBQVosRUFBa0I7QUFBQztBQUN0QixXQUFPdCtCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytWLElBQVgsQ0FBZ0JDLEtBQXZCO0FBQ0gsR0FGTSxNQUVBLElBQUksUUFBT2dKLEdBQVAsTUFBZSxRQUFuQixFQUE2QjtBQUNoQyxRQUFHLENBQUNELFdBQVcsQ0FBQ0MsR0FBRCxDQUFmLEVBQXFCO0FBQ2pCO0FBQ0FLLFNBQUcsR0FBRyxFQUFOLENBRmlCLENBRVI7O0FBQ1QsV0FBS0QsQ0FBTCxJQUFVSixHQUFWLEVBQWU7QUFDWDtBQUNBSyxXQUFHLENBQUNoNUIsSUFBSixDQUFTODRCLGNBQWMsQ0FBQ0MsQ0FBRCxDQUF2QixFQUZXLENBR1g7O0FBQ0FDLFdBQUcsQ0FBQ2g1QixJQUFKLENBQVM4NEIsY0FBYyxDQUFDSCxHQUFHLENBQUNJLENBQUQsQ0FBSixDQUF2QjtBQUNILE9BUmdCLENBU2pCOzs7QUFDQSxhQUFPLElBQUkxK0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXNlgsSUFBZixDQUFvQndILEdBQXBCLENBQVA7QUFDSCxLQVhELE1BV0s7QUFDRCxhQUFPTCxHQUFQO0FBQ0g7QUFDSixHQWZNLE1BZUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDaEMsV0FBTyxJQUFJdCtCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUJpZCxHQUFuQixDQUFQO0FBQ0gsR0FGTSxNQUVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2hDLFdBQU90K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXd2YsS0FBWCxDQUFpQlIsR0FBakIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxTQUFuQixFQUE4QjtBQUNqQyxXQUFPLElBQUl0K0IsRUFBRSxDQUFDc2YsT0FBSCxDQUFXb2MsSUFBZixDQUFvQjRDLEdBQXBCLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBRyxPQUFPQSxHQUFQLEtBQWUsVUFBbEIsRUFBOEI7QUFDakMsV0FBTyxJQUFJdCtCLEVBQUUsQ0FBQ3NmLE9BQUgsQ0FBVytCLEdBQWYsQ0FBbUJpZCxHQUFHLENBQUM3ekMsSUFBdkIsQ0FBUDtBQUNIO0FBQ0osQzs7Ozs7Ozs7Ozs7QUNuUUQsb0Q7Ozs7Ozs7Ozs7O0FDQUEsc0QiLCJmaWxlIjoiYmxvY2tweS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpRdWVyeVwiKSwgcmVxdWlyZShcImtvXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiYmxvY2tweVwiLCBbXCJqUXVlcnlcIiwgXCJrb1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJibG9ja3B5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImJsb2NrcHlcIl0gPSBmYWN0b3J5KHJvb3RbXCJqUXVlcnlcIl0sIHJvb3RbXCJrb1wiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qcXVlcnlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYmxvY2tweS5qc1wiKTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTdGFydGluZyBwb2ludCBvZiB0aGUgQmxvY2tQeSBhcHBsaWNhdGlvbiwgY29udGFpbmluZyB0aGUgbWFpblxuICogQmxvY2tQeSBjbGFzcy5cbiAqL1xuaW1wb3J0IFwiLi9jc3MvYmxvY2tweS5jc3NcIjtcbmltcG9ydCBcIi4vY3NzL2Jvb3RzdHJhcF9yZXRoZW1lLmNzc1wiO1xuaW1wb3J0ICQgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyBpbWFnZU1vZHVsZX0gZnJvbSBcInNrdWxwdF9tb2R1bGVzL2ltYWdlXCI7XG5pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIHdlYWtyZWZNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy93ZWFrcmVmXCI7XG4vL2ltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgbWF0cGxvdGxpYk1vZHVsZX0gZnJvbSBcInNrdWxwdF9tb2R1bGVzL21hdHBsb3RsaWIyXCI7XG5pbXBvcnQge0xvY2FsU3RvcmFnZVdyYXBwZXJ9IGZyb20gXCJzdG9yYWdlLmpzXCI7XG5pbXBvcnQge0VkaXRvcnNFbnVtfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCJlZGl0b3IvcHl0aG9uLmpzXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwic2VydmVyLmpzXCI7XG5pbXBvcnQge21ha2VJbnRlcmZhY2UsIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMsIFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9uc30gZnJvbSBcImludGVyZmFjZS5qc1wiO1xuaW1wb3J0IHtFZGl0b3JzfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtcbiAgICBCbG9ja1B5RmlsZVN5c3RlbSxcbiAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZSxcbiAgICBtYWtlTW9kZWxGaWxlLFxuICAgIG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlLFxuICAgIFVOREVMRVRBQkxFX0ZJTEVTLFxuICAgIFVOUkVOQU1BQkxFX0ZJTEVTXG59IGZyb20gXCIuL2ZpbGVzXCI7XG5pbXBvcnQge3VwbG9hZEZpbGUsIGRvd25sb2FkRmlsZX0gZnJvbSBcIi4vZWRpdG9yL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtCbG9ja1B5RW5naW5lfSBmcm9tIFwiZW5naW5lLmpzXCI7XG5pbXBvcnQge0Jsb2NrUHlUcmFjZX0gZnJvbSBcIi4vdHJhY2VcIjtcbmltcG9ydCB7QmxvY2tQeUNvbnNvbGV9IGZyb20gXCIuL2NvbnNvbGVcIjtcbmltcG9ydCB7QmxvY2tQeUZlZWRiYWNrfSBmcm9tIFwiZmVlZGJhY2suanNcIjtcbmltcG9ydCB7QmxvY2tQeVNlcnZlcn0gZnJvbSBcIi4vc2VydmVyXCI7XG5pbXBvcnQge0Jsb2NrUHlEaWFsb2d9IGZyb20gXCIuL2RpYWxvZ1wiO1xuaW1wb3J0IHtBc3NpZ21lbnRUeXBlLCBsb2FkQXNzaWdubWVudFNldHRpbmdzLCBtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWx9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5pbXBvcnQge0Jsb2NrUHlDb3JnaXMsIF9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfSBmcm9tIFwiLi9jb3JnaXNcIjtcbmltcG9ydCB7QmxvY2tQeUhpc3Rvcnl9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7Y2FwaXRhbGl6ZX0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1NhbXBsZVN1Ym1pc3Npb259IGZyb20gXCIuL2VkaXRvci9zYW1wbGVfc3VibWlzc2lvbnNcIjtcblxuZXhwb3J0IHtfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMsIF9JTVBPUlRFRF9EQVRBU0VUU307XG5cbmNvbnN0IEVESVRPUl9WRVJTSU9OID0gXCI1LjEuMlwiO1xuXG4vKipcbiAqIE1ham9yIGVudHJ5IHBvaW50IGZvciBjcmVhdGluZyBhIEJsb2NrUHkgaW5zdGFuY2UuXG4gKiBUd28gbW9zdCBpbXBvcnRhbnQgZmllbGRzIGFyZSBgbW9kZWxgIGFuZCBgY29tcG9uZW50c2AuXG4gKiBUaGUgYG1vZGVsYCBob2xkcyBhbGwgdGhlIGRhdGEgYWJvdXQgdGhlIGludGVyZmFjZS5cbiAqIFRoZSBgY29tcG9uZW50c2AgYXJlIHJlZmVyZW5jZXMgdG8gdGhlIGRpc3BhcmF0ZSBwYXJ0cyBvZiBCbG9ja1B5LlxuICpcbiAqIE1vc3Qgb2YgdGhpcyBjbGFzc2VzIGRlZmluaXRpb24gaXMganVzdCBpbml0aWFsaXppbmcgdGhlIG1vZGVsIGFuZCB1cGRhdGluZ1xuICogaXQgb24gYW4gYXNzaWdubWVudCBzd2l0Y2guXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvbiAtIFVzZXIgbGV2ZWwgc2V0dGluZ3MgKGUuZy4sIHdoYXQgZWRpdG9yIG1vZGUsIHdoZXRoZXIgdG8gbXV0ZSBzZW1hbnRpYyBlcnJvcnMsIGV0Yy4pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzc2lnbm1lbnQgLSBBc3NpZ25tZW50IGxldmVsIHNldHRpbmdzIChkYXRhIGFib3V0IHRoZSBsb2FkZWQgYXNzaWdubWVudCwgdXNlciwgc3VibWlzc2lvbiwgZXRjLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VibWlzc2lvbiAtIEluY2x1ZGVzIHRoZSBzb3VyY2UgY29kZSBvZiBhbnkgcHJvZ3JhbXMgdG8gYmUgbG9hZGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgYXNzaWdubWVudCwgc3VibWlzc2lvbikge1xuICAgICAgICB0aGlzLmluaXRNb2RlbChjb25maWd1cmF0aW9uKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBc3NpZ25tZW50KGNvbmZpZ3VyYXRpb24sIGFzc2lnbm1lbnQsIHN1Ym1pc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdE1haW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgQmxvY2tQeSBvYmplY3QgYnkgaW5pdGlhbGl6aW5nIGl0cyBpbnRlcmZhY2UsXG4gICAgICogbW9kZWwsIGFuZCBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdE1haW4oKSB7XG4gICAgICAgIHRoaXMuaW5pdFV0aWxpdGllcygpO1xuICAgICAgICB0aGlzLmluaXRNb2RlbE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy50dXJuT25IYWNrcygpO1xuICAgICAgICB0aGlzLmluaXRJbnRlcmZhY2UoKTtcbiAgICAgICAgdGhpcy5hcHBseU1vZGVsKCk7XG4gICAgICAgIHRoaXMuaW5pdENvbXBvbmVudHMoKTtcbiAgICAgICAgdGhpcy5tYWtlRXh0cmFTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgZGVmYXVsdCB2YWx1ZSBvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUga2V5IHRvIGxvb2sgdXAgYSB2YWx1ZSBmb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdFZhbHVlIC0gaWYgdGhlIGtleSBpcyBub3QgZm91bmQgYW55d2hlcmUsIHVzZSB0aGlzIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2V0dGluZyhrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9ba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsU2V0dGluZ3NfLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFNldHRpbmdzXy5nZXQoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbW9kZWwgdG8gaXRzIGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQ2F0ZWdvcmllczpcbiAgICAgKiAgICogdXNlcjogdmFsdWVzIGZvciB0aGUgY3VycmVudCB1c2VyIChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBhc3NpZ25tZW50OiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGFzc2lnbm1lbnQgKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIHN1Ym1pc3Npb246IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgc3VibWlzc2lvbiAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogZGlzcGxheTogZmxhZ3MgcmVsYXRlZCB0byBjdXJyZW50IHZpc2liaWxpdHkgKHN0b3JlZCB0byBsb2NhbFNldHRpbmdzKVxuICAgICAqICAgKiBzdGF0dXM6IG1lc3NhZ2VzIHJlbGF0ZWQgdG8gY3VycmVudCBzdGF0dXMgKG5vdCBzdG9yZWQpXG4gICAgICogICAqIGV4ZWN1dGlvbjogdmFsdWVzIHJlbGF0ZWQgdG8gbGFzdCBydW4gKG5vdCBzdG9yZWQpXG4gICAgICogICAqIGNvbmZpZ3VyYXRpb246IGNvbnN0YW50IHZhbHVlcyByZWxhdGVkIHRvIHNldHVwIChub3Qgc3RvcmVkKVxuICAgICAqL1xuICAgIGluaXRNb2RlbChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIC8vIENvbm5lY3QgdG8gbG9jYWwgc3RvcmFnZVxuICAgICAgICB0aGlzLmxvY2FsU2V0dGluZ3NfID0gbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoXCJsb2NhbFNldHRpbmdzXCIpO1xuICAgICAgICB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uXyA9IGNvbmZpZ3VyYXRpb247XG5cbiAgICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1widXNlci5pZFwiXSksXG4gICAgICAgICAgICAgICAgbmFtZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1widXNlci5uYW1lXCJdKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHlvdSBhcmUgYW4gT3duZXIgKGNhbiBtb2RpZnkgdGhlIGFzc2lnbm1lbnQpLCBHcmFkZXIgKGNhbiB2aWV3XG4gICAgICAgICAgICAgICAgICogdGhlIGFzc2lnbm1lbnRzJyBpbmZvcm1hdGlvbikgb3IgU3R1ZGVudCAoY2FuIG5vdCBzZWUgYW55IGluc3RydWN0b3Igc3R1ZmYpLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJvbGU6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwidXNlci5yb2xlXCIsIFwib3duZXJcIikpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgY291cnNlIGZvciB0aGlzIHVzZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb3Vyc2VJZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1widXNlci5jb3Vyc2VfaWRcIl0pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgYXNzaWdubWVudCBncm91cCB0aGF0IHRoaXMgdXNlciBpcyBpbnNpZGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBncm91cElkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmdyb3VwX2lkXCJdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzc2lnbm1lbnQ6IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKFwiU2NyYXRjaCBDYW52YXNcIiksXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBrby5vYnNlcnZhYmxlKFwiV2VsY29tZSB0byBCbG9ja1B5LiBUcnkgZWRpdGluZyBhbmQgcnVubmluZyB0aGUgY29kZSBiZWxvdy5cIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGh1bWFuLWZyaWVuZGx5IFVSTCB0byB1c2UgYXMgYSBzaG9ydGN1dCBmb3IgdGhpcyBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdXJsOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdhcm5pbmcgbWVzc2FnZSBpZiBtYXplXG4gICAgICAgICAgICAgICAgdHlwZToga28ub2JzZXJ2YWJsZShBc3NpZ21lbnRUeXBlLkJMT0NLUFkpLFxuICAgICAgICAgICAgICAgIHBvaW50czoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBzdGFydGluZ0NvZGU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZVwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvblJ1bjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9ydW5cIl0gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQub25fY2hhbmdlXCJdIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIG9uRXZhbDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9ldmFsXCJdIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgIGV4dHJhSW5zdHJ1Y3RvckZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkobG9hZENvbmNhdGVuYXRlZEZpbGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlc1wiXSkgfHwgW10pLFxuICAgICAgICAgICAgICAgIGV4dHJhU3RhcnRpbmdGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICBmb3JrZWRJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBmb3JrZWRWZXJzaW9uOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgY291cnNlSWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICB0YWdzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIHNhbXBsZVN1Ym1pc3Npb25zOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIHJldmlld2VkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnJldmlld2VkXCJdKSxcbiAgICAgICAgICAgICAgICBwdWJsaWM6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQucHVibGljXCJdKSxcbiAgICAgICAgICAgICAgICBoaWRkZW46IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuaGlkZGVuXCJdKSxcbiAgICAgICAgICAgICAgICBpcFJhbmdlczoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5pcF9yYW5nZXNcIl0pLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWwoY29uZmlndXJhdGlvbilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgY29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIGV4dHJhRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgdXJsOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIHNjb3JlOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgIGNvcnJlY3Q6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnRJZCBpbmZlcnJlZCBmcm9tIGFzc2lnbm1lbnQuaWRcbiAgICAgICAgICAgICAgICAvLyBjb3Vyc2VJZCBpbmZlcnJlZCBmcm9tIHVzZXIuY291cnNlSWRcbiAgICAgICAgICAgICAgICAvLyB1c2VySWQgaW5mZXJyZWQgZnJvbSB1c2VyLmlkXG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudFZlcnNpb24gaW5mZXJyZWQgZnJvbSBhc3NpZ25tZW50LnZlcnNpb25cbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25TdGF0dXM6IGtvLm9ic2VydmFibGUoXCJTdGFydGVkXCIpLFxuICAgICAgICAgICAgICAgIGdyYWRpbmdTdGF0dXM6IGtvLm9ic2VydmFibGUoXCJOb3RSZWFkeVwiKSxcbiAgICAgICAgICAgICAgICBvd25lcklkOiBrby5vYnNlcnZhYmxlKG51bGwpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnRseSB2aXNpYmxlIEZpbGUsIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIHByZXNlbnRlZCB3aXRoIHRoZSBpbnN0cnVjdG9yIHNldHRpbmdzIGFuZCBmaWxlc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGluc3RydWN0b3I6IGtvLm9ic2VydmFibGUoXCJcIit0aGlzLmdldFNldHRpbmcoXCJkaXNwbGF5Lmluc3RydWN0b3JcIiwgXCJmYWxzZVwiKT09PVwidHJ1ZVwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBwcmV2ZW50IHRoZSBwcmludGVyIGZyb20gc2hvd2luZyB0aGluZ3NcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBtdXRlUHJpbnRlcjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogKFB5dGhvbiBWaWV3cykgVGhlIGN1cnJlbnQgZWRpdG9yIG1vZGUuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0Rpc3BsYXlNb2Rlc31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBweXRob25Nb2RlOiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkucHl0aG9uLm1vZGVcIiwgRGlzcGxheU1vZGVzLlNQTElUKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgSGlzdG9yeSBtb2RlIGlzIGVuZ2FnZWQuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaGlzdG9yeU1vZGU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIGF1dG8tc2F2aW5nIGNoYW5nZXMgaW4gUHl0aG9uIGVkaXRvclxuICAgICAgICAgICAgICAgICAqIElmIGFuIGludGVnZXIsIHNwZWNpZmllcyB0aGUgZGVsYXkgdGhhdCBzaG91bGQgYmUgdXNlZCAobWljcm9zZWNvbmRzKS5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIG5ldmVyIG9uIGluIG5vbi1QeXRob24gZWRpdG9ycy5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbHxpbnR9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXV0b1NhdmU6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGNvbnNvbGUgaXMgZnVsbCB3aWR0aCBhbmQgZmVlZGJhY2sgaXMgaGlkZGVuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYmlnQ29uc29sZToga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBjb25zb2xlLlxuICAgICAgICAgICAgICAgICAqICAgIElmIG51bGwsIHRoZW4gbGV0IHRoZSBoZWlnaHQgcmVtYWluIHVuY2hhbmdlZFxuICAgICAgICAgICAgICAgICAqICAgIElmIGEgbnVtYmVyLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ29uc29sZUhlaWdodDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uc29sZUhlaWdodDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGljaCBwYW5lbCB0byBzaG93IGluIHRoZSBzZWNvbmQgcm93J3Mgc2Vjb25kIGNvbHVtblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2Vjb25kUm93U2Vjb25kUGFuZWw6IGtvLm9ic2VydmFibGUoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLKSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIHRyYWNpbmcgdGhlIGNvZGUgcmlnaHQgbm93XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJhY2VFeGVjdXRpb246IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBsaXN0IG9mIHByb21pc2VzIHRvIHN0aWxsIHJlc29sdmUgd2hpbGUgbG9hZGluZyBkYXRhc2V0c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxQcm9taXNlPn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsb2FkaW5nRGF0YXNldHM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHRlbXBvcmFyeSBjaGFuZ2VkIHZhbHVlIG9mIHRoZSBpbnN0cnVjdGlvbnMgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSB3aGF0IGlzIGluIHRoZSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhbmdlZEluc3RydWN0aW9uczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIGhvbGRlciBmb3IgdGhlIHRpbWVyIHRvIHRyaWdnZXIgb24tY2hhbmdlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyaWdnZXJPbkNoYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IGZlZWRiYWNrIGFuZCBvdXRwdXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgc3VibWlzc2lvbi5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdvdWxkIGJlIGZhbHNlIGlmIHRoZXJlIGlzIG5vIGZlZWRiYWNrL291dHB1dCAoaS5lLiwgY29kZSBoYXMgbm90IGJlZW4gcnVuKSxcbiAgICAgICAgICAgICAgICAgKiBvciBpZiB0aGUgdXNlciBoYXMgbW9kaWZpZWQgdGhlIHN1Ym1pc3Npb24gYWZ0ZXIgdGhlIGxhc3QgcnVuIChlLmcuLCBieSBlZGl0aW5nXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpcnR5U3VibWlzc2lvbjoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdG8gbWFrZSB0aGUgQmxvY2tQeSBlbGVtZW50IGluIEZVTEwgU0NSRUVOIG1vZGUuIFNhZGx5LCBub3QgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICAqICB3aXRoaW4gdGhlIHdpbmRvdywgYnV0IEZVTEwgU0NSRUVOLiBWZXJ5IGFnZ3Jlc3NpdmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVsbHNjcmVlbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXNlci1zdXBwbGllZCBwYXNzY29kZSB0byBjb21wYXJlIG9uIHRoZSBzZXJ2ZXIgYWdhaW5zdCB0aGUgY3VycmVudCBwYXNzY29kZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXNzY29kZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBjbGVhciBvdXQgaW5wdXRzIGFmdGVyIGEgcnVuL29uX3J1biBjeWNsZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNsZWFySW5wdXRzOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGltYWdlcyBzaG91bGQgYmUgcmVuZGVyZWQgKHRydWUpLCBvciBqdXN0IHN0YXkgYXMgdGV4dCBjb2RlIChmYWxzZSkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVuZGVySW1hZ2VzOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIGVkaXRvclZlcnNpb246IEVESVRPUl9WRVJTSU9OLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkucmVhZF9vbmx5XCIsIFwiZmFsc2VcIikudG9TdHJpbmcoKT09PVwidHJ1ZVwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVcGxvYWRlZCBmaWxlcyBhcmUgb25lcyB0aGF0IGhhdmUgYmVlbiBsaXN0ZWQgYnkgdGhlIHJlbW90ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVwbG9hZGVkRmlsZXM6IGtvLm9ic2VydmFibGUobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEhpc3RvcnlNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkRGF0YXNldE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2dFdmVudDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9nRXZlbnRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2VNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXM6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbGlzdFVwbG9hZGVkRmlsZXM6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxpc3RVcGxvYWRlZEZpbGVzTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGRvd25sb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgZG93bmxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwbG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwbG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgb25FeGVjdXRpb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IGluLXByb2dyZXNzIGV4ZWN1dGlvbnNcbiAgICAgICAgICAgICAgICByZXBvcnRzOiB7fSxcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIE91dHB1dCBvYmplY3RzXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIC8vIExpc3Qgb2YgaW5wdXR0ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIGlucHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXg6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBhIHN0dWRlbnQgcnVuXG4gICAgICAgICAgICAgICAgc3R1ZGVudDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHI6IHRoZSBmaWxlbmFtZSB0aGF0IHdhcyBsYXN0IGV4ZWN1dGVkIGFuZCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdExpbmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIHNpbXBsZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjZURhdGE6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlU3RlcDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsIGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGNhbGxzOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gZmVlZGJhY2sgZnJvbSB0aGUgaW5zdHJ1Y3RvciBydW5cbiAgICAgICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHIgKG1hcmtkb3duKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiUmVhZHlcIiksXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNFcnJvcjoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNVbmNvdmVyZWQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBudWxsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyB0byBmaXJlIHdoZW4gY2VydGFpbiBldmVudHMgb2NjdXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIHN0dWRlbnQgZ2V0cyBhIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImNhbGxiYWNrLnN1Y2Nlc3NcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2VydmVyIGlzIGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb25uZWN0ZWQ6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwic2VydmVyLmNvbm5lY3RlZFwiLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYmxvY2tseVBhdGg6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiYmxvY2tseS5wYXRoXCJdLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRQb2ludDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJhdHRhY2htZW50LnBvaW50XCJdLFxuICAgICAgICAgICAgICAgIC8vIEpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgLy8gTWFwcyBjb2RlcyAoJ2xvZ19ldmVudCcsICdzYXZlX2NvZGUnKSB0byBVUkxzXG4gICAgICAgICAgICAgICAgdXJsczogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJ1cmxzXCJdIHx8IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGludGVyZmFjZVxuICAgICAqL1xuICAgIGluaXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIGxldCBjb25zdGFudHMgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGxldCBndWkgPSBtYWtlSW50ZXJmYWNlKHRoaXMpO1xuICAgICAgICBjb25zdGFudHMuY29udGFpbmVyID0gJChjb25zdGFudHMuYXR0YWNobWVudFBvaW50KS5odG1sKCQoZ3VpKSk7XG4gICAgfTtcblxuICAgIGxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5sb2FkQXNzaWdubWVudChhc3NpZ25tZW50X2lkKTtcbiAgICB9XG5cbiAgICBsb2FkVGFncyh0YWdzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHRhZ3NcbiAgICB9XG5cbiAgICBsb2FkU2FtcGxlU3VibWlzc2lvbnMoc2FtcGxlcykge1xuICAgICAgICAvLyBBbHJlYWR5IGEgSlNPTiBsaXN0IHJlcHJlc2VudGluZyBzYW1wbGVzXG4gICAgfVxuXG4gICAgbG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICB9XG5cbiAgICBsb2FkU3VibWlzc2lvbihzdWJtaXNzaW9uLCBhc3NpZ25tZW50KSB7XG4gICAgICAgIGlmICghc3VibWlzc2lvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogU2NhcmllciBcIllvdSBhcmUgbm90IGxvZ2dlZCBpbiBtZXNzYWdlXCJcbiAgICAgICAgICAgIHRoaXMubG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHN1Ym1pc3Npb25zJyBhc3NpZ25tZW50IHZlcnNpb24gYW5kIHRoZSBhc3NpZ25tZW50cycgdmVyc2lvbiBjb25mbGljdD9cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmlkKHN1Ym1pc3Npb24uaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29kZShzdWJtaXNzaW9uLmNvZGUpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWJtaXNzaW9uLmNvcnJlY3QpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc3VibWlzc2lvbi5zY29yZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5lbmRwb2ludChzdWJtaXNzaW9uLmVuZHBvaW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnVybChzdWJtaXNzaW9uLnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi52ZXJzaW9uKHN1Ym1pc3Npb24udmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5ncmFkaW5nU3RhdHVzKHN1Ym1pc3Npb24uZ3JhZGluZ19zdGF0dXMpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhzdWJtaXNzaW9uLnN1Ym1pc3Npb25fc3RhdHVzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLm93bmVySWQoc3VibWlzc2lvbi51c2VyX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC51c2VyLmNvdXJzZUlkKHN1Ym1pc3Npb24uY291cnNlX2lkKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoc3VibWlzc2lvbi5leHRyYV9maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRBc3NpZ25tZW50RGF0YV8oZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgdGhpcy5yZXNldEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kaXNtb3VudEV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IHdhc1NlcnZlckNvbm5lY3RlZCA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgIGxldCBhc3NpZ25tZW50ID0gZGF0YS5hc3NpZ25tZW50O1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaWQoYXNzaWdubWVudC5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC52ZXJzaW9uKGFzc2lnbm1lbnQudmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5jb3Vyc2VJZChhc3NpZ25tZW50LmNvdXJzZV9pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5mb3JrZWRJZChhc3NpZ25tZW50LmZvcmtlZF9pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5mb3JrZWRWZXJzaW9uKGFzc2lnbm1lbnQuZm9ya2VkX3ZlcnNpb24pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKGFzc2lnbm1lbnQuaGlkZGVuKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKGFzc2lnbm1lbnQucmV2aWV3ZWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucHVibGljKGFzc2lnbm1lbnQucHVibGljKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnR5cGUoYXNzaWdubWVudC50eXBlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnVybChhc3NpZ25tZW50LnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wb2ludHMoYXNzaWdubWVudC5wb2ludHMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaXBSYW5nZXMoYXNzaWdubWVudC5pcF9yYW5nZXMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKGFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoYXNzaWdubWVudC5uYW1lKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKGFzc2lnbm1lbnQub25fY2hhbmdlIHx8IG51bGwpO1xuICAgICAgICBpZiAoYXNzaWdubWVudC5vbl9jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUoXCIhb25fY2hhbmdlLnB5XCIsIGFzc2lnbm1lbnQub25fY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKGFzc2lnbm1lbnQub25fZXZhbCB8fCBudWxsKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQub25fZXZhbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShcIiFvbl9ldmFsLnB5XCIsIGFzc2lnbm1lbnQub25fZXZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuKGFzc2lnbm1lbnQub25fcnVuKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZShhc3NpZ25tZW50LnN0YXJ0aW5nX2NvZGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub3duZXJJZChhc3NpZ25tZW50Lm93bmVyX2lkKTtcbiAgICAgICAgdGhpcy5sb2FkVGFncyhhc3NpZ25tZW50LnRhZ3MpO1xuICAgICAgICB0aGlzLmxvYWRTYW1wbGVTdWJtaXNzaW9ucyhhc3NpZ25tZW50LnNhbXBsZV9zdWJtaXNzaW9ucyk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcywgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9zdGFydGluZ19maWxlcywgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyk7XG4gICAgICAgIGxvYWRBc3NpZ25tZW50U2V0dGluZ3ModGhpcy5tb2RlbCwgYXNzaWdubWVudC5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMubG9hZFN1Ym1pc3Npb24oZGF0YS5zdWJtaXNzaW9uLCBhc3NpZ25tZW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbih0cnVlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobnVsbCk7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQod2FzU2VydmVyQ29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmNvcmdpcy5sb2FkRGF0YXNldHModHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0ucmVmcmVzaCgpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgIH1cblxuICAgIGluaXRNb2RlbE1ldGhvZHMoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgbW9kZWwudWkgPSB7XG4gICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgaXNHcmFkZXI6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVzZXIucm9sZSgpID09PSBcIm93bmVyXCIgfHwgbW9kZWwudXNlci5yb2xlKCkgPT09IFwiZ3JhZGVyXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuaXNDaGFuZ2VkKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51dGlsaXRpZXMubWFya2Rvd24obW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZXNldDogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG51bGwpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudToge1xuICAgICAgICAgICAgICAgIHRleHRGdWxsc2NyZWVuOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKSA/IFwiZmEtY29tcHJlc3MtYXJyb3dzLWFsdFwiIDogXCJmYS1leHBhbmQtYXJyb3dzLWFsdFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjbGlja0Z1bGxzY3JlZW46ICgpID0+e1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oIW1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVkaXRJbnB1dHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmRpYWxvZy5FRElUX0lOUFVUUygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9nZ2xlSW1hZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlbmRlckltYWdlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuZGlzYWJsZUltYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0RWRpdG9yLmVuYWJsZUltYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCFtb2RlbC5kaXNwbGF5LnJlbmRlckltYWdlcygpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbk1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpIHx8IG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRNYXJrU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWwudXNlci5ncm91cElkKCkgPyBcIlByb2JsZW0gY2xvc2VkXCIgOiBcIkFzc2lnbm1lbnQgY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSZW9wZW4gZm9yIGVkaXRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSdW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSAmJiBtb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdWJtaXQgZWFybHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNsaWNrTWFya1N1Ym1pdHRlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIllvdSBjYW5ub3QgcmVvcGVuIGNsb3NlZCBhc3NpZ25tZW50cy4gQ29udGFjdCBhIGdyYWRlciFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJpblByb2dyZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZGVsYXllZFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uU3RhdHVzKFwiU3VibWl0dGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCkgfHwgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5jYW5DbG9zZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcInN1Ym1pdHRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlZDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZWRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2hvd1F1ZXVlZElucHV0czoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVRdWV1ZWRJbnB1dHMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWNvbmRSb3c6IHtcbiAgICAgICAgICAgICAgICBpc0FsbFZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlTWlkZGxlUGFuZWwoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNGZWVkYmFja1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDS1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNUcmFjZVZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNDb25zb2xlU2hvd1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUoKSB8fCBtb2RlbC51aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc3dpdGNoTGFiZWw6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVmlldyBUcmFjZVwiIDogXCJcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYWR2YW5jZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFuZWwgPSBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWFrZVdpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhbmVsID0gbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbDtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5wcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsKGN1cnJlbnRQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3RvcmVQYW5lbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhbmVsID0gbW9kZWwuZGlzcGxheS5wcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUGFuZWwoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbChvbGRQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBhbmVsKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnNvbGU6IHtcbiAgICAgICAgICAgICAgICBzaXplOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC0xMlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTZcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGlkZUV2YWx1YXRlOiBrby5wdXJlQ29tcHV0ZWQoICgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRXZhbHVhdGUoKSB8fCAhbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscygpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmVlZGJhY2s6IHtcbiAgICAgICAgICAgICAgICBiYWRnZToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ub25lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnVudGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXJ1bnRpbWUtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW50YXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zeW50YXgtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlZGl0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zeW50YXgtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRlcm5hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWludGVybmFsLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VtYW50aWNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbmFseXplclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXNlbWFudGljLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmVlZGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtZmVlZGJhY2stZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXByb2JsZW0tY29tcGxldGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1pbnN0cnVjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJubyBlcnJvcnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1uby1lcnJvcnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnVudGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJ1bnRpbWUgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW50YXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTeW50YXggRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlZGl0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFZGl0b3IgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRlcm5hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkludGVybmFsIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VtYW50aWNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbmFseXplclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFsZ29yaXRobSBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZlZWRiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3Rpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5zdHJ1Y3Rpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkluY29ycmVjdCBBbnN3ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkNvbXBsZXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm8gZXJyb3JzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNlOiB7XG4gICAgICAgICAgICAgICAgaGFzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsaW5lOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEgfHwgc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gdHJhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQmVmb3JlIHJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IGxhc3RTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJGaW5pc2hlZCBydW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoeSBhcmUgdGhlc2UgbnVtYmVycyB3b25reT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkxpbmUgXCIrKHRyYWNlRGF0YVtzdGVwXS5saW5lLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IE1hdGgubWF4KDAsIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBNYXRoLm1pbihtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpLCBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChuZXh0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRhdGE6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbGFzdFN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlRGF0YVtzdGVwIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZURhdGFbc3RlcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxlczoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGFzQ29udGVudHM6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5zd2VyLnB5XCI6IHJldHVybiBtb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhaW5zdHJ1Y3Rpb25zLm1kXCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9jaGFuZ2UucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/bW9ja191cmxzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9pbWFnZXMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/aW1hZ2VzLmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9wcmVmaXgucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiIWFuc3dlcl9wcmVmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9zdWZmaXgucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiIWFuc3dlcl9zdWZmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3Rvb2xib3guYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiF0YWdzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQudGFncygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnMoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/bW9ja191cmxzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3ByZWZpeC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfc3VmZml4LnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3RhZ3MuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9zZXR0aW5ncy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/aW1hZ2VzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgsIFwie31cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3Rvb2xib3guYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3JtYWxUb29sYm94ID0gc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5ibG9ja0VkaXRvci5UT09MQk9YRVNbXCJub3JtYWxcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsVG9vbGJveCA9IEpTT04uc3RyaW5naWZ5KG5vcm1hbFRvb2xib3gsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCwgbm9ybWFsVG9vbGJveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucyhbU2FtcGxlU3VibWlzc2lvbi5CbGFuaygpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZml4IGV4dHJhZmlsZXMgZm9yIGluc3RydWN0b3IgYW5kIHN0dWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHVkZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0dWRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0YXJ0aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmFtZTogKG5ld05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLnJlbmFtZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpLCBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFN0dWRlbnRDb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeFB5ID0gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIiFhbnN3ZXJfcHJlZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4UHkgPSBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiIWFuc3dlcl9zdWZmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeFB5ICYmIHByZWZpeFB5LmhhbmRsZSAmJiBwcmVmaXhQeS5oYW5kbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IHByZWZpeFB5LmhhbmRsZSgpICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VmZml4UHkgJiYgc3VmZml4UHkuaGFuZGxlICYmIHN1ZmZpeFB5LmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSArIHN1ZmZpeFB5LmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFTdHVkZW50RmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhU3RhcnRpbmdGaWxlczogb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlGaWxlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVVJMIERhdGFcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/aW1hZ2VzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW1hZ2VzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiIWFuc3dlcl9wcmVmaXgucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQW5zd2VyIFByZWZpeFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFuc3dlciBTdWZmaXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlRvb2xib3hcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiJlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0b3JzOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudDoga28ucHVyZUNvbXB1dGVkKCAoKT0+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lZGl0b3JzLmdldEVkaXRvcihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFZGl0b3JzKCkpID8gXCJOb25lXCIgOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPyBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKSA6IFwiTm9uZVwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuUmVzZXRcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uY29kZShtb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKCkubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gZmlsZS5maWxlbmFtZSgpLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW5TYXZlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmRpc3BsYXkuYXV0b1NhdmUoKSksXG4gICAgICAgICAgICAgICAgY2FuRGVsZXRlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpIHx8IG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSAmJlxuICAgICAgICAgICAgICAgICAgICBVTkRFTEVUQUJMRV9GSUxFUy5pbmRleE9mKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSkgPT09IC0xKSxcbiAgICAgICAgICAgICAgICBjYW5SZW5hbWU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKCkgfHwgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIFVOUkVOQU1BQkxFX0ZJTEVTLmluZGV4T2YobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKSA9PT0gLTEpLFxuICAgICAgICAgICAgICAgIHVwbG9hZDogdXBsb2FkRmlsZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZEZpbGUuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBpbXBvcnREYXRhc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5jb3JnaXMub3BlbkRpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHl0aG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2RlTWlycm9yID0gc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0RWRpdG9yLmNvZGVNaXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZU1pcnJvci5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjb2RlTWlycm9yLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVNb2RlOiAobmV3TW9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtVmlldy5DaGFuZ2VcIiwgXCJcIiwgXCJcIiwgbmV3TW9kZSwgbW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShuZXdNb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLm9sZFB5dGhvbk1vZGUgPSBuZXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc0hpc3RvcnlBdmFpbGFibGU6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRIaXN0b3J5XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgdHVybk9mZkhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnVwZGF0ZUVkaXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5zZXRSZWFkT25seShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHVybk9uSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9hZEhpc3RvcnkoKHJlc3BvbnNlKSA9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5sb2FkKHJlc3BvbnNlLmhpc3RvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnNldFJlYWRPbmx5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19ISVNUT1JZKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5Pbkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlVG9TdGFydCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXM6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVQcmV2aW91cygpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZU5leHQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RSZWNlbnQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVUb01vc3RSZWNlbnQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZTogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkudXNlKCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbG9hZEltYWdlczogKCkgPT4gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiaW1hZ2VcIikucmVsb2FkSW1hZ2VzKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhdmU6ICgpID0+IHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUFzc2lnbm1lbnQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRFZGl0b3I6IChuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdG9yID0gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGVjdXRlOiB7XG4gICAgICAgICAgICAgICAgaXNSdW5uaW5nOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcnVuTGFiZWw6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFID8gXCJTdG9wXCIgOiBcIlJ1blwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBydW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHlnYW1lTGliICE9PSBcInVuZGVmaW5lZFwiICYmIFB5Z2FtZUxpYi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHlnYW1lTGliLlN0b3BQeWdhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmRlbGF5ZWRSdW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZhbHVhdGU6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZXZhbHVhdGUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIHN0YXR1czogKGVuZHBvaW50ID0+XG4gICAgICAgICAgICAgICAgICAgIFwic2VydmVyLXN0YXR1cy1cIiArIG1vZGVsLnN0YXR1c1tlbmRwb2ludF0oKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNFbmRwb2ludENvbm5lY3RlZDogKGVuZHBvaW50KSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24udXJscyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tlbmRwb2ludF0gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIGNhcGl0YWxpemUobW9kZWwuc3RhdHVzLmxvYWRBc3NpZ25tZW50TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2FkSGlzdG9yeU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRGaWxlTWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2FkRGF0YXNldE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvZ0V2ZW50TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMuc2F2ZUltYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy51cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMudXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2UoKSB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZm9yY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgZmlsZUhhbmRsZXIgPSAkKFwiLmJsb2NrcHktZm9yY2UtbG9hZC1hc3NpZ25tZW50LWZpbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlsZUhhbmRsZXIuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKS5mYWRlT3V0KDEwMCkuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB1c2VyIHRvIHVwbG9hZCBhIGZpbGUgY29udGFpbmluZyBhbiBhc3NpZ25tZW50IHN1Ym1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uWzBdLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50U3VibWlzc2lvbiA9IEpTT04ucGFyc2UoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRBc3NpZ25tZW50RGF0YV8oYXNzaWdubWVudFN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbi52YWwoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNlbGYubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMoc2VsZiwgbW9kZWwpO1xuICAgIH1cblxuICAgIHR1cm5PbkhhY2tzKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ET1wiKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9pbWFnZS5qc1wiXSA9IGltYWdlTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi93ZWFrcmVmLmpzXCJdID0gd2Vha3JlZk1vZHVsZS50b1N0cmluZygpO1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvbWF0cGxvdGxpYi9weXBsb3QvX19pbml0X18uanNcIl0gPSBtYXRwbG90bGliTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHlzIHRoZSBLbm9ja291dEpTIGJpbmRpbmdzIHRvIHRoZSBtb2RlbCwgaW5zdGFudGlhdGluZyB0aGUgdmFsdWVzIGludG8gdGhlXG4gICAgICogSFRNTC5cbiAgICAgKi9cbiAgICBhcHBseU1vZGVsKCkge1xuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHRoaXMubW9kZWwsIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXJbMF0pO1xuICAgIH1cblxuICAgIGluaXRVdGlsaXRpZXMoKSB7XG4gICAgICAgIGxldCBtYWluID0gdGhpcztcbiAgICAgICAgdGhpcy51dGlsaXRpZXMgPSB7XG4gICAgICAgICAgICBtYXJrZG93bjogKHRleHQpID0+IHRleHQgPyBFYXN5TURFLnByb3RvdHlwZS5tYXJrZG93bih0ZXh0KSA6IFwiPHA+PC9wPlwiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5pdENvbXBvbmVudHMoKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyO1xuICAgICAgICBsZXQgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXM7XG4gICAgICAgIC8vIEVhY2ggb2YgdGhlc2UgY29tcG9uZW50cyB3aWxsIHRha2UgdGhlIEJsb2NrUHkgaW5zdGFuY2UsIGFuZCBwb3NzaWJseSBhXG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgcmVsZXZhbnQgSFRNTCBsb2NhdGlvbiB3aGVyZSBpdCB3aWxsIGJlIGVtYmVkZGVkLlxuICAgICAgICBjb21wb25lbnRzLmRpYWxvZyA9IG5ldyBCbG9ja1B5RGlhbG9nKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZGlhbG9nXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy5mZWVkYmFjayA9IG5ldyBCbG9ja1B5RmVlZGJhY2sobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFja1wiKSk7XG4gICAgICAgIGNvbXBvbmVudHMudHJhY2UgPSBuZXcgQmxvY2tQeVRyYWNlKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmNvbnNvbGUgPSBuZXcgQmxvY2tQeUNvbnNvbGUobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1jb25zb2xlXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy5lbmdpbmUgPSBuZXcgQmxvY2tQeUVuZ2luZShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5maWxlU3lzdGVtID0gbmV3IEJsb2NrUHlGaWxlU3lzdGVtKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmVkaXRvcnMgPSBuZXcgRWRpdG9ycyhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWVkaXRvclwiKSk7XG4gICAgICAgIC8vIENvbnZlbmllbnQgc2hvcnRjdXQgZGlyZWN0bHkgdG8gUHl0aG9uRWRpdG9yXG4gICAgICAgIGNvbXBvbmVudHMucHl0aG9uRWRpdG9yID0gdGhpcy5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwicHl0aG9uXCIpO1xuICAgICAgICBjb21wb25lbnRzLnNlcnZlciA9IG5ldyBCbG9ja1B5U2VydmVyKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmNvcmdpcyA9IG5ldyBCbG9ja1B5Q29yZ2lzKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmhpc3RvcnkgPSBuZXcgQmxvY2tQeUhpc3RvcnkobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1oaXN0b3J5LXRvb2xiYXJcIikpO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuc2hvdygpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuaGlkZSgpO1xuICAgIH1cblxuICAgIG1ha2VFeHRyYVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtSW5zdHJ1Y3Rpb25zLkNoYW5nZVwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLCBcImluc3RydWN0aW9ucy5tZFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICByZXNldEludGVyZmFjZSgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmVuZ2luZS5yZXNldCgpO1xuICAgICAgICAvLyBEaXNhYmxlIGFueSBhbHRlcm5hdGl2ZSBsb2dFbnRyeSBmdW5jdGlvbnMgd2UgaGF2ZSBiZWVuIGdpdmVuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIuYWx0TG9nRW50cnkgPSBudWxsO1xuICAgIH1cblxuICAgIHJlcXVlc3RQYXNzY29kZSgpIHtcbiAgICAgICAgbGV0IHVzZXJTdXBwbGllZFBhc3Njb2RlID0gcHJvbXB0KFwiUGxlYXNlIGVudGVyIHRoZSBwYXNzY29kZS5cIik7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5wYXNzY29kZSh1c2VyU3VwcGxpZWRQYXNzY29kZSk7XG4gICAgfVxuXG59XG5cbiIsImltcG9ydCB7ZW5jb2RlSFRNTH0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5cbi8qKlxuICogRXZhbHVhdGUgYnV0dG9uIEhUTUwgdGVtcGxhdGVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFNUQVJUX0VWQUxfSFRNTCA9IGBcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tb3V0bGluZSBmbG9hdC1yaWdodCBibG9ja3B5LWJ0bi1ldmFsXCI+XG4gICAgRXZhbHVhdGVcbjwvYnV0dG9uPmA7XG5cbi8qKlxuICogSFRNTCB0ZW1wbGF0ZSBmb3IgYSBuZXcgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IE5FV19DT05TT0xFX0xJTkVfSFRNTCA9IFwiPGRpdj48L2Rpdj5cIjtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgZW50aXJlIGNvbnNvbGUgYXJlYVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENPTlNPTEVfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtNiBibG9ja3B5LXBhbmVsIGJsb2NrcHktY29uc29sZSdcbiAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkNvbnNvbGVcIlxuICAgICAgICAgIGRhdGEtYmluZD1cImNsYXNzOiB1aS5jb25zb2xlLnNpemVcIj5cbiAgICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LXNob3ctZmVlZGJhY2snXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5zZWNvbmRSb3cuaXNDb25zb2xlU2hvd1Zpc2libGUsIGNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgPHN0cm9uZz5Db25zb2xlOjwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1wcmludGVyIGJsb2NrcHktcHJpbnRlci1kZWZhdWx0Jz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICA8L2Rpdj5gO1xuXG4vKipcbiAqIEFsbCB0aGUgcG9zc2libGUgdHlwZXMgZm9yIGEgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEBlbnVtXG4gKi9cbmV4cG9ydCBsZXQgQ29uc29sZUxpbmVUeXBlID0ge1xuICAgIFRFWFQ6IFwidGV4dFwiLFxuICAgIEhUTUw6IFwiaHRtbFwiLFxuICAgIFBMT1Q6IFwicGxvdFwiLFxuICAgIElNQUdFOiBcImltYWdlXCIsXG4gICAgUFlHQU1FOiBcInB5Z2FtZVwiLFxuICAgIFRVUlRMRTogXCJ0dXJ0bGVcIixcbiAgICBFVkFMOiBcImV2YWxcIixcbiAgICBTVEFSVF9FVkFMOiBcInN0YXJ0X2V2YWxcIixcbiAgICBWQUxVRTogXCJ2YWx1ZVwiLFxuICAgIElOUFVUOiBcImlucHV0XCIsXG4gICAgVEVTVF9DQVNFOiBcInRlc3RfY2FzZVwiXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IHZlcnNpb24gb2YgYSBsaW5lIGluIHRoZSBjb25zb2xlLiBBbGwgb3RoZXIgY29uc29sZSBsaW5lc1xuICogc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLiBDcml0aWNhbGx5LCB0aGV5IG5lZWQgdG8gaW1wbGVtZW50IGEgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdHlwZSwgY29udGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIGJhY2sgdG8gdGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZS5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtCbG9ja1B5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdGVnb3JpemVzIHdoYXQga2luZCBvZiBsaW5lIHRoaXMgaXMgKHRleHQvaHRtbC9wbG90L2V0Yy4pXG4gICAgICAgICAqIEB0eXBlIHtDb25zb2xlTGluZVR5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdHVhbCBkYXRhIHN0b3JlZCBvbiB0aGlzIGxpbmUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0YWRhdGEgYWJvdXQgd2hlcmUgdGhlIGxpbmUgb3JpZ2luYXRlZCBmcm9tIGluIHRoZSBjb2RlLlxuICAgICAgICAgKiBAdHlwZSB7e2ZpbGVuYW1lOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgc3RlcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IFNrLmN1cnJGaWxlbmFtZSxcbiAgICAgICAgICAgIHN0ZXA6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAsXG4gICAgICAgICAgICBsaW5lOiBtYWluLmNvbXBvbmVudHMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSFRNTCBjb250ZW50IHN0b3JlZCBvbiB0aGlzIGxpbmUsIG1lYW50IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAqIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAdHlwZSB7KnxqUXVlcnkuZm4uaW5pdHxqUXVlcnl8SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh0bWwgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiAgXCJibG9ja3B5LXByaW50ZXItb3V0cHV0XCIsXG4gICAgICAgICAgICBcImRhdGEtY29udGFpbmVyXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnQsXG4gICAgICAgICAgICBcImRhdGEtdG9nZ2xlXCI6IFwidG9vbHRpcFwiLFxuICAgICAgICAgICAgXCJkYXRhLXBsYWNlbWVudFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiZGF0YS1zdGVwXCI6IHRoaXMub3JpZ2luLnN0ZXAsXG4gICAgICAgICAgICBcInRpdGxlXCI6IFwiU3RlcCBcIiArIHRoaXMub3JpZ2luLnN0ZXAgKyBcIiwgTGluZSBcIiArIHRoaXMub3JpZ2luLmxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxpbmUgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhbWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU2t1bHB0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc29sZSBsaW5lJ3MgY29udGVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0b1NrdWxwdCgpIHtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkodGhpcy5jb250ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhpcyBjb25zb2xlIGxpbmUgYnkgZGVsZXRpbmcgaXRzIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLmh0bWwucmVtb3ZlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVR1cnRsZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICAvLyBUT0RPOiBDYXB0dXJlIHR1cnRsZSBjb21tYW5kcyBmb3IgdHJhY2luZyBwdXJwb3Nlc1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlRVUlRMRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS10dXJ0bGUtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5wcmVwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbFswXS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5wb3NpdGlvbigpLnRvcDtcbiAgICAgICAgICAgIC8vJCgnaHRtbCcpLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVB5Z2FtZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlBZR0FNRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1weWdhbWUtb3V0cHV0XCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuO1xuICAgICAgICB0aGlzLnB5Z2FtZU9iaiA9IHB5Z2FtZU9iajtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIC8vU2subWFpbl9jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q2FudmFzXCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLmh0bWwucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5zY3JvbGxUb3AoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICAvLyBTdGFydHMgb2ZmIGFzIGEgbm8tb3BcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7fTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNlY29uZFJvdy5yZXN0b3JlUGFuZWwoKTtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZShjbGVhbnVwRnVuY3Rpb24sIGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwID0gKCkgPT4gY2xlYW51cEZ1bmN0aW9uKHRoaXMucHlnYW1lT2JqLCBsaXN0ZW5lcnMpO1xuICAgIH1cblxufVxuXG5jbGFzcyBDb25zb2xlTGluZUltYWdlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLklNQUdFLCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLWltYWdlLW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVBsb3QgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUExPVCwgY29udGVudCk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1wbG90LW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVGV4dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGFkZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQgKyBjb250ZW50O1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWVuY29kZWRUZXh0IHx8IGVuY29kZWRUZXh0LnRyaW0oKS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgIGVuY29kZWRUZXh0ID0gXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8c2FtcD48L3NhbXA+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVmFsdWUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5WQUxVRSwgY29udGVudCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8Y29kZT48L2NvZGU+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW5wdXQgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgcHJvbXB0TWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU5QVVQsIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSW5wdXQgYm94IGZvciByZWNlaXZpbmcgaW5wdXQoKSBmcm9tIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICovXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIC8vIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbmluZ1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBJbnB1dCBmb3JtXG4gICAgICAgICAgICBsZXQgaW5wdXRGb3JtID0gJChcIjxpbnB1dCB0eXBlPSd0ZXh0JyAvPlwiKTtcbiAgICAgICAgICAgIC8vIEVudGVyIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0QnRuID0gJChcIjxidXR0b24+PC9idXR0b24+XCIsIHtcImh0bWxcIjogXCJFbnRlclwifSk7XG4gICAgICAgICAgICAvLyBHcm91cCBmb3JtIGFuZCBidXR0b25cbiAgICAgICAgICAgIGxldCBpbnB1dEdyb3VwID0gJChcIjxkaXY+PC9kaXY+XCIsIHtcImNsYXNzXCI6IFwiYmxvY2tweS1jb25zb2xlLWlucHV0XCJ9KTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0Rm9ybSk7XG4gICAgICAgICAgICBpbnB1dEdyb3VwLmFwcGVuZChpbnB1dEJ0bik7XG4gICAgICAgICAgICAvLyBQcm9tcHQgYm94LCBuZXcgbGluZSwgaW5wdXQgZ3JvdXBcbiAgICAgICAgICAgIGxldCBpbnB1dEJveCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0TXNnID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgIHtcImh0bWxcIjogZW5jb2RlZFRleHR9KTtcbiAgICAgICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoaW5wdXRNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRCb3guYXBwZW5kKCQoXCI8YnI+XCIpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoaW5wdXRHcm91cCk7XG4gICAgICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQoaW5wdXRCb3gpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvLyBNYWtlIGl0IGludGVyYWN0aXZlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlSW50ZXJhY3RpdmUoaW5wdXRGb3JtLCBpbnB1dEJ0bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIG1ha2VJbnRlcmFjdGl2ZShpbnB1dCwgYnV0dG9uKSB7XG4gICAgICAgIGxldCByZXNvbHZlT25DbGljaztcbiAgICAgICAgbGV0IHN1Ym1pdHRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZU9uQ2xpY2sgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgbGV0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSBpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2godXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnV0dG9uLmNsaWNrKHN1Ym1pdEZvcm0pO1xuICAgICAgICBpbnB1dC5rZXl1cCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dEluZGV4LCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICBpbnB1dC52YWwodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlZFByb21pc2U7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZUV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmVJbnB1dCB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBcIkV2YWx1YXRlOlwiKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5TVEFSVF9FVkFMKTtcbiAgICAgICAgdGhpcy5odG1sLmFwcGVuZCgkKFNUQVJUX0VWQUxfSFRNTCkpO1xuICAgICAgICB0aGlzLmh0bWwuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmV4ZWN1dGUuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5Q29uc29sZSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZm9yIG1hbmFnaW5nIHRoZSBjb25zb2xlLCB3aXRoIGZlYXR1cmVzIGZvciB0aGluZ3MgbGlrZSBwcmludGluZywgcGxvdHRpbmcsIGV2YWxpbmcsIGlucHV0aW5nLlxuICAgICAqIFRoZSBcInByaW50ZXJcIiBpcyB0aGUgcmVnaW9uIHdoZXJlIHdlIHB1dCB0aGluZ3MsIGFzIG9wcG9zZWQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3aG9sZS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZyA9IHRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlclwiKTtcblxuICAgICAgICB0aGlzLk1JTklNVU1fV0lEVEggPSAyMDA7XG4gICAgICAgIHRoaXMuTUlOSU1VTV9IRUlHSFQgPSAyMDA7XG4gICAgICAgIHRoaXMuREVGQVVMVF9IRUlHSFQgPSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCk7IC8vIExldCBDU1MgZGVmaW5lIHRoaXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuXG4gICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQ7XG4gICAgICAgIC8vdGhpcy5pbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZSB1c2VyIG1vZGlmaWVzIGEgZmlsZSwgdGhlbiBtYWtlIHRoZSBjb25zb2xlIGxvb2sgZmFkZWQgYSBsaXR0bGVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXR1cyBvZiB0aGUgcHJpbnRlciwgaW5jbHVkaW5nIHJlbW92aW5nIGFueSB0ZXh0IGluIGl0IGFuZFxuICAgICAqIGZpeGluZyBpdHMgc2l6ZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmVtcHR5KCk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIHJlc2V0IGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBudWxsO1xuICAgICAgICBTay5UdXJ0bGVHcmFwaGljcyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUdXJ0bGVMaW5lLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmxvYWRBc3NldC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbnVsbDtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZ2V0VHVydGxlTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHVydGxlTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50dXJ0bGVMaW5lID0gbmV3IENvbnNvbGVMaW5lVHVydGxlKHRoaXMubWFpbik7XG4gICAgICAgICAgICB0aGlzLnR1cnRsZUxpbmUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCB3ZSdsbCBkbyBzb1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFByaW50ZXJEaW1lbnNpb24gPSB0aGlzLnByaW50ZXJUYWcud2lkdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KGN1cnJlbnRQcmludGVyRGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICBTay5UdXJ0bGVHcmFwaGljcy5oZWlnaHQgPSBjdXJyZW50UHJpbnRlckRpbWVuc2lvbi00MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50dXJ0bGVMaW5lLmh0bWxbMF07XG4gICAgfVxuXG4gICAgaGFuZGxlUHlnYW1lUmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgYW5kIHRoZSBuZXdIZWlnaHQgaXMgYmlnZ2VyIHRoYW4gZGVmYXVsdCwgd2UnbGwgY2hhbmdlIGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpICYmXG4gICAgICAgICAgICBuZXdIZWlnaHQgPiB0aGlzLkRFRkFVTFRfSEVJR0hUKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KDMwK25ld0hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcHlnYW1lIHdpbmRvdyBpcyB3aWRlciB0aGFuIHRoZSBjb25zb2xlLCB3ZSdsbCBleHBhbmQgdGVtcG9yYXJpbHkuXG4gICAgICAgIGlmIChuZXdXaWR0aCA+IHRoaXMucHJpbnRlclRhZy53aWR0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuc2Vjb25kUm93Lm1ha2VXaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5pc2hUdXJ0bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc2F2ZVR1cnRsZU91dHB1dCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50dXJ0bGVMaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMudHVydGxlTGluZS5odG1sLmZpbmQoXCJjYW52YXNcIikubGFzdCgpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUltYWdlKFwidHVydGxlX291dHB1dFwiLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5weWdhbWVMaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMucHlnYW1lTGluZS5jYW52YXM7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlSW1hZ2UoXCJ0dXJ0bGVfb3V0cHV0XCIsIGRhdGFVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHRoZXJlIGFyZSBubyB0dXJ0bGVzIHRvIHNhdmU/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0dXJ0bGVzIHNob3VsZCBiZSBiYXNlZCBvbiB0aGUgY3VycmVudCB3aWR0aFxuICAgIG5ld1R1cnRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fV0lEVEgsIHRoaXMucHJpbnRlclRhZy53aWR0aCgpLTQwKTtcbiAgICB9XG5cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fSEVJR0hULCB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkrNDApO1xuICAgIH1cblxuICAgIGlzTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZWFjaCBwcmludGVkIGVsZW1lbnQgaW4gdGhlIHByaW50ZXIgYW5kIG1ha2VzIGl0IGhpZGRlblxuICAgICAqIG9yIHZpc2libGUsIGRlcGVuZGluZyBvbiB3aGF0IHN0ZXAgd2UncmUgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcCAtIFRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIGV4ZWN1dGVkIHByb2dyYW0gdGhhdCB3ZSdyZSBvbjsgZWFjaCBlbGVtZW50IGluIHRoZSBwcmludGVyIG11c3QgYmUgbWFya2VkIHdpdGggYSBcImRhdGEtc3RlcFwiIHByb3BlcnR5IHRvIHJlc29sdmUgdGhpcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFnZSAtIERlcHJlY2F0ZWQsIG5vdCBzdXJlIHdoYXQgdGhpcyBldmVuIGRvZXMuXG4gICAgICovXG4gICAgc3RlcFByaW50ZXIoc3RlcCwgcGFnZSkge1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcuZmluZChcIi5ibG9ja3B5LXByaW50ZXItb3V0cHV0XCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKFwiZGF0YS1zdGVwXCIpIDw9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmludCBhIGxpbmUgdG8gdGhlIG9uLXNjcmVlbiBwcmludGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lVGV4dCAtIEEgbGluZSBvZiB0ZXh0IHRvIGJlIHByaW50ZWQgb3V0LlxuICAgICAqL1xuICAgIHByaW50KGxpbmVUZXh0KSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgbWVhbnMgZG8gbm90aGluZy5cbiAgICAgICAgLy8gcHJpbnQoXCJcIiwgZW5kPVwiXCIpXG4gICAgICAgIGlmICghbGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpbmVUZXh0LmNoYXJBdChsaW5lVGV4dC5sZW5ndGgtMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BsaXRMaW5lcyA9IGxpbmVUZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBpZiAodGhpcy5saW5lQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLmFkZENvbnRlbnQoc3BsaXRMaW5lc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0xOyBpIDwgc3BsaXRMaW5lcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRoaXMubGluZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0aGlzLmxpbmVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHBsb3QocGxvdHMpIHtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lUGxvdCh0aGlzLm1haW4sIHBsb3RzKTtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90QnVmZmVyO1xuICAgIH1cblxuICAgIHB5Z2FtZShzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgaWYgKHRoaXMucHlnYW1lTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbmV3IENvbnNvbGVMaW5lUHlnYW1lKHRoaXMubWFpbiwgc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKTtcbiAgICAgICAgICAgIHRoaXMucHlnYW1lTGluZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5weWdhbWVMaW5lO1xuICAgIH1cblxuICAgIHByaW50UElMSW1hZ2UoaW1hZ2VEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVFwiLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lSW1hZ2UodGhpcy5tYWluLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwcmludFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBwcmludGVkVmFsdWUgPSBuZXcgQ29uc29sZUxpbmVWYWx1ZSh0aGlzLm1haW4sIHZhbHVlKTtcbiAgICAgICAgcHJpbnRlZFZhbHVlLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gcHJpbnRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIFByb21pc2UgZnJvbSB0aGUgSW5wdXQgYm94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb21wdE1lc3NhZ2UgLSBNZXNzYWdlIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbnB1dCh0aGlzLm1haW4sIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9O1xuXG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUV2YWx1YXRlKHRoaXMubWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIGJlZ2luRXZhbCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RXZhbHVhdGlvbiA9IG5ldyBDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RXZhbHVhdGlvbi5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmNvbmRpdGlvbmFsbHkgc2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnRhZy5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcucHJvcChcInNjcm9sbEhlaWdodFwiKSAtIHRoaXMudGFnLnByb3AoXCJjbGllbnRIZWlnaHRcIilcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuXG59IiwiaW1wb3J0IHtzbHVnfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLy8gVE9ETzogZWRpdG9yLmJtLmJsb2NrRWRpdG9yLmV4dHJhVG9vbHNbXVxuXG5leHBvcnQgbGV0IF9JTVBPUlRFRF9EQVRBU0VUUyA9IHt9O1xuZXhwb3J0IGxldCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMgPSB7fTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdmVyeSBzaW1wbGlzdGljIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgdHJhbnNmb3JtXG4gKiBhIGdpdmVuIGJ1dHRvbiBpbnRvIGEgXCJMb2FkZWRcIiBzdGF0ZSAoZGlzYWJsZWQsIHByZXNzZWQgc3RhdGUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ0biAtIEFuIEhUTUwgZWxlbWVudCB0byBjaGFuZ2UgdGhlIHRleHQgb2YuXG4gKi9cbmxldCBzZXRCdXR0b25Mb2FkZWQgPSBmdW5jdGlvbiAoYnRuKSB7XG4gICAgYnRuLmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpXG4gICAgICAgIC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLnRleHQoXCJMb2FkZWRcIilcbiAgICAgICAgLmF0dHIoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbm5lY3RzIHRvIHRoZSBDT1JHSVMgZGF0YXNldHMgYW5kIG1hbmFnZXMgaW50ZXJhY3Rpb25zXG4gKiB3aXRoIHRoZW0uIFRoaXMgaW5jbHVkZXMgbG9hZGluZyBpbiBkYXRhc2V0cyBhdCBsYXVuY2ggYW5kIG9uLXRoZS1mbHkuXG4gKiBOb3RlIHRoYXQgdGhpcyBoYXMgbm8gcHJlc2VuY2Ugb24gc2NyZWVuLCBzbyBpdCBkb2VzIG5vdCBoYXZlIGEgdGFnLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlDb3JnaXN9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlDb3JnaXMobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICB0aGlzLmxvYWRlZERhdGFzZXRzID0gW107XG4gICAgdGhpcy5sb2FkRGF0YXNldHMoKTtcbn1cblxuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUubG9hZERhdGFzZXRzID0gZnVuY3Rpb24gKHNpbGVudGx5KSB7XG4gICAgLy8gTG9hZCBpbiBlYWNoIHRoZSBkYXRhc2V0c1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbCxcbiAgICAgICAgZWRpdG9yID0gdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLFxuICAgICAgICBzZXJ2ZXIgPSB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXI7XG4gICAgbGV0IGltcG9ydHMgPSBbXTtcbiAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzKCkuc3BsaXQoXCIsXCIpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIShuYW1lIGluIEJsb2NrTWlycm9yQmxvY2tFZGl0b3IuRVhUUkFfVE9PTFMpKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2guYXBwbHkoaW1wb3J0cywgdGhpcy5pbXBvcnREYXRhc2V0KHNsdWcobmFtZSksIG5hbWUsIHNpbGVudGx5KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgYXJlIGxvYWRlZCwgdXBkYXRlIHRoZSB0b29sYm94LlxuICAgICQud2hlbi5hcHBseSgkLCBpbXBvcnRzKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRSSUdHRVJFRFwiKTtcbiAgICAgICAgZWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlcnZlci5maW5hbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIGRlZmluaXRpb25zIGZvciBhIGRhdGFzZXQgaW50byB0aGUgZW52aXJvbm1lbnQsIGluY2x1ZGluZ1xuICogdGhlIGRhdGFzZXQgKGFzIGEgSlMgZmlsZSksIHRoZSBza3VscHQgYmluZGluZ3MsIGFuZCB0aGUgYmxvY2tseVxuICogYmluZGluZ3MuIFRoaXMgcmVxdWlyZXMgYWNjZXNzIHRvIGEgQ09SR0lTIHNlcnZlciwgYW5kIG9jY3Vyc1xuICogYXN5bmNocm9ub3VzbHkuIFRoZSByZXF1ZXN0cyBhcmUgZmlyZWQgYW5kIHRoZWlyIGRlZmVycmVkIG9iamVjdHNcbiAqIGFyZSByZXR1cm5lZCAtIGNhbGxlcnMgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHBlcmZvcm0gYW4gYWN0aW9uXG4gKiBvbiBjb21wbGV0aW9uIG9mIHRoZSBpbXBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNsdWcgLSBUaGUgVVJMIHNhZmUgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSB1c2VyLWZyaWVuZGx5IHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheS48RGVmZXJyZWQ+fSAtIFJldHVybnMgdGhlIGFzeW5jIHJlcXVlc3RzIGFzIGRlZmVycmVkIG9iamVjdHMuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLmltcG9ydERhdGFzZXQgPSBmdW5jdGlvbiAoc2x1ZywgbmFtZSkge1xuICAgIGxldCB1cmxfcmV0cmlldmFscyA9IFtdO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJpbXBvcnREYXRhc2V0c1wiKSkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW1wb3J0RGF0YXNldHMgKyBcImJsb2NrcHkvXCIgKyBzbHVnICsgXCIvXCIgKyBzbHVnO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5sb2FkaW5nRGF0YXNldHMucHVzaChuYW1lKTtcbiAgICAgICAgLy8gQWN0dWFsbHkgZ2V0IGRhdGFcbiAgICAgICAgbGV0IGdldERhdGFzZXQgPSAkLmdldFNjcmlwdChyb290ICsgXCJfZGF0YXNldC5qc1wiKTtcbiAgICAgICAgLy8gTG9hZCBnZXRDb21wbGV0ZSBzaWxlbnRseSBpbiB0aGUgYmFja2dyb3VuZCBiZWNhdXNlIGl0cyBiaWcgOihcbiAgICAgICAgbGV0IGdldENvbXBsZXRlID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2NvbXBsZXRlLmpzXCIpO1xuICAgICAgICBsZXQgZ2V0U2t1bHB0ID0gJC5nZXQocm9vdCArIFwiX3NrdWxwdC5qc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bXCJzcmMvbGliL1wiICsgc2x1ZyArIFwiL19faW5pdF9fLmpzXCJdID0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnZXRCbG9ja2x5ID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2Jsb2NrbHkuanNcIik7XG4gICAgICAgIC8vIE9uIGNvbXBsZXRpb24sIHVwZGF0ZSBtZW51cy5cbiAgICAgICAgJC53aGVuKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZERhdGFzZXRzLnB1c2goc2x1Zyk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dFRvQmxvY2tzLmhpZGRlbkltcG9ydHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5mb3JjZUJsb2NrUmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1cmxfcmV0cmlldmFscy5wdXNoKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxfcmV0cmlldmFscztcbn07XG5cbi8qKlxuICogT3BlbnMgYSBkaWFsb2cgYm94IHRvIHByZXNlbnQgdGhlIHVzZXIgd2l0aCB0aGUgZGF0YXNldHMgYXZhaWxhYmxlXG4gKiB0aHJvdWdoIHRoZSBDT1JHSVMgc2VydmVyLiBUaGlzIHJlcXVpcmVzIGEgY2FsbCwgc28gdGhpcyBtZXRob2RcbiAqIGNvbXBsZXRlcyBhc3luY2hyb25vdXNseS4gVGhlIGRpYWxvZyBpcyBjb21wb3NlZCBvZiBhIHRhYmxlIHdpdGhcbiAqIGJ1dHRvbnMgdG8gbG9hZCB0aGUgZGF0YXNldHMgKE1vcmUgdGhhbiBvbmUgZGF0YXNldCBjYW4gYmUgbG9hZGVkXG4gKiBmcm9tIHdpdGhpbiB0aGUgZGlhbG9nIGF0IGEgdGltZSkuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cztcbiAgICAgICAgJC5nZXRKU09OKHJvb3QgKyBcImluZGV4Lmpzb25cIiwgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHVwIHRoZSBCb2R5XG4gICAgICAgICAgICBsZXQgZGF0YXNldHMgPSBkYXRhLmJsb2NrcHk7XG4gICAgICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHJvb3QrXCJibG9ja3B5L2luZGV4Lmh0bWxcIjtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICQoYDxwPkRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0IDxhIGhyZWY9JyR7ZG9jdW1lbnRhdGlvbn0nIHRhcmdldD1fYmxhbms+dXJsPC9hPjwvcD5gKTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gJChcIjx0YWJsZT48L3RhYmxlPlwiLCB7XCJjbGFzc1wiOiBcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWRcIn0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YXNldHMpLnNvcnQoKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2x1Z2dlZE5hbWUgPSBzbHVnKGRhdGFzZXRzW25hbWVdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxldCBidG4gPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5Mb2FkPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGltZ1NyYyA9IHJvb3QrXCIuLi9pbWFnZXMvZGF0YXNldHMvXCIrbmFtZStcIi1pY29uLnBuZ1wiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZERhdGFzZXRzLmluZGV4T2Yoc2x1Z2dlZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnRuLmNsaWNrKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydERhdGFzZXQoc2x1Z2dlZE5hbWUsIFwiRGF0YSAtIFwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xldCBpbWcgPSBgPGltZyBzcmM9JyR7aW1nU3JjfScgY2xhc3M9XCJjb3JnaXMtaWNvblwiPmA7XG4gICAgICAgICAgICAgICAgJChcIjx0cj48L3RyPlwiKVxuICAgICAgICAgICAgICAgICAgICAvLy5hcHBlbmQoJChcIjx0ZD5cIiArIGltZyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD5cIiArIGRhdGFzZXRzW25hbWVdLnRpdGxlICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0ub3ZlcnZpZXcgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+PC90ZD5cIikuYXBwZW5kKGJ0bikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhib2R5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRUbyhzdGFydCk7XG4gICAgICAgICAgICAvLyBTaG93IHRoZSBhY3R1YWwgZGlhbG9nXG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuc2hvdyhcIkltcG9ydCBEYXRhc2V0c1wiLCBzdGFydCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE2NDUwMzEyMDQwMzVcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvYWNiYXJ0L1Byb2plY3RzL2Jsb2NrcHktZWR1L2Jsb2NrcHkvbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiLi4vXCIsXCJobXJcIjp0cnVlLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTY0NTAzMTIwNDA0NFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9hY2JhcnQvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBUT0RPOiBEeWFubWljYWxseSBwb3B1bGF0ZSBhcmlhLWxhYmVsbGVkYnkgaW4gdGhpcyBhbmQgb3RoZXIgcGxhY2VzXG5cbmV4cG9ydCBsZXQgRElBTE9HX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz0nYmxvY2tweS1kaWFsb2cgbW9kYWwgaGlkZGVuJ1xuICAgICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICAgICBhcmlhLWxhYmVsPSdEaWFsb2cnXG4gICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZGlhbG9nIG1vZGFsLWxnJyByb2xlPVwiZG9jdW1lbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWNvbnRlbnQnIHJvbGU9J3JlZ2lvbicgYXJpYS1sYWJlbD0nRGlhbG9nIGNvbnRlbnQnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz0nbW9kYWwtdGl0bGUnPkR5bmFtaWMgQ29udGVudDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWJvZHknIHN0eWxlPSdtYXgtd2lkdGg6MTAwJTsgbWF4LWhlaWdodDo0MDBweCc+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlIG1vZGFsLWNsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJz5DbG9zZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tc3VjY2VzcyBtb2RhbC1va2F5JyBkYXRhLWRpc21pc3M9J21vZGFsJz5Pa2F5PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuYDtcblxuLyoqXG4gKiBBIHV0aWxpdHkgb2JqZWN0IGZvciBxdWlja2x5IGFuZCBjb252ZW5pZW50bHkgZ2VuZXJhdGluZyBkaWFsb2cgYm94ZXMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3QgZHluYW1pY2FsbHkgY3JlYXRlIG5ldyBib3hlczsgaXQgcmV1c2VzIHRoZSBzYW1lIG9uZVxuICogb3ZlciBhbmQgb3ZlciBhZ2Fpbi4gSXQgdHVybnMgb3V0IGR5bmFtaWNhbGx5IGdlbmVyYXRpbmcgbmV3IGRpYWxvZyBib3hlc1xuICogaXMgYSBwYWluISBTbyB3ZSBjYW4ndCBzdGFjayB0aGVtLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlEaWFsb2d9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeURpYWxvZyhtYWluLCB0YWcpIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgdGhpcy50aXRsZVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLXRpdGxlXCIpO1xuICAgIHRoaXMuYm9keVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLWJvZHlcIik7XG4gICAgdGhpcy5mb290ZXJUYWcgPSB0YWcuZmluZChcIi5tb2RhbC1mb290ZXJcIik7XG4gICAgdGhpcy5va2F5QnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtb2theVwiKTtcbiAgICB0aGlzLmNsb3NlQnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtY2xvc2VcIik7XG5cbiAgICB0aGlzLnllcyA9ICgpID0+IHt9O1xuICAgIHRoaXMubm8gPSAoKSA9PiB7fTtcbiAgICB0aGlzLm9rYXlCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnllcygpO1xuICAgICAgICB0aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMubm8oKTtcbiAgICAgICAgLy90aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG59XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgZXh0ZXJuYWxseSBhdmFpbGFibGUgZnVuY3Rpb24gZm9yIHBvcHBpbmcgdXAgYSBkaWFsb2dcbiAqIG1lc3NhZ2UuIFRoaXMgbWVudSB3aWxsIGJlIGRyYWdnYWJsZSBieSBpdHMgdGl0bGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBtZXNzYWdlIGRpYWxvZy4gQ2FuIGhhdmUgSFRNTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG1lc3NhZ2UgZGlhbG9nLiBDYW4gaGF2ZSBIVE1MLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25jbG9zZSAtIEEgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2cuXG4gKi9cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAodGl0bGUsIGJvZHksIG9uY2xvc2UpIHtcbiAgICB0aGlzLnRpdGxlVGFnLmh0bWwodGl0bGUpO1xuICAgIHRoaXMuYm9keVRhZy5odG1sKGJvZHkpO1xuICAgIHRoaXMudGFnLm1vZGFsKFwic2hvd1wiKTtcbiAgICB0aGlzLm9rYXlCdXR0b24uaGlkZSgpO1xuICAgIHRoaXMudGFnLmRyYWdnYWJsZSh7XG4gICAgICAgIFwiaGFuZGxlXCI6IFwiLm1vZGFsLXRpdGxlXCJcbiAgICB9KTtcblxuICAgIHRoaXMudGFnLm9uKFwiaGlkZGVuLmJzLm1vZGFsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvbmNsb3NlICE9PSB1bmRlZmluZWQgJiYgb25jbG9zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKHRpdGxlLCBib2R5LCB5ZXMsIG5vLCB5ZXNUZXh0KSB7XG4gICAgaWYgKHllc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ZXNUZXh0ID0gXCJPa2F5XCI7XG4gICAgfVxuICAgIHRoaXMuc2hvdyh0aXRsZSwgYm9keSwgbm8pO1xuICAgIHRoaXMueWVzID0geWVzO1xuICAgIHRoaXMubm8gPSBubztcbiAgICB0aGlzLm9rYXlCdXR0b24uc2hvdygpLmh0bWwoeWVzVGV4dCk7XG4gICAgLy8gVE9ETzogYWRkIG9rYXkgYnV0dG9uIGFuZCBjYW5jZWwgYnV0dG9uXG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5BU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbmZpcm0oXCJBc3NpZ25tZW50IENoYW5nZWRcIiwgXCJZb3VyIGluc3RydWN0b3IgaGFzIG1hZGUgY2hhbmdlcyB0byB0aGlzIGFzc2lnbm1lbnQuIFdvdWxkIHlvdSBsaWtlIHRvIHJlbG9hZD8gQWxsIHlvdXIgd29yayBoYXMgYmVlbiBzYXZlZC5cIiwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMb2FkaW5nIEFzc2lnbm1lbnRcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9MSVNUSU5HX1VQTE9BREVEX0ZJTEVTID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExpc3RpbmcgVXBsb2FkZWQgRmlsZXNcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbGlzdGluZyB0aGUgdXBsb2FkZWQgZmlsZXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfVVBMT0FESU5HX0ZJTEUgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgVXBsb2FkZWQgRmlsZVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB1cGxvYWRpbmcgdGhlIGZpbGUuPGJyPlxuUGxlYXNlIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBTYXZpbmcgQXNzaWdubWVudFwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBzYXZpbmcgdGhlIGFzc2lnbm1lbnQuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfU0hPV19TVFVERU5UX0VSUk9SID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5zaG93KFwiT3JpZ2luYWwgRXJyb3JcIiwgYFdoZW4gSSByYW4geW91ciBjb2RlLCBJIGVuY291bnRlcmVkIGFuIGVycm9yOlxcblxcbjxkaXYgY2xhc3M9XCJibG9ja3B5LWRpYWxvZy1zdHVkZW50LWVycm9yLW1lc3NhZ2VcIj4ke2Vycm9yfTwvZGl2PmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuUE9TSVRJVkVfRkVFREJBQ0tfRlVMTCA9IGZ1bmN0aW9uICh0aXRsZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyh0aXRsZSwgbWVzc2FnZSk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5TQ1JFRU5TSE9UX0JMT0NLUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPXG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBVcGRhdGluZyBTdWJtaXNzaW9uIFN0YXR1c1wiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB1cGRhdGluZyB5b3VyIHN1Ym1pc3Npb24gc3RhdHVzLjxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi5gKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xPQURJTkdfSElTVE9SWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMb2FkaW5nIEhpc3RvcnlcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB5b3VyIGhpc3RvcnkuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuT0ZGRVJfRk9SSyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgc2V0dXBVcmwgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzLmluc3RydWN0aW9uc0Fzc2lnbm1lbnRTZXR1cDtcbiAgICBzZXR1cFVybCA9IHNldHVwVXJsID8gYCAoPGEgaHJlZj1cIiR7c2V0dXBVcmx9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+SG93IGRvIEkgZG8gdGhhdD88L2E+KWAgOiBcIlwiO1xuICAgIHRoaXMuc2hvdyhcIkFzc2lnbm1lbnQgTm90IE93bmVkOyBGb3JrP1wiLCBgXG4gICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgSXQgbG9va3MgbGlrZSB5b3Ugd2FudCB0byBlZGl0IHRoaXMgYXNzaWdubWVudCwgYnV0IHlvdSBhcmUgbm90IGFuIGluc3RydWN0b3JcbiAgICBvciBkZXNpZ25lciBpbiB0aGUgY291cnNlIHRoYXQgb3ducyBpdCAoXCJDb3Vyc2UgTmFtZVwiKS4gV291bGQgeW91IGxpa2UgdG8gZm9ya1xuICAgIHRoaXMgYXNzaWdubWVudCAob3IgaXRzIGVudGlyZSBncm91cCkgc28gdGhhdCB5b3UgY2FuIHNhdmUgeW91ciBtb2RpZmljYXRpb25zP1xuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICAgIFJlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgTGF1bmNoIFVSTCBpbiB0aGUgYXNzaWdubWVudHMnIHNldHRpbmdzIG9uIENhbnZhcyEke3NldHVwVXJsfVxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlJz5Gb3JrIGVudGlyZSBhc3NpZ25tZW50IGdyb3VwPC9idXR0b24+PC9kaXY+XG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUnPkZvcmsganVzdCB0aGlzIGFzc2lnbm1lbnQ8L2J1dHRvbj48L2Rpdj5cbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1kYW5nZXInPlJlc2V0IG15IGxvY2FsIGNoYW5nZXM8L2J1dHRvbj48L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCJcbiAgICAgICAgICAgICAgICBuYW1lPVwiYmxvY2tweS10cmFuc2Zlci1zdWJtaXNzaW9uc1wiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS10cmFuc2Zlci1zdWJtaXNzaW9uc1wiPlRyYW5zZmVyIFN0dWRlbnQgU3VibWlzc2lvbnMgZm9yIHRoaXMgY291cnNlPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tdGV4dFwiIGZvcj1cImJsb2NrcHktY291cnNlLWlkXCI+TmV3IG93bmluZyBjb3Vyc2UgaWQ6IDwvbGFiZWw+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJibG9ja3B5LWNvdXJzZS1pZFwiIHZhbHVlPVwiJHt0aGlzLm1haW4ubW9kZWwudXNlci5jb3Vyc2VJZCgpfVwiPlxuICAgIDwvZGl2PlxuICAgIGApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRURJVF9JTlBVVFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGlucHV0VGV4dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5qb2luKFwiXFxuXCIpO1xuICAgIGxldCBjbGVhcklucHV0cyA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCkgPyBcIlwiIDogXCJjaGVja2VkXCI7XG4gICAgbGV0IHllcyA9ICgpID0+IHtcbiAgICAgICAgbGV0IGNoZWNrZWQgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktcmVtZW1iZXItaW5wdXRzXCIpLnByb3AoXCJjaGVja2VkXCIpO1xuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWlucHV0LWxpc3RcIikudmFsKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCFjaGVja2VkKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dChpbnB1dHMpO1xuICAgIH07XG4gICAgdGhpcy5jb25maXJtKFwiRWRpdCBSZW1lbWJlcmVkIElucHV0c1wiLCBgXG5cbjxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0cyBmb3JtLWNoZWNrLWlucHV0XCJcbiAgICAgICAgbmFtZT1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzXCIgJHtjbGVhcklucHV0c30+XG48bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIj5SZXVzZSBpbnB1dHMgZm9yIG5leHQgZXhlY3V0aW9uPC9sYWJlbD5cbjwvZGl2PlxuXG48dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWlucHV0LWxpc3QgZm9ybS1jb250cm9sXCIgcm93cz1cIjRcIj4ke2lucHV0VGV4dH08L3RleHRhcmVhPjxicj5cbkVkaXQgdGhlIGlucHV0cyBhYm92ZSB0byBzdG9yZSBhbmQgcmV1c2UgdGhlbSBhY3Jvc3MgbXVsdGlwbGUgZXhlY3V0aW9ucy5cbkVhY2ggaW5wdXQgc2hvdWxkIGJlIHB1dCBvbiBpdHMgb3duIGxpbmUuXG5Zb3UgZG8gbm90IG5lZWQgcXVvdGVzOyB0aGUgdGV4dCB3aWxsIGJlIGVudGVyZWQgbGl0ZXJhbGx5LlxuIFxuYCwgeWVzLCB0aGlzLm5vLCBcIlNhdmVcIik7XG4gICAgLy8gVE9ETzogQWxsb3cgdXNlciB0byBzcGVjaWZ5IHRoZSBpbmZpbml0ZSBzdHJpbmcgdG8ga2VlcCBnaXZpbmcgd2hlbiB0aGUgb3RoZXJzIHJ1biBvdXRcbn07IiwiaW1wb3J0IHtFZGl0b3JzfSBmcm9tIFwiLi4vZWRpdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQudGFyZ2V0LmZpbGVzO1xuICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGUgPT5cbiAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5jdXJyZW50KCkudXBsb2FkRmlsZShlKVxuICAgICk7XG4gICAgZmlsZVJlYWRlci5maWxlTmFtZSA9IGZpbGVzWzBdLm5hbWU7XG4gICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGVzWzBdKTtcbiAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2x1Z2dpZnkodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1teYS16MC05XS9naSwgXCJfXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEZpbGUobW9kZWwsIGV2ZW50KSB7XG4gICAgbGV0IHtuYW1lLCBleHRlbnNpb24sIGNvbnRlbnRzLCBtaW1ldHlwZX0gPSBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS5kb3dubG9hZEZpbGUoKTtcbiAgICAvLyBNYWtlIHNhZmVcbiAgICBuYW1lID0gc2x1Z2dpZnkobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUgKyBleHRlbnNpb247XG4gICAgLy8gTWFrZSB0aGUgZGF0YSBkb3dubG9hZCBhcyBhIGZpbGVcbiAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50c10sIHt0eXBlOiBtaW1ldHlwZX0pO1xuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIG5hbWUpO1xuICAgIH0gZWxzZXtcbiAgICAgICAgbGV0IHRlbXBvcmFyeURvd25sb2FkTGluayA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgdGVtcG9yYXJ5RG93bmxvYWRMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgdGVtcG9yYXJ5RG93bmxvYWRMaW5rLmRvd25sb2FkID0gbmFtZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wb3JhcnlEb3dubG9hZExpbmspO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuY2xpY2soKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wb3JhcnlEb3dubG9hZExpbmspO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5maWxlU3lzdGVtID0gbWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW07XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGUgPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZUZpbGUoKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS5kZWxldGVGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlRGVsZXRlZCgpIHtcbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIHRoZSBwcmV2aW91cyBmaWxlIGluc3RlYWQgb2YgYSBkZWZhdWx0IGZpbGVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmVkaXRvcnMuY2hhbmdlRWRpdG9yKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIG9uRmlsZVVwZGF0ZWQoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5maWxlbmFtZSA9PT0gdGhpcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgLy90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZVN5c3RlbS5zdG9wV2F0Y2hpbmdGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy90aGlzLnRyYWNrQ3VycmVudEZpbGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrQ3VycmVudEZpbGUoKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS53YXRjaEZpbGUodGhpcy5maWxlbmFtZSwge1xuICAgICAgICAgICAgdXBkYXRlZDogdGhpcy5vbkZpbGVVcGRhdGVkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVkOiB0aGlzLm9uRmlsZURlbGV0ZWQuYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBuZXdGaWxlbmFtZTtcbiAgICAgICAgdGhpcy5maWxlID0gdGhpcy5maWxlU3lzdGVtLmdldEZpbGUobmV3RmlsZW5hbWUpO1xuICAgICAgICB0aGlzLnRyYWNrQ3VycmVudEZpbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdGaWxlbmFtZSAtIHRoZSBmaWxlbmFtZSB0aGF0IHRoZSBvdGhlciBlZGl0b3Igd2lsbCBiZSBzd2l0Y2hpbmcgdG9cbiAgICAgKiBAcGFyYW0gb2xkRWRpdG9yXG4gICAgICogQHBhcmFtIG5ld0VkaXRvclxuICAgICAqL1xuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS5zdG9wV2F0Y2hpbmdGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdGhpcy5maWxlLmhhbmRsZShjb250ZW50cyk7XG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBFZGl0b3JzLnBhcnNlRmlsZW5hbWUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBmaWxlbmFtZS5uYW1lLFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBmaWxlbmFtZS50eXBlLFxuICAgICAgICAgICAgY29udGVudHM6IHRoaXMuZmlsZS5oYW5kbGUoKSxcbiAgICAgICAgICAgIG1pbWV0eXBlOiBcInRleHQvcGxhaW5cIlxuICAgICAgICB9O1xuICAgIH1cbn0iLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7RGlzcGxheU1vZGVzfSBmcm9tIFwiLi9weXRob25cIjtcblxuY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HUyA9IFtcbiAgICBbXCJ0b29sYm94XCIsIFwidG9vbGJveFwiLCBcIm5vcm1hbFwiLCBcInRvb2xib3hcIiwgXCJXaGljaCB2ZXJzaW9uIG9mIHRoZSB0b29sYm94IHRvIHByZXNlbnQgdG8gdGhlIHVzZXIuXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlXCIsIFwiYmxvY2tweVwiLCBcInR5cGVcIiwgXCJUaGUgdHlwZSBvZiBxdWVzdGlvbjsgQmxvY2tQeSBwcm9ncmFtbWluZyBwcm9ibGVtcyBhcmUgdGhlIGRlZmF1bHQsIGJ1dCB3ZSBhbHNvIHN1cHBvcnQgc3RhdGljIHJlYWRpbmdzLCBxdWl6IHF1ZXN0aW9ucywgYW5kIGEgTWF6ZSBnYW1lLlwiXSxcbiAgICBbXCJwYXNzY29kZVwiLCBcInBhc3Njb2RlXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiQSBzdHJpbmcgdGhhdCB0aGUgdXNlciBtdXN0IGVudGVyIHRvIGFjY2VzcyB0aGUgcHJvYmxlbS4gSWYgYmxhbmssIHRoZW4gbm8gcGFzc2NvZGUgaXMgcHJvbXB0ZWQuXCJdLFxuICAgIC8vW1widG9vbGJveExldmVsXCIsIFwidG9vbGJveF9sZXZlbFwiLCBcIm5vcm1hbFwiLCBcInRvb2xib3hcIiwgXCJJTkNPTVBMRVRFOiBXaGF0IGxldmVsIG9mIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlciAoaGlkaW5nIGFuZCBzaG93aW5nIGNhdGVnb3JpZXMpLlwiXSxcbiAgICBbXCJzdGFydFZpZXdcIiwgXCJzdGFydF92aWV3XCIsIERpc3BsYXlNb2Rlcy5TUExJVCwgRGlzcGxheU1vZGVzLCBcIlRoZSBQeXRob24gZWRpdG9yIG1vZGUgdG8gc3RhcnQgaW4gd2hlbiB0aGUgc3R1ZGVudCBzdGFydHMgdGhlIHByb2JsZW0uXCJdLFxuICAgIFtcImRhdGFzZXRzXCIsIFwiZGF0YXNldHNcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJUaGUgY3VycmVudCBsaXN0IG9mIGRhdGFzZXRzIGF2YWlsYWJsZSBvbiBsb2FkIGFzIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZy5cIl0sXG4gICAgW1wiZGlzYWJsZVRpbWVvdXRcIiwgXCJkaXNhYmxlX3RpbWVvdXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgY29kZSBpcyBhbGxvd2VkIHRvIHJ1biB3aXRob3V0IHRpbWVvdXRzIChwb3RlbnRpYWxseSBhbGxvd2luZyBpbmZpbml0ZSBsb29wcykuXCJdLFxuICAgIFtcImlzUGFyc29uc1wiLCBcImlzX3BhcnNvbnNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhpcyBpcyBhIHBhcnNvbidzIHN0eWxlIHF1ZXN0aW9uIChqdW1ibGVkKS5cIl0sXG4gICAgW1wiZGlzYWJsZUZlZWRiYWNrXCIsIFwiZGlzYWJsZV9mZWVkYmFja1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBubyBpbnN0cnVjdG9yIHNjcmlwdHMgYXJlIHJ1biAoZS5nLiwgb25fcnVuIGFuZCBvbl9ldmFsKS5cIl0sXG4gICAgW1wiZGlzYWJsZUluc3RydWN0b3JSdW5cIiwgXCJkaXNhYmxlX2luc3RydWN0b3JfcnVuXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBpbnN0cnVjdG9yIG9uX3J1biB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHJ1biB0aGUgc3R1ZGVudHMnIGNvZGUuIFRoaXMgc3RpbGwgcnVucyB0aGUgc3R1ZGVudHMnIGNvZGUgb25jZSBiZWZvcmVoYW5kLCBidXQgdGhlIG91dHB1dC9kYXRhIHdpbGwgbm90IGJlIGF2YWlsYWJsZSB0byB0aGUgaW5zdHJ1Y3RvcidzIG9uX3J1bi5weSBzY3JpcHQuXCJdLFxuICAgIFtcImRpc2FibGVTdHVkZW50UnVuXCIsIFwiZGlzYWJsZV9zdHVkZW50X3J1blwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgcnVuIGJ1dHRvbiBubyBsb25nZXIgcnVuIHRoZSBzdHVkZW50cycgY29kZS4gVGhpcyBzdGlsbCBydW5zIHRoZSBpbnN0cnVjdG9yJ3MgZmVlZGJhY2sgb25fcnVuIHNjcmlwdC5cIl0sXG4gICAgW1wiZGlzYWJsZVRpZmFcIiwgXCJkaXNhYmxlX3RpZmFcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gZG8gbm90IGF1dG9tYXRpY2FsbHkgcnVuIFRpZmEgKHdoaWNoIGNhbiBiZSBzbG93KS5cIl0sXG4gICAgW1wiZGlzYWJsZVRyYWNlXCIsIFwiZGlzYWJsZV90cmFjZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMgY29kZSB3aWxsIG5vdCBoYXZlIGl0cyBleGVjdXRpb24gdHJhY2VkIChubyB2YXJpYWJsZXMgcmVjb3JkZWQsIG5vIGNvdmVyYWdlIHRyYWNrZWQpLlwiXSxcbiAgICBbXCJkaXNhYmxlRWRpdFwiLCBcImRpc2FibGVfZWRpdFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZWRpdGFibGUuXCJdLFxuICAgIFtcImVuYWJsZUltYWdlc1wiLCBcImNhbl9pbWFnZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB1c2VycyBjYW4gY29weS9wYXN0ZSBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgdGV4dCBlZGl0b3IuXCJdLFxuICAgIFtcImVuYWJsZUJsb2Nrc1wiLCBcImNhbl9ibG9ja3NcIiwgdHJ1ZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudCBjYW4gZWRpdCB0aGUgYmxvY2sgaW50ZXJmYWNlIChpZiBub3QsIHRoZW4gaXQgaXMgdmlzaWJsZSBidXQgbm90IGVkaXRhYmxlKS5cIl0sXG4gICAgW1wiY2FuQ2xvc2VcIiwgXCJjYW5fY2xvc2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnQgc2hvdWxkIG1hcmsgdGhlaXIgc3VibWlzc2lvbiBjbG9zZWQgd2hlbiB0aGV5IGFyZSBkb25lLiBUaGVyZSBpcyBubyB3YXkgdG8gZm9yY2UgYSBzdHVkZW50IHRvIGRvIHNvLiBVbmxpa2UgUmV2aWV3ZWQsIHRoaXMgc3RpbGwgc3VibWl0cyB0aGUgY29ycmVjdG5lc3MuXCJdLFxuICAgIFtcIm9ubHlJbnRlcmFjdGl2ZVwiLCBcIm9ubHlfaW50ZXJhY3RpdmVcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZSBlZGl0b3JzIGFyZSBoaWRkZW4sIHRoZSBwcm9ncmFtIGlzIGF1dG9tYXRpY2FsbHkgcnVuLCBhbmQgdGhlbiB0aGUgY29uc29sZSBlbnRlcnMgRXZhbCBtb2RlIChpbnRlcmFjdGl2ZSkuXCJdLFxuICAgIFtcIm9ubHlVcGxvYWRzXCIsIFwib25seV91cGxvYWRzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cycgZmlsZSB3aWxsIG5vdCBiZSBkaXJlY3RseSBlZGl0YWJsZSAodGhleSB3aWxsIGhhdmUgdG8gdXBsb2FkIHN1Ym1pc3Npb25zKS5cIl0sXG4gICAgLy8gV2hhdCBtZW51cy9mZWVkYmFjayB0byBzaG93IGFuZCBoaWRlXG4gICAgW1wiaGlkZVN1Ym1pc3Npb25cIiwgXCJoaWRlX3N1Ym1pc3Npb25cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlaXIgc3VibWlzc2lvbidzIGNvZGUgb3IgaGlzdG9yeSBvbiBDYW52YXMuXCJdLFxuICAgIFtcImhpZGVGaWxlc1wiLCBcImhpZGVfZmlsZXNcIiwgdHJ1ZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyB3aWxsIG5vdCBzZWUgdGhlIFZpZXcgRmlsZXMgdG9vbGJhci5cIl0sXG4gICAgW1wiaGlkZVF1ZXVlZElucHV0c1wiLCBcImhpZGVfcXVldWVkX2lucHV0c1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMgY2Fubm90IGFjY2VzcyB0aGUgcXVldWVkIGlucHV0cyBib3ggKG1ha2VzIHJlcGVhdGVkIGRlYnVnZ2luZyBlYXNpZXIgZm9yIHRoZSBpbnB1dCBmdW5jdGlvbikuXCJdLFxuICAgIFtcImhpZGVFZGl0b3JzXCIsIFwiaGlkZV9lZGl0b3JzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIGFsbCBvZiB0aGUgZWRpdG9ycyBhcmUgaGlkZGVuLlwiXSxcbiAgICBbXCJoaWRlTWlkZGxlUGFuZWxcIiwgXCJoaWRlX21pZGRsZV9wYW5lbFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgY29uc29sZSBhbmQgZmVlZGJhY2sgYXJlYXMgaXMgaGlkZGVuLlwiXSxcbiAgICBbXCJoaWRlQWxsXCIsIFwiaGlkZV9hbGxcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklOQ09NUExFVEU6IElmIGNoZWNrZWQsIHRoZW4gdGhlIGVudGlyZSBpbnRlcmZhY2UgaXMgaGlkZGVuLlwiXSxcbiAgICBbXCJoaWRlRXZhbHVhdGVcIiwgXCJoaWRlX2V2YWx1YXRlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBFdmFsdWF0ZSBidXR0b24gaXMgbm90IHNob3duIG9uIHRoZSBjb25zb2xlLlwiXSxcbiAgICBbXCJoaWRlSW1wb3J0RGF0YXNldHNCdXR0b25cIiwgXCJoaWRlX2ltcG9ydF9kYXRhc2V0c19idXR0b25cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgY2Fubm90IHNlZSB0aGUgaW1wb3J0IGRhdGFzZXRzIGJ1dHRvbi5cIl0sXG4gICAgLy8gVE9ETzogRml4IHRoaXMgb25lIHRvIGJlIHNldHRhYmxlXG4gICAgW1wiaGlkZUltcG9ydFN0YXRlbWVudHNcIiwgXCJoaWRlX2ltcG9ydF9zdGF0ZW1lbnRzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCBjZXJ0YWluIGtpbmRzIG9mIGltcG9ydCBzdGF0ZW1lbnRzIChtYXRwbG90bGliLCB0dXJ0bGUsIGRhdGFzZXRzKSBhcmUgbm90IHNob3duIGluIHRoZSBibG9jayBpbnRlcmZhY2UuXCJdLFxuICAgIFtcImhpZGVDb3ZlcmFnZUJ1dHRvblwiLCBcImhpZGVfY292ZXJhZ2VfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCB0aGUgY292ZXJhZ2UgYnV0dG9uIGlzIG5vdCBzaG93bi5cIl0sXG4gICAgW1wic2F2ZVR1cnRsZU91dHB1dFwiLCBcInNhdmVfdHVydGxlX291dHB1dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0dXJ0bGUgKGFuZCBweWdhbWUpIG91dHB1dCBpcyBzYXZlZCB3aGVuZXZlciB0aGUgcHJvZ3JhbSB1c2VzIGl0LlwiXSxcbl07XG5cbmV4cG9ydCBsZXQgQXNzaWdtZW50VHlwZSA9IHtcbiAgICBCTE9DS1BZOiBcImJsb2NrcHlcIixcbiAgICBNQVpFOiBcIm1hemVcIixcbiAgICBRVUlaOiBcInF1aXpcIixcbiAgICBSRUFESU5HOiBcInJlYWRpbmdcIlxufTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRhdGlvbihuYW1lKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgQVNTSUdOTUVOVF9TRVRUSU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQVNTSUdOTUVOVF9TRVRUSU5HU1tpXVswXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiRG9jdW1lbnRhdGlvbiBub3QgZm91bmQgZm9yIGZpZWxkXCI7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdGFydFZpZXdUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0VmlldygpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGFzc2lnbm1lbnQuc2V0dGluZ3Muc3RhcnRWaWV3LmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktc3RhcnQtdmlldy1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwgPSBBU1NJR05NRU5UX1NFVFRJTkdTXG4gICAgLy8gT25seSBoYW5kbGUgdGhlIHNpbXBsZSBib29sZWFucyB0aGlzIHdheVxuICAgIC5maWx0ZXIoKHNldHRpbmcpID0+IHNldHRpbmdbM10gPT09IFwiYm9vbFwiKVxuICAgIC5tYXAoKHNldHRpbmcpID0+IHtcbiAgICAgICAgbGV0IHByZXR0eU5hbWUgPSBzZXR0aW5nWzFdLnNwbGl0KFwiX1wiKS5tYXAod29yZD0+KHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrd29yZC5zbGljZSgxKSkpLmpvaW4oXCIgXCIpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtJHtzZXR0aW5nWzBdfVwiPiR7cHJldHR5TmFtZX08L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnNldHRpbmdzLiR7c2V0dGluZ1swXX1cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke3NldHRpbmdbNF19XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9KS5qb2luKFwiXFxuXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS12aWV3LXNldHRpbmdzXCI+XG4gICAgXG4gICAgPGZvcm0+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEyIG14LWF1dG9cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc3VjY2Vzc1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnNldHRpbmdzLnNhdmVcIj5TYXZlIGNoYW5nZXM8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+TmFtZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLW5hbWVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50Lm5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgc3R1ZGVudC1mYWNpbmcgbmFtZSBvZiB0aGUgYXNzaWdubWVudC4gQXNzaWdubWVudHMgd2l0aGluIGEgZ3JvdXAgYXJlIG9yZGVyZWQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgYnkgdGhlaXIgbmFtZSwgc28geW91IG1heSB3YW50IHRvIHVzZSBhIG5hbWluZyBzY2hlbWUgbGlrZSBcIiM0My41KSBXaGF0ZXZlclwiLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlVSTDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudXJsXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIGNvdXJzZS11bmlxdWUgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uc2lzdGVudGx5IHJlZmVyIHRvIHRoaXMgYXNzaWdubWVudC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIj5QdWJsaWM6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnB1YmxpY1wiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIG5vdCBwdWJsaWMsIHVzZXJzIG91dHNpZGUgb2YgdGhlIGNvdXJzZSB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGUgYXNzaWdubWVudCBpbiBjb3Vyc2UgbGlzdGluZ3MuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIj5IaWRkZW46PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LmhpZGRlblwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIGhpZGRlbiwgc3R1ZGVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlaXIgZ3JhZGUgd2hpbGUgd29ya2luZyBvbiB0aGUgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXJldmlld2VkXCI+UmV2aWV3ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGFzc2lnbm1lbnQucmV2aWV3ZWRcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiByZXZpZXdlZCwgdGhlIGFzc2lnbm1lbnQgbmVlZCB0byBiZSBjb21tZW50ZWQgdXBvbiBhbmQgcmVncmFkZWQgYnkgdGhlIHN0YWZmIGFmdGVyIHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UG9pbnRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wb2ludHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnBvaW50c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoaXMgYXNzaWdubWVudCBpcyB3b3J0aDsgZGVmYXVsdHMgdG8gMSBwb2ludC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlN0YXJ0aW5nIFZpZXc6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiQmxvY2tzXCIsIFwidGgtbGFyZ2VcIiwgRGlzcGxheU1vZGVzLkJMT0NLKX1cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tN1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInN0YXJ0Vmlld1wiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5JUCBSYW5nZXM6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LmlwUmFuZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIElQIEFkZHJlc3NlcyB0aGF0IHdpbGwgYmUgZXhwbGljaXRseSBhbGxvd2VkLiBJZiBibGFuayxcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgYWRkcmVzc2VzIGFyZSBhbGxvd2VkLiBJZiBhbiBhZGRyZXNzIHN0YXJ0cyB3aXRoIDxjb2RlPl48L2NvZGU+IHRoZW4gaXQgaXQgaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3RlZCwgYnV0IHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdHVybiB3aXRoIGEgPGNvZGU+ITwvY29kZT4uIEFkZHJlc3NlcyBjYW4gYWxzb1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIGEgYml0IG1hc2sgdG8gYWxsb3cgYSByYW5nZSBvZiBhZGRyZXNzZXMuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcGFzc2NvZGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5QYXNzY29kZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5wYXNzY29kZVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInBhc3Njb2RlXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJlbG9hZGVkIERhdGFzZXRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtZGF0YXNldHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwiZGF0YXNldHNcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtdG9vbGJveFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPkJsb2NrIFRvb2xib3g6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94XCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm5vcm1hbFwiPk5vcm1hbCBUb29sYm94PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN0XCI+Q1RAVlQgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdDJcIj5DVEBWVCBUb29sYm94IFYyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1pbmltYWxcIj5NaW5pbWFsIFNldDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJmdWxsXCI+QWxsIEJsb2Nrczwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdXN0b21cIj5DdXN0b208L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJ0b29sYm94XCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5Qcm9ibGVtIFR5cGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC50eXBlXCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJsb2NrcHlcIj5CbG9ja1B5PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1hemVcIj5NYXplPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInF1aXpcIj5RdWl6IFF1ZXN0aW9uPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJlYWRpbmdcIj5SZWFkaW5nPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidHlwZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgJHtBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MfVxuICAgIDwvZm9ybT5cbiAgICBcbiAgICA8L2Rpdj5cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdO1xuICAgICAgICBsZXQgdmFsdWUgPSBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKCk7XG4gICAgICAgIC8vIE9ubHkgc3RvcmUgdGhpcyBzZXR0aW5nIGlmIGl0cyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFxuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgc2V0dGluZ3Nbc2VydmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQXNzaWdubWVudFNldHRpbmdzKG1vZGVsLCBzZXR0aW5ncykge1xuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3MpO1xuICAgICAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdO1xuICAgICAgICAgICAgaWYgKHNlcnZlck5hbWUgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKHNldHRpbmdzW3NlcnZlck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN0YXJ0X3ZpZXcpIHtcbiAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShzZXR0aW5ncy5zdGFydF92aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdLFxuICAgICAgICAgICAgZmllbGRUeXBlID0gc2V0dGluZ1szXTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2NsaWVudE5hbWVdID0ga28ub2JzZXJ2YWJsZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbmZpZ1ZhbHVlID0gY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc2V0dGluZ3MuXCIrc2VydmVyTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRUeXBlID09PSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1ZhbHVlID0gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoY29uZmlnVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5cbmNsYXNzIEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vVE9ETzogdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIC8vIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcblxuICAgICAgICAvL1RPRE86IHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gdXBkYXRlXG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IudmFsdWUoKSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBVcGRhdGVcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgQXNzaWdubWVudFNldHRpbmdzID0ge1xuICAgIG5hbWU6IFwiQXNzaWdubWVudCBTZXR0aW5nc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcsXG4gICAgdGVtcGxhdGU6IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUxcbn07IiwiXHJcblxyXG5leHBvcnQgY29uc3QgZGVmYXVsdF9oZWFkZXIgPSBgXHJcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi10b29sYmFyIGNvbC1tZC0xMiBidG4tdG9vbGJhclwiXHJcbiAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiUHl0aG9uIFRvb2xiYXJcIj5cclxuICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIj5cclxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcclxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcclxuICAgICAgICAgICAgICAgIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxyXG4gICAgICAgICA8L2xhYmVsPlxyXG5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXHJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxyXG4gICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXHJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXHJcbiAgICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgXHJcbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcclxuICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiLFxyXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcclxuICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgPC9kaXY+XHJcbiA8L2Rpdj5cclxuYDtcclxuIiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSU1BR0VfRURJVE9SX0hUTUwgPSBgXHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8aDM+QXZhaWxhYmxlIEltYWdlczwvaDM+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbWFnZXMucmVsb2FkSW1hZ2VzXCI+UmVsb2FkIEF2YWlsYWJsZSBJbWFnZXM8L2J1dHRvbj5cclxuICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5LnVwbG9hZGVkRmlsZXMoKSAhPT0gbnVsbCAtLT5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6IE9iamVjdC5rZXlzKGRpc3BsYXkudXBsb2FkZWRGaWxlcygpKSwgYXM6ICdwbGFjZW1lbnQnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZyBkYXRhLWJpbmQ9XCJ0ZXh0OiAkZGF0YVwiPjwvc3Ryb25nPjpcclxuICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6ICRyb290LmRpc3BsYXkudXBsb2FkZWRGaWxlcygpW3BsYWNlbWVudF0sIGFzOiAnZmlsZW5hbWUnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGZpbGVuYW1lWzBdXCI+PC9zcGFuPjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgZGF0YS1iaW5kPVwiYXR0cjogeyBzcmM6IGZpbGVuYW1lWzFdLCBhbHQ6IGZpbGVuYW1lWzFdIH1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMzBweFwiIGhlaWdodD1cIjMwcHhcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSW1hZ2VFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcblxyXG4gICAgICAgIGxldCB1cGxvYWRlZEZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudXBsb2FkZWRGaWxlcygpO1xyXG4gICAgICAgIGlmICh1cGxvYWRlZEZpbGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkSW1hZ2VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTsqL1xyXG4gICAgfVxyXG5cclxuICAgIHJlbG9hZEltYWdlcygpIHtcclxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubGlzdFVwbG9hZGVkRmlsZXMoKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS51cGxvYWRlZEZpbGVzKHJlc3BvbnNlLmZpbGVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZ3MuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyhyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICAvKnRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSW1hZ2VFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkltYWdlXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/aW1hZ2VzLmJsb2NrcHlcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogSW1hZ2VFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IElNQUdFX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSlNPTl9FRElUT1JfSFRNTCA9IGBcclxuICAgICR7ZGVmYXVsdF9oZWFkZXJ9XHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1qc29uXCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSnNvbkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLWpzb25cIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEpzb25FZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkpTT05cIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5qc29uXCJdLFxyXG4gICAgY29uc3RydWN0b3I6IEpzb25FZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IEpTT05fRURJVE9SX0hUTUxcclxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBNQVJLRE9XTl9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLW1hcmtkb3duXCI+PC90ZXh0YXJlYT4gICAgXG5gO1xuXG5cbmNsYXNzIE1hcmtkb3duRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5tZGUgPSBuZXcgRWFzeU1ERSh7XG4gICAgICAgICAgICBlbGVtZW50OiB0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1tYXJrZG93blwiKVswXSxcbiAgICAgICAgICAgIGF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIG1pbkhlaWdodDogXCIzMDBweFwiLFxuICAgICAgICAgICAgLy9zY3JvbGxiYXJTdHlsZTogXCJuYXRpdmVcIixcbiAgICAgICAgICAgIC8vIFRPRE86IGltYWdlVXBsb2FkRnVuY3Rpb25cbiAgICAgICAgICAgIHJlbmRlcmluZ0NvbmZpZzoge1xuICAgICAgICAgICAgICAgIGNvZGVTeW50YXhIaWdobGlnaHRpbmc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5tZGUuY29kZW1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZGUudmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMubWRlLnZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiTWFya2Rvd25cIixcbiAgICBleHRlbnNpb25zOiBbXCIubWRcIl0sXG4gICAgY29uc3RydWN0b3I6IE1hcmtkb3duRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogTUFSS0RPV05fRURJVE9SX0hUTUxcbn07IiwiLyoqXG4gKiBUT0RPOiByZW5hbWUgZmlsZXMsIG1hbnVhbCBzYXZlLCB0YWdzLCBzYW1wbGVfc3VibWlzc2lvbnMsIG9uX2V2YWwsIG5vbi1idWlsdGluIGZpbGVzXG4gKiBUT0RPOiBpbXBvcnQgZGF0YSwgaGlzdG9yeSwgcnVuLCB1cmxfZGF0YSwgYXNzaWdubWVudF9zZXR0aW5ncywgcGFyc29uc19tb2RlXG4gKiBUT0RPOiBkZWxldGUgYmVjb21lcyBcImNsZWFyXCIgZm9yIGluc3RydWN0b3IgZmlsZXNcbiAqL1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyfVxuICovXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yLCBzbHVnZ2lmeX0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0hJU1RPUllfVE9PTEJBUl9IVE1MfSBmcm9tIFwiLi4vaGlzdG9yeVwiO1xuXG5leHBvcnQgbGV0IERpc3BsYXlNb2RlcyA9IHtcbiAgICBCTE9DSzogXCJibG9ja1wiLFxuICAgIFNQTElUOiBcInNwbGl0XCIsXG4gICAgVEVYVDogXCJ0ZXh0XCJcbn07XG5cbmZ1bmN0aW9uIG1ha2VUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBkaXNwbGF5LnB5dGhvbk1vZGUoKSA9PT0gJyR7bW9kZX0nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi51cGRhdGVNb2RlLmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktbW9kZS1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmV4cG9ydCBjb25zdCBQWVRIT05fRURJVE9SX0hUTUwgPSBgXG5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tdG9vbGJhciBjb2wtbWQtMTIgYnRuLXRvb2xiYXJcIlxuICAgICAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiUHl0aG9uIFRvb2xiYXJcIj5cblxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJ1biBHcm91cFwiPiAgICAgICAgIFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYmxvY2tweS1ydW4gbm90cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZXhlY3V0ZS5ydW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7J2Jsb2NrcHktcnVuLXJ1bm5pbmcnOiB1aS5leGVjdXRlLmlzUnVubmluZ31cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1wbGF5XCI+PC9zcGFuPiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5leGVjdXRlLnJ1bkxhYmVsXCI+PC9zcGFuPlxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXRvZ2dsZSBtci0yXCIgZGF0YS10b2dnbGU9XCJidXR0b25zXCI+XG4gICAgICAgICAgICA8IS0tIGtvIGlmOiAkcm9vdC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUJsb2NrcygpIC0tPlxuICAgICAgICAgICAgJHttYWtlVGFiKFwiQmxvY2tzXCIsIFwidGgtbGFyZ2VcIiwgRGlzcGxheU1vZGVzLkJMT0NLKX1cbiAgICAgICAgICAgICR7bWFrZVRhYihcIlNwbGl0XCIsIFwiY29sdW1uc1wiLCBEaXNwbGF5TW9kZXMuU1BMSVQpfVxuICAgICAgICAgICAgJHttYWtlVGFiKFwiVGV4dFwiLCBcImFsaWduLWxlZnRcIiwgRGlzcGxheU1vZGVzLlRFWFQpfVxuICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJlc2V0IEdyb3VwXCI+XG4gICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucmVzZXRcIj5cbiAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtc3luY1wiPjwvc3Bhbj4gUmVzZXRcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPCEtLSBrbyBpZjogIWFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUltcG9ydERhdGFzZXRzQnV0dG9uKCkgLS0+XG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSW1wb3J0IEdyb3VwXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmltcG9ydERhdGFzZXRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1jbG91ZC1kb3dubG9hZC1hbHRcIj48L3NwYW4+IEltcG9ydCBkYXRhc2V0c1xuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1maWxlLXVwbG9hZFwiPjwvc3Bhbj4gVXBsb2FkXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImJsb2NrcHktdG9vbGJhci11cGxvYWRcIiB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImV2ZW50OiB7Y2hhbmdlOiB1aS5lZGl0b3JzLnVwbG9hZH1cIj5cbiAgICAgICAgICAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBkcm9wZG93bi10b2dnbGUgZHJvcGRvd24tdG9nZ2xlLXNwbGl0XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiPlRvZ2dsZSBEcm9wZG93bjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPSdkcm9wZG93bi1pdGVtIGJsb2NrcHktdG9vbGJhci1kb3dubG9hZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmRvd25sb2FkXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZG93bmxvYWQnPjwvc3Bhbj4gRG93bmxvYWRcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJIaXN0b3J5IEdyb3VwXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24udG9nZ2xlSGlzdG9yeU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHVpLmVkaXRvcnMucHl0aG9uLmlzSGlzdG9yeUF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeyBhY3RpdmU6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHsgJ2FyaWEtcHJlc3NlZCc6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWhpc3RvcnlcIj48L3NwYW4+IEhpc3RvcnlcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIEZ1bGx5IGZ1bmN0aW9uYWwsIGJ1dCBhIGxpdHRsZSB0b28uLiBJbnZhc2l2ZSBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJGdWxsc2NyZWVuIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IGRpc3BsYXkucHl0aG9uTW9kZSgpID09PSAndGV4dCdcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmZ1bGxzY3JlZW5cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1leHBhbmQtYXJyb3dzLWFsdFwiPjwvc3Bhbj4gRnVsbHNjcmVlblxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlNhdmUgR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5TYXZlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkRlbGV0ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmRlbGV0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJlbmFtZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblJlbmFtZVwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtc2lnbmF0dXJlXCI+PC9zcGFuPiBSZW5hbWVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2Pi0tPlxuICAgICAgICAgXG4gICAgPC9kaXY+XG4gICAgXG4gICAgJHtISVNUT1JZX1RPT0xCQVJfSFRNTH1cblxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLWJsb2NrbWlycm9yXCJcbiAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5tZW51LmlzU3VibWl0dGVkXCI+XG4gICAgPC9kaXY+XG5gO1xuXG5cblxuZnVuY3Rpb24gY29udmVydElweW5iVG9QeXRob24oY29kZSkge1xuICAgIGxldCBpcHluYiA9IEpTT04ucGFyc2UoY29kZSk7XG4gICAgbGV0IGlzVXNhYmxlID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2UubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICFjZWxsLnNvdXJjZVswXS5zdGFydHNXaXRoKFwiJVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICAgICAgY2VsbC5jZWxsX3R5cGUgPT09IFwicmF3XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBtYWtlUHl0aG9uID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiJycnXCIrY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKStcIicnJ1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaXB5bmIuY2VsbHMuZmlsdGVyKGlzVXNhYmxlKS5tYXAobWFrZVB5dGhvbikuam9pbihcIlxcblwiKTtcbn1cblxuY2xhc3MgUHl0aG9uRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnLmZpbmQoXCIuYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIikpO1xuICAgICAgICBCbG9ja2x5LnNldFBhcmVudENvbnRhaW5lcihtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyWzBdKTtcbiAgICAgICAgdGhpcy5ibSA9IG5ldyBCbG9ja01pcnJvcih7XG4gICAgICAgICAgICBcImNvbnRhaW5lclwiOiB0aGlzLnRhZ1swXSxcbiAgICAgICAgICAgIFwicnVuXCI6IG1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuLmJpbmQobWFpbi5jb21wb25lbnRzLmVuZ2luZSksXG4gICAgICAgICAgICBcInNraXBTa3VscHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiYmxvY2tseU1lZGlhUGF0aFwiOiBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYmxvY2tseVBhdGgsXG4gICAgICAgICAgICBcInRvb2xib3hcIjogbWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3goKSxcbiAgICAgICAgICAgIFwiaW1hZ2VNb2RlXCI6IHRydWUsXG4gICAgICAgICAgICBpbWFnZURvd25sb2FkSG9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRVcmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VVcGxvYWRIb29rOiAoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc3QgdXVpZCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtdKSkuc3Vic3RyaW5nKDMxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJtaXNzaW9uSWQgPSBtYWluLm1vZGVsLnN1Ym1pc3Npb24uaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbi5jb21wb25lbnRzLnNlcnZlci51cGxvYWRGaWxlKFwic3VibWlzc2lvblwiLCBzdWJtaXNzaW9uSWQsIGJsb2IubmFtZSwgYmxvYiwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmVuZHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc29sdmUoSlNPTi5zdHJpbmdpZnkobWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHNbXCJkb3dubG9hZEZpbGVcIl0gKyBgP3BsYWNlbWVudD1zdWJtaXNzaW9uJmRpcmVjdG9yeT0ke3N1Ym1pc3Npb25JZH0mZmlsZW5hbWU9JHtibG9iLm5hbWV9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwiSW1hZ2UoXCIrSlNPTi5zdHJpbmdpZnkoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSkrXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5zdHJpbmdpZnkoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltYWdlTGl0ZXJhbEhvb2s6IChvbGRVcmwpID0+IHtcbiAgICAgICAgICAgICAgICAvL3JldHVybiBgSW1hZ2UoXCIke29sZFVybH1cIilgO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXCIke29sZFVybH1cImA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8naGVpZ2h0JzogJzIwMDBweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG5cbiAgICAgICAgdGhpcy5tYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG5cbiAgICBjb25maWd1cmVFeHRyYUJsb2NrbHkoKSB7XG4gICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLmNvbmZpZ3VyZUNvbnRleHRNZW51ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlNjcmVlbnNob3RcIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlNDUkVFTlNIT1RfQkxPQ0tTXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIGxldCBvbGRGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBpZiAob2xkRmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKERpc3BsYXlNb2Rlcy5URVhUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUodGhpcy5vbGRQeXRob25Nb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50Qk1MaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm0uYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50Qk1MaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLmJtLmlzUGFyc29ucyA9ICgpID0+IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibS5pc1BhcnNvbnMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5pc1BhcnNvbnM7XG5cbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5saW5lc0Vycm9yLnN1YnNjcmliZSgobGluZXMpID0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLWVycm9yLWxpbmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGluZXNVbmNvdmVyZWQuc3Vic2NyaWJlKChsaW5lcykgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLXVuY292ZXJlZC1saW5lXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL3RoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLnJlbmRlcigpO1xuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGlzIGRvZXNuJ3QgZW5kIHVwIGxvb2tpbmcgcmlnaHQgKGdvIHRvIGEgZGlmZmVyZW50IGVkaXRvciwgY29tZSBiYWNrLCBhbmQgaXQnbGwgYmUgc3F1aXNoZWQpXG4gICAgICAgIC8vdGhpcy5ibS5yZWZyZXNoKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ibS5yZWZyZXNoKCksIDApO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICBpZiAobmV3Q29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gdGhpcy5maWxlLmhhbmRsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciwgZmlsZSB3YXMgYWxyZWFkeSBzaHV0IGRvd24uXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudHMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBjbG9zaW5nIHRoaXMgZmlsZVxuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8odGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJtLnNldENvZGUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5ibS5nZXRDb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJtLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJMaW5lU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIGNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uc2V0TW9kZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlLnN1YnNjcmliZShtb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZShtb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUJsb2Nrcy5zdWJzY3JpYmUoZW5hYmxlZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3guc3Vic2NyaWJlKHRoaXMucmVsb2FkVG9vbGJveC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlSW1hZ2VzLnN1YnNjcmliZShpbWFnZU1vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRJbWFnZU1vZGUoaW1hZ2VNb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVsb2FkVG9vbGJveCh0b29sYm94KSB7XG4gICAgICAgIGlmICh0b29sYm94ID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tVG9vbGJveCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj90b29sYm94LmJsb2NrcHlcIik7XG4gICAgICAgICAgICBpZiAoY3VzdG9tVG9vbGJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJveCA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IEpTT04ucGFyc2UoY3VzdG9tVG9vbGJveC5oYW5kbGUoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBUT0RPOiBJbXByb3ZlIGVycm9yIG1lc3NhZ2UgZm9yIGluc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IFwibWluaW1hbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24udG9vbGJveCA9IHRvb2xib3g7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBpbnZhbGlkIHRvb2xib3ggYmV0dGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi50b29sYm94ID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWRPbmx5KHRoaXMuZGVjaWRlSWZOb3RFZGl0YWJsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkT25seSh0aGlzLmRlY2lkZUlmTm90RWRpdGFibGUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlY2lkZUlmTm90RWRpdGFibGUoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSB8fCAoXG4gICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzKCkgJiYgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0UmVhZE9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5ibS5zZXRSZWFkT25seShpc1JlYWRPbmx5KTtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvZGUgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIuaXB5bmJcIikpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuVXBsb2FkXCIsIFwiXCIsIFwiXCIsIGNvZGUsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvZGUpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuKCk7XG4gICAgICAgIC8vIFRPRE86IFJ1biBjb2RlXG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZG93bmxvYWRGaWxlKCk7XG4gICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiByZXN1bHQuZXh0ZW5zaW9uID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IHNsdWdnaWZ5KHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1pbWV0eXBlID0gXCJ0ZXh0L3gtcHl0aG9uXCI7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5Eb3dubG9hZFwiLCBcIlwiLCBcIlwiLCBcIlwiLCByZXN1bHQubmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQeXRob25FZGl0b3IgPSB7XG4gICAgbmFtZTogXCJQeXRob25cIixcbiAgICBleHRlbnNpb25zOiBbXCIucHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFB5dGhvbkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFBZVEhPTl9FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBRVUlaX0VESVRPUl9IVE1MID0gYFxyXG4gICAgPGRpdj5cclxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXF1aXpcIj48L3RleHRhcmVhPlxyXG4gICAgPC9kaXY+XHJcbmA7XHJcblxyXG5jbGFzcyBRdWl6RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xyXG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcclxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcclxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFF1aXpFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIlF1aXpcIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5xdWl6XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFF1aXpFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFFVSVpfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIFBhbmVsIGZvciBlZGl0aW5nIHRoZSBzZXQgb2YgU2FtcGxlIFN1Ym1pc3Npb25zLlxuICogVGhlc2UgYXJlIG5vdCBwcm92aWRlZCBhdCBhbGwgdG8gc3R1ZGVudHMgd2l0aG91dCB0aGUgR3JhZGVyIHJvbGUuXG4gKi9cblxuaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBTdWJtaXNzaW9uU3RhdHVzZXMgPSB7XG4gICAgVU5LTk9XTjogXCJ1bmtub3duXCIsXG4gICAgUEFTU0VEOiBcInBhc3NlZFwiLFxuICAgIEZBSUxFRDogXCJmYWlsZWRcIixcbiAgICBFUlJPUjogXCJlcnJvclwiLFxuICAgIFNLSVBQRUQ6IFwic2tpcHBlZFwiXG59O1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlU3VibWlzc2lvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBCbGFuayhjb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oXCJVbnRpdGxlZFwiKyhjb3VudCB8fCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pc3Npb25TdGF0dXNlcy5VTktOT1dOLCBcImE9MFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oZGF0YS5uYW1lLCBkYXRhLnN0YXR1cywgZGF0YS5jb2RlKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU0FNUExFX1NVQk1JU1NJT05TX0hUTUwgPSBgXG48ZGl2PlxuICAgIDxkaXYgZGF0YS1iaW5kPVwiZm9yZWFjaDoge2RhdGE6IGFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnN9XCJcbiAgICAgICAgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3Itc2FtcGxlLXN1Ym1pc3Npb25zLWNvZGVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNvZGVNaXJyb3JJbnN0YW5jZTogY29kZVwiPjwvdGV4dGFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN0YXR1c1wiPjwvc3Bhbj4gICAgICAgIFxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxua28uYmluZGluZ0hhbmRsZXJzLmNvZGVNaXJyb3JJbnN0YW5jZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50XG4gICAgICAgIC8vIFNldCB1cCBhbnkgaW5pdGlhbCBzdGF0ZSwgZXZlbnQgaGFuZGxlcnMsIGV0Yy4gaGVyZVxuICAgICAgICBjb25zb2xlLmxvZyhcIklOSVRcIik7XG4gICAgICAgIGxldCBjbSA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNtLnNldFNpemUoXCIxMDAlXCIsIFwiMTAwcHhcIik7XG4gICAgICAgIHJldHVybiBjbTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50LFxuICAgICAgICAvLyBhbmQgYWdhaW4gd2hlbmV2ZXIgYW55IG9ic2VydmFibGVzL2NvbXB1dGVkcyB0aGF0IGFyZSBhY2Nlc3NlZCBjaGFuZ2VcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBET00gZWxlbWVudCBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgdmFsdWVzIGhlcmUuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVVBEQVRFXCIpO1xuICAgIH1cbn07XG5cbmNsYXNzIFNhbXBsZVN1Ym1pc3Npb25zVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpIHtcblxuICAgIH1cblxuICAgIHJlYnVpbGRFZGl0b3JzKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlYnVpbGRpbmcgZWRpdG9yc1wiKTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vdGhpcy5yZWJ1aWxkRWRpdG9ycygpO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLGNtKSA9PiBjb25zb2xlLmxvZyhcIisrK1wiLCBjbS5Db2RlTWlycm9yKSkpO1xuICAgICAgICAgICAgdGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSwgY20pID0+IGNtLkNvZGVNaXJyb3IucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVGUkVTSFwiKTtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLCBjbSkgPT4gY20uQ29kZU1pcnJvci5yZWZyZXNoKCkpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvZGVNaXJyb3JzKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnNldFZhbHVlKG5ld0NvbnRlbnRzLmpvaW4oXCJcXG5cIikpKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnJlZnJlc2goKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvcnMubWFwKGNtID0+IGNtLmdldFZhbHVlKCkpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTYW1wbGVTdWJtaXNzaW9ucyA9IHtcbiAgICBuYW1lOiBcIlNhbXBsZSBTdWJtaXNzaW9uc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogU2FtcGxlU3VibWlzc2lvbnNWaWV3LFxuICAgIHRlbXBsYXRlOiBTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTFxufTtcbiIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgVEFHU19FRElUT1JfSFRNTCA9IGBcbkNyZWF0ZSBuZXdcbkltcG9ydCBieSBuYW1lXG5GaW5kIGJ5IG93bmVyL2NvdXJzZS9raW5kXG5cblRhZ3M6XG4gICAgRGF0YTpcbiAgICAgICAgTmFtZVxuICAgICAgICBLaW5kXG4gICAgICAgIExldmVsXG4gICAgICAgIFZlcnNpb25cbiAgICAgICAgRGVzY3JpcHRpb25cbiAgICBDb250cm9sczpcbiAgICAgICAgRWRpdFxuICAgICAgICBSZW1vdmVcbiAgICAgICAgRGVsZXRlIFxuYDtcblxuY2xhc3MgVGFnc0VkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRhZ3NcIikpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRhZ3NFZGl0b3IgPSB7XG4gICAgbmFtZTogXCJUYWdzXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIXRhZ3MuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogVGFnc0VkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFRBR1NfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgVEVYVF9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDxkaXY+XG4gICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdGV4dFwiPjwvdGV4dGFyZWE+XG4gICAgPC9kaXY+XG5gO1xuXG5jbGFzcyBUZXh0RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0RWRpdG9yID0ge1xuICAgIG5hbWU6IFwiVGV4dFwiLFxuICAgIGV4dGVuc2lvbnM6IFtcIi50eHRcIl0sXG4gICAgY29uc3RydWN0b3I6IFRleHRFZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBURVhUX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPT0xCT1hfRURJVE9SX0hUTUwgPSBgXHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIlxyXG4gICAgICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJUb29sYm94IFRvb2xiYXJcIj5cclxuICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJTYXZlIEdyb3VwXCI+ICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLWVkaXRvci1qc29uLXNhdmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXHJcbiAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdG9vbGJveFwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIFRvb2xib3hFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10b29sYm94XCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLWpzb24tc2F2ZVwiKS5vbihcImNsaWNrXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94KCkgPT09IFwiY3VzdG9tXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5yZWxvYWRUb29sYm94KFwiY3VzdG9tXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLXRvb2xib3gtc2F2ZVwiKS5vZmYoXCJjbGlja1wiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUb29sYm94RWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJUb29sYm94XCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/dG9vbGJveC5ibG9ja3B5XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFRvb2xib3hFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFRPT0xCT1hfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIEVkaXRvcnMgYXJlIGluZmVycmVkIGZyb20gRmlsZW5hbWVzLlxuICpcbiAqIFRoZSBlZGl0b3IgaXMgYmFzZWQgb24gdGhlIGV4dGVuc2lvbjpcbiAqICAuYmxvY2tweTogU3BlY2lhbCBlZGl0b3IgKHdpbGwgYmUgY2hvc2VuIGJ5IGZpbGVuYW1lKVxuICogIC5weTogUHl0aG9uIEVkaXRvclxuICogIC5tZDogTWFya2Rvd24gRWRpdG9yXG4gKiAgLnR4dDogVGV4dCBFZGl0b3IgKGFsc28gdXNlZCBmb3Igb3RoZXIgdHlwZXMpXG4gKiAgLnBlbWw6IFBFTUwgRWRpdG9yXG4gKiAgLnBuZywgLmdpZiwgLmpwZWcsIC5qcGcsIC5ibXA6IEltYWdlIEVkaXRvclxuICogIC5qc29uOiBKU09OIEVkaXRvclxuICogIC55YW1sOiBZQU1MIEVkaXRvclxuICovXG5cbmltcG9ydCB7UHl0aG9uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcHl0aG9uXCI7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90ZXh0XCI7XG5pbXBvcnQge0Fzc2lnbWVudFR5cGUgYXMgQXNzaWdubWVudFR5cGUsIEFzc2lnbm1lbnRTZXR0aW5nc30gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcbmltcG9ydCB7VGFnc0VkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3RhZ3NcIjtcbmltcG9ydCB7TWFya2Rvd25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9tYXJrZG93blwiO1xuaW1wb3J0IHtTYW1wbGVTdWJtaXNzaW9uc30gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuaW1wb3J0IHtKc29uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvanNvblwiO1xuaW1wb3J0IHtUb29sYm94RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdG9vbGJveFwiO1xuaW1wb3J0IHtRdWl6RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcXVpelwiO1xuaW1wb3J0IHtJbWFnZUVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL2ltYWdlc1wiO1xuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgcG9zc2libGUgZWRpdG9ycyBhdmFpbGFibGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgRWRpdG9yc0VudW0gPSB7XG4gICAgU1VCTUlTU0lPTjogXCJzdWJtaXNzaW9uXCIsXG4gICAgQVNTSUdOTUVOVDogXCJhc3NpZ25tZW50XCIsXG4gICAgSU5TVFJVQ1RJT05TOiBcImluc3RydWN0aW9uc1wiLFxuICAgIE9OX1JVTjogXCJvbl9ydW5cIixcbiAgICBPTl9DSEFOR0U6IFwib25fY2hhbmdlXCIsXG4gICAgT05fRVZBTDogXCJvbl9ldmFsXCIsXG4gICAgU1RBUlRJTkdfQ09ERTogXCJzdGFydGluZ19jb2RlXCIsXG4gICAgU0FNUExFX1NVQk1JU1NJT05TOiBcInNhbXBsZV9zdWJtaXNzaW9uc1wiLFxuICAgIElOU1RSVUNUT1JfRklMRTogXCJpbnN0cnVjdG9yX2ZpbGVcIlxufTtcblxuY29uc3QgU1BFQ0lBTF9OQU1FU1BBQ0VTID0gW1wiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJFwiXTtcblxuY29uc3QgQVZBSUxBQkxFX0VESVRPUlMgPSBbXG4gICAgVGV4dEVkaXRvciwgUHl0aG9uRWRpdG9yLCBBc3NpZ25tZW50U2V0dGluZ3MsIFRhZ3NFZGl0b3IsIE1hcmtkb3duRWRpdG9yLFxuICAgIFNhbXBsZVN1Ym1pc3Npb25zLCBKc29uRWRpdG9yLCBUb29sYm94RWRpdG9yLCBRdWl6RWRpdG9yLCBJbWFnZUVkaXRvclxuXTtcblxuZXhwb3J0IGNvbnN0IEVESVRPUlNfSFRNTCA9IEFWQUlMQUJMRV9FRElUT1JTLm1hcChlZGl0b3IgPT4gYFxuPGRpdiBjbGFzcz1cImNvbC1tZC0xMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktZWRpdG9yXCIgXG4gICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfSdcIj5cbiAgICA8ZGl2PlxuICAgICR7ZWRpdG9yLnRlbXBsYXRlfVxuICAgIDwvZGl2PlxuPC9kaXY+XG5gXG4gICAgLypcbiAgICBgXG48IS0tIGtvIGlmOiB1aS5lZGl0b3JzLnZpZXcoKS5uYW1lID09PSAnJHtlZGl0b3IubmFtZX0nIC0tPlxuJHtlZGl0b3IudGVtcGxhdGV9XG48IS0tIC9rbyAtLT5gKi9cbikuam9pbihcIlxcblwiKTtcblxuZXhwb3J0IGNsYXNzIEVkaXRvcnMge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkXyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnNfID0ge307XG4gICAgICAgIHRoaXMuYnlOYW1lXyA9IHt9O1xuICAgICAgICBBVkFJTEFCTEVfRURJVE9SUy5mb3JFYWNoKGVkaXRvciA9PiB0aGlzLnJlZ2lzdGVyRWRpdG9yKGVkaXRvcikpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZS5zdWJzY3JpYmUodGhpcy5jaGFuZ2VFZGl0b3IsIHRoaXMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRWRpdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBkYXRhLmV4dGVuc2lvbnM7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKHRoaXMubWFpbiwgdGhpcy50YWcpO1xuICAgICAgICBpbnN0YW5jZS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmJ5TmFtZV9bZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCldID0gaW5zdGFuY2U7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uc19bZXh0ZW5zaW9uc1tpXV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5TmFtZV9bbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICBjaGFuZ2VFZGl0b3IobmV3RmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IG9sZEVkaXRvciA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IG5ld0VkaXRvciA9IHRoaXMuZ2V0RWRpdG9yKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRFZGl0b3IuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ld0VkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZUZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gcGF0aC5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChTUEVDSUFMX05BTUVTUEFDRVMuaW5kZXhPZihzcGFjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGFjZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIGxldCB0eXBlID0gcGF0aC5zdWJzdHIocGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICByZXR1cm4ge1wic3BhY2VcIjogc3BhY2UsIFwibmFtZVwiOiBuYW1lLCBcInR5cGVcIjogdHlwZX07XG4gICAgfVxuXG4gICAgZ2V0RWRpdG9yKHBhdGgpIHtcbiAgICAgICAgbGV0IHtzcGFjZSwgbmFtZSwgdHlwZX0gPSBFZGl0b3JzLnBhcnNlRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICh0eXBlID09PSBcIi5ibG9ja3B5XCIgJiYgcGF0aCBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1twYXRoXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNzaWdubWVudFR5cGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50eXBlKCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50VHlwZSAhPT0gQXNzaWdubWVudFR5cGUuQkxPQ0tQWSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiYW5zd2VyXCIgJiYgdHlwZSA9PT0gXCIucHlcIikge1xuICAgICAgICAgICAgICAgIGlmIChcIi5cIithc3NpZ25tZW50VHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW1wiLlwiK2Fzc2lnbm1lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gZWRpdG9yIHJlZ2lzdGVyZWQgZm9yIGFzc2lnbm1lbnQgdHlwZTpcIiwgYXNzaWdubWVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkX1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5leHRlbnNpb25zXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bdHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkX1swXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnR5cGUoKSwgc3BhY2UsIG5hbWUsIHR5cGUpO1xuICAgIH1cblxufSIsImltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuL3NlcnZlclwiO1xuaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9ydW5cIjtcbmltcG9ydCB7UnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL3J1blwiO1xuaW1wb3J0IHtFdmFsQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL2V2YWxcIjtcbmltcG9ydCB7U2FtcGxlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL3NhbXBsZVwiO1xuaW1wb3J0IHtPbkNoYW5nZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9jaGFuZ2VcIjtcbmltcG9ydCB7T25FdmFsQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX2V2YWxcIjtcbmltcG9ydCB7T25TYW1wbGVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fc2FtcGxlXCI7XG5cbi8qKlxuICogQW4gb2JqZWN0IGZvciBleGVjdXRpbmcgUHl0aG9uIGNvZGUgYW5kIHBhc3NpbmcgdGhlIHJlc3VsdHMgYWxvbmcgdG8gaW50ZXJlc3RlZCBjb21wb25lbnRzLlxuICpcbiAqIEludGVyZXN0aW5nIGNvbXBvbmVudHM6XG4gKiAgRXhlY3V0aW9uIEJ1ZmZlcjogUmVzcG9uc2libGUgZm9yIGNvbGxlY3RpbmcgdGhlIHRyYWNlIGR1cmluZyBwcm9ncmFtIGV4ZWN1dGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICBUaGlzIHByZXZlbnRzIEtub2Nrb3V0anMgZnJvbSB1cGRhdGluZyB0aGUgZWRpdG9yIGR1cmluZyBleGVjdXRpb24uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUVkaXRvcn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uTW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uO1xuXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbnMgPSB7XG4gICAgICAgICAgICBydW46IG5ldyBSdW5Db25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgZXZhbDogbmV3IEV2YWxDb25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25SdW46IG5ldyBPblJ1bkNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvbkNoYW5nZTogbmV3IE9uQ2hhbmdlQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uRXZhbDogbmV3IE9uRXZhbENvbmZpZ3VyYXRpb24obWFpbilcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmVjb25maWd1cmUgc2t1bHB0IHNvIHdlIGNhbiBwYXJzZVxuICAgICAgICBTay5jb25maWd1cmUodGhpcy5jb25maWd1cmF0aW9ucy5ydW4uZ2V0U2t1bHB0T3B0aW9ucygpKTtcblxuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdHJhY2luZyB3aGlsZSB0aGUgcHJvZ3JhbSBpcyBleGVjdXRpbmdcbiAgICAgICAgdGhpcy5leGVjdXRpb25CdWZmZXIgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5hYmxlIGZ1bmN0aW9uIHRvIGJlIHJ1biB3aGVuIGV4ZWN1dGlvbiBoYXMgZnVsbHkgZW5kZWQsXG4gICAgICAgICAqIHdoZXRoZXIgaXQgc3VjY2VlZHMgb3IgZmFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRXhlY3V0aW9uQmVnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLm9uRXhlY3V0aW9uRW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCByZXBvcnRzXG4gICAgICovXG4gICAgcmVzZXRSZXBvcnRzKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5leGVjdXRpb25Nb2RlbC5yZXBvcnRzO1xuICAgICAgICByZXBvcnRbXCJ2ZXJpZmllclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcIm1vZGVsXCJdID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIH07XG5cbiAgICByZXNldFN0dWRlbnRNb2RlbCgpIHtcbiAgICAgICAgbGV0IHN0dWRlbnQgPSB0aGlzLmV4ZWN1dGlvbk1vZGVsLnN0dWRlbnQ7XG4gICAgICAgIHN0dWRlbnQuY2FsbHMgPSB7fTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50U3RlcChudWxsKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKDApO1xuICAgICAgICBzdHVkZW50Lmxhc3RTdGVwKDApO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRMaW5lKG51bGwpO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRUcmFjZURhdGEucmVtb3ZlQWxsKCk7XG4gICAgICAgIHN0dWRlbnQucmVzdWx0cyA9IG51bGw7XG4gICAgICAgIHN0dWRlbnQudHJhY2luZyA9IFtdO1xuICAgIH1cblxuICAgIHJlc2V0RXhlY3V0aW9uQnVmZmVyKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHtcbiAgICAgICAgICAgIFwidHJhY2VcIjogW10sXG4gICAgICAgICAgICBcInN0ZXBcIjogMCxcbiAgICAgICAgICAgIFwibGluZVwiOiAwLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGludGVyZmFjZSBhc3BlY3RzIG9mIHRoZSBwcmV2aW91cyBSdW4uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIC8vIFRPRE86IENsZWFyIG91dCBhbnkgY292ZXJhZ2UvdHJhY2UvZXJyb3IgaGlnaGxpZ2h0cyBpbiBlZGl0b3JzXG4gICAgICAgIC8vIFJlc2V0IGV4ZWN1dGlvbiBpbiBtb2RlbFxuICAgICAgICB0aGlzLnJlc2V0U3R1ZGVudE1vZGVsKCk7XG4gICAgICAgIC8vIEdldCByZXBvcnRzIHJlYWR5XG4gICAgICAgIHRoaXMucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgZXhlY3V0aW9uIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlc2V0RXhlY3V0aW9uQnVmZmVyKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgY29uc29sZSBvZiBwcmludGVkIHN0dWZmXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBvbGQgZmVlZGJhY2tcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2suY2xlYXIoKTtcbiAgICB9XG5cbiAgICBkZWxheWVkUnVuKCkge1xuICAgICAgICAvL3RoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8kKFwiLmJsb2NrcHktcnVuXCIpLmFkZENsYXNzKFwiYmxvY2tweS1ydW4tcnVubmluZ1wiKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgLy9zZXRUaW1lb3V0KHRoaXMucnVuLmJpbmQodGhpcyksIDEpO1xuICAgIH1cblxuICAgIHN0b3AoKSB7XG5cbiAgICB9XG5cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMucnVuLnVzZSh0aGlzKTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlRmVlZGJhY2soKSkge1xuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlU2VjcmV0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vblJ1bigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uc2hvd0Vycm9ycy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgfVxuXG4gICAgb25SdW4oKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMub25SdW4udXNlKHRoaXMpO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZXhlY3V0aW9uRW5kXy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICBsZXQgZXZhbHVhdGlvbklucHV0ID0gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5ldmFsdWF0ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhldmFsdWF0aW9uSW5wdXQpO1xuICAgICAgICBldmFsdWF0aW9uSW5wdXQudGhlbigodXNlcklucHV0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmV2YWwudXNlKHRoaXMsIHVzZXJJbnB1dCk7XG4gICAgICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlRmVlZGJhY2soKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVTZWNyZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMub25FdmFsLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uc2hvd0Vycm9ycy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuZXZhbHVhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkV2YWwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMub25FdmFsLnVzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbih0aGlzLmV2YWx1YXRlLmJpbmQodGhpcykpXG4gICAgICAgICAgICAudGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgIH1cblxuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uQ2hhbmdlLnVzZSh0aGlzKTtcbiAgICB9XG5cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIHJldHVybiBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZSgoKSA9PlxuICAgICAgICAgICAgU2suaW1wb3J0TWFpbldpdGhCb2R5KHRoaXMuY29uZmlndXJhdGlvbi5maWxlbmFtZSwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmNvZGUsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN5c21vZHVsZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVkIHdoZW5ldmVyIHRoZSBQeXRob24gY29kZSBjaGFuZ2VzXG4gICAgICovXG4gICAgb25fY2hhbmdlKCkge1xuICAgICAgICBsZXQgRklMRU5BTUUgPSBcIm9uX2NoYW5nZVwiO1xuICAgICAgICAvLyBTa2lwIGlmIHRoZSBpbnN0cnVjdG9yIGhhcyBub3QgZGVmaW5lZCBhbnl0aGluZ1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5wcm9ncmFtc1tGSUxFTkFNRV0oKS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0YXR1cyhcImNoYW5naW5nXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUNvZGUoKTtcbiAgICAgICAgLy8gT24gc3RlcCBkb2VzIG5vdCBwZXJmb3JtIHBhcnNlIGFuYWx5c2lzIGJ5IGRlZmF1bHQgb3IgcnVuIHN0dWRlbnQgY29kZVxuICAgICAgICBsZXQgZW5naW5lID0gdGhpcztcbiAgICAgICAgbGV0IGZlZWRiYWNrID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2s7XG4gICAgICAgIGVuZ2luZS5yZXNldFJlcG9ydHMoKTtcbiAgICAgICAgZW5naW5lLnZlcmlmeUNvZGUoKTtcbiAgICAgICAgZW5naW5lLnVwZGF0ZVBhcnNlKCk7XG4gICAgICAgIGVuZ2luZS5ydW5JbnN0cnVjdG9yQ29kZShGSUxFTkFNRSwgdHJ1ZSwgZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSkge1xuICAgICAgICAgICAgICAgIC8vIFNVQ0NFU1MsIFNDT1JFLCBDQVRFR09SWSwgTEFCRUwsIE1FU1NBR0UsIERBVEEsIEhJREVcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBvbmx5IHNob3cgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzXG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICEoY2F0ZWdvcnkgPT09IFwiSW5zdHJ1Y3RvclwiICYmIGxhYmVsID09PSBcIk5vIGVycm9yc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBmZWVkYmFjay5wcmVzZW50RmVlZGJhY2soY2F0ZWdvcnksIGxhYmVsLCBtZXNzYWdlLCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5naW5lLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2sobW9kdWxlLiRkKTtcbiAgICAgICAgICAgICAgICBlbmdpbmUubWFpbi5tb2RlbC5leGVjdXRpb24uc3RhdHVzKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbmdpbmUubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcImVuZ2luZVwiLCBcIm9uX2NoYW5nZVwiKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGF0dGVtcHQgdG8gY2FsbCB0aGUgZGVmaW5lZCBvbkV4ZWN1dGlvbkVuZCxcbiAgICAgKiBidXQgd2lsbCBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vIGZ1bmN0aW9uIGRlZmluZWQuXG4gICAgICovXG4gICAgZXhlY3V0aW9uRW5kXygpIHtcbiAgICAgICAgaWYgKHRoaXMub25FeGVjdXRpb25FbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25FeGVjdXRpb25FbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZXhlY3V0aW9uQmVnaW5fKCkge1xuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGlvbkJlZ2luICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0aW9uQmVnaW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4iLCJleHBvcnQgY29uc3QgRU1QVFlfTU9EVUxFID0gXCJsZXQgJGJ1aWx0aW5tb2R1bGUgPSBmdW5jdGlvbihtb2QpeyByZXR1cm4gbW9kOyB9XCI7XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGhvbGRpbmcgc2V0dGluZ3Mgb2YgYSBwYXJ0aWN1bGFyIHJ1biBjb25maWd1cmF0aW9uLlxuICogVGhpcyBpcyB0aGUgcm9vdCBjbGFzcyBmb3IgYWxsIG90aGVyIGNvbmZpZ3VyYXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5c21vZHVsZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICAvLyBBY2Nlc3MgcG9pbnQgZm9yIGluc3RydWN0b3IgZGF0YVxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0cyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgU2suY29uc29sZSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGU7XG4gICAgICAgIFNrLnF1ZXVlZElucHV0ID0gW107XG4gICAgICAgIFNrLmNvbmZpZ3VyZSh0aGlzLmdldFNrdWxwdE9wdGlvbnMoKSk7XG4gICAgICAgIC8vIFNldCBvcGVuRmlsZSBhcyBtZWNoYW5pc20gdG8gcmVhZCBmaWxlc1xuICAgICAgICBTay5pbkJyb3dzZXIgPSB0aGlzLm9wZW5GaWxlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IHJlcXVlc3RzXG4gICAgICAgIFNrLnJlcXVlc3RzR2V0ID0gKHVybCwgZGF0YSwgdGltZW91dCkgPT4gdGhpcy5vcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCk7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFwiZG8geW91IHdhbnQgdG8gd2FpdD8gcHJvbXB0XCJcbiAgICAgICAgU2sudGltZW91dEhhbmRsZXIgPSAodGltZVBhc3NlZCwgZXhlY0xpbWl0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb21wdE1lc3NhZ2UgPSB0aGlzLmdldFRpbWVvdXRQcm9tcHQodGltZVBhc3NlZC8xMDAwID4gMzApO1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gcHJvbXB0KHByb21wdE1lc3NhZ2UsIFNrLmV4ZWNMaW1pdC8xMDAwKTtcbiAgICAgICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCB8fCBkZWxheT09MCkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gU2suZXhlY0xpbWl0ICsgcGFyc2VJbnQoZGVsYXksIDEwKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiBkZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWxheTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0YWNoIGJlZm9yZUNhbGxcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IHRoaXMuYmVmb3JlQ2FsbC5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRUaW1lb3V0UHJvbXB0KGxvbmdUaW1lb3V0KSB7XG4gICAgICAgIGlmIChsb25nVGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIHByb2dyYW0gaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBydW4gKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBpcyB0YWtpbmcgYSB3aGlsZSB0byBydW4uIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2t1bHB0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fZnV0dXJlX186IFNrLnB5dGhvbjMsXG4gICAgICAgICAgICAvLyBpbXBvcnRcbiAgICAgICAgICAgIHJlYWQ6IHRoaXMuaW1wb3J0RmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gb3BlblxuICAgICAgICAgICAgLy9maWxlb3BlbjogdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gZmlsZS53cml0ZVxuICAgICAgICAgICAgZmlsZXdyaXRlOiB0aGlzLndyaXRlRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gcHJpbnRcbiAgICAgICAgICAgIG91dHB1dDogdGhpcy5wcmludC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gaW5wdXRcbiAgICAgICAgICAgIGlucHV0ZnVuOiB0aGlzLmlucHV0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBpbnB1dGZ1blRha2VzUHJvbXB0OiB0cnVlLFxuICAgICAgICAgICAgLy8gTWVkaWEgSW1hZ2UgUHJveHkgVVJMXG4gICAgICAgICAgICBpbWFnZVByb3h5OiB0aGlzLmdldEltYWdlUHJveHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzZXQgYnkgdGhlIHN5c3RlbSBzbyB3ZSBjYW4gdXNlIG91ciBvd24gc2VydmVycyBpbiBwcmFjdGljZVxuICAgICAgICAgICAgZW1vamlQcm94eTogKHBhcnQpID0+IGBodHRwczovL3R3ZW1vamkubWF4Y2RuLmNvbS92LzEzLjEuMC9zdmcvJHtwYXJ0LnRvTG93ZXJDYXNlKCl9LnN2Z2AsXG4gICAgICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBrZWVwIHRoZSBnbG9iYWxzXG4gICAgICAgICAgICByZXRhaW5HbG9iYWxzOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBhY2Nlc3MgU2t1bHB0IGJ1aWx0LWlucy4gVGhpcyBpcyBwcmV0dHkgZ2VuZXJpYywgdGFrZW5cbiAgICAgKiBhbG1vc3QgZGlyZWN0bHkgZnJvbSB0aGUgU2t1bHB0IGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBUaGUgcHl0aG9uIGZpbGVuYW1lIChlLmcuLCBcIm9zXCIgb3IgXCJwcHJpbnRcIikgdGhhdCB3aWxsIGJlIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSBvZiB0aGUgZmlsZSAod2VpcmQsIHJpZ2h0PylcbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXNuJ3QgZm91bmQuXG4gICAgICovXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmltcGxlbWVudGVkIG1ldGhvZCFcIik7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9O1xuXG4gICAgb3BlblVSTCh1cmwsIGRhdGEsIHRpbWVvdXQpIHtcbiAgICAgICAgLy9yZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgbW9ja1VybERhdGEgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCI/bW9ja191cmxzLmJsb2NrcHlcIik7XG4gICAgICAgIGlmIChtb2NrVXJsRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBVUkwgRGF0YSB3YXMgbm90IG1hZGUgYXZhaWxhYmxlIGZvciB0aGlzIGFzc2lnbm1lbnRcIikpO1xuICAgICAgICB9XG4gICAgICAgIG1vY2tVcmxEYXRhID0gSlNPTi5wYXJzZShtb2NrVXJsRGF0YS5oYW5kbGUoKSk7XG4gICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIG1vY2tVcmxEYXRhKSB7XG4gICAgICAgICAgICBpZiAobW9ja1VybERhdGEuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9ja1VybERhdGFbZmlsZW5hbWVdLmxlbmd0aDsgaSs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vY2tVcmxEYXRhW2ZpbGVuYW1lXVtpXSA9PT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZURhdGEgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnJlYWRGaWxlKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZmlsZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vcmVqZWN0KG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogXCIrdXJsK1wiIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIHRocm93IChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFwiK3VybCtcIiB3YXMgbm90IG1hZGUgYXZhaWxhYmxlIGZvciB0aGlzIGFzc2lnbm1lbnRcIikpO1xuICAgICAgICAvL30pO1xuICAgIH1cblxuICAgIG9wZW5GaWxlKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmltcGxlbWVudGVkIG1ldGhvZCFcIik7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICB3cml0ZUZpbGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIHByaW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHJpbnQodmFsdWUpO1xuICAgIH1cblxuICAgIGlucHV0KCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmltcGxlbWVudGVkIG1ldGhvZCFcIik7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICBjbGVhcklucHV0KCkge1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnB1dE1vY2tGdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFNrLnF1ZXVlZElucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFNrLnF1ZXVlZElucHV0LnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0SW1hZ2VQcm94eSh1cmwpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIHN0ZXAoKSB7XG5cbiAgICB9XG5cbiAgICBsYXN0U3RlcCgpIHtcblxuICAgIH1cblxuICAgIGlzRm9yYmlkZGVuKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdCBzdWNjZXNzIGV4ZWN1dGlvblwiKTtcbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0IGZhaWx1cmUgZXhlY3V0aW9uXCIpO1xuICAgIH1cblxuICAgIGZpbmFsbHkocmVzdWx0KSB7XG4gICAgICAgIC8vIEZvcmNlIFB5Z2FtZSB0byBzdG9wIHRyYXBwaW5nIGtleWJvYXJkIGV2ZW50c1xuICAgICAgICBpZiAodGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5weWdhbWVMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5weWdhbWVMaW5lLnN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR1bW15T3V0U2FuZGJveCgpIHtcbiAgICAgICAgLy9Tay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvc2FuZGJveC5weVwiXSA9IFwiY2xhc3MgU2FuZGJveDogcGFzc1xcbmRlZiBydW4oKTogcGFzc1xcbmRlZiByZXNldCgpOiBwYXNzXFxuXCI7XG4gICAgfVxuXG4gICAgYmVmb3JlQ2FsbChmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncykge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVFJBQ0tJTkcgQ0FMTFwiLCBmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncyk7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBmYXN0Y2FsbCB0b28/IENoZWNrIGhvdyB0aGF0IHdvcmtzIGluIFNrdWxwdCBzaWRlXG4gICAgICAgIGxldCBzdHVkZW50TW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgaWYgKCEoXCJjYWxsc1wiIGluIHN0dWRlbnRNb2RlbCkpIHtcbiAgICAgICAgICAgIHN0dWRlbnRNb2RlbC5jYWxscyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZ1bmN0aW9uTmFtZSBpbiBzdHVkZW50TW9kZWwuY2FsbHMpKSB7XG4gICAgICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcmdzID0ge307XG4gICAgICAgIC8vIEdldCBhY3R1YWwgcGFyYW1ldGVyIG5hbWVzISFcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgcG9zYXJncy5sZW5ndGg7IGkrPSAxKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19BUkdcIitpXSA9IHBvc2FyZ3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGt3YXJncyAmJiBrd2FyZ3NbMF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJnc1tcIl9fQVJHU1wiXSA9IGt3YXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa3dhcmdzICYmIGt3YXJnc1sxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19LV0FSR1NcIl0gPSBrd2FyZ3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhhcmdzKTtcbiAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzW2Z1bmN0aW9uTmFtZV0ucHVzaChhcmdzKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7U3R1ZGVudENvbmZpZ3VyYXRpb259IGZyb20gXCIuL3N0dWRlbnRcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7QmxvY2tQeVRyYWNlfSBmcm9tIFwiLi4vdHJhY2VcIjtcblxuZXhwb3J0IGNsYXNzIEV2YWxDb25maWd1cmF0aW9uIGV4dGVuZHMgU3R1ZGVudENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUsIGNvZGUpIHtcbiAgICAgICAgLy8gVE9ETzogZml4IHRvIGJlIGN1cnJlbnRseSBhZGRlZCBsaW5lXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIl8gPSBcIiArIGNvZGU7XG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gbnVsbDtcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG5cbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IHRydWU7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscygpO1xuXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5BZGRcIiwgXCJcIiwgXCJcIiwgY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiQ29tcGlsZVwiLCBcIlwiLCBcIlwiLCB0aGlzLmNvZGUsIFwiZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFdmFsIHN1Y2Nlc3NcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRXZhbHVhdGUuUHJvZ3JhbVwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmdsb2JhbHMoU2suZ2xvYmFscyk7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LnJlc3VsdHMgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHJpbnRWYWx1ZShTay5mZmkucmVtYXBUb0pzKG1vZHVsZS4kZC5fLiRyKCkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vdGhpcy5zdGVwKG1vZHVsZS4kZCwgbW9kdWxlLiRkLC0xLCAwLCBmaWxlbmFtZSArIFwiLnB5XCIpO1xuICAgICAgICAgICAgdGhpcy5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInRyYWNlXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZSxcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVhbExpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5maWx0ZXIoeCA9PiAheC5pc0RvY3N0cmluZykubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlc3VsdHNcIjogbW9kdWxlLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ub3V0cHV0LFxuICAgICAgICAgICAgICAgIFwiZXZhbHVhdGlvblwiOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICAgICAgXCJjYWxsc1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY2FsbHMsXG4gICAgICAgICAgICAgICAgXCJ0cmFjaW5nXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXZhbCBmYWlsdXJlXCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlLkVycm9yXCIsIFwiXCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwiZXZhbHVhdGlvblwiOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICAgICAgXCJ0cmFjaW5nXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHtDb25maWd1cmF0aW9uLCBFTVBUWV9NT0RVTEV9IGZyb20gXCIuL2NvbmZpZ3VyYXRpb25zLmpzXCI7XG5pbXBvcnQgeyRza19tb2RfaW5zdHJ1Y3Rvcn0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL3NrX21vZF9pbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyRza19tb2RfY292ZXJhZ2V9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZVwiO1xuaW1wb3J0IHskcGVkYWxfdHJhY2VyfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyXCI7XG5pbXBvcnQge2Nob21wU3BlY2lhbEZpbGV9IGZyb20gXCIuLi9maWxlc1wiO1xuXG5jb25zdCBVVElMSVRZX01PRFVMRV9DT0RFID0gXCJ2YXIgJGJ1aWx0aW5tb2R1bGUgPSBcIiArICRza19tb2RfaW5zdHJ1Y3Rvci50b1N0cmluZygpO1xuY29uc3QgQ09WRVJBR0VfTU9EVUxFX0NPREUgPSAkc2tfbW9kX2NvdmVyYWdlO1xuXG5leHBvcnQgY2xhc3MgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBJbnN0cnVjdG9ycyBnZXQgNCBzZWNvbmRzXG4gICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IDcwMDA7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKCk7XG4gICAgICAgIC8vIFN0ZXBwZXIhIEV4ZWN1dGVkIGFmdGVyIGV2ZXJ5IHN0YXRlbWVudC5cbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsOyAvLyAxMCAqMTAwMFxuICAgICAgICAvLyBNdXRlIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIodHJ1ZSk7XG4gICAgICAgIC8vIERpc2FibGUgaW5wdXQgYm94XG4gICAgICAgIFNrLnF1ZXVlZElucHV0ID0gW107XG4gICAgICAgIC8vIFRPRE8gU2suaW5wdXRmdW4gPSBCbG9ja1B5RW5naW5lLmlucHV0TW9ja0Z1bmN0aW9uO1xuICAgICAgICAvLyBUT0RPOiBBbGxvdyBpbnB1dCBmdW5jdGlvbiB0byBkaXNhYmxlIHRoZSB0aW1lciwgc29tZWhvd1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBiZWZvcmVDYWxsIGNoZWNrZXIgdW5sZXNzIHNwZWNpZmljYWxseSByZXF1ZXN0ZWRcbiAgICAgICAgU2suYmVmb3JlQ2FsbEJhY2t1cCA9IFNrLmJlZm9yZUNhbGw7XG4gICAgICAgIFNrLmJlZm9yZUNhbGwgPSBudWxsO1xuICAgICAgICAvLyBFbmFibGUgdXRpbGl0eSBtb2RlXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvdXRpbGl0eS9fX2luaXRfXy5qc1wiXSA9IFVUSUxJVFlfTU9EVUxFX0NPREU7XG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvY292ZXJhZ2UucHlcIl0gPSBDT1ZFUkFHRV9NT0RVTEVfQ09ERTtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyBuZWVkcyB0byBiZSBvcHRpbWl6ZWRcbiAgICAgICAgLy9jb25zdCBQRURBTF9UUkFDRVJfTU9EVUxFX0NPREUgPSBTay5jb21waWxlKCRwZWRhbF90cmFjZXIsIFwidHJhY2VyLnB5XCIsIFwiZXhlY1wiLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC90cmFjZXIucHlcIl0gPSAkcGVkYWxfdHJhY2VyO1xuICAgICAgICBkZWxldGUgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3RyYWNlci5qc1wiXTtcbiAgICAgICAgLy8gVE9ETzogTW9jayBQZWRhbCdzIHRyYWNlciBtb2R1bGUgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmVyc2lvblxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCIuL19pbnN0cnVjdG9yL19faW5pdF9fLmpzXCJdID0gRU1QVFlfTU9EVUxFO1xuICAgICAgICAvLyBSZXVzZSBhbnkgZXhpc3Rpbmcgc3lzbW9kdWxlcyB0aGF0IHdlIHByZXZpb3VzbHkgZm91bmQsIGJ1dCBub3QgX19tYWluX18gbW9kdWxlc1xuICAgICAgICB0aGlzLnN5c21vZHVsZXMgPSB0aGlzLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cygpO1xuICAgICAgICAvLyBIb3JyaWZpYyBoYWNrLCB0byBwcmV2ZW50IFRpZmEgZnJvbSBjYWNoaW5nIGEgYmFkIHZlcnNpb24gb2YgdGhlIHN0dWRlbnRzJyBpbXBvcnRcbiAgICAgICAgU2suY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzID0gdGhpcy5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cygpIHtcbiAgICAgICAgbGV0IHN5c21vZHVsZXMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcztcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIGlmIChzeXNtb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGVuYW1lIG9mIHRoaXMuZ2V0QWxsRmlsZW5hbWVzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2tGaWxlbmFtZSA9IG5ldyBTay5idWlsdGluLnN0cihmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN5c21vZHVsZXMucXVpY2skbG9va3VwKHNrRmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5c21vZHVsZXMuZGVsJGl0ZW0oc2tGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeXNtb2R1bGVzO1xuICAgIH1cblxuICAgIGdldEFsbFN0dWRlbnRGaWxlcygpIHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB7XG4gICAgICAgICAgICBcImFuc3dlci5weVwiOiB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKVxuICAgICAgICB9O1xuICAgICAgICAvLyBTa2lwIHNwZWNpYWwgaW5zdHJ1Y3RvciBmaWxlc1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBpZiAoIShcIiFeJCNcIi5pbmNsdWRlcyhmaWxlLmZpbGVuYW1lKClbMF0pKSkge1xuICAgICAgICAgICAgICAgIGZpbGVzW2ZpbGUuZmlsZW5hbWUoKV0gPSBjaG9tcFNwZWNpYWxGaWxlKGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbmNsdWRlIG5vcm1hbCBzdHVkZW50IGV4dHJhIGZpbGVzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgZmlsZXNbZmlsZS5maWxlbmFtZSgpXSA9IGZpbGUuY29udGVudHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG5cbiAgICBnZXRBbGxGaWxlbmFtZXMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IGNob21wU3BlY2lhbEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKFwiLnB5XCIpKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiX19tYWluX19cIixcbiAgICAgICAgICAgIFwiX2luc3RydWN0b3JcIixcbiAgICAgICAgICAgIC4uLnRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkubWFwKGZpbGUgPT4gXCJfaW5zdHJ1Y3Rvci5cIiArIGNsZWFuKGZpbGUuZmlsZW5hbWUoKSkpLFxuICAgICAgICAgICAgLi4udGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpLm1hcChmaWxlID0+IGNsZWFuKGZpbGUuZmlsZW5hbWUoKSkpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGdldFRpbWVvdXRQcm9tcHQobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKGxvbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGhhcyB0YWtlbiBhIFJFQUxMWSBsb25nIHRpbWUgdG8gY2hlY2sgeW91ciBjb2RlICgzMCBvciBtb3JlIHNlY29uZHMpLiBZb3UgbWlnaHQgd2FudCB0byBjYW5jZWwgYW5kIGNoZWNrIHlvdXIgY29kZSAob3IgZ2V0IGhlbHAgZnJvbSBhbiBpbnN0cnVjdG9yKS4gT3IsIHlvdSBjYW4gYWRkIG1vcmUgc2Vjb25kcyB0byB3YWl0IGJlbG93LlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIGluc3RydWN0b3IgY29kZSBpcyB0YWtpbmcgYSBsaXR0bGUgd2hpbGUgdG8gY2hlY2sgeW91ciBjb2RlOyBpdCBtaWdodCBqdXN0IG5lZWQgYSBsaXR0bGUgbW9yZSB0aW1lLiBIb3cgbWFueSBtb3JlIHNlY29uZHMgd291bGQgeW91IGxpa2UgdG8gd2FpdD9cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5GaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiBcIitmaWxlbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGltcG9ydEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcIi4vYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9vbl9ldmFsLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSB8fCBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vX2luc3RydWN0b3IvX19pbml0X18uanNcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX01PRFVMRTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkJ1aWx0LWluIG1vZHVsZXMgbm90IGFjY2Vzc2libGUuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogJ1wiK2ZpbGVuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIC8vcmV0dXJuIFwiQXBwbGVQaWVcIjtcbiAgICAgICAgY29uc29sZS5sb2coXCI+Pj5cIiwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKSk7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKSA8IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dEluZGV4ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCk7XG4gICAgICAgICAgICBsZXQgbmV4dElucHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dElucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiQXBwbGVQaWVcIjtcbiAgICAgICAgfVxuICAgICAgICAvKnJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShTay5xdWV1ZWRJbnB1dC5wb3AoKSk7XG4gICAgICAgIH0pOyovXG4gICAgfVxuXG4gICAgYmVmb3JlQ2FsbChmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncykge1xuICAgICAgICBsZXQgc3R1ZGVudE1vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJIRVkgSU5TVFJVQ1RPUiBDQUxMXCIsIGZ1bmN0aW9uTmFtZSwgc3R1ZGVudE1vZGVsLnRyYWNpbmcpO1xuICAgICAgICBpZiAoc3R1ZGVudE1vZGVsLnRyYWNpbmcgJiYgc3R1ZGVudE1vZGVsLnRyYWNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdXBlci5iZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcblxuZXhwb3J0IGNsYXNzIE9uQ2hhbmdlQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9jaGFuZ2UucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJpZ2dlck9uQ2hhbmdlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldCwgSU5TVFJVQ1RPUl9NQVJLRVIsIE5FV19MSU5FX1JFR0VYfSBmcm9tIFwiLi9vbl9ydW5cIjtcbmltcG9ydCB7aW5kZW50fSBmcm9tIFwiLi4vdXRpbGl0aWVzXCI7XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgV1JBUF9JTlNUUlVDVE9SX0NPREUgPSBmdW5jdGlvbiAoc3R1ZGVudENvZGUsIGluc3RydWN0b3JDb2RlLCBxdWljaywgaXNTYWZlKSB7XG4gICAgbGV0IHNhZmVDb2RlID0gSlNPTi5zdHJpbmdpZnkoc3R1ZGVudENvZGUpO1xuXG4gICAgcmV0dXJuIGBcbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbiMgQmFja3VwIHRoZSBmZWVkYmFja1xub25fcnVuX2ZlZWRiYWNrID0gW11cbmZvciBmZWVkYmFjayBpbiBNQUlOX1JFUE9SVC5mZWVkYmFjazpcbiAgICBvbl9ydW5fZmVlZGJhY2suYXBwZW5kKGZlZWRiYWNrKVxuTUFJTl9SRVBPUlQuZmVlZGJhY2suY2xlYXIoKVxuXG5mcm9tIHBlZGFsLmVudmlyb25tZW50cy5ibG9ja3B5IGltcG9ydCBzZXR1cF9lbnZpcm9ubWVudFxuIyBBZGQgaW4gZXZhbHVhdGVkIHN0dWZmIGZyb20gbGFzdCB0aW1lXG5zdHVkZW50ID0gZ2V0X3NhbmRib3goKVxuIyBUT0RPOiBXaGF0IGFib3V0IG5ldyBpbnB1dHMgc2luY2Ugd2UgbGFzdCByYW4vZXZhbGVkP1xuIyBNQUlOX1JFUE9SVC5zdWJtaXNzaW9uLmZpbGVzWydldmFsdWF0aW9uJ10gPSAke3NhZmVDb2RlfVxuZXZhbHVhdGUoJHtzYWZlQ29kZX1bJ2V2YWx1YXRpb24nXSlcblxuIyBUT0RPOiBSZWZhY3RvciByZXNvbHZlciB0byByZXR1cm4gaW5zdHJ1Y3Rpb25zXG4jIE1vbmtleS1wYXRjaCBxdWVzdGlvbnNcbiNmcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbiNxdWVzdGlvbnMuc2hvd19xdWVzdGlvbiA9IHNldF9pbnN0cnVjdGlvbnNcblxuJHtJTlNUUlVDVE9SX01BUktFUn1cbiR7aW5zdHJ1Y3RvckNvZGV9XG5cbiMgUmVzb2x2ZSBldmVyeXRoaW5nXG5mcm9tIHBlZGFsLnJlc29sdmVycy5zaW1wbGUgaW1wb3J0IHJlc29sdmVcbmZpbmFsID0gcmVzb2x2ZSgpXG5TVUNDRVNTID0gZmluYWwuc3VjY2Vzc1xuU0NPUkUgPSBmaW5hbC5zY29yZVxuQ0FURUdPUlkgPSBmaW5hbC5jYXRlZ29yeVxuTEFCRUwgPSBmaW5hbC50aXRsZVxuTUVTU0FHRSA9IGZpbmFsLm1lc3NhZ2VcbkRBVEEgPSBmaW5hbC5kYXRhXG5ISURFID0gZmluYWwuaGlkZV9jb3JyZWN0bmVzc1xuXG4jIEhhbmRsZSBxdWVzdGlvbnNcbmlmIGZpbmFsLmluc3RydWN0aW9uczpcbiAgICBzZXRfaW5zdHJ1Y3Rpb25zKGZpbmFsLmluc3RydWN0aW9uc1stMV0ubWVzc2FnZSlcbiAgICBcbiMgSGFuZGxlIHBvc2l0aXZlIGZlZWRiYWNrXG5QT1NJVElWRSA9IFtdXG5mb3IgcG9zaXRpdmUgaW4gZmluYWwucG9zaXRpdmVzOlxuICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5tZXNzYWdlXG4gICAgaWYgbm90IHBvc2l0aXZlOlxuICAgICAgICBtZXNzYWdlID0gcG9zaXRpdmUuZWxzZV9tZXNzYWdlXG4gICAgUE9TSVRJVkUuYXBwZW5kKHtcbiAgICAgICAgXCJ0aXRsZVwiOiBwb3NpdGl2ZS50aXRsZSxcbiAgICAgICAgXCJsYWJlbFwiOiBwb3NpdGl2ZS5sYWJlbCxcbiAgICAgICAgXCJtZXNzYWdlXCI6IG1lc3NhZ2VcbiAgICB9KVxuICAgIFxuIyBIYW5kbGUgc3lzdGVtIG1lc3NhZ2VzXG5mb3Igc3lzdGVtIGluIGZpbmFsLnN5c3RlbXM6XG4gICAgaWYgc3lzdGVtLmxhYmVsID09ICdsb2cnOlxuICAgICAgICBjb25zb2xlX2xvZyhzeXN0ZW0udGl0bGUsIHN5c3RlbS5tZXNzYWdlKTtcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2RlYnVnJzpcbiAgICAgICAgY29uc29sZV9kZWJ1ZyhzeXN0ZW0udGl0bGUsIHN5c3RlbS5tZXNzYWdlKTtcblxuYDtcbn07XG5cbmV4cG9ydCBjbGFzcyBPbkV2YWxDb25maWd1cmF0aW9uIGV4dGVuZHMgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIl9pbnN0cnVjdG9yLm9uX2V2YWxcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkgfHwgXCJcIjtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuXG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIC8vbGV0IHN0dWRlbnRDb2RlU2FmZSA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50LmV2YWx1YXRpb24gfHwgXCJOb25lXCI7XG4gICAgICAgIGxldCBzdHVkZW50RmlsZXMgPSB0aGlzLmdldEFsbFN0dWRlbnRGaWxlcygpO1xuICAgICAgICBzdHVkZW50RmlsZXNbXCJldmFsdWF0aW9uXCJdID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQuZXZhbHVhdGlvbiB8fCBcIk5vbmVcIjtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+PlwiLCBpbnN0cnVjdG9yQ29kZSk7XG4gICAgICAgIGxldCBsaW5lT2Zmc2V0ID0gZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQoaW5zdHJ1Y3RvckNvZGUpOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGg7XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7XG4gICAgICAgICAgICBcImNvbXBsaW1lbnRzXCI6IFtdLFxuICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBcIi4vX2luc3RydWN0b3Ivb25fZXZhbC5weVwiLFxuICAgICAgICAgICAgXCJjb2RlXCI6IGluc3RydWN0b3JDb2RlLFxuICAgICAgICAgICAgXCJsaW5lT2Zmc2V0XCI6IGxpbmVPZmZzZXRcbiAgICAgICAgICAgIC8vJ2NvbXBsZXRlJzogZmFsc2UgLy8gQWN0dWFsbHksIGxldCdzIHVzZSB1bmRlZmluZWQgZm9yIG5vdy5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG5cbiAgICAgICAgLy9Tay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3IuZ2xvYmFscztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9uRXZhbCBzdWNjZXNzXCIpO1xuICAgICAgICAvLyBUT0RPOiBBY3R1YWxseSBwYXJzZSByZXN1bHRzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzID0gU2suZ2xvYmFscztcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLnN5c21vZHVsZXMgPSBTay5zeXNtb2R1bGVzO1xuICAgICAgICBjb25zb2xlLmxvZyhtb2R1bGUpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG1vZHVsZS4kZC5vbl9ldmFsLiRkO1xuICAgICAgICBjb25zb2xlLmxvZyhtb2R1bGUuJGQpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBzY29yZSkpO1xuICAgICAgICBsZXQgb2xkU2NvcmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZShNYXRoLm1heChvbGRTY29yZSwgc2NvcmUpKTtcbiAgICAgICAgLy8gSGlkZSBzdGF0dXNcbiAgICAgICAgbGV0IGhpZGUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuSElERSk7XG4gICAgICAgIC8vIEFuZCBmaXJlIHRoZSByZXN1bHQhXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNjb3JlLCBzdWNjZXNzLCBoaWRlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAvL2FmdGVyKG1vZHVsZSk7XG5cbiAgICAgICAgLyppZiAoc3VjY2VzcyAmJiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3ModGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaWQoKSk7XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmICghU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufSIsImltcG9ydCB7aW5kZW50fSBmcm9tIFwiLi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldChpbnN0cnVjdG9yQ29kZSkge1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3RvckNvZGUuaW5kZXhPZihJTlNUUlVDVE9SX01BUktFUik7XG4gICAgY29uc3QgYmVmb3JlID0gaW5zdHJ1Y3RvckNvZGUuc2xpY2UoMCwgaW5kZXgpO1xuICAgIGNvbnN0IG1hdGNoID0gYmVmb3JlLm1hdGNoKE5FV19MSU5FX1JFR0VYKTtcbiAgICByZXR1cm4gbWF0Y2ggPyAoMSttYXRjaC5sZW5ndGgpIDogMDtcbn1cblxuZXhwb3J0IGNvbnN0IElOU1RSVUNUT1JfTUFSS0VSID0gXCIjIyNSdW4gdGhlIGFjdHVhbCBpbnN0cnVjdG9yIGNvZGUjIyNcIjtcbmV4cG9ydCBjb25zdCBORVdfTElORV9SRUdFWCA9IC9cXG4vZztcbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgV1JBUF9JTlNUUlVDVE9SX0NPREUgPSBmdW5jdGlvbiAoc3R1ZGVudEZpbGVzLCBpbnN0cnVjdG9yQ29kZSwgcXVpY2ssIGlzU2FmZSkge1xuICAgIGxldCBzYWZlQ29kZSA9IEpTT04uc3RyaW5naWZ5KHN0dWRlbnRGaWxlcyk7XG4gICAgbGV0IHNraXBfdGlmYSA9IHF1aWNrID8gXCJUcnVlXCI6IFwiRmFsc2VcIjtcblxuICAgIC8vIFRPRE86IEFkZCBpbiBTay5xdWV1ZWRJbnB1dCB0byBiZSBwYXNzZWQgaW5cblxuICAgIHJldHVybiBgXG4jIFN1cHBvcnQgb3VyIHN5c21vZHVsZXMgaGFjayBieSBjbGVhcmluZyBvdXQgYW55IGxpbmdlcmluZyBvbGQgZGF0YVxuZnJvbSBwZWRhbC5jb3JlLnJlcG9ydCBpbXBvcnQgTUFJTl9SRVBPUlRcbk1BSU5fUkVQT1JULmNsZWFyKClcblxuZnJvbSBjaXNjMTA4IGltcG9ydCBzdHVkZW50X3Rlc3RzXG5zdHVkZW50X3Rlc3RzLnJlc2V0KClcblxuZnJvbSB1dGlsaXR5IGltcG9ydCAqXG5cbiMgTG9hZCBpbiBzb21lIGNvbW1vbmx5IHVzZWQgdG9vbHNcbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuZnJvbSBwZWRhbC5zYW5kYm94LmNvbW1hbmRzIGltcG9ydCAqXG5mcm9tIHBlZGFsLmNvcmUuY29tbWFuZHMgaW1wb3J0ICpcblxuZnJvbSBwZWRhbC5lbnZpcm9ubWVudHMuYmxvY2tweSBpbXBvcnQgc2V0dXBfZW52aXJvbm1lbnRcbiMgRG8gd2UgZXhlY3V0ZSBzdHVkZW50J3MgY29kZT9cbnNraXBfcnVuID0gZ2V0X21vZGVsX2luZm8oJ2Fzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUluc3RydWN0b3JSdW4nKVxuaW5wdXRzID0gTm9uZSBpZiBza2lwX3J1biBlbHNlIGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKVxuXG4jIFNldCB0aGUgc2VlZCB0byB0aGUgc3VibWlzc2lvbiBJRCBieSBkZWZhdWx0P1xuZnJvbSBwZWRhbC5xdWVzdGlvbnMgaW1wb3J0IHNldF9zZWVkXG5zZXRfc2VlZChzdHIoZ2V0X21vZGVsX2luZm8oXCJzdWJtaXNzaW9uLmlkXCIpKSlcblxuIyBJbml0aWFsaXplIHRoZSBCbG9ja1B5IGVudmlyb25tZW50XG5wZWRhbCA9IHNldHVwX2Vudmlyb25tZW50KHNraXBfdGlmYT0ke3NraXBfdGlmYX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfcnVuPXNraXBfcnVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM9aW5wdXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluX2ZpbGU9J2Fuc3dlci5weScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzPSR7c2FmZUNvZGV9KVxuc3R1ZGVudCA9IHBlZGFsLmZpZWxkc1snc3R1ZGVudCddXG5cbiMgVE9ETzogUmVmYWN0b3IgcmVzb2x2ZXIgdG8gcmV0dXJuIGluc3RydWN0aW9uc1xuIyBNb25rZXktcGF0Y2ggcXVlc3Rpb25zXG4jZnJvbSBwZWRhbCBpbXBvcnQgcXVlc3Rpb25zXG4jcXVlc3Rpb25zLnNob3dfcXVlc3Rpb24gPSBzZXRfaW5zdHJ1Y3Rpb25zXG5cbiR7SU5TVFJVQ1RPUl9NQVJLRVJ9XG4ke2luc3RydWN0b3JDb2RlfVxuXG4jIFJlc29sdmUgZXZlcnl0aGluZ1xuZnJvbSBwZWRhbC5yZXNvbHZlcnMuc2ltcGxlIGltcG9ydCByZXNvbHZlXG5maW5hbCA9IHJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuIyBIYW5kbGUgcXVlc3Rpb25zXG5pZiBmaW5hbC5pbnN0cnVjdGlvbnM6XG4gICAgc2V0X2luc3RydWN0aW9ucyhmaW5hbC5pbnN0cnVjdGlvbnNbLTFdLm1lc3NhZ2UpXG4gICAgXG4jIEhhbmRsZSBwb3NpdGl2ZSBmZWVkYmFja1xuUE9TSVRJVkUgPSBbXVxuZm9yIHBvc2l0aXZlIGluIGZpbmFsLnBvc2l0aXZlczpcbiAgICBtZXNzYWdlID0gcG9zaXRpdmUubWVzc2FnZVxuICAgIGlmIG5vdCBwb3NpdGl2ZTpcbiAgICAgICAgbWVzc2FnZSA9IHBvc2l0aXZlLmVsc2VfbWVzc2FnZVxuICAgIFBPU0lUSVZFLmFwcGVuZCh7XG4gICAgICAgIFwidGl0bGVcIjogcG9zaXRpdmUudGl0bGUsXG4gICAgICAgIFwibGFiZWxcIjogcG9zaXRpdmUubGFiZWwsXG4gICAgICAgIFwibWVzc2FnZVwiOiBtZXNzYWdlXG4gICAgfSlcbiAgICBcbiMgSGFuZGxlIHN5c3RlbSBtZXNzYWdlc1xuZm9yIHN5c3RlbSBpbiBmaW5hbC5zeXN0ZW1zOlxuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnbG9nJzpcbiAgICAgICAgY29uc29sZV9sb2coc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG4gICAgaWYgc3lzdGVtLmxhYmVsID09ICdkZWJ1Zyc6XG4gICAgICAgIGNvbnNvbGVfZGVidWcoc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG5cbmA7XG59O1xuXG5leHBvcnQgY2xhc3MgT25SdW5Db25maWd1cmF0aW9uIGV4dGVuZHMgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIl9pbnN0cnVjdG9yLm9uX3J1blwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpO1xuXG4gICAgICAgIGxldCBkaXNhYmxlVGlmYSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaWZhKCk7XG4gICAgICAgIC8vIFB1dCB0aGUgaW5wdXQgaW5kZXggYmFjayB0byB0aGUgZnJvbnQsIHNvIHdlIGNhbiByZXBsYXkgaW5wdXRzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgxKTtcblxuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICAvL2xldCBzdHVkZW50Q29kZVNhZmUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIGxldCBzdHVkZW50RmlsZXMgPSB0aGlzLmdldEFsbFN0dWRlbnRGaWxlcygpO1xuICAgICAgICB0aGlzLmR1bW15T3V0U2FuZGJveCgpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3RvckNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudEZpbGVzLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGxldCBsaW5lT2Zmc2V0ID0gZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQoaW5zdHJ1Y3RvckNvZGUpOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGg7XG4gICAgICAgIC8vbGluZU9mZnNldCA9IDA7IC8vaW5zdHJ1Y3RvckNvZGUuc3BsaXQoTkVXX0xJTkVfUkVHRVgpLmxlbmd0aCAtIGxpbmVPZmZzZXQgLSA0O1xuICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdID0ge1xuICAgICAgICAgICAgXCJjb21wbGltZW50c1wiOiBbXSxcbiAgICAgICAgICAgIFwiZmlsZW5hbWVcIjogXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiLFxuICAgICAgICAgICAgXCJjb2RlXCI6IGluc3RydWN0b3JDb2RlLFxuICAgICAgICAgICAgXCJsaW5lT2Zmc2V0XCI6IGxpbmVPZmZzZXRcbiAgICAgICAgICAgIC8vJ2NvbXBsZXRlJzogZmFsc2UgLy8gQWN0dWFsbHksIGxldCdzIHVzZSB1bmRlZmluZWQgZm9yIG5vdy5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgLy8gVE9ETyBMb2dnaW5nISEhIVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiT25SdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgLy8gVE9ETzogQWN0dWFsbHkgcGFyc2UgcmVzdWx0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3IuZ2xvYmFscyA9IFNrLmdsb2JhbHM7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzID0gU2suc3lzbW9kdWxlcztcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG1vZHVsZS4kZC5vbl9ydW4uJGQ7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc2NvcmUpKTtcbiAgICAgICAgbGV0IG9sZFNjb3JlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoKTtcbiAgICAgICAgc2NvcmUgPSBNYXRoLm1heChvbGRTY29yZSwgc2NvcmUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZShzY29yZSk7XG4gICAgICAgIC8vIEhpZGUgc3RhdHVzXG4gICAgICAgIGxldCBoaWRlID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLkhJREUpO1xuICAgICAgICAvLyBBbmQgZmlyZSB0aGUgcmVzdWx0IVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvbihzY29yZSwgc3VjY2VzcywgaGlkZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgLy9hZnRlcihtb2R1bGUpO1xuXG4gICAgICAgIC8qaWYgKHN1Y2Nlc3MgJiYgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmlkKCkpO1xuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoIVNrLmV4ZWN1dGlvblJlcG9ydHMuaW5zdHJ1Y3Rvci5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiT25SdW4gZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIkdyYWNlZnVsRXhpdFwiKSB7XG4gICAgICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImNvZGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiZXJyb3JcIl0gPSBlcnJvcjtcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImxpbmVfb2Zmc2V0XCJdID0gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGFmdGVyKGVycm9yKTtcbiAgICB9XG59XG5cblxuLypcbiMgVGhlIGZvbGxvd2luZyBpcyB0aGUgb2xkIGluc3RydWN0b3IgY29kZSwgbGVhdmluZyBpdCBoZXJlIGZvciBub3cuXG5cbmZyb20gcGVkYWwuY29yZS5yZXBvcnQgaW1wb3J0IE1BSU5fUkVQT1JUXG4jIFN1cHBvcnQgb3VyIHN5c21vZHVsZXMgaGFjayBieSBjbGVhcmluZyBvdXQgYW55IGxpbmdlcmluZyBvbGQgZGF0YVxuTUFJTl9SRVBPUlQuY2xlYXIoKVxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCBjb250ZXh0dWFsaXplX3JlcG9ydFxuY29udGV4dHVhbGl6ZV9yZXBvcnQoJHtzYWZlQ29kZX0sIFwiYW5zd2VyLnB5XCIpXG4ke3RpZmFBbmFseXNpc31cbmZyb20gcGVkYWwuc2FuZGJveC5zYW5kYm94IGltcG9ydCBTYW5kYm94XG5mcm9tIHBlZGFsLnNhbmRib3ggaW1wb3J0IGNvbXBhdGliaWxpdHlcbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuc3R1ZGVudCA9IE1BSU5fUkVQT1JUWydzYW5kYm94J11bJ3J1biddID0gU2FuZGJveCgpXG5zdHVkZW50LnJlcG9ydF9leGNlcHRpb25zX21vZGUgPSBUcnVlXG5sb2coZ2V0X21vZGVsX2luZm8oJ2V4ZWN1dGlvbi5pbnB1dCcpKVxuc3R1ZGVudC5zZXRfaW5wdXQoZ2V0X21vZGVsX2luZm8oJ2V4ZWN1dGlvbi5pbnB1dCcpKVxuaWYgbm90IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJyk6XG4gICAgY29tcGF0aWJpbGl0eS5ydW5fc3R1ZGVudChyYWlzZV9leGNlcHRpb25zPUZhbHNlKVxuI2xvZyhzdHVkZW50LmRhdGEpXG4jc3R1ZGVudCA9IGdldF9zdHVkZW50X2RhdGEoKVxuI2Vycm9yLCBwb3NpdGlvbiA9IGdldF9zdHVkZW50X2Vycm9yKClcbiNjb21wYXRpYmlsaXR5LnJhaXNlX2V4Y2VwdGlvbihlcnJvciwgcG9zaXRpb24pXG5ydW5fc3R1ZGVudCA9IGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnRcbnJlc2V0X291dHB1dCA9IGNvbXBhdGliaWxpdHkucmVzZXRfb3V0cHV0XG5xdWV1ZV9pbnB1dCA9IGNvbXBhdGliaWxpdHkucXVldWVfaW5wdXRcbmdldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LmdldF9vdXRwdXRcbmdldF9wbG90cyA9IGNvbXBhdGliaWxpdHkuZ2V0X3Bsb3RzXG5jb21wYXRpYmlsaXR5LnRyYWNlX2xpbmVzID0gdHJhY2VfbGluZXNcbmZyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xucXVlc3Rpb25zLnNob3dfcXVlc3Rpb24gPSBzZXRfaW5zdHJ1Y3Rpb25zXG4jIFRPRE86IFJlbW92ZSB0aGUgbmVlZCBmb3IgdGhpcyBoYWNrIVxuZGVmIGNhcHR1cmVfb3V0cHV0KGZ1bmMsICphcmdzKTpcbiAgIHJlc2V0X291dHB1dCgpXG4gICBzdHVkZW50LmNhbGwoZnVuYy5fX25hbWVfXywgKmFyZ3MpXG4gICByZXR1cm4gZ2V0X291dHB1dCgpXG5jb21wYXRpYmlsaXR5LmNhcHR1cmVfb3V0cHV0ID0gY2FwdHVyZV9vdXRwdXRcblxuZnJvbSBwZWRhbC5jYWl0LmNhaXRfYXBpIGltcG9ydCBwYXJzZV9wcm9ncmFtXG4ke2luc3RydWN0b3JDb2RlfVxuZnJvbSBwZWRhbC5yZXNvbHZlcnMgaW1wb3J0IHNpbXBsZVxuZmluYWwgPSBzaW1wbGUucmVzb2x2ZSgpXG5TVUNDRVNTID0gZmluYWwuc3VjY2Vzc1xuU0NPUkUgPSBmaW5hbC5zY29yZVxuQ0FURUdPUlkgPSBmaW5hbC5jYXRlZ29yeVxuTEFCRUwgPSBmaW5hbC50aXRsZVxuTUVTU0FHRSA9IGZpbmFsLm1lc3NhZ2VcbkRBVEEgPSBmaW5hbC5kYXRhXG5ISURFID0gZmluYWwuaGlkZV9jb3JyZWN0bmVzc1xuXG4gKi8iLCJpbXBvcnQge09uUnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vb25fcnVuXCI7XG5cbmV4cG9ydCBjbGFzcyBPblNhbXBsZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBPblJ1bkNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIm9uX3J1bi5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge1N0dWRlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zdHVkZW50XCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5cbmV4cG9ydCBjbGFzcyBSdW5Db25maWd1cmF0aW9uIGV4dGVuZHMgU3R1ZGVudENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC51aS5maWxlcy5nZXRTdHVkZW50Q29kZSgpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVN0dWRlbnRSdW4oKSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVGaWxlKFwiYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGVcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5jb2RlKTtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG5cbiAgICAgICAgZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyc2UoKTtcblxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHNbXCJ2ZXJpZmllclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBCb29sZWFuKHRoaXMuY29kZS50cmltKCkpLFxuICAgICAgICAgICAgXCJjb2RlXCI6IHRoaXMuY29kZVxuICAgICAgICB9O1xuXG4gICAgICAgIFNrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNsZWFySW5wdXQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJ1biBzdWNjZXNzXCIpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIFwiaW5wdXRzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICAgICAgXCJvdXRwdXRzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ub3V0cHV0KCkubWFwKGxpbmUgPT4gbGluZS5jb250ZW50KS5qb2luKFwiXFxuXCIpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJSdW4uUHJvZ3JhbVwiLCBcIlwiLCBcIlwiLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbihmYWxzZSk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuZmluaXNoVHVydGxlcygpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmdsb2JhbHMoU2suZ2xvYmFscyk7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LnJlc3VsdHMgPSBtb2R1bGU7XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUV2YWx1YXRlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuYmVnaW5FdmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RlcChtb2R1bGUuJGQsIG1vZHVsZS4kZCwtMSwgMCwgZmlsZW5hbWUgKyBcIi5weVwiKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0cmFjZVwiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlYWxMaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UuZmlsdGVyKHggPT4gIXguaXNEb2NzdHJpbmcpLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZXN1bHRzXCI6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICBcIm91dHB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCxcbiAgICAgICAgICAgICAgICBcImlucHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgXCJjYWxsc1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY2FsbHMsXG4gICAgICAgICAgICAgICAgXCJ0cmFjaW5nXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmYWlsdXJlKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSdW4gZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKHJlcG9ydC5wYXJzZXIuc3VjY2VzcyAmJiByZXBvcnQudmVyaWZpZXIuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiQ29tcGlsZS5FcnJvclwiLCBcIlwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlJ1bi5Qcm9ncmFtXCIsIFwiUHJvZ3JhbUVycm9yT3V0cHV0XCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge1N0dWRlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zdHVkZW50XCI7XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgU3R1ZGVudENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIFRPRE86IEZpeCB0byBiZSB0aGUgY3VycmVudCBzYW1wbGUgc3VibWlzc2lvblxuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJhbnN3ZXIucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJwcmludCgnTm90IHJlYWR5IHlldCEnKVwiO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnNcIjtcblxuZXhwb3J0IGNsYXNzIFN0dWRlbnRDb25maWd1cmF0aW9uIGV4dGVuZHMgQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gTGltaXQgZXhlY3V0aW9uIHRvIDQgc2Vjb25kc1xuICAgICAgICBsZXQgc2V0dGluZ3MgPSB0aGlzLm1haW4ubW9kZWwuc2V0dGluZ3M7XG4gICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IDUwMDA7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKCk7XG4gICAgICAgIC8vIFN0ZXBwZXIhIEV4ZWN1dGVkIGFmdGVyIGV2ZXJ5IHN0YXRlbWVudC5cbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSB0aGlzLnN0ZXAuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBVbm11dGUgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcihmYWxzZSk7XG5cbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCBhZnRlciBlYWNoIHN0ZXBcbiAgICAgICAgLy8gYWZ0ZXJTaW5nbGVFeGVjdXRpb25cblxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3V0aWxpdHkvX19pbml0X18uanNcIl0gPSBFTVBUWV9NT0RVTEU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmaWxlbmFtZSwgZm91bmQpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKFNrLmJ1aWx0aW5GaWxlcyAmJiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogXCIgKyBmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGltcG9ydEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb3JiaWRkZW4oZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkZpbGUgbm90IGFjY2Vzc2libGU6ICdcIiArIGZpbGVuYW1lICsgXCInXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkJ1aWx0LWluIG1vZHVsZXMgbm90IGFjY2Vzc2libGUuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXQocHJvbXB0TWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5pbnB1dChwcm9tcHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpc0ZvcmJpZGRlbihmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChcInNyYy9saWIvdXRpbGl0eS9cIikgfHxcbiAgICAgICAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJzcmMvbGliL3BlZGFsL1wiKSB8fFxuICAgICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcIi4vX2luc3RydWN0b3IvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFwiU3RlcHNcIiB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjb2RlLCBtZWFudCB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgdG8gdGhlIFNrdWxwdFxuICAgICAqIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdsb2JhbHMgLSBIYXNoIHRoYXQgbWFwcyB0aGUgbmFtZXMgb2YgZ2xvYmFsIHZhcmlhYmxlcyAoU3RyaW5ncykgdG8gdGhlaXIgU2t1bHB0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbHMgLSBIYXNoIHRoYXQgbWFwcyB0aGUgbmFtZXMgb2YgbG9jYWwgdmFyaWFibGVzIChTdHJpbmdzKSB0byB0aGVpciBTa3VscHQgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVOdW1iZXIgLSBUaGUgY29ycmVzcG9uZGluZyBsaW5lIG51bWJlciBpbiB0aGUgc291cmNlIGNvZGUgdGhhdCBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uTnVtYmVyIC0gVGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIG51bWJlciBpbiB0aGUgc291cmNlIGNvZGUgdGhhdCBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpbmsgb2YgaXQgYXMgdGhlIFwiWFwiIHBvc2l0aW9uIHRvIHRoZSBsaW5lTnVtYmVyJ3MgXCJZXCIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHB5dGhvbiBmaWxlIGJlaW5nIGV4ZWN1dGVkIChlLmcuLCBcIl9fbWFpbl9fLnB5XCIpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEb2NzdHJpbmcgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGFuIGFjdHVhbCBsaW5lIG9yIGEgZG9jc3RyaW5nLlxuICAgICAqL1xuICAgIHN0ZXAoZ2xvYmFscywgbG9jYWxzLCBsaW5lTnVtYmVyLCBjb2x1bW5OdW1iZXIsIGZpbGVuYW1lLCBpc0RvY3N0cmluZykge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RlcCA9IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwO1xuICAgICAgICAgICAgZ2xvYmFscyA9IHRoaXMubWFpbi5jb21wb25lbnRzLnRyYWNlLnBhcnNlR2xvYmFscyhnbG9iYWxzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRyYWNlIGxvY2FsIHZhcmlhYmxlcyBwcm9wZXJseVxuICAgICAgICAgICAgLy9sZXQgbG9jYWxzID0gdGhpcy5tYWluLmNvbXBvbmVudHMudHJhY2UucGFyc2VHbG9iYWxzKGxvY2Fscyk7XG4gICAgICAgICAgICAvL09iamVjdC5hc3NpZ24oZ2xvYmFscywgbG9jYWxzKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBcInN0ZXBcIjogY3VycmVudFN0ZXAsXG4gICAgICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAvLydibG9jayc6IGhpZ2hsaWdodE1hcFtsaW5lTnVtYmVyLTFdLFxuICAgICAgICAgICAgICAgIFwibGluZVwiOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIFwiY29sdW1uXCI6IGNvbHVtbk51bWJlcixcbiAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjogZ2xvYmFscy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIFwibW9kdWxlc1wiOiBnbG9iYWxzLm1vZHVsZXMsXG4gICAgICAgICAgICAgICAgXCJpc0RvY3N0cmluZ1wiOiBpc0RvY3N0cmluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCA9IGN1cnJlbnRTdGVwICsgMTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIFNrdWxwdCBleGVjdXRpb24gdG8gdGVybWluYXRlIHRoZSBleGVjdXRpb25CdWZmZXJcbiAgICAgKiBhbmQgaGFuZCBpdCBvZmYgdG8gdGhlIGV4ZWN1dGlvbiB0cmFjZSBpbiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgbGFzdFN0ZXAoKSB7XG4gICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50TGluZSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RMaW5lKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgfTtcblxuICAgIGdldExpbmVzKGFzdCkge1xuICAgICAgICBsZXQgdmlzaXRlZExpbmVzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgdmlzaXRCb2R5ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmxpbmVubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZExpbmVzLmFkZChub2RlLmxpbmVubyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ib2R5LmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUub3JlbHNlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5vcmVsc2UuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5maW5hbGJvZHkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmZpbmFsYm9keS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmlzaXRCb2R5KGFzdCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHZpc2l0ZWRMaW5lcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhlIHBhcnNlIGluZm9ybWF0aW9uIGlzIHVwLXRvLWRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVQYXJzZSgpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy8gSG9sZCBhbGwgdGhlIGFjdHVhbGx5IGRpc2NvdmVyZWQgbGluZXMgZnJvbSB0aGUgcGFyc2VcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIC8vIEF0dGVtcHQgYSBwYXJzZVxuICAgICAgICBsZXQgYXN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcnNlID0gU2sucGFyc2UodGhpcy5maWxlbmFtZSwgdGhpcy5jb2RlKTtcbiAgICAgICAgICAgIGFzdCA9IFNrLmFzdEZyb21QYXJzZShwYXJzZS5jc3QsIHRoaXMuZmlsZW5hbWUsIHBhcnNlLmZsYWdzKTtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy5nZXRMaW5lcyhhc3QpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmVwb3J0IHRoZSBlcnJvclxuICAgICAgICAgICAgcmVwb3J0W1wicGFyc2VyXCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwiZW1wdHlcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IGxpbmVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmZpbGVuYW1lLCB0aGlzLmNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1Y2Nlc3NmdWwgcGFyc2VcbiAgICAgICAgcmVwb3J0W1wicGFyc2VyXCJdID0ge1xuICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRydWUsXG4gICAgICAgICAgICBcImFzdFwiOiBhc3QsXG4gICAgICAgICAgICBcImVtcHR5XCI6IGFzdC5ib2R5Lmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIFwibGluZXNcIjogbGluZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2hvd0Vycm9ycygpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKHJlcG9ydFtcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2suY2xlYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRSdW5FcnJvcihyZXBvcnQuc3R1ZGVudC5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm92aWRlU2VjcmV0RXJyb3IoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmZWVkYmFjayA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrO1xuICAgICAgICBpZiAoIXJlcG9ydFtcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGVycm9yQnV0dG9uID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1zdHVkZW50LWVycm9yXCIpO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBmZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IsIHRydWUpO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uYXR0cihcInRpdGxlXCIsIFwiQ2xpY2sgdG8gc2VlIE9yaWdpbmFsIEVycm9yXCIpO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24udG9vbHRpcCh7XCJ0cmlnZ2VyXCI6IFwiaG92ZXJcIiwgXCJjb250YWluZXJcIjogdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYXR0YWNobWVudFBvaW50fSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5jbGljaygoKSA9PiB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfU0hPV19TVFVERU5UX0VSUk9SKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgbGV0IEZFRURCQUNLX0hUTUwgPSBgXG5cbjxzcGFuIGNsYXNzPSdibG9ja3B5LWZsb2F0aW5nLWZlZWRiYWNrIHRleHQtbXV0ZWQtbGVzcyBwdWxsLXJpZ2h0IHBvc2l0aW9uLXN0aWNreSBzdGlja3ktdG9wJ1xuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhcmlhLWxhYmVsPVwiTmV3IEZlZWRiYWNrIEFsZXJ0XCI+XG4gICAgTmV3IGZlZWRiYWNrICZ1YXJyO1xuPC9zcGFuPlxuXG48ZGl2IGNsYXNzPSdibG9ja3B5LWZlZWRiYWNrIGNvbC1tZC02IGJsb2NrcHktcGFuZWwnXG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkZlZWRiYWNrXCJcbiAgICAgICAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPlxuXG4gICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICBjbGFzcz0nYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgZmxvYXQtcmlnaHQnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuc2Vjb25kUm93LmFkdmFuY2VTdGF0ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZWNvbmRSb3cuc3dpdGNoTGFiZWxcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG4gICAgXG4gICAgPCEtLSBQb3NpdGl2ZSBGZWVkYmFjayBSZWdpb24gLS0+XG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stcG9zaXRpdmUgZmxvYXQtcmlnaHRcIj5cbiAgICAgICAgXG4gICAgXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEFjdHVhbCBGZWVkYmFjayBSZWdpb24gLS0+ICAgIFxuICAgIDxkaXY+XG4gICAgICAgIDxzdHJvbmc+RmVlZGJhY2s6IDwvc3Ryb25nPlxuICAgICAgICA8c3BhbiBjbGFzcz0nYmFkZ2UgYmxvY2tweS1mZWVkYmFjay1jYXRlZ29yeSBmZWVkYmFjay1iYWRnZSdcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczogdWkuZmVlZGJhY2suYmFkZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVpLmZlZWRiYWNrLmNhdGVnb3J5XCI+RmVlZGJhY2sgS2luZDwvc3Bhbj5cbiAgICAgICAgPHNtYWxsIGRhdGEtYmluZD1cInRleHQ6ICgxMDAqc3VibWlzc2lvbi5zY29yZSgpKSsnJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbCgpXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGV4dC1tdXRlZFwiPjwvc21hbGw+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZyBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stbGFiZWxcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidGV4dDogZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsXCI+PC9zdHJvbmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLW1lc3NhZ2VcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PiAgICAgICAgICAgIFxuYDtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlGZWVkYmFjayB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoZSBmZWVkYmFjayBhcmVhLCB3aGVyZSB1c2VycyBhcmUgdG9sZCB0aGUgc3RhdGUgb2YgdGhlaXJcbiAgICAgKiBwcm9ncmFtJ3MgZXhlY3V0aW9uIGFuZCBnaXZlbiBndWlkYW5jZS4gQWxzbyBtYW5hZ2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgVHJhY2UgVGFibGUuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdGhpcyB7QmxvY2tQeUZlZWRiYWNrfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrO1xuXG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnlcIik7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbGFiZWxcIik7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLnBvc2l0aXZlID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlXCIpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZXkgY2hhbmdlIHRoZSBzdHVkZW50IGV4dHJhIGZpbGVzLCBhbHNvIHVwZGF0ZSB0aGUgZGlydHkgZmxhZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24odHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgc2NyZWVuICh0YWtlcyAxIHNlY29uZCkgdG8gbWFrZSB0aGUgRmVlZGJhY2sgYXJlYSB2aXNpYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICAkKFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcub2Zmc2V0KCkudG9wXG4gICAgICAgIH0sIDEwMDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmZWVkYmFjayBhcmVhIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGZWVkYmFja1Zpc2libGUoKSB7XG4gICAgICAgIGxldCB2aXNpYmlsaXR5QnVmZmVyID0gMTAwO1xuICAgICAgICBsZXQgdG9wT2ZFbGVtZW50ID0gdGhpcy50YWcub2Zmc2V0KCkudG9wO1xuICAgICAgICAvL2xldCBib3R0b21PZkVsZW1lbnQgPSB0aGlzLnRhZy5vZmZzZXQoKS50b3AgKyB0aGlzLnRhZy5vdXRlckhlaWdodCgpO1xuICAgICAgICBsZXQgYm90dG9tT2ZFbGVtZW50ID0gdG9wT2ZFbGVtZW50ICsgdmlzaWJpbGl0eUJ1ZmZlcjtcbiAgICAgICAgbGV0IGJvdHRvbU9mU2NyZWVuID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICAgICBsZXQgdG9wT2ZTY3JlZW4gPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgIC8vYm90dG9tX29mX2VsZW1lbnQgLT0gNDA7IC8vIFVzZXIgZnJpZW5kbHkgcGFkZGluZ1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHRvcE9mRWxlbWVudCA8IGJvdHRvbU9mU2NyZWVuKSAmJlxuICAgICAgICAgICAgKHRvcE9mU2NyZWVuIDwgYm90dG9tT2ZFbGVtZW50KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgb3V0cHV0IGN1cnJlbnRseSBpbiB0aGUgZmVlZGJhY2sgYXJlYS4gQWxzbyByZXNldHMgdGhlIHByaW50ZXIgYW5kXG4gICAgICogYW55IGhpZ2hsaWdodGVkIGxpbmVzIGluIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKFwiKlJlYWR5KlwiKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobnVsbCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5oaWRkZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmNsZWFyUG9zaXRpdmVGZWVkYmFjaygpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZmluZEZpcnN0RXJyb3JMaW5lKGZlZWRiYWNrRGF0YSkge1xuICAgICAgICBpZiAoZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cCkge1xuICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJsb2NhdGlvblwiKSk7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGxvY2F0aW9uLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGluZVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKmZvciAobGV0IGkgPSBmZWVkYmFja0RhdGEubGVuZ3RoLTE7IGkgPj0gMDsgaS09IDEpIHtcbiAgICAgICAgICAgIGlmIChcInBvc2l0aW9uXCIgaW4gZmVlZGJhY2tEYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlZWRiYWNrRGF0YVtpXS5wb3NpdGlvbi5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsOyovXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3VsYXJGZWVkYmFjaygpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG1vZGVsIHdpdGggdGhlc2UgbmV3IGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICogQHBhcmFtIGV4ZWN1dGlvblJlc3VsdHNcbiAgICAgKi9cbiAgICB1cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIC8vIFBhcnNlIG91dCBkYXRhXG4gICAgICAgIGxldCBtZXNzYWdlID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLk1FU1NBR0UpO1xuICAgICAgICBsZXQgY2F0ZWdvcnkgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuQ0FURUdPUlkpO1xuICAgICAgICBsZXQgbGFiZWwgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuTEFCRUwpO1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5ISURFKTtcbiAgICAgICAgbGV0IGRhdGEgPSBleGVjdXRpb25SZXN1bHRzLkRBVEE7XG4gICAgICAgIGxldCBwb3NpdGl2ZXMgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuUE9TSVRJVkUpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIGJhc2VkIG9uIGFzc2lnbm1lbnRzJyBzZXR0aW5nc1xuICAgICAgICBsZXQgaGlkZVNjb3JlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCk7XG4gICAgICAgIGlmIChoaWRlU2NvcmUgJiYgY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBjYXRlZ29yeSA9IFwibm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBsYWJlbCA9IFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJObyBlcnJvcnMgcmVwb3J0ZWQuXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1hcCB0byBleHBlY3RlZCBCbG9ja1B5IGxhYmVsc1xuICAgICAgICBpZiAoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnN0cnVjdG9yXCIgJiYgbGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gXCJleHBsYWluXCIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCJJbnN0cnVjdG9yIEZlZWRiYWNrXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBwcmVzZW50IGEgbGFjayBvZiBlcnJvciBhcyBiZWluZyBpbmNvcnJlY3RcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGFjY29yZGluZ2x5XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1haW4udXRpbGl0aWVzLm1hcmtkb3duKG1lc3NhZ2UpLnJlcGxhY2UoLzxwcmU+XFxuL2csIFwiPHByZT5cXG5cXG5cIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICAvL2xldCBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5maW5kKFwicHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vfSwgNDAwKTtcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0cmFja2luZyBzdHVkZW50IGZpbGUsIGxldCdzIHRyYWNrIHRoZSBpbnN0cnVjdG9yIGZpbGVcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiSW50ZXJ2ZW50aW9uXCIsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgXCJhbnN3ZXIucHlcIik7XG5cbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBwcmV2aW91c2x5IGhpZ2hsaWdodGVkIGxpbmVzXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciBvbiBhIGxpbmUgYW5kIHJlcG9ydCB0aGF0XG4gICAgICAgIGxldCBsaW5lID0gQmxvY2tQeUZlZWRiYWNrLmZpbmRGaXJzdEVycm9yTGluZShkYXRhKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lICE9PSBudWxsICYmIGxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmVydCB0aGUgc2V0IG9mIHRyYWNlZCBsaW5lc1xuICAgICAgICBsZXQgc3R1ZGVudFJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChzdHVkZW50UmVwb3J0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCB1bmNvdmVyZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnBhcnNlci5saW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWRlbnRSZXBvcnQubGluZXMuaW5kZXhPZihsaW5lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jb3ZlcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZCh1bmNvdmVyZWRMaW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9zaXRpdmVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aXZlRGF0YSA9IHBvc2l0aXZlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zaXRpdmVGZWVkYmFjayhwb3NpdGl2ZURhdGEubWVzc2FnZSwgXCJzdGFyXCIsIFwiZ3JlZW5cIiwgKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwocG9zaXRpdmVEYXRhLnRpdGxlLCBwb3NpdGl2ZURhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJQb3NpdGl2ZUZlZWRiYWNrKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgYWRkUG9zaXRpdmVGZWVkYmFjayh0ZXh0LCBpY29uLCBjb2xvciwgb25jbGljaywgdG9FbmQpIHtcbiAgICAgICAgbGV0IHBvc2l0aXZlID0gJChcIjxzcGFuPjwvc3Bhbj5cIik7XG4gICAgICAgIHBvc2l0aXZlLmFkZENsYXNzKFwiYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZS1pY29uIGZhcyBmYS1cIitpY29uKTtcbiAgICAgICAgcG9zaXRpdmUuY3NzKFwiY29sb3JcIiwgY29sb3IpO1xuICAgICAgICBwb3NpdGl2ZS5hdHRyKFwidGl0bGVcIiwgdGV4dCk7XG4gICAgICAgIGlmICh0b0VuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5hcHBlbmQocG9zaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5wcmVwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGl2ZS50b29sdGlwKHtcInRyaWdnZXJcIjogXCJob3ZlclwiLCBcImNvbnRhaW5lclwiOiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnR9KTtcbiAgICAgICAgaWYgKG9uY2xpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpdmUuY2xpY2sob25jbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUuaG92ZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GZWVkYmFja1wiLCBcInBvc2l0aXZlXCIsIFwiaG92ZXJcIiwgdGV4dCwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgYW55IGFjY3VtdWxhdGVkIGZlZWRiYWNrXG4gICAgICovXG4gICAgcHJlc2VudEZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKTtcblxuICAgICAgICAvLyBUT0RPOiBMb2dnaW5nXG4gICAgICAgIC8vdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiZmVlZGJhY2tcIiwgY2F0ZWdvcnkrXCJ8XCIrbGFiZWwsIG1lc3NhZ2UpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5RmVlZGJhY2tVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgbm90aWZ5RmVlZGJhY2tVcGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZlZWRiYWNrVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmxvYXRpbmctZmVlZGJhY2tcIikuc2hvdygpLmZhZGVPdXQoNzAwMCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJlc2VudFJ1bkVycm9yKGVycm9yLCBqdXN0X3JldHVybikge1xuICAgICAgICBpZiAoanVzdF9yZXR1cm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganVzdF9yZXR1cm4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSwgbGFiZWwsIGNhdGVnb3J5LCBsaW5lbm87XG4gICAgICAgIGxhYmVsID0gZXJyb3IudHAkbmFtZTtcbiAgICAgICAgY2F0ZWdvcnkgPSBcInJ1bnRpbWVcIjtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuY29udmVydFNrdWxwdEVycm9yKGVycm9yKTtcblxuICAgICAgICBpZiAoanVzdF9yZXR1cm4pIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgaWYgKGxpbmVubyAhPT0gdW5kZWZpbmVkICYmIGxpbmVubyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lbm8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnVpbGRUcmFjZWJhY2soZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnRyYWNlYmFjay5tYXAoZnJhbWUgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmVubyA9IGZyYW1lLmxpbmVubztcbiAgICAgICAgICAgIGlmIChmcmFtZS5maWxlbmFtZS5zbGljZSgwLCAtMykgPT09IGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgICAgICAgICBsaW5lbm8gLT0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLmluc3RydWN0b3IubGluZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaWxlID0gYEZpbGUgPGNvZGUgY2xhc3M9XCJmaWxlbmFtZVwiPlwiJHtmcmFtZS5maWxlbmFtZX1cIjwvY29kZT4sIGA7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGBvbiBsaW5lIDxjb2RlIGNsYXNzPVwibGluZW5vXCI+JHtsaW5lbm99PC9jb2RlPiwgYDtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IChmcmFtZS5zY29wZSAhPT0gXCI8bW9kdWxlPlwiICYmXG4gICAgICAgICAgICBmcmFtZS5zY29wZSAhPT0gdW5kZWZpbmVkKSA/IGBpbiBzY29wZSAke2ZyYW1lLnNjb3BlfWAgOiBcIlwiO1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZnJhbWUuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBgXFxuPHByZT48Y29kZT4ke2ZyYW1lLnNvdXJjZX08L2NvZGU+PC9wcmU+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlICsgbGluZSArIHNjb3BlICsgc291cmNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb252ZXJ0U2t1bHB0RXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQsIGlzSW5zdHJ1Y3Rvcikge1xuICAgICAgICBsZXQgbmFtZSA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGxldCBhcmdzID0gU2suZmZpLnJlbWFwVG9KcyhlcnJvci5hcmdzKTtcbiAgICAgICAgbGV0IHRvcCA9IGAke25hbWV9OiAke2FyZ3NbMF19XFxuPGJyPlxcbjxicj5gO1xuICAgICAgICBsZXQgdHJhY2ViYWNrID0gXCJcIjtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnIgJiYgZXJyb3IuZXJyLnRyYWNlYmFjayAmJiBlcnJvci5lcnIudHJhY2ViYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEZyYW1lcyA9IHRoaXMuYnVpbGRUcmFjZWJhY2soZXJyb3IuZXJyLCBmaWxlbmFtZUV4ZWN1dGVkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXCJUcmFjZWJhY2s6XCJdO1xuICAgICAgICAgICAgICAgIGlmIChhbGxGcmFtZXMubGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5hbGxGcmFtZXMuc2xpY2UoMCwgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAuLi4gSGlkaW5nICR7YWxsRnJhbWVzLmxlbmd0aCAtIDN9IG90aGVyIHN0YWNrIGZyYW1lcyAuLi4sYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWxsRnJhbWVzLnNsaWNlKC0zLCAtMikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmFsbEZyYW1lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlYmFjayA9IHJlc3VsdC5qb2luKFwiXFxuPGJyPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0luc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBcIkVycm9yIGluIGluc3RydWN0b3IgZmVlZGJhY2suIFBsZWFzZSBzaG93IHRoZSBmb2xsb3dpbmcgdG8gYW4gaW5zdHJ1Y3Rvcjo8YnI+XFxuXCIrdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnRyYWNlYmFjayAmJiBlcnJvci50cmFjZWJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrID0gXCJUcmFjZWJhY2s6PGJyPlxcblwiICsgdGhpcy5idWlsZFRyYWNlYmFjayhlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCkuam9pbihcIlxcbjxicj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcCtcIlxcblwiK3RyYWNlYmFjaztcbiAgICB9XG5cbiAgICBwcmVzZW50SW50ZXJuYWxFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCkge1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeShcInJ1bnRpbWVcIik7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKFwiVGltZW91dCBFcnJvclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoXCJpbnRlcm5hbFwiKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGFiZWwoXCJJbnRlcm5hbCBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuY29udmVydFNrdWxwdEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5RmVlZGJhY2tVcGRhdGUoKTtcblxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLVN5c3RlbS5FcnJvclwiLCBcImludGVybmFsXCIsIFwiSW50ZXJuYWwgRXJyb3JcIiwgbWVzc2FnZSwgZmlsZW5hbWVFeGVjdXRlZCk7XG4gICAgfVxufSIsImltcG9ydCB7Zmlyc3REZWZpbmVkVmFsdWV9IGZyb20gXCJ1dGlsaXRpZXMuanNcIjtcblxuLy8gJHttYWtlVGFiKFwiP21vY2tfdXJscy5ibG9ja3B5XCIsIFwiVVJMIERhdGFcIiwgdHJ1ZSl9XG5cbmNvbnN0IG1ha2VUYWIgPSBmdW5jdGlvbihmaWxlbmFtZSwgZnJpZW5kbHlOYW1lLCBoaWRlSWZFbXB0eSwgbm90SW5zdHJ1Y3Rvcikge1xuICAgIGlmIChmcmllbmRseU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmcmllbmRseU5hbWUgPSBmaWxlbmFtZTtcbiAgICB9XG4gICAgbGV0IGluc3RydWN0b3JGaWxlQ2xhc3MgPSBcIlwiO1xuICAgIGxldCBoaWRlSWZOb3RJbnN0cnVjdG9yID0gXCJ0cnVlXCI7XG4gICAgaWYgKCFub3RJbnN0cnVjdG9yKSB7XG4gICAgICAgIGluc3RydWN0b3JGaWxlQ2xhc3MgPSBcImJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCI7XG4gICAgICAgIGhpZGVJZk5vdEluc3RydWN0b3IgPSBcImRpc3BsYXkuaW5zdHJ1Y3RvcigpXCI7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gJHtpbnN0cnVjdG9yRmlsZUNsYXNzfVwiPlxuICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBkaXNwbGF5LmZpbGVuYW1lKCkgPT09ICcke2ZpbGVuYW1lfSd9LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBkaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsICcke2ZpbGVuYW1lfScpLFxuICAgICAgICAgICAgICAgIHZpc2libGU6ICghJHtoaWRlSWZFbXB0eX0gfHwgdWkuZmlsZXMuaGFzQ29udGVudHMoJyR7ZmlsZW5hbWV9JykpICYmICR7aGlkZUlmTm90SW5zdHJ1Y3Rvcn1cIj5cbiAgICAgICAgICAgICR7ZnJpZW5kbHlOYW1lfTwvYT5cbiAgICA8L2xpPmA7XG59O1xuXG5leHBvcnQgbGV0IEZJTEVTX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1maWxlc1wiXG4gICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZmlsZXMudmlzaWJsZVwiPlxuPHVsIGNsYXNzPVwibmF2IG5hdi10YWJzXCIgcm9sZT1cInRhYmxpc3RcIj5cblxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgIDxzdHJvbmc+VmlldzogPC9zdHJvbmc+XG4gICAgPC9saT5cblxuICAgICR7bWFrZVRhYihcImFuc3dlci5weVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIkluc3RydWN0aW9uc1wiKX1cbiAgICAke21ha2VUYWIoXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIsIFwiU2V0dGluZ3NcIil9XG4gICAgJHttYWtlVGFiKFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCJTdGFydGluZyBDb2RlXCIpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ydW4ucHlcIiwgXCJPbiBSdW5cIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX2NoYW5nZS5weVwiLCBcIk9uIENoYW5nZVwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhb25fZXZhbC5weVwiLCBcIk9uIEV2YWxcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsIFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiF0YWdzLmJsb2NrcHlcIiwgXCJUYWdzXCIsIHRydWUpfVxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7J2Jsb2NrcHktZmlsZS1pbnN0cnVjdG9yJzogIWZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJykgfHwgJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKCkgXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZWRpdGFibGU6IGZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAkcm9vdC51aS5maWxlcy5kaXNwbGF5RmlsZW5hbWUoZmlsZW5hbWUoKSlcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6ICRyb290LmRpc3BsYXkuaW5zdHJ1Y3RvcigpXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmlsZW5hbWVcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogc3VibWlzc2lvbi5leHRyYUZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKCl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gIFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGRyb3Bkb3duXCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCIgaHJlZj1cIiNcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgIHJvbGU9XCJidXR0b25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPkFkZCBOZXc8L2E+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/bW9ja191cmxzLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz9tb2NrX3VybHMuYmxvY2tweScpXCI+VVJMIERhdGE8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnP2ltYWdlcy5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/aW1hZ2VzLmJsb2NrcHknKVwiPkltYWdlczwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/dG9vbGJveC5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/dG9vbGJveC5ibG9ja3B5JylcIj5Ub29sYm94PC9hPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIXRhZ3MuYmxvY2tweScpXCI+VGFnczwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpXCI+U2FtcGxlIFN1Ym1pc3Npb25zPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchb25fY2hhbmdlLnB5JylcIj5PbiBDaGFuZ2U8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiBhc3NpZ25tZW50Lm9uRXZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9ldmFsLnB5JylcIj5PbiBFdmFsPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFhbnN3ZXJfcHJlZml4LnB5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchYW5zd2VyX3ByZWZpeC5weScpXCI+QW5zd2VyIFByZWZpeDwvYT5cbiAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFhbnN3ZXJfc3VmZml4LnB5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchYW5zd2VyX3N1ZmZpeC5weScpXCI+QW5zd2VyIFN1ZmZpeDwvYT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1kaXZpZGVyXCI+PC9kaXY+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3RhcnRpbmcnKVwiPlN0YXJ0aW5nIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnaW5zdHJ1Y3RvcicpXCI+SW5zdHJ1Y3RvciBGaWxlPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJ3N0dWRlbnQnKVwiPlN0dWRlbnQgRmlsZTwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9saT5cbiAgXG48L3VsPlxuPC9kaXY+XG5gO1xuXG5jb25zdCBORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MID0gYFxuPGZvcm0+XG48ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICA8IS0tIEZpbGVuYW1lIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj5GaWxlbmFtZTo8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCI+ICAgIFxuICAgIDwvZGl2PlxuICAgIDwhLS0gRmlsZXR5cGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHQgbXQtMlwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+RmlsZXR5cGU6IDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiXG4gICAgICAgICAgICBpZD1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiPjwvc3Bhbj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBJbmFjY2Vzc2libGUgdG8gc3R1ZGVudD8gLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHQgbXQtMlwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiPk5hbWVzcGFjZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTRcIj5cbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiFcIj5Db21wbGV0ZWx5IGluYWNjZXNzaWJsZTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIj9cIj5IaWRkZW4gZnJvbSBzdHVkZW50LCBhY2Nlc3NpYmxlIHByb2dyYW1hdGljYWxseTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiZcIj5WaXNpYmxlIHRvIHN0dWRlbnQsIGJ1dCBub3QgZWRpdGFibGU8L29wdGlvbj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjwvZm9ybT5cbmA7XG5cbi8qKlxuICogRmlsZW5hbWVzIGxpdmUgaW4gb25lIG9mIGZpdmUgcG9zc2libGUgbmFtZXNwYWNlczpcbiAqICBJbnN0cnVjdG9yICghKTogSW52aXNpYmxlIHRvIHRoZSBzdHVkZW50IHVuZGVyIGFsbCBjaXJjdW1zdGFuY2VzXG4gKiAgU3RhcnQgU3BhY2UgKF4pOiBVc2VkIHRvIHJlc2V0IHRoZSBzdHVkZW50IG5hbWVzcGFjZVxuICogIFN0dWRlbnQgU3BhY2UgKCk6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQgd2hlbiBkaXNwbGF5LmhpZGVGaWxlcyBpcyBub3QgdHJ1ZSwgYWJsZSB0byBiZSBlZGl0ZWRcbiAqICBIaWRkZW4gU3BhY2UgKD8pOiBOb3QgZGlyZWN0bHkgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGFjY2Vzc2libGUgcHJvZ3JhbW1hdGljYWxseVxuICogIFJlYWQtb25seSBTcGFjZSAoJik6IEFuIGluc3RydWN0b3IgZmlsZSB0eXBlIHZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBpcyB1bmVkaXRhYmxlIGJ5IHRoZW1cbiAqICBTZWNyZXQgU3BhY2UgKCQpOiBOb3QgdmlzaWJsZSBmcm9tIHRoZSBtZW51IGF0IGFsbCwgc29tZSBvdGhlciBtZWNoYW5pc20gY29udHJvbHMgaXRcbiAqICBHZW5lcmF0ZWQgU3BhY2UgKCopOiBWaXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgZGVzdHJveWVkIGFmdGVyIEVuZ2luZS5DbGVhci4gQ2FuIHNoYWRvdyBhbiBhY3R1YWwgZmlsZS5cbiAqICBDb25jYXRlbmF0ZWQgU3BhY2UgKCMpOiBVc2VkIHdoZW4gYnVuZGxpbmcgYSBzcGFjZSBmb3IgdGhlIHNlcnZlci5cbiAqL1xuXG5leHBvcnQgbGV0IFNUQVJUSU5HX0ZJTEVTID0gW1xuICAgIC8vIFN1Ym1pc3Npb25cbiAgICBcImFuc3dlci5weVwiLFxuICAgIC8vIEluc3RydWN0b3IgZmlsZXNcbiAgICBcIiFpbnN0cnVjdGlvbnMubWRcIixcbiAgICBcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIixcbiAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsXG4gICAgXCIhb25fcnVuLnB5XCIsXG4gICAgXCIkc2V0dGluZ3MuYmxvY2tweVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IEJBU0lDX05FV19GSUxFUyA9IFtcbiAgICBcIiFvbl9jaGFuZ2UucHlcIixcbiAgICBcIiFvbl9ldmFsLnB5XCIsXG4gICAgXCI/bW9ja191cmxzLmJsb2NrcHlcIixcbiAgICBcIj90b29sYm94LmJsb2NrcHlcIixcbiAgICBcIiF0YWdzLmJsb2NrcHlcIixcbiAgICBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiLFxuICAgIFwiIWFuc3dlcl9wcmVmaXgucHlcIixcbiAgICBcIiFhbnN3ZXJfc3VmZml4LnB5XCJcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBjaG9tcFNwZWNpYWxGaWxlKGZpbGVuYW1lKSB7XG4gICAgaWYgKFwiIV4/JiQqI1wiLmluY2x1ZGVzKGZpbGVuYW1lWzBdKSkge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbn1cblxuY29uc3QgSU5TVFJVQ1RPUl9ESVJFQ1RPUlkgPSBcIl9pbnN0cnVjdG9yL1wiO1xuY29uc3QgU1RVREVOVF9ESVJFQ1RPUlkgPSBcIl9zdHVkZW50L1wiO1xuXG5jb25zdCBTZWFyY2hNb2RlcyA9IHtcbiAgICBFVkVSWVdIRVJFOiBcIkVWRVJZV0hFUkVcIixcbiAgICBTVEFSVF9XSVRIX0lOU1RSVUNUT1I6IFwiU1RBUlRfV0lUSF9JTlNUUlVDVE9SXCIsXG4gICAgT05MWV9TVFVERU5UX0ZJTEVTOiBcIk9OTFlfU1RVREVOVF9GSUxFU1wiXG59O1xuXG5jb25zdCBERUxFVEFCTEVfU0lNUExFX0ZJTEVTID0gW1wiIW9uX2NoYW5nZS5weVwiLCBcIiFvbl9ldmFsLnB5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5ERUxFVEFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5SRU5BTUFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhb25fY2hhbmdlLnB5XCIsIFwiIW9uX2V2YWwucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIj90b29sYm94LmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiF0YWdzLmJsb2NrcHlcIiwgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFhbnN3ZXJfcHJlZml4LnB5XCIsIFwiIWFuc3dlcl9zdWZmaXgucHlcIl07XG5cbmNsYXNzIEJsb2NrUHlGaWxlIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29udGVudHMgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5vd25lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgIHJldHVybiB7XCJmaWxlbmFtZVwiOiBrby5vYnNlcnZhYmxlKGZpbGVuYW1lKSwgY29udGVudHM6IGtvLm9ic2VydmFibGUoY29udGVudHMgfHwgXCJcIil9O1xufVxuXG5mdW5jdGlvbiBtYWtlTW9ja01vZGVsRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICByZXR1cm4geyBmaWxlbmFtZTogKCkgPT4gZmlsZW5hbWUsIGNvbnRlbnRzOiAoKSA9PiBjb250ZW50cyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZENvbmNhdGVuYXRlZEZpbGUoY29uY2F0ZW5hdGVkRmlsZSwgbW9kZWxGaWxlTGlzdCkge1xuICAgIGlmIChjb25jYXRlbmF0ZWRGaWxlKSB7XG4gICAgICAgIGxldCBmaWxlcyA9IEpTT04ucGFyc2UoY29uY2F0ZW5hdGVkRmlsZSk7XG4gICAgICAgIGxldCBtb2RlbEZpbGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxGaWxlcy5wdXNoKG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGZpbGVzW2ZpbGVuYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZmlsZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUsIGZpbGUuY29udGVudHMpKTtcbiAgICAgICAgaWYgKG1vZGVsRmlsZUxpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsZUxpc3QobW9kZWxGaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxGaWxlcztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbEZpbGVMaXN0KSB7XG4gICAgICAgICAgICBtb2RlbEZpbGVMaXN0KFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWxGaWxlTGlzdCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtb2RlbEZpbGVMaXN0KCkubWFwKGZpbGUgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUuZmlsZW5hbWUoKSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBmaWxlLmNvbnRlbnRzKClcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbW9kZWxGaWxlTGlzdCgpLmZvckVhY2goZmlsZSA9PlxuICAgICAgICAgICAgcmVzdWx0W2ZpbGUuZmlsZW5hbWUoKV0gPSBmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBkYXRhYmFzZSBsb2dpY1xuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUZpbGVTeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlc18gPSB7fTtcbiAgICAgICAgdGhpcy5tb3VudEZpbGVzKCk7XG5cbiAgICAgICAgdGhpcy53YXRjaE1vZGVsKCk7XG4gICAgICAgIHRoaXMud2F0Y2hlc18gPSB7fTtcblxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yLnN1YnNjcmliZSgodmlzaWJsaXR5KT0+IHtcbiAgICAgICAgICAgICQoXCIuYmxvY2tweS1maWxlLWluc3RydWN0b3JcIikudG9nZ2xlKHZpc2libGl0eSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHdhdGNoRmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCEoZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgc3RvcFdhdGNoaW5nRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV07XG4gICAgfVxuXG4gICAgd2F0Y2hNb2RlbCgpIHtcbiAgICAgICAgbGV0IGZpbGVzeXN0ZW0gPSB0aGlzO1xuICAgICAgICBbdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyxcbiAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyxcbiAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzXS5mb3JFYWNoKGZpbGVBcnJheSA9PlxuICAgICAgICAgICAgZmlsZUFycmF5LnN1YnNjcmliZShmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiBzZWNvbmQuc3RhdHVzLmxvY2FsZUNvbXBhcmUoZmlyc3Quc3RhdHVzKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsRmlsZSA9IGNoYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayBuZXcgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXN5c3RlbS5uZXdGaWxlKG1vZGVsRmlsZS5maWxlbmFtZSgpLCBtb2RlbEZpbGUuY29udGVudHMoKSwgbW9kZWxGaWxlLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc3lzdGVtLm5vdGlmeVdhdGNoZXMoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5zdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzeXN0ZW0uZGVsZXRlRmlsZUxvY2FsbHlfKG1vZGVsRmlsZS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gbW9kZWxGaWxlLmZpbGVuYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMsIFwiYXJyYXlDaGFuZ2VcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhbnN3ZXIucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBmaXJzdCBlbGVtZW50IG9mIHN1Ym1pc3Npb24uY29kZSlcbiAgICAvLyAhb25fcnVuLnB5LCAhb25fY2hhbmdlLnB5LCAhb25fZXZhbC5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlbGV2YW50IGFzc2lnbm1lbnQuPHdoYXRldmVyPlxuICAgIC8vIF5zdGFydGluZ19jb2RlLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZmlyc3QgZWxlbWVudCBvZiBhc3NpZ25tZW50LnN0YXJ0aW5nQ29kZVxuICAgIC8vIF53aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlXG4gICAgLy8gIXdoYXRldmVyIG9yID93aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuZXh0cmFGaWxlc1xuICAgIC8vIE90aGVyd2lzZTpcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZXN0IG9mIHRoZSBlbGVtZW50cyBvZiBzdWJtaXNzaW9uLmNvZGVcbiAgICAvKipcbiAgICAgKiBOZXcgc3BlY2lhbCBmaWxlcyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgaGVyZVxuICAgICAqIEBwYXJhbSBmaWxlIHtCbG9ja1B5RmlsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ic2VydmVGaWxlXyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fcnVuLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW47XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fY2hhbmdlLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fZXZhbC5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbDtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFpbnN0cnVjdGlvbnMubWRcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCJec3RhcnRpbmdfY29kZS5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiF0YWdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50YWdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIkc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5O1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIl5cIikpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiIVwiKSB8fFxuICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIj9cIikgfHxcbiAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9ic2VydmVJbkFycmF5XyhmaWxlLCBhcnJheSkge1xuICAgICAgICBmaWxlLm93bmVyID0gYXJyYXk7XG4gICAgICAgIGxldCBjb2RlQnVuZGxlID0gZmlsZS5vd25lcigpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjb2RlQnVuZGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUJ1bmRsZVtpXS5maWxlbmFtZSgpID09PSBmaWxlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBjb2RlQnVuZGxlW2ldLmNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLmhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IG5ld0ZpbGUgPSBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBuZXdGaWxlLmNvbnRlbnRzO1xuICAgICAgICAgICAgYXJyYXkucHVzaChuZXdGaWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdW50RmlsZXMoKSB7XG4gICAgICAgIHRoaXMubmV3RmlsZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiXnN0YXJ0aW5nX2NvZGUucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFvbl9ydW4ucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIik7XG4gICAgfVxuXG4gICAgZGlzbW91bnRFeHRyYUZpbGVzKCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZmlsZXNfKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWxlc18uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoVU5ERUxFVEFCTEVfRklMRVMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNfW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53YXRjaGVzX1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VibWlzc2lvbi5jb2RlVE9ETzogU2hvdWxkbid0IHdlIG5vdGlmeSB0aGUgVUkgdGhhdCB0aGUgZmlsZSB3YXMgZGVsZXRlZD9cbiAgICB9XG5cbiAgICBuZXdGaWxlKGZpbGVuYW1lLCBjb250ZW50cywgbW9kZWxGaWxlKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzXykge1xuICAgICAgICAgICAgLy8gRmlsZSBhbHJlYWR5IGV4aXN0cyEgSnVzdCB1cGRhdGUgaXRzIGhhbmRsZVxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nRmlsZSA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIGlmIChtb2RlbEZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbGVfKGV4aXN0aW5nRmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nRmlsZS5oYW5kbGUgPSBtb2RlbEZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGlzdGluZ0ZpbGUuaGFuZGxlKGNvbnRlbnRzIHx8IFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgICAgIGxldCBuZXdGaWxlID0gbmV3IEJsb2NrUHlGaWxlKHRoaXMubWFpbiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgdGhpcy5maWxlc19bZmlsZW5hbWVdID0gbmV3RmlsZTtcbiAgICAgICAgICAgIGlmIChtb2RlbEZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbGVfKG5ld0ZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlLmhhbmRsZSA9IG1vZGVsRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZS5oYW5kbGUoY29udGVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgICAgIGNvbnRlbnRzID0gY29udGVudHMgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5maWxlc19bZmlsZW5hbWVdLmhhbmRsZShjb250ZW50cyk7XG4gICAgfVxuXG4gICAgcmVhZEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5oYW5kbGUoKTtcbiAgICB9XG5cbiAgICBnZXRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxvYmplY3R9IFRoZSBpbmZvIGFib3V0IHRoZSBmaWxlLCBvciBmYWxzZSBpZiBpdCBjb3VsZCBub3QgYmUgZGVsZXRlZFxuICAgICAqL1xuICAgIGRlbGV0ZUZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKERFTEVUQUJMRV9TSU1QTEVfRklMRVMuaW5kZXhPZihmaWxlbmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZGVsZXRlRmlsZUxvY2FsbHlfKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrIHRvIGV2ZW50dWFsbHkgY2FsbCBkZWxldGVGaWxlTG9jYWxseV9cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lci5yZW1vdmUobW9kZWxGaWxlID0+IG1vZGVsRmlsZS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmRlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgcmVuYW1lRmlsZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmIChVTlJFTkFNQUJMRV9GSUxFUy5pbmRleE9mKHNvdXJjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrIHRvIGV2ZW50dWFsbHkgY2FsbCBkZWxldGVGaWxlTG9jYWxseV9cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lci5yZW1vdmUobW9kZWxGaWxlID0+IG1vZGVsRmlsZS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub3RpZnlXYXRjaGVzKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlLmZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLnVwZGF0ZWQoZmlsZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yRmlsZShuYW1lLCBzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IFRoaXMgaXMgY2FsbGVkIHF1aXRlIGEgYml0IGJ5IHRoZSBJbXBvcnQgbWVjaGFuaXNtLCBtaWdodCBuZWVkXG4gICAgICAgICAgICAgIHRvIG9wdGltaXplIGl0IHNvbWUgbW9yZS4gRG8gdGltaW5nIHRlc3RzLlxuXG4gICAgICAgIGZpbGVzLipcbiAgICAgICAgX2luc3RydWN0b3IvZmlsZXMuKlxuICAgICAgICBfc3R1ZGVudC9maWxlcy4qXG5cbiAgICAgICAgSWYgYSBzdHVkZW50IHNlYXJjaGVzIGZvciBhIGZpbGUsIGl0IGNoZWNrcyB0aGUgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBpbXBvcnQgaGVscGVyID0+IFwiLi9oZWxwZXIucHlcIlxuICAgICAgICAgICAgb3BlbihcImV4dGVybmFsLmpzb25cIikgPT4gXCJleHRlcm5hbC5qc29uXCJcbiAgICAgICAgSWYgYW4gaW5zdHJ1Y3RvciBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgXCIhXCIsIFwiXlwiLCBcIj9cIiwgXCImXCIsIFwiKlwiLCBcIlwiIG5hbWVzcGFjZXNcbiAgICAgICAgICAgIFRvIGV4cGxpY2l0bHkgc2VhcmNoIGluc3RydWN0b3IgbmFtZXNwYWNlcyBmaXJzdFxuICAgICAgICAgICAgICAgIGltcG9ydCBfaW5zdHJ1Y3Rvci5oZWxwZXIgPT4gXCIuL2luc3RydWN0b3IvaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiX2luc3RydWN0b3IvZXh0ZXJuYWwuanNvblwiKSA9PiBcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gYWxsb3cgc3R1ZGVudCBmaWxlcyB0byBvdmVycmlkZTpcbiAgICAgICAgICAgICAgICBpbXBvcnQgaGVscGVyID0+IFwiLi9oZWxwZXIucHlcIlxuICAgICAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgICAgICB0byBvbmx5IGNoZWNrIHN0dWRlbnQgZmlsZXMsIHByZXBlbmQgd2l0aCBfc3R1ZGVudFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQ2hvcCBvZmYgc3RhcnRpbmcgXCIuL1wiXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5FVkVSWVdIRVJFO1xuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBzdGFydCB3aXRoIGluc3RydWN0b3Igc2lkZT9cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChJTlNUUlVDVE9SX0RJUkVDVE9SWSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKElOU1RSVUNUT1JfRElSRUNUT1JZLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuU1RBUlRfV0lUSF9JTlNUUlVDVE9SO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCB0aGUgc2VhcmNoIGJlIGxpbWl0ZWQgdG8gdGhlIHN0dWRlbnQgbW9kZT9cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChTVFVERU5UX0RJUkVDVE9SWSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKFNUVURFTlRfRElSRUNUT1JZLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9IGVsc2UgaWYgKHN0dWRlbnRTZWFyY2gpIHtcbiAgICAgICAgICAgIHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5PTkxZX1NUVURFTlRfRklMRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGluc3RydWN0b3IgdmVyc2lvbnNcbiAgICAgICAgbGV0IGV4dHJhU3R1ZGVudEZpbGVzID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgZXh0cmFJbnN0cnVjdG9yRmlsZXMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpO1xuICAgICAgICBsZXQgZXh0cmFTdGFydGluZ0ZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKCk7XG4gICAgICAgIC8vIENoZWNrIHNwZWNpYWwgZmlsZXMgKFRPRE86IGhvdyB3b3VsZCBhbiBpbnN0cnVjdG9yIGFjY2VzcyBcIi4vX2luc3RydWN0b3IvYW5zd2VyLnB5XCI/XG4gICAgICAgIGxldCBzcGVjaWFsRmlsZSA9IHRoaXMuc2VhcmNoRm9yU3BlY2lhbEZpbGVzXyhuYW1lLCBzZWFyY2hNb2RlKTtcbiAgICAgICAgaWYgKHNwZWNpYWxGaWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFsRmlsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydCBsb29raW5nIHRocm91Z2ggcG9zc2libGUgZmlsZXNcbiAgICAgICAgbGV0IHN0dWRlbnRWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYVN0dWRlbnRGaWxlcywgbmFtZSk7XG4gICAgICAgIGxldCBnZW5lcmF0ZWRWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYVN0dWRlbnRGaWxlcywgXCIqXCIrbmFtZSk7XG4gICAgICAgIGxldCBkZWZhdWx0VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiJlwiK25hbWUpO1xuICAgICAgICBsZXQgaGlkZGVuVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiP1wiK25hbWUpO1xuICAgICAgICBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3REZWZpbmVkVmFsdWUoaGlkZGVuVmVyc2lvbiwgZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zdHJ1Y3RvclZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiFcIituYW1lKTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdGFydGluZ0ZpbGVzLCBcIl5cIituYW1lKTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUikge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGluc3RydWN0b3JWZXJzaW9uLCBoaWRkZW5WZXJzaW9uLCBzdGFydGluZ1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5FVkVSWVdIRVJFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3REZWZpbmVkVmFsdWUoZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0b3JWZXJzaW9uLCBoaWRkZW5WZXJzaW9uLCBzdGFydGluZ1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yRmlsZUluTGlzdF8obW9kZWxMaXN0LCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2RlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtb2RlbExpc3RbaV0uZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yU3BlY2lhbEZpbGVzXyhmaWxlbmFtZSwgc2VhcmNoTW9kZSkge1xuICAgICAgICBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTKSB7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImFuc3dlci5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL2Fuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX3J1bi5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL29uX3J1bi5weVwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9jaGFuZ2UucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9jaGFuZ2UucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL29uX2V2YWwubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkpO1xuICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9ucy5tZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL2luc3RydWN0aW9ucy5tZFwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKSk7XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRpbmdfY29kZS5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL3N0YXJ0aW5nX2NvZGUucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbmV3RmlsZURpYWxvZyhraW5kKSB7XG4gICAgICAgIGxldCBib2R5ID0gJChORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MKTtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gYm9keS5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiKTtcbiAgICAgICAgbGV0IGZpbGV0eXBlID0gYm9keS5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiKTtcbiAgICAgICAgbGV0IG5hbWVzcGFjZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCIpO1xuICAgICAgICBsZXQgZXh0ZW5zaW9uUmVnZXggPSAvKD86XFwuKFteLl0rKSk/JC87XG4gICAgICAgIGZpbGVuYW1lLm9uKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuc2lvblJlZ2V4LmV4ZWMoZmlsZW5hbWUudmFsKCkpWzFdO1xuICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uID09PSB1bmRlZmluZWQgPyBcIk5vIGV4dGVuc2lvblwiIDogZXh0ZW5zaW9uO1xuICAgICAgICAgICAgLy9UT0RPOiB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmdldEVkaXRvckZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGZpbGV0eXBlLnRleHQoZXh0ZW5zaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB5ZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImluc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IG5hbWVzcGFjZS52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJzdGFydGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJeXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWxlbmFtZS52YWwoKSkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcHJlZml4K2ZpbGVuYW1lLnZhbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV3RmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJvZHkuc3VibWl0KChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB5ZXMoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLmNvbmZpcm0oXCJNYWtlIE5ldyBGaWxlXCIsIGJvZHksIHllcywgKCk9Pnt9LCBcIkFkZFwiKTtcbiAgICB9XG59IiwiLy9UT0RPOiBNb3ZlIGdldCBsaW5rIGRvd24gdG8gZm9vdGVyLCByZW1vdmUgdmVydGljYWwgYmFyIGZyb20gcXVpY2stbWVudVxuZXhwb3J0IGxldCBGT09URVJfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJjb2wtbWQtMTIgYmxvY2tweS1wYW5lbCBibG9ja3B5LXN0YXR1c1wiPlxuICAgIDxkaXY+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvYWRBc3NpZ25tZW50JylcIj5Mb2FkIEFzc2lnbm1lbnRcbiAgICAgICAgICAgIDwhLS0ga28gaWY6IGRpc3BsYXkuaW5zdHJ1Y3RvciAtLT5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICBjbGFzcz1cImJsb2NrcHktZm9yY2UtbG9hZC1hc3NpZ25tZW50LWZpbGUgYmxvY2tweS1oaWRkZW4tZmlsZVwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJhcHBsaWNhdGlvbi9KU09OXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImV2ZW50OiB7Y2hhbmdlOiB1aS5zZXJ2ZXIuZm9yY2UubG9hZEFzc2lnbm1lbnR9XCI+XG4gICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgPC9sYWJlbD4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVBc3NpZ25tZW50JylcIj5TYXZlIEFzc2lnbm1lbnQ8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRmlsZScpXCI+TG9hZCBGaWxlPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnc2F2ZUZpbGUnKVwiPlNhdmUgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvYWREYXRhc2V0JylcIj5Mb2FkIERhdGFzZXQ8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2dFdmVudCcpXCI+TG9nIEV2ZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygndXBkYXRlU3VibWlzc2lvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5zZXJ2ZXIuZm9yY2UudXBkYXRlU3VibWlzc2lvblwiPlVwZGF0ZSBTdWJtaXNzaW9uPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnb25FeGVjdXRpb24nKVwiPkV4ZWN1dGlvbjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLnNlcnZlci5tZXNzYWdlc1wiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2PlxuICAgICAgICA8c3Bhbj5Vc2VyOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmlkXCI+PC9zcGFuPiAoPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5uYW1lXCI+PC9zcGFuPiwgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5yb2xlXCI+PC9zcGFuPik8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+Q291cnNlOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmNvdXJzZUlkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkdyb3VwOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmdyb3VwSWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogYXNzaWdubWVudC5pZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Bc3NpZ25tZW50IFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQudmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5TdWJtaXNzaW9uOiBcbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24uaWRcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJpZjogc3VibWlzc2lvbi5vd25lcklkKCkgIT0gdXNlci5pZCgpXCI+XG4gICAgICAgICAgICAgICAgKE93bmVyIElEOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLm93bmVySWQoKVwiPjwvc3Bhbj4pXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj4sIFxuICAgICAgICA8c3Bhbj5TdWJtaXNzaW9uIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24udmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5FZGl0b3IgVmVyc2lvbjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogZGlzcGxheS5lZGl0b3JWZXJzaW9uXCI+PC9zcGFuPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDsiLCIvLyBUT0RPOiBTaG91bGQgZGlzYWJsZSBidXR0b25zIGlmIHdlIGNhbid0IGFjdGl2YXRlIHRoZW0uXG5cbmV4cG9ydCBjb25zdCBISVNUT1JZX1RPT0xCQVJfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJibG9ja3B5LWhpc3RvcnktdG9vbGJhciBjb2wtbWQtMTJcIiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBkaXNwbGF5Lmhpc3RvcnlNb2RlXCI+XG5cbiAgICA8Zm9ybSBjbGFzcz1cImZvcm0taW5saW5lXCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc3RhcnQgYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5zdGFydFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWJhY2t3YXJkJz48L3NwYW4+IFN0YXJ0XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5wcmV2aW91c1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1iYWNrd2FyZCc+PC9zcGFuPiBQcmV2aW91c1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cImJsb2NrcHktaGlzdG9yeS1zZWxlY3RvciBmb3JtLWNvbnRyb2wgY3VzdG9tLXNlbGVjdCBtci0yXCIgYXJpYS10aXRsZT1cIkhpc3RvcnkgU2VsZWN0b3JcIj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5LnVzZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1maWxlLWltcG9ydCc+PC9zcGFuPiBVc2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm5leHRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZm9yd2FyZCc+PC9zcGFuPiBOZXh0XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkubW9zdFJlY2VudFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWZvcndhcmQnPjwvc3Bhbj4gTW9zdCBSZWNlbnRcbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9mb3JtPlxuPC9kaXY+XG5gO1xuXG4vKipcbiAqIEFuIG9iamVjdCBmb3IgZGlzcGxheWluZyB0aGUgdXNlcidzIGNvZGluZyBsb2dzICh0aGVpciBoaXN0b3J5KS5cbiAqIEEgbGlnaHR3ZWlnaHQgY29tcG9uZW50LCBpdHMgb25seSBqb2IgaXMgdG8gb3BlbiBhIGRpYWxvZy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5SGlzdG9yeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUhpc3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5lZGl0RXZlbnRzID0gW107XG4gICAgfVxuXG4gICAgbG9hZChoaXN0b3J5KSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJChcIi5ibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3JcIikuZW1wdHkoKTtcbiAgICAgICAgbGV0IGVkaXRJZCA9IDA7XG4gICAgICAgIGhpc3RvcnlcbiAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiAoXG4gICAgICAgICAgICAgICAgIWVudHJ5LmZpbGVfcGF0aC5zdGFydHNXaXRoKFwiX2luc3RydWN0b3IuXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiQ29tcGlsZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiSW50ZXJ2ZW50aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSB8fCBlbnRyeS5ldmVudF90eXBlICE9PSBcIlgtU3VibWlzc2lvbi5MTVNcIilcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50X3R5cGUgPSBSRU1BUF9FVkVOVF9UWVBFU1tlbnRyeS5ldmVudF90eXBlXSB8fCBlbnRyeS5ldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5ZWQgPSBwcmV0dHlQcmludERhdGVUaW1lKGVudHJ5LmNsaWVudF90aW1lc3RhbXApICtcIiAtIFwiK2V2ZW50X3R5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRpc2FibGUgPSAoZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJGaWxlLkVkaXRcIik7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9ICQoXCI8b3B0aW9uPjwvb3B0aW9uPlwiLCB7dGV4dDogZGlzcGxheWVkLCBkaXNhYmxlZDogZGlzYWJsZX0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRWRpdEV2ZW50KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uYXR0cihcInZhbHVlXCIsIGVkaXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdEV2ZW50cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdElkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuYXBwZW5kKG9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5tYXgoMCwgZWRpdElkLTEpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5jaGFuZ2UoKGV2dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW92ZVRvU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKDApO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIG1vdmVQcmV2aW91cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5tYXgoMCwgY3VycmVudElkLTEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlTmV4dCgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5taW4odGhpcy5lZGl0RXZlbnRzLmxlbmd0aC0xLCBjdXJyZW50SWQrMSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIG1vdmVUb01vc3RSZWNlbnQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0RXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5zZXRDb2RlKHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0RXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5lZGl0RXZlbnRzW2N1cnJlbnRJZF0ubWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5maWxlLmhhbmRsZShjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRWRpdEV2ZW50KGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoKGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5FZGl0XCIgfHxcbiAgICAgICAgICAgICAgICAgZW50cnkuZXZlbnRfdHlwZSA9PT0gXCJGaWxlLkNyZWF0ZVwiKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGVudHJ5LmZpbGVfcGF0aCk7XG4gICAgfVxuXG59XG5cbmNvbnN0IFJFTUFQX0VWRU5UX1RZUEVTID0ge1xuICAgIFwiU2Vzc2lvbi5TdGFydFwiOiBcIkJlZ2FuIHNlc3Npb25cIixcbiAgICBcIlgtSVAuQ2hhbmdlXCI6IFwiQ2hhbmdlZCBJUCBhZGRyZXNzXCIsXG4gICAgXCJGaWxlLkVkaXRcIjogXCJFZGl0ZWQgY29kZVwiLFxuICAgIFwiRmlsZS5DcmVhdGVcIjogXCJTdGFydGVkIGFzc2lnbm1lbnRcIixcbiAgICBcIlJ1bi5Qcm9ncmFtXCI6IFwiUmFuIHByb2dyYW1cIixcbiAgICBcIkNvbXBpbGUuRXJyb3JcIjogXCJTeW50YXggZXJyb3JcIixcbiAgICBcIlgtU3VibWlzc2lvbi5MTVNcIjogXCJVcGRhdGVkIGdyYWRlXCJcbn07XG5cbmNvbnN0IG1vbnRoTmFtZXMgPSBbXG4gICAgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIixcbiAgICBcIkFwclwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsXG4gICAgXCJBdWdcIiwgXCJTZXB0XCIsIFwiT2N0XCIsXG4gICAgXCJOb3ZcIiwgXCJEZWNcIlxuXTtcbmNvbnN0IHdlZWtEYXlzID0gW1xuICAgIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsXG4gICAgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIixcbiAgICBcIlNhdFwiXG5dO1xuXG5mdW5jdGlvbiBpc1NhbWVEYXkoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiBmaXJzdC5nZXREYXRlKCkgPT09IHNlY29uZC5nZXREYXRlKCkgJiZcbiAgICAgICAgZmlyc3QuZ2V0TW9udGgoKSA9PT0gc2Vjb25kLmdldE1vbnRoKCkgJiZcbiAgICAgICAgZmlyc3QuZ2V0RnVsbFllYXIoKSA9PT0gc2Vjb25kLmdldEZ1bGxZZWFyKCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGEgZGF0ZS90aW1lIHN0cmluZyBhbmQgcmV3cml0ZSBpdCBhcyBzb21ldGhpbmdcbiAqIG1vcmUgaHVtYW4gcmVhZGFibGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGltZVN0cmluZyAtIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSAoXCJZWVlZTU1ERCBISE1NU1NcIilcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gQSBodW1hbi1yZWFkYWJsZSB0aW1lIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJldHR5UHJpbnREYXRlVGltZSh0aW1lU3RyaW5nKSB7XG4gICAgLypsZXQgeWVhciA9IHRpbWVTdHJpbmcuc2xpY2UoMCwgNCksXG4gICAgICAgIG1vbnRoID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSg0LCA2KSwgMTApLTEsXG4gICAgICAgIGRheSA9IHRpbWVTdHJpbmcuc2xpY2UoNiwgOCksXG4gICAgICAgIGhvdXIgPSB0aW1lU3RyaW5nLnNsaWNlKDksIDExKSxcbiAgICAgICAgbWludXRlcyA9IHRpbWVTdHJpbmcuc2xpY2UoMTEsIDEzKSxcbiAgICAgICAgc2Vjb25kcyA9IHRpbWVTdHJpbmcuc2xpY2UoMTMsIDE1KTsqL1xuICAgIC8vIFRPRE86IEhhbmRsZSB0aW1lem9uZXMgY29ycmVjdGx5XG4gICAgaWYgKHRpbWVTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJVbmRlZmluZWQgVGltZVwiO1xuICAgIH1cbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgcGFzdCA9IG5ldyBEYXRlKHBhcnNlSW50KHRpbWVTdHJpbmcsIDEwKSk7XG4gICAgaWYgKGlzU2FtZURheShub3csIHBhc3QpKSB7XG4gICAgICAgIHJldHVybiBcIlRvZGF5IGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRheVN0ciA9IHdlZWtEYXlzW3Bhc3QuZ2V0RGF5KCldO1xuICAgICAgICBsZXQgbW9udGhTdHIgPSBtb250aE5hbWVzW3Bhc3QuZ2V0TW9udGgoKV07XG4gICAgICAgIGxldCBkYXRlID0gZGF5U3RyICsgXCIsIFwiICsgbW9udGhTdHIgKyBcIiBcIiArIHBhc3QuZ2V0RGF0ZSgpO1xuICAgICAgICBpZiAobm93LmdldEZ1bGxZZWFyKCkgPT09IHBhc3QuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgKyBcIiBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgKyBcIiwgXCIrcGFzdC5nZXRGdWxsWWVhcigpICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIE9wZW5zIHRoZSBoaXN0b3J5IGRpYWxvZyBib3guIFRoaXMgcmVxdWlyZXMgYSB0cmlwIHRvIHRoZSBzZXJ2ZXIgYW5kXG4gKiBvY2N1cnMgYXN5bmNocm9ub3VzbHkuIFRoZSB1c2VycycgY29kZSBpcyBzaG93biBpbiBwcmVmb3JtYXR0ZWQgdGV4dFxuICogdGFncyAobm8gY29kZSBoaWdobGlnaHRpbmcgY3VycmVudGx5KSBhbG9uZyB3aXRoIHRoZSB0aW1lc3RhbXAuXG4gKi9cbkJsb2NrUHlIaXN0b3J5LnByb3RvdHlwZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpYWxvZyA9IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZztcbiAgICB2YXIgYm9keSA9IFwiPHByZT5hID0gMDwvcHJlPlwiO1xuICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5nZXRIaXN0b3J5KGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGJvZHkgPSBkYXRhLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbXBsZXRlLCBlbGVtKSB7IFxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlX3N0ciA9IHByZXR0eVByaW50RGF0ZVRpbWUoZWxlbS50aW1lKTtcbiAgICAgICAgICAgIHZhciBuZXdfbGluZSA9IFwiPGI+XCIrY29tcGxldGVfc3RyK1wiPC9iPjxicj48cHJlPlwiK2VsZW0uY29kZStcIjwvcHJlPlwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlK1wiXFxuXCIrbmV3X2xpbmU7XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBkaWFsb2cuc2hvdyhcIldvcmsgSGlzdG9yeVwiLCBib2R5LCBmdW5jdGlvbigpIHt9KTtcbiAgICB9KTtcbn07IiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIG1haW4gSFRNTCBvZiBCbG9ja1B5IGludGVyZmFjZSwgYW5kIGhlbHBlciBmdW5jdGlvbnMuXG4gKiBDb21iaW5lcyBhIGxvdCBvZiBIVE1MIGZyb20gY29tcG9uZW50cy5cbiAqXG4gKiBIZXJlJ3MgdGhlIGxheW91dDpcbiAqICBSb3cgMTogSGVhZGVyIGFuZCBRdWljayBNZW51XG4gKiAgUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrXG4gKiAgUm93IDM6IEZpbGUgTmF2aWdhdGlvblxuICogIFJvdyA0OiBWaWV3IFJvd1xuICogIFJvdyA1OiBGb290ZXIgUm93XG4gKi9cblxuaW1wb3J0IHtUUkFDRV9IVE1MfSBmcm9tIFwidHJhY2UuanNcIjtcbmltcG9ydCB7RElBTE9HX0hUTUx9IGZyb20gXCJkaWFsb2cuanNcIjtcbmltcG9ydCB7RkVFREJBQ0tfSFRNTH0gZnJvbSBcImZlZWRiYWNrLmpzXCI7XG5pbXBvcnQge0ZJTEVTX0hUTUx9IGZyb20gXCJmaWxlcy5qc1wiO1xuaW1wb3J0IHtGT09URVJfSFRNTH0gZnJvbSBcImZvb3Rlci5qc1wiO1xuaW1wb3J0IHtFRElUT1JTX0hUTUx9IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge0NPTlNPTEVfSFRNTH0gZnJvbSBcImNvbnNvbGUuanNcIjtcblxuLyoqXG4gKiBUaGUgZGlmZmVyZW50IGxheW91dCBvcHRpb25zIG9mIHRoZSBwYW5lcyBpbiB0aGUgc2Vjb25kIHJvdyBvZiB0aGUgbGF5b3V0LlxuICogQGVudW0ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMgPSB7XG4gICAgRkVFREJBQ0s6IFwiZmVlZGJhY2tcIixcbiAgICBUUkFDRTogXCJ0cmFjZVwiLFxuICAgIE5PTkU6IFwibm9uZVwiXG59O1xuXG4vKipcbiAqIFNldHVwIGFueSBhZGRpdGlvbmFsIEtub2Nrb3V0IHN1YnNjcmlwdGlvbnMgdG8gZmlyZSBvbiBpbnRlcmZhY2UgY2hhbmdlcy5cbiAqIEBwYXJhbSBzZWxmXG4gKiBAcGFyYW0gbW9kZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMoc2VsZiwgbW9kZWwpIHtcbiAgICAvLyBIaWdobGlnaHQgTWFya2Rvd24gd2hlbiBpbnN0cnVjdGlvbnMgdXBkYXRlXG4gICAgbGV0IGhpZ2hsaWdodFRpbWVvdXQgPSBudWxsO1xuICAgIG1vZGVsLnVpLmluc3RydWN0aW9ucy5jdXJyZW50LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmIChoaWdobGlnaHRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaGlnaGxpZ2h0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LWluc3RydWN0aW9ucyBwcmUgY29kZVwiKS5tYXAoIChpLCBibG9jaykgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCA0MDApO1xuICAgIH0pO1xuICAgIC8vIFByb3ZpZGUgRnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuLnN1YnNjcmliZSgoaXNGdWxsc2NyZWVuKSA9PiB7XG4gICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5SZXF1ZXN0XCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsc2NyZWVuLnRvU3RyaW5nKCksIFwiXCIpO1xuICAgICAgICBpZiAoaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBuYXZpZ2F0aW9uVUkgY291bGQgYWxsb3cgdXMgdG8gZm9yY2UgY29udHJvbHMgdG8gc2hvd1xuICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIucGFyZW50KClbMF0ucmVxdWVzdEZ1bGxzY3JlZW4oKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYEVycm9yIGF0dGVtcHRpbmcgdG8gZW5hYmxlIGZ1bGwtc2NyZWVuIG1vZGU6ICR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5uYW1lfSlgO1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5FcnJvclwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSwgIFwiXCIpO1xuICAgICAgICAgICAgICAgIGFsZXJ0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLlN1Y2Nlc3NcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbih0cnVlKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5jc3MoXCJvdmVyZmxvdy15XCIsIFwiYXV0b1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXhpdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsc2NyZWVuLnRvU3RyaW5nKCksIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbihmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBUT0RPOiBHZXQgc2hhcmVhYmxlIGxpbmsgYnV0dG9uXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW50ZXJmYWNlKG1haW4pIHtcbiAgICByZXR1cm4gYFxuPGRpdiBjbGFzcz0nYmxvY2tweS1jb250ZW50IGNvbnRhaW5lci1mbHVpZCc+XG5cbiAgICA8IS0tIERpYWxvZyAtLT5cbiAgICAke0RJQUxPR19IVE1MfVxuICAgIFxuICAgIDwhLS0gSGlkZGVuIENhcHR1cmUgQ2FudmFzIC0tPlxuICAgIDxjYW52YXMgaWQ9J2NhcHR1cmUtY2FudmFzJyBjbGFzcz0nZC1ub25lJyByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jYW52YXM+XG4gICAgXG4gICAgPCEtLSBSb3cgMTogSGVhZGVyIGFuZCBRdWljayBNZW51IC0tPlxuICAgIDxkaXYgY2xhc3M9J3Jvdyc+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0gRGVzY3JpcHRpb24gLS0+XG4gICAgICAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtOSBibG9ja3B5LXBhbmVsIGJsb2NrcHktaGVhZGVyJ1xuICAgICAgICAgICAgICAgcm9sZT0naGVhZGluZycgYXJpYS1sYWJlbD0nQXNzaWdubWVudCBEZXNjcmlwdGlvbic+XG4gICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gQXNzaWdubWVudCBOYW1lIC0tPlxuICAgICAgICAgICAgPHNwYW4gcm9sZT0naGVhZGluZycgYXJpYS1sZXZlbD0nMSdcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmxvY2tweS1uYW1lXCI+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz5CbG9ja1B5OiA8L3N0cm9uZz4gXG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBhc3NpZ25tZW50Lm5hbWUnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBSZXNldCBJbnN0cnVjdGlvbnMgQnV0dG9uIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJsb2NrcHktaW5zdHJ1Y3Rpb25zLXJlc2V0XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5pbnN0cnVjdGlvbnMuaXNDaGFuZ2VkXCI+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJmbG9hdC1yaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5pbnN0cnVjdGlvbnMucmVzZXRcIlxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgIFJlc2V0IGluc3RydWN0aW9uczwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIEluc3RydWN0aW9ucyAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktaW5zdHJ1Y3Rpb25zJ1xuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJodG1sOiB1aS5pbnN0cnVjdGlvbnMuY3VycmVudFwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTMgYmxvY2tweS1wYW5lbCBibG9ja3B5LXF1aWNrLW1lbnUnXG4gICAgICAgICAgICAgcm9sZT0nbWVudWJhcicgYXJpYS1sYWJlbD0nUXVpY2sgTWVudScgdGl0bGU9XCJRdWljayBNZW51XCI+XG4gICAgICAgICAgICA8IS0tIEdldCBTaGFyZWFibGUgTGluayAtLT5cbiAgICAgICAgICAgIDwhLS08YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIj5cbiAgICAgICAgICAgICAgICBHZXQgc2hhcmVhYmxlIGxpbms8L2J1dHRvbj4tLT5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IHVpLm1lbnUuaXNTdWJtaXR0ZWRcIj5cbiAgICAgICAgICAgICAgICBZb3VyIHN1Ym1pc3Npb24gaXMgcmVhZHkgdG8gYmUgcmV2aWV3ZWQhPC9zcGFuPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5tZW51LmNhbk1hcmtTdWJtaXR0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5tZW51LnRleHRNYXJrU3VibWl0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLm1lbnUuY2xpY2tNYXJrU3VibWl0dGVkXCI+PC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFZpZXcgYXMgaW5zdHJ1Y3RvciAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCJcbiAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkucm9sZS5pc0dyYWRlclwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIlwiIGlkPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogZGlzcGxheS5pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgICAgICAgICBWaWV3IGFzIGluc3RydWN0b3JcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIFJlYWRvbmx5IG1vZGUgZm9yIHNweWluZyAtLT5cbiAgICAgICAgICAgIDxkaXYgZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIE93bmVyOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLm93bmVySWRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiYmxvY2tweS1yZWFkLW9ubHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogZGlzcGxheS5yZWFkT25seVwiPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1yZWFkLW9ubHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRvbmx5P1xuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBGdWxsc2NyZWVuIGJ1dHRvbiAtLT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUuY2xpY2tGdWxsc2NyZWVuXCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkZ1bGwgU2NyZWVuXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcycgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLm1lbnUudGV4dEZ1bGxzY3JlZW5cIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gRWRpdCBRdWV1ZWQgSW5wdXRzIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS5lZGl0SW5wdXRzLCB2aXNpYmxlOiB1aS5tZW51LnNob3dRdWV1ZWRJbnB1dHNcIiB0aXRsZT1cIkVkaXQgSW5wdXRzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1saXN0LWFsdCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFRvZ2dsZSBJbWFnZSBSZW5kZXJpbmcgLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS50b2dnbGVJbWFnZXNcIiB0aXRsZT1cIlRvZ2dsZSBJbWFnZXNcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1pbWFnZXNcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gUGluayBCdWcgZm9yIGFjdHVhbCBlcnJvcnMgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktc3R1ZGVudC1lcnJvciBmYXMgZmEtYnVnXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgIDwvZGl2PlxuICAgIFxuICAgIDwhLS0gUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrIC0tPlxuICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc0FsbFZpc2libGUgLS0+XG4gICAgPGRpdiBjbGFzcz0ncm93Jz5cbiAgICBcbiAgICAgICAgPCEtLSBDb25zb2xlIC0tPlxuICAgICAgICAke0NPTlNPTEVfSFRNTH1cbiAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIFxuICAgICAgICA8IS0tIFRyYWNlIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUgLS0+XG4gICAgICAgICR7VFJBQ0VfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICAke0ZJTEVTX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgNDogVmlldyBSb3cgLS0+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAke0VESVRPUlNfSFRNTH1cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gUm93IDU6IEZvb3RlciBSb3cgLS0+ICAgIFxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgJHtGT09URVJfSFRNTH1cbiAgICA8L2Rpdj5cbiAgICBcbjwvZGl2PlxuICAgIGA7XG59IiwiaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwiLi9zdG9yYWdlXCI7XG5pbXBvcnQge2xvYWRBc3NpZ25tZW50U2V0dGluZ3MsIHNhdmVBc3NpZ25tZW50U2V0dGluZ3N9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5cbi8qKlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU3RhdHVzU3RhdGUgPSB7XG4gICAgUkVBRFk6IFwicmVhZHlcIixcbiAgICBBQ1RJVkU6IFwiYWN0aXZlXCIsXG4gICAgUkVUUllJTkc6IFwicmV0cnlpbmdcIixcbiAgICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG4gICAgT0ZGTElORTogXCJvZmZsaW5lXCJcbn07XG5cbi8qKlxuICogT2JqZWN0IGZvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIGV4dGVybmFsIHNlcnZlcnMuIFRoaXMgaW5jbHVkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbiAqIHNhdmluZyBhbmQgbG9hZGluZyBmaWxlcywgbG9nZ2luZyBldmVudHMsIHNhdmluZyBjb21wbGV0aW9ucywgYW5kIHJldHJpZXZpbmcgaGlzdG9yeS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5U2VydmVyfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5U2VydmVyKG1haW4pIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuXG4gICAgLy8gU2F2ZSBVUkxzIGxvY2FsbHkgZm9yIHF1aWNrZXIgYWNjZXNzXG4gICAgdGhpcy51cmxzID0gbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHM7XG5cbiAgICAvLyBBZGQgdGhlIExvY2FsU3RvcmFnZSBjb25uZWN0aW9uXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoXCJCTE9DS1BZXCIpO1xuXG4gICAgLy8gRmF1bHRSZXNpc3RhbnRDYWNoZVxuICAgIHRoaXMucXVldWUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcImxvZ0V2ZW50XCIsIFwiW11cIikpLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0RGVmYXVsdChcInVwZGF0ZVN1Ym1pc3Npb25cIiwgXCJbXVwiKSlcbiAgICB9O1xuICAgIHRoaXMuTUFYX1FVRVVFX1NJWkUgPSB7XG4gICAgICAgIFwibG9nRXZlbnRcIjogMjAwLFxuICAgICAgICBcInVwZGF0ZVN1Ym1pc3Npb25cIjogNTBcbiAgICB9O1xuXG4gICAgdGhpcy5USU1FUl9ERUxBWSA9IDEwMDA7XG4gICAgdGhpcy5GQUlMX0RFTEFZID0gMjAwMDtcblxuICAgIHRoaXMudGltZXJzID0ge307XG5cbiAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xuICAgIHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA9IDA7XG5cbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcyA9IFtdO1xuICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHRoaXMuY2hlY2tDYWNoZXMoKTtcblxuICAgIHRoaXMuYWx0TG9nRW50cnkgPSBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBJUCBhZGRyZXNzIGhhcyBjaGFuZ2VkLCBsb2dnaW5nIGFuIGV2ZW50IGlmIHRoYXQgb2NjdXJzLlxuICogQHBhcmFtIHJlc3BvbnNlXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNoZWNrSVAgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcIklQXCIpKSB7XG4gICAgICAgICAgICBsZXQgb2xkSVAgPSB0aGlzLnN0b3JhZ2UuZ2V0KFwiSVBcIik7XG4gICAgICAgICAgICBpZiAob2xkSVAgIT09IHJlc3BvbnNlLmlwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIFwib2xkXCI6IG9sZElQLFxuICAgICAgICAgICAgICAgICAgICBcIm5ld1wiOiByZXNwb25zZS5pcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsdExvZ0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWx0TG9nRW50cnkoXCJYLUlQLkNoYW5nZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dFdmVudChcIlgtSVAuQ2hhbmdlXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChcIklQXCIsIHJlc3BvbnNlLmlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXCJJUFwiLCByZXNwb25zZS5pcCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlcmUgaGF2ZSBiZWVuIHByZXZpb3VzIGZhaWx1cmVzIGNhY2hlZCwgYW5kIGlmIHNvIHJldHJpZXMgdGhlbS5cbiAqIFRPRE86IHVwZGF0ZVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jaGVja0NhY2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcInNhdmVBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0KFwic2F2ZUFzc2lnbm1lbnRcIikpO1xuICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgXCJhc3NpZ25tZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNhdmVBc3NpZ25tZW50XCIsIHRoaXMuVElNRVJfREVMQVkpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcy5mb3JFYWNoKChmaWxlbmFtZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmhhcyhcInNhdmVGaWxlXCIgKyBmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0KFwic2F2ZUZpbGVcIiArIGZpbGVuYW1lKSk7XG4gICAgICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIFwic2F2ZUZpbGVcIiwgdGhpcy5USU1FUl9ERUxBWSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VydmVyID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXVlKS5mb3JFYWNoKGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAoZnVuY3Rpb24gcHVzaEFueVF1ZXVlZChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyLnF1ZXVlW2VuZHBvaW50XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHNlcnZlci5xdWV1ZVtlbmRwb2ludF0ucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2VydmVyLnVybHNbZW5kcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuX3Bvc3RSZXRyeShkYXRhLCBlbmRwb2ludCwgMTAwMCwgcHVzaEFueVF1ZXVlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSh7XCJzdWNjZXNzXCI6IHRydWV9KTtcbiAgICB9KTtcbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAobW9kZWwsIGZpbGVuYW1lKSB7XG4gICAgbW9kZWwuc3Vic2NyaWJlKChjb250ZW50cykgPT5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuYXV0b1NhdmUoKSA/IHRoaXMuc2F2ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSA6IGZhbHNlLCB0aGlzKTtcbiAgICB0aGlzLmNhY2hlZEZpbGVuYW1lcy5wdXNoKGZpbGVuYW1lKTtcbn07XG5cbi8qKlxuICogVE9ETzogZml4XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5zdWJtaXNzaW9uLmNvZGUsIFwiYW5zd2VyLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uUnVuLCBcIiFvbl9ydW4ucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25FdmFsLCBcIiFvbl9ldmFsLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlLCBcIiFvbl9jaGFuZ2UucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zLCBcIiFpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlLCBcIl5zdGFydGluZ19jb2RlLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYVN0dWRlbnRGaWxlcywgXCIjZXh0cmFfc3R1ZGVudF9maWxlcy5ibG9ja3B5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYVN0YXJ0aW5nRmlsZXMsIFwiI2V4dHJhX3N0YXJ0aW5nX2ZpbGVzLmJsb2NrcHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiNleHRyYV9pbnN0cnVjdG9yX2ZpbGVzLmJsb2NrcHlcIik7XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVFdmVudExvZ3MgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cub25ibHVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiU2Vzc2lvbi5FbmRcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICB3aW5kb3cub25mb2N1cyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2dFdmVudChcIlNlc3Npb24uU3RhcnRcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IEFkZCBpbiBiZWFjb24/XG59O1xuXG4vKipcbiAqXG4gKiBTb21lIHN1YnNjcmlwdGlvbnMgaGF2ZSB0byBoYXBwZW4gYWZ0ZXIgb3RoZXIgdGhpbmdzIGhhdmUgYmVlbiBsb2FkZWQuXG4gKiBSaWdodCBub3cgdGhpcyBpcyBqdXN0IGFmdGVyIENPUkdJUyBsaWJyYXJpZXMgaGF2ZSBiZWVuIGxvYWRlZCwgYnV0IG1heWJlXG4gKiB3ZSdsbCBhZGQgbW9yZSBsYXRlciBhbmQgdGhpcyB3aWxsIG5lZWQgdG8gYmUgcmVmYWN0b3JlZC5cbiAqXG4gKiBUT0RPOiBmaXhcbiAqXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmZpbmFsaXplU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL3RoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzLnN1YnNjcmliZSh0aGlzLnNhdmVBc3NpZ25tZW50LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBkZWZhdWx0IHBheWxvYWQgZm9yIGFueSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHNlcnZlciBBUElcbiAqIEByZXR1cm5zIHt7YXNzaWdubWVudF9pZDogKiwgY291cnNlX2lkOiAqLCBncm91cF9pZDogKiwgdXNlcl9pZDogKiwgdGltZXpvbmU6ICosIHZlcnNpb246ICosIHRpbWVzdGFtcDogKn19XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZVNlcnZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFzc2lnbm1lbnQgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudDtcbiAgICBsZXQgdXNlciA9IHRoaXMubWFpbi5tb2RlbC51c2VyO1xuICAgIGxldCBzdWJtaXNzaW9uID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb247XG4gICAgbGV0IGRpc3BsYXkgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheTtcbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gbm93LmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImFzc2lnbm1lbnRfaWRcIjogYXNzaWdubWVudC5pZCgpLFxuICAgICAgICBcImFzc2lnbm1lbnRfZ3JvdXBfaWRcIjogdXNlci5ncm91cElkKCksXG4gICAgICAgIFwiY291cnNlX2lkXCI6IHVzZXIuY291cnNlSWQoKSxcbiAgICAgICAgXCJzdWJtaXNzaW9uX2lkXCI6IHN1Ym1pc3Npb24uaWQoKSxcbiAgICAgICAgXCJ1c2VyX2lkXCI6IHVzZXIuaWQoKSxcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IGFzc2lnbm1lbnQudmVyc2lvbigpLFxuICAgICAgICBcInRpbWVzdGFtcFwiOiBtaWNyb3NlY29uZHMsXG4gICAgICAgIFwidGltZXpvbmVcIjogbm93LmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgIFwicGFzc2NvZGVcIjogZGlzcGxheS5wYXNzY29kZSgpXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdHVzIGFuZCBtZXNzYWdlIGZvciB0aGUgcmVsZXZhbnQgZW5kcG9pbnQuXG4gKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gb25lIG9mIHRoZSBVUkwgZW5kcG9pbnRzXG4gKiBAcGFyYW0gc3RhdHVzIHtTdGF0dXNTdGF0ZX1cbiAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmc/fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIHN0YXR1cywgbWVzc2FnZSkge1xuICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXNbZW5kcG9pbnRdKHN0YXR1cyk7XG4gICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludCArIFwiTWVzc2FnZVwiXShtZXNzYWdlIHx8IFwiXCIpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGFuIG92ZXJsYXkgb24gdGhlIHNjcmVlbiB0aGF0IGJsb2NrcyBvcGVyYXRpb24gdW50aWwgdGhlIHN5c3RlbSBpcyByZWFkeS5cbiAqIFRoZSBvdmVybGF5IGdldHMgcHJvZ3Jlc3NpdmVseSBkYXJrZXIgdG8gaW5kaWNhdGUgcmVwZWF0ZWQgZmFpbHVyZXMuXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNob3dPdmVybGF5ID0gZnVuY3Rpb24gKGF0dGVtcHQpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgKz0gMTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJibG9ja3B5LW92ZXJsYXlcIikubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9ICQoJzxkaXYgY2xhc3M9XCJibG9ja3B5LW92ZXJsYXlcIj4gPC9kaXY+Jyk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gICAgc3dpdGNoIChhdHRlbXB0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzk4OFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM2NTVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjMzMzXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImJsYWNrXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVbmRvIGEgbGV2ZWwgb2Ygb3ZlcmxheTsgaWYgdGhpcyB3YXMgdGhlIGxhc3QgbGV2ZWwsIHJlbW92ZXMgaXQgZnJvbSB0aGUgc2NyZWVuLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5oaWRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgLT0gMTtcbiAgICBpZiAodGhpcy5ibG9ja2luZ0F0dGVtcHRzIDw9IDApIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9lbnF1ZXVlRGF0YSA9IGZ1bmN0aW9uIChjYWNoZSwgZGF0YSkge1xuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIG5vdCBvdmVyZmlsbGVkIHRoZSBxdWV1ZVxuICAgIGxldCBsZW5ndGggPSB0aGlzLnF1ZXVlW2NhY2hlXS5sZW5ndGg7XG4gICAgbGV0IG1heCA9IHRoaXMuTUFYX1FVRVVFX1NJWkVbY2FjaGVdO1xuICAgIGlmIChsZW5ndGggPiBtYXgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtjYWNoZV0gPSB0aGlzLnF1ZXVlW2NhY2hlXS5zbGljZShsZW5ndGggLSBtYXgsIG1heCk7XG4gICAgfVxuICAgIC8vIE9ubHkgYWRkIHRoZSBlbGVtZW50IGlmIGl0J3MgbmV3XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldChjYWNoZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5xdWV1ZVtjYWNoZV0pKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZGVxdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5xdWV1ZVtjYWNoZV0uaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnNwbGljZShpbmRleCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGVuZHBvaW50LCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICBsZXQgcG9zdFJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgcG9zdFxuICAgICAgICB0aGlzLl9lbnF1ZXVlRGF0YShlbmRwb2ludCwgZGF0YSk7XG4gICAgICAgICQucG9zdCh0aGlzLnVybHNbZW5kcG9pbnRdLCBkYXRhKVxuICAgICAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICBwb3N0UmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocG9zdFJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBBSkFYIHJlcXVlc3QgdGhhdCwgdXBvbiBmYWlsdXJlLCB3aWxsIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHdhcyB0aGVcbiAqIGxhdGVzdCBhdHRlbXB0IGZvciB0aGlzIGBjYWNoZWAgbWFya2VyLiBJZiBzbywgaXQgd2lsbCBhdHRlbXB0IGFnYWluIHVudGlsXG4gKiBzdWNjZXNzZnVsOyBvdGhlcndpc2UsIGl0IGdpdmVzIHVwIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIEFKQVgtcmVhZHkgZGF0YSB0byBiZSBwb3N0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgdGltZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludCAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgY2FjaGUgZW50cnlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXkgLSBUaGUgY3VycmVudCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gdHJ5aW5nIHRoZSByZXF1ZXN0IGFnYWluLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdExhdGVzdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXksIGZhaWx1cmVGdW5jdGlvbiwgZG9uZUZ1bmN0aW9uKSB7XG4gICAgbGV0IGNhY2hlID0gZW5kcG9pbnQgKyBmaWxlbmFtZTtcbiAgICBsZXQgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgJC5wb3N0KHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGEpXG4gICAgICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgY2xlYXIgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb25uZWN0ZWQgYnV0IGZhaWxlZCwgZG9uJ3QgdHJ5IGFnYWluIGJ1dCBsZXQgdGhlIHVzZXIga25vdyB3aHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUZ1bmN0aW9uKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoZXJyb3IsIHRleHRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIHRoZW4gbGV0J3MgdHJ5IGl0IGFnYWluIGluIGEgYml0XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIGVuZHBvaW50LCBkZWxheSArIHRoaXMuRkFJTF9ERUxBWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGRvbmVGdW5jdGlvbik7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbY2FjaGVdKTtcbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVyc1tjYWNoZV0gPSBzZXRUaW1lb3V0KHJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdEJsb2NraW5nID0gZnVuY3Rpb24gKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cywgc3VjY2VzcywgZmFpbHVyZSwgZXh0cmFTZXR0aW5ncz17fSkge1xuICAgIHRoaXMuc2hvd092ZXJsYXkoYXR0ZW1wdHMpO1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgdXJsOiB0aGlzLnVybHNbZW5kcG9pbnRdLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAuLi5leHRyYVNldHRpbmdzXG4gICAgfSlcbiAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAuZmFpbCgoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZShlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhlbmRwb2ludCwgZGF0YSwgYXR0ZW1wdHMgLSAxLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoYXNzaWdubWVudF9pZCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiYXNzaWdubWVudF9pZFwiXSA9IGFzc2lnbm1lbnRfaWQ7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxvYWRBc3NpZ25tZW50XCIsIGRhdGEsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubG9hZEFzc2lnbm1lbnREYXRhXyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVChyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVBc3NpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiaGlkZGVuXCJdID0gbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKTtcbiAgICAgICAgZGF0YVtcInJldmlld2VkXCJdID0gbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpO1xuICAgICAgICBkYXRhW1wicHVibGljXCJdID0gbW9kZWwuYXNzaWdubWVudC5wdWJsaWMoKTtcbiAgICAgICAgZGF0YVtcInVybFwiXSA9IG1vZGVsLmFzc2lnbm1lbnQudXJsKCk7XG4gICAgICAgIGRhdGFbXCJwb2ludHNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnBvaW50cygpO1xuICAgICAgICBkYXRhW1wiaXBfcmFuZ2VzXCJdID0gbW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcygpO1xuICAgICAgICBkYXRhW1wibmFtZVwiXSA9IG1vZGVsLmFzc2lnbm1lbnQubmFtZSgpO1xuICAgICAgICBkYXRhW1wic2V0dGluZ3NcIl0gPSBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKTtcblxuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJzYXZlQXNzaWdubWVudFwiLCBkYXRhLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc3NpYmxlRm9yay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFNhdmUgQXNzaWdubWVudClcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEhpc3RvcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkSGlzdG9yeVwiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxpc3RVcGxvYWRlZEZpbGVzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxpc3RVcGxvYWRlZEZpbGVzXCIpKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibGlzdFVwbG9hZGVkRmlsZXNcIiwgZGF0YSwgMiwgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnVwbG9hZEZpbGUgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBkaXJlY3RvcnksIGZpbGVuYW1lLCBjb250ZW50cywgY2FsbGJhY2spIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBsb2FkRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wicGxhY2VtZW50XCJdID0gcGxhY2VtZW50O1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvbnRlbnRzXCJdID0gY29udGVudHM7XG4gICAgICAgIGxldCBmZCA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoZCxlKSA9PiAoZC5hcHBlbmQoLi4uZSksIGQpLCBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGxvYWRGaWxlXCIsIGZkLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBMT0FESU5HX0ZJTEUodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtwcm9jZXNzRGF0YTogZmFsc2UsIGNvbnRlbnRUeXBlOiBmYWxzZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoVXBsb2FkIEZpbGUpXCIpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50X3R5cGUsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgZmlsZV9wYXRoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9nRXZlbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImV2ZW50X3R5cGVcIl0gPSBldmVudF90eXBlO1xuICAgICAgICBkYXRhW1wiY2F0ZWdvcnlcIl0gPSBjYXRlZ29yeTtcbiAgICAgICAgZGF0YVtcImxhYmVsXCJdID0gbGFiZWw7XG4gICAgICAgIGRhdGFbXCJtZXNzYWdlXCJdID0gbWVzc2FnZTtcbiAgICAgICAgZGF0YVtcImZpbGVfcGF0aFwiXSA9IGZpbGVfcGF0aDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIFwibG9nRXZlbnRcIiwgMCwgKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVJbWFnZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGltYWdlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVJbWFnZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcInR1cnRsZV9vdXRwdXRcIiwgXCJzYXZlSW1hZ2VcIiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvblN0YXR1cyA9IGZ1bmN0aW9uKG5ld1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wic3RhdHVzXCJdID0gbmV3U3RhdHVzO1xuICAgICAgICBsZXQgcG9zdFN0YXR1c0NoYW5nZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIGRhdGEsIDIsIHBvc3RTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBsb2FkIGZpbGVzIGFuZCB3ZWIgcmVzb3VyY2VzLlxuICpcbiAqIERFUFJFQ0FURURcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHR5cGUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRfZmlsZVwiKSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcInR5cGVcIl0gPSB0eXBlO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcodGhpcy51cmxzLmxvYWRfZmlsZSwgZGF0YSwgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKFwiU2VydmVyIGZhaWx1cmUhIFJlcG9ydCB0byBpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhcIk5vIGZpbGUgc2VydmVyIGF2YWlsYWJsZS5cIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKExvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNvbnRlbnRzLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5ID0gdGhpcy5USU1FUl9ERUxBWTtcbiAgICB9XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvZGVcIl0gPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIGRlbGF5LCB0aGlzLnN0YXJ0UG9zc2libGVGb3JrLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnN0YXJ0UG9zc2libGVGb3JrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmZvcmthYmxlKSB7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5PRkZFUl9GT1JLKCk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvbiA9IGZ1bmN0aW9uIChzY29yZSwgY29ycmVjdCwgaGlkZGVuT3ZlcnJpZGUsIGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzY29yZVwiXSA9IHNjb3JlO1xuICAgICAgICBkYXRhW1wiY29ycmVjdFwiXSA9IGNvcnJlY3Q7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5fb3ZlcnJpZGVcIl0gPSBoaWRkZW5PdmVycmlkZTtcbiAgICAgICAgZGF0YVtcImZvcmNlX3VwZGF0ZVwiXSA9IGZvcmNlVXBkYXRlO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuZ2V0UG5nRnJvbUJsb2NrcygocG5nRGF0YSwgaW1nKSA9PiB7XG4gICAgICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBwbmdEYXRhO1xuICAgICAgICAgICAgaWYgKGltZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBpbWcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoaWRkZW5PdmVycmlkZSAmJiBjb3JyZWN0ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhW1wiYXNzaWdubWVudF9pZFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJleHBvcnQgY29uc3QgJHNrX21vZF9jb3ZlcmFnZSA9IGBcblwiXCJcIlxuSGlkZW91cyBmaWxsLWluIHJlcGxhY2VtZW50IGZvciBDb3ZlcmFnZSwgbGV2ZXJhZ2luZyBzb21lIG1hZ2ljIGZyb20gdGhlXG5VdGlsaXR5IGZ1bmN0aW9uLiBUaGUgZGF0YSB0aGlzIHJldHVybnMgaXMgZmFsc2UgLSBpdCBkb2Vzbid0IGFjdHVhbGx5XG5kZXNjcmliZSB0aGUgbWlzc2luZyBsaW5lcyBhbmQgYWxsIGxpbmVzOyBpdCBqdXN0IGRlc2NyaWJlcyB0aGUgdHJhY2VkIGxpbmVzLlxuQnV0IHNpbmNlIFBlZGFsIGRvZXNuJ3QgbmVlZCB0aGUgb3RoZXIgdHdvLCBpdCB3b3JrcyBvdXQgZmluZSB3aGVuIHlvdSBkbzpcblxuc3RhdGVtZW50cyAtIG1pc3NpbmdcblwiXCJcIlxuXG5pbXBvcnQgdXRpbGl0eVxuXG5jbGFzcyBDb3ZlcmFnZTpcbiAgICBkZWYgc3RhcnQoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzdG9wKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgc2F2ZShzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIF9hbmFseXplKHNlbGYsIGZpbGVuYW1lOiBzdHIpOlxuICAgICAgICBsaW5lcyA9IHNldCh1dGlsaXR5LnRyYWNlX2xpbmVzKCkpXG4gICAgICAgICMgbGluZXMgd2lsbCBiZSB0aGUgbGluZXMgdGhhdCB3ZXJlIGFjdHVhbGx5IGV4ZWN1dGVkXG4gICAgICAgIHJldHVybiBBbmFseXNpcyhOb25lLCBsZW4obGluZXMpLCBOb25lLCBzZXQoKSwgbGluZXMpXG5cblxuY2xhc3MgTnVtYmVyczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpOlxuICAgICAgICBzZWxmLm5fbWlzc2luZyA9IG5fbWlzc2luZ1xuICAgICAgICBzZWxmLm5fc3RhdGVtZW50cyA9IG5fc3RhdGVtZW50c1xuICAgICAgICBzZWxmLnBjX2NvdmVyZWQgPSBwY19jb3ZlcmVkXG5cblxuY2xhc3MgQW5hbHlzaXM6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkLCBtaXNzaW5nLCBzdGF0ZW1lbnRzKTpcbiAgICAgICAgc2VsZi5taXNzaW5nID0gbWlzc2luZ1xuICAgICAgICBzZWxmLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYubnVtYmVycyA9IE51bWJlcnMobl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpXG5cblxuY2xhc3MgcHl0aG9uOlxuICAgIGRlZiBnZXRfcHl0aG9uX3NvdXJjZShzZWxmKTpcbiAgICAgICAgcmV0dXJuIE5vbmVcbmA7IiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbW9kLCBzYW1wbGVXcmFwcGVyO1xuICAgIG1vZCA9IHtfX25hbWVfXzogXCJpbWFnZVwifTtcblxuICAgIGlmICghU2suUElMKSB7XG4gICAgICAgIFNrLlBJTCA9IHthc3NldHM6IHt9fTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50UHJvbWlzZSBpcyBhIHdvcmthcm91bmQgdG8gYWxsb3cgdXNhZ2Ugb2YgdGhlIGNsZWFuIHByb21pc2Utc3R5bGVcbiAgICAvLyB0aGVuL2NhdGNoIHN5bnRheCBidXQgdG8gaW5zdGFudGx5IGNhbGwgcmVzb2x2ZSB0aGUgdGhlbi9jYXRjaCBjaGFpbiBzbyB3ZVxuICAgIC8vIGNhbiBhdm9pZCBjcmVhdGluZyBTdXNwZW5zaW9ucyBpbiB1bm5lY2Vzc2FyeSBjYXNlcy4gIFRoaXMgaXMgZGVzaXJhYmxlXG4gICAgLy8gYmVjYXVzZSBTdXNwZW5zaW9ucyBoYXZlIGEgZmFpcmx5IGxhcmdlIG5lZ2F0aXZlIGltcGFjdCBvbiBvdmVyYWxsXG4gICAgLy8gcGVyZm9ybWFuY2UuICBUaGVzZSAnaW5zdGFudCBwcm9taXNlcycgY29tZSBpbnRvIHBsYXkgd2hlbiBhIHRyYWNlcigpXG4gICAgLy8gY2FsbCBpcyBtYWRlIHdpdGggYSB2YWx1ZSBvdGhlciB0aGFuIDEuICBXaGVuIHRyYWNlciBpcyAwIG9yIGdyZWF0ZXIgdGhhbiAxXG4gICAgLy8gLCB3ZSBjYW4gYnlwYXNzIHRoZSBjcmVhdGlvbiBvZiBhIFN1c3BlbnNpb24gYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgbGluZSBvZlxuICAgIC8vIGNvZGUgaW1tZWRpYXRlbHkgaWYgdGhlIGN1cnJlbnQgbGluZSBpcyBub3QgZ29pbmcgdG8gaW52b2x2ZSBhIHNjcmVlblxuICAgIC8vIHVwZGF0ZS4gV2UgZGV0ZXJtaW5lIGlmIGEgcmVhbCBwcm9taXNlIG9yIEluc3RhbnRQcm9taXNlIGlzIG5lY2Vzc2FyeSBieVxuICAgIC8vIGNoZWNraW5nIEZyYW1lTWFuYWdlci53aWxsUmVuZGVyTmV4dCgpXG4gICAgZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlcnI7XG4gICAgfVxuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlID8gdGhpcy5sYXN0UmVzdWx0IDogdGhpcztcbiAgICB9O1xuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgYnVpbGRJbWFnZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKFNrLlBJTC5hc3NldHNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFNrLlBJTC5hc3NldHNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShTay5QSUwuYXNzZXRzW25hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU2suUElMLmFzc2V0c1tuYW1lXSA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXNzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgIC8vIG9wZW4oZmlsZW5hbWUpIG9yIG9wZW4odXJsKVxuICAgICAgICAvLyBzaG93KClcblxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZmlsZV9vcl91cmwpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImZpbGVfb3JfdXJsXCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsZV9vcl91cmwpKTtcbiAgICAgICAgICAgIHNlbGYuZmlsZV9vcl91cmwgPSBmaWxlX29yX3VybDtcbiAgICAgICAgICAgIC8vIFRPRE86IENoYW5nZSB0byBzdXNwZW5zaW9uXG4gICAgICAgICAgICB2YXIgaW1hZ2VQcm9taXNlID0gZ2V0QXNzZXQoU2suZmZpLnJlbWFwVG9KcyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgdmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpO1xuICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgICAgIHN1c3AucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3AuZGF0YVtcImVycm9yXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihzdXNwLmRhdGFbXCJlcnJvclwiXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3VzcC5kYXRhW1wiZXJyb3JcIl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gc2VsZi5pbWFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3VzcC5kYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IGltYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy53aWR0aCA9IHNlbGYuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmhlaWdodCA9IHNlbGYuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHNlbGYuaW1hZ2UsIDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5waXhlbHMgPSBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3VzcDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5zaG93ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBpZiAoU2suY29uc29sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIGRyYXdpbmcgYXJlYS4gU2suY29uc29sZSBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29uc29sZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHNlbGYuaW1hZ2UsXG4gICAgICAgICAgICAgICAgZmlsZV9vcl91cmw6IHNlbGYuZmlsZV9vcl91cmxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNrLmNvbnNvbGUucHJpbnRQSUxJbWFnZShjb25zb2xlRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZmxpcCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgtMSlcIjtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtb2QuSW1hZ2UgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgaW1hZ2UsIFwiSW1hZ2VcIiwgW10pO1xuXG4gICAgcmV0dXJuIG1vZDtcbn07IiwiZXhwb3J0IGNvbnN0ICRwZWRhbF90cmFjZXIgPSBgXHJcblxyXG5cIlwiXCJcclxuV3JhcHMgdGhlIHRyYWNlciBtb2R1bGUgaW4gUGVkYWxcclxuXCJcIlwiXHJcblxyXG5pbXBvcnQgb3NcclxuaW1wb3J0IHV0aWxpdHlcclxuICAgICAgICBcclxuY2xhc3MgU2FuZGJveEJhc2ljVHJhY2VyOlxyXG4gICAgXCJcIlwiXHJcblxyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgc2VsZi5maWxlbmFtZSA9IFwic3R1ZGVudC5weVwiXHJcbiAgICAgICAgc2VsZi5jb2RlID0gTm9uZVxyXG5cclxuICAgIGRlZiBhc19maWxlbmFtZShzZWxmLCBmaWxlbmFtZSwgY29kZSk6XHJcbiAgICAgICAgaWYgb3MucGF0aC5pc2FicyhmaWxlbmFtZSk6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBmaWxlbmFtZVxyXG4gICAgICAgIGVsc2U6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBvcy5wYXRoLmFic3BhdGgoZmlsZW5hbWUpXHJcbiAgICAgICAgc2VsZi5jb2RlID0gY29kZVxyXG4gICAgICAgIHJldHVybiBzZWxmXHJcblxyXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcclxuICAgICAgICBwYXNzXHJcblxyXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsLCB0cmFjZWJhY2spOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbmNsYXNzIFNhbmRib3hOYXRpdmVUcmFjZXIoU2FuZGJveEJhc2ljVHJhY2VyKTpcclxuICAgIFwiXCJcIlxyXG4gICAgVHJhY2tzIGxpbmVzIGNvdmVyZWQgYW5kIGZ1bmN0aW9uIGNhbGxzLiBQb3NzaWJseSBvdGhlciB0aGluZ3M/IFdlIGNvdWxkIHRyYWNrIHZhcmlhYmxlcywgaWYgdGhhdFxyXG4gICAgd2FzIHNvbWV0aGluZyBwZW9wbGUgd2FudGVkLlxyXG5cclxuICAgIFRPRE86IEhhbmRsZSBtdWx0aXBsZSBzdWJtaXNzaW9uIGZpbGVzP1xyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgI3NlbGYuY2FsbHMgPSB1dGlsaXR5LnRyYWNlX2NhbGxzKClcclxuICAgICAgICBzZWxmLmxpbmVzID0gdXRpbGl0eS50cmFjZV9saW5lcygpXHJcbiAgICAgICAgc2VsZi5zdGVwX2luZGV4ID0gbGVuKHV0aWxpdHkudHJhY2VfbGluZXMoKSlcclxuICAgIFxyXG4gICAgZGVmIGdldF9jYWxscyhzZWxmKTpcclxuICAgICAgICByZXR1cm4gdXRpbGl0eS50cmFjZV9jYWxscygpXHJcbiAgICBcclxuICAgIGNhbGxzID0gcHJvcGVydHkoZ2V0X2NhbGxzKVxyXG4gICAgXHJcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxyXG4gICAgICAgIHV0aWxpdHkuc3RhcnRfdHJhY2Uoc2VsZilcclxuXHJcbiAgICBkZWYgX19leGl0X18oc2VsZiwgZXhjX3R5cGUsIGV4Y192YWwsIHRyYWNlYmFjayk6XHJcbiAgICAgICAgdXRpbGl0eS5zdG9wX3RyYWNlKHNlbGYpXHJcblxyXG5UUkFDRVJfU1RZTEVTID0ge1xyXG4gICAgJ25vbmUnOiBTYW5kYm94QmFzaWNUcmFjZXIsXHJcbiAgICAnbmF0aXZlJzogU2FuZGJveE5hdGl2ZVRyYWNlclxyXG59XHJcblxyXG5gOyIsIi8qKlxuICogU2t1bHB0IE1vZHVsZSBmb3IgaG9sZGluZyB0aGUgSW5zdHJ1Y3RvciBBUEkuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgbG9hZGVkIGluIGJ5IGdldHRpbmcgdGhlIGZ1bmN0aW9ucycgc291cmNlIGNvZGUgZnJvbSB0b1N0cmluZy5cbiAqIElzbid0IHRoYXQgY3Jhenk/XG4gKlxuICpcbiAqL1xuZXhwb3J0IGxldCAkc2tfbW9kX2luc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBNYWluIG1vZHVsZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIGF0IHRoZSBlbmQuXG4gICAgbGV0IG1vZCA9IHt9O1xuICAgIGxldCBub25lID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIFxuICAgIGxldCBwcmlvciA9IG51bGw7XG4gICAgbW9kLnRpbWVpdCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwidGltZWl0XCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBkaWZmZXJlbmNlO1xuICAgICAgICBpZiAocHJpb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IERhdGUubm93KCkgLSBwcmlvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhTay5mZmkucmVtYXBUb0pzKG5hbWUpLCBkaWZmZXJlbmNlLzEwMDApO1xuICAgICAgICBwcmlvciA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBmZWVkYmFjayB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9sb2cgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygoWy4uLmFyZ3VtZW50c10pLm1hcChTay5mZmkucmVtYXBUb0pzKSk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBkZWJ1ZyB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9kZWJ1ZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvdmVydHMgdGhlIG91dHB1dCBpbiB0aGUgc3R1ZGVudCByZXBvcnQgdG8gYSBweXRob24gXG4gICAgICogbGlzdCBhbmQgcmV0dXJucyBpdC5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X291dHB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfb3V0cHV0XCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS50b1NrdWxwdCgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlc2V0cyB0aGUgb3V0cHV0LCBwYXJ0aWN1bGFybHkgdXNlZnVsIGlmIHRoZSBzdHVkZW50XG4gICAgICogY29kZSBpcyBnb2luZyB0byBiZSByZXJ1bi5cbiAgICAgKi9cbiAgICBtb2QucmVzZXRfb3V0cHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJlc2V0X291dHB1dFwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ub3V0cHV0LnJlbW92ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgfSk7XG4gICAgXG4gICAgLyptb2QucXVldWVfaW5wdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicXVldWVfaW5wdXRcIiwgYXJndW1lbnRzLCAxLCBJbmZpbml0eSk7XG4gICAgICAgIGxldCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gYXJncy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGFyZ3NbaV07XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiaW5wdXRcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhpbnB1dCkpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaChTay5mZmkucmVtYXBUb0pzKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9KTsqL1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9wcm9ncmFtID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wcm9ncmFtXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJ2ZXJpZmllclwiXS5jb2RlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9ldmFsdWF0aW9uID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9ldmFsdWF0aW9uXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmV2YWx1YXRpb24gfHwgXCJcIik7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnRyYWNlX2xpbmVzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnJlYWxMaW5lcztcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KGxpbmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kLnRyYWNlX2NhbGxzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIi0tXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNIRUNLSU5HIENBTExTXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbJ3N0dWRlbnQnXS5zdWNjZXNzKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBjYWxscyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmNhbGxzO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtcbiAgICB9KTtcblxuICAgIG1vZC5zdGFydF90cmFjZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIGlmIChTay5iZWZvcmVDYWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBTay5iZWZvcmVDYWxsID0gU2suYmVmb3JlQ2FsbEJhY2t1cDtcbiAgICAgICAgfVxuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLnB1c2godHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9FTkRcIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgIH0pO1xuXG4gICAgbW9kLnN0b3BfdHJhY2UgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RPUC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcucG9wKCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUT1AvRU5EXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG1vZC5nZXRfc3R1ZGVudF9lcnJvciA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtub25lLCBub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvcixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLnRyYWNlYmFjayAmJiBlcnJvci50cmFjZWJhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uW1wibGluZVwiXSA9IGVycm9yLnRyYWNlYmFja1swXS5saW5lbm87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uID0gU2suZmZpLnJlbWFwVG9QeShwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Vycm9yLCBwb3NpdGlvbl0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcbiAgICBtb2QuaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImhhZF9leGVjdXRpb25fdGltZV9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gIVNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MgJiYgXG4gICAgICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXJyb3IgJiZcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvci50cCRuYW1lID09PSBcIlRpbWVMaW1pdEVycm9yXCI7XG4gICAgfSk7XG4gICAgXG4gICAgbGV0IGJhY2t1cFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgbW9kLmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGJhY2t1cFRpbWUgPSBTay5leGVjTGltaXQ7XG4gICAgICAgIGlmIChTay5leGVjTGltaXRGdW5jdGlvbikge1xuICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtb2QudW5saW1pdF9leGVjdXRpb25fdGltZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ1bmxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IGJhY2t1cFRpbWU7XG4gICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnN1cHByZXNzX3Njcm9sbGluZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJzdXBwcmVzc19zY3JvbGxpbmdcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBcbiAgICAvKlxuICAgIGRlZiBoaXN0KHNlbGYsIGRhdGEsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0hpc3RvZ3JhbScsICd2YWx1ZXMnOiBkYXRhLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHBsb3Qoc2VsZiwgeHMsIHlzPU5vbmUsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIGlmIHlzID09IE5vbmU6XG4gICAgICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdMaW5lJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd4JzogcmFuZ2UobGVuKHhzKSksICd5JzogeHMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHNjYXR0ZXIoc2VsZiwgeHMsIHlzLCAqKmt3YXJncyk6XG4gICAgICAgIGxhYmVsID0ga3dhcmdzLmdldCgnbGFiZWwnLCBOb25lKVxuICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdTY2F0dGVyJywgJ3gnOiB4cywgJ3knOiB5cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICovXG4gICAgbW9kLmdldF9wbG90cyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfcGxvdHNcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dHMgPSBvdXRwdXRzLmZpbHRlcihmdW5jdGlvbihvdXRwdXQpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50eXBlID09PSBcInBsb3RcIjtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XCJkYXRhXCI6IGdyYXBoLmNvbnRlbnQubWFwKGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bsb3QgPSB7IFwidHlwZVwiOiBwbG90LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCI6IFwiXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsb3QudHlwZSA9PT0gXCJsaW5lXCIgfHwgcGxvdC50eXBlID09PSBcInNjYXR0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGxvdFtcInhcIl0gPSBwbG90LmRhdGEubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYueDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieVwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi55OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbG90LnR5cGUgPT09IFwiaGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1widmFsdWVzXCJdID0gcGxvdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdQbG90O1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBcInhsYWJlbFwiOiBcIlwiLCBcInlsYWJlbFwiOiBcIlwiLCBcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiXCIsIFwibGVnZW5kXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkob3V0cHV0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIC8vIFByb3ZpZGVzIGBzdHVkZW50YCBhcyBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIGRhdGEgdGhhdCB0aGUgc3R1ZGVudCBkZWNsYXJlZC5cbiAgICBtb2QuU3R1ZGVudERhdGEgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgZnVuY3Rpb24oJGdibCwgJGxvYykge1xuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICAvL3NlbGYuZGF0YSA9IFNrLmJ1aWx0aW4uZGljdCgpO1xuICAgICAgICAgICAgbGV0IG5ld0RpY3QgPSBuZXcgU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBTay5hYnN0ci5zYXR0cihzZWxmLCBuZXcgU2suYnVpbHRpbi5zdHIoXCJkYXRhXCIpLCBuZXdEaWN0LCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYubW9kdWxlID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ucmVzdWx0cztcbiAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBzZWxmLm1vZHVsZS4kZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLmFic3RyLm9iamVjdFNldEl0ZW0obmV3RGljdCwgU2suZmZpLnJlbWFwVG9QeShTay51bmZpeFJlc2VydmVkKGtleSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FsbF9mID0gZnVuY3Rpb24oa3dhKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFwiY2FsbFwiLCBhcmd1bWVudHMubGVuZ3RoLCAxLCBJbmZpbml0eSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIga3dhcmdzID0gbmV3IFNrLmJ1aWx0aW5zLmRpY3Qoa3dhKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSBhcmdzWzBdO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgyKTtcblxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGt3YXJncy5tcCRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKFwiaW5wdXRzXCIpKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFNrLmZmaS5yZW1hcFRvSnMoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIikpO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uT2JqZWN0ID0gZGF0YS5tcCRsb29rdXAoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbk9iamVjdC50cCRjYWxsKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbF9mLmNvX2t3YXJncyA9IHRydWU7XG4gICAgICAgIC8vY2FsbF9mLmNvX3Zhcm5hbWVzID0gW1wic2VsZlwiLCBcImZ1bmN0aW9uXCJdO1xuICAgICAgICBjYWxsX2YuY29fbmFtZT0gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiY2FsbFwiKTtcbiAgICAgICAgJGxvY1tcImNhbGxfJHJuJFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoY2FsbF9mKTtcblxuICAgICAgICAkbG9jW1wiX19yZXByX19cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZ2V0X25hbWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfbmFtZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQocHJvcGVydHkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgJGxvYy5nZXRfdmFsdWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfdmFsdWVzX2J5X3R5cGVcIiwgYXJndW1lbnRzLCAyLCAzKTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImV4Y2x1ZGVfYnVpbHRpbnNcIiwgXCJib29sZWFuXCIsIFNrLmJ1aWx0aW4uY2hlY2tCb29sKGV4Y2x1ZGVfYnVpbHRpbnMpKTtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gU2suZmZpLnJlbWFwVG9KcyhleGNsdWRlX2J1aWx0aW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHNlbGYubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGVbcHJvcGVydHldLnRwJG5hbWUgPT09IHR5cGUudHAkbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSwgXCJTdHVkZW50RGF0YVwiKTtcbiAgICBtb2Quc3R1ZGVudCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQobW9kLlN0dWRlbnREYXRhKTtcbiAgICBcbiAgICBtb2QuZ2V0X3N0dWRlbnRfZGF0YSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9kYXRhXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBtb2Quc3R1ZGVudDtcbiAgICB9KTtcblxuICAgIG1vZC5zZXRfaW5zdHJ1Y3Rpb25zID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihuZXdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInNldF9pbnN0cnVjdGlvbnNcIiwgYXJndW1lbnRzLCAxLCAyKTtcbiAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gU2suZmZpLnJlbWFwVG9KcyhuZXdJbnN0cnVjdGlvbnMpO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wibW9kZWxcIl0uZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG5ld0luc3RydWN0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBtb2QuZ2V0X21vZGVsX2luZm8gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9tb2RlbF9pbmZvXCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBtb2RlbCA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXTtcbiAgICAgICAga2V5cyA9IFNrLmZmaS5yZW1hcFRvSnMoa2V5cykuc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KG1vZGVsKCkpO1xuICAgIH0pO1xuXG4gICAgbW9kLmNsZWFyX2V4aXN0aW5nX3N0dWRlbnRfaW1wb3J0cyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9kYXRhXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cygpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBtb2Q7XG59O1xuIiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciBtb2QsIHNhbXBsZVdyYXBwZXI7XHJcbiAgICBtb2QgPSB7X19uYW1lX186IFwid2Vha3JlZlwifTtcclxuXHJcbiAgICAvKm1vZC5XZWFrU2V0ID0gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIndlYWtyZWYuV2Vha1NldFwiLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFdlYWtTZXQoKVxyXG4gICAgfSk7Ki9cclxuXHJcbiAgICB2YXIgV2Vha1NldCA9IGZ1bmN0aW9uKCRnYmwsICRsb2MpIHtcclxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xyXG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19pbml0X19cIiwgYXJndW1lbnRzLCAyLCAyKTtcclxuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImRhdGFcIiwgXCJpdGVyYWJsZVwiLCBTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZGF0YSkpO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGl0ZXIgPSBTay5hYnN0ci5pdGVyKGRhdGEpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IFNrLmFic3RyLml0ZXJuZXh0KGl0ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5wdXNoKG5ldyBXZWFrUmVmKG5leHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJGxvYy5fX2l0ZXJfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3T2ZEYXRhID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHNlbGYuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNlbGYuZGF0YVtpXS5kZXJlZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdPZkRhdGEucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSB2aWV3T2ZEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gU2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi5saXN0KHZpZXdPZkRhdGEpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyokbG9jLm5leHQkID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi50cCRpdGVyKCk7XHJcbiAgICAgICAgfSk7Ki9cclxuXHJcbiAgICAgICAgJGxvYy5hZGQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIGl0ZW0pIHtcclxuICAgICAgICAgICAgc2VsZi5kYXRhLnB1c2gobmV3IFdlYWtSZWYoaXRlbSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIG1vZC5XZWFrU2V0ID0gU2subWlzY2V2YWwuYnVpbGRDbGFzcyhtb2QsIFdlYWtTZXQsIFwiV2Vha1NldFwiLCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIG1vZDtcclxufTsiLCJsZXQgTE9DQUxfU1RPUkFHRV9SRUY7XG50cnkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGID0gbG9jYWxTdG9yYWdlO1xuICAgIGxldCBtb2QgPSBcIkJMT0NLUFlfTE9DQUxTVE9SQUdFX1RFU1RcIjtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKG1vZCk7XG59IGNhdGNoKGUpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRiA9IHtcbiAgICAgICAgX2RhdGEgICAgICAgOiB7fSxcbiAgICAgICAgc2V0SXRlbSAgICAgOiBmdW5jdGlvbihpZCwgdmFsKSB7IHJldHVybiB0aGlzLl9kYXRhW2lkXSA9IFN0cmluZyh2YWwpOyB9LFxuICAgICAgICBnZXRJdGVtICAgICA6IGZ1bmN0aW9uKGlkKSB7IHJldHVybiB0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KGlkKSA/IHRoaXMuX2RhdGFbaWRdIDogbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlSXRlbSAgOiBmdW5jdGlvbihpZCkgeyByZXR1cm4gZGVsZXRlIHRoaXMuX2RhdGFbaWRdOyB9LFxuICAgICAgICBjbGVhciAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YSA9IHt9OyB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgb2JqZWN0IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBMb2NhbFN0b3JhZ2UuIFRoZSBMb2NhbFN0b3JhZ2VcbiAqIGJyb3dzZXIgQVBJIGFsbG93cyBmb3Igb2ZmbGluZSBzdG9yYWdlLiBUaGF0IEFQSSBpcyB2ZXJ5IHVuc29waGlzdGljYXRlZCxcbiAqIGFuZCBpcyBlc3NlbnRpYWxseSBhIGxhbWUga2V5LXZhbHVlIHN0b3JlLiBUaGlzIG9iamVjdCBzaXRzIG9uIHRvcFxuICogYW5kIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXRpZXMsIGluY2x1ZGluZyBydWRpbWVudGFyeWNhY2hlXG4gKiBjYWNoZSBleHBpcmF0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0xvY2FsU3RvcmFnZVdyYXBwZXJ9XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gQSBuYW1lc3BhY2UgdG8gdXNlIGluIGdyb3VwaW5nIGFjY2VzcyB0byBsb2NhbHN0b3JhZ2UuIFRoaXMga2VlcHMgYWNjZXNzIGNsZWFuIGFuZCBvcmdhbml6ZWQsIHdoaWxlIGFsc28gbWFraW5nIGl0IHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgTG9jYWxTdG9yYWdlIGNvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gTG9jYWxTdG9yYWdlV3JhcHBlcihuYW1lc3BhY2UpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbn1cbi8qKlxuICogQSBtZXRob2QgZm9yIGFkZGluZyBhIGtleS92YWx1ZSBwYWlyIHRvIExvY2FsU3RvcmFnZS5cbiAqIE5vdGUgdGhhdCBib3RoIHBhcmFtZXRlcnMgbXVzdCBiZSBzdHJpbmdzIChKU09OLnN0cmluZ2lmeSBpcyB5b3VyIGZyaWVuZCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldCA9ICBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIiwgdmFsdWUpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiLCAkLm5vdygpKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJlbW92aW5nIGEga2V5IGZyb20gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJlbW92ZS5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIik7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdGltZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdGltZSBmb3IuXG4gKiBAcmV0dXJucyB7SW50ZWdlcn0gLSBUaGUgdGltZXN0YW1wIChsb2NhbCBlcG9jaCkgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHNldC5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBwYXJzZUludChMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIikpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQgaW5zdGVhZC5cbiAqIFRoaXMgZGVmYXVsdCB3aWxsIGJlIHNldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZS4gTXVzdCBiZSBhIHN0cmluZy5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSB0ZXN0IGZvciB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgaW4gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHRlc3QgZXhpc3RlbmNlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBBIHRlc3QgZm9yIHdoZXRoZXIgdGhlIHNlcnZlciBoYXMgdGhlIG5ld2VyIHZlcnNpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGFzc3VtZXMgdGhhdCB0aGUgc2VydmVyIHRyaXAgdGFrZXMgYWJvdXQgNSBzZWNvbmRzLiBUaGlzIG1ldGhvZFxuICogaXMgbGFyZ2VseSBkZXByZWNhdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzZXJ2ZXJfdGltZSAtIFRoZSBzZXJ2ZXIncyB0aW1lIGFzIGFuIGVwb2NoIChpbiBtaWxsaXNlY29uZHMpXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmlzX25ldyA9IGZ1bmN0aW9uKGtleSwgc2VydmVyX3RpbWUpIHtcbiAgICB2YXIgc3RvcmVkX3RpbWUgPSBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIik7XG4gICAgcmV0dXJuIChzZXJ2ZXJfdGltZSA+PSBzdG9yZWRfdGltZSs1MDAwKTtcbn07XG4iLCJleHBvcnQgY29uc3QgVFJBQ0VfSFRNTCA9IGBcblxuPGRpdiBjbGFzcz1cImJsb2NrcHktdHJhY2UgY29sLW1kLTYgYmxvY2tweS1wYW5lbFwiXG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIlRyYWNlXCI+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+XG4gICAgICAgIDxzdHJvbmc+VHJhY2U6IDwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LWhpZGUtdHJhY2UnXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+IEhpZGUgVHJhY2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgbWItMyBibG9ja3B5LXRyYWNlLWNvbnRyb2xzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZpcnN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuYmFja3dhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlN0ZXA6PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgLyA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZvcndhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5sYXN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiB1aS50cmFjZS5saW5lJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDx0YWJsZSBjbGFzcz0ndGFibGUgdGFibGUtc20gdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1ob3Zlcic+XG4gICAgICAgIDxjYXB0aW9uPkN1cnJlbnQgdmFyaWFibGVzIGF0IHRoaXMgc3RlcDwvY2FwdGlvbj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyPjx0aD5OYW1lPC90aD48dGg+VHlwZTwvdGg+PHRoPlZhbHVlPC90aD48L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHkgZGF0YS1iaW5kPVwiZm9yZWFjaDogdWkudHJhY2UuZGF0YSgpLnByb3BlcnRpZXNcIj5cbiAgICAgICAgICAgIDx0ciBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBuYW1lICE9ICdfX2ZpbGVfXycgJiYgbmFtZSAhPSAnX19wYXRoX18nXCI+XG4gICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmQ9XCJ0ZXh0OiB0eXBlXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgIDxjb2RlIGRhdGEtYmluZD1cInRleHQ6IHZhbHVlXCI+PC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIGtvIGlmOiB0eXBlID09IFwiTGlzdFwiIC0tPlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIlwiIGRhdGEtYmluZD1cImNsaWNrOiAvLyRyb290LnZpZXdFeGFjdFZhbHVlKHR5cGUsIGV4YWN0X3ZhbHVlKVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1uZXctd2luZG93Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgICBcbjwvZGl2PlxuYDtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlUcmFjZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5JR05PUkVEX0dMT0JBTFMgPSBbXCJfX25hbWVfX1wiLCBcIl9fZG9jX19cIiwgXCJfX3BhY2thZ2VfX1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzbWV0aG9kXCIsIFwicHJvcGVydHlcIiwgXCJzdGF0aWNtZXRob2RcIl07XG5cbiAgICAgICAgLy8gdGhpcy50cmFjZS5jbGljayh0aGlzLmJ1aWxkVHJhY2VUYWJsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgc2V0IG9mIHZhcmlhYmxlcyB0cmFjZWQgZnJvbSB0aGUgZXhlY3V0aW9uIGFuZCBwYXJzZSBvdXQgYW55XG4gICAgICogZ2xvYmFsIHZhcmlhYmxlcyBhbmQgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZXMgLSBhIG1hcHBpbmcgb2YgdmFyaWFibGUgbmFtZXMgdG8gdGhlaXIgU2t1cHQgdmFsdWUuXG4gICAgICovXG4gICAgcGFyc2VHbG9iYWxzKHZhcmlhYmxlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtb2R1bGVzID0gW107XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJhY2VFeGVjdXRpb24oKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFyaWFibGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5JR05PUkVEX0dMT0JBTFMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZShcIl8kcnckXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIl8kcm4kXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gQmxvY2tQeVRyYWNlLnBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB7XCJuYW1lXCI6IHByb3BlcnR5LCBcInR5cGVcIjogXCJVbmtub3duXCIsIFwidmFsdWVcIjogdmFsdWUudG9TdHJpbmcoKX07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaCh2YWx1ZS4kZC5fX25hbWVfXy52KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1wicHJvcGVydGllc1wiOiByZXN1bHQsIFwibW9kdWxlc1wiOiBtb2R1bGVzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFNrdWxwdCB2YWx1ZSBpbnRvIGEgbW9yZSBlYXNpbHkgcHJpbnRhYmxlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBza3VscHQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VWYWx1ZShwcm9wZXJ0eSwgdmFsdWUsIGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiVW5kZWZpbmVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZ1bmM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgQXJndW1lbnRzOiBcIit2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMuam9pbihcIiwgXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBObyBhcmd1bWVudHNcIilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm1vZHVsZTogcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uc3RyOlxuICAgICAgICAgICAgICAgIGlmIChmdWxsTGVuZ3RoIHx8IHZhbHVlLnYubGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiW1wiK3ZhbHVlLnNxJGxlbmd0aCgpK1wiIGNoYXJhY3RlcnMgbm90IHNob3duXVwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5vbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIk5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIk5vbmVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uYm9vbDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubm1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludFwiID09PSB2YWx1ZS5za1R5cGUgPyBcIkludGVnZXJcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uaW50XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZmxvYXRfOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4udHVwbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5saXN0OlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52Lmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlsuLi4gXCIrdmFsdWUudi5sZW5ndGgrXCIgZWxlbWVudHMgLi4uXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5kaWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUgJSAxID09PSAwID8gXCJJbnRlZ2VyXCIgOiBcIkZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6ICh2YWx1ZSA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiB2YWx1ZS50cCRuYW1lID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLnRwJG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRPRE86IHZpZXdFeGFjdFZhbHVlIiwiLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IGlzIGluIHRoZSBsaXN0LlxuICogQHBhcmFtIHthbnl0aGluZ30gbmVlZGxlIC0gVGhlIGVsZW1lbnQgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0FycmF5fSBoYXlzdGFjayAtIFRoZSBsaXN0IHRvIHNlYXJjaC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMobmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPiAtMTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHZhbHVlcyBmcm9tIGFuIGFycmF5LCBwcmVzZXJ2aW5nIG9yZGVyLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICogQ291cnRlc3k6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTg0MzcwL2hvdy10by1tZXJnZS10d28tYXJyYXlzLWluLWphdmFzY3JpcHQtYW5kLWRlLWR1cGxpY2F0ZS1pdGVtc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHVuaXF1aWZ5LiBFbGVtZW50cyBjb21wYXJlZCB3aXRoID09PS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICB2YXIgYSA9IGFycmF5LmNvbmNhdCgpO1xuICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yKHZhciBqPWkrMTsgajxhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZihhW2ldID09PSBhW2pdKSB7YS5zcGxpY2Uoai0tLCAxKTt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIGFuIGFycmF5IGJhc2VkXG4gKiBvbiBhbiBcImFkZEFycmF5XCIgYW5kIFwicmVtb3ZlQXJyYXlcIi4gQW55IGVsZW1lbnRcbiAqIGZvdW5kIGluIHJlbW92ZUFycmF5IGlzIHJlbW92ZWQgZnJvbSB0aGUgZmlyc3QgYXJyYXlcbiAqIGFuZCBhbGwgdGhlIGVsZW1lbnRzIG9mIGFkZEFycmF5IGFyZSBhZGRlZC5cbiAqIEFueSBkdXBsaWNhdGUgaXRlbXMgYXJlIHJlbW92ZWQuXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5LCBzbyBpcyBub24tZGVzdHJ1Y3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gbWFuaXB1bGF0ZVxuICogQHBhcmFtIHtBcnJheX0gYWRkQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG1vZGlmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZEFycmF5KGFycmF5LCBhZGRBcnJheSwgcmVtb3ZlQXJyYXkpIHtcbiAgICB2YXIgY29weUFycmF5ID0gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUFycmF5LmluZGV4T2YoaXRlbSkgPT09IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheVVuaXF1ZShjb3B5QXJyYXkuY29uY2F0KGFkZEFycmF5KSk7XG59XG5cbi8qKlxuICogRGVlcGx5IGNsb25lcyBhIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBBIG5vZGUgdG8gY2xvbmVcbiAqIEByZXR1cm4ge05vZGV9IEEgY2xvbmUgb2YgdGhlIGdpdmVuIG5vZGUgYW5kIGFsbCBpdHMgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBhIHRleHQgbm9kZSwgdGhlbiByZS1jcmVhdGUgaXQgcmF0aGVyIHRoYW4gY2xvbmUgaXRcbiAgICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLm5vZGVWYWx1ZSkgOiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gXG4gICAgLy8gUmVjdXJzZSAgICAgXG4gICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCkpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICAgXG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEluZGVudHMgdGhlIGdpdmVuIHN0cmluZyBieSA0IHNwYWNlcy4gVGhpcyBjb3JyZWN0bHkgaGFuZGxlcyBtdWx0aS1saW5lIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHdpdGggZm91ciBzcGFjZXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IG5ldyBsaW5lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZW50KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXig/PS4pL2dtLCBcIiAgICBcIik7XG59XG5cbi8qKlxuICogVHVybnMgc3BhY2VzIGludG8gdW5kZXJzY29yZXMgaW4gdGhlIHN0cmluZywgbWFrZXMgaXQgbG93ZXJjYXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbHVnKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzL2csIFwiX1wiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBiZSBjYXBpdGFsaXplZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIFtgbWluYCwgYG1heGBdLlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIGxvd2VzdCBwb3NzaWJsZSBpbnRlZ2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBoaWdoZXN0IHBvc3NpYmxlIGludGVnZXIgKGluY2x1c2l2ZSkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRlZ2VyKG1pbixtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYXgtbWluKzEpK21pbik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBzb21lIHRleHQgc28gdGhhdCBpdCBjYW4gYmUgc2FmZWx5IHdyaXR0ZW4gaW50byBhbiBIVE1MIGJveC5cbiAqIFRoaXMgaW5jbHVkZXMgcmVwbGFjaW5nIHNwZWNpYWwgSFRNTCBjaGFyYWN0ZXJzICgmLCA8LCA+LCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHRleHQgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSFRNTC1zYWZlIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIVE1MKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csIFwiJmFwb3M7XCIpO1xufVxuXG4vKipcbiAqIFNodWZmbGUgdGhlIGJsb2NrcyBpbiB0aGUgd29ya3NwYWNlXG4gKi9cbmlmICh0eXBlb2YgQmxvY2tseSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEJsb2NrbHkuV29ya3NwYWNlU3ZnLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1ldHJpY3Mudmlld1dpZHRoIC8gMixcbiAgICAgICAgICAgIGhlaWdodCA9IG1ldHJpY3Mudmlld0hlaWdodDtcbiAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuZ2V0VG9wQmxvY2tzKGZhbHNlKTtcbiAgICAgICAgdmFyIHkgPSA1LCB4ID0gMCxcbiAgICAgICAgICAgIG1heGltYWxfaW5jcmVhc2UgPSBoZWlnaHQvYmxvY2tzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gR2V0IGEgYmxvY2tcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYmxvY2suZ2V0UmVsYXRpdmVUb1N1cmZhY2VYWSgpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gLXByb3BlcnRpZXMueCtyYW5kb21JbnRlZ2VyKDEwLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5tb3ZlQnkoeCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgLXByb3BlcnRpZXMueSt5KTtcbiAgICAgICAgICAgIHkgPSB5ICsgcmFuZG9tSW50ZWdlcig1LCBtYXhpbWFsX2luY3JlYXNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogTW92ZSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyIGJhc2VkIG9uIGEgY29uZGl0aW9uYWwgY2hlY2suXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTg4Nzk2Ny9qYXZhc2NyaXB0LW1vdmUtb2JqZWN0cy1mcm9tLW9uZS1hcnJheS10by1hbm90aGVyLWJlc3QtYXBwcm9hY2hcbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnRzKHNvdXJjZSwgdGFyZ2V0LCBtb3ZlQ2hlY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKG1vdmVDaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgICAgc291cmNlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfSBcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBvbmUgb2YgdGhlIFNrLmJ1aWx0aW4gb2JqZWN0c1xuICogVE9ETzogbWFrZSB0aGlzIHNvIHdlIGRvbid0IGhhdmUgdG8gZXhwbGljaXRseSBwdXQgb3V0IGV2ZXJ5IG9wdGlvblxuICogICAgICAgICAgb25lIHBvc3NpYmxlIHRoaW5nIHdlIGNvdWxkIGRvIGlzIGdldCBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBcbiAqICAgICAgICAgIG9mIHRoZSBjb25zdHJ1Y3RvciBhbmQgbG9vayBmb3IgdGhlIHN1YnN0cmluZyBcInJldHVybiBuZXcgU2suYnVpbHRpblwiXG4gKiAgICAgICAgICBCdXQgSSBkb24ndCBrbm93IGhvdyByZWxpYWJsZSB0aGF0IGlzLiAgUmF0aGVyLCBpdCdzIGtpbmQgb2YgaGFja2lzaC5cbiAqICAgICAgICAgIFNob3VsZCB0ZWhvcmV0aWNhbGx5IGJlbG9uZyBpbiBTay5mZmlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGV4YW1pbmVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIHR5cGVzXG4qKi9cbmZ1bmN0aW9uIGlzU2tCdWlsdGluKG9iail7XG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ib29sKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8pIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKTtcbiAgICAvL3ZhciBjb25zX3N0ciA9IG9iai5jb25zdHJ1Y3RvciArIFwiXCI7XG4gICAgLy9yZXR1cm4gY29uc19zdHIuaW5kZXhPZihcInJldHVybiBuZXcgU2suYnVpbHRpblwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGlzQXN0Tm9kZShvYmope1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgXCJfYXN0bmFtZVwiIGluIG9iajtcbn1cblxuLyoqXG4gKiBTaG91bGQgdGhlb3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpLCBidXQgSSBwdXQgaXQgaGVyZSBpbnN0ZWFkIHRvIG5vdCBtZXNzIHVwIHRoZSBza3VscHQgZmlsZXNcbiAqIGxpa2UgdGhlIG5vcm1hbCBTay5mZmkucmVtYXBUb1B5LCBpdCBkb2Vzbid0IHdvcmsgZm9yIGZ1bmN0aW9ucyBvciBtb3JlIGNvbXBsZXggb2JqZWN0cywgYnV0IGl0IGhhbmRsZXNcbiAqIGNhc2VzIHdoZXJlIHRoZSB0eXBlcyBpbiBvYmogYXJlIGEgbWl4IG9mIHB5dGhvbiBTSU1QTEUgb2JqZWN0cyBhbmQgU0lNUExFIG5vcm1hbCBqYXZhc2NyaXB0IG9iamVjdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7U2suYnVpbHRpbi4/Pz99IC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBweXRob24gb2JqZWN0LCBkcm9wcGluZyBhbGwgZnVuY3Rpb25zIGFuZCB0aGluZ3MgaXQgY2FuJ3QgY29udmVydFxuKiovXG5mdW5jdGlvbiBtaXhlZFJlbWFwVG9QeShvYmope1xuICAgIHZhciBrO1xuICAgIHZhciBrdnM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFycjtcbiAgICAvL0BUT0RPOiBzaG91bGQgdGhlb3JldGljYWxseSBjaGVjayBpZiB0aGUgb2JqZWN0IGlzIGEgcHlob24gZGljdCBvciBhcnJheSB3aXRoIGpzIG9iamVjdHNcbiAgICBpZiAoaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFscmVhZHkgcHl0aG9uIHJlYWR5XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFjdHVhbGx5IGEgamF2YXNjcmlwdCBhcnJheVxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy9mb3IgZWFjaCBvYmplY3QsIGNvbnZlcnQgaXQgdG8gYSBweXRob24gb2JqZWN0IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICB2YXIgc3VidmFsID0gb2JqW2ldO1xuICAgICAgICAgICAgaWYoIWlzU2tCdWlsdGluKHN1YnZhbCkpe1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKG1peGVkUmVtYXBUb1B5KHN1YnZhbCkpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc3VidmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChhcnIpO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7Ly9udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZighaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgICAgICAvL2Fzc3VtaW5nIGl0J3MgYSBzdGFuZGFyZCBkaWN0aW9uYXJ5XG4gICAgICAgICAgICBrdnMgPSBbXTsvL1NrLmJ1aWx0aW4uZGljdCB1c2VzIGFuIGFycmF5IG9mIGtleS12YWx1ZSxrZXktdmFsdWUuLi5cbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIGtleSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShrKSk7XG4gICAgICAgICAgICAgICAgLy9jb3ZlcnQgY29ycmVzcG9uZGluZyB2YWx1ZSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShvYmpba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY3JlYXRlIHRoZSBuZXcgZGljdGlvbmFyeVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3Qoa3ZzKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKG9iaik7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iai5uYW1lKTtcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2tub2Nrb3V0X187Il0sInNvdXJjZVJvb3QiOiIifQ==