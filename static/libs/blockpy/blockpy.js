(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var skulpt_modules_weakref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! skulpt_modules/weakref */ "./src/skulpt_modules/weakref.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */




 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_5__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration; //console.log(configuration, configuration["submission.code"], configuration["partId"], extractPart(configuration["submission.code"] || "", configuration["partId"]));

      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray(Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(configuration["assignment.extra_instructor_files"]) || []),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(configuration["submission.code"] || "", configuration["partId"]) || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_7__["DisplayModes"].TEXT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK),
          previousSecondRowSecondPanel: ko.observable(null),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),

          /**
           * Whether or not images should be rendered (true), or just stay as text code (false).
           */
          renderImages: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true"),

          /**
           * Uploaded files are ones that have been listed by the remote
           */
          uploadedFiles: ko.observable(null),

          /**
           * Backup copy of the latest known full code for the Submission. This is relevant if there was a
           * PartID specified, in which case the submission.code in the model is only showing what we know
           * locally.
           */
          backupSubmissionCode: ko.observable(configuration["submission.code"] || "")
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          listUploadedFiles: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          listUploadedFilesMessage: ko.observable(""),
          // @type {ServerStatus}
          downloadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          downloadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          uploadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          uploadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {},

          /**
           * Unique Part ID that can distinguish this editor instance's region of the assignment.
           * It's possible that other editors may be attached to a different Part of the same assignmnet, on the
           * same page.
           * **/
          partId: ko.observable(configuration["partId"] || "")
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.display.backupSubmissionCode(submission.code);
      this.model.submission.code(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(submission.code, this.model.configuration.partId()) || "");
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.submissionStatus(submission.submission_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.debug(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        smallLayout: ko.pureComputed(function () {
          return !model.display.instructor() && model.assignment.settings.smallLayout();
        }),
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.onlyInteractive();
          }),
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          toggleImages: function toggleImages() {
            if (model.display.renderImages()) {
              self.components.pythonEditor.bm.textEditor.disableImages();
            } else {
              self.components.pythonEditor.bm.textEditor.enableImages();
            }

            model.display.renderImages(!model.display.renderImages());
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          }),
          showClock: ko.pureComputed(function () {
            return !model.assignment.settings.hasClock();
          })
        },
        secondRow: {
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-5";
          }),
          hideTraceButton: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideTraceButton();
          }),
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            }
          },
          makeWide: function makeWide() {
            var currentPanel = model.display.secondRowSecondPanel;
            model.display.previousSecondRowSecondPanel(currentPanel());
            currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
          },
          restorePanel: function restorePanel() {
            var oldPanel = model.display.previousSecondRowSecondPanel;

            if (oldPanel() !== null) {
              model.display.secondRowSecondPanel(oldPanel());
              oldPanel(null);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.smallLayout() || model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          }),
          resetScore: function resetScore() {
            model.submission.score(0);
            model.submission.correct(false);
            self.components.server.updateSubmission(model.submission.score(), model.submission.correct(), true, true);
          }
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          highlightedLine: ko.pureComputed(function () {
            if (model.display.secondRowSecondPanel() !== interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              return [];
            }

            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return [];
            } else if (step === 0) {
              return [];
            } else {
              return [traceData[step - 1].line];
            }
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + traceData[step - 1].line;
            }
          }),
          ast: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return "Starting execution";

              case lastStep:
                return "Finished execution";

              default:
                return "Current step: " + _trace__WEBPACK_IMPORTED_MODULE_13__["AST_DESCRIPTIONS"][traceData[step - 1].ast];
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-6";
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?images.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?images.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?images.blockpy":
                self.components.fileSystem.newFile(path, "{}");
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          rename: function rename(newName) {
            return self.components.fileSystem.renameFile(model.display.filename(), newName);
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?images.blockpy") {
              return "Images";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-7";
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && (model.assignment.settings.hideEditors() || model.assignment.settings.onlyInteractive()) ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_10__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          images: {
            reloadImages: function reloadImages() {
              return self.components.editors.byName("image").reloadImages();
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          }),
          runLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run";
          }),
          run: function run() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun();
            }
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        },
        footer: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.ui.smallLayout();
          })
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/weakref.js"] = weakrefModule.toString();
      //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_16__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_15__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_13__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_14__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_12__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_10__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_6__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_8__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_18__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_19__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
      this.clock = null;
      var container = this.model.configuration.container;

      var updateClock = function updateClock() {
        return container.find(".blockpy-menu-clock").text(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["getCurrentTime"])());
      };

      if (this.model.ui.menu.showClock()) {
        this.clock = setInterval(updateClock, 1000);
      }

      this.model.ui.menu.showClock.subscribe(function (changed) {
        if (_this2.model.ui.menu.showClock()) {
          if (_this2.clock) {
            clearInterval(_this2.clock);
            _this2.clock = null;
          }
        } else {
          if (!_this2.clock) {
            _this2.clock = setInterval(updateClock, 1000);
          }
        }
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.offset().top; //$('html').scrollTop(top);

        $("html").scrollTop(top); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.offset().top;
        $("html").scrollTop(top);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};

      this.main.model.ui.secondRow.restorePanel();
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();
      console.log(inputIndex, this.main.model.execution.input().length);

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "handlePygameResize",
    value: function handlePygameResize(newWidth, newHeight) {
      // If the user hasn't changed the console size, and the newHeight is bigger than default, we'll change it
      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height() && newHeight > this.DEFAULT_HEIGHT) {
        this.printerTag.height(30 + newHeight);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      } // If the pygame window is wider than the console, we'll expand temporarily.


      if (newWidth > this.printerTag.width()) {
        this.main.model.ui.secondRow.makeWide();
      }
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else if (this.pygameLine) {
          var _canvas = this.pygameLine.canvas;

          var _dataUrl = _canvas.toDataURL("image/png");

          this.main.components.server.saveImage("turtle_output", _dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_LISTING_UPLOADED_FILES = function (reason) {
  this.show("Error Listing Uploaded Files", "BlockPy encountered an error while listing the uploaded files.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_UPLOADING_FILE = function (reason) {
  this.show("Error Uploaded File", "BlockPy encountered an error while uploading the file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["partId", "part_id", "", "string", "The Part ID of an Assignment that this editor is responsible for. Assignments can have regions (\"Parts\") that behave independently to the user but all correspond to the same assignment on the backend. Blank corresponds to the full document. Note that most assignment settings will apply UNIVERSALLY across all parts, including the on_run.py and the other settings on this page."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle (and pygame) output is saved whenever the program uses it."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["hideTraceButton", "hide_trace_button", false, "bool", "If checked, then the Trace button is not shown."], ["smallLayout", "small_layout", false, "bool", "If checked, then the interface fits into a smaller region."], ["hasClock", "has_clock", false, "bool", "If checked, then a clock is shown in the top right corner."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-part-id\" class=\"col-sm-2 col-form-label text-right\">Part ID:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-part-id\"\n                data-bind=\"value: configuration.partId\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("partId"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/images.js":
/*!******************************!*\
  !*** ./src/editor/images.js ***!
  \******************************/
/*! exports provided: IMAGE_EDITOR_HTML, ImageEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_EDITOR_HTML", function() { return IMAGE_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageEditor", function() { return ImageEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var IMAGE_EDITOR_HTML = "\n     <div>\n        <h3>Available Images</h3>\n        \n        <button data-bind=\"click: ui.editors.images.reloadImages\">Reload Available Images</button>\n        <!-- ko if: display.uploadedFiles() !== null -->\n            <ul>\n                <!-- ko foreach: { data: Object.keys(display.uploadedFiles()), as: 'placement' } -->\n                <li>\n                    <strong data-bind=\"text: $data\"></strong>:\n                    <ul>\n                    <!-- ko foreach: { data: $root.display.uploadedFiles()[placement], as: 'filename' } -->\n                        <li>\n                            <span data-bind=\"text: filename[0]\"></span>:\n                            <img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                width=\"30px\" height=\"30px\"/>\n                        </li>\n                    <!-- /ko -->\n                    </ul>\n                </li>\n                <!-- /ko -->\n            </ul>\n        <!-- /ko -->\n    </div>\n";

var ImageEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ImageEditorView, _AbstractEditor);

  var _super = _createSuper(ImageEditorView);

  function ImageEditorView(main, tag) {
    _classCallCheck(this, ImageEditorView);

    return _super.call(this, main, tag);
  }

  _createClass(ImageEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ImageEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      var uploadedFiles = this.main.model.display.uploadedFiles();

      if (uploadedFiles === null) {
        this.reloadImages();
      }

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      /*
      this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
        // Notify relevant file of changes to BM
      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);*/
    }
  }, {
    key: "reloadImages",
    value: function reloadImages() {
      var _this = this;

      this.main.components.server.listUploadedFiles(function (response) {
        if (response.success) {
          _this.main.model.display.uploadedFiles(response.files);
        } else {
          _this.main.components.dialogs.ERROR_LISTING_UPLOADED_FILES(response.message);
        }
      });
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {}
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      /*this.dirty = !this.dirty;
      if (this.dirty) {
          this.dirty = true;
          this.file.handle(this.codeMirror.getValue());
          this.dirty = false;
      }*/
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();

      _get(_getPrototypeOf(ImageEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ImageEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ImageEditor = {
  name: "Image",
  extensions: ["?images.blockpy"],
  constructor: ImageEditorView,
  template: IMAGE_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface */ "./src/interface.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */



var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> <span data-bind=\"text: ui.execute.runLabel\"></span>\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() && !ui.smallLayout()-->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\" data-bind=\"hidden: ui.smallLayout\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\" data-bind=\"hidden: ui.smallLayout\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHook: function imageDownloadHook(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        //const uuid = window.URL.createObjectURL(new Blob([])).substring(31);
        return new Promise(function (resolve, reject) {
          var submissionId = main.model.submission.id();
          main.components.server.uploadFile("submission", submissionId, blob.name, blob, function (response) {
            resolve(JSON.stringify(response.endpoint)); //resolve(JSON.stringify(main.model.configuration.urls["downloadFile"] + `?placement=submission&directory=${submissionId}&filename=${blob.name}`));
          }); //return Promise.resolve("Image("+JSON.stringify(URL.createObjectURL(blob))+")");
          //return Promise.resolve(JSON.stringify(URL.createObjectURL(blob)));
        });
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        //return `Image("${oldUrl}")`;
        return "\"".concat(oldUrl, "\"");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.lineTraceSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
        this.lineTraceSubscription = this.main.model.ui.trace.highlightedLine.subscribe(function (lines) {
          _this3.bm.clearHighlightedLines("editor-traced-line");

          _this3.bm.setHighlightedLines(lines, "editor-traced-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }

      if (this.lineTraceSubscription) {
        this.lineTraceSubscription.dispose();
        this.lineTraceSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      }); // Small Layout Stuff

      this.oldHeight = null;

      if (this.main.model.ui.smallLayout()) {
        this.useSmallLayout();
      }

      this.main.model.ui.smallLayout.subscribe(function (useSmallLayout) {
        if (useSmallLayout) {
          _this4.useSmallLayout();
        } else if (_this4.oldHeight !== null) {
          _this4.bm.configuration.height = _this4.oldHeight;

          _this4.bm.textEditor.resizeResponsively();

          _this4.oldHeight = null;
        }
      });
    }
  }, {
    key: "useSmallLayout",
    value: function useSmallLayout() {
      this.bm.textEditor.updateGutter({
        indentSidebar: false
      });
      this.oldHeight = this.bm.configuration.height;
      this.bm.configuration.height = 300; // TODO: Parameterize this

      this.bm.textEditor.resizeResponsively();
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.configuration.partId.subscribe(function (changed) {// TODO: Handle part id changing after everything is loaded
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py", ".reading"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
/* harmony import */ var _editor_images__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./editor/images */ "./src/editor/images.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */










/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"], _editor_images__WEBPACK_IMPORTED_MODULE_9__["ImageEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "', class: ui.editors.width\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback()) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          _this2.configuration.provideSecretError();

          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // TODO: Make this set by the system so we can use our own servers in practice
        emojiProxy: function emojiProxy(part) {
          return "https://twemoji.maxcdn.com/v/13.1.0/svg/".concat(part.toLowerCase(), ".svg");
        },
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../files */ "./src/files.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found, but not __main__ modules

      this.sysmodules = this.clearExistingStudentImports(); // Horrific hack, to prevent Tifa from caching a bad version of the students' import

      Sk.clearExistingStudentImports = this.clearExistingStudentImports;
      return this;
    }
  }, {
    key: "print",
    value: function print(value) {
      _get(_getPrototypeOf(InstructorConfiguration.prototype), "print", this).call(this, value);

      console.info("Printed:", value);
    }
  }, {
    key: "clearExistingStudentImports",
    value: function clearExistingStudentImports() {
      var sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      if (sysmodules !== undefined) {
        var _iterator = _createForOfIteratorHelper(this.getAllFilenames()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var filename = _step.value;
            var skFilename = new Sk.builtin.str(filename);
            /*if (sysmodules.quick$lookup(skFilename)) {
                sysmodules.pop$item(skFilename);
            }*/

            sysmodules.pop$item(skFilename);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return sysmodules;
    }
  }, {
    key: "getAllStudentFiles",
    value: function getAllStudentFiles() {
      var files = {
        "answer.py": this.main.model.ui.files.getStudentCode()
      }; // Skip special instructor files

      this.main.model.assignment.extraInstructorFiles().forEach(function (file) {
        if (!"!^$#".includes(file.filename()[0])) {
          files[file.filename()] = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(file.contents());
        }
      }); // Include normal student extra files

      this.main.model.submission.extraFiles().forEach(function (file) {
        files[file.filename()] = file.contents();
      });
      return files;
    }
  }, {
    key: "getAllFilenames",
    value: function getAllFilenames() {
      function clean(filename) {
        filename = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(filename);

        if (filename.endsWith(".py")) {
          filename = filename.slice(0, -3);
        }

        return filename;
      }

      return ["__main__", "_instructor"].concat(_toConsumableArray(this.main.model.assignment.extraInstructorFiles().map(function (file) {
        return "_instructor." + clean(file.filename());
      })), _toConsumableArray(this.main.model.submission.extraFiles().map(function (file) {
        return clean(file.filename());
      })));
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      console.log(">>>", this.main.model.execution.input(), this.main.model.execution.inputIndex());

      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\n# MAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, "['evaluation'])\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(_on_run__WEBPACK_IMPORTED_MODULE_2__["INSTRUCTOR_MARKER"], "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";

      var studentFiles = this.getAllStudentFiles();
      studentFiles["evaluation"] = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      console.log(">>>", instructorCode);
      var lineOffset = Object(_on_run__WEBPACK_IMPORTED_MODULE_2__["findActualInstructorOffset"])(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: findActualInstructorOffset, INSTRUCTOR_MARKER, NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findActualInstructorOffset", function() { return findActualInstructorOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSTRUCTOR_MARKER", function() { return INSTRUCTOR_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function findActualInstructorOffset(instructorCode) {
  var index = instructorCode.indexOf(INSTRUCTOR_MARKER);
  var before = instructorCode.slice(0, index);
  var match = before.match(NEW_LINE_REGEX);
  return match ? 1 + match.length : 0;
}
var INSTRUCTOR_MARKER = "###Run the actual instructor code###";
var NEW_LINE_REGEX = /\n/g;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentFiles);
  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom bakery import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          files=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(INSTRUCTOR_MARKER, "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa(); // Put the input index back to the front, so we can replay inputs

      this.main.model.execution.inputIndex(1);
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentFiles = this.getAllStudentFiles();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      var lineOffset = findActualInstructorOffset(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;
      //lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode();

      if (this.main.model.assignment.settings.disableStudentRun()) {
        this.code = "";
      } //this.code = this.main.model.submission.code();


      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };

      if (typeof Sk.environ == "undefined") {
        Sk.environ = new Sk.builtin.dict();
      }

      var printerTag = this.main.components.console.printerTag,
          width = printerTag.width() - 50,
          height = Math.max(300, printerTag.height() - 50);
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_WIDTH"), new Sk.builtin.int_(width));
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_HEIGHT"), new Sk.builtin.int_(height));
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        if (Sk.builtinFiles && Sk.builtinFiles["files"][filename] !== undefined) {
          return Sk.builtinFiles["files"][filename];
        } else {
          throw new Sk.builtin.OSError("File not found: " + filename);
        }
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring, astName) {
      if (filename === "answer.py") {
        /*if (execStack) {
            console.log(execStack.map(([n, o]) => [n, {...o}]));
        }*/
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(_objectSpread(_objectSpread({}, globals), locals)); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring,
          "ast": astName
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear();
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\"\n            data-bind=\"class: ui.console.size\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <!-- ko ifnot: ui.secondRow.hideTraceButton -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    <!-- /ko -->\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n        <small data-bind=\"click: ui.feedback.resetScore,\n                          visible: display.instructor() && execution.feedback.label() && submission.score() > 0\"\n            class=\"text-muted\" style=\"cursor: pointer\"><u>(reset)</u></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 700);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      this.feedbackModel.message("*Ready*");
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);

        if (this.shouldScrollIntoView()) {
          this.scrollIntoView();
        }
      }
    }
  }, {
    key: "shouldScrollIntoView",
    value: function shouldScrollIntoView() {
      return !this.main.model.ui.smallLayout();
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this4 = this;

      return error.traceback.map(function (frame) {
        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, chompSpecialFile, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chompSpecialFile", function() { return chompSpecialFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible, class: ui.files.width\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?images.blockpy'),\n                           click: ui.files.add.bind($data, '?images.blockpy')\">Images</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
function chompSpecialFile(filename) {
  if ("!^?&$*#".includes(filename[0])) {
    return filename.slice(1);
  } else {
    return filename;
  }
}
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(filename, _contents) {
  return {
    filename: function (_filename) {
      function filename() {
        return _filename.apply(this, arguments);
      }

      filename.toString = function () {
        return _filename.toString();
      };

      return filename;
    }(function () {
      return filename;
    }),
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var _filename2 in files) {
      if (files.hasOwnProperty(_filename2)) {
        modelFiles.push(makeModelFile(_filename2, files[_filename2]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    if (modelFileList) {
      modelFileList(modelFiles);
    } else {
      return modelFiles;
    }
  } else {
    if (modelFileList) {
      modelFileList([]);
    } else {
      return [];
    }
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.main.model.display.instructor.subscribe(function (visiblity) {
      $(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "renameFile",
    value: function renameFile(source, destination) {
      if (UNRENAMABLE_FILES.indexOf(source) !== -1) {
        return false;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(hiddenVersion, defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row' data-bind=\"hidden: ui.smallLayout()\">\n         \n         <!-- Description -->\n         <div class='col-md-9 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-3 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <!-- Fullscreen button -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\">\n                <span class='fas' data-bind=\"class: ui.menu.textFullscreen\"></span>\n            </button>\n            <!-- Edit Queued Inputs -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\">\n                <span class='fas fa-list-alt'></span>\n            </button>\n            <!-- Toggle Image Rendering -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-toggle=\"button\"\n                data-bind=\"click: ui.menu.toggleImages\" title=\"Toggle Images\">\n                <span class=\"fas fa-images\"></span>\n            </button>\n            <!-- Pink Bug for actual errors -->\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n            <span data-bind=\"hidden: ui.menu.showClock\" class=\"blockpy-menu-clock\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- ko if: ui.smallLayout() -->\n    <!-- Small layout View as instructor -->\n    <div class=\"form-check\"\n         data-bind=\"visible: ui.role.isGrader\">\n        <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n            data-bind=\"checked: display.instructor\">\n        <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n            View as instructor\n        </label>\n    </div>\n    <!-- ko if: ui.files.visible() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    <!-- /ko -->\n    \n    <div class='row'>\n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div data-bind=\"class: ui.secondRow.width\">\n    <div class='row'>\n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n    </div>\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible() && !ui.smallLayout() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    \n    </div>\n    \n    \n    <!-- Row 5: Footer Row -->    \n    <!-- ko if: ui.footer.visible -->\n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var configuration = this.main.model.configuration;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode(),
    "part_id": configuration.partId()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  var extraSettings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  this.showOverlay(attempts);
  return $.ajax(_objectSpread({
    type: "POST",
    url: this.urls[endpoint],
    data: data
  }, extraSettings)).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.listUploadedFiles = function (callback) {
  var _this10 = this;

  if (this.main.model.ui.server.isEndpointConnected("listUploadedFiles")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("listUploadedFiles", data, 2, callback, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_LISTING_UPLOADED_FILES(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.uploadFile = function (placement, directory, filename, contents, callback) {
  var _this11 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("uploadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    data["contents"] = contents;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("uploadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this11.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this12 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this12.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this12.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this13 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this13._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this13.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this13.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  mod.clear_existing_student_imports = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    Sk.clearExistingStudentImports();
  });
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/weakref.js":
/*!***************************************!*\
  !*** ./src/skulpt_modules/weakref.js ***!
  \***************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "weakref"
  };
  /*mod.WeakSet = Sk.abstr.buildNativeClass("weakref.WeakSet", {
      constructor: function WeakSet()
  });*/

  var WeakSet = function WeakSet($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, data) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("data", "iterable", Sk.builtin.checkIterable(data));
      self.data = [];
      var iter = Sk.abstr.iter(data);
      var next;

      do {
        next = Sk.abstr.iternext(iter);

        if (next !== undefined) {
          self.data.push(new WeakRef(next));
        }
      } while (next !== undefined);

      return Sk.builtin.none.none$;
    });
    $loc.__iter__ = new Sk.builtin.func(function (self) {
      var viewOfData = [];

      for (var i = 0; i < self.data.length; i++) {
        var item = self.data[i].deref();

        if (item !== undefined) {
          viewOfData.push(item);
        }
      }

      self.data = viewOfData;
      return Sk.abstr.iter(new Sk.builtin.list(viewOfData));
    });
    /*$loc.next$ = new Sk.builtin.func(function (self) {
        return self.tp$iter();
    });*/

    $loc.add = new Sk.builtin.func(function (self, item) {
      self.data.push(new WeakRef(item));
    });
  };

  mod.WeakSet = Sk.misceval.buildClass(mod, WeakSet, "WeakSet", []);
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, AST_DESCRIPTIONS, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AST_DESCRIPTIONS", function() { return AST_DESCRIPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    <p data-bind=\"text: ui.trace.ast\"></p>\n    <p>Variables after this step:</p>\n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var AST_DESCRIPTIONS = {
  "Add": "An addition operator",
  "And": "A boolean AND operator",
  "AnnAssign": "An annotated assignment",
  "Assert": "An assert statement",
  "Assign": "An assignment statement",
  "AsyncFor": "An asychronous for loop",
  "AsyncFunctionDef": "An asychronous function definition",
  "AsyncWith": "An asychronous with statement",
  "Attribute": "An attribute lookup (access a field)",
  "AugAssign": "An augmented assignment",
  "AugLoad": "An augmented load",
  "AugStore": "An augmented store",
  "Await": "An await statement",
  "BinOp": "A binary operator",
  "BitAnd": "A bitwise AND operator",
  "BitOr": "A bitwise OR operator",
  "BitXor": "A bitwise XOR operator",
  "BoolOp": "A boolean operator",
  "Break": "A break statement",
  "Bytes": "A literal bytes string",
  "Call": "A function call",
  "ClassDef": "A class definition",
  "Compare": "A boolean comparison",
  "Constant": "A literal value",
  "Continue": "A continue statement",
  "Del": "A delete statement",
  "Delete": "A deletion",
  "Dict": "A dictionary literal",
  "DictComp": "A dictionary comprehension",
  "Div": "A division operator",
  "Ellipsis": "An ellipsis",
  "Eq": "An equality comparison operator",
  "ExceptHandler": "An except handler",
  "Expr": "An expression used as a statement",
  "Expression": "An evaluated expression",
  "ExtSlice": "A multi-dimensional slice",
  "FloorDiv": "An integer division operator",
  "For": "A FOR loop",
  "FormattedValue": "A formatted value in an f-string",
  "FunctionDef": "A function definition",
  "GeneratorExp": "A generator expression",
  "Global": "A global statement",
  "Gt": "A greater than comparison operator",
  "GtE": "A greater than or equal to comparison operator",
  "If": "An IF statement",
  "IfExp": "An IF expression",
  "Import": "An import statement",
  "ImportFrom": "An import/from statement",
  "In": "An IN operator",
  "Index": "An index",
  "Interactive": "An interactive expression",
  "Invert": "An invert operator",
  "Is": "An IS operator",
  "IsNot": "An IS NOT operator",
  "JoinedStr": "An f-string",
  "LShift": "A left shift operator",
  "Lambda": "A lambda expression",
  "List": "A list literal",
  "ListComp": "A list comprehension",
  "Load": "A load",
  "Lt": "A less than comparison operator",
  "LtE": "A less than or equal to comparison operator",
  "MatMult": "A matrix multiplication operator",
  "Mod": "A modulo operator",
  "Module": "A module",
  "Mult": "A multiplication operator",
  "Name": "A name",
  "NameConstant": "A name constant",
  "Nonlocal": "A nonlocal statement",
  "Not": "A not operator",
  "NotEq": "A not equal to comparison operator",
  "NotIn": "A NOT IN operator",
  "Num": "A numeric literal",
  "Or": "A boolean OR operator",
  "Param": "A parameter",
  "Pass": "A pass statement",
  "Pow": "A power operator",
  "RShift": "A right shift operator",
  "Raise": "A raise statement",
  "Return": "A return statement",
  "Set": "A set literal",
  "SetComp": "A set comprehension",
  "Slice": "A slice",
  "Starred": "A starred argument",
  "Store": "A store",
  "Str": "A string literal",
  "Sub": "A subtraction operator",
  "Subscript": "A subscript",
  "Suite": "A suite",
  "Try": "A try statement",
  "Tuple": "A tuple literal",
  "TypeIgnore": " a type ignore",
  "UAdd": "A unary addition operator",
  "USub": "A unary subtraction operator",
  "UnaryOp": "A unary operator",
  "While": "A while loop",
  "With": "A with statement",
  "Yield": "A yield statement",
  "YieldFrom": "A yield/from statement"
};
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod", "$free", "$cell"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = []; //console.log(variables);

      if (!this.main.model.display.traceExecution()) {
        /*if ("$cell" in variables) {
            variables = {...variables, ...variables.$cell};
        }*/

        /*if ("$free" in variables) {
            variables = {...variables, ...variables.$free};
        }*/
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1 && value !== undefined) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (property) {
        case "dataclass":
          return {
            name: property,
            type: "Decorator",
            value: "<dataclass decorator>"
          };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Parameters: " + value.func_code.co_varnames.join(", ") : " No parameters"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue, extractPart, getCurrentTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractPart", function() { return extractPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentTime", function() { return getCurrentTime; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}

var DEFAULT_SECTION_PATTERN = /^(##### Part (.+))$/gm;
/**
 * Finds the given Part ID using the pattern `#### Part whatever` (on its own separate line). If the pattern
 * is not found, then null is returned. If no pattern is given (empty string or null), then the original text
 * is returned without modifications.
 * @param text
 * @param partId
 * @returns {null|*}
 */

function extractPart(text, partId) {
  if (partId === "" || partId == null) {
    return text;
  }

  var parts = text.split(DEFAULT_SECTION_PATTERN);

  for (var i = 2; i < parts.length; i += 3) {
    /* // Unnecessary assertion, but not bad to think about
    if (!parts[i-1].startsWith("#### Part ")) {
        throw "Error: part format is broken!";
    }*/
    if (parts[i] === partId) {
      var body = parts[i + 1];

      if (body && body[0] === "\n") {
        body = body.slice(1);
      }

      if (i !== parts.length - 3 && body && body.slice(-1) === "\n") {
        body = body.slice(0, -1);
      }

      return body;
    }
  }

  return null;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/

function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

function getCurrentTime() {
  var today = new Date();
  var h = Math.floor(today.getHours() % 12);
  var m = today.getMinutes(); //let s = today.getSeconds();

  if (m < 10) {
    m = "0" + m;
  } //if (s < 10) {s = "0" + s;}


  var p = "am";

  if (today.getHours() >= 12) {
    p = "pm";
  }

  return "".concat(h, ":").concat(m).concat(p);
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9qc29uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL21hcmtkb3duLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3B5dGhvbi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9xdWl6LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy93ZWFrcmVmLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3RyYWNlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwia29cIiJdLCJuYW1lcyI6WyJFRElUT1JfVkVSU0lPTiIsIkJsb2NrUHkiLCJjb25maWd1cmF0aW9uIiwiYXNzaWdubWVudCIsInN1Ym1pc3Npb24iLCJpbml0TW9kZWwiLCJ1bmRlZmluZWQiLCJzZXRBc3NpZ25tZW50IiwiaW5pdE1haW4iLCJpbml0VXRpbGl0aWVzIiwiaW5pdE1vZGVsTWV0aG9kcyIsInR1cm5PbkhhY2tzIiwiaW5pdEludGVyZmFjZSIsImFwcGx5TW9kZWwiLCJpbml0Q29tcG9uZW50cyIsIm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMiLCJzdGFydCIsImtleSIsImRlZmF1bHRWYWx1ZSIsImluaXRpYWxDb25maWd1cmF0aW9uXyIsImxvY2FsU2V0dGluZ3NfIiwiaGFzIiwiZ2V0IiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsIm1vZGVsIiwidXNlciIsImlkIiwia28iLCJvYnNlcnZhYmxlIiwibmFtZSIsInJvbGUiLCJnZXRTZXR0aW5nIiwiY291cnNlSWQiLCJncm91cElkIiwiaW5zdHJ1Y3Rpb25zIiwidXJsIiwidHlwZSIsIkFzc2lnbWVudFR5cGUiLCJCTE9DS1BZIiwicG9pbnRzIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYVN0YXJ0aW5nRmlsZXMiLCJmb3JrZWRJZCIsImZvcmtlZFZlcnNpb24iLCJvd25lcklkIiwidmVyc2lvbiIsInRhZ3MiLCJzYW1wbGVTdWJtaXNzaW9ucyIsInJldmlld2VkIiwiaGlkZGVuIiwiaXBSYW5nZXMiLCJzZXR0aW5ncyIsIm1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbCIsImNvZGUiLCJleHRyYWN0UGFydCIsImV4dHJhRmlsZXMiLCJlbmRwb2ludCIsInNjb3JlIiwiY29ycmVjdCIsInN1Ym1pc3Npb25TdGF0dXMiLCJncmFkaW5nU3RhdHVzIiwiZGlzcGxheSIsImZpbGVuYW1lIiwiaW5zdHJ1Y3RvciIsIm11dGVQcmludGVyIiwicHl0aG9uTW9kZSIsIkRpc3BsYXlNb2RlcyIsIlRFWFQiLCJoaXN0b3J5TW9kZSIsImF1dG9TYXZlIiwiYmlnQ29uc29sZSIsInByZXZpb3VzQ29uc29sZUhlaWdodCIsImN1cnJlbnRDb25zb2xlSGVpZ2h0Iiwic2Vjb25kUm93U2Vjb25kUGFuZWwiLCJTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMiLCJGRUVEQkFDSyIsInByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWwiLCJ0cmFjZUV4ZWN1dGlvbiIsImxvYWRpbmdEYXRhc2V0cyIsImNoYW5nZWRJbnN0cnVjdGlvbnMiLCJ0cmlnZ2VyT25DaGFuZ2UiLCJkaXJ0eVN1Ym1pc3Npb24iLCJmdWxsc2NyZWVuIiwicGFzc2NvZGUiLCJjbGVhcklucHV0cyIsInJlbmRlckltYWdlcyIsImVkaXRvclZlcnNpb24iLCJyZWFkT25seSIsInRvU3RyaW5nIiwidXBsb2FkZWRGaWxlcyIsImJhY2t1cFN1Ym1pc3Npb25Db2RlIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsImxpc3RVcGxvYWRlZEZpbGVzIiwibGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlIiwiZG93bmxvYWRGaWxlIiwiZG93bmxvYWRGaWxlTWVzc2FnZSIsInVwbG9hZEZpbGUiLCJ1cGxvYWRGaWxlTWVzc2FnZSIsIm9uRXhlY3V0aW9uIiwiZXhlY3V0aW9uIiwicmVwb3J0cyIsIm91dHB1dCIsImlucHV0IiwiaW5wdXRJbmRleCIsInN0dWRlbnQiLCJjdXJyZW50U3RlcCIsImxhc3RTdGVwIiwiY3VycmVudExpbmUiLCJsYXN0TGluZSIsImN1cnJlbnRUcmFjZURhdGEiLCJjdXJyZW50VHJhY2VTdGVwIiwicmVzdWx0cyIsImdsb2JhbHMiLCJjYWxscyIsInN5c21vZHVsZXMiLCJmZWVkYmFjayIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxhYmVsIiwibGluZXNFcnJvciIsImxpbmVzVW5jb3ZlcmVkIiwiY2FsbGJhY2tzIiwic2VydmVyQ29ubmVjdGVkIiwiYmxvY2tseVBhdGgiLCJhdHRhY2htZW50UG9pbnQiLCJjb250YWluZXIiLCJ1cmxzIiwicGFydElkIiwiY29uc3RhbnRzIiwiZ3VpIiwibWFrZUludGVyZmFjZSIsIiQiLCJodG1sIiwiYXNzaWdubWVudF9pZCIsImNvbXBvbmVudHMiLCJzZXJ2ZXIiLCJzYW1wbGVzIiwic3RhcnRpbmdfY29kZSIsImV4dHJhX3N0YXJ0aW5nX2ZpbGVzIiwibG9hZE5vU3VibWlzc2lvbiIsImdyYWRpbmdfc3RhdHVzIiwiU3VibWlzc2lvblN0YXR1c2VzIiwiVU5LTk9XTiIsInN1Ym1pc3Npb25fc3RhdHVzIiwidXNlcl9pZCIsImNvdXJzZV9pZCIsImV4dHJhX2ZpbGVzIiwiZGF0YSIsImNvbnNvbGUiLCJkZWJ1ZyIsInJlc2V0SW50ZXJmYWNlIiwiZmlsZVN5c3RlbSIsImRpc21vdW50RXh0cmFGaWxlcyIsIndhc1NlcnZlckNvbm5lY3RlZCIsImZvcmtlZF9pZCIsImZvcmtlZF92ZXJzaW9uIiwiaXBfcmFuZ2VzIiwib25fY2hhbmdlIiwibmV3RmlsZSIsIm9uX2V2YWwiLCJvbl9ydW4iLCJvd25lcl9pZCIsImxvYWRUYWdzIiwibG9hZFNhbXBsZVN1Ym1pc3Npb25zIiwic2FtcGxlX3N1Ym1pc3Npb25zIiwiZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcyIsImxvYWRBc3NpZ25tZW50U2V0dGluZ3MiLCJsb2FkU3VibWlzc2lvbiIsImNvcmdpcyIsImxvYWREYXRhc2V0cyIsInB5dGhvbkVkaXRvciIsImJtIiwicmVmcmVzaCIsInNldFN0YXR1cyIsInNlbGYiLCJ1aSIsInNtYWxsTGF5b3V0IiwicHVyZUNvbXB1dGVkIiwiaXNHcmFkZXIiLCJpc0NoYW5nZWQiLCJjdXJyZW50IiwidXRpbGl0aWVzIiwibWFya2Rvd24iLCJyZXNldCIsIm1lbnUiLCJ2aXNpYmxlIiwib25seUludGVyYWN0aXZlIiwidGV4dEZ1bGxzY3JlZW4iLCJjbGlja0Z1bGxzY3JlZW4iLCJlZGl0SW5wdXRzIiwiZGlhbG9nIiwiRURJVF9JTlBVVFMiLCJ0b2dnbGVJbWFnZXMiLCJ0ZXh0RWRpdG9yIiwiZGlzYWJsZUltYWdlcyIsImVuYWJsZUltYWdlcyIsImNhbk1hcmtTdWJtaXR0ZWQiLCJjYW5DbG9zZSIsInRleHRNYXJrU3VibWl0dGVkIiwiaXNDb21wbGV0ZWQiLCJpc1N1Ym1pdHRlZCIsImNsaWNrTWFya1N1Ym1pdHRlZCIsImFsZXJ0IiwiZW5naW5lIiwiZGVsYXllZFJ1biIsInRvTG93ZXJDYXNlIiwic2hvd1F1ZXVlZElucHV0cyIsImhpZGVRdWV1ZWRJbnB1dHMiLCJzaG93Q2xvY2siLCJoYXNDbG9jayIsInNlY29uZFJvdyIsIndpZHRoIiwiaGlkZVRyYWNlQnV0dG9uIiwiaXNBbGxWaXNpYmxlIiwiaGlkZU1pZGRsZVBhbmVsIiwiaXNGZWVkYmFja1Zpc2libGUiLCJpc1RyYWNlVmlzaWJsZSIsIlRSQUNFIiwiaXNDb25zb2xlU2hvd1Zpc2libGUiLCJzd2l0Y2hMYWJlbCIsImFkdmFuY2VTdGF0ZSIsImN1cnJlbnRQYW5lbCIsIk5PTkUiLCJtYWtlV2lkZSIsInJlc3RvcmVQYW5lbCIsIm9sZFBhbmVsIiwic2l6ZSIsImhpZGVFdmFsdWF0ZSIsIkFDVElWRSIsImJhZGdlIiwicmVzZXRTY29yZSIsInRyYWNlIiwiaGlnaGxpZ2h0ZWRMaW5lIiwic3RlcCIsInRyYWNlRGF0YSIsImxpbmUiLCJhc3QiLCJBU1RfREVTQ1JJUFRJT05TIiwiZmlyc3QiLCJiYWNrd2FyZCIsInByZXZpb3VzIiwiTWF0aCIsIm1heCIsImZvcndhcmQiLCJuZXh0IiwibWluIiwibGFzdCIsImZpbGVzIiwiaGlkZUZpbGVzIiwiaGFzQ29udGVudHMiLCJwYXRoIiwic29tZSIsImZpbGUiLCJsZW5ndGgiLCJhZGQiLCJub3JtYWxUb29sYm94IiwiYmxvY2tFZGl0b3IiLCJUT09MQk9YRVMiLCJKU09OIiwic3RyaW5naWZ5IiwiU2FtcGxlU3VibWlzc2lvbiIsIkJsYW5rIiwibmV3RmlsZURpYWxvZyIsImRlbGV0ZUZpbGUiLCJyZW5hbWUiLCJuZXdOYW1lIiwicmVuYW1lRmlsZSIsImdldFN0dWRlbnRDb2RlIiwicHJlZml4UHkiLCJnZXRGaWxlIiwic3VmZml4UHkiLCJoYW5kbGUiLCJleHRyYVN0dWRlbnRGaWxlcyIsIm9ic2VydmVDb25jYXRlbmF0ZWRGaWxlIiwiZGlzcGxheUZpbGVuYW1lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWRpdG9ycyIsImdldEVkaXRvciIsInZpZXciLCJoaWRlRWRpdG9ycyIsIm1hcCIsInN1YnN0ciIsIm1ha2VNb2RlbEZpbGUiLCJjb250ZW50cyIsImNhblNhdmUiLCJjYW5EZWxldGUiLCJVTkRFTEVUQUJMRV9GSUxFUyIsImluZGV4T2YiLCJjYW5SZW5hbWUiLCJVTlJFTkFNQUJMRV9GSUxFUyIsInVwbG9hZCIsImJpbmQiLCJkb3dubG9hZCIsImltcG9ydERhdGFzZXQiLCJvcGVuRGlhbG9nIiwicHl0aG9uIiwiY29kZU1pcnJvciIsInNldE9wdGlvbiIsImdldE9wdGlvbiIsInVwZGF0ZU1vZGUiLCJuZXdNb2RlIiwib2xkUHl0aG9uTW9kZSIsImlzSGlzdG9yeUF2YWlsYWJsZSIsImlzRW5kcG9pbnRDb25uZWN0ZWQiLCJ0dXJuT2ZmSGlzdG9yeU1vZGUiLCJ1cGRhdGVFZGl0b3IiLCJzZXRSZWFkT25seSIsInR1cm5Pbkhpc3RvcnlNb2RlIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiaGlzdG9yeSIsImxvYWQiLCJFUlJPUl9MT0FESU5HX0hJU1RPUlkiLCJ0b2dnbGVIaXN0b3J5TW9kZSIsIm1vdmVUb1N0YXJ0IiwibW92ZVByZXZpb3VzIiwibW92ZU5leHQiLCJtb3N0UmVjZW50IiwibW92ZVRvTW9zdFJlY2VudCIsInVzZSIsImltYWdlcyIsInJlbG9hZEltYWdlcyIsImJ5TmFtZSIsInNhdmUiLCJidWlsZEVkaXRvciIsIm5ld0RPTSIsImluZGV4IiwibmV3RWxlbWVudCIsImVkaXRvciIsImV4ZWN1dGUiLCJpc1J1bm5pbmciLCJydW5MYWJlbCIsInJ1biIsIlB5Z2FtZUxpYiIsInJ1bm5pbmciLCJTdG9wUHlnYW1lIiwiZXZhbHVhdGUiLCJtZXNzYWdlcyIsImNhcGl0YWxpemUiLCJmb3JjZSIsImV2ZW50IiwiYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbiIsInRhcmdldCIsInBhcmVudCIsImZhZGVPdXQiLCJmYWRlSW4iLCJmciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwiYXNzaWdubWVudFN1Ym1pc3Npb24iLCJwYXJzZSIsInJlc3VsdCIsImxvYWRBc3NpZ25tZW50RGF0YV8iLCJmaWxlTmFtZSIsInJlYWRBc1RleHQiLCJ2YWwiLCJsb2ciLCJmb290ZXIiLCJtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zIiwiU2siLCJidWlsdGluRmlsZXMiLCJpbWFnZU1vZHVsZSIsImFwcGx5QmluZGluZ3MiLCJtYWluIiwidGV4dCIsIkVhc3lNREUiLCJwcm90b3R5cGUiLCJCbG9ja1B5RGlhbG9nIiwiZmluZCIsIkJsb2NrUHlGZWVkYmFjayIsIkJsb2NrUHlUcmFjZSIsIkJsb2NrUHlDb25zb2xlIiwiQmxvY2tQeUVuZ2luZSIsIkJsb2NrUHlGaWxlU3lzdGVtIiwiRWRpdG9ycyIsIkJsb2NrUHlTZXJ2ZXIiLCJCbG9ja1B5Q29yZ2lzIiwiQmxvY2tQeUhpc3RvcnkiLCJzaG93IiwiaGlkZSIsInN1YnNjcmliZSIsImNoYW5nZWQiLCJjbG9jayIsInVwZGF0ZUNsb2NrIiwiZ2V0Q3VycmVudFRpbWUiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJhbHRMb2dFbnRyeSIsInVzZXJTdXBwbGllZFBhc3Njb2RlIiwicHJvbXB0IiwiU1RBUlRfRVZBTF9IVE1MIiwiTkVXX0NPTlNPTEVfTElORV9IVE1MIiwiQ09OU09MRV9IVE1MIiwiQ29uc29sZUxpbmVUeXBlIiwiSFRNTCIsIlBMT1QiLCJJTUFHRSIsIlBZR0FNRSIsIlRVUlRMRSIsIkVWQUwiLCJTVEFSVF9FVkFMIiwiVkFMVUUiLCJJTlBVVCIsIlRFU1RfQ0FTRSIsIkNvbnNvbGVMaW5lIiwiY29udGVudCIsIm9yaWdpbiIsImN1cnJGaWxlbmFtZSIsImV4ZWN1dGlvbkJ1ZmZlciIsImZmaSIsInJlbWFwVG9QeSIsInJlbW92ZSIsIkNvbnNvbGVMaW5lVHVydGxlIiwiYWRkQ2xhc3MiLCJ3aGVyZSIsInByZXBlbmQiLCJ0b3AiLCJvZmZzZXQiLCJzY3JvbGxUb3AiLCJDb25zb2xlTGluZVB5Z2FtZSIsInB5Z2FtZU9iaiIsImluaXRpYWxpemVkIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kIiwiY2xlYW51cCIsImNsZWFudXBGdW5jdGlvbiIsImxpc3RlbmVycyIsIkNvbnNvbGVMaW5lSW1hZ2UiLCJDb25zb2xlTGluZVBsb3QiLCJDb25zb2xlTGluZVRleHQiLCJlbmNvZGVkVGV4dCIsImVuY29kZUhUTUwiLCJ0cmltIiwibGluZURhdGEiLCJ0b29sdGlwIiwiQ29uc29sZUxpbmVWYWx1ZSIsIkNvbnNvbGVMaW5lSW5wdXQiLCJwcm9tcHRNZXNzYWdlIiwiaW5wdXRGb3JtIiwiaW5wdXRCdG4iLCJpbnB1dEdyb3VwIiwiaW5wdXRCb3giLCJpbnB1dE1zZyIsIm1ha2VJbnRlcmFjdGl2ZSIsImJ1dHRvbiIsInJlc29sdmVPbkNsaWNrIiwic3VibWl0dGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3VibWl0Rm9ybSIsInVzZXJJbnB1dHRlZFZhbHVlIiwicXVldWVkSW5wdXQiLCJwdXNoIiwicHJvcCIsImNsaWNrIiwia2V5dXAiLCJrZXlDb2RlIiwiZm9jdXMiLCJDb25zb2xlTGluZUV2YWx1YXRlIiwiQ29uc29sZUxpbmVTdGFydEV2YWx1YXRlIiwidGFnIiwicHJpbnRlclRhZyIsIk1JTklNVU1fV0lEVEgiLCJNSU5JTVVNX0hFSUdIVCIsIkRFRkFVTFRfSEVJR0hUIiwiaGVpZ2h0IiwiY2xlYXIiLCJyZW1vdmVBbGwiLCJsaW5lQnVmZmVyIiwicGxvdEJ1ZmZlciIsImVtcHR5IiwidHVydGxlTGluZSIsIlR1cnRsZUdyYXBoaWNzIiwiZ2V0VHVydGxlTGluZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiYXNzZXRzIiwibG9hZEFzc2V0IiwicHlnYW1lTGluZSIsInJlbmRlciIsImN1cnJlbnRQcmludGVyRGltZW5zaW9uIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJzYXZlVHVydGxlT3V0cHV0IiwiZGF0YVVybCIsInRvRGF0YVVSTCIsInBhZ2UiLCJlYWNoIiwiYXR0ciIsImxpbmVUZXh0IiwiZmx1c2giLCJjaGFyQXQiLCJzcGxpdExpbmVzIiwic3BsaXQiLCJhZGRDb250ZW50IiwiaSIsInBsb3RzIiwiaW1hZ2VEYXRhIiwiaW1hZ2UiLCJpbWFnZUJ1ZmZlciIsInZhbHVlIiwicHJpbnRlZFZhbHVlIiwiaW5wdXRCdWZmZXIiLCJzdGFydEV2YWx1YXRpb24iLCJhbmltYXRlIiwiX0lNUE9SVEVEX0RBVEFTRVRTIiwiX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTIiwic2V0QnV0dG9uTG9hZGVkIiwiYnRuIiwicmVtb3ZlQ2xhc3MiLCJsb2FkZWREYXRhc2V0cyIsInNpbGVudGx5IiwiaW1wb3J0cyIsImRhdGFzZXRzIiwiZm9yRWFjaCIsIkJsb2NrTWlycm9yQmxvY2tFZGl0b3IiLCJFWFRSQV9UT09MUyIsImFwcGx5Iiwic2x1ZyIsIndoZW4iLCJkb25lIiwiZm9yY2VCbG9ja1JlZnJlc2giLCJyZW1ha2VUb29sYm94IiwiZmFpbCIsImFyZ3VtZW50cyIsImVycm9yIiwiYWx3YXlzIiwiZmluYWxpemVTdWJzY3JpcHRpb25zIiwidXJsX3JldHJpZXZhbHMiLCJyb290IiwiaW1wb3J0RGF0YXNldHMiLCJnZXREYXRhc2V0IiwiZ2V0U2NyaXB0IiwiZ2V0Q29tcGxldGUiLCJnZXRTa3VscHQiLCJnZXRCbG9ja2x5IiwidGV4dFRvQmxvY2tzIiwiaGlkZGVuSW1wb3J0cyIsImdldEpTT04iLCJibG9ja3B5IiwiZG9jdW1lbnRhdGlvbiIsImJvZHkiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsInNsdWdnZWROYW1lIiwidGl0bGVOYW1lIiwiaW1nU3JjIiwidGl0bGUiLCJvdmVydmlldyIsImFwcGVuZFRvIiwiRElBTE9HX0hUTUwiLCJ0aXRsZVRhZyIsImJvZHlUYWciLCJmb290ZXJUYWciLCJva2F5QnV0dG9uIiwiY2xvc2VCdXR0b24iLCJ5ZXMiLCJubyIsIm1vZGFsIiwiY2xvc2UiLCJvbmNsb3NlIiwiZHJhZ2dhYmxlIiwib24iLCJjb25maXJtIiwieWVzVGV4dCIsIkFTU0lHTk1FTlRfVkVSU0lPTl9DSEFOR0VEIiwiRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCIsInJlYXNvbiIsIkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMiLCJFUlJPUl9VUExPQURJTkdfRklMRSIsIkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCIsIkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUiIsIlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwiLCJTQ1JFRU5TSE9UX0JMT0NLUyIsIkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTIiwiT0ZGRVJfRk9SSyIsInNldHVwVXJsIiwiaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwIiwiaW5wdXRUZXh0Iiwiam9pbiIsImNoZWNrZWQiLCJpbnB1dHMiLCJmaWxlUmVhZGVyIiwic2x1Z2dpZnkiLCJyZXBsYWNlIiwiZXh0ZW5zaW9uIiwibWltZXR5cGUiLCJibG9iIiwiQmxvYiIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm1zU2F2ZU9yT3BlbkJsb2IiLCJtc1NhdmVCbG9iIiwidGVtcG9yYXJ5RG93bmxvYWRMaW5rIiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJBYnN0cmFjdEVkaXRvciIsImNoYW5nZUVkaXRvciIsIndhdGNoRmlsZSIsInVwZGF0ZWQiLCJvbkZpbGVVcGRhdGVkIiwiZGVsZXRlZCIsIm9uRmlsZURlbGV0ZWQiLCJuZXdGaWxlbmFtZSIsIm9sZEVkaXRvciIsInRyYWNrQ3VycmVudEZpbGUiLCJuZXdFZGl0b3IiLCJzdG9wV2F0Y2hpbmdGaWxlIiwicGFyc2VGaWxlbmFtZSIsIkFTU0lHTk1FTlRfU0VUVElOR1MiLCJNQVpFIiwiUVVJWiIsIlJFQURJTkciLCJnZXREb2N1bWVudGF0aW9uIiwibWFrZVN0YXJ0Vmlld1RhYiIsImljb24iLCJtb2RlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19CT09MRUFOX0NPTVBPTkVOVFNfSFRNTCIsImZpbHRlciIsInNldHRpbmciLCJwcmV0dHlOYW1lIiwid29yZCIsInRvVXBwZXJDYXNlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCIsIkJMT0NLIiwiU1BMSVQiLCJzYXZlQXNzaWdubWVudFNldHRpbmdzIiwiY2xpZW50TmFtZSIsInNlcnZlck5hbWUiLCJzdGFydF92aWV3IiwiZmllbGRUeXBlIiwiY29uZmlnVmFsdWUiLCJBc3NpZ25tZW50U2V0dGluZ3NWaWV3IiwiZGlydHkiLCJjdXJyZW50TGlzdGVuZXIiLCJ1cGRhdGVIYW5kbGUiLCJuZXdDb250ZW50cyIsIkFzc2lnbm1lbnRTZXR0aW5ncyIsImV4dGVuc2lvbnMiLCJjb25zdHJ1Y3RvciIsInRlbXBsYXRlIiwiZGVmYXVsdF9oZWFkZXIiLCJJTUFHRV9FRElUT1JfSFRNTCIsIkltYWdlRWRpdG9yVmlldyIsImN1cnJlbnRTdWJzY3JpcHRpb24iLCJkaWFsb2dzIiwiZGlzcG9zZSIsIkltYWdlRWRpdG9yIiwiSlNPTl9FRElUT1JfSFRNTCIsIkpzb25FZGl0b3JWaWV3IiwiQ29kZU1pcnJvciIsImZyb21UZXh0QXJlYSIsInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nIiwibGluZU51bWJlcnMiLCJmaXJzdExpbmVOdW1iZXIiLCJpbmRlbnRVbml0IiwidGFiU2l6ZSIsImluZGVudFdpdGhUYWJzIiwiZXh0cmFLZXlzIiwiY20iLCJibHVyIiwic2V0VGltZW91dCIsInNldFZhbHVlIiwiZ2V0VmFsdWUiLCJvZmYiLCJKc29uRWRpdG9yIiwiTUFSS0RPV05fRURJVE9SX0hUTUwiLCJNYXJrZG93bkVkaXRvclZpZXciLCJtZGUiLCJlbGVtZW50IiwiYXV0b0Rvd25sb2FkRm9udEF3ZXNvbWUiLCJmb3JjZVN5bmMiLCJtaW5IZWlnaHQiLCJyZW5kZXJpbmdDb25maWciLCJjb2RlU3ludGF4SGlnaGxpZ2h0aW5nIiwiY29kZW1pcnJvciIsIk1hcmtkb3duRWRpdG9yIiwibWFrZVRhYiIsIlBZVEhPTl9FRElUT1JfSFRNTCIsIkhJU1RPUllfVE9PTEJBUl9IVE1MIiwiY29udmVydElweW5iVG9QeXRob24iLCJpcHluYiIsImlzVXNhYmxlIiwiY2VsbCIsImNlbGxfdHlwZSIsInNvdXJjZSIsIm1ha2VQeXRob24iLCJjZWxscyIsIlB5dGhvbkVkaXRvclZpZXciLCJCbG9ja2x5Iiwic2V0UGFyZW50Q29udGFpbmVyIiwiQmxvY2tNaXJyb3IiLCJ0b29sYm94IiwiaW1hZ2VEb3dubG9hZEhvb2siLCJvbGRVcmwiLCJpbWFnZVVwbG9hZEhvb2siLCJyZWplY3QiLCJzdWJtaXNzaW9uSWQiLCJpbWFnZUxpdGVyYWxIb29rIiwibWFrZVN1YnNjcmlwdGlvbnMiLCJsaW5lRXJyb3JTdWJzY3JpcHRpb24iLCJsaW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uIiwibGluZVRyYWNlU3Vic2NyaXB0aW9uIiwibWFrZVBlckFzc2lnbm1lbnRTdWJzY3JpcHRpb25zIiwid29ya3NwYWNlIiwiY29uZmlndXJlQ29udGV4dE1lbnUiLCJvcHRpb25zIiwiZW5hYmxlZCIsImNhbGxiYWNrIiwib2xkRmlsZW5hbWUiLCJjdXJyZW50Qk1MaXN0ZW5lciIsImFkZENoYW5nZUxpc3RlbmVyIiwiaXNQYXJzb25zIiwibGluZXMiLCJzZXRIaWdobGlnaHRlZExpbmVzIiwiY2xlYXJIaWdobGlnaHRlZExpbmVzIiwiZGVsZXRlRmlsZUxvY2FsbHlfIiwic2V0Q29kZSIsImdldENvZGUiLCJyZW1vdmVDaGFuZ2VMaXN0ZW5lciIsImNsZWFyTGluZVN1YnNjcmlwdGlvbnMiLCJzZXRNb2RlIiwiZW5hYmxlQmxvY2tzIiwicmVsb2FkVG9vbGJveCIsImltYWdlTW9kZSIsInNldEltYWdlTW9kZSIsIm9sZEhlaWdodCIsInVzZVNtYWxsTGF5b3V0IiwicmVzaXplUmVzcG9uc2l2ZWx5IiwidXBkYXRlR3V0dGVyIiwiaW5kZW50U2lkZWJhciIsImN1c3RvbVRvb2xib3giLCJkZWNpZGVJZk5vdEVkaXRhYmxlIiwib25seVVwbG9hZHMiLCJpc1JlYWRPbmx5IiwiZW5kc1dpdGgiLCJQeXRob25FZGl0b3IiLCJRVUlaX0VESVRPUl9IVE1MIiwiUXVpekVkaXRvclZpZXciLCJRdWl6RWRpdG9yIiwiUEFTU0VEIiwiRkFJTEVEIiwiRVJST1IiLCJTS0lQUEVEIiwiY291bnQiLCJTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTCIsImJpbmRpbmdIYW5kbGVycyIsImNvZGVNaXJyb3JJbnN0YW5jZSIsImluaXQiLCJ2YWx1ZUFjY2Vzc29yIiwiYWxsQmluZGluZ3MiLCJ2aWV3TW9kZWwiLCJiaW5kaW5nQ29udGV4dCIsInNldFNpemUiLCJ1cGRhdGUiLCJTYW1wbGVTdWJtaXNzaW9uc1ZpZXciLCJjb2RlTWlycm9ycyIsIlNhbXBsZVN1Ym1pc3Npb25zIiwiVEFHU19FRElUT1JfSFRNTCIsIlRhZ3NFZGl0b3JWaWV3IiwiVGFnc0VkaXRvciIsIlRFWFRfRURJVE9SX0hUTUwiLCJUZXh0RWRpdG9yVmlldyIsIlRleHRFZGl0b3IiLCJUT09MQk9YX0VESVRPUl9IVE1MIiwiVG9vbGJveEVkaXRvclZpZXciLCJUb29sYm94RWRpdG9yIiwiRWRpdG9yc0VudW0iLCJTVUJNSVNTSU9OIiwiQVNTSUdOTUVOVCIsIklOU1RSVUNUSU9OUyIsIk9OX1JVTiIsIk9OX0NIQU5HRSIsIk9OX0VWQUwiLCJTVEFSVElOR19DT0RFIiwiU0FNUExFX1NVQk1JU1NJT05TIiwiSU5TVFJVQ1RPUl9GSUxFIiwiU1BFQ0lBTF9OQU1FU1BBQ0VTIiwiQVZBSUxBQkxFX0VESVRPUlMiLCJFRElUT1JTX0hUTUwiLCJyZWdpc3RlcmVkXyIsImV4dGVuc2lvbnNfIiwiYnlOYW1lXyIsInJlZ2lzdGVyRWRpdG9yIiwiaW5zdGFuY2UiLCJleGl0IiwiZW50ZXIiLCJzcGFjZSIsImFzc2lnbm1lbnRUeXBlIiwiQXNzaWdubWVudFR5cGUiLCJsYXN0SW5kZXhPZiIsImV4ZWN1dGlvbk1vZGVsIiwiY29uZmlndXJhdGlvbnMiLCJSdW5Db25maWd1cmF0aW9uIiwiZXZhbCIsIkV2YWxDb25maWd1cmF0aW9uIiwiT25SdW5Db25maWd1cmF0aW9uIiwiT25DaGFuZ2VDb25maWd1cmF0aW9uIiwiT25FdmFsQ29uZmlndXJhdGlvbiIsImNvbmZpZ3VyZSIsImdldFNrdWxwdE9wdGlvbnMiLCJvbkV4ZWN1dGlvbkJlZ2luIiwib25FeGVjdXRpb25FbmQiLCJyZXBvcnQiLCJ0cmFjaW5nIiwicmVzZXRTdHVkZW50TW9kZWwiLCJyZXNldFJlcG9ydHMiLCJyZXNldEV4ZWN1dGlvbkJ1ZmZlciIsInRoZW4iLCJmYWlsdXJlIiwiZGlzYWJsZUZlZWRiYWNrIiwicHJvdmlkZVNlY3JldEVycm9yIiwic2hvd0Vycm9ycyIsImV4ZWN1dGlvbkVuZF8iLCJldmFsdWF0aW9uSW5wdXQiLCJ1c2VySW5wdXQiLCJtaXNjZXZhbCIsImFzeW5jVG9Qcm9taXNlIiwiaW1wb3J0TWFpbldpdGhCb2R5IiwiRklMRU5BTUUiLCJwcm9ncmFtcyIsInNhdmVDb2RlIiwidmVyaWZ5Q29kZSIsInVwZGF0ZVBhcnNlIiwicnVuSW5zdHJ1Y3RvckNvZGUiLCJtb2R1bGUiLCJleGVjdXRpb25SZXBvcnRzIiwicHJlc2VudEZlZWRiYWNrIiwiJGQiLCJFTVBUWV9NT0RVTEUiLCJDb25maWd1cmF0aW9uIiwiaW5Ccm93c2VyIiwib3BlbkZpbGUiLCJyZXF1ZXN0c0dldCIsInRpbWVvdXQiLCJvcGVuVVJMIiwidGltZW91dEhhbmRsZXIiLCJ0aW1lUGFzc2VkIiwiZXhlY0xpbWl0IiwiZGlzYWJsZVRpbWVvdXQiLCJnZXRUaW1lb3V0UHJvbXB0IiwiZGVsYXkiLCJwYXJzZUludCIsImV4ZWNMaW1pdEZ1bmN0aW9uIiwiSW5maW5pdHkiLCJiZWZvcmVDYWxsIiwibG9uZ1RpbWVvdXQiLCJfX2Z1dHVyZV9fIiwicHl0aG9uMyIsInJlYWQiLCJpbXBvcnRGaWxlIiwiZmlsZXdyaXRlIiwid3JpdGVGaWxlIiwicHJpbnQiLCJpbnB1dGZ1biIsImlucHV0ZnVuVGFrZXNQcm9tcHQiLCJpbWFnZVByb3h5IiwiZ2V0SW1hZ2VQcm94eSIsImVtb2ppUHJveHkiLCJwYXJ0IiwicmV0YWluR2xvYmFscyIsIndhcm4iLCJtb2NrVXJsRGF0YSIsImJ1aWx0aW4iLCJJT0Vycm9yIiwiaGFzT3duUHJvcGVydHkiLCJmaWxlRGF0YSIsInJlYWRGaWxlIiwiRXJyb3IiLCJzdG9wIiwiZnVuY3Rpb25OYW1lIiwicG9zYXJncyIsImt3YXJncyIsInN0dWRlbnRNb2RlbCIsImFyZ3MiLCJwb3AiLCJhZnRlclNpbmdsZUV4ZWN1dGlvbiIsInByaW50VmFsdWUiLCJyZW1hcFRvSnMiLCJfIiwiJHIiLCJ4IiwiaXNEb2NzdHJpbmciLCJTdHVkZW50Q29uZmlndXJhdGlvbiIsIlVUSUxJVFlfTU9EVUxFX0NPREUiLCIkc2tfbW9kX2luc3RydWN0b3IiLCJDT1ZFUkFHRV9NT0RVTEVfQ09ERSIsIiRza19tb2RfY292ZXJhZ2UiLCJJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiIsImJlZm9yZUNhbGxCYWNrdXAiLCIkcGVkYWxfdHJhY2VyIiwiY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzIiwiaW5mbyIsImdldEFsbEZpbGVuYW1lcyIsInNrRmlsZW5hbWUiLCJzdHIiLCJwb3AkaXRlbSIsImluY2x1ZGVzIiwiY2hvbXBTcGVjaWFsRmlsZSIsImNsZWFuIiwiZm91bmQiLCJzZWFyY2hGb3JGaWxlIiwiT1NFcnJvciIsIm5leHRJbnB1dCIsImNsZWFyVGltZW91dCIsIldSQVBfSU5TVFJVQ1RPUl9DT0RFIiwic3R1ZGVudENvZGUiLCJpbnN0cnVjdG9yQ29kZSIsInF1aWNrIiwiaXNTYWZlIiwic2FmZUNvZGUiLCJJTlNUUlVDVE9SX01BUktFUiIsImRpc2FibGVUaWZhIiwic3R1ZGVudEZpbGVzIiwiZ2V0QWxsU3R1ZGVudEZpbGVzIiwiZXZhbHVhdGlvbiIsImR1bW15T3V0U2FuZGJveCIsImxpbmVPZmZzZXQiLCJmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldCIsIlNVQ0NFU1MiLCJTQ09SRSIsIm9sZFNjb3JlIiwiSElERSIsInNjcm9sbGluZyIsInNjcm9sbFRvQm90dG9tIiwidHAkbmFtZSIsInByZXNlbnRJbnRlcm5hbEVycm9yIiwiYmVmb3JlIiwibWF0Y2giLCJORVdfTElORV9SRUdFWCIsInNraXBfdGlmYSIsIk9uU2FtcGxlQ29uZmlndXJhdGlvbiIsImRpc2FibGVTdHVkZW50UnVuIiwiQm9vbGVhbiIsImVudmlyb24iLCJkaWN0Iiwic2V0JGl0ZW0iLCJpbnRfIiwiY2xlYXJJbnB1dCIsImZpbmlzaFR1cnRsZXMiLCJiZWdpbkV2YWwiLCJwYXJzZXIiLCJ2ZXJpZmllciIsIlNhbXBsZUNvbmZpZ3VyYXRpb24iLCJpc0ZvcmJpZGRlbiIsImxvY2FscyIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJhc3ROYW1lIiwicGFyc2VHbG9iYWxzIiwicHJvcGVydGllcyIsIm1vZHVsZXMiLCJ2aXNpdGVkTGluZXMiLCJTZXQiLCJ2aXNpdEJvZHkiLCJub2RlIiwibGluZW5vIiwic3RhdGVtZW50Iiwib3JlbHNlIiwiZmluYWxib2R5IiwiQXJyYXkiLCJmcm9tIiwiYXN0RnJvbVBhcnNlIiwiY3N0IiwiZmxhZ3MiLCJnZXRMaW5lcyIsInByZXNlbnRSdW5FcnJvciIsImVycm9yQnV0dG9uIiwiRkVFREJBQ0tfSFRNTCIsImZlZWRiYWNrTW9kZWwiLCJwb3NpdGl2ZSIsInZpc2liaWxpdHlCdWZmZXIiLCJ0b3BPZkVsZW1lbnQiLCJib3R0b21PZkVsZW1lbnQiLCJib3R0b21PZlNjcmVlbiIsInRvcE9mU2NyZWVuIiwiY2xlYXJQb3NpdGl2ZUZlZWRiYWNrIiwiZXhlY3V0aW9uUmVzdWx0cyIsIk1FU1NBR0UiLCJDQVRFR09SWSIsIkxBQkVMIiwiREFUQSIsInBvc2l0aXZlcyIsIlBPU0lUSVZFIiwiaGlkZVNjb3JlIiwiYmxvY2siLCJobGpzIiwiaGlnaGxpZ2h0QmxvY2siLCJmaW5kRmlyc3RFcnJvckxpbmUiLCJzdHVkZW50UmVwb3J0IiwidW5jb3ZlcmVkTGluZXMiLCJwb3NpdGl2ZURhdGEiLCJhZGRQb3NpdGl2ZUZlZWRiYWNrIiwiY29sb3IiLCJvbmNsaWNrIiwidG9FbmQiLCJjc3MiLCJob3ZlciIsInVwZGF0ZUZlZWRiYWNrIiwibm90aWZ5RmVlZGJhY2tVcGRhdGUiLCJzaG91bGRTY3JvbGxJbnRvVmlldyIsInNjcm9sbEludG9WaWV3IiwianVzdF9yZXR1cm4iLCJjb252ZXJ0U2t1bHB0RXJyb3IiLCJmaWxlbmFtZUV4ZWN1dGVkIiwidHJhY2ViYWNrIiwiZnJhbWUiLCJzY29wZSIsImlzSW5zdHJ1Y3RvciIsImVyciIsImFsbEZyYW1lcyIsImJ1aWxkVHJhY2ViYWNrIiwiZmVlZGJhY2tEYXRhIiwicXVpY2skbG9va3VwIiwibG9jYXRpb24iLCJ0cCRnZXRhdHRyIiwiZnJpZW5kbHlOYW1lIiwiaGlkZUlmRW1wdHkiLCJub3RJbnN0cnVjdG9yIiwiaW5zdHJ1Y3RvckZpbGVDbGFzcyIsImhpZGVJZk5vdEluc3RydWN0b3IiLCJGSUxFU19IVE1MIiwiTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCIsIlNUQVJUSU5HX0ZJTEVTIiwiQkFTSUNfTkVXX0ZJTEVTIiwiSU5TVFJVQ1RPUl9ESVJFQ1RPUlkiLCJTVFVERU5UX0RJUkVDVE9SWSIsIlNlYXJjaE1vZGVzIiwiRVZFUllXSEVSRSIsIlNUQVJUX1dJVEhfSU5TVFJVQ1RPUiIsIk9OTFlfU1RVREVOVF9GSUxFUyIsIkRFTEVUQUJMRV9TSU1QTEVfRklMRVMiLCJCbG9ja1B5RmlsZSIsIm93bmVyIiwibWFrZU1vY2tNb2RlbEZpbGUiLCJjb25jYXRlbmF0ZWRGaWxlIiwibW9kZWxGaWxlTGlzdCIsIm1vZGVsRmlsZXMiLCJjcmVhdGVDb25jYXRlbmF0ZWRGaWxlIiwiZmlsZXNfIiwibW91bnRGaWxlcyIsIndhdGNoTW9kZWwiLCJ3YXRjaGVzXyIsInZpc2libGl0eSIsInRvZ2dsZSIsImZpbGVzeXN0ZW0iLCJmaWxlQXJyYXkiLCJjaGFuZ2VzIiwic2Vjb25kIiwibG9jYWxlQ29tcGFyZSIsImNoYW5nZSIsIm1vZGVsRmlsZSIsIm5vdGlmeVdhdGNoZXMiLCJvYnNlcnZlSW5BcnJheV8iLCJhcnJheSIsImNvZGVCdW5kbGUiLCJleGlzdGluZ0ZpbGUiLCJvYnNlcnZlRmlsZV8iLCJkZXN0aW5hdGlvbiIsInN0dWRlbnRTZWFyY2giLCJzZWFyY2hNb2RlIiwic3BlY2lhbEZpbGUiLCJzZWFyY2hGb3JTcGVjaWFsRmlsZXNfIiwic3R1ZGVudFZlcnNpb24iLCJzZWFyY2hGb3JGaWxlSW5MaXN0XyIsImdlbmVyYXRlZFZlcnNpb24iLCJkZWZhdWx0VmVyc2lvbiIsImhpZGRlblZlcnNpb24iLCJmaXJzdERlZmluZWRWYWx1ZSIsImluc3RydWN0b3JWZXJzaW9uIiwic3RhcnRpbmdWZXJzaW9uIiwibW9kZWxMaXN0Iiwia2luZCIsImZpbGV0eXBlIiwibmFtZXNwYWNlIiwiZXh0ZW5zaW9uUmVnZXgiLCJleGVjIiwicHJlZml4Iiwic3VibWl0IiwicHJldmVudERlZmF1bHQiLCJGT09URVJfSFRNTCIsImN1cnJlbnRJZCIsImVkaXRFdmVudHMiLCJzZWxlY3RvciIsImVkaXRJZCIsImVudHJ5IiwiZmlsZV9wYXRoIiwiZXZlbnRfdHlwZSIsIlJFTUFQX0VWRU5UX1RZUEVTIiwiZGlzcGxheWVkIiwicHJldHR5UHJpbnREYXRlVGltZSIsImNsaWVudF90aW1lc3RhbXAiLCJkaXNhYmxlIiwib3B0aW9uIiwiZGlzYWJsZWQiLCJpc0VkaXRFdmVudCIsImV2dCIsIm1vbnRoTmFtZXMiLCJ3ZWVrRGF5cyIsImlzU2FtZURheSIsImdldERhdGUiLCJnZXRNb250aCIsImdldEZ1bGxZZWFyIiwidGltZVN0cmluZyIsIm5vdyIsIkRhdGUiLCJwYXN0IiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiZGF5U3RyIiwiZ2V0RGF5IiwibW9udGhTdHIiLCJkYXRlIiwiZ2V0SGlzdG9yeSIsInJldmVyc2UiLCJyZWR1Y2UiLCJjb21wbGV0ZSIsImVsZW0iLCJjb21wbGV0ZV9zdHIiLCJ0aW1lIiwibmV3X2xpbmUiLCJoaWdobGlnaHRUaW1lb3V0IiwiaXNGdWxsc2NyZWVuIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsIlRSQUNFX0hUTUwiLCJSRVRSWUlORyIsIk9GRkxJTkUiLCJzdG9yYWdlIiwicXVldWUiLCJnZXREZWZhdWx0IiwiTUFYX1FVRVVFX1NJWkUiLCJUSU1FUl9ERUxBWSIsIkZBSUxfREVMQVkiLCJ0aW1lcnMiLCJvdmVybGF5IiwiYmxvY2tpbmdBdHRlbXB0cyIsImNhY2hlZEZpbGVuYW1lcyIsImNyZWF0ZVN1YnNjcmlwdGlvbnMiLCJjaGVja0NhY2hlcyIsImNoZWNrSVAiLCJvbGRJUCIsImlwIiwic2V0IiwiX3Bvc3RMYXRlc3RSZXRyeSIsInB1c2hBbnlRdWV1ZWQiLCJfcG9zdFJldHJ5IiwiY3JlYXRlRmlsZVN1YnNjcmlwdGlvbiIsImNyZWF0ZUV2ZW50TG9ncyIsIm9uYmx1ciIsIm9uZm9jdXMiLCJjcmVhdGVTZXJ2ZXJEYXRhIiwibWljcm9zZWNvbmRzIiwiZ2V0VGltZSIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2hvd092ZXJsYXkiLCJhdHRlbXB0IiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhpZGVPdmVybGF5IiwiX2VucXVldWVEYXRhIiwiY2FjaGUiLCJfZGVxdWV1ZURhdGEiLCJzcGxpY2UiLCJwb3N0UmVxdWVzdCIsInBvc3QiLCJ0ZXh0U3RhdHVzIiwiZmFpbHVyZUZ1bmN0aW9uIiwiZG9uZUZ1bmN0aW9uIiwicmVxdWVzdCIsImNhY2hlZFRpbWUiLCJfcG9zdEJsb2NraW5nIiwiYXR0ZW1wdHMiLCJleHRyYVNldHRpbmdzIiwiYWpheCIsImVycm9yVGhyb3duIiwic3RhcnRQb3NzaWJsZUZvcmsiLCJwbGFjZW1lbnQiLCJkaXJlY3RvcnkiLCJmZCIsImVudHJpZXMiLCJkIiwiRm9ybURhdGEiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwibmV3U3RhdHVzIiwicG9zdFN0YXR1c0NoYW5nZSIsImVycm9yQ2FsbGJhY2siLCJsb2FkX2ZpbGUiLCJmb3JrYWJsZSIsImhpZGRlbk92ZXJyaWRlIiwiZm9yY2VVcGRhdGUiLCJnZXRQbmdGcm9tQmxvY2tzIiwicG5nRGF0YSIsImltZyIsIiRidWlsdGlubW9kdWxlIiwibW9kIiwic2FtcGxlV3JhcHBlciIsIl9fbmFtZV9fIiwiUElMIiwiSW5zdGFudFByb21pc2UiLCJsYXN0UmVzdWx0IiwibGFzdEVycm9yIiwiY2IiLCJidWlsZEltYWdlIiwiZ2V0QXNzZXQiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25lcnJvciIsInNyYyIsIiRnYmwiLCIkbG9jIiwiX19pbml0X18iLCJmdW5jIiwiZmlsZV9vcl91cmwiLCJweUNoZWNrQXJncyIsInB5Q2hlY2tUeXBlIiwiY2hlY2tTdHJpbmciLCJpbWFnZVByb21pc2UiLCJzdXNwIiwiU3VzcGVuc2lvbiIsIm5vbmUiLCJub25lJCIsInJlc3VtZSIsInByb21pc2UiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwicGl4ZWxzIiwiZ2V0SW1hZ2VEYXRhIiwiTmFtZUVycm9yIiwiY29uc29sZURhdGEiLCJwcmludFBJTEltYWdlIiwiZmxpcCIsInN0eWxlIiwidHJhbnNmb3JtIiwiYnVpbGRDbGFzcyIsInByaW9yIiwidGltZWl0IiwiZGlmZmVyZW5jZSIsImNvbnNvbGVfbG9nIiwiY29uc29sZV9kZWJ1ZyIsImdldF9vdXRwdXQiLCJpdGVtIiwidG9Ta3VscHQiLCJsaXN0IiwicmVzZXRfb3V0cHV0IiwiZ2V0X3Byb2dyYW0iLCJnZXRfZXZhbHVhdGlvbiIsInRyYWNlX2xpbmVzIiwicmVhbExpbmVzIiwidHJhY2VfY2FsbHMiLCJzdGFydF90cmFjZSIsInN0b3BfdHJhY2UiLCJnZXRfc3R1ZGVudF9lcnJvciIsInR1cGxlIiwicG9zaXRpb24iLCJoYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3IiLCJiYWNrdXBUaW1lIiwibGltaXRfZXhlY3V0aW9uX3RpbWUiLCJleGVjU3RhcnQiLCJ1bmxpbWl0X2V4ZWN1dGlvbl90aW1lIiwic3VwcHJlc3Nfc2Nyb2xsaW5nIiwiZ2V0X3Bsb3RzIiwib3V0cHV0cyIsImdyYXBoIiwicGxvdCIsIm5ld1Bsb3QiLCJ2IiwieSIsIlN0dWRlbnREYXRhIiwibmV3RGljdCIsImFic3RyIiwic2F0dHIiLCJvYmplY3RTZXRJdGVtIiwidW5maXhSZXNlcnZlZCIsImNhbGxfZiIsImt3YSIsInB5Q2hlY2tBcmdzTGVuIiwiY2FsbCIsImJ1aWx0aW5zIiwibXAkbG9va3VwIiwiZnVuY3Rpb25PYmplY3QiLCJ0cCRjYWxsIiwiY29fa3dhcmdzIiwiY29fbmFtZSIsImdldF9uYW1lc19ieV90eXBlIiwiZXhjbHVkZV9idWlsdGlucyIsImNoZWNrQm9vbCIsInByb3BlcnR5IiwiZ2V0X3ZhbHVlc19ieV90eXBlIiwiY2FsbHNpbU9yU3VzcGVuZCIsImdldF9zdHVkZW50X2RhdGEiLCJzZXRfaW5zdHJ1Y3Rpb25zIiwibmV3SW5zdHJ1Y3Rpb25zIiwiZ2V0X21vZGVsX2luZm8iLCJjbGVhcl9leGlzdGluZ19zdHVkZW50X2ltcG9ydHMiLCJXZWFrU2V0IiwiY2hlY2tJdGVyYWJsZSIsIml0ZXIiLCJpdGVybmV4dCIsIldlYWtSZWYiLCJfX2l0ZXJfXyIsInZpZXdPZkRhdGEiLCJkZXJlZiIsIkxPQ0FMX1NUT1JBR0VfUkVGIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJfZGF0YSIsIlN0cmluZyIsImdldEl0ZW0iLCJpc19uZXciLCJzZXJ2ZXJfdGltZSIsInN0b3JlZF90aW1lIiwiSUdOT1JFRF9HTE9CQUxTIiwidmFyaWFibGVzIiwicGFyc2VkIiwicGFyc2VWYWx1ZSIsImZ1bGxMZW5ndGgiLCJmdW5jX2NvZGUiLCJjb192YXJuYW1lcyIsInNxJGxlbmd0aCIsImJvb2wiLCJubWJlciIsInNrVHlwZSIsImZsb2F0XyIsIk51bWJlciIsImFycmF5Q29udGFpbnMiLCJuZWVkbGUiLCJoYXlzdGFjayIsImFycmF5VW5pcXVlIiwiYSIsImNvbmNhdCIsImoiLCJleHBhbmRBcnJheSIsImFkZEFycmF5IiwicmVtb3ZlQXJyYXkiLCJjb3B5QXJyYXkiLCJjbG9uZU5vZGUiLCJjbG9uZSIsIm5vZGVUeXBlIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImluZGVudCIsInMiLCJyYW5kb21JbnRlZ2VyIiwiZmxvb3IiLCJyYW5kb20iLCJXb3Jrc3BhY2VTdmciLCJzaHVmZmxlIiwibWV0cmljcyIsImdldE1ldHJpY3MiLCJ2aWV3V2lkdGgiLCJ2aWV3SGVpZ2h0IiwiYmxvY2tzIiwiZ2V0VG9wQmxvY2tzIiwibWF4aW1hbF9pbmNyZWFzZSIsImdldFJlbGF0aXZlVG9TdXJmYWNlWFkiLCJtb3ZlQnkiLCJtb3ZlRWxlbWVudHMiLCJtb3ZlQ2hlY2siLCJpc1NrQnVpbHRpbiIsIm9iaiIsImxuZyIsImlzQXN0Tm9kZSIsIkRFRkFVTFRfU0VDVElPTl9QQVRURVJOIiwicGFydHMiLCJtaXhlZFJlbWFwVG9QeSIsImsiLCJrdnMiLCJhcnIiLCJzdWJ2YWwiLCJhc3NrJCIsInRvZGF5IiwiaCIsImdldEhvdXJzIiwibSIsImdldE1pbnV0ZXMiLCJwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtE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QUE1QixDQUFSO0FBQ0EsTUFBSUMsQ0FBQyxHQUFHSCxLQUFLLENBQUNJLFVBQU4sRUFBUixDQUg2QixDQUk3Qjs7QUFDQSxNQUFJRCxDQUFDLEdBQUcsRUFBUixFQUFZO0FBQUNBLEtBQUMsR0FBRyxNQUFNQSxDQUFWO0FBQWEsR0FMRyxDQU03Qjs7O0FBQ0EsTUFBSUUsQ0FBQyxHQUFHLElBQVI7O0FBQ0EsTUFBSUwsS0FBSyxDQUFDRSxRQUFOLE1BQWtCLEVBQXRCLEVBQTBCO0FBQ3RCRyxLQUFDLEdBQUcsSUFBSjtBQUNIOztBQUNELG1CQUFVSixDQUFWLGNBQWVFLENBQWYsU0FBbUJFLENBQW5CO0FBQ0gsQzs7Ozs7Ozs7Ozs7QUNwVEQsb0Q7Ozs7Ozs7Ozs7O0FDQUEsc0QiLCJmaWxlIjoiYmxvY2tweS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpRdWVyeVwiKSwgcmVxdWlyZShcImtvXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiYmxvY2tweVwiLCBbXCJqUXVlcnlcIiwgXCJrb1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJibG9ja3B5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImJsb2NrcHlcIl0gPSBmYWN0b3J5KHJvb3RbXCJqUXVlcnlcIl0sIHJvb3RbXCJrb1wiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qcXVlcnlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYmxvY2tweS5qc1wiKTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBTdGFydGluZyBwb2ludCBvZiB0aGUgQmxvY2tQeSBhcHBsaWNhdGlvbiwgY29udGFpbmluZyB0aGUgbWFpblxuICogQmxvY2tQeSBjbGFzcy5cbiAqL1xuaW1wb3J0IFwiLi9jc3MvYmxvY2tweS5jc3NcIjtcbmltcG9ydCBcIi4vY3NzL2Jvb3RzdHJhcF9yZXRoZW1lLmNzc1wiO1xuaW1wb3J0ICQgZnJvbSBcImpxdWVyeVwiO1xuaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyBpbWFnZU1vZHVsZX0gZnJvbSBcInNrdWxwdF9tb2R1bGVzL2ltYWdlXCI7XG5pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIHdlYWtyZWZNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy93ZWFrcmVmXCI7XG4vL2ltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgbWF0cGxvdGxpYk1vZHVsZX0gZnJvbSBcInNrdWxwdF9tb2R1bGVzL21hdHBsb3RsaWIyXCI7XG5pbXBvcnQge0xvY2FsU3RvcmFnZVdyYXBwZXJ9IGZyb20gXCJzdG9yYWdlLmpzXCI7XG5pbXBvcnQge0VkaXRvcnNFbnVtfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCJlZGl0b3IvcHl0aG9uLmpzXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwic2VydmVyLmpzXCI7XG5pbXBvcnQge21ha2VJbnRlcmZhY2UsIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMsIFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9uc30gZnJvbSBcImludGVyZmFjZS5qc1wiO1xuaW1wb3J0IHtFZGl0b3JzfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtcbiAgICBCbG9ja1B5RmlsZVN5c3RlbSxcbiAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZSxcbiAgICBtYWtlTW9kZWxGaWxlLFxuICAgIG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlLFxuICAgIFVOREVMRVRBQkxFX0ZJTEVTLFxuICAgIFVOUkVOQU1BQkxFX0ZJTEVTXG59IGZyb20gXCIuL2ZpbGVzXCI7XG5pbXBvcnQge3VwbG9hZEZpbGUsIGRvd25sb2FkRmlsZX0gZnJvbSBcIi4vZWRpdG9yL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtCbG9ja1B5RW5naW5lfSBmcm9tIFwiZW5naW5lLmpzXCI7XG5pbXBvcnQge0FTVF9ERVNDUklQVElPTlMsIEJsb2NrUHlUcmFjZX0gZnJvbSBcIi4vdHJhY2VcIjtcbmltcG9ydCB7QmxvY2tQeUNvbnNvbGV9IGZyb20gXCIuL2NvbnNvbGVcIjtcbmltcG9ydCB7QmxvY2tQeUZlZWRiYWNrfSBmcm9tIFwiZmVlZGJhY2suanNcIjtcbmltcG9ydCB7QmxvY2tQeVNlcnZlcn0gZnJvbSBcIi4vc2VydmVyXCI7XG5pbXBvcnQge0Jsb2NrUHlEaWFsb2d9IGZyb20gXCIuL2RpYWxvZ1wiO1xuaW1wb3J0IHtBc3NpZ21lbnRUeXBlLCBsb2FkQXNzaWdubWVudFNldHRpbmdzLCBtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWx9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5pbXBvcnQge0Jsb2NrUHlDb3JnaXMsIF9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfSBmcm9tIFwiLi9jb3JnaXNcIjtcbmltcG9ydCB7QmxvY2tQeUhpc3Rvcnl9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgZXh0cmFjdFBhcnQsIGdldEN1cnJlbnRUaW1lfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U2FtcGxlU3VibWlzc2lvbiwgU3VibWlzc2lvblN0YXR1c2VzfSBmcm9tIFwiLi9lZGl0b3Ivc2FtcGxlX3N1Ym1pc3Npb25zXCI7XG5cbmV4cG9ydCB7X0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTLCBfSU1QT1JURURfREFUQVNFVFN9O1xuXG5jb25zdCBFRElUT1JfVkVSU0lPTiA9IFwiNS4xLjJcIjtcblxuLyoqXG4gKiBNYWpvciBlbnRyeSBwb2ludCBmb3IgY3JlYXRpbmcgYSBCbG9ja1B5IGluc3RhbmNlLlxuICogVHdvIG1vc3QgaW1wb3J0YW50IGZpZWxkcyBhcmUgYG1vZGVsYCBhbmQgYGNvbXBvbmVudHNgLlxuICogVGhlIGBtb2RlbGAgaG9sZHMgYWxsIHRoZSBkYXRhIGFib3V0IHRoZSBpbnRlcmZhY2UuXG4gKiBUaGUgYGNvbXBvbmVudHNgIGFyZSByZWZlcmVuY2VzIHRvIHRoZSBkaXNwYXJhdGUgcGFydHMgb2YgQmxvY2tQeS5cbiAqXG4gKiBNb3N0IG9mIHRoaXMgY2xhc3NlcyBkZWZpbml0aW9uIGlzIGp1c3QgaW5pdGlhbGl6aW5nIHRoZSBtb2RlbCBhbmQgdXBkYXRpbmdcbiAqIGl0IG9uIGFuIGFzc2lnbm1lbnQgc3dpdGNoLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gLSBVc2VyIGxldmVsIHNldHRpbmdzIChlLmcuLCB3aGF0IGVkaXRvciBtb2RlLCB3aGV0aGVyIHRvIG11dGUgc2VtYW50aWMgZXJyb3JzLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50IC0gQXNzaWdubWVudCBsZXZlbCBzZXR0aW5ncyAoZGF0YSBhYm91dCB0aGUgbG9hZGVkIGFzc2lnbm1lbnQsIHVzZXIsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1Ym1pc3Npb24gLSBJbmNsdWRlcyB0aGUgc291cmNlIGNvZGUgb2YgYW55IHByb2dyYW1zIHRvIGJlIGxvYWRlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIGFzc2lnbm1lbnQsIHN1Ym1pc3Npb24pIHtcbiAgICAgICAgdGhpcy5pbml0TW9kZWwoY29uZmlndXJhdGlvbik7XG4gICAgICAgIGlmIChhc3NpZ25tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXNzaWdubWVudChjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRNYWluKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEJsb2NrUHkgb2JqZWN0IGJ5IGluaXRpYWxpemluZyBpdHMgaW50ZXJmYWNlLFxuICAgICAqIG1vZGVsLCBhbmQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRNYWluKCkge1xuICAgICAgICB0aGlzLmluaXRVdGlsaXRpZXMoKTtcbiAgICAgICAgdGhpcy5pbml0TW9kZWxNZXRob2RzKCk7XG4gICAgICAgIHRoaXMudHVybk9uSGFja3MoKTtcbiAgICAgICAgdGhpcy5pbml0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuYXBwbHlNb2RlbCgpO1xuICAgICAgICB0aGlzLmluaXRDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMubWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGRlZmF1bHQgdmFsdWUgb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIGtleSB0byBsb29rIHVwIGEgdmFsdWUgZm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRWYWx1ZSAtIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGFueXdoZXJlLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNldHRpbmcoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbFNldHRpbmdzXy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTZXR0aW5nc18uZ2V0KGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGVsIHRvIGl0cyBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIENhdGVnb3JpZXM6XG4gICAgICogICAqIHVzZXI6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgdXNlciAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogYXNzaWdubWVudDogdmFsdWVzIGZvciB0aGUgY3VycmVudCBhc3NpZ25tZW50IChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBzdWJtaXNzaW9uOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHN1Ym1pc3Npb24gKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGRpc3BsYXk6IGZsYWdzIHJlbGF0ZWQgdG8gY3VycmVudCB2aXNpYmlsaXR5IChzdG9yZWQgdG8gbG9jYWxTZXR0aW5ncylcbiAgICAgKiAgICogc3RhdHVzOiBtZXNzYWdlcyByZWxhdGVkIHRvIGN1cnJlbnQgc3RhdHVzIChub3Qgc3RvcmVkKVxuICAgICAqICAgKiBleGVjdXRpb246IHZhbHVlcyByZWxhdGVkIHRvIGxhc3QgcnVuIChub3Qgc3RvcmVkKVxuICAgICAqICAgKiBjb25maWd1cmF0aW9uOiBjb25zdGFudCB2YWx1ZXMgcmVsYXRlZCB0byBzZXR1cCAobm90IHN0b3JlZClcbiAgICAgKi9cbiAgICBpbml0TW9kZWwoY29uZmlndXJhdGlvbikge1xuICAgICAgICAvLyBDb25uZWN0IHRvIGxvY2FsIHN0b3JhZ2VcbiAgICAgICAgdGhpcy5sb2NhbFNldHRpbmdzXyA9IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKFwibG9jYWxTZXR0aW5nc1wiKTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGNvbmZpZ3VyYXRpb24sIGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0sIGNvbmZpZ3VyYXRpb25bXCJwYXJ0SWRcIl0sIGV4dHJhY3RQYXJ0KGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0gfHwgXCJcIiwgY29uZmlndXJhdGlvbltcInBhcnRJZFwiXSkpO1xuXG4gICAgICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuaWRcIl0pLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIubmFtZVwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB5b3UgYXJlIGFuIE93bmVyIChjYW4gbW9kaWZ5IHRoZSBhc3NpZ25tZW50KSwgR3JhZGVyIChjYW4gdmlld1xuICAgICAgICAgICAgICAgICAqIHRoZSBhc3NpZ25tZW50cycgaW5mb3JtYXRpb24pIG9yIFN0dWRlbnQgKGNhbiBub3Qgc2VlIGFueSBpbnN0cnVjdG9yIHN0dWZmKS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByb2xlOiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcInVzZXIucm9sZVwiLCBcIm93bmVyXCIpKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGNvdXJzZSBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY291cnNlSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuY291cnNlX2lkXCJdKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50IGFzc2lnbm1lbnQgZ3JvdXAgdGhhdCB0aGlzIHVzZXIgaXMgaW5zaWRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1widXNlci5ncm91cF9pZFwiXSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NpZ25tZW50OiB7XG4gICAgICAgICAgICAgICAgaWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZToga28ub2JzZXJ2YWJsZShcIlNjcmF0Y2ggQ2FudmFzXCIpLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uczoga28ub2JzZXJ2YWJsZShcIldlbGNvbWUgdG8gQmxvY2tQeS4gVHJ5IGVkaXRpbmcgYW5kIHJ1bm5pbmcgdGhlIGNvZGUgYmVsb3cuXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBodW1hbi1mcmllbmRseSBVUkwgdG8gdXNlIGFzIGEgc2hvcnRjdXQgZm9yIHRoaXMgYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVybDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuaW5nIG1lc3NhZ2UgaWYgbWF6ZVxuICAgICAgICAgICAgICAgIHR5cGU6IGtvLm9ic2VydmFibGUoQXNzaWdtZW50VHlwZS5CTE9DS1BZKSxcbiAgICAgICAgICAgICAgICBwb2ludHM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdDb2RlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnN0YXJ0aW5nX2NvZGVcIl0gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgb25SdW46IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQub25fcnVuXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2NoYW5nZVwiXSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICBvbkV2YWw6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQub25fZXZhbFwiXSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICBleHRyYUluc3RydWN0b3JGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KGxvYWRDb25jYXRlbmF0ZWRGaWxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmV4dHJhX2luc3RydWN0b3JfZmlsZXNcIl0pIHx8IFtdKSxcbiAgICAgICAgICAgICAgICBleHRyYVN0YXJ0aW5nRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgZm9ya2VkSWQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgZm9ya2VkVmVyc2lvbjoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBvd25lcklkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgdGFnczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICBzYW1wbGVTdWJtaXNzaW9uczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICByZXZpZXdlZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5yZXZpZXdlZFwiXSksXG4gICAgICAgICAgICAgICAgcHVibGljOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnB1YmxpY1wiXSksXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmhpZGRlblwiXSksXG4gICAgICAgICAgICAgICAgaXBSYW5nZXM6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuaXBfcmFuZ2VzXCJdKSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsKGNvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGtvLm9ic2VydmFibGUoZXh0cmFjdFBhcnQoY29uZmlndXJhdGlvbltcInN1Ym1pc3Npb24uY29kZVwiXSB8fCBcIlwiLCBjb25maWd1cmF0aW9uW1wicGFydElkXCJdKSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBleHRyYUZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIHVybDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDoga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICBzY29yZToga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICBjb3JyZWN0OiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50SWQgaW5mZXJyZWQgZnJvbSBhc3NpZ25tZW50LmlkXG4gICAgICAgICAgICAgICAgLy8gY291cnNlSWQgaW5mZXJyZWQgZnJvbSB1c2VyLmNvdXJzZUlkXG4gICAgICAgICAgICAgICAgLy8gdXNlcklkIGluZmVycmVkIGZyb20gdXNlci5pZFxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnRWZXJzaW9uIGluZmVycmVkIGZyb20gYXNzaWdubWVudC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgdmVyc2lvbjoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uU3RhdHVzOiBrby5vYnNlcnZhYmxlKFwiU3RhcnRlZFwiKSxcbiAgICAgICAgICAgICAgICBncmFkaW5nU3RhdHVzOiBrby5vYnNlcnZhYmxlKFwiTm90UmVhZHlcIiksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDdXJyZW50bHkgdmlzaWJsZSBGaWxlLCBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmaWxlbmFtZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSBwcmVzZW50ZWQgd2l0aCB0aGUgaW5zdHJ1Y3RvciBzZXR0aW5ncyBhbmQgZmlsZXNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpbnN0cnVjdG9yOiBrby5vYnNlcnZhYmxlKFwiXCIrdGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5pbnN0cnVjdG9yXCIsIFwiZmFsc2VcIik9PT1cInRydWVcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcHJldmVudCB0aGUgcHJpbnRlciBmcm9tIHNob3dpbmcgdGhpbmdzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbXV0ZVByaW50ZXI6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIChQeXRob24gVmlld3MpIFRoZSBjdXJyZW50IGVkaXRvciBtb2RlLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtEaXNwbGF5TW9kZXN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHl0aG9uTW9kZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJkaXNwbGF5LnB5dGhvbi5tb2RlXCIsIERpc3BsYXlNb2Rlcy5URVhUKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgSGlzdG9yeSBtb2RlIGlzIGVuZ2FnZWQuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaGlzdG9yeU1vZGU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIGF1dG8tc2F2aW5nIGNoYW5nZXMgaW4gUHl0aG9uIGVkaXRvclxuICAgICAgICAgICAgICAgICAqIElmIGFuIGludGVnZXIsIHNwZWNpZmllcyB0aGUgZGVsYXkgdGhhdCBzaG91bGQgYmUgdXNlZCAobWljcm9zZWNvbmRzKS5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIG5ldmVyIG9uIGluIG5vbi1QeXRob24gZWRpdG9ycy5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbHxpbnR9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXV0b1NhdmU6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGNvbnNvbGUgaXMgZnVsbCB3aWR0aCBhbmQgZmVlZGJhY2sgaXMgaGlkZGVuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYmlnQ29uc29sZToga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBjb25zb2xlLlxuICAgICAgICAgICAgICAgICAqICAgIElmIG51bGwsIHRoZW4gbGV0IHRoZSBoZWlnaHQgcmVtYWluIHVuY2hhbmdlZFxuICAgICAgICAgICAgICAgICAqICAgIElmIGEgbnVtYmVyLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ29uc29sZUhlaWdodDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uc29sZUhlaWdodDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGljaCBwYW5lbCB0byBzaG93IGluIHRoZSBzZWNvbmQgcm93J3Mgc2Vjb25kIGNvbHVtblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2Vjb25kUm93U2Vjb25kUGFuZWw6IGtvLm9ic2VydmFibGUoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLKSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGJlIHRyYWNpbmcgdGhlIGNvZGUgcmlnaHQgbm93XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJhY2VFeGVjdXRpb246IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBsaXN0IG9mIHByb21pc2VzIHRvIHN0aWxsIHJlc29sdmUgd2hpbGUgbG9hZGluZyBkYXRhc2V0c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxQcm9taXNlPn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsb2FkaW5nRGF0YXNldHM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHRlbXBvcmFyeSBjaGFuZ2VkIHZhbHVlIG9mIHRoZSBpbnN0cnVjdGlvbnMgaGF2ZSBiZWVuIGNoYW5nZWQgZnJvbSB3aGF0IGlzIGluIHRoZSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhbmdlZEluc3RydWN0aW9uczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIGhvbGRlciBmb3IgdGhlIHRpbWVyIHRvIHRyaWdnZXIgb24tY2hhbmdlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyaWdnZXJPbkNoYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IGZlZWRiYWNrIGFuZCBvdXRwdXQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgc3VibWlzc2lvbi5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdvdWxkIGJlIGZhbHNlIGlmIHRoZXJlIGlzIG5vIGZlZWRiYWNrL291dHB1dCAoaS5lLiwgY29kZSBoYXMgbm90IGJlZW4gcnVuKSxcbiAgICAgICAgICAgICAgICAgKiBvciBpZiB0aGUgdXNlciBoYXMgbW9kaWZpZWQgdGhlIHN1Ym1pc3Npb24gYWZ0ZXIgdGhlIGxhc3QgcnVuIChlLmcuLCBieSBlZGl0aW5nXG4gICAgICAgICAgICAgICAgICogdGhlIHRleHQpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpcnR5U3VibWlzc2lvbjoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdG8gbWFrZSB0aGUgQmxvY2tQeSBlbGVtZW50IGluIEZVTEwgU0NSRUVOIG1vZGUuIFNhZGx5LCBub3QgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICAqICB3aXRoaW4gdGhlIHdpbmRvdywgYnV0IEZVTEwgU0NSRUVOLiBWZXJ5IGFnZ3Jlc3NpdmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnVsbHNjcmVlbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXNlci1zdXBwbGllZCBwYXNzY29kZSB0byBjb21wYXJlIG9uIHRoZSBzZXJ2ZXIgYWdhaW5zdCB0aGUgY3VycmVudCBwYXNzY29kZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXNzY29kZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBjbGVhciBvdXQgaW5wdXRzIGFmdGVyIGEgcnVuL29uX3J1biBjeWNsZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNsZWFySW5wdXRzOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGltYWdlcyBzaG91bGQgYmUgcmVuZGVyZWQgKHRydWUpLCBvciBqdXN0IHN0YXkgYXMgdGV4dCBjb2RlIChmYWxzZSkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVuZGVySW1hZ2VzOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIGVkaXRvclZlcnNpb246IEVESVRPUl9WRVJTSU9OLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkucmVhZF9vbmx5XCIsIFwiZmFsc2VcIikudG9TdHJpbmcoKT09PVwidHJ1ZVwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVcGxvYWRlZCBmaWxlcyBhcmUgb25lcyB0aGF0IGhhdmUgYmVlbiBsaXN0ZWQgYnkgdGhlIHJlbW90ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHVwbG9hZGVkRmlsZXM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQmFja3VwIGNvcHkgb2YgdGhlIGxhdGVzdCBrbm93biBmdWxsIGNvZGUgZm9yIHRoZSBTdWJtaXNzaW9uLiBUaGlzIGlzIHJlbGV2YW50IGlmIHRoZXJlIHdhcyBhXG4gICAgICAgICAgICAgICAgICogUGFydElEIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSB0aGUgc3VibWlzc2lvbi5jb2RlIGluIHRoZSBtb2RlbCBpcyBvbmx5IHNob3dpbmcgd2hhdCB3ZSBrbm93XG4gICAgICAgICAgICAgICAgICogbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBiYWNrdXBTdWJtaXNzaW9uQ29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdIHx8IFwiXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEhpc3Rvcnk6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRIaXN0b3J5TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRGaWxlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkRGF0YXNldDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZERhdGFzZXRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9nRXZlbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHNhdmVJbWFnZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHNhdmVGaWxlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlQXNzaWdubWVudDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgc2F2ZUFzc2lnbm1lbnRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvbjoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvbk1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uU3RhdHVzOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxpc3RVcGxvYWRlZEZpbGVzOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsaXN0VXBsb2FkZWRGaWxlc01lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICB1cGxvYWRGaWxlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICB1cGxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIG9uRXhlY3V0aW9uOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGVjdXRpb246IHtcbiAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCBpbi1wcm9ncmVzcyBleGVjdXRpb25zXG4gICAgICAgICAgICAgICAgcmVwb3J0czoge30sXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBPdXRwdXQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIG91dHB1dDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAvLyBMaXN0IG9mIGlucHV0dGVkIHN0cmluZ3NcbiAgICAgICAgICAgICAgICBpbnB1dDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4OiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gYSBzdHVkZW50IHJ1blxuICAgICAgICAgICAgICAgIHN0dWRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyOiB0aGUgZmlsZW5hbWUgdGhhdCB3YXMgbGFzdCBleGVjdXRlZCBhbmQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZXNlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0ZXA6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGxhc3RMaW5lOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBzaW1wbGUgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2VEYXRhOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjZVN0ZXA6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdHVhbCBleGVjdXRpb24gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBjYWxsczoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3lzbW9kdWxlczogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIGZlZWRiYWNrIGZyb20gdGhlIGluc3RydWN0b3IgcnVuXG4gICAgICAgICAgICAgICAgZmVlZGJhY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyIChtYXJrZG93bilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlJlYWR5XCIpLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzRXJyb3I6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzVW5jb3ZlcmVkOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0cyBvZiB0aGUgbGFzdCBleGVjdXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbnMgdG8gZmlyZSB3aGVuIGNlcnRhaW4gZXZlbnRzIG9jY3VyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHRoZSBzdHVkZW50IGdldHMgYSBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJjYWxsYmFjay5zdWNjZXNzXCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHNlcnZlciBpcyBjb25uZWN0ZWQuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2VydmVyQ29ubmVjdGVkOiBrby5vYnNlcnZhYmxlKHRoaXMuZ2V0U2V0dGluZyhcInNlcnZlci5jb25uZWN0ZWRcIiwgdHJ1ZSkpLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgICAgICAgIGJsb2NrbHlQYXRoOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImJsb2NrbHkucGF0aFwiXSxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50UG9pbnQ6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiYXR0YWNobWVudC5wb2ludFwiXSxcbiAgICAgICAgICAgICAgICAvLyBKUXVlcnkgb2JqZWN0XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgICAgIC8vIE1hcHMgY29kZXMgKCdsb2dfZXZlbnQnLCAnc2F2ZV9jb2RlJykgdG8gVVJMc1xuICAgICAgICAgICAgICAgIHVybHM6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1widXJsc1wiXSB8fCB7fSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVbmlxdWUgUGFydCBJRCB0aGF0IGNhbiBkaXN0aW5ndWlzaCB0aGlzIGVkaXRvciBpbnN0YW5jZSdzIHJlZ2lvbiBvZiB0aGUgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICAgKiBJdCdzIHBvc3NpYmxlIHRoYXQgb3RoZXIgZWRpdG9ycyBtYXkgYmUgYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgUGFydCBvZiB0aGUgc2FtZSBhc3NpZ25tbmV0LCBvbiB0aGVcbiAgICAgICAgICAgICAgICAgKiBzYW1lIHBhZ2UuXG4gICAgICAgICAgICAgICAgICogKiovXG4gICAgICAgICAgICAgICAgcGFydElkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJwYXJ0SWRcIl0gfHwgXCJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgaW50ZXJmYWNlXG4gICAgICovXG4gICAgaW5pdEludGVyZmFjZSgpIHtcbiAgICAgICAgbGV0IGNvbnN0YW50cyA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbjtcbiAgICAgICAgbGV0IGd1aSA9IG1ha2VJbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIGNvbnN0YW50cy5jb250YWluZXIgPSAkKGNvbnN0YW50cy5hdHRhY2htZW50UG9pbnQpLmh0bWwoJChndWkpKTtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2lnbm1lbnQoYXNzaWdubWVudF9pZCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpO1xuICAgIH1cblxuICAgIGxvYWRUYWdzKHRhZ3MpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhIEpTT04gbGlzdCByZXByZXNlbnRpbmcgdGFnc1xuICAgIH1cblxuICAgIGxvYWRTYW1wbGVTdWJtaXNzaW9ucyhzYW1wbGVzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHNhbXBsZXNcbiAgICB9XG5cbiAgICBsb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoYXNzaWdubWVudC5zdGFydGluZ19jb2RlKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9zdGFydGluZ19maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRTdWJtaXNzaW9uKHN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpIHtcbiAgICAgICAgaWYgKCFzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2FyaWVyIFwiWW91IGFyZSBub3QgbG9nZ2VkIGluIG1lc3NhZ2VcIlxuICAgICAgICAgICAgdGhpcy5sb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFdoYXQgaWYgc3VibWlzc2lvbnMnIGFzc2lnbm1lbnQgdmVyc2lvbiBhbmQgdGhlIGFzc2lnbm1lbnRzJyB2ZXJzaW9uIGNvbmZsaWN0P1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uaWQoc3VibWlzc2lvbi5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5iYWNrdXBTdWJtaXNzaW9uQ29kZShzdWJtaXNzaW9uLmNvZGUpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29kZShleHRyYWN0UGFydChzdWJtaXNzaW9uLmNvZGUsIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5wYXJ0SWQoKSkgfHwgXCJcIik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KHN1Ym1pc3Npb24uY29ycmVjdCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zY29yZShzdWJtaXNzaW9uLnNjb3JlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmVuZHBvaW50KHN1Ym1pc3Npb24uZW5kcG9pbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24udXJsKHN1Ym1pc3Npb24udXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnZlcnNpb24oc3VibWlzc2lvbi52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmdyYWRpbmdTdGF0dXMoc3VibWlzc2lvbi5ncmFkaW5nX3N0YXR1cyB8fCBTdWJtaXNzaW9uU3RhdHVzZXMuVU5LTk9XTik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKHN1Ym1pc3Npb24uc3VibWlzc2lvbl9zdGF0dXMgfHwgU3VibWlzc2lvblN0YXR1c2VzLlVOS05PV04pO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24ub3duZXJJZChzdWJtaXNzaW9uLnVzZXJfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLnVzZXIuY291cnNlSWQoc3VibWlzc2lvbi5jb3Vyc2VfaWQpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShzdWJtaXNzaW9uLmV4dHJhX2ZpbGVzLCB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyk7XG4gICAgfVxuXG4gICAgbG9hZEFzc2lnbm1lbnREYXRhXyhkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoZGF0YSk7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcmZhY2UoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZGlzbW91bnRFeHRyYUZpbGVzKCk7XG4gICAgICAgIGxldCB3YXNTZXJ2ZXJDb25uZWN0ZWQgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKCk7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICBsZXQgYXNzaWdubWVudCA9IGRhdGEuYXNzaWdubWVudDtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmlkKGFzc2lnbm1lbnQuaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudmVyc2lvbihhc3NpZ25tZW50LnZlcnNpb24pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuY291cnNlSWQoYXNzaWdubWVudC5jb3Vyc2VfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZm9ya2VkSWQoYXNzaWdubWVudC5mb3JrZWRfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZm9ya2VkVmVyc2lvbihhc3NpZ25tZW50LmZvcmtlZF92ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmhpZGRlbihhc3NpZ25tZW50LmhpZGRlbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZChhc3NpZ25tZW50LnJldmlld2VkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnB1YmxpYyhhc3NpZ25tZW50LnB1YmxpYyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC50eXBlKGFzc2lnbm1lbnQudHlwZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC51cmwoYXNzaWdubWVudC51cmwpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucG9pbnRzKGFzc2lnbm1lbnQucG9pbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmlwUmFuZ2VzKGFzc2lnbm1lbnQuaXBfcmFuZ2VzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucyhhc3NpZ25tZW50Lmluc3RydWN0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5uYW1lKGFzc2lnbm1lbnQubmFtZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShhc3NpZ25tZW50Lm9uX2NoYW5nZSB8fCBudWxsKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQub25fY2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKFwiIW9uX2NoYW5nZS5weVwiLCBhc3NpZ25tZW50Lm9uX2NoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbChhc3NpZ25tZW50Lm9uX2V2YWwgfHwgbnVsbCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50Lm9uX2V2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUoXCIhb25fZXZhbC5weVwiLCBhc3NpZ25tZW50Lm9uX2V2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vblJ1bihhc3NpZ25tZW50Lm9uX3J1bik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUoYXNzaWdubWVudC5zdGFydGluZ19jb2RlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50Lm93bmVySWQoYXNzaWdubWVudC5vd25lcl9pZCk7XG4gICAgICAgIHRoaXMubG9hZFRhZ3MoYXNzaWdubWVudC50YWdzKTtcbiAgICAgICAgdGhpcy5sb2FkU2FtcGxlU3VibWlzc2lvbnMoYXNzaWdubWVudC5zYW1wbGVfc3VibWlzc2lvbnMpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShhc3NpZ25tZW50LmV4dHJhX2luc3RydWN0b3JfZmlsZXMsIHRoaXMubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpO1xuICAgICAgICBsb2FkQXNzaWdubWVudFNldHRpbmdzKHRoaXMubW9kZWwsIGFzc2lnbm1lbnQuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmxvYWRTdWJtaXNzaW9uKGRhdGEuc3VibWlzc2lvbiwgYXNzaWdubWVudCk7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24odHJ1ZSk7XG4gICAgICAgIHRoaXMubW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG51bGwpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKHdhc1NlcnZlckNvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5jb3JnaXMubG9hZERhdGFzZXRzKHRydWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnJlZnJlc2goKTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICB9XG5cbiAgICBpbml0TW9kZWxNZXRob2RzKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIG1vZGVsLnVpID0ge1xuICAgICAgICAgICAgc21hbGxMYXlvdXQ6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSksXG4gICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgaXNHcmFkZXI6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVzZXIucm9sZSgpID09PSBcIm93bmVyXCIgfHwgbW9kZWwudXNlci5yb2xlKCkgPT09IFwiZ3JhZGVyXCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgaXNDaGFuZ2VkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuaXNDaGFuZ2VkKCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51dGlsaXRpZXMubWFya2Rvd24obW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZXNldDogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG51bGwpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudToge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGtvLnB1cmVDb21wdXRlZChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlJbnRlcmFjdGl2ZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0ZXh0RnVsbHNjcmVlbjoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oKSkgPyBcImZhLWNvbXByZXNzLWFycm93cy1hbHRcIiA6IFwiZmEtZXhwYW5kLWFycm93cy1hbHRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY2xpY2tGdWxsc2NyZWVuOiAoKSA9PntcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCFtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlZGl0SW5wdXRzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5kaWFsb2cuRURJVF9JTlBVVFMoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvZ2dsZUltYWdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5yZW5kZXJJbWFnZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0RWRpdG9yLmRpc2FibGVJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dEVkaXRvci5lbmFibGVJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnJlbmRlckltYWdlcyghbW9kZWwuZGlzcGxheS5yZW5kZXJJbWFnZXMoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW5NYXJrU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSB8fCBtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5jYW5DbG9zZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0ZXh0TWFya1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnVpLm1lbnUuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnVzZXIuZ3JvdXBJZCgpID8gXCJQcm9ibGVtIGNsb3NlZFwiIDogXCJBc3NpZ25tZW50IGNsb3NlZFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLnVpLm1lbnUuaXNTdWJtaXR0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVvcGVuIGZvciBlZGl0aW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgJiYgbW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdWJtaXRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3VibWl0IGVhcmx5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjbGlja01hcmtTdWJtaXR0ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnVpLm1lbnUuaXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJZb3UgY2Fubm90IHJlb3BlbiBjbG9zZWQgYXNzaWdubWVudHMuIENvbnRhY3QgYSBncmFkZXIhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLnVpLm1lbnUuaXNTdWJtaXR0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uU3RhdHVzKFwiaW5Qcm9ncmVzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmRlbGF5ZWRSdW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvblN0YXR1cyhcIlN1Ym1pdHRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAobW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpIHx8IG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuY2FuQ2xvc2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJzdWJtaXR0ZWRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cygpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29tcGxldGVkXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHNob3dRdWV1ZWRJbnB1dHM6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlUXVldWVkSW5wdXRzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHNob3dDbG9jazoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhhc0Nsb2NrKClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Vjb25kUm93OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6IFwiY29sLW1kLTVcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGlkZVRyYWNlQnV0dG9uOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlVHJhY2VCdXR0b24oKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNBbGxWaXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZU1pZGRsZVBhbmVsKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzRmVlZGJhY2tWaXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0tcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzVHJhY2VWaXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0VcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQ29uc29sZVNob3dWaXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuc2Vjb25kUm93LmlzRmVlZGJhY2tWaXNpYmxlKCkgfHwgbW9kZWwudWkuc2Vjb25kUm93LmlzVHJhY2VWaXNpYmxlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHN3aXRjaExhYmVsOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlZpZXcgVHJhY2VcIiA6IFwiXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGFkdmFuY2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFBhbmVsID0gbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDSyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1ha2VXaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYW5lbCA9IG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbChjdXJyZW50UGFuZWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN0b3JlUGFuZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRQYW5lbCA9IG1vZGVsLmRpc3BsYXkucHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFBhbmVsKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwob2xkUGFuZWwoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRQYW5lbChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25zb2xlOiB7XG4gICAgICAgICAgICAgICAgc2l6ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpKSB8fFxuICAgICAgICAgICAgICAgICAgICAobW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC02XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZGVFdmFsdWF0ZToga28ucHVyZUNvbXB1dGVkKCAoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUV2YWx1YXRlKCkgfHwgIW1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmdsb2JhbHMoKSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgICAgYmFkZ2U6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ1bnRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ydW50aW1lLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc3ludGF4LWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWRpdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc3ludGF4LWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1pbnRlcm5hbC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbWFudGljXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5hbHl6ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zZW1hbnRpYy1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZlZWRiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWZlZWRiYWNrLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1wcm9ibGVtLWNvbXBsZXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3Rpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtaW5zdHJ1Y3Rpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm8gZXJyb3JzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtbm8tZXJyb3JzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ1bnRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSdW50aW1lIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3ludGF4IEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWRpdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRWRpdG9yIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW50ZXJuYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnRlcm5hbCBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbWFudGljXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5hbHl6ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbGdvcml0aG0gRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmZWVkYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkluc3RydWN0aW9uc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbmNvcnJlY3QgQW5zd2VyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJDb21wbGV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vIGVycm9yc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmVzZXRTY29yZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnNjb3JlKDApO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24obW9kZWwuc3VibWlzc2lvbi5zY29yZSgpLCBtb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNlOiB7XG4gICAgICAgICAgICAgICAgaGFzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZExpbmU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgIT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSB8fCBzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cmFjZURhdGFbc3RlcC0xXS5saW5lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxpbmU6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSB8fCBzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyB0cmFjZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCZWZvcmUgcnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gbGFzdFN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkZpbmlzaGVkIHJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2h5IGFyZSB0aGVzZSBudW1iZXJzIHdvbmt5P1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTGluZSBcIisodHJhY2VEYXRhW3N0ZXAtMV0ubGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhc3Q6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN0YXJ0aW5nIGV4ZWN1dGlvblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBsYXN0U3RlcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJGaW5pc2hlZCBleGVjdXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ3VycmVudCBzdGVwOiBcIiArIEFTVF9ERVNDUklQVElPTlNbdHJhY2VEYXRhW3N0ZXAtMV0uYXN0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYWNrd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBNYXRoLm1heCgwLCBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3J3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gTWF0aC5taW4obW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSwgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobmV4dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxhc3RTdGVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZURhdGFbc3RlcCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VEYXRhW3N0ZXBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOiBcImNvbC1tZC02XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnRzOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuc3dlci5weVwiOiByZXR1cm4gbW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWluc3RydWN0aW9ucy5tZFwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2V2YWwucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP21vY2tfdXJscy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/aW1hZ2VzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP2ltYWdlcy5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfcHJlZml4LnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfc3VmZml4LnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90b29sYm94LmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhdGFncy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LnRhZ3MoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP21vY2tfdXJscy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9wcmVmaXgucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3N1ZmZpeC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90YWdzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/c2V0dGluZ3MuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP2ltYWdlcy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoLCBcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90b29sYm94LmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9ybWFsVG9vbGJveCA9IHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuVE9PTEJPWEVTW1wibm9ybWFsXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbFRvb2xib3ggPSBKU09OLnN0cmluZ2lmeShub3JtYWxUb29sYm94LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgsIG5vcm1hbFRvb2xib3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnMoW1NhbXBsZVN1Ym1pc3Npb24uQmxhbmsoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2NoYW5nZS5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGZpeCBleHRyYWZpbGVzIGZvciBpbnN0cnVjdG9yIGFuZCBzdHVkZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlRGlhbG9nKFwiaW5zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R1ZGVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJzdHVkZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydGluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJzdGFydGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5maWxlbmFtZShwYXRoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5hbWU6IChuZXdOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5yZW5hbWVGaWxlKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRTdHVkZW50Q29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVmaXhQeSA9IHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCIhYW5zd2VyX3ByZWZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeFB5ID0gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIiFhbnN3ZXJfc3VmZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHNlbGYubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXhQeSAmJiBwcmVmaXhQeS5oYW5kbGUgJiYgcHJlZml4UHkuaGFuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBwcmVmaXhQeS5oYW5kbGUoKSArIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1ZmZpeFB5ICYmIHN1ZmZpeFB5LmhhbmRsZSAmJiBzdWZmaXhQeS5oYW5kbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKyBzdWZmaXhQeS5oYW5kbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4dHJhU3R1ZGVudEZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhSW5zdHJ1Y3RvckZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKSxcbiAgICAgICAgICAgICAgICBleHRyYVN0YXJ0aW5nRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RmlsZW5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVSTCBEYXRhXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP2ltYWdlcy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkltYWdlc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFuc3dlciBQcmVmaXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbnN3ZXIgU3VmZml4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUb29sYm94XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIiZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yczoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3IobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6IFwiY29sLW1kLTdcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdmlldzoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRWRpdG9ycygpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlJbnRlcmFjdGl2ZSgpKSkgPyBcIk5vbmVcIiA6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA/IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpIDogXCJOb25lXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5SZXNldFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5jb2RlKG1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMoKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lKCkuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhblNhdmU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuZGlzcGxheS5hdXRvU2F2ZSgpKSxcbiAgICAgICAgICAgICAgICBjYW5EZWxldGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKCkgfHwgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIFVOREVMRVRBQkxFX0ZJTEVTLmluZGV4T2YobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKSA9PT0gLTEpLFxuICAgICAgICAgICAgICAgIGNhblJlbmFtZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKSB8fCBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgVU5SRU5BTUFCTEVfRklMRVMuaW5kZXhPZihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpID09PSAtMSksXG4gICAgICAgICAgICAgICAgdXBsb2FkOiB1cGxvYWRGaWxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkRmlsZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgICAgIGltcG9ydERhdGFzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmNvcmdpcy5vcGVuRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBweXRob246IHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGVNaXJyb3IgPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuY29kZU1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlTWlycm9yLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNvZGVNaXJyb3IuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1vZGU6IChuZXdNb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1WaWV3LkNoYW5nZVwiLCBcIlwiLCBcIlwiLCBuZXdNb2RlLCBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5weXRob25Nb2RlKG5ld01vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iub2xkUHl0aG9uTW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzSGlzdG9yeUF2YWlsYWJsZToga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpLFxuICAgICAgICAgICAgICAgICAgICB0dXJuT2ZmSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnNldFJlYWRPbmx5KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0dXJuT25IaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2FkSGlzdG9yeSgocmVzcG9uc2UpID0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5oaXN0b3J5LmxvYWQocmVzcG9uc2UuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9uSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVUb1N0YXJ0KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVByZXZpb3VzKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlTmV4dCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFJlY2VudDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVRvTW9zdFJlY2VudCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlOiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS51c2UoKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkSW1hZ2VzOiAoKSA9PiBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJpbWFnZVwiKS5yZWxvYWRJbWFnZXMoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZTogKCkgPT4gc2VsZi5jb21wb25lbnRzLnNlcnZlci5zYXZlQXNzaWdubWVudCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzYW1wbGVTdWJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBidWlsZEVkaXRvcjogKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGl0b3IgPSBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJTYW1wbGUgU3VibWlzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYnVpbGRFZGl0b3IobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IHtcbiAgICAgICAgICAgICAgICBpc1J1bm5pbmc6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBydW5MYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkUgPyBcIlN0b3BcIiA6IFwiUnVuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJ1bjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQeWdhbWVMaWIgIT09IFwidW5kZWZpbmVkXCIgJiYgUHlnYW1lTGliLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQeWdhbWVMaWIuU3RvcFB5Z2FtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZGVsYXllZFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZTogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5ldmFsdWF0ZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAoZW5kcG9pbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXItc3RhdHVzLVwiICsgbW9kZWwuc3RhdHVzW2VuZHBvaW50XSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0VuZHBvaW50Q29ubmVjdGVkOiAoZW5kcG9pbnQpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzW2VuZHBvaW50XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgY2FwaXRhbGl6ZShtb2RlbC5zdGF0dXMubG9hZEFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlQXNzaWdubWVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRIaXN0b3J5TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZEZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlRmlsZU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWREYXRhc2V0TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9nRXZlbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlSW1hZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy51cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSgpIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmb3JjZToge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudDogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBmaWxlSGFuZGxlciA9ICQoXCIuYmxvY2tweS1mb3JjZS1sb2FkLWFzc2lnbm1lbnQtZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9maWxlSGFuZGxlci5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLnBhcmVudCgpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXIgdG8gdXBsb2FkIGEgZmlsZSBjb250YWluaW5nIGFuIGFzc2lnbm1lbnQgc3VibWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IGFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b25bMF0uZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnRTdWJtaXNzaW9uID0gSlNPTi5wYXJzZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEFzc2lnbm1lbnREYXRhXyhhc3NpZ25tZW50U3VibWlzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIuZmlsZU5hbWUgPSBmaWxlc1swXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzVGV4dChmaWxlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uLnZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvbjogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2VsZi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkuZmFkZU91dCgxMDApLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvb3Rlcjoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGtvLnB1cmVDb21wdXRlZChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC51aS5zbWFsbExheW91dCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyhzZWxmLCBtb2RlbCk7XG4gICAgfVxuXG4gICAgdHVybk9uSGFja3MoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUT0RPXCIpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2ltYWdlLmpzXCJdID0gaW1hZ2VNb2R1bGUudG9TdHJpbmcoKTtcbiAgICAgICAgLy9Tay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3dlYWtyZWYuanNcIl0gPSB3ZWFrcmVmTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9tYXRwbG90bGliL3B5cGxvdC9fX2luaXRfXy5qc1wiXSA9IG1hdHBsb3RsaWJNb2R1bGUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseXMgdGhlIEtub2Nrb3V0SlMgYmluZGluZ3MgdG8gdGhlIG1vZGVsLCBpbnN0YW50aWF0aW5nIHRoZSB2YWx1ZXMgaW50byB0aGVcbiAgICAgKiBIVE1MLlxuICAgICAqL1xuICAgIGFwcGx5TW9kZWwoKSB7XG4gICAgICAgIGtvLmFwcGx5QmluZGluZ3ModGhpcy5tb2RlbCwgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lclswXSk7XG4gICAgfVxuXG4gICAgaW5pdFV0aWxpdGllcygpIHtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzO1xuICAgICAgICB0aGlzLnV0aWxpdGllcyA9IHtcbiAgICAgICAgICAgIG1hcmtkb3duOiAodGV4dCkgPT4gdGV4dCA/IEVhc3lNREUucHJvdG90eXBlLm1hcmtkb3duKHRleHQpIDogXCI8cD48L3A+XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbml0Q29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXI7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIGxldCBtYWluID0gdGhpcztcbiAgICAgICAgLy8gRWFjaCBvZiB0aGVzZSBjb21wb25lbnRzIHdpbGwgdGFrZSB0aGUgQmxvY2tQeSBpbnN0YW5jZSwgYW5kIHBvc3NpYmx5IGFcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIHRoZSByZWxldmFudCBIVE1MIGxvY2F0aW9uIHdoZXJlIGl0IHdpbGwgYmUgZW1iZWRkZWQuXG4gICAgICAgIGNvbXBvbmVudHMuZGlhbG9nID0gbmV3IEJsb2NrUHlEaWFsb2cobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1kaWFsb2dcIikpO1xuICAgICAgICBjb21wb25lbnRzLmZlZWRiYWNrID0gbmV3IEJsb2NrUHlGZWVkYmFjayhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy50cmFjZSA9IG5ldyBCbG9ja1B5VHJhY2UobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29uc29sZSA9IG5ldyBCbG9ja1B5Q29uc29sZShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWNvbnNvbGVcIikpO1xuICAgICAgICBjb21wb25lbnRzLmVuZ2luZSA9IG5ldyBCbG9ja1B5RW5naW5lKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmZpbGVTeXN0ZW0gPSBuZXcgQmxvY2tQeUZpbGVTeXN0ZW0obWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuZWRpdG9ycyA9IG5ldyBFZGl0b3JzKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZWRpdG9yXCIpKTtcbiAgICAgICAgLy8gQ29udmVuaWVudCBzaG9ydGN1dCBkaXJlY3RseSB0byBQeXRob25FZGl0b3JcbiAgICAgICAgY29tcG9uZW50cy5weXRob25FZGl0b3IgPSB0aGlzLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJweXRob25cIik7XG4gICAgICAgIGNvbXBvbmVudHMuc2VydmVyID0gbmV3IEJsb2NrUHlTZXJ2ZXIobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29yZ2lzID0gbmV3IEJsb2NrUHlDb3JnaXMobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuaGlzdG9yeSA9IG5ldyBCbG9ja1B5SGlzdG9yeShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWhpc3RvcnktdG9vbGJhclwiKSk7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgfVxuXG4gICAgbWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1JbnN0cnVjdGlvbnMuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQsIFwiaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9jayA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUNsb2NrID0gKCkgPT4gY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1tZW51LWNsb2NrXCIpLnRleHQoZ2V0Q3VycmVudFRpbWUoKSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnVpLm1lbnUuc2hvd0Nsb2NrKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzZXRJbnRlcnZhbCh1cGRhdGVDbG9jaywgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnVpLm1lbnUuc2hvd0Nsb2NrLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwudWkubWVudS5zaG93Q2xvY2soKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbG9jayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzZXRJbnRlcnZhbCh1cGRhdGVDbG9jaywgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIHJlc2V0SW50ZXJmYWNlKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIC8vIERpc2FibGUgYW55IGFsdGVybmF0aXZlIGxvZ0VudHJ5IGZ1bmN0aW9ucyB3ZSBoYXZlIGJlZW4gZ2l2ZW5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5hbHRMb2dFbnRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVxdWVzdFBhc3Njb2RlKCkge1xuICAgICAgICBsZXQgdXNlclN1cHBsaWVkUGFzc2NvZGUgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIHBhc3Njb2RlLlwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LnBhc3Njb2RlKHVzZXJTdXBwbGllZFBhc3Njb2RlKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuXG4gICAgfVxuXG59XG5cbiIsImltcG9ydCB7ZW5jb2RlSFRNTH0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5cbi8qKlxuICogRXZhbHVhdGUgYnV0dG9uIEhUTUwgdGVtcGxhdGVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFNUQVJUX0VWQUxfSFRNTCA9IGBcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tb3V0bGluZSBmbG9hdC1yaWdodCBibG9ja3B5LWJ0bi1ldmFsXCI+XG4gICAgRXZhbHVhdGVcbjwvYnV0dG9uPmA7XG5cbi8qKlxuICogSFRNTCB0ZW1wbGF0ZSBmb3IgYSBuZXcgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IE5FV19DT05TT0xFX0xJTkVfSFRNTCA9IFwiPGRpdj48L2Rpdj5cIjtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgZW50aXJlIGNvbnNvbGUgYXJlYVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENPTlNPTEVfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LXBhbmVsIGJsb2NrcHktY29uc29sZSdcbiAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkNvbnNvbGVcIlxuICAgICAgICAgIGRhdGEtYmluZD1cImNsYXNzOiB1aS5jb25zb2xlLnNpemVcIj5cbiAgICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LXNob3ctZmVlZGJhY2snXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5zZWNvbmRSb3cuaXNDb25zb2xlU2hvd1Zpc2libGUsIGNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgPHN0cm9uZz5Db25zb2xlOjwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1wcmludGVyIGJsb2NrcHktcHJpbnRlci1kZWZhdWx0Jz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICA8L2Rpdj5gO1xuXG4vKipcbiAqIEFsbCB0aGUgcG9zc2libGUgdHlwZXMgZm9yIGEgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEBlbnVtXG4gKi9cbmV4cG9ydCBsZXQgQ29uc29sZUxpbmVUeXBlID0ge1xuICAgIFRFWFQ6IFwidGV4dFwiLFxuICAgIEhUTUw6IFwiaHRtbFwiLFxuICAgIFBMT1Q6IFwicGxvdFwiLFxuICAgIElNQUdFOiBcImltYWdlXCIsXG4gICAgUFlHQU1FOiBcInB5Z2FtZVwiLFxuICAgIFRVUlRMRTogXCJ0dXJ0bGVcIixcbiAgICBFVkFMOiBcImV2YWxcIixcbiAgICBTVEFSVF9FVkFMOiBcInN0YXJ0X2V2YWxcIixcbiAgICBWQUxVRTogXCJ2YWx1ZVwiLFxuICAgIElOUFVUOiBcImlucHV0XCIsXG4gICAgVEVTVF9DQVNFOiBcInRlc3RfY2FzZVwiXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IHZlcnNpb24gb2YgYSBsaW5lIGluIHRoZSBjb25zb2xlLiBBbGwgb3RoZXIgY29uc29sZSBsaW5lc1xuICogc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLiBDcml0aWNhbGx5LCB0aGV5IG5lZWQgdG8gaW1wbGVtZW50IGEgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdHlwZSwgY29udGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIGJhY2sgdG8gdGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZS5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtCbG9ja1B5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdGVnb3JpemVzIHdoYXQga2luZCBvZiBsaW5lIHRoaXMgaXMgKHRleHQvaHRtbC9wbG90L2V0Yy4pXG4gICAgICAgICAqIEB0eXBlIHtDb25zb2xlTGluZVR5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdHVhbCBkYXRhIHN0b3JlZCBvbiB0aGlzIGxpbmUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0YWRhdGEgYWJvdXQgd2hlcmUgdGhlIGxpbmUgb3JpZ2luYXRlZCBmcm9tIGluIHRoZSBjb2RlLlxuICAgICAgICAgKiBAdHlwZSB7e2ZpbGVuYW1lOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgc3RlcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IFNrLmN1cnJGaWxlbmFtZSxcbiAgICAgICAgICAgIHN0ZXA6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAsXG4gICAgICAgICAgICBsaW5lOiBtYWluLmNvbXBvbmVudHMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSFRNTCBjb250ZW50IHN0b3JlZCBvbiB0aGlzIGxpbmUsIG1lYW50IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAqIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAdHlwZSB7KnxqUXVlcnkuZm4uaW5pdHxqUXVlcnl8SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh0bWwgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiAgXCJibG9ja3B5LXByaW50ZXItb3V0cHV0XCIsXG4gICAgICAgICAgICBcImRhdGEtY29udGFpbmVyXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnQsXG4gICAgICAgICAgICBcImRhdGEtdG9nZ2xlXCI6IFwidG9vbHRpcFwiLFxuICAgICAgICAgICAgXCJkYXRhLXBsYWNlbWVudFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiZGF0YS1zdGVwXCI6IHRoaXMub3JpZ2luLnN0ZXAsXG4gICAgICAgICAgICBcInRpdGxlXCI6IFwiU3RlcCBcIiArIHRoaXMub3JpZ2luLnN0ZXAgKyBcIiwgTGluZSBcIiArIHRoaXMub3JpZ2luLmxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxpbmUgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhbWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU2t1bHB0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc29sZSBsaW5lJ3MgY29udGVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0b1NrdWxwdCgpIHtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkodGhpcy5jb250ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhpcyBjb25zb2xlIGxpbmUgYnkgZGVsZXRpbmcgaXRzIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLmh0bWwucmVtb3ZlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVR1cnRsZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICAvLyBUT0RPOiBDYXB0dXJlIHR1cnRsZSBjb21tYW5kcyBmb3IgdHJhY2luZyBwdXJwb3Nlc1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlRVUlRMRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS10dXJ0bGUtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5wcmVwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbFswXS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAvLyQoJ2h0bWwnKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgICAgICQoXCJodG1sXCIpLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVB5Z2FtZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlBZR0FNRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1weWdhbWUtb3V0cHV0XCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuO1xuICAgICAgICB0aGlzLnB5Z2FtZU9iaiA9IHB5Z2FtZU9iajtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIC8vU2subWFpbl9jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q2FudmFzXCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLmh0bWwub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICAvLyBTdGFydHMgb2ZmIGFzIGEgbm8tb3BcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7fTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNlY29uZFJvdy5yZXN0b3JlUGFuZWwoKTtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZShjbGVhbnVwRnVuY3Rpb24sIGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwID0gKCkgPT4gY2xlYW51cEZ1bmN0aW9uKHRoaXMucHlnYW1lT2JqLCBsaXN0ZW5lcnMpO1xuICAgIH1cblxufVxuXG5jbGFzcyBDb25zb2xlTGluZUltYWdlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLklNQUdFLCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLWltYWdlLW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVBsb3QgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUExPVCwgY29udGVudCk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1wbG90LW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVGV4dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGFkZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQgKyBjb250ZW50O1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWVuY29kZWRUZXh0IHx8IGVuY29kZWRUZXh0LnRyaW0oKS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgIGVuY29kZWRUZXh0ID0gXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8c2FtcD48L3NhbXA+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVmFsdWUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5WQUxVRSwgY29udGVudCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8Y29kZT48L2NvZGU+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW5wdXQgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgcHJvbXB0TWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU5QVVQsIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSW5wdXQgYm94IGZvciByZWNlaXZpbmcgaW5wdXQoKSBmcm9tIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICovXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIC8vIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbmluZ1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBJbnB1dCBmb3JtXG4gICAgICAgICAgICBsZXQgaW5wdXRGb3JtID0gJChcIjxpbnB1dCB0eXBlPSd0ZXh0JyAvPlwiKTtcbiAgICAgICAgICAgIC8vIEVudGVyIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0QnRuID0gJChcIjxidXR0b24+PC9idXR0b24+XCIsIHtcImh0bWxcIjogXCJFbnRlclwifSk7XG4gICAgICAgICAgICAvLyBHcm91cCBmb3JtIGFuZCBidXR0b25cbiAgICAgICAgICAgIGxldCBpbnB1dEdyb3VwID0gJChcIjxkaXY+PC9kaXY+XCIsIHtcImNsYXNzXCI6IFwiYmxvY2tweS1jb25zb2xlLWlucHV0XCJ9KTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0Rm9ybSk7XG4gICAgICAgICAgICBpbnB1dEdyb3VwLmFwcGVuZChpbnB1dEJ0bik7XG4gICAgICAgICAgICAvLyBQcm9tcHQgYm94LCBuZXcgbGluZSwgaW5wdXQgZ3JvdXBcbiAgICAgICAgICAgIGxldCBpbnB1dEJveCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0TXNnID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgIHtcImh0bWxcIjogZW5jb2RlZFRleHR9KTtcbiAgICAgICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoaW5wdXRNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRCb3guYXBwZW5kKCQoXCI8YnI+XCIpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoaW5wdXRHcm91cCk7XG4gICAgICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQoaW5wdXRCb3gpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvLyBNYWtlIGl0IGludGVyYWN0aXZlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlSW50ZXJhY3RpdmUoaW5wdXRGb3JtLCBpbnB1dEJ0bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIG1ha2VJbnRlcmFjdGl2ZShpbnB1dCwgYnV0dG9uKSB7XG4gICAgICAgIGxldCByZXNvbHZlT25DbGljaztcbiAgICAgICAgbGV0IHN1Ym1pdHRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZU9uQ2xpY2sgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgbGV0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSBpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2godXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnV0dG9uLmNsaWNrKHN1Ym1pdEZvcm0pO1xuICAgICAgICBpbnB1dC5rZXl1cCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dEluZGV4LCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICBpbnB1dC52YWwodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlZFByb21pc2U7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZUV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmVJbnB1dCB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBcIkV2YWx1YXRlOlwiKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5TVEFSVF9FVkFMKTtcbiAgICAgICAgdGhpcy5odG1sLmFwcGVuZCgkKFNUQVJUX0VWQUxfSFRNTCkpO1xuICAgICAgICB0aGlzLmh0bWwuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmV4ZWN1dGUuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5Q29uc29sZSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZm9yIG1hbmFnaW5nIHRoZSBjb25zb2xlLCB3aXRoIGZlYXR1cmVzIGZvciB0aGluZ3MgbGlrZSBwcmludGluZywgcGxvdHRpbmcsIGV2YWxpbmcsIGlucHV0aW5nLlxuICAgICAqIFRoZSBcInByaW50ZXJcIiBpcyB0aGUgcmVnaW9uIHdoZXJlIHdlIHB1dCB0aGluZ3MsIGFzIG9wcG9zZWQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3aG9sZS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZyA9IHRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlclwiKTtcblxuICAgICAgICB0aGlzLk1JTklNVU1fV0lEVEggPSAyMDA7XG4gICAgICAgIHRoaXMuTUlOSU1VTV9IRUlHSFQgPSAyMDA7XG4gICAgICAgIHRoaXMuREVGQVVMVF9IRUlHSFQgPSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCk7IC8vIExldCBDU1MgZGVmaW5lIHRoaXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuXG4gICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQ7XG4gICAgICAgIC8vdGhpcy5pbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZSB1c2VyIG1vZGlmaWVzIGEgZmlsZSwgdGhlbiBtYWtlIHRoZSBjb25zb2xlIGxvb2sgZmFkZWQgYSBsaXR0bGVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXR1cyBvZiB0aGUgcHJpbnRlciwgaW5jbHVkaW5nIHJlbW92aW5nIGFueSB0ZXh0IGluIGl0IGFuZFxuICAgICAqIGZpeGluZyBpdHMgc2l6ZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmVtcHR5KCk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIHJlc2V0IGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBudWxsO1xuICAgICAgICBTay5UdXJ0bGVHcmFwaGljcyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUdXJ0bGVMaW5lLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmxvYWRBc3NldC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbnVsbDtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZ2V0VHVydGxlTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHVydGxlTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50dXJ0bGVMaW5lID0gbmV3IENvbnNvbGVMaW5lVHVydGxlKHRoaXMubWFpbik7XG4gICAgICAgICAgICB0aGlzLnR1cnRsZUxpbmUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCB3ZSdsbCBkbyBzb1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFByaW50ZXJEaW1lbnNpb24gPSB0aGlzLnByaW50ZXJUYWcud2lkdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KGN1cnJlbnRQcmludGVyRGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgICAgICAgICBTay5UdXJ0bGVHcmFwaGljcy5oZWlnaHQgPSBjdXJyZW50UHJpbnRlckRpbWVuc2lvbi00MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50dXJ0bGVMaW5lLmh0bWxbMF07XG4gICAgfVxuXG4gICAgaGFuZGxlUHlnYW1lUmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgYW5kIHRoZSBuZXdIZWlnaHQgaXMgYmlnZ2VyIHRoYW4gZGVmYXVsdCwgd2UnbGwgY2hhbmdlIGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpICYmXG4gICAgICAgICAgICBuZXdIZWlnaHQgPiB0aGlzLkRFRkFVTFRfSEVJR0hUKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KDMwK25ld0hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcHlnYW1lIHdpbmRvdyBpcyB3aWRlciB0aGFuIHRoZSBjb25zb2xlLCB3ZSdsbCBleHBhbmQgdGVtcG9yYXJpbHkuXG4gICAgICAgIGlmIChuZXdXaWR0aCA+IHRoaXMucHJpbnRlclRhZy53aWR0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuc2Vjb25kUm93Lm1ha2VXaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5pc2hUdXJ0bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc2F2ZVR1cnRsZU91dHB1dCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50dXJ0bGVMaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMudHVydGxlTGluZS5odG1sLmZpbmQoXCJjYW52YXNcIikubGFzdCgpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUltYWdlKFwidHVydGxlX291dHB1dFwiLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5weWdhbWVMaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMucHlnYW1lTGluZS5jYW52YXM7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlSW1hZ2UoXCJ0dXJ0bGVfb3V0cHV0XCIsIGRhdGFVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHRoZXJlIGFyZSBubyB0dXJ0bGVzIHRvIHNhdmU/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0dXJ0bGVzIHNob3VsZCBiZSBiYXNlZCBvbiB0aGUgY3VycmVudCB3aWR0aFxuICAgIG5ld1R1cnRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fV0lEVEgsIHRoaXMucHJpbnRlclRhZy53aWR0aCgpLTQwKTtcbiAgICB9XG5cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLk1JTklNVU1fSEVJR0hULCB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkrNDApO1xuICAgIH1cblxuICAgIGlzTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZWFjaCBwcmludGVkIGVsZW1lbnQgaW4gdGhlIHByaW50ZXIgYW5kIG1ha2VzIGl0IGhpZGRlblxuICAgICAqIG9yIHZpc2libGUsIGRlcGVuZGluZyBvbiB3aGF0IHN0ZXAgd2UncmUgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcCAtIFRoZSBjdXJyZW50IHN0ZXAgb2YgdGhlIGV4ZWN1dGVkIHByb2dyYW0gdGhhdCB3ZSdyZSBvbjsgZWFjaCBlbGVtZW50IGluIHRoZSBwcmludGVyIG11c3QgYmUgbWFya2VkIHdpdGggYSBcImRhdGEtc3RlcFwiIHByb3BlcnR5IHRvIHJlc29sdmUgdGhpcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFnZSAtIERlcHJlY2F0ZWQsIG5vdCBzdXJlIHdoYXQgdGhpcyBldmVuIGRvZXMuXG4gICAgICovXG4gICAgc3RlcFByaW50ZXIoc3RlcCwgcGFnZSkge1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcuZmluZChcIi5ibG9ja3B5LXByaW50ZXItb3V0cHV0XCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKFwiZGF0YS1zdGVwXCIpIDw9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmludCBhIGxpbmUgdG8gdGhlIG9uLXNjcmVlbiBwcmludGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lVGV4dCAtIEEgbGluZSBvZiB0ZXh0IHRvIGJlIHByaW50ZWQgb3V0LlxuICAgICAqL1xuICAgIHByaW50KGxpbmVUZXh0KSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgbWVhbnMgZG8gbm90aGluZy5cbiAgICAgICAgLy8gcHJpbnQoXCJcIiwgZW5kPVwiXCIpXG4gICAgICAgIGlmICghbGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmx1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpbmVUZXh0LmNoYXJBdChsaW5lVGV4dC5sZW5ndGgtMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BsaXRMaW5lcyA9IGxpbmVUZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBpZiAodGhpcy5saW5lQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLmFkZENvbnRlbnQoc3BsaXRMaW5lc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0xOyBpIDwgc3BsaXRMaW5lcy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRoaXMubGluZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVUZXh0KHRoaXMubWFpbiwgQ29uc29sZUxpbmVUeXBlLlRFWFQsIHNwbGl0TGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0aGlzLmxpbmVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHBsb3QocGxvdHMpIHtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lUGxvdCh0aGlzLm1haW4sIHBsb3RzKTtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wbG90QnVmZmVyO1xuICAgIH1cblxuICAgIHB5Z2FtZShzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgaWYgKHRoaXMucHlnYW1lTGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbmV3IENvbnNvbGVMaW5lUHlnYW1lKHRoaXMubWFpbiwgc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKTtcbiAgICAgICAgICAgIHRoaXMucHlnYW1lTGluZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5weWdhbWVMaW5lO1xuICAgIH1cblxuICAgIHByaW50UElMSW1hZ2UoaW1hZ2VEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVFwiLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lSW1hZ2UodGhpcy5tYWluLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwcmludFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBwcmludGVkVmFsdWUgPSBuZXcgQ29uc29sZUxpbmVWYWx1ZSh0aGlzLm1haW4sIHZhbHVlKTtcbiAgICAgICAgcHJpbnRlZFZhbHVlLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gcHJpbnRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIFByb21pc2UgZnJvbSB0aGUgSW5wdXQgYm94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb21wdE1lc3NhZ2UgLSBNZXNzYWdlIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbnB1dCh0aGlzLm1haW4sIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9O1xuXG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUV2YWx1YXRlKHRoaXMubWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIGJlZ2luRXZhbCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RXZhbHVhdGlvbiA9IG5ldyBDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RXZhbHVhdGlvbi5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmNvbmRpdGlvbmFsbHkgc2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnRhZy5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcucHJvcChcInNjcm9sbEhlaWdodFwiKSAtIHRoaXMudGFnLnByb3AoXCJjbGllbnRIZWlnaHRcIilcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuXG59IiwiaW1wb3J0IHtzbHVnfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLy8gVE9ETzogZWRpdG9yLmJtLmJsb2NrRWRpdG9yLmV4dHJhVG9vbHNbXVxuXG5leHBvcnQgbGV0IF9JTVBPUlRFRF9EQVRBU0VUUyA9IHt9O1xuZXhwb3J0IGxldCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMgPSB7fTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdmVyeSBzaW1wbGlzdGljIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgdHJhbnNmb3JtXG4gKiBhIGdpdmVuIGJ1dHRvbiBpbnRvIGEgXCJMb2FkZWRcIiBzdGF0ZSAoZGlzYWJsZWQsIHByZXNzZWQgc3RhdGUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ0biAtIEFuIEhUTUwgZWxlbWVudCB0byBjaGFuZ2UgdGhlIHRleHQgb2YuXG4gKi9cbmxldCBzZXRCdXR0b25Mb2FkZWQgPSBmdW5jdGlvbiAoYnRuKSB7XG4gICAgYnRuLmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpXG4gICAgICAgIC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLnRleHQoXCJMb2FkZWRcIilcbiAgICAgICAgLmF0dHIoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbm5lY3RzIHRvIHRoZSBDT1JHSVMgZGF0YXNldHMgYW5kIG1hbmFnZXMgaW50ZXJhY3Rpb25zXG4gKiB3aXRoIHRoZW0uIFRoaXMgaW5jbHVkZXMgbG9hZGluZyBpbiBkYXRhc2V0cyBhdCBsYXVuY2ggYW5kIG9uLXRoZS1mbHkuXG4gKiBOb3RlIHRoYXQgdGhpcyBoYXMgbm8gcHJlc2VuY2Ugb24gc2NyZWVuLCBzbyBpdCBkb2VzIG5vdCBoYXZlIGEgdGFnLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlDb3JnaXN9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlDb3JnaXMobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICB0aGlzLmxvYWRlZERhdGFzZXRzID0gW107XG4gICAgdGhpcy5sb2FkRGF0YXNldHMoKTtcbn1cblxuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUubG9hZERhdGFzZXRzID0gZnVuY3Rpb24gKHNpbGVudGx5KSB7XG4gICAgLy8gTG9hZCBpbiBlYWNoIHRoZSBkYXRhc2V0c1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbCxcbiAgICAgICAgZWRpdG9yID0gdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLFxuICAgICAgICBzZXJ2ZXIgPSB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXI7XG4gICAgbGV0IGltcG9ydHMgPSBbXTtcbiAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzKCkuc3BsaXQoXCIsXCIpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIShuYW1lIGluIEJsb2NrTWlycm9yQmxvY2tFZGl0b3IuRVhUUkFfVE9PTFMpKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2guYXBwbHkoaW1wb3J0cywgdGhpcy5pbXBvcnREYXRhc2V0KHNsdWcobmFtZSksIG5hbWUsIHNpbGVudGx5KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgYXJlIGxvYWRlZCwgdXBkYXRlIHRoZSB0b29sYm94LlxuICAgICQud2hlbi5hcHBseSgkLCBpbXBvcnRzKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRSSUdHRVJFRFwiKTtcbiAgICAgICAgZWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlcnZlci5maW5hbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIGRlZmluaXRpb25zIGZvciBhIGRhdGFzZXQgaW50byB0aGUgZW52aXJvbm1lbnQsIGluY2x1ZGluZ1xuICogdGhlIGRhdGFzZXQgKGFzIGEgSlMgZmlsZSksIHRoZSBza3VscHQgYmluZGluZ3MsIGFuZCB0aGUgYmxvY2tseVxuICogYmluZGluZ3MuIFRoaXMgcmVxdWlyZXMgYWNjZXNzIHRvIGEgQ09SR0lTIHNlcnZlciwgYW5kIG9jY3Vyc1xuICogYXN5bmNocm9ub3VzbHkuIFRoZSByZXF1ZXN0cyBhcmUgZmlyZWQgYW5kIHRoZWlyIGRlZmVycmVkIG9iamVjdHNcbiAqIGFyZSByZXR1cm5lZCAtIGNhbGxlcnMgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHBlcmZvcm0gYW4gYWN0aW9uXG4gKiBvbiBjb21wbGV0aW9uIG9mIHRoZSBpbXBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNsdWcgLSBUaGUgVVJMIHNhZmUgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSB1c2VyLWZyaWVuZGx5IHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheS48RGVmZXJyZWQ+fSAtIFJldHVybnMgdGhlIGFzeW5jIHJlcXVlc3RzIGFzIGRlZmVycmVkIG9iamVjdHMuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLmltcG9ydERhdGFzZXQgPSBmdW5jdGlvbiAoc2x1ZywgbmFtZSkge1xuICAgIGxldCB1cmxfcmV0cmlldmFscyA9IFtdO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJpbXBvcnREYXRhc2V0c1wiKSkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW1wb3J0RGF0YXNldHMgKyBcImJsb2NrcHkvXCIgKyBzbHVnICsgXCIvXCIgKyBzbHVnO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5sb2FkaW5nRGF0YXNldHMucHVzaChuYW1lKTtcbiAgICAgICAgLy8gQWN0dWFsbHkgZ2V0IGRhdGFcbiAgICAgICAgbGV0IGdldERhdGFzZXQgPSAkLmdldFNjcmlwdChyb290ICsgXCJfZGF0YXNldC5qc1wiKTtcbiAgICAgICAgLy8gTG9hZCBnZXRDb21wbGV0ZSBzaWxlbnRseSBpbiB0aGUgYmFja2dyb3VuZCBiZWNhdXNlIGl0cyBiaWcgOihcbiAgICAgICAgbGV0IGdldENvbXBsZXRlID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2NvbXBsZXRlLmpzXCIpO1xuICAgICAgICBsZXQgZ2V0U2t1bHB0ID0gJC5nZXQocm9vdCArIFwiX3NrdWxwdC5qc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bXCJzcmMvbGliL1wiICsgc2x1ZyArIFwiL19faW5pdF9fLmpzXCJdID0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnZXRCbG9ja2x5ID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2Jsb2NrbHkuanNcIik7XG4gICAgICAgIC8vIE9uIGNvbXBsZXRpb24sIHVwZGF0ZSBtZW51cy5cbiAgICAgICAgJC53aGVuKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZERhdGFzZXRzLnB1c2goc2x1Zyk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dFRvQmxvY2tzLmhpZGRlbkltcG9ydHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5mb3JjZUJsb2NrUmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1cmxfcmV0cmlldmFscy5wdXNoKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxfcmV0cmlldmFscztcbn07XG5cbi8qKlxuICogT3BlbnMgYSBkaWFsb2cgYm94IHRvIHByZXNlbnQgdGhlIHVzZXIgd2l0aCB0aGUgZGF0YXNldHMgYXZhaWxhYmxlXG4gKiB0aHJvdWdoIHRoZSBDT1JHSVMgc2VydmVyLiBUaGlzIHJlcXVpcmVzIGEgY2FsbCwgc28gdGhpcyBtZXRob2RcbiAqIGNvbXBsZXRlcyBhc3luY2hyb25vdXNseS4gVGhlIGRpYWxvZyBpcyBjb21wb3NlZCBvZiBhIHRhYmxlIHdpdGhcbiAqIGJ1dHRvbnMgdG8gbG9hZCB0aGUgZGF0YXNldHMgKE1vcmUgdGhhbiBvbmUgZGF0YXNldCBjYW4gYmUgbG9hZGVkXG4gKiBmcm9tIHdpdGhpbiB0aGUgZGlhbG9nIGF0IGEgdGltZSkuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cztcbiAgICAgICAgJC5nZXRKU09OKHJvb3QgKyBcImluZGV4Lmpzb25cIiwgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHVwIHRoZSBCb2R5XG4gICAgICAgICAgICBsZXQgZGF0YXNldHMgPSBkYXRhLmJsb2NrcHk7XG4gICAgICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHJvb3QrXCJibG9ja3B5L2luZGV4Lmh0bWxcIjtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICQoYDxwPkRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0IDxhIGhyZWY9JyR7ZG9jdW1lbnRhdGlvbn0nIHRhcmdldD1fYmxhbms+dXJsPC9hPjwvcD5gKTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gJChcIjx0YWJsZT48L3RhYmxlPlwiLCB7XCJjbGFzc1wiOiBcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWRcIn0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YXNldHMpLnNvcnQoKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2x1Z2dlZE5hbWUgPSBzbHVnKGRhdGFzZXRzW25hbWVdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxldCBidG4gPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5Mb2FkPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGltZ1NyYyA9IHJvb3QrXCIuLi9pbWFnZXMvZGF0YXNldHMvXCIrbmFtZStcIi1pY29uLnBuZ1wiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZERhdGFzZXRzLmluZGV4T2Yoc2x1Z2dlZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnRuLmNsaWNrKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydERhdGFzZXQoc2x1Z2dlZE5hbWUsIFwiRGF0YSAtIFwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xldCBpbWcgPSBgPGltZyBzcmM9JyR7aW1nU3JjfScgY2xhc3M9XCJjb3JnaXMtaWNvblwiPmA7XG4gICAgICAgICAgICAgICAgJChcIjx0cj48L3RyPlwiKVxuICAgICAgICAgICAgICAgICAgICAvLy5hcHBlbmQoJChcIjx0ZD5cIiArIGltZyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD5cIiArIGRhdGFzZXRzW25hbWVdLnRpdGxlICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0ub3ZlcnZpZXcgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+PC90ZD5cIikuYXBwZW5kKGJ0bikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhib2R5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRUbyhzdGFydCk7XG4gICAgICAgICAgICAvLyBTaG93IHRoZSBhY3R1YWwgZGlhbG9nXG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuc2hvdyhcIkltcG9ydCBEYXRhc2V0c1wiLCBzdGFydCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE2NjQ2NDg2MjA1MzRcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvYWNiYXJ0L1Byb2plY3RzL2Jsb2NrcHktZWR1L2Jsb2NrcHkvbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiLi4vXCIsXCJobXJcIjp0cnVlLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTY2NDY0ODYyMDUxNlxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9hY2JhcnQvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBUT0RPOiBEeWFubWljYWxseSBwb3B1bGF0ZSBhcmlhLWxhYmVsbGVkYnkgaW4gdGhpcyBhbmQgb3RoZXIgcGxhY2VzXG5cbmV4cG9ydCBsZXQgRElBTE9HX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz0nYmxvY2tweS1kaWFsb2cgbW9kYWwgaGlkZGVuJ1xuICAgICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICAgICBhcmlhLWxhYmVsPSdEaWFsb2cnXG4gICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZGlhbG9nIG1vZGFsLWxnJyByb2xlPVwiZG9jdW1lbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWNvbnRlbnQnIHJvbGU9J3JlZ2lvbicgYXJpYS1sYWJlbD0nRGlhbG9nIGNvbnRlbnQnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz0nbW9kYWwtdGl0bGUnPkR5bmFtaWMgQ29udGVudDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWJvZHknIHN0eWxlPSdtYXgtd2lkdGg6MTAwJTsgbWF4LWhlaWdodDo0MDBweCc+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlIG1vZGFsLWNsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJz5DbG9zZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tc3VjY2VzcyBtb2RhbC1va2F5JyBkYXRhLWRpc21pc3M9J21vZGFsJz5Pa2F5PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICAgIFxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuYDtcblxuLyoqXG4gKiBBIHV0aWxpdHkgb2JqZWN0IGZvciBxdWlja2x5IGFuZCBjb252ZW5pZW50bHkgZ2VuZXJhdGluZyBkaWFsb2cgYm94ZXMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3QgZHluYW1pY2FsbHkgY3JlYXRlIG5ldyBib3hlczsgaXQgcmV1c2VzIHRoZSBzYW1lIG9uZVxuICogb3ZlciBhbmQgb3ZlciBhZ2Fpbi4gSXQgdHVybnMgb3V0IGR5bmFtaWNhbGx5IGdlbmVyYXRpbmcgbmV3IGRpYWxvZyBib3hlc1xuICogaXMgYSBwYWluISBTbyB3ZSBjYW4ndCBzdGFjayB0aGVtLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlEaWFsb2d9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeURpYWxvZyhtYWluLCB0YWcpIHtcbiAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgdGhpcy50aXRsZVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLXRpdGxlXCIpO1xuICAgIHRoaXMuYm9keVRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLWJvZHlcIik7XG4gICAgdGhpcy5mb290ZXJUYWcgPSB0YWcuZmluZChcIi5tb2RhbC1mb290ZXJcIik7XG4gICAgdGhpcy5va2F5QnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtb2theVwiKTtcbiAgICB0aGlzLmNsb3NlQnV0dG9uID0gdGFnLmZpbmQoXCIubW9kYWwtY2xvc2VcIik7XG5cbiAgICB0aGlzLnllcyA9ICgpID0+IHt9O1xuICAgIHRoaXMubm8gPSAoKSA9PiB7fTtcbiAgICB0aGlzLm9rYXlCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLnllcygpO1xuICAgICAgICB0aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG4gICAgdGhpcy5jbG9zZUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMubm8oKTtcbiAgICAgICAgLy90aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG4gICAgfSk7XG59XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgZXh0ZXJuYWxseSBhdmFpbGFibGUgZnVuY3Rpb24gZm9yIHBvcHBpbmcgdXAgYSBkaWFsb2dcbiAqIG1lc3NhZ2UuIFRoaXMgbWVudSB3aWxsIGJlIGRyYWdnYWJsZSBieSBpdHMgdGl0bGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBtZXNzYWdlIGRpYWxvZy4gQ2FuIGhhdmUgSFRNTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG1lc3NhZ2UgZGlhbG9nLiBDYW4gaGF2ZSBIVE1MLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25jbG9zZSAtIEEgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSBkaWFsb2cuXG4gKi9cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAodGl0bGUsIGJvZHksIG9uY2xvc2UpIHtcbiAgICB0aGlzLnRpdGxlVGFnLmh0bWwodGl0bGUpO1xuICAgIHRoaXMuYm9keVRhZy5odG1sKGJvZHkpO1xuICAgIHRoaXMudGFnLm1vZGFsKFwic2hvd1wiKTtcbiAgICB0aGlzLm9rYXlCdXR0b24uaGlkZSgpO1xuICAgIHRoaXMudGFnLmRyYWdnYWJsZSh7XG4gICAgICAgIFwiaGFuZGxlXCI6IFwiLm1vZGFsLXRpdGxlXCJcbiAgICB9KTtcblxuICAgIHRoaXMudGFnLm9uKFwiaGlkZGVuLmJzLm1vZGFsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvbmNsb3NlICE9PSB1bmRlZmluZWQgJiYgb25jbG9zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5jb25maXJtID0gZnVuY3Rpb24gKHRpdGxlLCBib2R5LCB5ZXMsIG5vLCB5ZXNUZXh0KSB7XG4gICAgaWYgKHllc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5ZXNUZXh0ID0gXCJPa2F5XCI7XG4gICAgfVxuICAgIHRoaXMuc2hvdyh0aXRsZSwgYm9keSwgbm8pO1xuICAgIHRoaXMueWVzID0geWVzO1xuICAgIHRoaXMubm8gPSBubztcbiAgICB0aGlzLm9rYXlCdXR0b24uc2hvdygpLmh0bWwoeWVzVGV4dCk7XG4gICAgLy8gVE9ETzogYWRkIG9rYXkgYnV0dG9uIGFuZCBjYW5jZWwgYnV0dG9uXG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5BU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbmZpcm0oXCJBc3NpZ25tZW50IENoYW5nZWRcIiwgXCJZb3VyIGluc3RydWN0b3IgaGFzIG1hZGUgY2hhbmdlcyB0byB0aGlzIGFzc2lnbm1lbnQuIFdvdWxkIHlvdSBsaWtlIHRvIHJlbG9hZD8gQWxsIHlvdXIgd29yayBoYXMgYmVlbiBzYXZlZC5cIiwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMb2FkaW5nIEFzc2lnbm1lbnRcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9MSVNUSU5HX1VQTE9BREVEX0ZJTEVTID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExpc3RpbmcgVXBsb2FkZWQgRmlsZXNcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbGlzdGluZyB0aGUgdXBsb2FkZWQgZmlsZXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfVVBMT0FESU5HX0ZJTEUgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgVXBsb2FkZWQgRmlsZVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB1cGxvYWRpbmcgdGhlIGZpbGUuPGJyPlxuUGxlYXNlIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBTYXZpbmcgQXNzaWdubWVudFwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBzYXZpbmcgdGhlIGFzc2lnbm1lbnQuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfU0hPV19TVFVERU5UX0VSUk9SID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5zaG93KFwiT3JpZ2luYWwgRXJyb3JcIiwgYFdoZW4gSSByYW4geW91ciBjb2RlLCBJIGVuY291bnRlcmVkIGFuIGVycm9yOlxcblxcbjxkaXYgY2xhc3M9XCJibG9ja3B5LWRpYWxvZy1zdHVkZW50LWVycm9yLW1lc3NhZ2VcIj4ke2Vycm9yfTwvZGl2PmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuUE9TSVRJVkVfRkVFREJBQ0tfRlVMTCA9IGZ1bmN0aW9uICh0aXRsZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuc2hvdyh0aXRsZSwgbWVzc2FnZSk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5TQ1JFRU5TSE9UX0JMT0NLUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPXG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBVcGRhdGluZyBTdWJtaXNzaW9uIFN0YXR1c1wiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSB1cGRhdGluZyB5b3VyIHN1Ym1pc3Npb24gc3RhdHVzLjxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi5gKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xPQURJTkdfSElTVE9SWSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMb2FkaW5nIEhpc3RvcnlcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyB5b3VyIGhpc3RvcnkuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuT0ZGRVJfRk9SSyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgc2V0dXBVcmwgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzLmluc3RydWN0aW9uc0Fzc2lnbm1lbnRTZXR1cDtcbiAgICBzZXR1cFVybCA9IHNldHVwVXJsID8gYCAoPGEgaHJlZj1cIiR7c2V0dXBVcmx9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+SG93IGRvIEkgZG8gdGhhdD88L2E+KWAgOiBcIlwiO1xuICAgIHRoaXMuc2hvdyhcIkFzc2lnbm1lbnQgTm90IE93bmVkOyBGb3JrP1wiLCBgXG4gICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgSXQgbG9va3MgbGlrZSB5b3Ugd2FudCB0byBlZGl0IHRoaXMgYXNzaWdubWVudCwgYnV0IHlvdSBhcmUgbm90IGFuIGluc3RydWN0b3JcbiAgICBvciBkZXNpZ25lciBpbiB0aGUgY291cnNlIHRoYXQgb3ducyBpdCAoXCJDb3Vyc2UgTmFtZVwiKS4gV291bGQgeW91IGxpa2UgdG8gZm9ya1xuICAgIHRoaXMgYXNzaWdubWVudCAob3IgaXRzIGVudGlyZSBncm91cCkgc28gdGhhdCB5b3UgY2FuIHNhdmUgeW91ciBtb2RpZmljYXRpb25zP1xuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICAgIFJlbWVtYmVyIHRvIHVwZGF0ZSB0aGUgTGF1bmNoIFVSTCBpbiB0aGUgYXNzaWdubWVudHMnIHNldHRpbmdzIG9uIENhbnZhcyEke3NldHVwVXJsfVxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlJz5Gb3JrIGVudGlyZSBhc3NpZ25tZW50IGdyb3VwPC9idXR0b24+PC9kaXY+XG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUnPkZvcmsganVzdCB0aGlzIGFzc2lnbm1lbnQ8L2J1dHRvbj48L2Rpdj5cbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1kYW5nZXInPlJlc2V0IG15IGxvY2FsIGNoYW5nZXM8L2J1dHRvbj48L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCJcbiAgICAgICAgICAgICAgICBuYW1lPVwiYmxvY2tweS10cmFuc2Zlci1zdWJtaXNzaW9uc1wiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS10cmFuc2Zlci1zdWJtaXNzaW9uc1wiPlRyYW5zZmVyIFN0dWRlbnQgU3VibWlzc2lvbnMgZm9yIHRoaXMgY291cnNlPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tdGV4dFwiIGZvcj1cImJsb2NrcHktY291cnNlLWlkXCI+TmV3IG93bmluZyBjb3Vyc2UgaWQ6IDwvbGFiZWw+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJibG9ja3B5LWNvdXJzZS1pZFwiIHZhbHVlPVwiJHt0aGlzLm1haW4ubW9kZWwudXNlci5jb3Vyc2VJZCgpfVwiPlxuICAgIDwvZGl2PlxuICAgIGApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRURJVF9JTlBVVFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGlucHV0VGV4dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5qb2luKFwiXFxuXCIpO1xuICAgIGxldCBjbGVhcklucHV0cyA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCkgPyBcIlwiIDogXCJjaGVja2VkXCI7XG4gICAgbGV0IHllcyA9ICgpID0+IHtcbiAgICAgICAgbGV0IGNoZWNrZWQgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktcmVtZW1iZXItaW5wdXRzXCIpLnByb3AoXCJjaGVja2VkXCIpO1xuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWlucHV0LWxpc3RcIikudmFsKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCFjaGVja2VkKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dChpbnB1dHMpO1xuICAgIH07XG4gICAgdGhpcy5jb25maXJtKFwiRWRpdCBSZW1lbWJlcmVkIElucHV0c1wiLCBgXG5cbjxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0cyBmb3JtLWNoZWNrLWlucHV0XCJcbiAgICAgICAgbmFtZT1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzXCIgJHtjbGVhcklucHV0c30+XG48bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIj5SZXVzZSBpbnB1dHMgZm9yIG5leHQgZXhlY3V0aW9uPC9sYWJlbD5cbjwvZGl2PlxuXG48dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWlucHV0LWxpc3QgZm9ybS1jb250cm9sXCIgcm93cz1cIjRcIj4ke2lucHV0VGV4dH08L3RleHRhcmVhPjxicj5cbkVkaXQgdGhlIGlucHV0cyBhYm92ZSB0byBzdG9yZSBhbmQgcmV1c2UgdGhlbSBhY3Jvc3MgbXVsdGlwbGUgZXhlY3V0aW9ucy5cbkVhY2ggaW5wdXQgc2hvdWxkIGJlIHB1dCBvbiBpdHMgb3duIGxpbmUuXG5Zb3UgZG8gbm90IG5lZWQgcXVvdGVzOyB0aGUgdGV4dCB3aWxsIGJlIGVudGVyZWQgbGl0ZXJhbGx5LlxuIFxuYCwgeWVzLCB0aGlzLm5vLCBcIlNhdmVcIik7XG4gICAgLy8gVE9ETzogQWxsb3cgdXNlciB0byBzcGVjaWZ5IHRoZSBpbmZpbml0ZSBzdHJpbmcgdG8ga2VlcCBnaXZpbmcgd2hlbiB0aGUgb3RoZXJzIHJ1biBvdXRcbn07IiwiaW1wb3J0IHtFZGl0b3JzfSBmcm9tIFwiLi4vZWRpdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQudGFyZ2V0LmZpbGVzO1xuICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGUgPT5cbiAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5jdXJyZW50KCkudXBsb2FkRmlsZShlKVxuICAgICk7XG4gICAgZmlsZVJlYWRlci5maWxlTmFtZSA9IGZpbGVzWzBdLm5hbWU7XG4gICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGVzWzBdKTtcbiAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2x1Z2dpZnkodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1teYS16MC05XS9naSwgXCJfXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEZpbGUobW9kZWwsIGV2ZW50KSB7XG4gICAgbGV0IHtuYW1lLCBleHRlbnNpb24sIGNvbnRlbnRzLCBtaW1ldHlwZX0gPSBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS5kb3dubG9hZEZpbGUoKTtcbiAgICAvLyBNYWtlIHNhZmVcbiAgICBuYW1lID0gc2x1Z2dpZnkobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUgKyBleHRlbnNpb247XG4gICAgLy8gTWFrZSB0aGUgZGF0YSBkb3dubG9hZCBhcyBhIGZpbGVcbiAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50c10sIHt0eXBlOiBtaW1ldHlwZX0pO1xuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIG5hbWUpO1xuICAgIH0gZWxzZXtcbiAgICAgICAgbGV0IHRlbXBvcmFyeURvd25sb2FkTGluayA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgdGVtcG9yYXJ5RG93bmxvYWRMaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgdGVtcG9yYXJ5RG93bmxvYWRMaW5rLmRvd25sb2FkID0gbmFtZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wb3JhcnlEb3dubG9hZExpbmspO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuY2xpY2soKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wb3JhcnlEb3dubG9hZExpbmspO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5maWxlU3lzdGVtID0gbWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW07XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGUgPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZUZpbGUoKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS5kZWxldGVGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlRGVsZXRlZCgpIHtcbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIHRoZSBwcmV2aW91cyBmaWxlIGluc3RlYWQgb2YgYSBkZWZhdWx0IGZpbGVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmVkaXRvcnMuY2hhbmdlRWRpdG9yKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIG9uRmlsZVVwZGF0ZWQoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5maWxlbmFtZSA9PT0gdGhpcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgLy90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZVN5c3RlbS5zdG9wV2F0Y2hpbmdGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy90aGlzLnRyYWNrQ3VycmVudEZpbGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrQ3VycmVudEZpbGUoKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS53YXRjaEZpbGUodGhpcy5maWxlbmFtZSwge1xuICAgICAgICAgICAgdXBkYXRlZDogdGhpcy5vbkZpbGVVcGRhdGVkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVkOiB0aGlzLm9uRmlsZURlbGV0ZWQuYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBuZXdGaWxlbmFtZTtcbiAgICAgICAgdGhpcy5maWxlID0gdGhpcy5maWxlU3lzdGVtLmdldEZpbGUobmV3RmlsZW5hbWUpO1xuICAgICAgICB0aGlzLnRyYWNrQ3VycmVudEZpbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdGaWxlbmFtZSAtIHRoZSBmaWxlbmFtZSB0aGF0IHRoZSBvdGhlciBlZGl0b3Igd2lsbCBiZSBzd2l0Y2hpbmcgdG9cbiAgICAgKiBAcGFyYW0gb2xkRWRpdG9yXG4gICAgICogQHBhcmFtIG5ld0VkaXRvclxuICAgICAqL1xuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbS5zdG9wV2F0Y2hpbmdGaWxlKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdGhpcy5maWxlLmhhbmRsZShjb250ZW50cyk7XG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBFZGl0b3JzLnBhcnNlRmlsZW5hbWUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBmaWxlbmFtZS5uYW1lLFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBmaWxlbmFtZS50eXBlLFxuICAgICAgICAgICAgY29udGVudHM6IHRoaXMuZmlsZS5oYW5kbGUoKSxcbiAgICAgICAgICAgIG1pbWV0eXBlOiBcInRleHQvcGxhaW5cIlxuICAgICAgICB9O1xuICAgIH1cbn0iLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7RGlzcGxheU1vZGVzfSBmcm9tIFwiLi9weXRob25cIjtcblxuY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HUyA9IFtcbiAgICBbXCJ0b29sYm94XCIsIFwidG9vbGJveFwiLCBcIm5vcm1hbFwiLCBcInRvb2xib3hcIiwgXCJXaGljaCB2ZXJzaW9uIG9mIHRoZSB0b29sYm94IHRvIHByZXNlbnQgdG8gdGhlIHVzZXIuXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlXCIsIFwiYmxvY2tweVwiLCBcInR5cGVcIiwgXCJUaGUgdHlwZSBvZiBxdWVzdGlvbjsgQmxvY2tQeSBwcm9ncmFtbWluZyBwcm9ibGVtcyBhcmUgdGhlIGRlZmF1bHQsIGJ1dCB3ZSBhbHNvIHN1cHBvcnQgc3RhdGljIHJlYWRpbmdzLCBxdWl6IHF1ZXN0aW9ucywgYW5kIGEgTWF6ZSBnYW1lLlwiXSxcbiAgICBbXCJwYXNzY29kZVwiLCBcInBhc3Njb2RlXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiQSBzdHJpbmcgdGhhdCB0aGUgdXNlciBtdXN0IGVudGVyIHRvIGFjY2VzcyB0aGUgcHJvYmxlbS4gSWYgYmxhbmssIHRoZW4gbm8gcGFzc2NvZGUgaXMgcHJvbXB0ZWQuXCJdLFxuICAgIC8vW1widG9vbGJveExldmVsXCIsIFwidG9vbGJveF9sZXZlbFwiLCBcIm5vcm1hbFwiLCBcInRvb2xib3hcIiwgXCJJTkNPTVBMRVRFOiBXaGF0IGxldmVsIG9mIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlciAoaGlkaW5nIGFuZCBzaG93aW5nIGNhdGVnb3JpZXMpLlwiXSxcbiAgICBbXCJzdGFydFZpZXdcIiwgXCJzdGFydF92aWV3XCIsIERpc3BsYXlNb2Rlcy5URVhULCBEaXNwbGF5TW9kZXMsIFwiVGhlIFB5dGhvbiBlZGl0b3IgbW9kZSB0byBzdGFydCBpbiB3aGVuIHRoZSBzdHVkZW50IHN0YXJ0cyB0aGUgcHJvYmxlbS5cIl0sXG4gICAgW1wiZGF0YXNldHNcIiwgXCJkYXRhc2V0c1wiLCBcIlwiLCBcInN0cmluZ1wiLCBcIlRoZSBjdXJyZW50IGxpc3Qgb2YgZGF0YXNldHMgYXZhaWxhYmxlIG9uIGxvYWQgYXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nLlwiXSxcbiAgICBbXCJkaXNhYmxlVGltZW91dFwiLCBcImRpc2FibGVfdGltZW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyBjb2RlIGlzIGFsbG93ZWQgdG8gcnVuIHdpdGhvdXQgdGltZW91dHMgKHBvdGVudGlhbGx5IGFsbG93aW5nIGluZmluaXRlIGxvb3BzKS5cIl0sXG4gICAgW1wicGFydElkXCIsIFwicGFydF9pZFwiLCBcIlwiLCBcInN0cmluZ1wiLCBcIlRoZSBQYXJ0IElEIG9mIGFuIEFzc2lnbm1lbnQgdGhhdCB0aGlzIGVkaXRvciBpcyByZXNwb25zaWJsZSBmb3IuIEFzc2lnbm1lbnRzIGNhbiBoYXZlIHJlZ2lvbnMgKFxcXCJQYXJ0c1xcXCIpIHRoYXQgYmVoYXZlIGluZGVwZW5kZW50bHkgdG8gdGhlIHVzZXIgYnV0IGFsbCBjb3JyZXNwb25kIHRvIHRoZSBzYW1lIGFzc2lnbm1lbnQgb24gdGhlIGJhY2tlbmQuIEJsYW5rIGNvcnJlc3BvbmRzIHRvIHRoZSBmdWxsIGRvY3VtZW50LiBOb3RlIHRoYXQgbW9zdCBhc3NpZ25tZW50IHNldHRpbmdzIHdpbGwgYXBwbHkgVU5JVkVSU0FMTFkgYWNyb3NzIGFsbCBwYXJ0cywgaW5jbHVkaW5nIHRoZSBvbl9ydW4ucHkgYW5kIHRoZSBvdGhlciBzZXR0aW5ncyBvbiB0aGlzIHBhZ2UuXCJdLFxuICAgIFtcImlzUGFyc29uc1wiLCBcImlzX3BhcnNvbnNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhpcyBpcyBhIHBhcnNvbidzIHN0eWxlIHF1ZXN0aW9uIChqdW1ibGVkKS5cIl0sXG4gICAgW1wic2F2ZVR1cnRsZU91dHB1dFwiLCBcInNhdmVfdHVydGxlX291dHB1dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0dXJ0bGUgKGFuZCBweWdhbWUpIG91dHB1dCBpcyBzYXZlZCB3aGVuZXZlciB0aGUgcHJvZ3JhbSB1c2VzIGl0LlwiXSxcbiAgICBbXCJkaXNhYmxlRmVlZGJhY2tcIiwgXCJkaXNhYmxlX2ZlZWRiYWNrXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIG5vIGluc3RydWN0b3Igc2NyaXB0cyBhcmUgcnVuIChlLmcuLCBvbl9ydW4gYW5kIG9uX2V2YWwpLlwiXSxcbiAgICBbXCJkaXNhYmxlSW5zdHJ1Y3RvclJ1blwiLCBcImRpc2FibGVfaW5zdHJ1Y3Rvcl9ydW5cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGluc3RydWN0b3Igb25fcnVuIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcnVuIHRoZSBzdHVkZW50cycgY29kZS4gVGhpcyBzdGlsbCBydW5zIHRoZSBzdHVkZW50cycgY29kZSBvbmNlIGJlZm9yZWhhbmQsIGJ1dCB0aGUgb3V0cHV0L2RhdGEgd2lsbCBub3QgYmUgYXZhaWxhYmxlIHRvIHRoZSBpbnN0cnVjdG9yJ3Mgb25fcnVuLnB5IHNjcmlwdC5cIl0sXG4gICAgW1wiZGlzYWJsZVN0dWRlbnRSdW5cIiwgXCJkaXNhYmxlX3N0dWRlbnRfcnVuXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBydW4gYnV0dG9uIG5vIGxvbmdlciBydW4gdGhlIHN0dWRlbnRzJyBjb2RlLiBUaGlzIHN0aWxsIHJ1bnMgdGhlIGluc3RydWN0b3IncyBmZWVkYmFjayBvbl9ydW4gc2NyaXB0LlwiXSxcbiAgICBbXCJkaXNhYmxlVGlmYVwiLCBcImRpc2FibGVfdGlmYVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBkbyBub3QgYXV0b21hdGljYWxseSBydW4gVGlmYSAod2hpY2ggY2FuIGJlIHNsb3cpLlwiXSxcbiAgICBbXCJkaXNhYmxlVHJhY2VcIiwgXCJkaXNhYmxlX3RyYWNlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cyBjb2RlIHdpbGwgbm90IGhhdmUgaXRzIGV4ZWN1dGlvbiB0cmFjZWQgKG5vIHZhcmlhYmxlcyByZWNvcmRlZCwgbm8gY292ZXJhZ2UgdHJhY2tlZCkuXCJdLFxuICAgIFtcImRpc2FibGVFZGl0XCIsIFwiZGlzYWJsZV9lZGl0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cycgZmlsZSB3aWxsIG5vdCBiZSBlZGl0YWJsZS5cIl0sXG4gICAgW1wiZW5hYmxlSW1hZ2VzXCIsIFwiY2FuX2ltYWdlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHVzZXJzIGNhbiBjb3B5L3Bhc3RlIGltYWdlcyBkaXJlY3RseSBpbnRvIHRoZSB0ZXh0IGVkaXRvci5cIl0sXG4gICAgW1wiZW5hYmxlQmxvY2tzXCIsIFwiY2FuX2Jsb2Nrc1wiLCB0cnVlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IGNhbiBlZGl0IHRoZSBibG9jayBpbnRlcmZhY2UgKGlmIG5vdCwgdGhlbiBpdCBpcyB2aXNpYmxlIGJ1dCBub3QgZWRpdGFibGUpLlwiXSxcbiAgICBbXCJjYW5DbG9zZVwiLCBcImNhbl9jbG9zZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudCBzaG91bGQgbWFyayB0aGVpciBzdWJtaXNzaW9uIGNsb3NlZCB3aGVuIHRoZXkgYXJlIGRvbmUuIFRoZXJlIGlzIG5vIHdheSB0byBmb3JjZSBhIHN0dWRlbnQgdG8gZG8gc28uIFVubGlrZSBSZXZpZXdlZCwgdGhpcyBzdGlsbCBzdWJtaXRzIHRoZSBjb3JyZWN0bmVzcy5cIl0sXG4gICAgW1wib25seUludGVyYWN0aXZlXCIsIFwib25seV9pbnRlcmFjdGl2ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbiwgdGhlIHByb2dyYW0gaXMgYXV0b21hdGljYWxseSBydW4sIGFuZCB0aGVuIHRoZSBjb25zb2xlIGVudGVycyBFdmFsIG1vZGUgKGludGVyYWN0aXZlKS5cIl0sXG4gICAgW1wib25seVVwbG9hZHNcIiwgXCJvbmx5X3VwbG9hZHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzJyBmaWxlIHdpbGwgbm90IGJlIGRpcmVjdGx5IGVkaXRhYmxlICh0aGV5IHdpbGwgaGF2ZSB0byB1cGxvYWQgc3VibWlzc2lvbnMpLlwiXSxcbiAgICAvLyBXaGF0IG1lbnVzL2ZlZWRiYWNrIHRvIHNob3cgYW5kIGhpZGVcbiAgICBbXCJoaWRlU3VibWlzc2lvblwiLCBcImhpZGVfc3VibWlzc2lvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGVpciBzdWJtaXNzaW9uJ3MgY29kZSBvciBoaXN0b3J5IG9uIENhbnZhcy5cIl0sXG4gICAgW1wiaGlkZUZpbGVzXCIsIFwiaGlkZV9maWxlc1wiLCB0cnVlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IHNlZSB0aGUgVmlldyBGaWxlcyB0b29sYmFyLlwiXSxcbiAgICBbXCJoaWRlUXVldWVkSW5wdXRzXCIsIFwiaGlkZV9xdWV1ZWRfaW5wdXRzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cyBjYW5ub3QgYWNjZXNzIHRoZSBxdWV1ZWQgaW5wdXRzIGJveCAobWFrZXMgcmVwZWF0ZWQgZGVidWdnaW5nIGVhc2llciBmb3IgdGhlIGlucHV0IGZ1bmN0aW9uKS5cIl0sXG4gICAgW1wiaGlkZUVkaXRvcnNcIiwgXCJoaWRlX2VkaXRvcnNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gYWxsIG9mIHRoZSBlZGl0b3JzIGFyZSBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVNaWRkbGVQYW5lbFwiLCBcImhpZGVfbWlkZGxlX3BhbmVsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBjb25zb2xlIGFuZCBmZWVkYmFjayBhcmVhcyBpcyBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVBbGxcIiwgXCJoaWRlX2FsbFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlbiB0aGUgZW50aXJlIGludGVyZmFjZSBpcyBoaWRkZW4uXCJdLFxuICAgIFtcImhpZGVFdmFsdWF0ZVwiLCBcImhpZGVfZXZhbHVhdGVcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIEV2YWx1YXRlIGJ1dHRvbiBpcyBub3Qgc2hvd24gb24gdGhlIGNvbnNvbGUuXCJdLFxuICAgIFtcImhpZGVJbXBvcnREYXRhc2V0c0J1dHRvblwiLCBcImhpZGVfaW1wb3J0X2RhdGFzZXRzX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyBjYW5ub3Qgc2VlIHRoZSBpbXBvcnQgZGF0YXNldHMgYnV0dG9uLlwiXSxcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBvbmUgdG8gYmUgc2V0dGFibGVcbiAgICBbXCJoaWRlSW1wb3J0U3RhdGVtZW50c1wiLCBcImhpZGVfaW1wb3J0X3N0YXRlbWVudHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklOQ09NUExFVEU6IElmIGNoZWNrZWQsIGNlcnRhaW4ga2luZHMgb2YgaW1wb3J0IHN0YXRlbWVudHMgKG1hdHBsb3RsaWIsIHR1cnRsZSwgZGF0YXNldHMpIGFyZSBub3Qgc2hvd24gaW4gdGhlIGJsb2NrIGludGVyZmFjZS5cIl0sXG4gICAgW1wiaGlkZUNvdmVyYWdlQnV0dG9uXCIsIFwiaGlkZV9jb3ZlcmFnZV9idXR0b25cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklOQ09NUExFVEU6IElmIGNoZWNrZWQsIHRoZSBjb3ZlcmFnZSBidXR0b24gaXMgbm90IHNob3duLlwiXSxcbiAgICBbXCJoaWRlVHJhY2VCdXR0b25cIiwgXCJoaWRlX3RyYWNlX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgVHJhY2UgYnV0dG9uIGlzIG5vdCBzaG93bi5cIl0sXG4gICAgW1wic21hbGxMYXlvdXRcIiwgXCJzbWFsbF9sYXlvdXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGludGVyZmFjZSBmaXRzIGludG8gYSBzbWFsbGVyIHJlZ2lvbi5cIl0sXG4gICAgW1wiaGFzQ2xvY2tcIiwgXCJoYXNfY2xvY2tcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gYSBjbG9jayBpcyBzaG93biBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lci5cIl0sXG5dO1xuXG5leHBvcnQgbGV0IEFzc2lnbWVudFR5cGUgPSB7XG4gICAgQkxPQ0tQWTogXCJibG9ja3B5XCIsXG4gICAgTUFaRTogXCJtYXplXCIsXG4gICAgUVVJWjogXCJxdWl6XCIsXG4gICAgUkVBRElORzogXCJyZWFkaW5nXCJcbn07XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50YXRpb24obmFtZSkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IEFTU0lHTk1FTlRfU0VUVElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBU1NJR05NRU5UX1NFVFRJTkdTW2ldWzRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIkRvY3VtZW50YXRpb24gbm90IGZvdW5kIGZvciBmaWVsZFwiO1xufVxuXG5mdW5jdGlvbiBtYWtlU3RhcnRWaWV3VGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogYXNzaWdubWVudC5zZXR0aW5ncy5zdGFydFZpZXcoKSA9PT0gJyR7bW9kZX0nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0Vmlldy5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LXN0YXJ0LXZpZXctc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MID0gQVNTSUdOTUVOVF9TRVRUSU5HU1xuICAgIC8vIE9ubHkgaGFuZGxlIHRoZSBzaW1wbGUgYm9vbGVhbnMgdGhpcyB3YXlcbiAgICAuZmlsdGVyKChzZXR0aW5nKSA9PiBzZXR0aW5nWzNdID09PSBcImJvb2xcIilcbiAgICAubWFwKChzZXR0aW5nKSA9PiB7XG4gICAgICAgIGxldCBwcmV0dHlOYW1lID0gc2V0dGluZ1sxXS5zcGxpdChcIl9cIikubWFwKHdvcmQ9Pih3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3dvcmQuc2xpY2UoMSkpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIj4ke3ByZXR0eU5hbWV9PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy0ke3NldHRpbmdbMF19XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5zZXR0aW5ncy4ke3NldHRpbmdbMF19XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtzZXR0aW5nWzRdfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgfSkuam9pbihcIlxcblxcblwiKTtcblxuZXhwb3J0IGNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktdmlldy1zZXR0aW5nc1wiPlxuICAgIFxuICAgIDxmb3JtPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMiBteC1hdXRvXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3NcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5zZXR0aW5ncy5zYXZlXCI+U2F2ZSBjaGFuZ2VzPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtbmFtZVwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPk5hbWU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5uYW1lXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIHN0dWRlbnQtZmFjaW5nIG5hbWUgb2YgdGhlIGFzc2lnbm1lbnQuIEFzc2lnbm1lbnRzIHdpdGhpbiBhIGdyb3VwIGFyZSBvcmRlcmVkIGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGJ5IHRoZWlyIG5hbWUsIHNvIHlvdSBtYXkgd2FudCB0byB1c2UgYSBuYW1pbmcgc2NoZW1lIGxpa2UgXCIjNDMuNSkgV2hhdGV2ZXJcIi5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5VUkw6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy11cmxcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnVybFwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBjb3Vyc2UtdW5pcXVlIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbnNpc3RlbnRseSByZWZlciB0byB0aGlzIGFzc2lnbm1lbnQuIFxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCI+UHVibGljOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcHVibGljXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5wdWJsaWNcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHVibGljLCB1c2VycyBvdXRzaWRlIG9mIHRoZSBjb3Vyc2Ugd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlIGFzc2lnbm1lbnQgaW4gY291cnNlIGxpc3RpbmdzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCI+SGlkZGVuOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogYXNzaWdubWVudC5oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiBoaWRkZW4sIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIGdyYWRlIHdoaWxlIHdvcmtpbmcgb24gdGhlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlJldmlld2VkOjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnJldmlld2VkXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+ICBcbiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS05XCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgSWYgcmV2aWV3ZWQsIHRoZSBhc3NpZ25tZW50IG5lZWQgdG8gYmUgY29tbWVudGVkIHVwb24gYW5kIHJlZ3JhZGVkIGJ5IHRoZSBzdGFmZiBhZnRlciBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBvaW50c1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlBvaW50czo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5wb2ludHNcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGlzIGFzc2lnbm1lbnQgaXMgd29ydGg7IGRlZmF1bHRzIHRvIDEgcG9pbnQuIFxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcmV2aWV3ZWRcIj5TdGFydGluZyBWaWV3OjwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tM1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgYnRuLWdyb3VwLXRvZ2dsZSBtci0yXCIgZGF0YS10b2dnbGU9XCJidXR0b25zXCI+XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlNwbGl0XCIsIFwiY29sdW1uc1wiLCBEaXNwbGF5TW9kZXMuU1BMSVQpfVxuICAgICAgICAgICAgICAgICAgICAke21ha2VTdGFydFZpZXdUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTdcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJzdGFydFZpZXdcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+SVAgUmFuZ2VzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtaXAtcmFuZ2VzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5pcFJhbmdlc1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBJUCBBZGRyZXNzZXMgdGhhdCB3aWxsIGJlIGV4cGxpY2l0bHkgYWxsb3dlZC4gSWYgYmxhbmssXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGFkZHJlc3NlcyBhcmUgYWxsb3dlZC4gSWYgYW4gYWRkcmVzcyBzdGFydHMgd2l0aCA8Y29kZT5ePC9jb2RlPiB0aGVuIGl0IGl0IGlzIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tsaXN0ZWQsIGJ1dCB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIGluIHR1cm4gd2l0aCBhIDxjb2RlPiE8L2NvZGU+LiBBZGRyZXNzZXMgY2FuIGFsc29cbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBhIGJpdCBtYXNrIHRvIGFsbG93IGEgcmFuZ2Ugb2YgYWRkcmVzc2VzLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UGFzc2NvZGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wYXNzY29kZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MucGFzc2NvZGVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJwYXNzY29kZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1kYXRhc2V0c1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlByZWxvYWRlZCBEYXRhc2V0czo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcImRhdGFzZXRzXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5CbG9jayBUb29sYm94OjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy10b29sYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveFwiPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub3JtYWxcIj5Ob3JtYWwgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdFwiPkNUQFZUIFRvb2xib3g8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3QyXCI+Q1RAVlQgVG9vbGJveCBWMjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtaW5pbWFsXCI+TWluaW1hbCBTZXQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZnVsbFwiPkFsbCBCbG9ja3M8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3VzdG9tXCI+Q3VzdG9tPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidG9vbGJveFwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy10eXBlXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJvYmxlbSBUeXBlOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy10eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudHlwZVwiPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJibG9ja3B5XCI+QmxvY2tQeTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtYXplXCI+TWF6ZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJxdWl6XCI+UXVpeiBRdWVzdGlvbjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZWFkaW5nXCI+UmVhZGluZzwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInR5cGVcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcGFydC1pZFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlBhcnQgSUQ6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wYXJ0LWlkXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogY29uZmlndXJhdGlvbi5wYXJ0SWRcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJwYXJ0SWRcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgICR7QVNTSUdOTUVOVF9TRVRUSU5HU19CT09MRUFOX0NPTVBPTkVOVFNfSFRNTH1cbiAgICA8L2Zvcm0+XG4gICAgXG4gICAgPC9kaXY+XG5gO1xuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCkge1xuICAgIGxldCBzZXR0aW5ncyA9IHt9O1xuICAgIEFTU0lHTk1FTlRfU0VUVElOR1MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXSwgZGVmYXVsdFZhbHVlID0gc2V0dGluZ1syXTtcbiAgICAgICAgbGV0IHZhbHVlID0gbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXSgpO1xuICAgICAgICAvLyBPbmx5IHN0b3JlIHRoaXMgc2V0dGluZyBpZiBpdHMgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcbiAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW3NlcnZlck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCwgc2V0dGluZ3MpIHtcbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHNldHRpbmdzKTtcbiAgICAgICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJOYW1lIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nc1tzZXJ2ZXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3NbY2xpZW50TmFtZV0oc2V0dGluZ1syXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdGFydF92aWV3KSB7XG4gICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoc2V0dGluZ3Muc3RhcnRfdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXNzaWdubWVudFNldHRpbmdzTW9kZWwoY29uZmlndXJhdGlvbikge1xuICAgIGxldCBzZXR0aW5ncyA9IHt9O1xuICAgIEFTU0lHTk1FTlRfU0VUVElOR1MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSBzZXR0aW5nWzBdLCBzZXJ2ZXJOYW1lID0gc2V0dGluZ1sxXSwgZGVmYXVsdFZhbHVlID0gc2V0dGluZ1syXSxcbiAgICAgICAgICAgIGZpZWxkVHlwZSA9IHNldHRpbmdbM107XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zZXR0aW5ncy5cIitzZXJ2ZXJOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb25maWdWYWx1ZSA9IGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICBjb25maWdWYWx1ZSA9IGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dGluZ3NbY2xpZW50TmFtZV0gPSBrby5vYnNlcnZhYmxlKGNvbmZpZ1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xufVxuXG5jbGFzcyBBc3NpZ25tZW50U2V0dGluZ3NWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvL1RPRE86IHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICAvLyB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy9UT0RPOiB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IERvIHVwZGF0ZVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLnZhbHVlKCkpO1xuICAgICAgICAgICAgLy8gVE9ETzogVXBkYXRlXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICAvL3RoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZVxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFzc2lnbm1lbnRTZXR0aW5ncyA9IHtcbiAgICBuYW1lOiBcIkFzc2lnbm1lbnQgU2V0dGluZ3NcIixcbiAgICBleHRlbnNpb25zOiBbXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBBc3NpZ25tZW50U2V0dGluZ3NWaWV3LFxuICAgIHRlbXBsYXRlOiBBU1NJR05NRU5UX1NFVFRJTkdTX0VESVRPUl9IVE1MXG59OyIsIlxyXG5cclxuZXhwb3J0IGNvbnN0IGRlZmF1bHRfaGVhZGVyID0gYFxyXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tdG9vbGJhciBjb2wtbWQtMTIgYnRuLXRvb2xiYXJcIlxyXG4gICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlB5dGhvbiBUb29sYmFyXCI+XHJcbiAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCI+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1maWxlLXVwbG9hZFwiPjwvc3Bhbj4gVXBsb2FkXHJcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImJsb2NrcHktdG9vbGJhci11cGxvYWRcIiB0eXBlPVwiZmlsZVwiXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5cclxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImV2ZW50OiB7Y2hhbmdlOiB1aS5lZGl0b3JzLnVwbG9hZH1cIj5cclxuICAgICAgICAgPC9sYWJlbD5cclxuXHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGRyb3Bkb3duLXRvZ2dsZSBkcm9wZG93bi10b2dnbGUtc3BsaXRcIlxyXG4gICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+VG9nZ2xlIERyb3Bkb3duPC9zcGFuPlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cclxuICAgICAgICAgICAgPGEgY2xhc3M9J2Ryb3Bkb3duLWl0ZW0gYmxvY2tweS10b29sYmFyLWRvd25sb2FkJ1xyXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuZG93bmxvYWRcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1kb3dubG9hZCc+PC9zcGFuPiBEb3dubG9hZFxyXG4gICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIFxyXG4gICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkRlbGV0ZSBHcm91cFwiXHJcbiAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5EZWxldGVcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcclxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmRlbGV0ZVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvc3Bhbj4gRGVsZXRlXHJcbiAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgIDwvZGl2PlxyXG4gPC9kaXY+XHJcbmA7XHJcbiIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IElNQUdFX0VESVRPUl9IVE1MID0gYFxyXG4gICAgIDxkaXY+XHJcbiAgICAgICAgPGgzPkF2YWlsYWJsZSBJbWFnZXM8L2gzPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxidXR0b24gZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuaW1hZ2VzLnJlbG9hZEltYWdlc1wiPlJlbG9hZCBBdmFpbGFibGUgSW1hZ2VzPC9idXR0b24+XHJcbiAgICAgICAgPCEtLSBrbyBpZjogZGlzcGxheS51cGxvYWRlZEZpbGVzKCkgIT09IG51bGwgLS0+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDwhLS0ga28gZm9yZWFjaDogeyBkYXRhOiBPYmplY3Qua2V5cyhkaXNwbGF5LnVwbG9hZGVkRmlsZXMoKSksIGFzOiAncGxhY2VtZW50JyB9IC0tPlxyXG4gICAgICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmcgZGF0YS1iaW5kPVwidGV4dDogJGRhdGFcIj48L3N0cm9uZz46XHJcbiAgICAgICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0ga28gZm9yZWFjaDogeyBkYXRhOiAkcm9vdC5kaXNwbGF5LnVwbG9hZGVkRmlsZXMoKVtwbGFjZW1lbnRdLCBhczogJ2ZpbGVuYW1lJyB9IC0tPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBmaWxlbmFtZVswXVwiPjwvc3Bhbj46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGRhdGEtYmluZD1cImF0dHI6IHsgc3JjOiBmaWxlbmFtZVsxXSwgYWx0OiBmaWxlbmFtZVsxXSB9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjMwcHhcIiBoZWlnaHQ9XCIzMHB4XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEltYWdlRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG5cclxuICAgICAgICBsZXQgdXBsb2FkZWRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnVwbG9hZGVkRmlsZXMoKTtcclxuICAgICAgICBpZiAodXBsb2FkZWRGaWxlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbG9hZEltYWdlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG5cclxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7Ki9cclxuICAgIH1cclxuXHJcbiAgICByZWxvYWRJbWFnZXMoKSB7XHJcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxpc3RVcGxvYWRlZEZpbGVzKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudXBsb2FkZWRGaWxlcyhyZXNwb25zZS5maWxlcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2dzLkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMocmVzcG9uc2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgLyp0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfSovXHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEltYWdlRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJJbWFnZVwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiP2ltYWdlcy5ibG9ja3B5XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IEltYWdlRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBJTUFHRV9FRElUT1JfSFRNTFxyXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEpTT05fRURJVE9SX0hUTUwgPSBgXHJcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxyXG4gICAgIDxkaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItanNvblwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEpzb25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1qc29uXCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBKc29uRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJKU09OXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCIuanNvblwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBKc29uRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBKU09OX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgTUFSS0RPV05fRURJVE9SX0hUTUwgPSBgXG4gICAgJHtkZWZhdWx0X2hlYWRlcn1cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1tYXJrZG93blwiPjwvdGV4dGFyZWE+ICAgIFxuYDtcblxuXG5jbGFzcyBNYXJrZG93bkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMubWRlID0gbmV3IEVhc3lNREUoe1xuICAgICAgICAgICAgZWxlbWVudDogdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItbWFya2Rvd25cIilbMF0sXG4gICAgICAgICAgICBhdXRvRG93bmxvYWRGb250QXdlc29tZTogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZVN5bmM6IHRydWUsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IFwiMzAwcHhcIixcbiAgICAgICAgICAgIC8vc2Nyb2xsYmFyU3R5bGU6IFwibmF0aXZlXCIsXG4gICAgICAgICAgICAvLyBUT0RPOiBpbWFnZVVwbG9hZEZ1bmN0aW9uXG4gICAgICAgICAgICByZW5kZXJpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICBjb2RlU3ludGF4SGlnaGxpZ2h0aW5nOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1kZS5jb2RlbWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMubWRlLmNvZGVtaXJyb3IpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWRlLnZhbHVlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLm1kZS52YWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bkVkaXRvciA9IHtcbiAgICBuYW1lOiBcIk1hcmtkb3duXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLm1kXCJdLFxuICAgIGNvbnN0cnVjdG9yOiBNYXJrZG93bkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IE1BUktET1dOX0VESVRPUl9IVE1MXG59OyIsIi8qKlxuICogVE9ETzogcmVuYW1lIGZpbGVzLCBtYW51YWwgc2F2ZSwgdGFncywgc2FtcGxlX3N1Ym1pc3Npb25zLCBvbl9ldmFsLCBub24tYnVpbHRpbiBmaWxlc1xuICogVE9ETzogaW1wb3J0IGRhdGEsIGhpc3RvcnksIHJ1biwgdXJsX2RhdGEsIGFzc2lnbm1lbnRfc2V0dGluZ3MsIHBhcnNvbnNfbW9kZVxuICogVE9ETzogZGVsZXRlIGJlY29tZXMgXCJjbGVhclwiIGZvciBpbnN0cnVjdG9yIGZpbGVzXG4gKi9cblxuLyoqXG4gKlxuICogQGVudW0ge3N0cn1cbiAqL1xuaW1wb3J0IHtBYnN0cmFjdEVkaXRvciwgc2x1Z2dpZnl9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtISVNUT1JZX1RPT0xCQVJfSFRNTH0gZnJvbSBcIi4uL2hpc3RvcnlcIjtcbmltcG9ydCB7U2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfSBmcm9tIFwiLi4vaW50ZXJmYWNlXCI7XG5cbmV4cG9ydCBsZXQgRGlzcGxheU1vZGVzID0ge1xuICAgIEJMT0NLOiBcImJsb2NrXCIsXG4gICAgU1BMSVQ6IFwic3BsaXRcIixcbiAgICBURVhUOiBcInRleHRcIlxufTtcblxuZnVuY3Rpb24gbWFrZVRhYihuYW1lLCBpY29uLCBtb2RlKSB7XG4gICAgcmV0dXJuIGA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJsb2NrcHktbW9kZS1zZXQtYmxvY2tzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGRpc3BsYXkucHl0aG9uTW9kZSgpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLnVwZGF0ZU1vZGUuYmluZCgkZGF0YSwgJyR7bW9kZX0nKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtJHtpY29ufSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiYmxvY2tweS1tb2RlLXNldFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIGNoZWNrZWQ+ICR7bmFtZX1cbiAgICAgICAgICAgIDwvbGFiZWw+YDtcbn1cblxuZXhwb3J0IGNvbnN0IFBZVEhPTl9FRElUT1JfSFRNTCA9IGBcblxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi10b29sYmFyIGNvbC1tZC0xMiBidG4tdG9vbGJhclwiXG4gICAgICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJQeXRob24gVG9vbGJhclwiPlxuXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUnVuIEdyb3VwXCI+ICAgICAgICAgXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBibG9ja3B5LXJ1biBub3RyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5leGVjdXRlLnJ1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3M6IHsnYmxvY2tweS1ydW4tcnVubmluZyc6IHVpLmV4ZWN1dGUuaXNSdW5uaW5nfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXBsYXlcIj48L3NwYW4+IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLmV4ZWN1dGUucnVuTGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgIDwhLS0ga28gaWY6ICRyb290LmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlQmxvY2tzKCkgLS0+XG4gICAgICAgICAgICAke21ha2VUYWIoXCJCbG9ja3NcIiwgXCJ0aC1sYXJnZVwiLCBEaXNwbGF5TW9kZXMuQkxPQ0spfVxuICAgICAgICAgICAgJHttYWtlVGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVzZXQgR3JvdXBcIj5cbiAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5yZXNldFwiPlxuICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zeW5jXCI+PC9zcGFuPiBSZXNldFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIGtvIGlmOiAhYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlSW1wb3J0RGF0YXNldHNCdXR0b24oKSAmJiAhdWkuc21hbGxMYXlvdXQoKS0tPlxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkltcG9ydCBHcm91cFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbXBvcnREYXRhc2V0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtY2xvdWQtZG93bmxvYWQtYWx0XCI+PC9zcGFuPiBJbXBvcnQgZGF0YXNldHNcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxuICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGRyb3Bkb3duLXRvZ2dsZSBkcm9wZG93bi10b2dnbGUtc3BsaXRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+VG9nZ2xlIERyb3Bkb3duPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9J2Ryb3Bkb3duLWl0ZW0gYmxvY2tweS10b29sYmFyLWRvd25sb2FkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuZG93bmxvYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1kb3dubG9hZCc+PC9zcGFuPiBEb3dubG9hZFxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkhpc3RvcnkgR3JvdXBcIiBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNtYWxsTGF5b3V0XCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24udG9nZ2xlSGlzdG9yeU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHVpLmVkaXRvcnMucHl0aG9uLmlzSGlzdG9yeUF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeyBhY3RpdmU6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHsgJ2FyaWEtcHJlc3NlZCc6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWhpc3RvcnlcIj48L3NwYW4+IEhpc3RvcnlcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIEZ1bGx5IGZ1bmN0aW9uYWwsIGJ1dCBhIGxpdHRsZSB0b28uLiBJbnZhc2l2ZSBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJGdWxsc2NyZWVuIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IGRpc3BsYXkucHl0aG9uTW9kZSgpID09PSAndGV4dCdcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmZ1bGxzY3JlZW5cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1leHBhbmQtYXJyb3dzLWFsdFwiPjwvc3Bhbj4gRnVsbHNjcmVlblxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlNhdmUgR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5TYXZlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkRlbGV0ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmRlbGV0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlJlbmFtZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblJlbmFtZVwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtc2lnbmF0dXJlXCI+PC9zcGFuPiBSZW5hbWVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2Pi0tPlxuICAgICAgICAgXG4gICAgPC9kaXY+XG4gICAgXG4gICAgJHtISVNUT1JZX1RPT0xCQVJfSFRNTH1cblxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLWJsb2NrbWlycm9yXCJcbiAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5tZW51LmlzU3VibWl0dGVkXCI+XG4gICAgPC9kaXY+XG5gO1xuXG5cblxuZnVuY3Rpb24gY29udmVydElweW5iVG9QeXRob24oY29kZSkge1xuICAgIGxldCBpcHluYiA9IEpTT04ucGFyc2UoY29kZSk7XG4gICAgbGV0IGlzVXNhYmxlID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2UubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICFjZWxsLnNvdXJjZVswXS5zdGFydHNXaXRoKFwiJVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICAgICAgY2VsbC5jZWxsX3R5cGUgPT09IFwicmF3XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBtYWtlUHl0aG9uID0gZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwiY29kZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJtYXJrZG93blwiIHx8XG4gICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiJycnXCIrY2VsbC5zb3VyY2Uuam9pbihcIlxcblwiKStcIicnJ1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaXB5bmIuY2VsbHMuZmlsdGVyKGlzVXNhYmxlKS5tYXAobWFrZVB5dGhvbikuam9pbihcIlxcblwiKTtcbn1cblxuY2xhc3MgUHl0aG9uRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnLmZpbmQoXCIuYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIikpO1xuICAgICAgICBCbG9ja2x5LnNldFBhcmVudENvbnRhaW5lcihtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyWzBdKTtcbiAgICAgICAgdGhpcy5ibSA9IG5ldyBCbG9ja01pcnJvcih7XG4gICAgICAgICAgICBcImNvbnRhaW5lclwiOiB0aGlzLnRhZ1swXSxcbiAgICAgICAgICAgIFwicnVuXCI6IG1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuLmJpbmQobWFpbi5jb21wb25lbnRzLmVuZ2luZSksXG4gICAgICAgICAgICBcInNraXBTa3VscHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiYmxvY2tseU1lZGlhUGF0aFwiOiBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYmxvY2tseVBhdGgsXG4gICAgICAgICAgICBcInRvb2xib3hcIjogbWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3goKSxcbiAgICAgICAgICAgIFwiaW1hZ2VNb2RlXCI6IHRydWUsXG4gICAgICAgICAgICBpbWFnZURvd25sb2FkSG9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRVcmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VVcGxvYWRIb29rOiAoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc3QgdXVpZCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtdKSkuc3Vic3RyaW5nKDMxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJtaXNzaW9uSWQgPSBtYWluLm1vZGVsLnN1Ym1pc3Npb24uaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbi5jb21wb25lbnRzLnNlcnZlci51cGxvYWRGaWxlKFwic3VibWlzc2lvblwiLCBzdWJtaXNzaW9uSWQsIGJsb2IubmFtZSwgYmxvYiwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmVuZHBvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc29sdmUoSlNPTi5zdHJpbmdpZnkobWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHNbXCJkb3dubG9hZEZpbGVcIl0gKyBgP3BsYWNlbWVudD1zdWJtaXNzaW9uJmRpcmVjdG9yeT0ke3N1Ym1pc3Npb25JZH0mZmlsZW5hbWU9JHtibG9iLm5hbWV9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwiSW1hZ2UoXCIrSlNPTi5zdHJpbmdpZnkoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSkrXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5zdHJpbmdpZnkoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltYWdlTGl0ZXJhbEhvb2s6IChvbGRVcmwpID0+IHtcbiAgICAgICAgICAgICAgICAvL3JldHVybiBgSW1hZ2UoXCIke29sZFVybH1cIilgO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXCIke29sZFVybH1cImA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8naGVpZ2h0JzogJzIwMDBweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkUHl0aG9uTW9kZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKTtcblxuICAgICAgICB0aGlzLm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucygpO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZUV4dHJhQmxvY2tseSgpIHtcbiAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci53b3Jrc3BhY2UuY29uZmlndXJlQ29udGV4dE1lbnUgPSAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiU2NyZWVuc2hvdFwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuU0NSRUVOU0hPVF9CTE9DS1NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgbGV0IG9sZEZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAobmV3RmlsZW5hbWUgIT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGlmIChvbGRGaWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkUHl0aG9uTW9kZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSh0aGlzLm9sZFB5dGhvbk1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRCTUxpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ibS5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRCTUxpc3RlbmVyKTtcblxuICAgICAgICBpZiAobmV3RmlsZW5hbWUgIT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMuYm0uaXNQYXJzb25zID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJtLmlzUGFyc29ucyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmlzUGFyc29ucztcblxuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxpbmVzRXJyb3Iuc3Vic2NyaWJlKChsaW5lcykgPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm0uc2V0SGlnaGxpZ2h0ZWRMaW5lcyhsaW5lcywgXCJlZGl0b3ItZXJyb3ItbGluZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5saW5lc1VuY292ZXJlZC5zdWJzY3JpYmUoKGxpbmVzKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuYm0uc2V0SGlnaGxpZ2h0ZWRMaW5lcyhsaW5lcywgXCJlZGl0b3ItdW5jb3ZlcmVkLWxpbmVcIilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLnVpLnRyYWNlLmhpZ2hsaWdodGVkTGluZS5zdWJzY3JpYmUoKGxpbmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoXCJlZGl0b3ItdHJhY2VkLWxpbmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci10cmFjZWQtbGluZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL3RoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLnJlbmRlcigpO1xuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGlzIGRvZXNuJ3QgZW5kIHVwIGxvb2tpbmcgcmlnaHQgKGdvIHRvIGEgZGlmZmVyZW50IGVkaXRvciwgY29tZSBiYWNrLCBhbmQgaXQnbGwgYmUgc3F1aXNoZWQpXG4gICAgICAgIC8vdGhpcy5ibS5yZWZyZXNoKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ibS5yZWZyZXNoKCksIDApO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICBpZiAobmV3Q29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gdGhpcy5maWxlLmhhbmRsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciwgZmlsZSB3YXMgYWxyZWFkeSBzaHV0IGRvd24uXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudHMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBjbG9zaW5nIHRoaXMgZmlsZVxuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8odGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJtLnNldENvZGUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5ibS5nZXRDb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJtLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJMaW5lU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIGNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uc2V0TW9kZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlLnN1YnNjcmliZShtb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZShtb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUJsb2Nrcy5zdWJzY3JpYmUoZW5hYmxlZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3guc3Vic2NyaWJlKHRoaXMucmVsb2FkVG9vbGJveC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlSW1hZ2VzLnN1YnNjcmliZShpbWFnZU1vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRJbWFnZU1vZGUoaW1hZ2VNb2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU21hbGwgTGF5b3V0IFN0dWZmXG4gICAgICAgIHRoaXMub2xkSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zbWFsbExheW91dCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVzZVNtYWxsTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNtYWxsTGF5b3V0LnN1YnNjcmliZSh1c2VTbWFsbExheW91dCA9PiB7XG4gICAgICAgICAgICBpZiAodXNlU21hbGxMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVNtYWxsTGF5b3V0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub2xkSGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLmhlaWdodCA9IHRoaXMub2xkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuYm0udGV4dEVkaXRvci5yZXNpemVSZXNwb25zaXZlbHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZEhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVzZVNtYWxsTGF5b3V0KCkge1xuICAgICAgICB0aGlzLmJtLnRleHRFZGl0b3IudXBkYXRlR3V0dGVyKHtpbmRlbnRTaWRlYmFyOiBmYWxzZX0pO1xuICAgICAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuYm0uY29uZmlndXJhdGlvbi5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi5oZWlnaHQgPSAzMDA7IC8vIFRPRE86IFBhcmFtZXRlcml6ZSB0aGlzXG4gICAgICAgIHRoaXMuYm0udGV4dEVkaXRvci5yZXNpemVSZXNwb25zaXZlbHkoKTtcbiAgICB9XG5cbiAgICByZWxvYWRUb29sYm94KHRvb2xib3gpIHtcbiAgICAgICAgaWYgKHRvb2xib3ggPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXN0b21Ub29sYm94ID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiP3Rvb2xib3guYmxvY2tweVwiKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21Ub29sYm94ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b29sYm94ID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0b29sYm94ID0gSlNPTi5wYXJzZShjdXN0b21Ub29sYm94LmhhbmRsZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIFRPRE86IEltcHJvdmUgZXJyb3IgbWVzc2FnZSBmb3IgaW5zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICB0b29sYm94ID0gXCJtaW5pbWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi50b29sYm94ID0gdG9vbGJveDtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGludmFsaWQgdG9vbGJveCBiZXR0ZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLnRvb2xib3ggPSBcImVtcHR5XCI7XG4gICAgICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3Rvci5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhZE9ubHkodGhpcy5kZWNpZGVJZk5vdEVkaXRhYmxlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Mub25seVVwbG9hZHMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWRPbmx5KHRoaXMuZGVjaWRlSWZOb3RFZGl0YWJsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnBhcnRJZC5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBwYXJ0IGlkIGNoYW5naW5nIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgbG9hZGVkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlY2lkZUlmTm90RWRpdGFibGUoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSB8fCAoXG4gICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzKCkgJiYgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0UmVhZE9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5ibS5zZXRSZWFkT25seShpc1JlYWRPbmx5KTtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvZGUgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIuaXB5bmJcIikpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuVXBsb2FkXCIsIFwiXCIsIFwiXCIsIGNvZGUsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvZGUpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuKCk7XG4gICAgICAgIC8vIFRPRE86IFJ1biBjb2RlXG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZG93bmxvYWRGaWxlKCk7XG4gICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiByZXN1bHQuZXh0ZW5zaW9uID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IHNsdWdnaWZ5KHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1pbWV0eXBlID0gXCJ0ZXh0L3gtcHl0aG9uXCI7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5Eb3dubG9hZFwiLCBcIlwiLCBcIlwiLCBcIlwiLCByZXN1bHQubmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQeXRob25FZGl0b3IgPSB7XG4gICAgbmFtZTogXCJQeXRob25cIixcbiAgICBleHRlbnNpb25zOiBbXCIucHlcIiwgXCIucmVhZGluZ1wiXSxcbiAgICBjb25zdHJ1Y3RvcjogUHl0aG9uRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogUFlUSE9OX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFFVSVpfRURJVE9SX0hUTUwgPSBgXHJcbiAgICA8ZGl2PlxyXG4gICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItcXVpelwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIFF1aXpFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10ZXh0XCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgUXVpekVkaXRvciA9IHtcclxuICAgIG5hbWU6IFwiUXVpelwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiLnF1aXpcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogUXVpekVkaXRvclZpZXcsXHJcbiAgICB0ZW1wbGF0ZTogUVVJWl9FRElUT1JfSFRNTFxyXG59OyIsIi8qKlxuICogUGFuZWwgZm9yIGVkaXRpbmcgdGhlIHNldCBvZiBTYW1wbGUgU3VibWlzc2lvbnMuXG4gKiBUaGVzZSBhcmUgbm90IHByb3ZpZGVkIGF0IGFsbCB0byBzdHVkZW50cyB3aXRob3V0IHRoZSBHcmFkZXIgcm9sZS5cbiAqL1xuXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcblxuZXhwb3J0IGNvbnN0IFN1Ym1pc3Npb25TdGF0dXNlcyA9IHtcbiAgICBVTktOT1dOOiBcInVua25vd25cIixcbiAgICBQQVNTRUQ6IFwicGFzc2VkXCIsXG4gICAgRkFJTEVEOiBcImZhaWxlZFwiLFxuICAgIEVSUk9SOiBcImVycm9yXCIsXG4gICAgU0tJUFBFRDogXCJza2lwcGVkXCJcbn07XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVTdWJtaXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgc3RhdGljIEJsYW5rKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FtcGxlU3VibWlzc2lvbihcIlVudGl0bGVkXCIrKGNvdW50IHx8IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VibWlzc2lvblN0YXR1c2VzLlVOS05PV04sIFwiYT0wXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FtcGxlU3VibWlzc2lvbihkYXRhLm5hbWUsIGRhdGEuc3RhdHVzLCBkYXRhLmNvZGUpO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTCA9IGBcbjxkaXY+XG4gICAgPGRpdiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiB7ZGF0YTogYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9uc31cIlxuICAgICAgICBjbGFzcz1cInJvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIj48L3NwYW4+XG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1zYW1wbGUtc3VibWlzc2lvbnMtY29kZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY29kZU1pcnJvckluc3RhbmNlOiBjb2RlXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3RhdHVzXCI+PC9zcGFuPiAgICAgICAgXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5rby5iaW5kaW5nSGFuZGxlcnMuY29kZU1pcnJvckluc3RhbmNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYmluZGluZyBpcyBmaXJzdCBhcHBsaWVkIHRvIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gU2V0IHVwIGFueSBpbml0aWFsIHN0YXRlLCBldmVudCBoYW5kbGVycywgZXRjLiBoZXJlXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5JVFwiKTtcbiAgICAgICAgbGV0IGNtID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEoZWxlbWVudCwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY20uc2V0U2l6ZShcIjEwMCVcIiwgXCIxMDBweFwiKTtcbiAgICAgICAgcmV0dXJuIGNtO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgYmluZGluZyBpcyBmaXJzdCBhcHBsaWVkIHRvIGFuIGVsZW1lbnQsXG4gICAgICAgIC8vIGFuZCBhZ2FpbiB3aGVuZXZlciBhbnkgb2JzZXJ2YWJsZXMvY29tcHV0ZWRzIHRoYXQgYXJlIGFjY2Vzc2VkIGNoYW5nZVxuICAgICAgICAvLyBVcGRhdGUgdGhlIERPTSBlbGVtZW50IGJhc2VkIG9uIHRoZSBzdXBwbGllZCB2YWx1ZXMgaGVyZS5cbiAgICAgICAgY29uc29sZS5sb2coXCJVUERBVEVcIik7XG4gICAgfVxufTtcblxuY2xhc3MgU2FtcGxlU3VibWlzc2lvbnNWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jb2RlTWlycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYnVpbGRFZGl0b3IobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCkge1xuXG4gICAgfVxuXG4gICAgcmVidWlsZEVkaXRvcnMoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVidWlsZGluZyBlZGl0b3JzXCIpO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgLy90aGlzLnJlYnVpbGRFZGl0b3JzKCk7XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksY20pID0+IGNvbnNvbGUubG9nKFwiKysrXCIsIGNtLkNvZGVNaXJyb3IpKSk7XG4gICAgICAgICAgICB0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLCBjbSkgPT4gY20uQ29kZU1pcnJvci5yZWZyZXNoKCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSRUZSRVNIXCIpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksIGNtKSA9PiBjbS5Db2RlTWlycm9yLnJlZnJlc2goKSksIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29kZU1pcnJvcnMpO1xuICAgICAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLmVhY2goIChpLCBjbSkgPT4gY20uc2V0VmFsdWUobmV3Q29udGVudHMuam9pbihcIlxcblwiKSkpO1xuICAgICAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLmVhY2goIChpLCBjbSkgPT4gY20ucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9ycy5tYXAoY20gPT4gY20uZ2V0VmFsdWUoKSkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9ycyA9IFtdO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNhbXBsZVN1Ym1pc3Npb25zID0ge1xuICAgIG5hbWU6IFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBTYW1wbGVTdWJtaXNzaW9uc1ZpZXcsXG4gICAgdGVtcGxhdGU6IFNBTVBMRV9TVUJNSVNTSU9OU19IVE1MXG59O1xuIiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBUQUdTX0VESVRPUl9IVE1MID0gYFxuQ3JlYXRlIG5ld1xuSW1wb3J0IGJ5IG5hbWVcbkZpbmQgYnkgb3duZXIvY291cnNlL2tpbmRcblxuVGFnczpcbiAgICBEYXRhOlxuICAgICAgICBOYW1lXG4gICAgICAgIEtpbmRcbiAgICAgICAgTGV2ZWxcbiAgICAgICAgVmVyc2lvblxuICAgICAgICBEZXNjcmlwdGlvblxuICAgIENvbnRyb2xzOlxuICAgICAgICBFZGl0XG4gICAgICAgIFJlbW92ZVxuICAgICAgICBEZWxldGUgXG5gO1xuXG5jbGFzcyBUYWdzRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGFnc1wiKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVGFnc0VkaXRvciA9IHtcbiAgICBuYW1lOiBcIlRhZ3NcIixcbiAgICBleHRlbnNpb25zOiBbXCIhdGFncy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBUYWdzRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogVEFHU19FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0VESVRPUl9IVE1MID0gYFxuICAgICR7ZGVmYXVsdF9oZWFkZXJ9XG4gICAgPGRpdj5cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci10ZXh0XCI+PC90ZXh0YXJlYT5cbiAgICA8L2Rpdj5cbmA7XG5cbmNsYXNzIFRleHRFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10ZXh0XCIpWzBdLCB7XG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRleHRFZGl0b3IgPSB7XG4gICAgbmFtZTogXCJUZXh0XCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnR4dFwiXSxcbiAgICBjb25zdHJ1Y3RvcjogVGV4dEVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFRFWFRfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgVE9PTEJPWF9FRElUT1JfSFRNTCA9IGBcclxuICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiXHJcbiAgICAgICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlRvb2xib3ggVG9vbGJhclwiPlxyXG4gICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlNhdmUgR3JvdXBcIj4gICAgICAgICBcclxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tZWRpdG9yLWpzb24tc2F2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXNhdmVcIj48L3NwYW4+IFNhdmVcclxuICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci10b29sYm94XCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgVG9vbGJveEVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRvb2xib3hcIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJ0bi1lZGl0b3ItanNvbi1zYXZlXCIpLm9uKFwiY2xpY2tcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3goKSA9PT0gXCJjdXN0b21cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnJlbG9hZFRvb2xib3goXCJjdXN0b21cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJ0bi1lZGl0b3ItdG9vbGJveC1zYXZlXCIpLm9mZihcImNsaWNrXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFRvb2xib3hFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIlRvb2xib3hcIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIj90b29sYm94LmJsb2NrcHlcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogVG9vbGJveEVkaXRvclZpZXcsXHJcbiAgICB0ZW1wbGF0ZTogVE9PTEJPWF9FRElUT1JfSFRNTFxyXG59OyIsIi8qKlxuICogRWRpdG9ycyBhcmUgaW5mZXJyZWQgZnJvbSBGaWxlbmFtZXMuXG4gKlxuICogVGhlIGVkaXRvciBpcyBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uOlxuICogIC5ibG9ja3B5OiBTcGVjaWFsIGVkaXRvciAod2lsbCBiZSBjaG9zZW4gYnkgZmlsZW5hbWUpXG4gKiAgLnB5OiBQeXRob24gRWRpdG9yXG4gKiAgLm1kOiBNYXJrZG93biBFZGl0b3JcbiAqICAudHh0OiBUZXh0IEVkaXRvciAoYWxzbyB1c2VkIGZvciBvdGhlciB0eXBlcylcbiAqICAucGVtbDogUEVNTCBFZGl0b3JcbiAqICAucG5nLCAuZ2lmLCAuanBlZywgLmpwZywgLmJtcDogSW1hZ2UgRWRpdG9yXG4gKiAgLmpzb246IEpTT04gRWRpdG9yXG4gKiAgLnlhbWw6IFlBTUwgRWRpdG9yXG4gKi9cblxuaW1wb3J0IHtQeXRob25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9weXRob25cIjtcbmltcG9ydCB7VGV4dEVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3RleHRcIjtcbmltcG9ydCB7QXNzaWdtZW50VHlwZSBhcyBBc3NpZ25tZW50VHlwZSwgQXNzaWdubWVudFNldHRpbmdzfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuaW1wb3J0IHtUYWdzRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdGFnc1wiO1xuaW1wb3J0IHtNYXJrZG93bkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL21hcmtkb3duXCI7XG5pbXBvcnQge1NhbXBsZVN1Ym1pc3Npb25zfSBmcm9tIFwiLi9lZGl0b3Ivc2FtcGxlX3N1Ym1pc3Npb25zXCI7XG5pbXBvcnQge0pzb25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9qc29uXCI7XG5pbXBvcnQge1Rvb2xib3hFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90b29sYm94XCI7XG5pbXBvcnQge1F1aXpFZGl0b3J9IGZyb20gXCIuL2VkaXRvci9xdWl6XCI7XG5pbXBvcnQge0ltYWdlRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvaW1hZ2VzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBwb3NzaWJsZSBlZGl0b3JzIGF2YWlsYWJsZVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBFZGl0b3JzRW51bSA9IHtcbiAgICBTVUJNSVNTSU9OOiBcInN1Ym1pc3Npb25cIixcbiAgICBBU1NJR05NRU5UOiBcImFzc2lnbm1lbnRcIixcbiAgICBJTlNUUlVDVElPTlM6IFwiaW5zdHJ1Y3Rpb25zXCIsXG4gICAgT05fUlVOOiBcIm9uX3J1blwiLFxuICAgIE9OX0NIQU5HRTogXCJvbl9jaGFuZ2VcIixcbiAgICBPTl9FVkFMOiBcIm9uX2V2YWxcIixcbiAgICBTVEFSVElOR19DT0RFOiBcInN0YXJ0aW5nX2NvZGVcIixcbiAgICBTQU1QTEVfU1VCTUlTU0lPTlM6IFwic2FtcGxlX3N1Ym1pc3Npb25zXCIsXG4gICAgSU5TVFJVQ1RPUl9GSUxFOiBcImluc3RydWN0b3JfZmlsZVwiXG59O1xuXG5jb25zdCBTUEVDSUFMX05BTUVTUEFDRVMgPSBbXCIhXCIsIFwiXlwiLCBcIj9cIiwgXCIkXCJdO1xuXG5jb25zdCBBVkFJTEFCTEVfRURJVE9SUyA9IFtcbiAgICBUZXh0RWRpdG9yLCBQeXRob25FZGl0b3IsIEFzc2lnbm1lbnRTZXR0aW5ncywgVGFnc0VkaXRvciwgTWFya2Rvd25FZGl0b3IsXG4gICAgU2FtcGxlU3VibWlzc2lvbnMsIEpzb25FZGl0b3IsIFRvb2xib3hFZGl0b3IsIFF1aXpFZGl0b3IsIEltYWdlRWRpdG9yXG5dO1xuXG5leHBvcnQgY29uc3QgRURJVE9SU19IVE1MID0gQVZBSUxBQkxFX0VESVRPUlMubWFwKGVkaXRvciA9PiBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1wYW5lbCBibG9ja3B5LWVkaXRvclwiIFxuICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLnZpZXcoKS5uYW1lID09PSAnJHtlZGl0b3IubmFtZX0nLCBjbGFzczogdWkuZWRpdG9ycy53aWR0aFwiPlxuICAgIDxkaXY+XG4gICAgJHtlZGl0b3IudGVtcGxhdGV9XG4gICAgPC9kaXY+XG48L2Rpdj5cbmBcbiAgICAvKlxuICAgIGBcbjwhLS0ga28gaWY6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfScgLS0+XG4ke2VkaXRvci50ZW1wbGF0ZX1cbjwhLS0gL2tvIC0tPmAqL1xuKS5qb2luKFwiXFxuXCIpO1xuXG5leHBvcnQgY2xhc3MgRWRpdG9ycyB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfID0gW107XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc18gPSB7fTtcbiAgICAgICAgdGhpcy5ieU5hbWVfID0ge307XG4gICAgICAgIEFWQUlMQUJMRV9FRElUT1JTLmZvckVhY2goZWRpdG9yID0+IHRoaXMucmVnaXN0ZXJFZGl0b3IoZWRpdG9yKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lLnN1YnNjcmliZSh0aGlzLmNoYW5nZUVkaXRvciwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJFZGl0b3IoZGF0YSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9IGRhdGEuZXh0ZW5zaW9ucztcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IGRhdGEuY29uc3RydWN0b3IodGhpcy5tYWluLCB0aGlzLnRhZyk7XG4gICAgICAgIGluc3RhbmNlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZF8ucHVzaChpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYnlOYW1lX1tkYXRhLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBpbnN0YW5jZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zX1tleHRlbnNpb25zW2ldXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnlOYW1lX1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cblxuICAgIGNoYW5nZUVkaXRvcihuZXdGaWxlbmFtZSkge1xuICAgICAgICBsZXQgb2xkRWRpdG9yID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBsZXQgbmV3RWRpdG9yID0gdGhpcy5nZXRFZGl0b3IobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVkaXRvci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3RWRpdG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnQuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlRmlsZW5hbWUocGF0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSBwYXRoLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKFNQRUNJQUxfTkFNRVNQQUNFUy5pbmRleE9mKHNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwYWNlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB7XCJzcGFjZVwiOiBzcGFjZSwgXCJuYW1lXCI6IG5hbWUsIFwidHlwZVwiOiB0eXBlfTtcbiAgICB9XG5cbiAgICBnZXRFZGl0b3IocGF0aCkge1xuICAgICAgICBsZXQge3NwYWNlLCBuYW1lLCB0eXBlfSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiLmJsb2NrcHlcIiAmJiBwYXRoIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW3BhdGhdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc3NpZ25tZW50VHlwZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnR5cGUoKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRUeXBlICE9PSBBc3NpZ25tZW50VHlwZS5CTE9DS1BZKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiB0eXBlID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiLlwiK2Fzc2lnbm1lbnRUeXBlIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bXCIuXCIrYXNzaWdubWVudFR5cGVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBlZGl0b3IgcmVnaXN0ZXJlZCBmb3IgYXNzaWdubWVudCB0eXBlOlwiLCBhc3NpZ25tZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudHlwZSgpLCBzcGFjZSwgbmFtZSwgdHlwZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4vc2VydmVyXCI7XG5pbXBvcnQge09uUnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX3J1blwiO1xuaW1wb3J0IHtSdW5Db25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvcnVuXCI7XG5pbXBvcnQge0V2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvZXZhbFwiO1xuaW1wb3J0IHtTYW1wbGVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvc2FtcGxlXCI7XG5pbXBvcnQge09uQ2hhbmdlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX2NoYW5nZVwiO1xuaW1wb3J0IHtPbkV2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fZXZhbFwiO1xuaW1wb3J0IHtPblNhbXBsZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9zYW1wbGVcIjtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGV4ZWN1dGluZyBQeXRob24gY29kZSBhbmQgcGFzc2luZyB0aGUgcmVzdWx0cyBhbG9uZyB0byBpbnRlcmVzdGVkIGNvbXBvbmVudHMuXG4gKlxuICogSW50ZXJlc3RpbmcgY29tcG9uZW50czpcbiAqICBFeGVjdXRpb24gQnVmZmVyOiBSZXNwb25zaWJsZSBmb3IgY29sbGVjdGluZyB0aGUgdHJhY2UgZHVyaW5nIHByb2dyYW0gZXhlY3V0aW9uLlxuICogICAgICAgICAgICAgICAgICAgIFRoaXMgcHJldmVudHMgS25vY2tvdXRqcyBmcm9tIHVwZGF0aW5nIHRoZSBlZGl0b3IgZHVyaW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5RWRpdG9yfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5leGVjdXRpb25Nb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb247XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IHtcbiAgICAgICAgICAgIHJ1bjogbmV3IFJ1bkNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBldmFsOiBuZXcgRXZhbENvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvblJ1bjogbmV3IE9uUnVuQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBuZXcgT25DaGFuZ2VDb25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25FdmFsOiBuZXcgT25FdmFsQ29uZmlndXJhdGlvbihtYWluKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByZWNvbmZpZ3VyZSBza3VscHQgc28gd2UgY2FuIHBhcnNlXG4gICAgICAgIFNrLmNvbmZpZ3VyZSh0aGlzLmNvbmZpZ3VyYXRpb25zLnJ1bi5nZXRTa3VscHRPcHRpb25zKCkpO1xuXG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB0cmFjaW5nIHdoaWxlIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGluZ1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmFibGUgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gZXhlY3V0aW9uIGhhcyBmdWxseSBlbmRlZCxcbiAgICAgICAgICogd2hldGhlciBpdCBzdWNjZWVkcyBvciBmYWlscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25FeGVjdXRpb25CZWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25FeGVjdXRpb25FbmQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHJlcG9ydHNcbiAgICAgKi9cbiAgICByZXNldFJlcG9ydHMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLmV4ZWN1dGlvbk1vZGVsLnJlcG9ydHM7XG4gICAgICAgIHJlcG9ydFtcInZlcmlmaWVyXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wibW9kZWxcIl0gPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgfTtcblxuICAgIHJlc2V0U3R1ZGVudE1vZGVsKCkge1xuICAgICAgICBsZXQgc3R1ZGVudCA9IHRoaXMuZXhlY3V0aW9uTW9kZWwuc3R1ZGVudDtcbiAgICAgICAgc3R1ZGVudC5jYWxscyA9IHt9O1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRTdGVwKG51bGwpO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQubGFzdFN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudExpbmUobnVsbCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFRyYWNlRGF0YS5yZW1vdmVBbGwoKTtcbiAgICAgICAgc3R1ZGVudC5yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgc3R1ZGVudC50cmFjaW5nID0gW107XG4gICAgfVxuXG4gICAgcmVzZXRFeGVjdXRpb25CdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uQnVmZmVyID0ge1xuICAgICAgICAgICAgXCJ0cmFjZVwiOiBbXSxcbiAgICAgICAgICAgIFwic3RlcFwiOiAwLFxuICAgICAgICAgICAgXCJsaW5lXCI6IDAsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaW50ZXJmYWNlIGFzcGVjdHMgb2YgdGhlIHByZXZpb3VzIFJ1bi5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy8gVE9ETzogQ2xlYXIgb3V0IGFueSBjb3ZlcmFnZS90cmFjZS9lcnJvciBoaWdobGlnaHRzIGluIGVkaXRvcnNcbiAgICAgICAgLy8gUmVzZXQgZXhlY3V0aW9uIGluIG1vZGVsXG4gICAgICAgIHRoaXMucmVzZXRTdHVkZW50TW9kZWwoKTtcbiAgICAgICAgLy8gR2V0IHJlcG9ydHMgcmVhZHlcbiAgICAgICAgdGhpcy5yZXNldFJlcG9ydHMoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBleGVjdXRpb24gYnVmZmVyXG4gICAgICAgIHRoaXMucmVzZXRFeGVjdXRpb25CdWZmZXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBjb25zb2xlIG9mIHByaW50ZWQgc3R1ZmZcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5jbGVhcigpO1xuICAgICAgICAvLyBDbGVhciBvdXQgYW55IG9sZCBmZWVkYmFja1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5jbGVhcigpO1xuICAgIH1cblxuICAgIGRlbGF5ZWRSdW4oKSB7XG4gICAgICAgIC8vdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyQoXCIuYmxvY2tweS1ydW5cIikuYWRkQ2xhc3MoXCJibG9ja3B5LXJ1bi1ydW5uaW5nXCIpO1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAvL3NldFRpbWVvdXQodGhpcy5ydW4uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcblxuICAgIH1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ydW4udXNlKHRoaXMpO1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpKSB7XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVTZWNyZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUnVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5zaG93RXJyb3JzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvblJ1bigpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vblJ1bi51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5leGVjdXRpb25FbmRfLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIGxldCBldmFsdWF0aW9uSW5wdXQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmV2YWx1YXRlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2YWx1YXRpb25JbnB1dCk7XG4gICAgICAgIGV2YWx1YXRpb25JbnB1dC50aGVuKCh1c2VySW5wdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZXZhbC51c2UodGhpcywgdXNlcklucHV0KTtcbiAgICAgICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZVNlY3JldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5vbkV2YWwuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5zaG93RXJyb3JzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRXZhbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vbkV2YWwudXNlKHRoaXMpO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZXZhbHVhdGUuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMub25DaGFuZ2UudXNlKHRoaXMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlKCgpID0+XG4gICAgICAgICAgICBTay5pbXBvcnRNYWluV2l0aEJvZHkodGhpcy5jb25maWd1cmF0aW9uLmZpbGVuYW1lLCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uY29kZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3lzbW9kdWxlcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZWQgd2hlbmV2ZXIgdGhlIFB5dGhvbiBjb2RlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBvbl9jaGFuZ2UoKSB7XG4gICAgICAgIGxldCBGSUxFTkFNRSA9IFwib25fY2hhbmdlXCI7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGluc3RydWN0b3IgaGFzIG5vdCBkZWZpbmVkIGFueXRoaW5nXG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLnByb2dyYW1zW0ZJTEVOQU1FXSgpLnRyaW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3RhdHVzKFwiY2hhbmdpbmdcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlQ29kZSgpO1xuICAgICAgICAvLyBPbiBzdGVwIGRvZXMgbm90IHBlcmZvcm0gcGFyc2UgYW5hbHlzaXMgYnkgZGVmYXVsdCBvciBydW4gc3R1ZGVudCBjb2RlXG4gICAgICAgIGxldCBlbmdpbmUgPSB0aGlzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgZW5naW5lLnJlc2V0UmVwb3J0cygpO1xuICAgICAgICBlbmdpbmUudmVyaWZ5Q29kZSgpO1xuICAgICAgICBlbmdpbmUudXBkYXRlUGFyc2UoKTtcbiAgICAgICAgZW5naW5lLnJ1bkluc3RydWN0b3JDb2RlKEZJTEVOQU1FLCB0cnVlLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdKSB7XG4gICAgICAgICAgICAgICAgLy8gU1VDQ0VTUywgU0NPUkUsIENBVEVHT1JZLCBMQUJFTCwgTUVTU0FHRSwgREFUQSwgSElERVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgc2hvdyB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXNcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgIShjYXRlZ29yeSA9PT0gXCJJbnN0cnVjdG9yXCIgJiYgbGFiZWwgPT09IFwiTm8gZXJyb3JzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhjYXRlZ29yeSwgbGFiZWwsIG1lc3NhZ2UsIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmdpbmUubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhtb2R1bGUuJGQpO1xuICAgICAgICAgICAgICAgIGVuZ2luZS5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdGF0dXMoXCJjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVuZ2luZS5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiZW5naW5lXCIsIFwib25fY2hhbmdlXCIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYXR0ZW1wdCB0byBjYWxsIHRoZSBkZWZpbmVkIG9uRXhlY3V0aW9uRW5kLFxuICAgICAqIGJ1dCB3aWxsIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm8gZnVuY3Rpb24gZGVmaW5lZC5cbiAgICAgKi9cbiAgICBleGVjdXRpb25FbmRfKCkge1xuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGlvbkVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBleGVjdXRpb25CZWdpbl8oKSB7XG4gICAgICAgIGlmICh0aGlzLm9uRXhlY3V0aW9uQmVnaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25FeGVjdXRpb25CZWdpbigpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9NT0RVTEUgPSBcImxldCAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG1vZCl7IHJldHVybiBtb2Q7IH1cIjtcblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgaG9sZGluZyBzZXR0aW5ncyBvZiBhIHBhcnRpY3VsYXIgcnVuIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGlzIGlzIHRoZSByb290IGNsYXNzIGZvciBhbGwgb3RoZXIgY29uZmlndXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3lzbW9kdWxlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIC8vIEFjY2VzcyBwb2ludCBmb3IgaW5zdHJ1Y3RvciBkYXRhXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBTay5jb25zb2xlID0gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZTtcbiAgICAgICAgU2sucXVldWVkSW5wdXQgPSBbXTtcbiAgICAgICAgU2suY29uZmlndXJlKHRoaXMuZ2V0U2t1bHB0T3B0aW9ucygpKTtcbiAgICAgICAgLy8gU2V0IG9wZW5GaWxlIGFzIG1lY2hhbmlzbSB0byByZWFkIGZpbGVzXG4gICAgICAgIFNrLmluQnJvd3NlciA9IHRoaXMub3BlbkZpbGUuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgcmVxdWVzdHNcbiAgICAgICAgU2sucmVxdWVzdHNHZXQgPSAodXJsLCBkYXRhLCB0aW1lb3V0KSA9PiB0aGlzLm9wZW5VUkwodXJsLCBkYXRhLCB0aW1lb3V0KTtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgXCJkbyB5b3Ugd2FudCB0byB3YWl0PyBwcm9tcHRcIlxuICAgICAgICBTay50aW1lb3V0SGFuZGxlciA9ICh0aW1lUGFzc2VkLCBleGVjTGltaXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJvbXB0TWVzc2FnZSA9IHRoaXMuZ2V0VGltZW91dFByb21wdCh0aW1lUGFzc2VkLzEwMDAgPiAzMCk7XG4gICAgICAgICAgICBsZXQgZGVsYXkgPSBwcm9tcHQocHJvbXB0TWVzc2FnZSwgU2suZXhlY0xpbWl0LzEwMDApO1xuICAgICAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsIHx8IGRlbGF5PT0wKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBTay5leGVjTGltaXQgKyBwYXJzZUludChkZWxheSwgMTApICogMTAwMDtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IGRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9O1xuICAgICAgICAvLyBBdHRhY2ggYmVmb3JlQ2FsbFxuICAgICAgICBTay5iZWZvcmVDYWxsID0gdGhpcy5iZWZvcmVDYWxsLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFRpbWVvdXRQcm9tcHQobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKGxvbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBoYXMgdGFrZW4gYSBSRUFMTFkgbG9uZyB0aW1lIHRvIHJ1biAoMzAgb3IgbW9yZSBzZWNvbmRzKS4gWW91IG1pZ2h0IHdhbnQgdG8gY2FuY2VsIGFuZCBjaGVjayB5b3VyIGNvZGUuIE9yLCB5b3UgY2FuIGFkZCBtb3JlIHNlY29uZHMgdG8gd2FpdCBiZWxvdy5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBwcm9ncmFtIGlzIHRha2luZyBhIHdoaWxlIHRvIHJ1bi4gSG93IG1hbnkgbW9yZSBzZWNvbmRzIHdvdWxkIHlvdSBsaWtlIHRvIHdhaXQ/XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTa3VscHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19mdXR1cmVfXzogU2sucHl0aG9uMyxcbiAgICAgICAgICAgIC8vIGltcG9ydFxuICAgICAgICAgICAgcmVhZDogdGhpcy5pbXBvcnRGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBvcGVuXG4gICAgICAgICAgICAvL2ZpbGVvcGVuOiB0aGlzLm9wZW5GaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBmaWxlLndyaXRlXG4gICAgICAgICAgICBmaWxld3JpdGU6IHRoaXMud3JpdGVGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBwcmludFxuICAgICAgICAgICAgb3V0cHV0OiB0aGlzLnByaW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBpbnB1dFxuICAgICAgICAgICAgaW5wdXRmdW46IHRoaXMuaW5wdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGlucHV0ZnVuVGFrZXNQcm9tcHQ6IHRydWUsXG4gICAgICAgICAgICAvLyBNZWRpYSBJbWFnZSBQcm94eSBVUkxcbiAgICAgICAgICAgIGltYWdlUHJveHk6IHRoaXMuZ2V0SW1hZ2VQcm94eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIHNldCBieSB0aGUgc3lzdGVtIHNvIHdlIGNhbiB1c2Ugb3VyIG93biBzZXJ2ZXJzIGluIHByYWN0aWNlXG4gICAgICAgICAgICBlbW9qaVByb3h5OiAocGFydCkgPT4gYGh0dHBzOi8vdHdlbW9qaS5tYXhjZG4uY29tL3YvMTMuMS4wL3N2Zy8ke3BhcnQudG9Mb3dlckNhc2UoKX0uc3ZnYCxcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIGtlZXAgdGhlIGdsb2JhbHNcbiAgICAgICAgICAgIHJldGFpbkdsb2JhbHM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFjY2VzcyBTa3VscHQgYnVpbHQtaW5zLiBUaGlzIGlzIHByZXR0eSBnZW5lcmljLCB0YWtlblxuICAgICAqIGFsbW9zdCBkaXJlY3RseSBmcm9tIHRoZSBTa3VscHQgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBweXRob24gZmlsZW5hbWUgKGUuZy4sIFwib3NcIiBvciBcInBwcmludFwiKSB0aGF0IHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIG9mIHRoZSBmaWxlICh3ZWlyZCwgcmlnaHQ/KVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpc24ndCBmb3VuZC5cbiAgICAgKi9cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG5cbiAgICBvcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCkge1xuICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBtb2NrVXJsRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgaWYgKG1vY2tVcmxEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFVSTCBEYXRhIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9ja1VybERhdGEgPSBKU09OLnBhcnNlKG1vY2tVcmxEYXRhLmhhbmRsZSgpKTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gbW9ja1VybERhdGEpIHtcbiAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YS5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2NrVXJsRGF0YVtmaWxlbmFtZV0ubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ja1VybERhdGFbZmlsZW5hbWVdW2ldID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ucmVhZEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWplY3QobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogXCIrdXJsK1wiIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIC8vfSk7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIHdyaXRlRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaW5wdXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIGNsZWFySW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cygpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlucHV0TW9ja0Z1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2sucXVldWVkSW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gU2sucXVldWVkSW5wdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXRJbWFnZVByb3h5KHVybCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgc3RlcCgpIHtcblxuICAgIH1cblxuICAgIGxhc3RTdGVwKCkge1xuXG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0IHN1Y2Nlc3MgZXhlY3V0aW9uXCIpO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3QgZmFpbHVyZSBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmluYWxseShyZXN1bHQpIHtcbiAgICAgICAgLy8gRm9yY2UgUHlnYW1lIHRvIHN0b3AgdHJhcHBpbmcga2V5Ym9hcmQgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHVtbXlPdXRTYW5kYm94KCkge1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC9zYW5kYm94LnB5XCJdID0gXCJjbGFzcyBTYW5kYm94OiBwYXNzXFxuZGVmIHJ1bigpOiBwYXNzXFxuZGVmIHJlc2V0KCk6IHBhc3NcXG5cIjtcbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUUkFDS0lORyBDQUxMXCIsIGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGZhc3RjYWxsIHRvbz8gQ2hlY2sgaG93IHRoYXQgd29ya3MgaW4gU2t1bHB0IHNpZGVcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICBpZiAoIShcImNhbGxzXCIgaW4gc3R1ZGVudE1vZGVsKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZnVuY3Rpb25OYW1lIGluIHN0dWRlbnRNb2RlbC5jYWxscykpIHtcbiAgICAgICAgICAgIHN0dWRlbnRNb2RlbC5jYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgLy8gR2V0IGFjdHVhbCBwYXJhbWV0ZXIgbmFtZXMhIVxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBwb3NhcmdzLmxlbmd0aDsgaSs9IDEpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1wiK2ldID0gcG9zYXJnc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa3dhcmdzICYmIGt3YXJnc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19BUkdTXCJdID0ga3dhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0tXQVJHU1wiXSA9IGt3YXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXS5wdXNoKGFyZ3MpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuLi90cmFjZVwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSwgY29kZSkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdG8gYmUgY3VycmVudGx5IGFkZGVkIGxpbmVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiXyA9IFwiICsgY29kZTtcbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gdHJ1ZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLkFkZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIHRoaXMuY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1FdmFsdWF0ZS5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludFZhbHVlKFNrLmZmaS5yZW1hcFRvSnMobW9kdWxlLiRkLl8uJHIoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnMuanNcIjtcbmltcG9ydCB7JHNrX21vZF9pbnN0cnVjdG9yfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3JcIjtcbmltcG9ydCB7JHNrX21vZF9jb3ZlcmFnZX0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL2NvdmVyYWdlXCI7XG5pbXBvcnQgeyRwZWRhbF90cmFjZXJ9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9wZWRhbF90cmFjZXJcIjtcbmltcG9ydCB7Y2hvbXBTcGVjaWFsRmlsZX0gZnJvbSBcIi4uL2ZpbGVzXCI7XG5cbmNvbnN0IFVUSUxJVFlfTU9EVUxFX0NPREUgPSBcInZhciAkYnVpbHRpbm1vZHVsZSA9IFwiICsgJHNrX21vZF9pbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG5jb25zdCBDT1ZFUkFHRV9NT0RVTEVfQ09ERSA9ICRza19tb2RfY292ZXJhZ2U7XG5cbmV4cG9ydCBjbGFzcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIEluc3RydWN0b3JzIGdldCA0IHNlY29uZHNcbiAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogNzAwMDtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgLy8gU3RlcHBlciEgRXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc3RhdGVtZW50LlxuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IG51bGw7IC8vIDEwICoxMDAwXG4gICAgICAgIC8vIE11dGUgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcih0cnVlKTtcbiAgICAgICAgLy8gRGlzYWJsZSBpbnB1dCBib3hcbiAgICAgICAgU2sucXVldWVkSW5wdXQgPSBbXTtcbiAgICAgICAgLy8gVE9ETyBTay5pbnB1dGZ1biA9IEJsb2NrUHlFbmdpbmUuaW5wdXRNb2NrRnVuY3Rpb247XG4gICAgICAgIC8vIFRPRE86IEFsbG93IGlucHV0IGZ1bmN0aW9uIHRvIGRpc2FibGUgdGhlIHRpbWVyLCBzb21laG93XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJlZm9yZUNhbGwgY2hlY2tlciB1bmxlc3Mgc3BlY2lmaWNhbGx5IHJlcXVlc3RlZFxuICAgICAgICBTay5iZWZvcmVDYWxsQmFja3VwID0gU2suYmVmb3JlQ2FsbDtcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIC8vIEVuYWJsZSB1dGlsaXR5IG1vZGVcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gVVRJTElUWV9NT0RVTEVfQ09ERTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9jb3ZlcmFnZS5weVwiXSA9IENPVkVSQUdFX01PRFVMRV9DT0RFO1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIG5lZWRzIHRvIGJlIG9wdGltaXplZFxuICAgICAgICAvL2NvbnN0IFBFREFMX1RSQUNFUl9NT0RVTEVfQ09ERSA9IFNrLmNvbXBpbGUoJHBlZGFsX3RyYWNlciwgXCJ0cmFjZXIucHlcIiwgXCJleGVjXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3RyYWNlci5weVwiXSA9ICRwZWRhbF90cmFjZXI7XG4gICAgICAgIGRlbGV0ZSBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLmpzXCJdO1xuICAgICAgICAvLyBUT0RPOiBNb2NrIFBlZGFsJ3MgdHJhY2VyIG1vZHVsZSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2ZXJzaW9uXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcIi4vX2luc3RydWN0b3IvX19pbml0X18uanNcIl0gPSBFTVBUWV9NT0RVTEU7XG4gICAgICAgIC8vIFJldXNlIGFueSBleGlzdGluZyBzeXNtb2R1bGVzIHRoYXQgd2UgcHJldmlvdXNseSBmb3VuZCwgYnV0IG5vdCBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIHRoaXMuc3lzbW9kdWxlcyA9IHRoaXMuY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCk7XG4gICAgICAgIC8vIEhvcnJpZmljIGhhY2ssIHRvIHByZXZlbnQgVGlmYSBmcm9tIGNhY2hpbmcgYSBiYWQgdmVyc2lvbiBvZiB0aGUgc3R1ZGVudHMnIGltcG9ydFxuICAgICAgICBTay5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMgPSB0aGlzLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgc3VwZXIucHJpbnQodmFsdWUpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJQcmludGVkOlwiLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCkge1xuICAgICAgICBsZXQgc3lzbW9kdWxlcyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIF9fbWFpbl9fIG1vZHVsZXNcbiAgICAgICAgaWYgKHN5c21vZHVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgb2YgdGhpcy5nZXRBbGxGaWxlbmFtZXMoKSkge1xuICAgICAgICAgICAgICAgIGxldCBza0ZpbGVuYW1lID0gbmV3IFNrLmJ1aWx0aW4uc3RyKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAvKmlmIChzeXNtb2R1bGVzLnF1aWNrJGxvb2t1cChza0ZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzLnBvcCRpdGVtKHNrRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICAgIHN5c21vZHVsZXMucG9wJGl0ZW0oc2tGaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5c21vZHVsZXM7XG4gICAgfVxuXG4gICAgZ2V0QWxsU3R1ZGVudEZpbGVzKCkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHtcbiAgICAgICAgICAgIFwiYW5zd2VyLnB5XCI6IHRoaXMubWFpbi5tb2RlbC51aS5maWxlcy5nZXRTdHVkZW50Q29kZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNraXAgc3BlY2lhbCBpbnN0cnVjdG9yIGZpbGVzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGlmICghKFwiIV4kI1wiLmluY2x1ZGVzKGZpbGUuZmlsZW5hbWUoKVswXSkpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXNbZmlsZS5maWxlbmFtZSgpXSA9IGNob21wU3BlY2lhbEZpbGUoZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluY2x1ZGUgbm9ybWFsIHN0dWRlbnQgZXh0cmEgZmlsZXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlLmZpbGVuYW1lKCldID0gZmlsZS5jb250ZW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH1cblxuICAgIGdldEFsbEZpbGVuYW1lcygpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW4oZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gY2hvbXBTcGVjaWFsRmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIucHlcIikpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJfX21haW5fX1wiLFxuICAgICAgICAgICAgXCJfaW5zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgLi4udGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5tYXAoZmlsZSA9PiBcIl9pbnN0cnVjdG9yLlwiICsgY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgICAgICAuLi50aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKCkubWFwKGZpbGUgPT4gY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBjaGVjayB5b3VyIGNvZGUgKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlIChvciBnZXQgaGVscCBmcm9tIGFuIGluc3RydWN0b3IpLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGlzIHRha2luZyBhIGxpdHRsZSB3aGlsZSB0byBjaGVjayB5b3VyIGNvZGU7IGl0IG1pZ2h0IGp1c3QgbmVlZCBhIGxpdHRsZSBtb3JlIHRpbWUuIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiK2ZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfTU9EVUxFO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgLy9yZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+PlwiLCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCksIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpIDwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBuZXh0SW5wdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8qcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKFNrLnF1ZXVlZElucHV0LnBvcCgpKTtcbiAgICAgICAgfSk7Ki9cbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIGxldCBzdHVkZW50TW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkhFWSBJTlNUUlVDVE9SIENBTExcIiwgZnVuY3Rpb25OYW1lLCBzdHVkZW50TW9kZWwudHJhY2luZyk7XG4gICAgICAgIGlmIChzdHVkZW50TW9kZWwudHJhY2luZyAmJiBzdHVkZW50TW9kZWwudHJhY2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1cGVyLmJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuXG5leHBvcnQgY2xhc3MgT25DaGFuZ2VDb25maWd1cmF0aW9uIGV4dGVuZHMgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIm9uX2NoYW5nZS5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS50cmlnZ2VyT25DaGFuZ2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge2ZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0LCBJTlNUUlVDVE9SX01BUktFUiwgTkVXX0xJTkVfUkVHRVh9IGZyb20gXCIuL29uX3J1blwiO1xuaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50Q29kZSwgaW5zdHJ1Y3RvckNvZGUsIHF1aWNrLCBpc1NhZmUpIHtcbiAgICBsZXQgc2FmZUNvZGUgPSBKU09OLnN0cmluZ2lmeShzdHVkZW50Q29kZSk7XG5cbiAgICByZXR1cm4gYFxuZnJvbSB1dGlsaXR5IGltcG9ydCAqXG5cbiMgTG9hZCBpbiBzb21lIGNvbW1vbmx5IHVzZWQgdG9vbHNcbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuZnJvbSBwZWRhbC5zYW5kYm94LmNvbW1hbmRzIGltcG9ydCAqXG5mcm9tIHBlZGFsLmNvcmUuY29tbWFuZHMgaW1wb3J0ICpcblxuIyBCYWNrdXAgdGhlIGZlZWRiYWNrXG5vbl9ydW5fZmVlZGJhY2sgPSBbXVxuZm9yIGZlZWRiYWNrIGluIE1BSU5fUkVQT1JULmZlZWRiYWNrOlxuICAgIG9uX3J1bl9mZWVkYmFjay5hcHBlbmQoZmVlZGJhY2spXG5NQUlOX1JFUE9SVC5mZWVkYmFjay5jbGVhcigpXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIEFkZCBpbiBldmFsdWF0ZWQgc3R1ZmYgZnJvbSBsYXN0IHRpbWVcbnN0dWRlbnQgPSBnZXRfc2FuZGJveCgpXG4jIFRPRE86IFdoYXQgYWJvdXQgbmV3IGlucHV0cyBzaW5jZSB3ZSBsYXN0IHJhbi9ldmFsZWQ/XG4jIE1BSU5fUkVQT1JULnN1Ym1pc3Npb24uZmlsZXNbJ2V2YWx1YXRpb24nXSA9ICR7c2FmZUNvZGV9XG5ldmFsdWF0ZSgke3NhZmVDb2RlfVsnZXZhbHVhdGlvbiddKVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiX2luc3RydWN0b3Iub25fZXZhbFwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSB8fCBcIlwiO1xuXG4gICAgICAgIGxldCBkaXNhYmxlVGlmYSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaWZhKCk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQuZXZhbHVhdGlvbiB8fCBcIk5vbmVcIjtcbiAgICAgICAgbGV0IHN0dWRlbnRGaWxlcyA9IHRoaXMuZ2V0QWxsU3R1ZGVudEZpbGVzKCk7XG4gICAgICAgIHN0dWRlbnRGaWxlc1tcImV2YWx1YXRpb25cIl0gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudC5ldmFsdWF0aW9uIHx8IFwiTm9uZVwiO1xuICAgICAgICB0aGlzLmR1bW15T3V0U2FuZGJveCgpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3RvckNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudEZpbGVzLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4+XCIsIGluc3RydWN0b3JDb2RlKTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldChpbnN0cnVjdG9yQ29kZSk7IC8vaW5zdHJ1Y3RvckNvZGUuc3BsaXQoTkVXX0xJTkVfUkVHRVgpLmxlbmd0aDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICBcImNvZGVcIjogaW5zdHJ1Y3RvckNvZGUsXG4gICAgICAgICAgICBcImxpbmVPZmZzZXRcIjogbGluZU9mZnNldFxuICAgICAgICAgICAgLy8nY29tcGxldGUnOiBmYWxzZSAvLyBBY3R1YWxseSwgbGV0J3MgdXNlIHVuZGVmaW5lZCBmb3Igbm93LlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICAvL1NrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZSk7XG4gICAgICAgIGxldCByZXN1bHRzID0gbW9kdWxlLiRkLm9uX2V2YWwuJGQ7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZS4kZCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKE1hdGgubWF4KG9sZFNjb3JlLCBzY29yZSkpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPbkV2YWwgZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIkdyYWNlZnVsRXhpdFwiKSB7XG4gICAgICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImNvZGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiZXJyb3JcIl0gPSBlcnJvcjtcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImxpbmVfb2Zmc2V0XCJdID0gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGFmdGVyKGVycm9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdG9yQ29kZS5pbmRleE9mKElOU1RSVUNUT1JfTUFSS0VSKTtcbiAgICBjb25zdCBiZWZvcmUgPSBpbnN0cnVjdG9yQ29kZS5zbGljZSgwLCBpbmRleCk7XG4gICAgY29uc3QgbWF0Y2ggPSBiZWZvcmUubWF0Y2goTkVXX0xJTkVfUkVHRVgpO1xuICAgIHJldHVybiBtYXRjaCA/ICgxK21hdGNoLmxlbmd0aCkgOiAwO1xufVxuXG5leHBvcnQgY29uc3QgSU5TVFJVQ1RPUl9NQVJLRVIgPSBcIiMjI1J1biB0aGUgYWN0dWFsIGluc3RydWN0b3IgY29kZSMjI1wiO1xuZXhwb3J0IGNvbnN0IE5FV19MSU5FX1JFR0VYID0gL1xcbi9nO1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50RmlsZXMsIGluc3RydWN0b3JDb2RlLCBxdWljaywgaXNTYWZlKSB7XG4gICAgbGV0IHNhZmVDb2RlID0gSlNPTi5zdHJpbmdpZnkoc3R1ZGVudEZpbGVzKTtcbiAgICBsZXQgc2tpcF90aWZhID0gcXVpY2sgPyBcIlRydWVcIjogXCJGYWxzZVwiO1xuXG4gICAgLy8gVE9ETzogQWRkIGluIFNrLnF1ZXVlZElucHV0IHRvIGJlIHBhc3NlZCBpblxuXG4gICAgcmV0dXJuIGBcbiMgU3VwcG9ydCBvdXIgc3lzbW9kdWxlcyBoYWNrIGJ5IGNsZWFyaW5nIG91dCBhbnkgbGluZ2VyaW5nIG9sZCBkYXRhXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuTUFJTl9SRVBPUlQuY2xlYXIoKVxuXG5mcm9tIGJha2VyeSBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBTZXQgdGhlIHNlZWQgdG8gdGhlIHN1Ym1pc3Npb24gSUQgYnkgZGVmYXVsdD9cbmZyb20gcGVkYWwucXVlc3Rpb25zIGltcG9ydCBzZXRfc2VlZFxuc2V0X3NlZWQoc3RyKGdldF9tb2RlbF9pbmZvKFwic3VibWlzc2lvbi5pZFwiKSkpXG5cbiMgSW5pdGlhbGl6ZSB0aGUgQmxvY2tQeSBlbnZpcm9ubWVudFxucGVkYWwgPSBzZXR1cF9lbnZpcm9ubWVudChza2lwX3RpZmE9JHtza2lwX3RpZmF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3J1bj1za2lwX3J1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzPWlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9maWxlPSdhbnN3ZXIucHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcz0ke3NhZmVDb2RlfSlcbnN0dWRlbnQgPSBwZWRhbC5maWVsZHNbJ3N0dWRlbnQnXVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ydW5cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuICAgICAgICAvLyBQdXQgdGhlIGlucHV0IGluZGV4IGJhY2sgdG8gdGhlIGZyb250LCBzbyB3ZSBjYW4gcmVwbGF5IGlucHV0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMSk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICBsZXQgc3R1ZGVudEZpbGVzID0gdGhpcy5nZXRBbGxTdHVkZW50RmlsZXMoKTtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKTsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICAvL2xpbmVPZmZzZXQgPSAwOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGggLSBsaW5lT2Zmc2V0IC0gNDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIC8vIFRPRE8gTG9nZ2luZyEhISFcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk9uUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtb2R1bGUuJGQub25fcnVuLiRkO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgob2xkU2NvcmUsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc2NvcmUpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk9uUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufVxuXG5cbi8qXG4jIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG9sZCBpbnN0cnVjdG9yIGNvZGUsIGxlYXZpbmcgaXQgaGVyZSBmb3Igbm93LlxuXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbk1BSU5fUkVQT1JULmNsZWFyKClcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgY29udGV4dHVhbGl6ZV9yZXBvcnRcbmNvbnRleHR1YWxpemVfcmVwb3J0KCR7c2FmZUNvZGV9LCBcImFuc3dlci5weVwiKVxuJHt0aWZhQW5hbHlzaXN9XG5mcm9tIHBlZGFsLnNhbmRib3guc2FuZGJveCBpbXBvcnQgU2FuZGJveFxuZnJvbSBwZWRhbC5zYW5kYm94IGltcG9ydCBjb21wYXRpYmlsaXR5XG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcbnN0dWRlbnQgPSBNQUlOX1JFUE9SVFsnc2FuZGJveCddWydydW4nXSA9IFNhbmRib3goKVxuc3R1ZGVudC5yZXBvcnRfZXhjZXB0aW9uc19tb2RlID0gVHJ1ZVxubG9nKGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbnN0dWRlbnQuc2V0X2lucHV0KGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbmlmIG5vdCBnZXRfbW9kZWxfaW5mbygnYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlSW5zdHJ1Y3RvclJ1bicpOlxuICAgIGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnQocmFpc2VfZXhjZXB0aW9ucz1GYWxzZSlcbiNsb2coc3R1ZGVudC5kYXRhKVxuI3N0dWRlbnQgPSBnZXRfc3R1ZGVudF9kYXRhKClcbiNlcnJvciwgcG9zaXRpb24gPSBnZXRfc3R1ZGVudF9lcnJvcigpXG4jY29tcGF0aWJpbGl0eS5yYWlzZV9leGNlcHRpb24oZXJyb3IsIHBvc2l0aW9uKVxucnVuX3N0dWRlbnQgPSBjb21wYXRpYmlsaXR5LnJ1bl9zdHVkZW50XG5yZXNldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LnJlc2V0X291dHB1dFxucXVldWVfaW5wdXQgPSBjb21wYXRpYmlsaXR5LnF1ZXVlX2lucHV0XG5nZXRfb3V0cHV0ID0gY29tcGF0aWJpbGl0eS5nZXRfb3V0cHV0XG5nZXRfcGxvdHMgPSBjb21wYXRpYmlsaXR5LmdldF9wbG90c1xuY29tcGF0aWJpbGl0eS50cmFjZV9saW5lcyA9IHRyYWNlX2xpbmVzXG5mcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbnF1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuIyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgZm9yIHRoaXMgaGFjayFcbmRlZiBjYXB0dXJlX291dHB1dChmdW5jLCAqYXJncyk6XG4gICByZXNldF9vdXRwdXQoKVxuICAgc3R1ZGVudC5jYWxsKGZ1bmMuX19uYW1lX18sICphcmdzKVxuICAgcmV0dXJuIGdldF9vdXRwdXQoKVxuY29tcGF0aWJpbGl0eS5jYXB0dXJlX291dHB1dCA9IGNhcHR1cmVfb3V0cHV0XG5cbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuJHtpbnN0cnVjdG9yQ29kZX1cbmZyb20gcGVkYWwucmVzb2x2ZXJzIGltcG9ydCBzaW1wbGVcbmZpbmFsID0gc2ltcGxlLnJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuICovIiwiaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL29uX3J1blwiO1xuXG5leHBvcnQgY2xhc3MgT25TYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgT25SdW5Db25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9ydW4ucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuXG5leHBvcnQgY2xhc3MgUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVTdHVkZW50UnVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlRmlsZShcImFuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCksIG51bGwpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuY29kZSk7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIGVuZ2luZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnNlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1widmVyaWZpZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogQm9vbGVhbih0aGlzLmNvZGUudHJpbSgpKSxcbiAgICAgICAgICAgIFwiY29kZVwiOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIFNrLmVudmlyb24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgU2suZW52aXJvbiA9IG5ldyBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmludGVyVGFnID0gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludGVyVGFnLFxuICAgICAgICAgICAgd2lkdGggPSBwcmludGVyVGFnLndpZHRoKCktNTAsXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgzMDAsIHByaW50ZXJUYWcuaGVpZ2h0KCktNTApO1xuICAgICAgICBTay5lbnZpcm9uLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cihcIkRFU0lHTkVSX1dJTkRPV19XSURUSFwiKSwgbmV3IFNrLmJ1aWx0aW4uaW50Xyh3aWR0aCkpO1xuICAgICAgICBTay5lbnZpcm9uLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cihcIkRFU0lHTkVSX1dJTkRPV19IRUlHSFRcIiksIG5ldyBTay5idWlsdGluLmludF8oaGVpZ2h0KSk7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY2xlYXJJbnB1dCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgXCJpbnB1dHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIiksXG4gICAgICAgICAgICBcIm91dHB1dHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQoKS5tYXAobGluZSA9PiBsaW5lLmNvbnRlbnQpLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlJ1bi5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5maW5pc2hUdXJ0bGVzKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRXZhbHVhdGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5iZWdpbkV2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGVwKG1vZHVsZS4kZCwgbW9kdWxlLiRkLC0xLCAwLCBmaWxlbmFtZSArIFwiLnB5XCIpO1xuICAgICAgICAgICAgdGhpcy5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInRyYWNlXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZSxcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVhbExpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5maWx0ZXIoeCA9PiAheC5pc0RvY3N0cmluZykubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlc3VsdHNcIjogbW9kdWxlLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ub3V0cHV0LFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJ1biBmYWlsdXJlXCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAocmVwb3J0LnBhcnNlci5zdWNjZXNzICYmIHJlcG9ydC52ZXJpZmllci5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlLkVycm9yXCIsIFwiXCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJQcm9ncmFtRXJyb3JPdXRwdXRcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlYWxMaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UuZmlsdGVyKHggPT4gIXguaXNEb2NzdHJpbmcpLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7U3R1ZGVudENvbmZpZ3VyYXRpb259IGZyb20gXCIuL3N0dWRlbnRcIjtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gVE9ETzogRml4IHRvIGJlIHRoZSBjdXJyZW50IHNhbXBsZSBzdWJtaXNzaW9uXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlci5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcInByaW50KCdOb3QgcmVhZHkgeWV0IScpXCI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7Q29uZmlndXJhdGlvbiwgRU1QVFlfTU9EVUxFfSBmcm9tIFwiLi9jb25maWd1cmF0aW9uc1wiO1xuXG5leHBvcnQgY2xhc3MgU3R1ZGVudENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBMaW1pdCBleGVjdXRpb24gdG8gNCBzZWNvbmRzXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IHRoaXMubWFpbi5tb2RlbC5zZXR0aW5ncztcbiAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogNTAwMDtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgLy8gU3RlcHBlciEgRXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc3RhdGVtZW50LlxuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IHRoaXMuc3RlcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFVubXV0ZSBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKGZhbHNlKTtcblxuICAgICAgICAvLyBGdW5jdGlvbiB0byBjYWxsIGFmdGVyIGVhY2ggc3RlcFxuICAgICAgICAvLyBhZnRlclNpbmdsZUV4ZWN1dGlvblxuXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvdXRpbGl0eS9fX2luaXRfXy5qc1wiXSA9IEVNUFRZX01PRFVMRTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvcGVuRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGZpbGVuYW1lLCBmb3VuZCk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoU2suYnVpbHRpbkZpbGVzICYmIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiBcIiArIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvcmJpZGRlbihmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IFwiRmlsZSBub3QgYWNjZXNzaWJsZTogJ1wiICsgZmlsZW5hbWUgKyBcIidcIjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL2Fuc3dlci5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6ICdcIitmaWxlbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmlucHV0KHByb21wdE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlzRm9yYmlkZGVuKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwic3JjL2xpYi91dGlsaXR5L1wiKSB8fFxuICAgICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcInNyYy9saWIvcGVkYWwvXCIpIHx8XG4gICAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwiLi9faW5zdHJ1Y3Rvci9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXCJTdGVwc1wiIHRoZSBleGVjdXRpb24gb2YgdGhlIGNvZGUsIG1lYW50IHRvIGJlIHVzZWQgYXMgYSBjYWxsYmFjayB0byB0aGUgU2t1bHB0XG4gICAgICogZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFscyAtIEhhc2ggdGhhdCBtYXBzIHRoZSBuYW1lcyBvZiBnbG9iYWwgdmFyaWFibGVzIChTdHJpbmdzKSB0byB0aGVpciBTa3VscHQgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FscyAtIEhhc2ggdGhhdCBtYXBzIHRoZSBuYW1lcyBvZiBsb2NhbCB2YXJpYWJsZXMgKFN0cmluZ3MpIHRvIHRoZWlyIFNrdWxwdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZU51bWJlciAtIFRoZSBjb3JyZXNwb25kaW5nIGxpbmUgbnVtYmVyIGluIHRoZSBzb3VyY2UgY29kZSB0aGF0IGlzIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5OdW1iZXIgLSBUaGUgY29ycmVzcG9uZGluZyBjb2x1bW4gbnVtYmVyIGluIHRoZSBzb3VyY2UgY29kZSB0aGF0IGlzIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGluayBvZiBpdCBhcyB0aGUgXCJYXCIgcG9zaXRpb24gdG8gdGhlIGxpbmVOdW1iZXIncyBcIllcIiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHl0aG9uIGZpbGUgYmVpbmcgZXhlY3V0ZWQgKGUuZy4sIFwiX19tYWluX18ucHlcIikuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0RvY3N0cmluZyAtIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYW4gYWN0dWFsIGxpbmUgb3IgYSBkb2NzdHJpbmcuXG4gICAgICovXG4gICAgc3RlcChnbG9iYWxzLCBsb2NhbHMsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlciwgZmlsZW5hbWUsIGlzRG9jc3RyaW5nLCBhc3ROYW1lKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgLyppZiAoZXhlY1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhlY1N0YWNrLm1hcCgoW24sIG9dKSA9PiBbbiwgey4uLm99XSkpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcDtcbiAgICAgICAgICAgIGdsb2JhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMoey4uLmdsb2JhbHMsIC4uLmxvY2Fsc30pO1xuICAgICAgICAgICAgLy8gVE9ETzogVHJhY2UgbG9jYWwgdmFyaWFibGVzIHByb3Blcmx5XG4gICAgICAgICAgICAvL2xldCBsb2NhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMobG9jYWxzKTtcbiAgICAgICAgICAgIC8vT2JqZWN0LmFzc2lnbihnbG9iYWxzLCBsb2NhbHMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic3RlcFwiOiBjdXJyZW50U3RlcCxcbiAgICAgICAgICAgICAgICBcImZpbGVuYW1lXCI6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIC8vJ2Jsb2NrJzogaGlnaGxpZ2h0TWFwW2xpbmVOdW1iZXItMV0sXG4gICAgICAgICAgICAgICAgXCJsaW5lXCI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiBnbG9iYWxzLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgXCJtb2R1bGVzXCI6IGdsb2JhbHMubW9kdWxlcyxcbiAgICAgICAgICAgICAgICBcImlzRG9jc3RyaW5nXCI6IGlzRG9jc3RyaW5nLFxuICAgICAgICAgICAgICAgIFwiYXN0XCI6IGFzdE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAgPSBjdXJyZW50U3RlcCArIDE7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBTa3VscHQgZXhlY3V0aW9uIHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uQnVmZmVyXG4gICAgICogYW5kIGhhbmQgaXQgb2ZmIHRvIHRoZSBleGVjdXRpb24gdHJhY2UgaW4gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGxhc3RTdGVwKCkge1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0TGluZSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgIH07XG5cbiAgICBnZXRMaW5lcyhhc3QpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWRMaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHZpc2l0Qm9keSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5saW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRMaW5lcy5hZGQobm9kZS5saW5lbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYm9keS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9yZWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUub3JlbHNlLmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZmluYWxib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maW5hbGJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0Qm9keShhc3QpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpdGVkTGluZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZSBwYXJzZSBpbmZvcm1hdGlvbiBpcyB1cC10by1kYXRlXG4gICAgICovXG4gICAgdXBkYXRlUGFyc2UoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIC8vIEhvbGQgYWxsIHRoZSBhY3R1YWxseSBkaXNjb3ZlcmVkIGxpbmVzIGZyb20gdGhlIHBhcnNlXG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAvLyBBdHRlbXB0IGEgcGFyc2VcbiAgICAgICAgbGV0IGFzdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwYXJzZSA9IFNrLnBhcnNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICBhc3QgPSBTay5hc3RGcm9tUGFyc2UocGFyc2UuY3N0LCB0aGlzLmZpbGVuYW1lLCBwYXJzZS5mbGFncyk7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ2V0TGluZXMoYXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlcG9ydCB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImVtcHR5XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5maWxlbmFtZSwgdGhpcy5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWNjZXNzZnVsIHBhcnNlXG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJhc3RcIjogYXN0LFxuICAgICAgICAgICAgXCJlbXB0eVwiOiBhc3QuYm9keS5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBcImxpbmVzXCI6IGxpbmVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNob3dFcnJvcnMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZVNlY3JldEVycm9yKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgaWYgKCFyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckJ1dHRvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZmVlZGJhY2sucHJlc2VudFJ1bkVycm9yKHJlcG9ydC5zdHVkZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLmF0dHIoXCJ0aXRsZVwiLCBcIkNsaWNrIHRvIHNlZSBPcmlnaW5hbCBFcnJvclwiKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnRvb2x0aXAoe1widHJpZ2dlclwiOiBcImhvdmVyXCIsIFwiY29udGFpbmVyXCI6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludH0pO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uY2xpY2soKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUihtZXNzYWdlKSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IGxldCBGRUVEQkFDS19IVE1MID0gYFxuXG48c3BhbiBjbGFzcz0nYmxvY2tweS1mbG9hdGluZy1mZWVkYmFjayB0ZXh0LW11dGVkLWxlc3MgcHVsbC1yaWdodCBwb3NpdGlvbi1zdGlja3kgc3RpY2t5LXRvcCdcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1sYWJlbD1cIk5ldyBGZWVkYmFjayBBbGVydFwiPlxuICAgIE5ldyBmZWVkYmFjayAmdWFycjtcbjwvc3Bhbj5cblxuPGRpdiBjbGFzcz0nYmxvY2tweS1mZWVkYmFjayBibG9ja3B5LXBhbmVsJ1xuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJGZWVkYmFja1wiXG4gICAgICAgICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLmNvbnNvbGUuc2l6ZVwiPlxuXG4gICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgPCEtLSBrbyBpZm5vdDogdWkuc2Vjb25kUm93LmhpZGVUcmFjZUJ1dHRvbiAtLT5cbiAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbidcbiAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCdcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+XG4gICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLnNlY29uZFJvdy5zd2l0Y2hMYWJlbFwiPjwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFBvc2l0aXZlIEZlZWRiYWNrIFJlZ2lvbiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZSBmbG9hdC1yaWdodFwiPlxuICAgICAgICBcbiAgICBcbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gQWN0dWFsIEZlZWRiYWNrIFJlZ2lvbiAtLT4gICAgXG4gICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZz5GZWVkYmFjazogPC9zdHJvbmc+XG4gICAgICAgIDxzcGFuIGNsYXNzPSdiYWRnZSBibG9ja3B5LWZlZWRiYWNrLWNhdGVnb3J5IGZlZWRiYWNrLWJhZGdlJ1xuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB1aS5mZWVkYmFjay5iYWRnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdWkuZmVlZGJhY2suY2F0ZWdvcnlcIj5GZWVkYmFjayBLaW5kPC9zcGFuPlxuICAgICAgICA8c21hbGwgZGF0YS1iaW5kPVwidGV4dDogKDEwMCpzdWJtaXNzaW9uLnNjb3JlKCkpKyclJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKClcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+PC9zbWFsbD5cbiAgICAgICAgPHNtYWxsIGRhdGEtYmluZD1cImNsaWNrOiB1aS5mZWVkYmFjay5yZXNldFNjb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBkaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKSAmJiBzdWJtaXNzaW9uLnNjb3JlKCkgPiAwXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGV4dC1tdXRlZFwiIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyXCI+PHU+KHJlc2V0KTwvdT48L3NtYWxsPlxuICAgIDwvZGl2PlxuICAgIDxkaXY+XG4gICAgICAgIDxzdHJvbmcgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInRleHQ6IGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbFwiPjwvc3Ryb25nPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IGV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj4gICAgICAgICAgICBcbmA7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmVlZGJhY2sge1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgZmVlZGJhY2sgYXJlYSwgd2hlcmUgdXNlcnMgYXJlIHRvbGQgdGhlIHN0YXRlIG9mIHRoZWlyXG4gICAgICogcHJvZ3JhbSdzIGV4ZWN1dGlvbiBhbmQgZ2l2ZW4gZ3VpZGFuY2UuIEFsc28gbWFuYWdlcyB0aGUgY3JlYXRpb24gb2YgdGhlIFRyYWNlIFRhYmxlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRoaXMge0Jsb2NrUHlGZWVkYmFja31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjaztcblxuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWNhdGVnb3J5XCIpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbWVzc2FnZVwiKTtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZVwiKTtcblxuICAgICAgICAvLyBUT0RPOiBJZiB0aGV5IGNoYW5nZSB0aGUgc3R1ZGVudCBleHRyYSBmaWxlcywgYWxzbyB1cGRhdGUgdGhlIGRpcnR5IGZsYWdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNjcmVlbiAodGFrZXMgMSBzZWNvbmQpIHRvIG1ha2UgdGhlIEZlZWRiYWNrIGFyZWEgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgJChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMudGFnLm9mZnNldCgpLnRvcFxuICAgICAgICB9LCA3MDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmZWVkYmFjayBhcmVhIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGZWVkYmFja1Zpc2libGUoKSB7XG4gICAgICAgIGxldCB2aXNpYmlsaXR5QnVmZmVyID0gMTAwO1xuICAgICAgICBsZXQgdG9wT2ZFbGVtZW50ID0gdGhpcy50YWcub2Zmc2V0KCkudG9wO1xuICAgICAgICAvL2xldCBib3R0b21PZkVsZW1lbnQgPSB0aGlzLnRhZy5vZmZzZXQoKS50b3AgKyB0aGlzLnRhZy5vdXRlckhlaWdodCgpO1xuICAgICAgICBsZXQgYm90dG9tT2ZFbGVtZW50ID0gdG9wT2ZFbGVtZW50ICsgdmlzaWJpbGl0eUJ1ZmZlcjtcbiAgICAgICAgbGV0IGJvdHRvbU9mU2NyZWVuID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICAgICBsZXQgdG9wT2ZTY3JlZW4gPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgIC8vYm90dG9tX29mX2VsZW1lbnQgLT0gNDA7IC8vIFVzZXIgZnJpZW5kbHkgcGFkZGluZ1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHRvcE9mRWxlbWVudCA8IGJvdHRvbU9mU2NyZWVuKSAmJlxuICAgICAgICAgICAgKHRvcE9mU2NyZWVuIDwgYm90dG9tT2ZFbGVtZW50KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgb3V0cHV0IGN1cnJlbnRseSBpbiB0aGUgZmVlZGJhY2sgYXJlYS4gQWxzbyByZXNldHMgdGhlIHByaW50ZXIgYW5kXG4gICAgICogYW55IGhpZ2hsaWdodGVkIGxpbmVzIGluIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKFwiKlJlYWR5KlwiKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobnVsbCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5oaWRkZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmNsZWFyUG9zaXRpdmVGZWVkYmFjaygpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZmluZEZpcnN0RXJyb3JMaW5lKGZlZWRiYWNrRGF0YSkge1xuICAgICAgICBpZiAoZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cCkge1xuICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJsb2NhdGlvblwiKSk7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGxvY2F0aW9uLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGluZVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKmZvciAobGV0IGkgPSBmZWVkYmFja0RhdGEubGVuZ3RoLTE7IGkgPj0gMDsgaS09IDEpIHtcbiAgICAgICAgICAgIGlmIChcInBvc2l0aW9uXCIgaW4gZmVlZGJhY2tEYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlZWRiYWNrRGF0YVtpXS5wb3NpdGlvbi5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsOyovXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3VsYXJGZWVkYmFjaygpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG1vZGVsIHdpdGggdGhlc2UgbmV3IGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICogQHBhcmFtIGV4ZWN1dGlvblJlc3VsdHNcbiAgICAgKi9cbiAgICB1cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIC8vIFBhcnNlIG91dCBkYXRhXG4gICAgICAgIGxldCBtZXNzYWdlID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLk1FU1NBR0UpO1xuICAgICAgICBsZXQgY2F0ZWdvcnkgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuQ0FURUdPUlkpO1xuICAgICAgICBsZXQgbGFiZWwgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuTEFCRUwpO1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5ISURFKTtcbiAgICAgICAgbGV0IGRhdGEgPSBleGVjdXRpb25SZXN1bHRzLkRBVEE7XG4gICAgICAgIGxldCBwb3NpdGl2ZXMgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuUE9TSVRJVkUpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIGJhc2VkIG9uIGFzc2lnbm1lbnRzJyBzZXR0aW5nc1xuICAgICAgICBsZXQgaGlkZVNjb3JlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCk7XG4gICAgICAgIGlmIChoaWRlU2NvcmUgJiYgY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBjYXRlZ29yeSA9IFwibm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBsYWJlbCA9IFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJObyBlcnJvcnMgcmVwb3J0ZWQuXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1hcCB0byBleHBlY3RlZCBCbG9ja1B5IGxhYmVsc1xuICAgICAgICBpZiAoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnN0cnVjdG9yXCIgJiYgbGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gXCJleHBsYWluXCIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCJJbnN0cnVjdG9yIEZlZWRiYWNrXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBwcmVzZW50IGEgbGFjayBvZiBlcnJvciBhcyBiZWluZyBpbmNvcnJlY3RcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGFjY29yZGluZ2x5XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1haW4udXRpbGl0aWVzLm1hcmtkb3duKG1lc3NhZ2UpLnJlcGxhY2UoLzxwcmU+XFxuL2csIFwiPHByZT5cXG5cXG5cIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICAvL2xldCBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5maW5kKFwicHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vfSwgNDAwKTtcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0cmFja2luZyBzdHVkZW50IGZpbGUsIGxldCdzIHRyYWNrIHRoZSBpbnN0cnVjdG9yIGZpbGVcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiSW50ZXJ2ZW50aW9uXCIsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgXCJhbnN3ZXIucHlcIik7XG5cbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBwcmV2aW91c2x5IGhpZ2hsaWdodGVkIGxpbmVzXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciBvbiBhIGxpbmUgYW5kIHJlcG9ydCB0aGF0XG4gICAgICAgIGxldCBsaW5lID0gQmxvY2tQeUZlZWRiYWNrLmZpbmRGaXJzdEVycm9yTGluZShkYXRhKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lICE9PSBudWxsICYmIGxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmVydCB0aGUgc2V0IG9mIHRyYWNlZCBsaW5lc1xuICAgICAgICBsZXQgc3R1ZGVudFJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChzdHVkZW50UmVwb3J0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCB1bmNvdmVyZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnBhcnNlci5saW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWRlbnRSZXBvcnQubGluZXMuaW5kZXhPZihsaW5lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jb3ZlcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZCh1bmNvdmVyZWRMaW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9zaXRpdmVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aXZlRGF0YSA9IHBvc2l0aXZlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zaXRpdmVGZWVkYmFjayhwb3NpdGl2ZURhdGEubWVzc2FnZSwgXCJzdGFyXCIsIFwiZ3JlZW5cIiwgKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwocG9zaXRpdmVEYXRhLnRpdGxlLCBwb3NpdGl2ZURhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJQb3NpdGl2ZUZlZWRiYWNrKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgYWRkUG9zaXRpdmVGZWVkYmFjayh0ZXh0LCBpY29uLCBjb2xvciwgb25jbGljaywgdG9FbmQpIHtcbiAgICAgICAgbGV0IHBvc2l0aXZlID0gJChcIjxzcGFuPjwvc3Bhbj5cIik7XG4gICAgICAgIHBvc2l0aXZlLmFkZENsYXNzKFwiYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZS1pY29uIGZhcyBmYS1cIitpY29uKTtcbiAgICAgICAgcG9zaXRpdmUuY3NzKFwiY29sb3JcIiwgY29sb3IpO1xuICAgICAgICBwb3NpdGl2ZS5hdHRyKFwidGl0bGVcIiwgdGV4dCk7XG4gICAgICAgIGlmICh0b0VuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5hcHBlbmQocG9zaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5wcmVwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGl2ZS50b29sdGlwKHtcInRyaWdnZXJcIjogXCJob3ZlclwiLCBcImNvbnRhaW5lclwiOiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnR9KTtcbiAgICAgICAgaWYgKG9uY2xpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpdmUuY2xpY2sob25jbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUuaG92ZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GZWVkYmFja1wiLCBcInBvc2l0aXZlXCIsIFwiaG92ZXJcIiwgdGV4dCwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgYW55IGFjY3VtdWxhdGVkIGZlZWRiYWNrXG4gICAgICovXG4gICAgcHJlc2VudEZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKTtcblxuICAgICAgICAvLyBUT0RPOiBMb2dnaW5nXG4gICAgICAgIC8vdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiZmVlZGJhY2tcIiwgY2F0ZWdvcnkrXCJ8XCIrbGFiZWwsIG1lc3NhZ2UpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5RmVlZGJhY2tVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgbm90aWZ5RmVlZGJhY2tVcGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZlZWRiYWNrVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmxvYXRpbmctZmVlZGJhY2tcIikuc2hvdygpLmZhZGVPdXQoNzAwMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRTY3JvbGxJbnRvVmlldygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNob3VsZFNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubWFpbi5tb2RlbC51aS5zbWFsbExheW91dCgpO1xuICAgIH1cblxuICAgIHByZXNlbnRSdW5FcnJvcihlcnJvciwganVzdF9yZXR1cm4pIHtcbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGp1c3RfcmV0dXJuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UsIGxhYmVsLCBjYXRlZ29yeSwgbGluZW5vO1xuICAgICAgICBsYWJlbCA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGNhdGVnb3J5ID0gXCJydW50aW1lXCI7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvcik7XG5cbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCAmJiBsaW5lbm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZW5vKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWxkVHJhY2ViYWNrKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvci50cmFjZWJhY2subWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lbm8gPSBmcmFtZS5saW5lbm87XG4gICAgICAgICAgICBpZiAoZnJhbWUuZmlsZW5hbWUuc2xpY2UoMCwgLTMpID09PSBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgbGluZW5vIC09IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5pbnN0cnVjdG9yLmxpbmVPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlsZSA9IGBGaWxlIDxjb2RlIGNsYXNzPVwiZmlsZW5hbWVcIj5cIiR7ZnJhbWUuZmlsZW5hbWV9XCI8L2NvZGU+LCBgO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBgb24gbGluZSA8Y29kZSBjbGFzcz1cImxpbmVub1wiPiR7bGluZW5vfTwvY29kZT4sIGA7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSAoZnJhbWUuc2NvcGUgIT09IFwiPG1vZHVsZT5cIiAmJlxuICAgICAgICAgICAgZnJhbWUuc2NvcGUgIT09IHVuZGVmaW5lZCkgPyBgaW4gc2NvcGUgJHtmcmFtZS5zY29wZX1gIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGZyYW1lLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gYFxcbjxwcmU+PGNvZGU+JHtmcmFtZS5zb3VyY2V9PC9jb2RlPjwvcHJlPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZSArIGxpbmUgKyBzY29wZSArIHNvdXJjZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udmVydFNrdWxwdEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkLCBpc0luc3RydWN0b3IpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBlcnJvci50cCRuYW1lO1xuICAgICAgICBsZXQgYXJncyA9IFNrLmZmaS5yZW1hcFRvSnMoZXJyb3IuYXJncyk7XG4gICAgICAgIGxldCB0b3AgPSBgJHtuYW1lfTogJHthcmdzWzBdfVxcbjxicj5cXG48YnI+YDtcbiAgICAgICAgbGV0IHRyYWNlYmFjayA9IFwiXCI7XG4gICAgICAgIGlmIChuYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyICYmIGVycm9yLmVyci50cmFjZWJhY2sgJiYgZXJyb3IuZXJyLnRyYWNlYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxGcmFtZXMgPSB0aGlzLmJ1aWxkVHJhY2ViYWNrKGVycm9yLmVyciwgZmlsZW5hbWVFeGVjdXRlZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW1wiVHJhY2ViYWNrOlwiXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRnJhbWVzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsRnJhbWVzLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLi4uIEhpZGluZyAke2FsbEZyYW1lcy5sZW5ndGggLSAzfSBvdGhlciBzdGFjayBmcmFtZXMgLi4uLGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFsbEZyYW1lcy5zbGljZSgtMywgLTIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5hbGxGcmFtZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjZWJhY2sgPSByZXN1bHQuam9pbihcIlxcbjxicj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gXCJFcnJvciBpbiBpbnN0cnVjdG9yIGZlZWRiYWNrLiBQbGVhc2Ugc2hvdyB0aGUgZm9sbG93aW5nIHRvIGFuIGluc3RydWN0b3I6PGJyPlxcblwiK3RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci50cmFjZWJhY2sgJiYgZXJyb3IudHJhY2ViYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRyYWNlYmFjayA9IFwiVHJhY2ViYWNrOjxicj5cXG5cIiArIHRoaXMuYnVpbGRUcmFjZWJhY2soZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpLmpvaW4oXCJcXG48YnI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3ArXCJcXG5cIit0cmFjZWJhY2s7XG4gICAgfVxuXG4gICAgcHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoXCJydW50aW1lXCIpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbChcIlRpbWVvdXQgRXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KFwiaW50ZXJuYWxcIik7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKFwiSW50ZXJuYWwgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUZlZWRiYWNrVXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1TeXN0ZW0uRXJyb3JcIiwgXCJpbnRlcm5hbFwiLCBcIkludGVybmFsIEVycm9yXCIsIG1lc3NhZ2UsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQge2ZpcnN0RGVmaW5lZFZhbHVlfSBmcm9tIFwidXRpbGl0aWVzLmpzXCI7XG5cbi8vICR7bWFrZVRhYihcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIlVSTCBEYXRhXCIsIHRydWUpfVxuXG5jb25zdCBtYWtlVGFiID0gZnVuY3Rpb24oZmlsZW5hbWUsIGZyaWVuZGx5TmFtZSwgaGlkZUlmRW1wdHksIG5vdEluc3RydWN0b3IpIHtcbiAgICBpZiAoZnJpZW5kbHlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJpZW5kbHlOYW1lID0gZmlsZW5hbWU7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJcIjtcbiAgICBsZXQgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwidHJ1ZVwiO1xuICAgIGlmICghbm90SW5zdHJ1Y3Rvcikge1xuICAgICAgICBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiO1xuICAgICAgICBoaWRlSWZOb3RJbnN0cnVjdG9yID0gXCJkaXNwbGF5Lmluc3RydWN0b3IoKVwiO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtICR7aW5zdHJ1Y3RvckZpbGVDbGFzc31cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5maWxlbmFtZSgpID09PSAnJHtmaWxlbmFtZX0nfSxcbiAgICAgICAgICAgICAgICBjbGljazogZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCAnJHtmaWxlbmFtZX0nKSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAoISR7aGlkZUlmRW1wdHl9IHx8IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCcke2ZpbGVuYW1lfScpKSAmJiAke2hpZGVJZk5vdEluc3RydWN0b3J9XCI+XG4gICAgICAgICAgICAke2ZyaWVuZGx5TmFtZX08L2E+XG4gICAgPC9saT5gO1xufTtcblxuZXhwb3J0IGxldCBGSUxFU19IVE1MID0gYFxuPGRpdiBjbGFzcz1cImJsb2NrcHktcGFuZWwgYmxvY2tweS1maWxlc1wiXG4gICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZmlsZXMudmlzaWJsZSwgY2xhc3M6IHVpLmZpbGVzLndpZHRoXCI+XG48dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIiByb2xlPVwidGFibGlzdFwiPlxuXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgPHN0cm9uZz5WaWV3OiA8L3N0cm9uZz5cbiAgICA8L2xpPlxuXG4gICAgJHttYWtlVGFiKFwiYW5zd2VyLnB5XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiSW5zdHJ1Y3Rpb25zXCIpfVxuICAgICR7bWFrZVRhYihcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIiwgXCJTZXR0aW5nc1wiKX1cbiAgICAke21ha2VUYWIoXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIlN0YXJ0aW5nIENvZGVcIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX3J1bi5weVwiLCBcIk9uIFJ1blwiKX1cbiAgICAke21ha2VUYWIoXCIhb25fY2hhbmdlLnB5XCIsIFwiT24gQ2hhbmdlXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ldmFsLnB5XCIsIFwiT24gRXZhbFwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIiwgXCJTYW1wbGUgU3VibWlzc2lvbnNcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXRhZ3MuYmxvY2tweVwiLCBcIlRhZ3NcIiwgdHJ1ZSl9XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHsnYmxvY2tweS1maWxlLWluc3RydWN0b3InOiAhZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmaWxlbmFtZSgpLnN0YXJ0c1dpdGgoJyYnKSB8fCAkcm9vdC5kaXNwbGF5Lmluc3RydWN0b3IoKSBcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lZGl0YWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKClcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaWxlbmFtZVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBzdWJtaXNzaW9uLmV4dHJhRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJHJvb3QudWkuZmlsZXMuZGlzcGxheUZpbGVuYW1lKGZpbGVuYW1lKCkpXCI+XG4gICAgICAgICAgICA8L2E+ICAgICAgICBcbiAgICAgICAgPC9saT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gZHJvcGRvd25cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiBocmVmPVwiI1wiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgcm9sZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+QWRkIE5ldzwvYT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz9tb2NrX3VybHMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnP21vY2tfdXJscy5ibG9ja3B5JylcIj5VUkwgRGF0YTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/aW1hZ2VzLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz9pbWFnZXMuYmxvY2tweScpXCI+SW1hZ2VzPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz90b29sYm94LmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz90b29sYm94LmJsb2NrcHknKVwiPlRvb2xib3g8L2E+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchdGFncy5ibG9ja3B5JylcIj5UYWdzPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5JylcIj5TYW1wbGUgU3VibWlzc2lvbnM8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogYXNzaWdubWVudC5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9jaGFuZ2UucHknKVwiPk9uIENoYW5nZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25FdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIW9uX2V2YWwucHknKVwiPk9uIEV2YWw8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9wcmVmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfcHJlZml4LnB5JylcIj5BbnN3ZXIgUHJlZml4PC9hPlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9zdWZmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfc3VmZml4LnB5JylcIj5BbnN3ZXIgU3VmZml4PC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdzdGFydGluZycpXCI+U3RhcnRpbmcgRmlsZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdpbnN0cnVjdG9yJylcIj5JbnN0cnVjdG9yIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3R1ZGVudCcpXCI+U3R1ZGVudCBGaWxlPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICBcbjwvdWw+XG48L2Rpdj5cbmA7XG5cbmNvbnN0IE5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwgPSBgXG48Zm9ybT5cbjxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgIDwhLS0gRmlsZW5hbWUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiPkZpbGVuYW1lOjwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBGaWxldHlwZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIj5GaWxldHlwZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+PC9zcGFuPiAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIEluYWNjZXNzaWJsZSB0byBzdHVkZW50PyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+TmFtZXNwYWNlOiA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNFwiPlxuICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIVwiPkNvbXBsZXRlbHkgaW5hY2Nlc3NpYmxlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiP1wiPkhpZGRlbiBmcm9tIHN0dWRlbnQsIGFjY2Vzc2libGUgcHJvZ3JhbWF0aWNhbGx5PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJlwiPlZpc2libGUgdG8gc3R1ZGVudCwgYnV0IG5vdCBlZGl0YWJsZTwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPC9mb3JtPlxuYDtcblxuLyoqXG4gKiBGaWxlbmFtZXMgbGl2ZSBpbiBvbmUgb2YgZml2ZSBwb3NzaWJsZSBuYW1lc3BhY2VzOlxuICogIEluc3RydWN0b3IgKCEpOiBJbnZpc2libGUgdG8gdGhlIHN0dWRlbnQgdW5kZXIgYWxsIGNpcmN1bXN0YW5jZXNcbiAqICBTdGFydCBTcGFjZSAoXik6IFVzZWQgdG8gcmVzZXQgdGhlIHN0dWRlbnQgbmFtZXNwYWNlXG4gKiAgU3R1ZGVudCBTcGFjZSAoKTogVmlzaWJsZSB0byB0aGUgc3R1ZGVudCB3aGVuIGRpc3BsYXkuaGlkZUZpbGVzIGlzIG5vdCB0cnVlLCBhYmxlIHRvIGJlIGVkaXRlZFxuICogIEhpZGRlbiBTcGFjZSAoPyk6IE5vdCBkaXJlY3RseSB2aXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgYWNjZXNzaWJsZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiAgUmVhZC1vbmx5IFNwYWNlICgmKTogQW4gaW5zdHJ1Y3RvciBmaWxlIHR5cGUgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGlzIHVuZWRpdGFibGUgYnkgdGhlbVxuICogIFNlY3JldCBTcGFjZSAoJCk6IE5vdCB2aXNpYmxlIGZyb20gdGhlIG1lbnUgYXQgYWxsLCBzb21lIG90aGVyIG1lY2hhbmlzbSBjb250cm9scyBpdFxuICogIEdlbmVyYXRlZCBTcGFjZSAoKik6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBkZXN0cm95ZWQgYWZ0ZXIgRW5naW5lLkNsZWFyLiBDYW4gc2hhZG93IGFuIGFjdHVhbCBmaWxlLlxuICogIENvbmNhdGVuYXRlZCBTcGFjZSAoIyk6IFVzZWQgd2hlbiBidW5kbGluZyBhIHNwYWNlIGZvciB0aGUgc2VydmVyLlxuICovXG5cbmV4cG9ydCBsZXQgU1RBUlRJTkdfRklMRVMgPSBbXG4gICAgLy8gU3VibWlzc2lvblxuICAgIFwiYW5zd2VyLnB5XCIsXG4gICAgLy8gSW5zdHJ1Y3RvciBmaWxlc1xuICAgIFwiIWluc3RydWN0aW9ucy5tZFwiLFxuICAgIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIixcbiAgICBcIiFvbl9ydW4ucHlcIixcbiAgICBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQkFTSUNfTkVXX0ZJTEVTID0gW1xuICAgIFwiIW9uX2NoYW5nZS5weVwiLFxuICAgIFwiIW9uX2V2YWwucHlcIixcbiAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLFxuICAgIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgIFwiIXRhZ3MuYmxvY2tweVwiLFxuICAgIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsXG4gICAgXCIhYW5zd2VyX3ByZWZpeC5weVwiLFxuICAgIFwiIWFuc3dlcl9zdWZmaXgucHlcIlxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNob21wU3BlY2lhbEZpbGUoZmlsZW5hbWUpIHtcbiAgICBpZiAoXCIhXj8mJCojXCIuaW5jbHVkZXMoZmlsZW5hbWVbMF0pKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZS5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxufVxuXG5jb25zdCBJTlNUUlVDVE9SX0RJUkVDVE9SWSA9IFwiX2luc3RydWN0b3IvXCI7XG5jb25zdCBTVFVERU5UX0RJUkVDVE9SWSA9IFwiX3N0dWRlbnQvXCI7XG5cbmNvbnN0IFNlYXJjaE1vZGVzID0ge1xuICAgIEVWRVJZV0hFUkU6IFwiRVZFUllXSEVSRVwiLFxuICAgIFNUQVJUX1dJVEhfSU5TVFJVQ1RPUjogXCJTVEFSVF9XSVRIX0lOU1RSVUNUT1JcIixcbiAgICBPTkxZX1NUVURFTlRfRklMRVM6IFwiT05MWV9TVFVERU5UX0ZJTEVTXCJcbn07XG5cbmNvbnN0IERFTEVUQUJMRV9TSU1QTEVfRklMRVMgPSBbXCIhb25fY2hhbmdlLnB5XCIsIFwiIW9uX2V2YWwucHlcIl07XG5cbmV4cG9ydCBjb25zdCBVTkRFTEVUQUJMRV9GSUxFUyA9IFtcImFuc3dlci5weVwiLCBcIiFpbnN0cnVjdGlvbnMubWRcIiwgXCIhYXNzaWdubWVudF9zZXR0aW5ncy5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCIhb25fcnVuLnB5XCIsIFwiJHNldHRpbmdzLmJsb2NrcHlcIl07XG5cbmV4cG9ydCBjb25zdCBVTlJFTkFNQUJMRV9GSUxFUyA9IFtcImFuc3dlci5weVwiLCBcIiFpbnN0cnVjdGlvbnMubWRcIiwgXCIhYXNzaWdubWVudF9zZXR0aW5ncy5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCIhb25fcnVuLnB5XCIsIFwiJHNldHRpbmdzLmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFvbl9jaGFuZ2UucHlcIiwgXCIhb25fZXZhbC5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiP21vY2tfdXJscy5ibG9ja3B5XCIsIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIXRhZ3MuYmxvY2tweVwiLCBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIWFuc3dlcl9wcmVmaXgucHlcIiwgXCIhYW5zd2VyX3N1ZmZpeC5weVwiXTtcblxuY2xhc3MgQmxvY2tQeUZpbGUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cyB8fCBcIlwiO1xuICAgICAgICB0aGlzLm93bmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIHtcImZpbGVuYW1lXCI6IGtvLm9ic2VydmFibGUoZmlsZW5hbWUpLCBjb250ZW50czoga28ub2JzZXJ2YWJsZShjb250ZW50cyB8fCBcIlwiKX07XG59XG5cbmZ1bmN0aW9uIG1ha2VNb2NrTW9kZWxGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgIHJldHVybiB7IGZpbGVuYW1lOiAoKSA9PiBmaWxlbmFtZSwgY29udGVudHM6ICgpID0+IGNvbnRlbnRzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ29uY2F0ZW5hdGVkRmlsZShjb25jYXRlbmF0ZWRGaWxlLCBtb2RlbEZpbGVMaXN0KSB7XG4gICAgaWYgKGNvbmNhdGVuYXRlZEZpbGUpIHtcbiAgICAgICAgbGV0IGZpbGVzID0gSlNPTi5wYXJzZShjb25jYXRlbmF0ZWRGaWxlKTtcbiAgICAgICAgbGV0IG1vZGVsRmlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gZmlsZXMpIHtcbiAgICAgICAgICAgIGlmIChmaWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtb2RlbEZpbGVzLnB1c2gobWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgZmlsZXNbZmlsZW5hbWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9maWxlcyA9IGZpbGVzLm1hcChmaWxlID0+IG1ha2VNb2RlbEZpbGUoZmlsZS5maWxlbmFtZSwgZmlsZS5jb250ZW50cykpO1xuICAgICAgICBpZiAobW9kZWxGaWxlTGlzdCkge1xuICAgICAgICAgICAgbW9kZWxGaWxlTGlzdChtb2RlbEZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbEZpbGVzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsRmlsZUxpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsZUxpc3QoW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1vZGVsRmlsZUxpc3QoKS5tYXAoZmlsZSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5maWxlbmFtZSgpLFxuICAgICAgICAgICAgY29udGVudHM6IGZpbGUuY29udGVudHMoKVxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsRmlsZUxpc3QpIHtcbiAgICByZXR1cm4ga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBtb2RlbEZpbGVMaXN0KCkuZm9yRWFjaChmaWxlID0+XG4gICAgICAgICAgICByZXN1bHRbZmlsZS5maWxlbmFtZSgpXSA9IGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGRhdGFiYXNlIGxvZ2ljXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmlsZVN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVzXyA9IHt9O1xuICAgICAgICB0aGlzLm1vdW50RmlsZXMoKTtcblxuICAgICAgICB0aGlzLndhdGNoTW9kZWwoKTtcbiAgICAgICAgdGhpcy53YXRjaGVzXyA9IHt9O1xuXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKCh2aXNpYmxpdHkpPT4ge1xuICAgICAgICAgICAgJChcIi5ibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiKS50b2dnbGUodmlzaWJsaXR5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2F0Y2hGaWxlKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIShmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBzdG9wV2F0Y2hpbmdGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXTtcbiAgICB9XG5cbiAgICB3YXRjaE1vZGVsKCkge1xuICAgICAgICBsZXQgZmlsZXN5c3RlbSA9IHRoaXM7XG4gICAgICAgIFt0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzLFxuICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzLFxuICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXNdLmZvckVhY2goZmlsZUFycmF5ID0+XG4gICAgICAgICAgICBmaWxlQXJyYXkuc3Vic2NyaWJlKGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IHNlY29uZC5zdGF0dXMubG9jYWxlQ29tcGFyZShmaXJzdC5zdGF0dXMpKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWxGaWxlID0gY2hhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIG5ldyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBmaWxlc3lzdGVtLm5ld0ZpbGUobW9kZWxGaWxlLmZpbGVuYW1lKCksIG1vZGVsRmlsZS5jb250ZW50cygpLCBtb2RlbEZpbGUuY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzeXN0ZW0ubm90aWZ5V2F0Y2hlcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLnN0YXR1cyA9PT0gXCJkZWxldGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8obW9kZWxGaWxlLmZpbGVuYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlc3lzdGVtLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBtb2RlbEZpbGUuZmlsZW5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc3lzdGVtLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcywgXCJhcnJheUNoYW5nZVwiKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIGFuc3dlci5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGZpcnN0IGVsZW1lbnQgb2Ygc3VibWlzc2lvbi5jb2RlKVxuICAgIC8vICFvbl9ydW4ucHksICFvbl9jaGFuZ2UucHksICFvbl9ldmFsLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVsZXZhbnQgYXNzaWdubWVudC48d2hhdGV2ZXI+XG4gICAgLy8gXnN0YXJ0aW5nX2NvZGUucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBmaXJzdCBlbGVtZW50IG9mIGFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlXG4gICAgLy8gXndoYXRldmVyXG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVzdCBvZiB0aGUgZWxlbWVudHMgb2YgYXNzaWdubWVudC5zdGFydGluZ0NvZGVcbiAgICAvLyAhd2hhdGV2ZXIgb3IgP3doYXRldmVyXG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZWxlbWVudHMgb2YgYXNzaWdubWVudC5leHRyYUZpbGVzXG4gICAgLy8gT3RoZXJ3aXNlOlxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIG9mIHN1Ym1pc3Npb24uY29kZVxuICAgIC8qKlxuICAgICAqIE5ldyBzcGVjaWFsIGZpbGVzIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBoZXJlXG4gICAgICogQHBhcmFtIGZpbGUge0Jsb2NrUHlGaWxlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb2JzZXJ2ZUZpbGVfKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9ydW4ucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9jaGFuZ2UucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFvbl9ldmFsLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWluc3RydWN0aW9ucy5tZFwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIl5zdGFydGluZ19jb2RlLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIj90b29sYm94LmJsb2NrcHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWFuc3dlcl9wcmVmaXgucHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWFuc3dlcl9zdWZmaXgucHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIXRhZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnRhZ3M7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3M7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiRzZXR0aW5ncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiXlwiKSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIhXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiP1wiKSB8fFxuICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb2JzZXJ2ZUluQXJyYXlfKGZpbGUsIGFycmF5KSB7XG4gICAgICAgIGZpbGUub3duZXIgPSBhcnJheTtcbiAgICAgICAgbGV0IGNvZGVCdW5kbGUgPSBmaWxlLm93bmVyKCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNvZGVCdW5kbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlQnVuZGxlW2ldLmZpbGVuYW1lKCkgPT09IGZpbGUuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBmaWxlLmhhbmRsZSA9IGNvZGVCdW5kbGVbaV0uY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGUuaGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbmV3RmlsZSA9IG1ha2VNb2RlbEZpbGUoZmlsZS5maWxlbmFtZSk7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IG5ld0ZpbGUuY29udGVudHM7XG4gICAgICAgICAgICBhcnJheS5wdXNoKG5ld0ZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW91bnRGaWxlcygpIHtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCJec3RhcnRpbmdfY29kZS5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIW9uX3J1bi5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIWluc3RydWN0aW9ucy5tZFwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiKTtcbiAgICB9XG5cbiAgICBkaXNtb3VudEV4dHJhRmlsZXMoKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5maWxlc18pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmIChVTkRFTEVUQUJMRV9GSUxFUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndhdGNoZXNfW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdWJtaXNzaW9uLmNvZGVUT0RPOiBTaG91bGRuJ3Qgd2Ugbm90aWZ5IHRoZSBVSSB0aGF0IHRoZSBmaWxlIHdhcyBkZWxldGVkP1xuICAgIH1cblxuICAgIG5ld0ZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzLCBtb2RlbEZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIHRoaXMuZmlsZXNfKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzISBKdXN0IHVwZGF0ZSBpdHMgaGFuZGxlXG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdGaWxlID0gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICAgICAgaWYgKG1vZGVsRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlRmlsZV8oZXhpc3RpbmdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdGaWxlLmhhbmRsZSA9IG1vZGVsRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4aXN0aW5nRmlsZS5oYW5kbGUoY29udGVudHMgfHwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlsZSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgbGV0IG5ld0ZpbGUgPSBuZXcgQmxvY2tQeUZpbGUodGhpcy5tYWluLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVzX1tmaWxlbmFtZV0gPSBuZXdGaWxlO1xuICAgICAgICAgICAgaWYgKG1vZGVsRmlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlRmlsZV8obmV3RmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGUuaGFuZGxlID0gbW9kZWxGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlLmhhbmRsZShjb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RmlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgY29udGVudHMgPSBjb250ZW50cyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmZpbGVzX1tmaWxlbmFtZV0uaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICByZWFkRmlsZShmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlc19bZmlsZW5hbWVdLmhhbmRsZSgpO1xuICAgIH1cblxuICAgIGdldEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufG9iamVjdH0gVGhlIGluZm8gYWJvdXQgdGhlIGZpbGUsIG9yIGZhbHNlIGlmIGl0IGNvdWxkIG5vdCBiZSBkZWxldGVkXG4gICAgICovXG4gICAgZGVsZXRlRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoREVMRVRBQkxFX1NJTVBMRV9GSUxFUy5pbmRleE9mKGZpbGVuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaWxlID0gdGhpcy5kZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2sgdG8gZXZlbnR1YWxseSBjYWxsIGRlbGV0ZUZpbGVMb2NhbGx5X1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyLnJlbW92ZShtb2RlbEZpbGUgPT4gbW9kZWxGaWxlLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZUZpbGVMb2NhbGx5XyhmaWxlbmFtZSkge1xuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suZGVsZXRlZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG5cbiAgICByZW5hbWVGaWxlKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgaWYgKFVOUkVOQU1BQkxFX0ZJTEVTLmluZGV4T2Yoc291cmNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2sgdG8gZXZlbnR1YWxseSBjYWxsIGRlbGV0ZUZpbGVMb2NhbGx5X1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyLnJlbW92ZShtb2RlbEZpbGUgPT4gbW9kZWxGaWxlLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGlmeVdhdGNoZXMoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5maWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGUuZmlsZW5hbWVdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sudXBkYXRlZChmaWxlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWFyY2hGb3JGaWxlKG5hbWUsIHN0dWRlbnRTZWFyY2gpIHtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogVGhpcyBpcyBjYWxsZWQgcXVpdGUgYSBiaXQgYnkgdGhlIEltcG9ydCBtZWNoYW5pc20sIG1pZ2h0IG5lZWRcbiAgICAgICAgICAgICAgdG8gb3B0aW1pemUgaXQgc29tZSBtb3JlLiBEbyB0aW1pbmcgdGVzdHMuXG5cbiAgICAgICAgZmlsZXMuKlxuICAgICAgICBfaW5zdHJ1Y3Rvci9maWxlcy4qXG4gICAgICAgIF9zdHVkZW50L2ZpbGVzLipcblxuICAgICAgICBJZiBhIHN0dWRlbnQgc2VhcmNoZXMgZm9yIGEgZmlsZSwgaXQgY2hlY2tzIHRoZSBcIj9cIiwgXCImXCIsIFwiKlwiLCBcIlwiIG5hbWVzcGFjZXNcbiAgICAgICAgICAgIGltcG9ydCBoZWxwZXIgPT4gXCIuL2hlbHBlci5weVwiXG4gICAgICAgICAgICBvcGVuKFwiZXh0ZXJuYWwuanNvblwiKSA9PiBcImV4dGVybmFsLmpzb25cIlxuICAgICAgICBJZiBhbiBpbnN0cnVjdG9yIHNlYXJjaGVzIGZvciBhIGZpbGUsIGl0IGNoZWNrcyBcIiFcIiwgXCJeXCIsIFwiP1wiLCBcIiZcIiwgXCIqXCIsIFwiXCIgbmFtZXNwYWNlc1xuICAgICAgICAgICAgVG8gZXhwbGljaXRseSBzZWFyY2ggaW5zdHJ1Y3RvciBuYW1lc3BhY2VzIGZpcnN0XG4gICAgICAgICAgICAgICAgaW1wb3J0IF9pbnN0cnVjdG9yLmhlbHBlciA9PiBcIi4vaW5zdHJ1Y3Rvci9oZWxwZXIucHlcIlxuICAgICAgICAgICAgICAgIG9wZW4oXCJfaW5zdHJ1Y3Rvci9leHRlcm5hbC5qc29uXCIpID0+IFwiX2luc3RydWN0b3IvZXh0ZXJuYWwuanNvblwiXG4gICAgICAgICAgICB0byBhbGxvdyBzdHVkZW50IGZpbGVzIHRvIG92ZXJyaWRlOlxuICAgICAgICAgICAgICAgIGltcG9ydCBoZWxwZXIgPT4gXCIuL2hlbHBlci5weVwiXG4gICAgICAgICAgICAgICAgb3BlbihcImV4dGVybmFsLmpzb25cIikgPT4gXCJleHRlcm5hbC5qc29uXCJcbiAgICAgICAgICAgIHRvIG9ubHkgY2hlY2sgc3R1ZGVudCBmaWxlcywgcHJlcGVuZCB3aXRoIF9zdHVkZW50XG4gICAgICAgICAqL1xuICAgICAgICAvLyBDaG9wIG9mZiBzdGFydGluZyBcIi4vXCJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLkVWRVJZV0hFUkU7XG4gICAgICAgIC8vIFNob3VsZCB0aGUgc2VhcmNoIGJlIHN0YXJ0IHdpdGggaW5zdHJ1Y3RvciBzaWRlP1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKElOU1RSVUNUT1JfRElSRUNUT1JZKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoSU5TVFJVQ1RPUl9ESVJFQ1RPUlkubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5TVEFSVF9XSVRIX0lOU1RSVUNUT1I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvdWxkIHRoZSBzZWFyY2ggYmUgbGltaXRlZCB0byB0aGUgc3R1ZGVudCBtb2RlP1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFNUVURFTlRfRElSRUNUT1JZKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoU1RVREVOVF9ESVJFQ1RPUlkubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5PTkxZX1NUVURFTlRfRklMRVM7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R1ZGVudFNlYXJjaCkge1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUztcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgaW5zdHJ1Y3RvciB2ZXJzaW9uc1xuICAgICAgICBsZXQgZXh0cmFTdHVkZW50RmlsZXMgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKCk7XG4gICAgICAgIGxldCBleHRyYUluc3RydWN0b3JGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCk7XG4gICAgICAgIGxldCBleHRyYVN0YXJ0aW5nRmlsZXMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMoKTtcbiAgICAgICAgLy8gQ2hlY2sgc3BlY2lhbCBmaWxlcyAoVE9ETzogaG93IHdvdWxkIGFuIGluc3RydWN0b3IgYWNjZXNzIFwiLi9faW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIj9cbiAgICAgICAgbGV0IHNwZWNpYWxGaWxlID0gdGhpcy5zZWFyY2hGb3JTcGVjaWFsRmlsZXNfKG5hbWUsIHNlYXJjaE1vZGUpO1xuICAgICAgICBpZiAoc3BlY2lhbEZpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWNpYWxGaWxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IGxvb2tpbmcgdGhyb3VnaCBwb3NzaWJsZSBmaWxlc1xuICAgICAgICBsZXQgc3R1ZGVudFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3R1ZGVudEZpbGVzLCBuYW1lKTtcbiAgICAgICAgbGV0IGdlbmVyYXRlZFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3R1ZGVudEZpbGVzLCBcIipcIituYW1lKTtcbiAgICAgICAgbGV0IGRlZmF1bHRWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCImXCIrbmFtZSk7XG4gICAgICAgIGxldCBoaWRkZW5WZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCI/XCIrbmFtZSk7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5PTkxZX1NUVURFTlRfRklMRVMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShoaWRkZW5WZXJzaW9uLCBkZWZhdWx0VmVyc2lvbiwgc3R1ZGVudFZlcnNpb24sIGdlbmVyYXRlZFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnN0cnVjdG9yVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiIVwiK25hbWUpO1xuICAgICAgICBsZXQgc3RhcnRpbmdWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYVN0YXJ0aW5nRmlsZXMsIFwiXlwiK25hbWUpO1xuICAgICAgICBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuU1RBUlRfV0lUSF9JTlNUUlVDVE9SKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3REZWZpbmVkVmFsdWUoaW5zdHJ1Y3RvclZlcnNpb24sIGhpZGRlblZlcnNpb24sIHN0YXJ0aW5nVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmVyc2lvbiwgc3R1ZGVudFZlcnNpb24sIGdlbmVyYXRlZFZlcnNpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLkVWRVJZV0hFUkUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShkZWZhdWx0VmVyc2lvbiwgc3R1ZGVudFZlcnNpb24sIGdlbmVyYXRlZFZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3RvclZlcnNpb24sIGhpZGRlblZlcnNpb24sIHN0YXJ0aW5nVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWFyY2hGb3JGaWxlSW5MaXN0Xyhtb2RlbExpc3QsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG1vZGVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1vZGVsTGlzdFtpXS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZWFyY2hGb3JTcGVjaWFsRmlsZXNfKGZpbGVuYW1lLCBzZWFyY2hNb2RlKSB7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5PTkxZX1NUVURFTlRfRklMRVMpIHtcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL2Fuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW5zd2VyLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fcnVuLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fcnVuLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX2NoYW5nZS5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL29uX2NoYW5nZS5weVwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9ldmFsLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fZXZhbC5tZFwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSk7XG4gICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3Rpb25zLm1kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvaW5zdHJ1Y3Rpb25zLm1kXCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGFydGluZ19jb2RlLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivc3RhcnRpbmdfY29kZS5weVwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBuZXdGaWxlRGlhbG9nKGtpbmQpIHtcbiAgICAgICAgbGV0IGJvZHkgPSAkKE5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwpO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCIpO1xuICAgICAgICBsZXQgZmlsZXR5cGUgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCIpO1xuICAgICAgICBsZXQgbmFtZXNwYWNlID0gYm9keS5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIik7XG4gICAgICAgIGxldCBleHRlbnNpb25SZWdleCA9IC8oPzpcXC4oW14uXSspKT8kLztcbiAgICAgICAgZmlsZW5hbWUub24oXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uUmVnZXguZXhlYyhmaWxlbmFtZS52YWwoKSlbMV07XG4gICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24gPT09IHVuZGVmaW5lZCA/IFwiTm8gZXh0ZW5zaW9uXCIgOiBleHRlbnNpb247XG4gICAgICAgICAgICAvL1RPRE86IHRoaXMubWFpbi5jb21wb25lbnRzLmVkaXRvcnMuZ2V0RWRpdG9yRnJvbUV4dGVuc2lvbihleHRlbnNpb24pO1xuICAgICAgICAgICAgZmlsZXR5cGUudGV4dChleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHllcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiaW5zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gbmFtZXNwYWNlLnZhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSBcInN0YXJ0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIl5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbGVuYW1lLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBwcmVmaXgrZmlsZW5hbWUudmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdGaWxlKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYm9keS5zdWJtaXQoKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHllcygpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuY29uZmlybShcIk1ha2UgTmV3IEZpbGVcIiwgYm9keSwgeWVzLCAoKT0+e30sIFwiQWRkXCIpO1xuICAgIH1cbn0iLCIvL1RPRE86IE1vdmUgZ2V0IGxpbmsgZG93biB0byBmb290ZXIsIHJlbW92ZSB2ZXJ0aWNhbCBiYXIgZnJvbSBxdWljay1tZW51XG5leHBvcnQgbGV0IEZPT1RFUl9IVE1MID0gYFxuPGRpdiBjbGFzcz1cImNvbC1tZC0xMiBibG9ja3B5LXBhbmVsIGJsb2NrcHktc3RhdHVzXCI+XG4gICAgPGRpdj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZEFzc2lnbm1lbnQnKVwiPkxvYWQgQXNzaWdubWVudFxuICAgICAgICAgICAgPCEtLSBrbyBpZjogZGlzcGxheS5pbnN0cnVjdG9yIC0tPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiYmxvY2tweS1mb3JjZS1sb2FkLWFzc2lnbm1lbnQtZmlsZSBibG9ja3B5LWhpZGRlbi1maWxlXCJcbiAgICAgICAgICAgIGFjY2VwdD1cImFwcGxpY2F0aW9uL0pTT05cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLnNlcnZlci5mb3JjZS5sb2FkQXNzaWdubWVudH1cIj5cbiAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICA8L2xhYmVsPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnc2F2ZUFzc2lnbm1lbnQnKVwiPlNhdmUgQXNzaWdubWVudDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvYWRGaWxlJylcIj5Mb2FkIEZpbGU8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdzYXZlRmlsZScpXCI+U2F2ZSBGaWxlPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZERhdGFzZXQnKVwiPkxvYWQgRGF0YXNldDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvZ0V2ZW50JylcIj5Mb2cgRXZlbnQ8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCd1cGRhdGVTdWJtaXNzaW9uJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLnNlcnZlci5mb3JjZS51cGRhdGVTdWJtaXNzaW9uXCI+VXBkYXRlIFN1Ym1pc3Npb248L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdvbkV4ZWN1dGlvbicpXCI+RXhlY3V0aW9uPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXZcbiAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuc2VydmVyLm1lc3NhZ2VzXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXY+XG4gICAgICAgIDxzcGFuPlVzZXI6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIuaWRcIj48L3NwYW4+ICg8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLm5hbWVcIj48L3NwYW4+LCA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLnJvbGVcIj48L3NwYW4+KTwvc3Bhbj4sIFxuICAgICAgICA8c3Bhbj5Db3Vyc2U6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIuY291cnNlSWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+R3JvdXA6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIuZ3JvdXBJZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Bc3NpZ25tZW50OiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBhc3NpZ25tZW50LmlkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkFzc2lnbm1lbnQgVmVyc2lvbjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogYXNzaWdubWVudC52ZXJzaW9uXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPlN1Ym1pc3Npb246IFxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5pZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cImlmOiBzdWJtaXNzaW9uLm93bmVySWQoKSAhPSB1c2VyLmlkKClcIj5cbiAgICAgICAgICAgICAgICAoT3duZXIgSUQ6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24ub3duZXJJZCgpXCI+PC9zcGFuPilcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuPlN1Ym1pc3Npb24gVmVyc2lvbjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi52ZXJzaW9uXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkVkaXRvciBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBkaXNwbGF5LmVkaXRvclZlcnNpb25cIj48L3NwYW4+PC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gOyIsIi8vIFRPRE86IFNob3VsZCBkaXNhYmxlIGJ1dHRvbnMgaWYgd2UgY2FuJ3QgYWN0aXZhdGUgdGhlbS5cblxuZXhwb3J0IGNvbnN0IEhJU1RPUllfVE9PTEJBUl9IVE1MID0gYFxuPGRpdiBjbGFzcz1cImJsb2NrcHktaGlzdG9yeS10b29sYmFyIGNvbC1tZC0xMlwiIGRhdGEtYmluZD1cInZpc2libGU6IGRpc3BsYXkuaGlzdG9yeU1vZGVcIj5cblxuICAgIDxmb3JtIGNsYXNzPVwiZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJsb2NrcHktaGlzdG9yeS1zdGFydCBidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5LnN0YXJ0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtYmFja3dhcmQnPjwvc3Bhbj4gU3RhcnRcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5LnByZXZpb3VzXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWJhY2t3YXJkJz48L3NwYW4+IFByZXZpb3VzXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8c2VsZWN0IGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXNlbGVjdG9yIGZvcm0tY29udHJvbCBjdXN0b20tc2VsZWN0IG1yLTJcIiBhcmlhLXRpdGxlPVwiSGlzdG9yeSBTZWxlY3RvclwiPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkudXNlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZpbGUtaW1wb3J0Jz48L3NwYW4+IFVzZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkubmV4dFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1mb3J3YXJkJz48L3NwYW4+IE5leHRcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5tb3N0UmVjZW50XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtZm9yd2FyZCc+PC9zcGFuPiBNb3N0IFJlY2VudFxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Zvcm0+XG48L2Rpdj5cbmA7XG5cbi8qKlxuICogQW4gb2JqZWN0IGZvciBkaXNwbGF5aW5nIHRoZSB1c2VyJ3MgY29kaW5nIGxvZ3MgKHRoZWlyIGhpc3RvcnkpLlxuICogQSBsaWdodHdlaWdodCBjb21wb25lbnQsIGl0cyBvbmx5IGpvYiBpcyB0byBvcGVuIGEgZGlhbG9nLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlIaXN0b3J5fVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5SGlzdG9yeSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmN1cnJlbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRFdmVudHMgPSBbXTtcbiAgICB9XG5cbiAgICBsb2FkKGhpc3RvcnkpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgdGhpcy5lZGl0RXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSAkKFwiLmJsb2NrcHktaGlzdG9yeS1zZWxlY3RvclwiKS5lbXB0eSgpO1xuICAgICAgICBsZXQgZWRpdElkID0gMDtcbiAgICAgICAgaGlzdG9yeVxuICAgICAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IChcbiAgICAgICAgICAgICAgICAhZW50cnkuZmlsZV9wYXRoLnN0YXJ0c1dpdGgoXCJfaW5zdHJ1Y3Rvci5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJDb21waWxlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJJbnRlcnZlbnRpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpIHx8IGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiWC1TdWJtaXNzaW9uLkxNU1wiKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRfdHlwZSA9IFJFTUFQX0VWRU5UX1RZUEVTW2VudHJ5LmV2ZW50X3R5cGVdIHx8IGVudHJ5LmV2ZW50X3R5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXllZCA9IHByZXR0eVByaW50RGF0ZVRpbWUoZW50cnkuY2xpZW50X3RpbWVzdGFtcCkgK1wiIC0gXCIrZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWJsZSA9IChlbnRyeS5ldmVudF90eXBlICE9PSBcIkZpbGUuRWRpdFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uID0gJChcIjxvcHRpb24+PC9vcHRpb24+XCIsIHt0ZXh0OiBkaXNwbGF5ZWQsIGRpc2FibGVkOiBkaXNhYmxlfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFZGl0RXZlbnQoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5hdHRyKFwidmFsdWVcIiwgZWRpdElkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0RXZlbnRzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBlZGl0SWQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rvci5hcHBlbmQob3B0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbChNYXRoLm1heCgwLCBlZGl0SWQtMSkpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLmNoYW5nZSgoZXZ0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb3ZlVG9TdGFydCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoMCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZVByZXZpb3VzKCkge1xuICAgICAgICBsZXQgY3VycmVudElkID0gcGFyc2VJbnQodGhpcy5zZWxlY3Rvci52YWwoKSwgMTApO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbChNYXRoLm1heCgwLCBjdXJyZW50SWQtMSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIG1vdmVOZXh0KCkge1xuICAgICAgICBsZXQgY3VycmVudElkID0gcGFyc2VJbnQodGhpcy5zZWxlY3Rvci52YWwoKSwgMTApO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbChNYXRoLm1pbih0aGlzLmVkaXRFdmVudHMubGVuZ3RoLTEsIGN1cnJlbnRJZCsxKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZVRvTW9zdFJlY2VudCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwodGhpcy5lZGl0RXZlbnRzLmxlbmd0aC0xKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRFdmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudElkID0gcGFyc2VJbnQodGhpcy5zZWxlY3Rvci52YWwoKSwgMTApO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnNldENvZGUodGhpcy5lZGl0RXZlbnRzW2N1cnJlbnRJZF0ubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRFdmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudElkID0gcGFyc2VJbnQodGhpcy5zZWxlY3Rvci52YWwoKSwgMTApO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmVkaXRFdmVudHNbY3VycmVudElkXS5tZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmZpbGUuaGFuZGxlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFZGl0RXZlbnQoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICgoZW50cnkuZXZlbnRfdHlwZSA9PT0gXCJGaWxlLkVkaXRcIiB8fFxuICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlID09PSBcIkZpbGUuQ3JlYXRlXCIpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZW50cnkuZmlsZV9wYXRoKTtcbiAgICB9XG5cbn1cblxuY29uc3QgUkVNQVBfRVZFTlRfVFlQRVMgPSB7XG4gICAgXCJTZXNzaW9uLlN0YXJ0XCI6IFwiQmVnYW4gc2Vzc2lvblwiLFxuICAgIFwiWC1JUC5DaGFuZ2VcIjogXCJDaGFuZ2VkIElQIGFkZHJlc3NcIixcbiAgICBcIkZpbGUuRWRpdFwiOiBcIkVkaXRlZCBjb2RlXCIsXG4gICAgXCJGaWxlLkNyZWF0ZVwiOiBcIlN0YXJ0ZWQgYXNzaWdubWVudFwiLFxuICAgIFwiUnVuLlByb2dyYW1cIjogXCJSYW4gcHJvZ3JhbVwiLFxuICAgIFwiQ29tcGlsZS5FcnJvclwiOiBcIlN5bnRheCBlcnJvclwiLFxuICAgIFwiWC1TdWJtaXNzaW9uLkxNU1wiOiBcIlVwZGF0ZWQgZ3JhZGVcIlxufTtcblxuY29uc3QgbW9udGhOYW1lcyA9IFtcbiAgICBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLFxuICAgIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIixcbiAgICBcIkF1Z1wiLCBcIlNlcHRcIiwgXCJPY3RcIixcbiAgICBcIk5vdlwiLCBcIkRlY1wiXG5dO1xuY29uc3Qgd2Vla0RheXMgPSBbXG4gICAgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIixcbiAgICBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLFxuICAgIFwiU2F0XCJcbl07XG5cbmZ1bmN0aW9uIGlzU2FtZURheShmaXJzdCwgc2Vjb25kKSB7XG4gICAgcmV0dXJuIGZpcnN0LmdldERhdGUoKSA9PT0gc2Vjb25kLmdldERhdGUoKSAmJlxuICAgICAgICBmaXJzdC5nZXRNb250aCgpID09PSBzZWNvbmQuZ2V0TW9udGgoKSAmJlxuICAgICAgICBmaXJzdC5nZXRGdWxsWWVhcigpID09PSBzZWNvbmQuZ2V0RnVsbFllYXIoKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgYSBkYXRlL3RpbWUgc3RyaW5nIGFuZCByZXdyaXRlIGl0IGFzIHNvbWV0aGluZ1xuICogbW9yZSBodW1hbiByZWFkYWJsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0aW1lU3RyaW5nIC0gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIChcIllZWVlNTUREIEhITU1TU1wiKVxuICogQHJldHVybnMge1N0cmluZ30gLSBBIGh1bWFuLXJlYWRhYmxlIHRpbWUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBwcmV0dHlQcmludERhdGVUaW1lKHRpbWVTdHJpbmcpIHtcbiAgICAvKmxldCB5ZWFyID0gdGltZVN0cmluZy5zbGljZSgwLCA0KSxcbiAgICAgICAgbW9udGggPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKDQsIDYpLCAxMCktMSxcbiAgICAgICAgZGF5ID0gdGltZVN0cmluZy5zbGljZSg2LCA4KSxcbiAgICAgICAgaG91ciA9IHRpbWVTdHJpbmcuc2xpY2UoOSwgMTEpLFxuICAgICAgICBtaW51dGVzID0gdGltZVN0cmluZy5zbGljZSgxMSwgMTMpLFxuICAgICAgICBzZWNvbmRzID0gdGltZVN0cmluZy5zbGljZSgxMywgMTUpOyovXG4gICAgLy8gVE9ETzogSGFuZGxlIHRpbWV6b25lcyBjb3JyZWN0bHlcbiAgICBpZiAodGltZVN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBcIlVuZGVmaW5lZCBUaW1lXCI7XG4gICAgfVxuICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBwYXN0ID0gbmV3IERhdGUocGFyc2VJbnQodGltZVN0cmluZywgMTApKTtcbiAgICBpZiAoaXNTYW1lRGF5KG5vdywgcGFzdCkpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9kYXkgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGF5U3RyID0gd2Vla0RheXNbcGFzdC5nZXREYXkoKV07XG4gICAgICAgIGxldCBtb250aFN0ciA9IG1vbnRoTmFtZXNbcGFzdC5nZXRNb250aCgpXTtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXlTdHIgKyBcIiwgXCIgKyBtb250aFN0ciArIFwiIFwiICsgcGFzdC5nZXREYXRlKCk7XG4gICAgICAgIGlmIChub3cuZ2V0RnVsbFllYXIoKSA9PT0gcGFzdC5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZSArIFwiIGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZSArIFwiLCBcIitwYXN0LmdldEZ1bGxZZWFyKCkgKyBcIiBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogT3BlbnMgdGhlIGhpc3RvcnkgZGlhbG9nIGJveC4gVGhpcyByZXF1aXJlcyBhIHRyaXAgdG8gdGhlIHNlcnZlciBhbmRcbiAqIG9jY3VycyBhc3luY2hyb25vdXNseS4gVGhlIHVzZXJzJyBjb2RlIGlzIHNob3duIGluIHByZWZvcm1hdHRlZCB0ZXh0XG4gKiB0YWdzIChubyBjb2RlIGhpZ2hsaWdodGluZyBjdXJyZW50bHkpIGFsb25nIHdpdGggdGhlIHRpbWVzdGFtcC5cbiAqL1xuQmxvY2tQeUhpc3RvcnkucHJvdG90eXBlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlhbG9nID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nO1xuICAgIHZhciBib2R5ID0gXCI8cHJlPmEgPSAwPC9wcmU+XCI7XG4gICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmdldEhpc3RvcnkoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgYm9keSA9IGRhdGEucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoY29tcGxldGUsIGVsZW0pIHsgXG4gICAgICAgICAgICB2YXIgY29tcGxldGVfc3RyID0gcHJldHR5UHJpbnREYXRlVGltZShlbGVtLnRpbWUpO1xuICAgICAgICAgICAgdmFyIG5ld19saW5lID0gXCI8Yj5cIitjb21wbGV0ZV9zdHIrXCI8L2I+PGJyPjxwcmU+XCIrZWxlbS5jb2RlK1wiPC9wcmU+XCI7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGUrXCJcXG5cIituZXdfbGluZTtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGRpYWxvZy5zaG93KFwiV29yayBIaXN0b3J5XCIsIGJvZHksIGZ1bmN0aW9uKCkge30pO1xuICAgIH0pO1xufTsiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29udGFpbnMgbWFpbiBIVE1MIG9mIEJsb2NrUHkgaW50ZXJmYWNlLCBhbmQgaGVscGVyIGZ1bmN0aW9ucy5cbiAqIENvbWJpbmVzIGEgbG90IG9mIEhUTUwgZnJvbSBjb21wb25lbnRzLlxuICpcbiAqIEhlcmUncyB0aGUgbGF5b3V0OlxuICogIFJvdyAxOiBIZWFkZXIgYW5kIFF1aWNrIE1lbnVcbiAqICBSb3cgMjogQ29uc29sZSBhbmQgRmVlZGJhY2tcbiAqICBSb3cgMzogRmlsZSBOYXZpZ2F0aW9uXG4gKiAgUm93IDQ6IFZpZXcgUm93XG4gKiAgUm93IDU6IEZvb3RlciBSb3dcbiAqL1xuXG5pbXBvcnQge1RSQUNFX0hUTUx9IGZyb20gXCJ0cmFjZS5qc1wiO1xuaW1wb3J0IHtESUFMT0dfSFRNTH0gZnJvbSBcImRpYWxvZy5qc1wiO1xuaW1wb3J0IHtGRUVEQkFDS19IVE1MfSBmcm9tIFwiZmVlZGJhY2suanNcIjtcbmltcG9ydCB7RklMRVNfSFRNTH0gZnJvbSBcImZpbGVzLmpzXCI7XG5pbXBvcnQge0ZPT1RFUl9IVE1MfSBmcm9tIFwiZm9vdGVyLmpzXCI7XG5pbXBvcnQge0VESVRPUlNfSFRNTH0gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7Q09OU09MRV9IVE1MfSBmcm9tIFwiY29uc29sZS5qc1wiO1xuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgbGF5b3V0IG9wdGlvbnMgb2YgdGhlIHBhbmVzIGluIHRoZSBzZWNvbmQgcm93IG9mIHRoZSBsYXlvdXQuXG4gKiBAZW51bSB7U3RyaW5nfVxuICovXG5leHBvcnQgbGV0IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucyA9IHtcbiAgICBGRUVEQkFDSzogXCJmZWVkYmFja1wiLFxuICAgIFRSQUNFOiBcInRyYWNlXCIsXG4gICAgTk9ORTogXCJub25lXCJcbn07XG5cbi8qKlxuICogU2V0dXAgYW55IGFkZGl0aW9uYWwgS25vY2tvdXQgc3Vic2NyaXB0aW9ucyB0byBmaXJlIG9uIGludGVyZmFjZSBjaGFuZ2VzLlxuICogQHBhcmFtIHNlbGZcbiAqIEBwYXJhbSBtb2RlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyhzZWxmLCBtb2RlbCkge1xuICAgIC8vIEhpZ2hsaWdodCBNYXJrZG93biB3aGVuIGluc3RydWN0aW9ucyB1cGRhdGVcbiAgICBsZXQgaGlnaGxpZ2h0VGltZW91dCA9IG51bGw7XG4gICAgbW9kZWwudWkuaW5zdHJ1Y3Rpb25zLmN1cnJlbnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChoaWdobGlnaHRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rpb25zIHByZSBjb2RlXCIpLm1hcCggKGksIGJsb2NrKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LmhsanMuaGlnaGxpZ2h0QmxvY2soYmxvY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgfSk7XG4gICAgLy8gUHJvdmlkZSBGdWxsc2NyZWVuIHN1cHBvcnRcbiAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4uc3Vic2NyaWJlKChpc0Z1bGxzY3JlZW4pID0+IHtcbiAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLlJlcXVlc3RcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bGxzY3JlZW4udG9TdHJpbmcoKSwgXCJcIik7XG4gICAgICAgIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IG5hdmlnYXRpb25VSSBjb3VsZCBhbGxvdyB1cyB0byBmb3JjZSBjb250cm9scyB0byBzaG93XG4gICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5wYXJlbnQoKVswXS5yZXF1ZXN0RnVsbHNjcmVlbigpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgRXJyb3IgYXR0ZW1wdGluZyB0byBlbmFibGUgZnVsbC1zY3JlZW4gbW9kZTogJHtlcnIubWVzc2FnZX0gKCR7ZXJyLm5hbWV9KWA7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLkVycm9yXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLCAgXCJcIik7XG4gICAgICAgICAgICAgICAgYWxlcnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uU3VjY2Vzc1wiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKHRydWUpO1xuICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmNzcyhcIm92ZXJmbG93LXlcIiwgXCJhdXRvXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5FeGl0XCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Z1bGxzY3JlZW4udG9TdHJpbmcoKSwgXCJcIik7XG4gICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIFRPRE86IEdldCBzaGFyZWFibGUgbGluayBidXR0b25cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VJbnRlcmZhY2UobWFpbikge1xuICAgIHJldHVybiBgXG48ZGl2IGNsYXNzPSdibG9ja3B5LWNvbnRlbnQgY29udGFpbmVyLWZsdWlkJz5cblxuICAgIDwhLS0gRGlhbG9nIC0tPlxuICAgICR7RElBTE9HX0hUTUx9XG4gICAgXG4gICAgPCEtLSBIaWRkZW4gQ2FwdHVyZSBDYW52YXMgLS0+XG4gICAgPGNhbnZhcyBpZD0nY2FwdHVyZS1jYW52YXMnIGNsYXNzPSdkLW5vbmUnIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2NhbnZhcz5cbiAgICBcbiAgICA8IS0tIFJvdyAxOiBIZWFkZXIgYW5kIFF1aWNrIE1lbnUgLS0+XG4gICAgPGRpdiBjbGFzcz0ncm93JyBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNtYWxsTGF5b3V0KClcIj5cbiAgICAgICAgIFxuICAgICAgICAgPCEtLSBEZXNjcmlwdGlvbiAtLT5cbiAgICAgICAgIDxkaXYgY2xhc3M9J2NvbC1tZC05IGJsb2NrcHktcGFuZWwgYmxvY2tweS1oZWFkZXInXG4gICAgICAgICAgICAgICByb2xlPSdoZWFkaW5nJyBhcmlhLWxhYmVsPSdBc3NpZ25tZW50IERlc2NyaXB0aW9uJz5cbiAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBBc3NpZ25tZW50IE5hbWUgLS0+XG4gICAgICAgICAgICA8c3BhbiByb2xlPSdoZWFkaW5nJyBhcmlhLWxldmVsPScxJ1xuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LW5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPkJsb2NrUHk6IDwvc3Ryb25nPiBcbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGFzc2lnbm1lbnQubmFtZSc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIFJlc2V0IEluc3RydWN0aW9ucyBCdXR0b24gLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdGlvbnMtcmVzZXRcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmluc3RydWN0aW9ucy5pc0NoYW5nZWRcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImZsb2F0LXJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmluc3RydWN0aW9ucy5yZXNldFwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJcIj5cbiAgICAgICAgICAgICAgICAgICAgUmVzZXQgaW5zdHJ1Y3Rpb25zPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gSW5zdHJ1Y3Rpb25zIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1pbnN0cnVjdGlvbnMnXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImh0bWw6IHVpLmluc3RydWN0aW9ucy5jdXJyZW50XCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtMyBibG9ja3B5LXBhbmVsIGJsb2NrcHktcXVpY2stbWVudSdcbiAgICAgICAgICAgICByb2xlPSdtZW51YmFyJyBhcmlhLWxhYmVsPSdRdWljayBNZW51JyB0aXRsZT1cIlF1aWNrIE1lbnVcIj5cbiAgICAgICAgICAgIDwhLS0gR2V0IFNoYXJlYWJsZSBMaW5rIC0tPlxuICAgICAgICAgICAgPCEtLTxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiPlxuICAgICAgICAgICAgICAgIEdldCBzaGFyZWFibGUgbGluazwvYnV0dG9uPi0tPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidmlzaWJsZTogdWkubWVudS5pc1N1Ym1pdHRlZFwiPlxuICAgICAgICAgICAgICAgIFlvdXIgc3VibWlzc2lvbiBpcyByZWFkeSB0byBiZSByZXZpZXdlZCE8L3NwYW4+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLm1lbnUuY2FuTWFya1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVpLm1lbnUudGV4dE1hcmtTdWJtaXR0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkubWVudS5jbGlja01hcmtTdWJtaXR0ZWRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gVmlldyBhcyBpbnN0cnVjdG9yIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5yb2xlLmlzR3JhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiXCIgaWQ9XCJibG9ja3B5LWFzLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5Lmluc3RydWN0b3JcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIFZpZXcgYXMgaW5zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gUmVhZG9ubHkgbW9kZSBmb3Igc3B5aW5nIC0tPlxuICAgICAgICAgICAgPGRpdiBkYXRhLWJpbmQ9XCJpZjogc3VibWlzc2lvbi5vd25lcklkKCkgIT0gdXNlci5pZCgpXCI+XG4gICAgICAgICAgICAgICAgT3duZXI6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24ub3duZXJJZFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJibG9ja3B5LXJlYWQtb25seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5LnJlYWRPbmx5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlYWQtb25seVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZG9ubHk/XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIEZ1bGxzY3JlZW4gYnV0dG9uIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS5jbGlja0Z1bGxzY3JlZW5cIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiRnVsbCBTY3JlZW5cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzJyBkYXRhLWJpbmQ9XCJjbGFzczogdWkubWVudS50ZXh0RnVsbHNjcmVlblwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBFZGl0IFF1ZXVlZCBJbnB1dHMgLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LmVkaXRJbnB1dHMsIHZpc2libGU6IHVpLm1lbnUuc2hvd1F1ZXVlZElucHV0c1wiIHRpdGxlPVwiRWRpdCBJbnB1dHNcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWxpc3QtYWx0Jz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gVG9nZ2xlIEltYWdlIFJlbmRlcmluZyAtLT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LnRvZ2dsZUltYWdlc1wiIHRpdGxlPVwiVG9nZ2xlIEltYWdlc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWltYWdlc1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBQaW5rIEJ1ZyBmb3IgYWN0dWFsIGVycm9ycyAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2tweS1zdHVkZW50LWVycm9yIGZhcyBmYS1idWdcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLm1lbnUuc2hvd0Nsb2NrXCIgY2xhc3M9XCJibG9ja3B5LW1lbnUtY2xvY2tcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgPC9kaXY+XG4gICAgXG4gICAgPCEtLSBrbyBpZjogdWkuc21hbGxMYXlvdXQoKSAtLT5cbiAgICA8IS0tIFNtYWxsIGxheW91dCBWaWV3IGFzIGluc3RydWN0b3IgLS0+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIlxuICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkucm9sZS5pc0dyYWRlclwiPlxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJcIiBpZD1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBkaXNwbGF5Lmluc3RydWN0b3JcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgVmlldyBhcyBpbnN0cnVjdG9yXG4gICAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSgpIC0tPlxuICAgICR7RklMRVNfSFRNTH1cbiAgICA8IS0tIC9rbyAtLT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgIDwhLS0gUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrIC0tPlxuICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc0FsbFZpc2libGUgLS0+XG4gICAgPGRpdiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2Vjb25kUm93LndpZHRoXCI+XG4gICAgPGRpdiBjbGFzcz0ncm93Jz5cbiAgICAgICAgPCEtLSBDb25zb2xlIC0tPlxuICAgICAgICAke0NPTlNPTEVfSFRNTH1cbiAgICAgICAgPCEtLSBGZWVkYmFjayAtLT5cbiAgICAgICAgPCEtLSBrbyBpZjogdWkuc2Vjb25kUm93LmlzRmVlZGJhY2tWaXNpYmxlIC0tPlxuICAgICAgICAke0ZFRURCQUNLX0hUTUx9XG4gICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICA8IS0tIFRyYWNlIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUgLS0+XG4gICAgICAgICR7VFJBQ0VfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgMzogRmlsZSBOYXZpZ2F0aW9uIC0tPlxuICAgIDwhLS0ga28gaWY6IHVpLmZpbGVzLnZpc2libGUoKSAmJiAhdWkuc21hbGxMYXlvdXQoKSAtLT5cbiAgICAke0ZJTEVTX0hUTUx9XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgNDogVmlldyBSb3cgLS0+XG4gICAgJHtFRElUT1JTX0hUTUx9XG4gICAgXG4gICAgPC9kaXY+XG4gICAgXG4gICAgXG4gICAgPCEtLSBSb3cgNTogRm9vdGVyIFJvdyAtLT4gICAgXG4gICAgPCEtLSBrbyBpZjogdWkuZm9vdGVyLnZpc2libGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAke0ZPT1RFUl9IVE1MfVxuICAgIDwvZGl2PlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuPC9kaXY+XG4gICAgYDtcbn0iLCJpbXBvcnQge0xvY2FsU3RvcmFnZVdyYXBwZXJ9IGZyb20gXCIuL3N0b3JhZ2VcIjtcbmltcG9ydCB7bG9hZEFzc2lnbm1lbnRTZXR0aW5ncywgc2F2ZUFzc2lnbm1lbnRTZXR0aW5nc30gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcblxuLyoqXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBTdGF0dXNTdGF0ZSA9IHtcbiAgICBSRUFEWTogXCJyZWFkeVwiLFxuICAgIEFDVElWRTogXCJhY3RpdmVcIixcbiAgICBSRVRSWUlORzogXCJyZXRyeWluZ1wiLFxuICAgIEZBSUxFRDogXCJmYWlsZWRcIixcbiAgICBPRkZMSU5FOiBcIm9mZmxpbmVcIlxufTtcblxuLyoqXG4gKiBPYmplY3QgZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgZXh0ZXJuYWwgc2VydmVycy4gVGhpcyBpbmNsdWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuICogc2F2aW5nIGFuZCBsb2FkaW5nIGZpbGVzLCBsb2dnaW5nIGV2ZW50cywgc2F2aW5nIGNvbXBsZXRpb25zLCBhbmQgcmV0cmlldmluZyBoaXN0b3J5LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlTZXJ2ZXJ9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlTZXJ2ZXIobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICAvLyBTYXZlIFVSTHMgbG9jYWxseSBmb3IgcXVpY2tlciBhY2Nlc3NcbiAgICB0aGlzLnVybHMgPSBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscztcblxuICAgIC8vIEFkZCB0aGUgTG9jYWxTdG9yYWdlIGNvbm5lY3Rpb25cbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcIkJMT0NLUFlcIik7XG5cbiAgICAvLyBGYXVsdFJlc2lzdGFudENhY2hlXG4gICAgdGhpcy5xdWV1ZSA9IHtcbiAgICAgICAgXCJsb2dFdmVudFwiOiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXREZWZhdWx0KFwibG9nRXZlbnRcIiwgXCJbXVwiKSksXG4gICAgICAgIFwidXBkYXRlU3VibWlzc2lvblwiOiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXREZWZhdWx0KFwidXBkYXRlU3VibWlzc2lvblwiLCBcIltdXCIpKVxuICAgIH07XG4gICAgdGhpcy5NQVhfUVVFVUVfU0laRSA9IHtcbiAgICAgICAgXCJsb2dFdmVudFwiOiAyMDAsXG4gICAgICAgIFwidXBkYXRlU3VibWlzc2lvblwiOiA1MFxuICAgIH07XG5cbiAgICB0aGlzLlRJTUVSX0RFTEFZID0gMTAwMDtcbiAgICB0aGlzLkZBSUxfREVMQVkgPSAyMDAwO1xuXG4gICAgdGhpcy50aW1lcnMgPSB7fTtcblxuICAgIHRoaXMub3ZlcmxheSA9IG51bGw7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzID0gMDtcblxuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzID0gW107XG4gICAgdGhpcy5jcmVhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgdGhpcy5jaGVja0NhY2hlcygpO1xuXG4gICAgdGhpcy5hbHRMb2dFbnRyeSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIElQIGFkZHJlc3MgaGFzIGNoYW5nZWQsIGxvZ2dpbmcgYW4gZXZlbnQgaWYgdGhhdCBvY2N1cnMuXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY2hlY2tJUCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwiSVBcIikpIHtcbiAgICAgICAgICAgIGxldCBvbGRJUCA9IHRoaXMuc3RvcmFnZS5nZXQoXCJJUFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRJUCAhPT0gcmVzcG9uc2UuaXApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgXCJvbGRcIjogb2xkSVAsXG4gICAgICAgICAgICAgICAgICAgIFwibmV3XCI6IHJlc3BvbnNlLmlwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWx0TG9nRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHRMb2dFbnRyeShcIlgtSVAuQ2hhbmdlXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiWC1JUC5DaGFuZ2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFwiSVBcIiwgcmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChcIklQXCIsIHJlc3BvbnNlLmlwKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGVyZSBoYXZlIGJlZW4gcHJldmlvdXMgZmFpbHVyZXMgY2FjaGVkLCBhbmQgaWYgc28gcmV0cmllcyB0aGVtLlxuICogVE9ETzogdXBkYXRlXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNoZWNrQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwic2F2ZUFzc2lnbm1lbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXQoXCJzYXZlQXNzaWdubWVudFwiKSk7XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcImFzc2lnbm1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2F2ZUFzc2lnbm1lbnRcIiwgdGhpcy5USU1FUl9ERUxBWSk7XG4gICAgfVxuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzLmZvckVhY2goKGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwic2F2ZUZpbGVcIiArIGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXQoXCJzYXZlRmlsZVwiICsgZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBmaWxlbmFtZSwgXCJzYXZlRmlsZVwiLCB0aGlzLlRJTUVSX0RFTEFZKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucXVldWUpLmZvckVhY2goZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgIChmdW5jdGlvbiBwdXNoQW55UXVldWVkKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXIucXVldWVbZW5kcG9pbnRdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uoc2VydmVyLnF1ZXVlW2VuZHBvaW50XS5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzZXJ2ZXIudXJsc1tlbmRwb2ludF07XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5fcG9zdFJldHJ5KGRhdGEsIGVuZHBvaW50LCAxMDAwLCBwdXNoQW55UXVldWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKHtcInN1Y2Nlc3NcIjogdHJ1ZX0pO1xuICAgIH0pO1xufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtb2RlbCwgZmlsZW5hbWUpIHtcbiAgICBtb2RlbC5zdWJzY3JpYmUoKGNvbnRlbnRzKSA9PlxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5hdXRvU2F2ZSgpID8gdGhpcy5zYXZlRmlsZShmaWxlbmFtZSwgY29udGVudHMpIDogZmFsc2UsIHRoaXMpO1xuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzLnB1c2goZmlsZW5hbWUpO1xufTtcblxuLyoqXG4gKiBUT0RPOiBmaXhcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnN1Ym1pc3Npb24uY29kZSwgXCJhbnN3ZXIucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25SdW4sIFwiIW9uX3J1bi5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vbkV2YWwsIFwiIW9uX2V2YWwucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UsIFwiIW9uX2NoYW5nZS5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMsIFwiIWluc3RydWN0aW9ucy5tZFwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUsIFwiXnN0YXJ0aW5nX2NvZGUucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhU3R1ZGVudEZpbGVzLCBcIiNleHRyYV9zdHVkZW50X2ZpbGVzLmJsb2NrcHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhU3RhcnRpbmdGaWxlcywgXCIjZXh0cmFfc3RhcnRpbmdfZmlsZXMuYmxvY2tweVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiI2V4dHJhX2luc3RydWN0b3JfZmlsZXMuYmxvY2tweVwiKTtcbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50TG9ncyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5vbmJsdXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJTZXNzaW9uLkVuZFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHdpbmRvdy5vbmZvY3VzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiU2Vzc2lvbi5TdGFydFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogQWRkIGluIGJlYWNvbj9cbn07XG5cbi8qKlxuICpcbiAqIFNvbWUgc3Vic2NyaXB0aW9ucyBoYXZlIHRvIGhhcHBlbiBhZnRlciBvdGhlciB0aGluZ3MgaGF2ZSBiZWVuIGxvYWRlZC5cbiAqIFJpZ2h0IG5vdyB0aGlzIGlzIGp1c3QgYWZ0ZXIgQ09SR0lTIGxpYnJhcmllcyBoYXZlIGJlZW4gbG9hZGVkLCBidXQgbWF5YmVcbiAqIHdlJ2xsIGFkZCBtb3JlIGxhdGVyIGFuZCB0aGlzIHdpbGwgbmVlZCB0byBiZSByZWZhY3RvcmVkLlxuICpcbiAqIFRPRE86IGZpeFxuICpcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuZmluYWxpemVTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGF0YXNldHMuc3Vic2NyaWJlKHRoaXMuc2F2ZUFzc2lnbm1lbnQuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGRlZmF1bHQgcGF5bG9hZCBmb3IgYW55IGNvbW11bmljYXRpb24gd2l0aCB0aGUgc2VydmVyIEFQSVxuICogQHJldHVybnMge3thc3NpZ25tZW50X2lkOiAqLCBjb3Vyc2VfaWQ6ICosIGdyb3VwX2lkOiAqLCB1c2VyX2lkOiAqLCB0aW1lem9uZTogKiwgdmVyc2lvbjogKiwgdGltZXN0YW1wOiAqfX1cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlU2VydmVyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgYXNzaWdubWVudCA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50O1xuICAgIGxldCB1c2VyID0gdGhpcy5tYWluLm1vZGVsLnVzZXI7XG4gICAgbGV0IHN1Ym1pc3Npb24gPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbjtcbiAgICBsZXQgZGlzcGxheSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5O1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbjtcbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgbWljcm9zZWNvbmRzID0gbm93LmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBcImFzc2lnbm1lbnRfaWRcIjogYXNzaWdubWVudC5pZCgpLFxuICAgICAgICBcImFzc2lnbm1lbnRfZ3JvdXBfaWRcIjogdXNlci5ncm91cElkKCksXG4gICAgICAgIFwiY291cnNlX2lkXCI6IHVzZXIuY291cnNlSWQoKSxcbiAgICAgICAgXCJzdWJtaXNzaW9uX2lkXCI6IHN1Ym1pc3Npb24uaWQoKSxcbiAgICAgICAgXCJ1c2VyX2lkXCI6IHVzZXIuaWQoKSxcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IGFzc2lnbm1lbnQudmVyc2lvbigpLFxuICAgICAgICBcInRpbWVzdGFtcFwiOiBtaWNyb3NlY29uZHMsXG4gICAgICAgIFwidGltZXpvbmVcIjogbm93LmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgIFwicGFzc2NvZGVcIjogZGlzcGxheS5wYXNzY29kZSgpLFxuICAgICAgICBcInBhcnRfaWRcIjogY29uZmlndXJhdGlvbi5wYXJ0SWQoKVxuICAgIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBhbmQgbWVzc2FnZSBmb3IgdGhlIHJlbGV2YW50IGVuZHBvaW50LlxuICogQHBhcmFtIGVuZHBvaW50IHtzdHJpbmd9IG9uZSBvZiB0aGUgVVJMIGVuZHBvaW50c1xuICogQHBhcmFtIHN0YXR1cyB7U3RhdHVzU3RhdGV9XG4gKiBAcGFyYW0gbWVzc2FnZSB7c3RyaW5nP31cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24gKGVuZHBvaW50LCBzdGF0dXMsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzW2VuZHBvaW50XShzdGF0dXMpO1xuICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXNbZW5kcG9pbnQgKyBcIk1lc3NhZ2VcIl0obWVzc2FnZSB8fCBcIlwiKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyBhbiBvdmVybGF5IG9uIHRoZSBzY3JlZW4gdGhhdCBibG9ja3Mgb3BlcmF0aW9uIHVudGlsIHRoZSBzeXN0ZW0gaXMgcmVhZHkuXG4gKiBUaGUgb3ZlcmxheSBnZXRzIHByb2dyZXNzaXZlbHkgZGFya2VyIHRvIGluZGljYXRlIHJlcGVhdGVkIGZhaWx1cmVzLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zaG93T3ZlcmxheSA9IGZ1bmN0aW9uIChhdHRlbXB0KSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzICs9IDE7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYmxvY2tweS1vdmVybGF5XCIpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSAkKCc8ZGl2IGNsYXNzPVwiYmxvY2tweS1vdmVybGF5XCI+IDwvZGl2PicpO1xuICAgICAgICB0aGlzLm92ZXJsYXkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXR0ZW1wdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM5ODhcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjNjU1XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzMzM1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJibGFja1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5kbyBhIGxldmVsIG9mIG92ZXJsYXk7IGlmIHRoaXMgd2FzIHRoZSBsYXN0IGxldmVsLCByZW1vdmVzIGl0IGZyb20gdGhlIHNjcmVlbi5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuaGlkZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzIC09IDE7XG4gICAgaWYgKHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZW5xdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBub3Qgb3ZlcmZpbGxlZCB0aGUgcXVldWVcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5xdWV1ZVtjYWNoZV0ubGVuZ3RoO1xuICAgIGxldCBtYXggPSB0aGlzLk1BWF9RVUVVRV9TSVpFW2NhY2hlXTtcbiAgICBpZiAobGVuZ3RoID4gbWF4KSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdID0gdGhpcy5xdWV1ZVtjYWNoZV0uc2xpY2UobGVuZ3RoIC0gbWF4LCBtYXgpO1xuICAgIH1cbiAgICAvLyBPbmx5IGFkZCB0aGUgZWxlbWVudCBpZiBpdCdzIG5ld1xuICAgIGxldCBrZXkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnF1ZXVlW2NhY2hlXS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX2RlcXVldWVEYXRhID0gZnVuY3Rpb24gKGNhY2hlLCBkYXRhKSB7XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5zcGxpY2UoaW5kZXgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGNhY2hlLCBKU09OLnN0cmluZ2lmeSh0aGlzLnF1ZXVlW2NhY2hlXSkpO1xuICAgIH1cbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RSZXRyeSA9IGZ1bmN0aW9uIChkYXRhLCBlbmRwb2ludCwgZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgbGV0IHBvc3RSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIGEgYmFja3VwIG9mIHRoZSBjdXJyZW50IHBvc3RcbiAgICAgICAgdGhpcy5fZW5xdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAkLnBvc3QodGhpcy51cmxzW2VuZHBvaW50XSwgZGF0YSlcbiAgICAgICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcXVldWVEYXRhKGVuZHBvaW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0lQKHJlc3BvbnNlLmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIHRoZW4gbGV0J3MgdHJ5IGl0IGFnYWluIGluIGEgYml0XG4gICAgICAgICAgICAuZmFpbCgoZXJyb3IsIHRleHRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIGVuZHBvaW50LCBkZWxheSArIHRoaXMuRkFJTF9ERUxBWSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgcG9zdFJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHBvc3RSZXF1ZXN0LCBkZWxheSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIGEgQUpBWCByZXF1ZXN0IHRoYXQsIHVwb24gZmFpbHVyZSwgd2lsbCBjaGVjayB0byBzZWUgaWYgdGhpcyB3YXMgdGhlXG4gKiBsYXRlc3QgYXR0ZW1wdCBmb3IgdGhpcyBgY2FjaGVgIG1hcmtlci4gSWYgc28sIGl0IHdpbGwgYXR0ZW1wdCBhZ2FpbiB1bnRpbFxuICogc3VjY2Vzc2Z1bDsgb3RoZXJ3aXNlLCBpdCBnaXZlcyB1cCB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBBSkFYLXJlYWR5IGRhdGEgdG8gYmUgcG9zdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBUaGUgdW5pcXVlIG5hbWUgZ2l2ZW4gdG8gdGhlIHJlbGV2YW50IHRpbWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcG9pbnQgLSBUaGUgdW5pcXVlIG5hbWUgZ2l2ZW4gdG8gdGhlIHJlbGV2YW50IGNhY2hlIGVudHJ5XG4gKiBAcGFyYW0ge0ludGVnZXJ9IGRlbGF5IC0gVGhlIGN1cnJlbnQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuIHRyeWluZyB0aGUgcmVxdWVzdCBhZ2Fpbi5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RMYXRlc3RSZXRyeSA9IGZ1bmN0aW9uIChkYXRhLCBmaWxlbmFtZSwgZW5kcG9pbnQsIGRlbGF5LCBmYWlsdXJlRnVuY3Rpb24sIGRvbmVGdW5jdGlvbikge1xuICAgIGxldCBjYWNoZSA9IGVuZHBvaW50ICsgZmlsZW5hbWU7XG4gICAgbGV0IHJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgcG9zdFxuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGNhY2hlLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGxldCB0aW1lID0gdGhpcy5zdG9yYWdlLmdldFRpbWUoY2FjaGUpO1xuICAgICAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICQucG9zdCh0aGlzLnVybHNbZW5kcG9pbnRdLCBkYXRhKVxuICAgICAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0lQKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIGNsZWFyIGl0IGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWNoZWRUaW1lID0gdGhpcy5zdG9yYWdlLmdldFRpbWUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY29ubmVjdGVkIGJ1dCBmYWlsZWQsIGRvbid0IHRyeSBhZ2FpbiBidXQgbGV0IHRoZSB1c2VyIGtub3cgd2h5LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSB0aGUgbGF0ZXN0IG9uZSwgY2xlYXIgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWNoZWRUaW1lID0gdGhpcy5zdG9yYWdlLmdldFRpbWUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWx1cmVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVGdW5jdGlvbihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZhaWwoKGVycm9yLCB0ZXh0U3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFVFJZSU5HLCB0ZXh0U3RhdHVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIC8vIElmIHNlcnZlciByZXF1ZXN0IGlzIHRoZSBsYXRlc3Qgb25lLCB0aGVuIGxldCdzIHRyeSBpdCBhZ2FpbiBpbiBhIGJpdFxuICAgICAgICAgICAgICAgIGxldCBjYWNoZWRUaW1lID0gdGhpcy5zdG9yYWdlLmdldFRpbWUoY2FjaGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXkgKyB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShkb25lRnVuY3Rpb24pO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW2NhY2hlXSk7XG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lcnNbY2FjaGVdID0gc2V0VGltZW91dChyZXF1ZXN0LCBkZWxheSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RCbG9ja2luZyA9IGZ1bmN0aW9uIChlbmRwb2ludCwgZGF0YSwgYXR0ZW1wdHMsIHN1Y2Nlc3MsIGZhaWx1cmUsIGV4dHJhU2V0dGluZ3M9e30pIHtcbiAgICB0aGlzLnNob3dPdmVybGF5KGF0dGVtcHRzKTtcbiAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgIHVybDogdGhpcy51cmxzW2VuZHBvaW50XSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgLi4uZXh0cmFTZXR0aW5nc1xuICAgIH0pXG4gICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0lQKHJlc3BvbnNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZhaWwoKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuRkFJTEVELCB0ZXh0U3RhdHVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmUoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFVFJZSU5HLCB0ZXh0U3RhdHVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoZW5kcG9pbnQsIGRhdGEsIGF0dGVtcHRzIC0gMSwgc3VjY2VzcywgZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5GQUlMX0RFTEFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuXG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvYWRBc3NpZ25tZW50ID0gZnVuY3Rpb24gKGFzc2lnbm1lbnRfaWQpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEFzc2lnbm1lbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImFzc2lnbm1lbnRfaWRcIl0gPSBhc3NpZ25tZW50X2lkO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkQXNzaWdubWVudFwiLCBkYXRhLCA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmxvYWRBc3NpZ25tZW50RGF0YV8ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQocmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zYXZlQXNzaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwic2F2ZUFzc2lnbm1lbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImhpZGRlblwiXSA9IG1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCk7XG4gICAgICAgIGRhdGFbXCJyZXZpZXdlZFwiXSA9IG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKTtcbiAgICAgICAgZGF0YVtcInB1YmxpY1wiXSA9IG1vZGVsLmFzc2lnbm1lbnQucHVibGljKCk7XG4gICAgICAgIGRhdGFbXCJ1cmxcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnVybCgpO1xuICAgICAgICBkYXRhW1wicG9pbnRzXCJdID0gbW9kZWwuYXNzaWdubWVudC5wb2ludHMoKTtcbiAgICAgICAgZGF0YVtcImlwX3Jhbmdlc1wiXSA9IG1vZGVsLmFzc2lnbm1lbnQuaXBSYW5nZXMoKTtcbiAgICAgICAgZGF0YVtcIm5hbWVcIl0gPSBtb2RlbC5hc3NpZ25tZW50Lm5hbWUoKTtcbiAgICAgICAgZGF0YVtcInNldHRpbmdzXCJdID0gc2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyhtb2RlbCk7XG5cbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwic2F2ZUFzc2lnbm1lbnRcIiwgZGF0YSwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NzaWJsZUZvcmsuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUsIFwiU2VydmVyIGlzIG5vdCBjb25uZWN0ZWQhIChTYXZlIEFzc2lnbm1lbnQpXCIpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvYWRIaXN0b3J5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRIaXN0b3J5XCIpKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibG9hZEhpc3RvcnlcIiwgZGF0YSwgMiwgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19ISVNUT1JZKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5saXN0VXBsb2FkZWRGaWxlcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsaXN0VXBsb2FkZWRGaWxlc1wiKSkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxpc3RVcGxvYWRlZEZpbGVzXCIsIGRhdGEsIDIsIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVModGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS51cGxvYWRGaWxlID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgZGlyZWN0b3J5LCBmaWxlbmFtZSwgY29udGVudHMsIGNhbGxiYWNrKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInVwbG9hZEZpbGVcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcInBsYWNlbWVudFwiXSA9IHBsYWNlbWVudDtcbiAgICAgICAgZGF0YVtcImRpcmVjdG9yeVwiXSA9IGRpcmVjdG9yeTtcbiAgICAgICAgZGF0YVtcImZpbGVuYW1lXCJdID0gZmlsZW5hbWU7XG4gICAgICAgIGRhdGFbXCJjb250ZW50c1wiXSA9IGNvbnRlbnRzO1xuICAgICAgICBsZXQgZmQgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGQsZSkgPT4gKGQuYXBwZW5kKC4uLmUpLCBkKSwgbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdEJsb2NraW5nKFwidXBsb2FkRmlsZVwiLCBmZCwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1VQTE9BRElOR19GSUxFKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7cHJvY2Vzc0RhdGE6IGZhbHNlLCBjb250ZW50VHlwZTogZmFsc2V9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwbG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFVwbG9hZCBGaWxlKVwiKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2dFdmVudCA9IGZ1bmN0aW9uIChldmVudF90eXBlLCBjYXRlZ29yeSwgbGFiZWwsIG1lc3NhZ2UsIGZpbGVfcGF0aCkge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9nRXZlbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvZ0V2ZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJldmVudF90eXBlXCJdID0gZXZlbnRfdHlwZTtcbiAgICAgICAgZGF0YVtcImNhdGVnb3J5XCJdID0gY2F0ZWdvcnk7XG4gICAgICAgIGRhdGFbXCJsYWJlbFwiXSA9IGxhYmVsO1xuICAgICAgICBkYXRhW1wibWVzc2FnZVwiXSA9IG1lc3NhZ2U7XG4gICAgICAgIGRhdGFbXCJmaWxlX3BhdGhcIl0gPSBmaWxlX3BhdGg7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9nRXZlbnRcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3Bvc3RSZXRyeShkYXRhLCBcImxvZ0V2ZW50XCIsIDAsICgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zYXZlSW1hZ2UgPSBmdW5jdGlvbiAoZGlyZWN0b3J5LCBpbWFnZSkge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUltYWdlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlSW1hZ2VcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImRpcmVjdG9yeVwiXSA9IGRpcmVjdG9yeTtcbiAgICAgICAgZGF0YVtcImltYWdlXCJdID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUltYWdlXCIsIFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIC8vIFRyaWdnZXIgcmVxdWVzdFxuICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgXCJ0dXJ0bGVfb3V0cHV0XCIsIFwic2F2ZUltYWdlXCIsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUltYWdlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMgPSBmdW5jdGlvbihuZXdTdGF0dXMpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcInN0YXR1c1wiXSA9IG5ld1N0YXR1cztcbiAgICAgICAgbGV0IHBvc3RTdGF0dXNDaGFuZ2UgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMobmV3U3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiLCBkYXRhLCAyLCBwb3N0U3RhdHVzQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gbG9hZCBmaWxlcyBhbmQgd2ViIHJlc291cmNlcy5cbiAqXG4gKiBERVBSRUNBVEVEXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCB0eXBlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB2YXIgc2VydmVyID0gdGhpcztcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkX2ZpbGVcIikpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImZpbGVuYW1lXCJdID0gZmlsZW5hbWU7XG4gICAgICAgIGRhdGFbXCJ0eXBlXCJdID0gdHlwZTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKHRoaXMudXJscy5sb2FkX2ZpbGUsIGRhdGEsIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuc2V0U3RhdHVzKFwibG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhcIlNlcnZlciBmYWlsdXJlISBSZXBvcnQgdG8gaW5zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soXCJObyBmaWxlIHNlcnZlciBhdmFpbGFibGUuXCIpO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUsIFwiU2VydmVyIGlzIG5vdCBjb25uZWN0ZWQhIChMb2FkIEZpbGUpXCIpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVGaWxlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjb250ZW50cywgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxheSA9IHRoaXMuVElNRVJfREVMQVk7XG4gICAgfVxuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwic2F2ZUZpbGVcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImZpbGVuYW1lXCJdID0gZmlsZW5hbWU7XG4gICAgICAgIGRhdGFbXCJjb2RlXCJdID0gY29udGVudHM7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBmaWxlbmFtZSwgXCJzYXZlRmlsZVwiLCBkZWxheSwgdGhpcy5zdGFydFBvc3NpYmxlRm9yay5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zdGFydFBvc3NpYmxlRm9yayA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5mb3JrYWJsZSkge1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuT0ZGRVJfRk9SSygpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnVwZGF0ZVN1Ym1pc3Npb24gPSBmdW5jdGlvbiAoc2NvcmUsIGNvcnJlY3QsIGhpZGRlbk92ZXJyaWRlLCBmb3JjZVVwZGF0ZSkge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2VzcztcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBkYXRlU3VibWlzc2lvblwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wic2NvcmVcIl0gPSBzY29yZTtcbiAgICAgICAgZGF0YVtcImNvcnJlY3RcIl0gPSBjb3JyZWN0O1xuICAgICAgICBkYXRhW1wiaGlkZGVuX292ZXJyaWRlXCJdID0gaGlkZGVuT3ZlcnJpZGU7XG4gICAgICAgIGRhdGFbXCJmb3JjZV91cGRhdGVcIl0gPSBmb3JjZVVwZGF0ZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLmdldFBuZ0Zyb21CbG9ja3MoKHBuZ0RhdGEsIGltZykgPT4ge1xuICAgICAgICAgICAgZGF0YVtcImltYWdlXCJdID0gcG5nRGF0YTtcbiAgICAgICAgICAgIGlmIChpbWcucmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaW1nLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIFwidXBkYXRlU3VibWlzc2lvblwiLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGlkZGVuT3ZlcnJpZGUgJiYgY29ycmVjdCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YVtcImFzc2lnbm1lbnRfaWRcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07IiwiZXhwb3J0IGNvbnN0ICRza19tb2RfY292ZXJhZ2UgPSBgXG5cIlwiXCJcbkhpZGVvdXMgZmlsbC1pbiByZXBsYWNlbWVudCBmb3IgQ292ZXJhZ2UsIGxldmVyYWdpbmcgc29tZSBtYWdpYyBmcm9tIHRoZVxuVXRpbGl0eSBmdW5jdGlvbi4gVGhlIGRhdGEgdGhpcyByZXR1cm5zIGlzIGZhbHNlIC0gaXQgZG9lc24ndCBhY3R1YWxseVxuZGVzY3JpYmUgdGhlIG1pc3NpbmcgbGluZXMgYW5kIGFsbCBsaW5lczsgaXQganVzdCBkZXNjcmliZXMgdGhlIHRyYWNlZCBsaW5lcy5cbkJ1dCBzaW5jZSBQZWRhbCBkb2Vzbid0IG5lZWQgdGhlIG90aGVyIHR3bywgaXQgd29ya3Mgb3V0IGZpbmUgd2hlbiB5b3UgZG86XG5cbnN0YXRlbWVudHMgLSBtaXNzaW5nXG5cIlwiXCJcblxuaW1wb3J0IHV0aWxpdHlcblxuY2xhc3MgQ292ZXJhZ2U6XG4gICAgZGVmIHN0YXJ0KHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgc3RvcChzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIHNhdmUoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBfYW5hbHl6ZShzZWxmLCBmaWxlbmFtZTogc3RyKTpcbiAgICAgICAgbGluZXMgPSBzZXQodXRpbGl0eS50cmFjZV9saW5lcygpKVxuICAgICAgICAjIGxpbmVzIHdpbGwgYmUgdGhlIGxpbmVzIHRoYXQgd2VyZSBhY3R1YWxseSBleGVjdXRlZFxuICAgICAgICByZXR1cm4gQW5hbHlzaXMoTm9uZSwgbGVuKGxpbmVzKSwgTm9uZSwgc2V0KCksIGxpbmVzKVxuXG5cbmNsYXNzIE51bWJlcnM6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkKTpcbiAgICAgICAgc2VsZi5uX21pc3NpbmcgPSBuX21pc3NpbmdcbiAgICAgICAgc2VsZi5uX3N0YXRlbWVudHMgPSBuX3N0YXRlbWVudHNcbiAgICAgICAgc2VsZi5wY19jb3ZlcmVkID0gcGNfY292ZXJlZFxuXG5cbmNsYXNzIEFuYWx5c2lzOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBuX21pc3NpbmcsIG5fc3RhdGVtZW50cywgcGNfY292ZXJlZCwgbWlzc2luZywgc3RhdGVtZW50cyk6XG4gICAgICAgIHNlbGYubWlzc2luZyA9IG1pc3NpbmdcbiAgICAgICAgc2VsZi5zdGF0ZW1lbnRzID0gc3RhdGVtZW50c1xuICAgICAgICBzZWxmLm51bWJlcnMgPSBOdW1iZXJzKG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkKVxuXG5cbmNsYXNzIHB5dGhvbjpcbiAgICBkZWYgZ2V0X3B5dGhvbl9zb3VyY2Uoc2VsZik6XG4gICAgICAgIHJldHVybiBOb25lXG5gOyIsImV4cG9ydCB2YXIgJGJ1aWx0aW5tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1vZCwgc2FtcGxlV3JhcHBlcjtcbiAgICBtb2QgPSB7X19uYW1lX186IFwiaW1hZ2VcIn07XG5cbiAgICBpZiAoIVNrLlBJTCkge1xuICAgICAgICBTay5QSUwgPSB7YXNzZXRzOiB7fX07XG4gICAgfVxuXG4gICAgLy8gSW5zdGFudFByb21pc2UgaXMgYSB3b3JrYXJvdW5kIHRvIGFsbG93IHVzYWdlIG9mIHRoZSBjbGVhbiBwcm9taXNlLXN0eWxlXG4gICAgLy8gdGhlbi9jYXRjaCBzeW50YXggYnV0IHRvIGluc3RhbnRseSBjYWxsIHJlc29sdmUgdGhlIHRoZW4vY2F0Y2ggY2hhaW4gc28gd2VcbiAgICAvLyBjYW4gYXZvaWQgY3JlYXRpbmcgU3VzcGVuc2lvbnMgaW4gdW5uZWNlc3NhcnkgY2FzZXMuICBUaGlzIGlzIGRlc2lyYWJsZVxuICAgIC8vIGJlY2F1c2UgU3VzcGVuc2lvbnMgaGF2ZSBhIGZhaXJseSBsYXJnZSBuZWdhdGl2ZSBpbXBhY3Qgb24gb3ZlcmFsbFxuICAgIC8vIHBlcmZvcm1hbmNlLiAgVGhlc2UgJ2luc3RhbnQgcHJvbWlzZXMnIGNvbWUgaW50byBwbGF5IHdoZW4gYSB0cmFjZXIoKVxuICAgIC8vIGNhbGwgaXMgbWFkZSB3aXRoIGEgdmFsdWUgb3RoZXIgdGhhbiAxLiAgV2hlbiB0cmFjZXIgaXMgMCBvciBncmVhdGVyIHRoYW4gMVxuICAgIC8vICwgd2UgY2FuIGJ5cGFzcyB0aGUgY3JlYXRpb24gb2YgYSBTdXNwZW5zaW9uIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IGxpbmUgb2ZcbiAgICAvLyBjb2RlIGltbWVkaWF0ZWx5IGlmIHRoZSBjdXJyZW50IGxpbmUgaXMgbm90IGdvaW5nIHRvIGludm9sdmUgYSBzY3JlZW5cbiAgICAvLyB1cGRhdGUuIFdlIGRldGVybWluZSBpZiBhIHJlYWwgcHJvbWlzZSBvciBJbnN0YW50UHJvbWlzZSBpcyBuZWNlc3NhcnkgYnlcbiAgICAvLyBjaGVja2luZyBGcmFtZU1hbmFnZXIud2lsbFJlbmRlck5leHQoKVxuICAgIGZ1bmN0aW9uIEluc3RhbnRQcm9taXNlKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gZXJyO1xuICAgIH1cblxuICAgIEluc3RhbnRQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSBjYih0aGlzLmxhc3RSZXN1bHQpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yICA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSA/IHRoaXMubGFzdFJlc3VsdCA6IHRoaXM7XG4gICAgfTtcblxuICAgIEluc3RhbnRQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSBjYih0aGlzLmxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlID8gdGhpcy5sYXN0UmVzdWx0IDogdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkSW1hZ2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRBc3NldChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmIChTay5QSUwuYXNzZXRzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvL3JldHVybiBTay5QSUwuYXNzZXRzW25hbWVdO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoU2suUElMLmFzc2V0c1tuYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIFNrLlBJTC5hc3NldHNbbmFtZV0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGFzc2V0OiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlID0gZnVuY3Rpb24oJGdibCwgJGxvYykge1xuICAgICAgICAvLyBvcGVuKGZpbGVuYW1lKSBvciBvcGVuKHVybClcbiAgICAgICAgLy8gc2hvdygpXG5cbiAgICAgICAgJGxvYy5fX2luaXRfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIGZpbGVfb3JfdXJsKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19pbml0X19cIiwgYXJndW1lbnRzLCAyLCAyKTtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJmaWxlX29yX3VybFwiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKGZpbGVfb3JfdXJsKSk7XG4gICAgICAgICAgICBzZWxmLmZpbGVfb3JfdXJsID0gZmlsZV9vcl91cmw7XG4gICAgICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdG8gc3VzcGVuc2lvblxuICAgICAgICAgICAgdmFyIGltYWdlUHJvbWlzZSA9IGdldEFzc2V0KFNrLmZmaS5yZW1hcFRvSnMoZmlsZV9vcl91cmwpKTtcbiAgICAgICAgICAgIHZhciBzdXNwID0gbmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb24oKTtcbiAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgICAgICAgICBzdXNwLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdXNwLmRhdGFbXCJlcnJvclwiXSkge1xuICAgICAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBTay5idWlsdGluLklPRXJyb3Ioc3VzcC5kYXRhW1wiZXJyb3JcIl0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHN1c3AuZGF0YVtcImVycm9yXCJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHNlbGYuaW1hZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN1c3AuZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlNrLnByb21pc2VcIixcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBpbWFnZVByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMud2lkdGggPSBzZWxmLmltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5oZWlnaHQgPSBzZWxmLmltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZShzZWxmLmltYWdlLCAwLCAwLCBzZWxmLmltYWdlLndpZHRoLCBzZWxmLmltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGl4ZWxzID0gc2VsZi5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLCAwLCBzZWxmLmltYWdlLndpZHRoLCBzZWxmLmltYWdlLmhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHN1c3A7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2Muc2hvdyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgaWYgKFNrLmNvbnNvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk5hbWVFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBkcmF3aW5nIGFyZWEuIFNrLmNvbnNvbGUgaXMgdW5kZWZpbmVkIVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbnNvbGVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGltYWdlOiBzZWxmLmltYWdlLFxuICAgICAgICAgICAgICAgIGZpbGVfb3JfdXJsOiBzZWxmLmZpbGVfb3JfdXJsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTay5jb25zb2xlLnByaW50UElMSW1hZ2UoY29uc29sZURhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkbG9jLmZsaXAgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHNlbGYuaW1hZ2Uuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZVgoLTEpXCI7XG4gICAgICAgICAgICBpZiAoU2suY29uc29sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIGRyYXdpbmcgYXJlYS4gU2suY29uc29sZSBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgbW9kLkltYWdlID0gU2subWlzY2V2YWwuYnVpbGRDbGFzcyhtb2QsIGltYWdlLCBcIkltYWdlXCIsIFtdKTtcblxuICAgIHJldHVybiBtb2Q7XG59OyIsImV4cG9ydCBjb25zdCAkcGVkYWxfdHJhY2VyID0gYFxyXG5cclxuXCJcIlwiXHJcbldyYXBzIHRoZSB0cmFjZXIgbW9kdWxlIGluIFBlZGFsXHJcblwiXCJcIlxyXG5cclxuaW1wb3J0IG9zXHJcbmltcG9ydCB1dGlsaXR5XHJcbiAgICAgICAgXHJcbmNsYXNzIFNhbmRib3hCYXNpY1RyYWNlcjpcclxuICAgIFwiXCJcIlxyXG5cclxuICAgIFwiXCJcIlxyXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxyXG4gICAgICAgIHN1cGVyKCkuX19pbml0X18oKVxyXG4gICAgICAgIHNlbGYuZmlsZW5hbWUgPSBcInN0dWRlbnQucHlcIlxyXG4gICAgICAgIHNlbGYuY29kZSA9IE5vbmVcclxuXHJcbiAgICBkZWYgYXNfZmlsZW5hbWUoc2VsZiwgZmlsZW5hbWUsIGNvZGUpOlxyXG4gICAgICAgIGlmIG9zLnBhdGguaXNhYnMoZmlsZW5hbWUpOlxyXG4gICAgICAgICAgICBzZWxmLmZpbGVuYW1lID0gZmlsZW5hbWVcclxuICAgICAgICBlbHNlOlxyXG4gICAgICAgICAgICBzZWxmLmZpbGVuYW1lID0gb3MucGF0aC5hYnNwYXRoKGZpbGVuYW1lKVxyXG4gICAgICAgIHNlbGYuY29kZSA9IGNvZGVcclxuICAgICAgICByZXR1cm4gc2VsZlxyXG5cclxuICAgIGRlZiBfX2VudGVyX18oc2VsZik6XHJcbiAgICAgICAgcGFzc1xyXG5cclxuICAgIGRlZiBfX2V4aXRfXyhzZWxmLCBleGNfdHlwZSwgZXhjX3ZhbCwgdHJhY2ViYWNrKTpcclxuICAgICAgICBwYXNzXHJcblxyXG5jbGFzcyBTYW5kYm94TmF0aXZlVHJhY2VyKFNhbmRib3hCYXNpY1RyYWNlcik6XHJcbiAgICBcIlwiXCJcclxuICAgIFRyYWNrcyBsaW5lcyBjb3ZlcmVkIGFuZCBmdW5jdGlvbiBjYWxscy4gUG9zc2libHkgb3RoZXIgdGhpbmdzPyBXZSBjb3VsZCB0cmFjayB2YXJpYWJsZXMsIGlmIHRoYXRcclxuICAgIHdhcyBzb21ldGhpbmcgcGVvcGxlIHdhbnRlZC5cclxuXHJcbiAgICBUT0RPOiBIYW5kbGUgbXVsdGlwbGUgc3VibWlzc2lvbiBmaWxlcz9cclxuICAgIFwiXCJcIlxyXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxyXG4gICAgICAgIHN1cGVyKCkuX19pbml0X18oKVxyXG4gICAgICAgICNzZWxmLmNhbGxzID0gdXRpbGl0eS50cmFjZV9jYWxscygpXHJcbiAgICAgICAgc2VsZi5saW5lcyA9IHV0aWxpdHkudHJhY2VfbGluZXMoKVxyXG4gICAgICAgIHNlbGYuc3RlcF9pbmRleCA9IGxlbih1dGlsaXR5LnRyYWNlX2xpbmVzKCkpXHJcbiAgICBcclxuICAgIGRlZiBnZXRfY2FsbHMoc2VsZik6XHJcbiAgICAgICAgcmV0dXJuIHV0aWxpdHkudHJhY2VfY2FsbHMoKVxyXG4gICAgXHJcbiAgICBjYWxscyA9IHByb3BlcnR5KGdldF9jYWxscylcclxuICAgIFxyXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcclxuICAgICAgICB1dGlsaXR5LnN0YXJ0X3RyYWNlKHNlbGYpXHJcblxyXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsLCB0cmFjZWJhY2spOlxyXG4gICAgICAgIHV0aWxpdHkuc3RvcF90cmFjZShzZWxmKVxyXG5cclxuVFJBQ0VSX1NUWUxFUyA9IHtcclxuICAgICdub25lJzogU2FuZGJveEJhc2ljVHJhY2VyLFxyXG4gICAgJ25hdGl2ZSc6IFNhbmRib3hOYXRpdmVUcmFjZXJcclxufVxyXG5cclxuYDsiLCIvKipcbiAqIFNrdWxwdCBNb2R1bGUgZm9yIGhvbGRpbmcgdGhlIEluc3RydWN0b3IgQVBJLlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGxvYWRlZCBpbiBieSBnZXR0aW5nIHRoZSBmdW5jdGlvbnMnIHNvdXJjZSBjb2RlIGZyb20gdG9TdHJpbmcuXG4gKiBJc24ndCB0aGF0IGNyYXp5P1xuICpcbiAqXG4gKi9cbmV4cG9ydCBsZXQgJHNrX21vZF9pbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gTWFpbiBtb2R1bGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCBhdCB0aGUgZW5kLlxuICAgIGxldCBtb2QgPSB7fTtcbiAgICBsZXQgbm9uZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICBcbiAgICBsZXQgcHJpb3IgPSBudWxsO1xuICAgIG1vZC50aW1laXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInRpbWVpdFwiLCBhcmd1bWVudHMsIDEsIDEpO1xuICAgICAgICBsZXQgZGlmZmVyZW5jZTtcbiAgICAgICAgaWYgKHByaW9yID09PSBudWxsKSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBEYXRlLm5vdygpIC0gcHJpb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coU2suZmZpLnJlbWFwVG9KcyhuYW1lKSwgZGlmZmVyZW5jZS8xMDAwKTtcbiAgICAgICAgcHJpb3IgPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIExvZ3MgZmVlZGJhY2sgdG8gamF2YXNjcmlwdCBjb25zb2xlXG4gICAgICovXG4gICAgbW9kLmNvbnNvbGVfbG9nID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coKFsuLi5hcmd1bWVudHNdKS5tYXAoU2suZmZpLnJlbWFwVG9KcykpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIExvZ3MgZGVidWcgdG8gamF2YXNjcmlwdCBjb25zb2xlXG4gICAgICovXG4gICAgbW9kLmNvbnNvbGVfZGVidWcgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb3ZlcnRzIHRoZSBvdXRwdXQgaW4gdGhlIHN0dWRlbnQgcmVwb3J0IHRvIGEgcHl0aG9uIFxuICAgICAqIGxpc3QgYW5kIHJldHVybnMgaXQuXG4gICAgKiovXG4gICAgbW9kLmdldF9vdXRwdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X291dHB1dFwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IG91dHB1dCA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdW1wib3V0cHV0XCJdKCk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udG9Ta3VscHQoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXNldHMgdGhlIG91dHB1dCwgcGFydGljdWxhcmx5IHVzZWZ1bCBpZiB0aGUgc3R1ZGVudFxuICAgICAqIGNvZGUgaXMgZ29pbmcgdG8gYmUgcmVydW4uXG4gICAgICovXG4gICAgbW9kLnJlc2V0X291dHB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJyZXNldF9vdXRwdXRcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLm91dHB1dC5yZW1vdmVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIH0pO1xuICAgIFxuICAgIC8qbW9kLnF1ZXVlX2lucHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInF1ZXVlX2lucHV0XCIsIGFyZ3VtZW50cywgMSwgSW5maW5pdHkpO1xuICAgICAgICBsZXQgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgZm9yIChsZXQgaSA9IGFyZ3MubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImlucHV0XCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaW5wdXQpKTtcbiAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goU2suZmZpLnJlbWFwVG9KcyhpbnB1dCkpO1xuICAgICAgICB9XG4gICAgfSk7Ki9cbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBpbnN0cnVjdG9ycyB0byBnZXQgdGhlIHN0dWRlbnRzJyBjb2RlIGFzIGEgc3RyaW5nLlxuICAgICoqL1xuICAgIG1vZC5nZXRfcHJvZ3JhbSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfcHJvZ3JhbVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShTay5leGVjdXRpb25SZXBvcnRzW1widmVyaWZpZXJcIl0uY29kZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBpbnN0cnVjdG9ycyB0byBnZXQgdGhlIHN0dWRlbnRzJyBjb2RlIGFzIGEgc3RyaW5nLlxuICAgICoqL1xuICAgIG1vZC5nZXRfZXZhbHVhdGlvbiA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfZXZhbHVhdGlvblwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5ldmFsdWF0aW9uIHx8IFwiXCIpO1xuICAgIH0pO1xuICAgIFxuICAgIG1vZC50cmFjZV9saW5lcyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5yZWFsTGluZXM7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShsaW5lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZC50cmFjZV9jYWxscyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCItLVwiLCBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDSEVDS0lORyBDQUxMU1wiLCBTay5leGVjdXRpb25SZXBvcnRzWydzdHVkZW50J10uc3VjY2Vzcyk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgY2FsbHMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5jYWxscztcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KGNhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7XG4gICAgfSk7XG5cbiAgICBtb2Quc3RhcnRfdHJhY2UgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RBUlQvQkVHSU5cIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgICAgICBpZiAoU2suYmVmb3JlQ2FsbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgU2suYmVmb3JlQ2FsbCA9IFNrLmJlZm9yZUNhbGxCYWNrdXA7XG4gICAgICAgIH1cbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0udHJhY2luZy5wdXNoKHRydWUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RBUlQvRU5EXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICB9KTtcblxuICAgIG1vZC5zdG9wX3RyYWNlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUT1AvQkVHSU5cIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLnBvcCgpO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0udHJhY2luZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFNrLmJlZm9yZUNhbGwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVE9QL0VORFwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBtb2QuZ2V0X3N0dWRlbnRfZXJyb3IgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3N0dWRlbnRfZXJyb3JcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbm9uZSwgbm9uZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXJyb3IsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci50cmFjZWJhY2sgJiYgZXJyb3IudHJhY2ViYWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbltcImxpbmVcIl0gPSBlcnJvci50cmFjZWJhY2tbMF0ubGluZW5vO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbiA9IFNrLmZmaS5yZW1hcFRvUHkocG9zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtlcnJvciwgcG9zaXRpb25dKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG4gICAgbW9kLmhhZF9leGVjdXRpb25fdGltZV9lcnJvciA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJoYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3JcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuICFTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzICYmIFxuICAgICAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yICYmXG4gICAgICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXJyb3IudHAkbmFtZSA9PT0gXCJUaW1lTGltaXRFcnJvclwiO1xuICAgIH0pO1xuICAgIFxuICAgIGxldCBiYWNrdXBUaW1lID0gdW5kZWZpbmVkO1xuICAgIG1vZC5saW1pdF9leGVjdXRpb25fdGltZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJsaW1pdF9leGVjdXRpb25fdGltZVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBiYWNrdXBUaW1lID0gU2suZXhlY0xpbWl0O1xuICAgICAgICBpZiAoU2suZXhlY0xpbWl0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKCk7XG4gICAgICAgICAgICBTay5leGVjU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbW9kLnVubGltaXRfZXhlY3V0aW9uX3RpbWUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwidW5saW1pdF9leGVjdXRpb25fdGltZVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5leGVjTGltaXQgPSBiYWNrdXBUaW1lO1xuICAgICAgICBTay5leGVjU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuICAgIFxuICAgIG1vZC5zdXBwcmVzc19zY3JvbGxpbmcgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic3VwcHJlc3Nfc2Nyb2xsaW5nXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHMuaW5zdHJ1Y3Rvci5zY3JvbGxpbmcgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgXG4gICAgLypcbiAgICBkZWYgaGlzdChzZWxmLCBkYXRhLCAqKmt3YXJncyk6XG4gICAgICAgIGxhYmVsID0ga3dhcmdzLmdldCgnbGFiZWwnLCBOb25lKVxuICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdIaXN0b2dyYW0nLCAndmFsdWVzJzogZGF0YSwgJ2xhYmVsJzogbGFiZWx9KVxuICAgIGRlZiBwbG90KHNlbGYsIHhzLCB5cz1Ob25lLCAqKmt3YXJncyk6XG4gICAgICAgIGxhYmVsID0ga3dhcmdzLmdldCgnbGFiZWwnLCBOb25lKVxuICAgICAgICBpZiB5cyA9PSBOb25lOlxuICAgICAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnTGluZScsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneCc6IHJhbmdlKGxlbih4cykpLCAneSc6IHhzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdMaW5lJywgJ3gnOiB4cywgJ3knOiB5cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgIGRlZiBzY2F0dGVyKHNlbGYsIHhzLCB5cywgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnU2NhdHRlcicsICd4JzogeHMsICd5JzogeXMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICAqL1xuICAgIG1vZC5nZXRfcGxvdHMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3Bsb3RzXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0cyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdW1wib3V0cHV0XCJdKCk7XG4gICAgICAgICAgICBvdXRwdXRzID0gb3V0cHV0cy5maWx0ZXIoZnVuY3Rpb24ob3V0cHV0KSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQudHlwZSA9PT0gXCJwbG90XCI7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24oZ3JhcGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wiZGF0YVwiOiBncmFwaC5jb250ZW50Lm1hcChmdW5jdGlvbihwbG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdQbG90ID0geyBcInR5cGVcIjogcGxvdC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlwiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbG90LnR5cGUgPT09IFwibGluZVwiIHx8IHBsb3QudHlwZSA9PT0gXCJzY2F0dGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ4XCJdID0gcGxvdC5kYXRhLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Lng7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGxvdFtcInlcIl0gPSBwbG90LmRhdGEubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYueTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxvdC50eXBlID09PSBcImhpc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGxvdFtcInZhbHVlc1wiXSA9IHBsb3QuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGxvdDtcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXCJ4bGFiZWxcIjogXCJcIiwgXCJ5bGFiZWxcIjogXCJcIiwgXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcIlwiLCBcImxlZ2VuZFwiOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KG91dHB1dHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoW10pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcbiAgICAvLyBQcm92aWRlcyBgc3R1ZGVudGAgYXMgYW4gb2JqZWN0IHdpdGggYWxsIHRoZSBkYXRhIHRoYXQgdGhlIHN0dWRlbnQgZGVjbGFyZWQuXG4gICAgbW9kLlN0dWRlbnREYXRhID0gU2subWlzY2V2YWwuYnVpbGRDbGFzcyhtb2QsIGZ1bmN0aW9uKCRnYmwsICRsb2MpIHtcbiAgICAgICAgJGxvYy5fX2luaXRfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgLy9zZWxmLmRhdGEgPSBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgICAgIGxldCBuZXdEaWN0ID0gbmV3IFNrLmJ1aWx0aW4uZGljdCgpO1xuICAgICAgICAgICAgU2suYWJzdHIuc2F0dHIoc2VsZiwgbmV3IFNrLmJ1aWx0aW4uc3RyKFwiZGF0YVwiKSwgbmV3RGljdCwgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLm1vZHVsZSA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnJlc3VsdHM7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlID0gc2VsZi5tb2R1bGUuJGQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNlbGYubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTay5hYnN0ci5vYmplY3RTZXRJdGVtKG5ld0RpY3QsIFNrLmZmaS5yZW1hcFRvUHkoU2sudW5maXhSZXNlcnZlZChrZXkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2R1bGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNhbGxfZiA9IGZ1bmN0aW9uKGt3YSkge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcImNhbGxcIiwgYXJndW1lbnRzLmxlbmd0aCwgMSwgSW5maW5pdHksIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdmFyIGt3YXJncyA9IG5ldyBTay5idWlsdGlucy5kaWN0KGt3YSk7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBhcmdzWzFdO1xuICAgICAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMik7XG5cbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBrd2FyZ3MubXAkbG9va3VwKG5ldyBTay5idWlsdGluLnN0cihcImlucHV0c1wiKSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSBTay5mZmkucmVtYXBUb0pzKGlucHV0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0cy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlbGYudHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXCJkYXRhXCIpKTtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk9iamVjdCA9IGRhdGEubXAkbG9va3VwKGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb25PYmplY3QudHAkY2FsbChhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGNhbGxfZi5jb19rd2FyZ3MgPSB0cnVlO1xuICAgICAgICAvL2NhbGxfZi5jb192YXJuYW1lcyA9IFtcInNlbGZcIiwgXCJmdW5jdGlvblwiXTtcbiAgICAgICAgY2FsbF9mLmNvX25hbWU9IG5ldyBTay5idWlsdGluLnN0cihcImNhbGxcIik7XG4gICAgICAgICRsb2NbXCJjYWxsXyRybiRcIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGNhbGxfZik7XG5cbiAgICAgICAgJGxvY1tcIl9fcmVwcl9fXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkbG9jLmdldF9uYW1lc19ieV90eXBlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmLCB0eXBlLCBleGNsdWRlX2J1aWx0aW5zKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X25hbWVzX2J5X3R5cGVcIiwgYXJndW1lbnRzLCAyLCAzKTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImV4Y2x1ZGVfYnVpbHRpbnNcIiwgXCJib29sZWFuXCIsIFNrLmJ1aWx0aW4uY2hlY2tCb29sKGV4Y2x1ZGVfYnVpbHRpbnMpKTtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gU2suZmZpLnJlbWFwVG9KcyhleGNsdWRlX2J1aWx0aW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHNlbGYubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGVbcHJvcGVydHldLnRwJG5hbWUgPT09IHR5cGUudHAkbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhleGNsdWRlX2J1aWx0aW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zICYmIHByb3BlcnR5LnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU2suZmZpLnJlbWFwVG9QeShTay51bmZpeFJlc2VydmVkKHByb3BlcnR5KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICRsb2MuZ2V0X3ZhbHVlc19ieV90eXBlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmLCB0eXBlLCBleGNsdWRlX2J1aWx0aW5zKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3ZhbHVlc19ieV90eXBlXCIsIGFyZ3VtZW50cywgMiwgMyk7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJleGNsdWRlX2J1aWx0aW5zXCIsIFwiYm9vbGVhblwiLCBTay5idWlsdGluLmNoZWNrQm9vbChleGNsdWRlX2J1aWx0aW5zKSk7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IFNrLmZmaS5yZW1hcFRvSnMoZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlW3Byb3BlcnR5XS50cCRuYW1lID09PSB0eXBlLnRwJG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zICYmIHByb3BlcnR5LnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5tb2R1bGVbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFwiU3R1ZGVudERhdGFcIik7XG4gICAgbW9kLnN0dWRlbnQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kKG1vZC5TdHVkZW50RGF0YSk7XG4gICAgXG4gICAgbW9kLmdldF9zdHVkZW50X2RhdGEgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3N0dWRlbnRfZGF0YVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gbW9kLnN0dWRlbnQ7XG4gICAgfSk7XG5cbiAgICBtb2Quc2V0X2luc3RydWN0aW9ucyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24obmV3SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJzZXRfaW5zdHJ1Y3Rpb25zXCIsIGFyZ3VtZW50cywgMSwgMik7XG4gICAgICAgIG5ld0luc3RydWN0aW9ucyA9IFNrLmZmaS5yZW1hcFRvSnMobmV3SW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcIm1vZGVsXCJdLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhuZXdJbnN0cnVjdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgbW9kLmdldF9tb2RlbF9pbmZvID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihrZXlzKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfbW9kZWxfaW5mb1wiLCBhcmd1bWVudHMsIDEsIDEpO1xuICAgICAgICBsZXQgbW9kZWwgPSBTay5leGVjdXRpb25SZXBvcnRzW1wibW9kZWxcIl07XG4gICAgICAgIGtleXMgPSBTay5mZmkucmVtYXBUb0pzKGtleXMpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW9kZWwgPSBtb2RlbFtrZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShtb2RlbCgpKTtcbiAgICB9KTtcblxuICAgIG1vZC5jbGVhcl9leGlzdGluZ19zdHVkZW50X2ltcG9ydHMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3N0dWRlbnRfZGF0YVwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMoKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gbW9kO1xufTtcbiIsImV4cG9ydCB2YXIgJGJ1aWx0aW5tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgbW9kLCBzYW1wbGVXcmFwcGVyO1xyXG4gICAgbW9kID0ge19fbmFtZV9fOiBcIndlYWtyZWZcIn07XHJcblxyXG4gICAgLyptb2QuV2Vha1NldCA9IFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJ3ZWFrcmVmLldlYWtTZXRcIiwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBXZWFrU2V0KClcclxuICAgIH0pOyovXHJcblxyXG4gICAgdmFyIFdlYWtTZXQgPSBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XHJcbiAgICAgICAgJGxvYy5fX2luaXRfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYsIGRhdGEpIHtcclxuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9faW5pdF9fXCIsIGFyZ3VtZW50cywgMiwgMik7XHJcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJkYXRhXCIsIFwiaXRlcmFibGVcIiwgU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGRhdGEpKTtcclxuICAgICAgICAgICAgc2VsZi5kYXRhID0gW107XHJcbiAgICAgICAgICAgIGxldCBpdGVyID0gU2suYWJzdHIuaXRlcihkYXRhKTtcclxuICAgICAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBTay5hYnN0ci5pdGVybmV4dChpdGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGEucHVzaChuZXcgV2Vha1JlZihuZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKG5leHQgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRsb2MuX19pdGVyX18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld09mRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBzZWxmLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZWxmLmRhdGFbaV0uZGVyZWYoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3T2ZEYXRhLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5kYXRhID0gdmlld09mRGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrLmFic3RyLml0ZXIobmV3IFNrLmJ1aWx0aW4ubGlzdCh2aWV3T2ZEYXRhKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qJGxvYy5uZXh0JCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gKHNlbGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudHAkaXRlcigpO1xyXG4gICAgICAgIH0pOyovXHJcblxyXG4gICAgICAgICRsb2MuYWRkID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmLCBpdGVtKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YS5wdXNoKG5ldyBXZWFrUmVmKGl0ZW0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBtb2QuV2Vha1NldCA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBXZWFrU2V0LCBcIldlYWtTZXRcIiwgW10pO1xyXG5cclxuICAgIHJldHVybiBtb2Q7XHJcbn07IiwibGV0IExPQ0FMX1NUT1JBR0VfUkVGO1xudHJ5IHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRiA9IGxvY2FsU3RvcmFnZTtcbiAgICBsZXQgbW9kID0gXCJCTE9DS1BZX0xPQ0FMU1RPUkFHRV9URVNUXCI7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbShtb2QpO1xufSBjYXRjaChlKSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYgPSB7XG4gICAgICAgIF9kYXRhICAgICAgIDoge30sXG4gICAgICAgIHNldEl0ZW0gICAgIDogZnVuY3Rpb24oaWQsIHZhbCkgeyByZXR1cm4gdGhpcy5fZGF0YVtpZF0gPSBTdHJpbmcodmFsKTsgfSxcbiAgICAgICAgZ2V0SXRlbSAgICAgOiBmdW5jdGlvbihpZCkgeyByZXR1cm4gdGhpcy5fZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgPyB0aGlzLl9kYXRhW2lkXSA6IG51bGw7IH0sXG4gICAgICAgIHJlbW92ZUl0ZW0gIDogZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGRlbGV0ZSB0aGlzLl9kYXRhW2lkXTsgfSxcbiAgICAgICAgY2xlYXIgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGEgPSB7fTsgfVxuICAgIH07XG59XG5cbi8qKlxuICogSGVscGVyIG9iamVjdCBmb3IgaW50ZXJmYWNpbmcgd2l0aCB0aGUgTG9jYWxTdG9yYWdlLiBUaGUgTG9jYWxTdG9yYWdlXG4gKiBicm93c2VyIEFQSSBhbGxvd3MgZm9yIG9mZmxpbmUgc3RvcmFnZS4gVGhhdCBBUEkgaXMgdmVyeSB1bnNvcGhpc3RpY2F0ZWQsXG4gKiBhbmQgaXMgZXNzZW50aWFsbHkgYSBsYW1lIGtleS12YWx1ZSBzdG9yZS4gVGhpcyBvYmplY3Qgc2l0cyBvbiB0b3BcbiAqIGFuZCBwcm92aWRlcyBhIG51bWJlciBvZiB1c2VmdWwgdXRpbGl0aWVzLCBpbmNsdWRpbmcgcnVkaW1lbnRhcnljYWNoZVxuICogY2FjaGUgZXhwaXJhdGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtMb2NhbFN0b3JhZ2VXcmFwcGVyfVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIEEgbmFtZXNwYWNlIHRvIHVzZSBpbiBncm91cGluZyBhY2Nlc3MgdG8gbG9jYWxzdG9yYWdlLiBUaGlzIGtlZXBzIGFjY2VzcyBjbGVhbiBhbmQgb3JnYW5pemVkLCB3aGlsZSBhbHNvIG1ha2luZyBpdCBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIExvY2FsU3RvcmFnZSBjb25uZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIExvY2FsU3RvcmFnZVdyYXBwZXIobmFtZXNwYWNlKSB7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG59XG4vKipcbiAqIEEgbWV0aG9kIGZvciBhZGRpbmcgYSBrZXkvdmFsdWUgcGFpciB0byBMb2NhbFN0b3JhZ2UuXG4gKiBOb3RlIHRoYXQgYm90aCBwYXJhbWV0ZXJzIG11c3QgYmUgc3RyaW5ncyAoSlNPTi5zdHJpbmdpZnkgaXMgeW91ciBmcmllbmQpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXQgPSAgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIsIHZhbHVlKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIiwgJC5ub3coKSk7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZW1vdmluZyBhIGtleSBmcm9tIExvY2FsU3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZW1vdmUuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmb3IuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHRpbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHRpbWUgZm9yLlxuICogQHJldHVybnMge0ludGVnZXJ9IC0gVGhlIHRpbWVzdGFtcCAobG9jYWwgZXBvY2gpIHdoZW4gdGhlIGtleSB3YXMgbGFzdCBzZXQuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICogSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCwgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSBpcyB1c2VkIGluc3RlYWQuXG4gKiBUaGlzIGRlZmF1bHQgd2lsbCBiZSBzZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UuIE11c3QgYmUgYSBzdHJpbmcuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbihrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgdGVzdCBmb3Igd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIGluIExvY2FsU3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB0ZXN0IGV4aXN0ZW5jZSBmb3IuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKSAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogQSB0ZXN0IGZvciB3aGV0aGVyIHRoZSBzZXJ2ZXIgaGFzIHRoZSBuZXdlciB2ZXJzaW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBhc3N1bWVzIHRoYXQgdGhlIHNlcnZlciB0cmlwIHRha2VzIGFib3V0IDUgc2Vjb25kcy4gVGhpcyBtZXRob2RcbiAqIGlzIGxhcmdlbHkgZGVwcmVjYXRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gc2VydmVyX3RpbWUgLSBUaGUgc2VydmVyJ3MgdGltZSBhcyBhbiBlcG9jaCAoaW4gbWlsbGlzZWNvbmRzKVxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pc19uZXcgPSBmdW5jdGlvbihrZXksIHNlcnZlcl90aW1lKSB7XG4gICAgdmFyIHN0b3JlZF90aW1lID0gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpO1xuICAgIHJldHVybiAoc2VydmVyX3RpbWUgPj0gc3RvcmVkX3RpbWUrNTAwMCk7XG59O1xuIiwiZXhwb3J0IGNvbnN0IFRSQUNFX0hUTUwgPSBgXG5cbjxkaXYgY2xhc3M9XCJibG9ja3B5LXRyYWNlIGNvbC1tZC02IGJsb2NrcHktcGFuZWxcIlxuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJUcmFjZVwiPlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJjbGVhcmZpeFwiPlxuICAgICAgICA8c3Ryb25nPlRyYWNlOiA8L3N0cm9uZz5cbiAgICAgICAgXG4gICAgICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbidcbiAgICAgICAgICAgICAgICBjbGFzcz0nYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgZmxvYXQtcmlnaHQgYmxvY2tweS1oaWRlLXRyYWNlJ1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPiBIaWRlIFRyYWNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIG1iLTMgYmxvY2tweS10cmFjZS1jb250cm9sc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtcHJlcGVuZFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5maXJzdFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmJhY2t3YXJkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1iYWNrd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5TdGVwOjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCc+PC9zcGFuPlxuICAgICAgICAgICAgICAgIC8gPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBleGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5mb3J3YXJkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1mb3J3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UubGFzdFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogdWkudHJhY2UubGluZSc+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8cCBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS50cmFjZS5hc3RcIj48L3A+XG4gICAgPHA+VmFyaWFibGVzIGFmdGVyIHRoaXMgc3RlcDo8L3A+XG4gICAgPHRhYmxlIGNsYXNzPSd0YWJsZSB0YWJsZS1zbSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWhvdmVyJz5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyPjx0aD5OYW1lPC90aD48dGg+VHlwZTwvdGg+PHRoPlZhbHVlPC90aD48L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHkgZGF0YS1iaW5kPVwiZm9yZWFjaDogdWkudHJhY2UuZGF0YSgpLnByb3BlcnRpZXNcIj5cbiAgICAgICAgICAgIDx0ciBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBuYW1lICE9ICdfX2ZpbGVfXycgJiYgbmFtZSAhPSAnX19wYXRoX18nXCI+XG4gICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmQ9XCJ0ZXh0OiB0eXBlXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgIDxjb2RlIGRhdGEtYmluZD1cInRleHQ6IHZhbHVlXCI+PC9jb2RlPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIGtvIGlmOiB0eXBlID09IFwiTGlzdFwiIC0tPlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIlwiIGRhdGEtYmluZD1cImNsaWNrOiAvLyRyb290LnZpZXdFeGFjdFZhbHVlKHR5cGUsIGV4YWN0X3ZhbHVlKVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZ2x5cGhpY29uIGdseXBoaWNvbi1uZXctd2luZG93Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgICBcbjwvZGl2PlxuYDtcblxuZXhwb3J0IGNvbnN0IEFTVF9ERVNDUklQVElPTlMgPSB7XG4gICAgXCJBZGRcIjogXCJBbiBhZGRpdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiQW5kXCI6IFwiQSBib29sZWFuIEFORCBvcGVyYXRvclwiLFxuICAgIFwiQW5uQXNzaWduXCI6IFwiQW4gYW5ub3RhdGVkIGFzc2lnbm1lbnRcIixcbiAgICBcIkFzc2VydFwiOiBcIkFuIGFzc2VydCBzdGF0ZW1lbnRcIixcbiAgICBcIkFzc2lnblwiOiBcIkFuIGFzc2lnbm1lbnQgc3RhdGVtZW50XCIsXG4gICAgXCJBc3luY0ZvclwiOiBcIkFuIGFzeWNocm9ub3VzIGZvciBsb29wXCIsXG4gICAgXCJBc3luY0Z1bmN0aW9uRGVmXCI6IFwiQW4gYXN5Y2hyb25vdXMgZnVuY3Rpb24gZGVmaW5pdGlvblwiLFxuICAgIFwiQXN5bmNXaXRoXCI6IFwiQW4gYXN5Y2hyb25vdXMgd2l0aCBzdGF0ZW1lbnRcIixcbiAgICBcIkF0dHJpYnV0ZVwiOiBcIkFuIGF0dHJpYnV0ZSBsb29rdXAgKGFjY2VzcyBhIGZpZWxkKVwiLFxuICAgIFwiQXVnQXNzaWduXCI6IFwiQW4gYXVnbWVudGVkIGFzc2lnbm1lbnRcIixcbiAgICBcIkF1Z0xvYWRcIjogXCJBbiBhdWdtZW50ZWQgbG9hZFwiLFxuICAgIFwiQXVnU3RvcmVcIjogXCJBbiBhdWdtZW50ZWQgc3RvcmVcIixcbiAgICBcIkF3YWl0XCI6IFwiQW4gYXdhaXQgc3RhdGVtZW50XCIsXG4gICAgXCJCaW5PcFwiOiBcIkEgYmluYXJ5IG9wZXJhdG9yXCIsXG4gICAgXCJCaXRBbmRcIjogXCJBIGJpdHdpc2UgQU5EIG9wZXJhdG9yXCIsXG4gICAgXCJCaXRPclwiOiBcIkEgYml0d2lzZSBPUiBvcGVyYXRvclwiLFxuICAgIFwiQml0WG9yXCI6IFwiQSBiaXR3aXNlIFhPUiBvcGVyYXRvclwiLFxuICAgIFwiQm9vbE9wXCI6IFwiQSBib29sZWFuIG9wZXJhdG9yXCIsXG4gICAgXCJCcmVha1wiOiBcIkEgYnJlYWsgc3RhdGVtZW50XCIsXG4gICAgXCJCeXRlc1wiOiBcIkEgbGl0ZXJhbCBieXRlcyBzdHJpbmdcIixcbiAgICBcIkNhbGxcIjogXCJBIGZ1bmN0aW9uIGNhbGxcIixcbiAgICBcIkNsYXNzRGVmXCI6IFwiQSBjbGFzcyBkZWZpbml0aW9uXCIsXG4gICAgXCJDb21wYXJlXCI6IFwiQSBib29sZWFuIGNvbXBhcmlzb25cIixcbiAgICBcIkNvbnN0YW50XCI6IFwiQSBsaXRlcmFsIHZhbHVlXCIsXG4gICAgXCJDb250aW51ZVwiOiBcIkEgY29udGludWUgc3RhdGVtZW50XCIsXG4gICAgXCJEZWxcIjogXCJBIGRlbGV0ZSBzdGF0ZW1lbnRcIixcbiAgICBcIkRlbGV0ZVwiOiBcIkEgZGVsZXRpb25cIixcbiAgICBcIkRpY3RcIjogXCJBIGRpY3Rpb25hcnkgbGl0ZXJhbFwiLFxuICAgIFwiRGljdENvbXBcIjogXCJBIGRpY3Rpb25hcnkgY29tcHJlaGVuc2lvblwiLFxuICAgIFwiRGl2XCI6IFwiQSBkaXZpc2lvbiBvcGVyYXRvclwiLFxuICAgIFwiRWxsaXBzaXNcIjogXCJBbiBlbGxpcHNpc1wiLFxuICAgIFwiRXFcIjogXCJBbiBlcXVhbGl0eSBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJFeGNlcHRIYW5kbGVyXCI6IFwiQW4gZXhjZXB0IGhhbmRsZXJcIixcbiAgICBcIkV4cHJcIjogXCJBbiBleHByZXNzaW9uIHVzZWQgYXMgYSBzdGF0ZW1lbnRcIixcbiAgICBcIkV4cHJlc3Npb25cIjogXCJBbiBldmFsdWF0ZWQgZXhwcmVzc2lvblwiLFxuICAgIFwiRXh0U2xpY2VcIjogXCJBIG11bHRpLWRpbWVuc2lvbmFsIHNsaWNlXCIsXG4gICAgXCJGbG9vckRpdlwiOiBcIkFuIGludGVnZXIgZGl2aXNpb24gb3BlcmF0b3JcIixcbiAgICBcIkZvclwiOiBcIkEgRk9SIGxvb3BcIixcbiAgICBcIkZvcm1hdHRlZFZhbHVlXCI6IFwiQSBmb3JtYXR0ZWQgdmFsdWUgaW4gYW4gZi1zdHJpbmdcIixcbiAgICBcIkZ1bmN0aW9uRGVmXCI6IFwiQSBmdW5jdGlvbiBkZWZpbml0aW9uXCIsXG4gICAgXCJHZW5lcmF0b3JFeHBcIjogXCJBIGdlbmVyYXRvciBleHByZXNzaW9uXCIsXG4gICAgXCJHbG9iYWxcIjogXCJBIGdsb2JhbCBzdGF0ZW1lbnRcIixcbiAgICBcIkd0XCI6IFwiQSBncmVhdGVyIHRoYW4gY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiR3RFXCI6IFwiQSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiSWZcIjogXCJBbiBJRiBzdGF0ZW1lbnRcIixcbiAgICBcIklmRXhwXCI6IFwiQW4gSUYgZXhwcmVzc2lvblwiLFxuICAgIFwiSW1wb3J0XCI6IFwiQW4gaW1wb3J0IHN0YXRlbWVudFwiLFxuICAgIFwiSW1wb3J0RnJvbVwiOiBcIkFuIGltcG9ydC9mcm9tIHN0YXRlbWVudFwiLFxuICAgIFwiSW5cIjogXCJBbiBJTiBvcGVyYXRvclwiLFxuICAgIFwiSW5kZXhcIjogXCJBbiBpbmRleFwiLFxuICAgIFwiSW50ZXJhY3RpdmVcIjogXCJBbiBpbnRlcmFjdGl2ZSBleHByZXNzaW9uXCIsXG4gICAgXCJJbnZlcnRcIjogXCJBbiBpbnZlcnQgb3BlcmF0b3JcIixcbiAgICBcIklzXCI6IFwiQW4gSVMgb3BlcmF0b3JcIixcbiAgICBcIklzTm90XCI6IFwiQW4gSVMgTk9UIG9wZXJhdG9yXCIsXG4gICAgXCJKb2luZWRTdHJcIjogXCJBbiBmLXN0cmluZ1wiLFxuICAgIFwiTFNoaWZ0XCI6IFwiQSBsZWZ0IHNoaWZ0IG9wZXJhdG9yXCIsXG4gICAgXCJMYW1iZGFcIjogXCJBIGxhbWJkYSBleHByZXNzaW9uXCIsXG4gICAgXCJMaXN0XCI6IFwiQSBsaXN0IGxpdGVyYWxcIixcbiAgICBcIkxpc3RDb21wXCI6IFwiQSBsaXN0IGNvbXByZWhlbnNpb25cIixcbiAgICBcIkxvYWRcIjogXCJBIGxvYWRcIixcbiAgICBcIkx0XCI6IFwiQSBsZXNzIHRoYW4gY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiTHRFXCI6IFwiQSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiTWF0TXVsdFwiOiBcIkEgbWF0cml4IG11bHRpcGxpY2F0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJNb2RcIjogXCJBIG1vZHVsbyBvcGVyYXRvclwiLFxuICAgIFwiTW9kdWxlXCI6IFwiQSBtb2R1bGVcIixcbiAgICBcIk11bHRcIjogXCJBIG11bHRpcGxpY2F0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJOYW1lXCI6IFwiQSBuYW1lXCIsXG4gICAgXCJOYW1lQ29uc3RhbnRcIjogXCJBIG5hbWUgY29uc3RhbnRcIixcbiAgICBcIk5vbmxvY2FsXCI6IFwiQSBub25sb2NhbCBzdGF0ZW1lbnRcIixcbiAgICBcIk5vdFwiOiBcIkEgbm90IG9wZXJhdG9yXCIsXG4gICAgXCJOb3RFcVwiOiBcIkEgbm90IGVxdWFsIHRvIGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIk5vdEluXCI6IFwiQSBOT1QgSU4gb3BlcmF0b3JcIixcbiAgICBcIk51bVwiOiBcIkEgbnVtZXJpYyBsaXRlcmFsXCIsXG4gICAgXCJPclwiOiBcIkEgYm9vbGVhbiBPUiBvcGVyYXRvclwiLFxuICAgIFwiUGFyYW1cIjogXCJBIHBhcmFtZXRlclwiLFxuICAgIFwiUGFzc1wiOiBcIkEgcGFzcyBzdGF0ZW1lbnRcIixcbiAgICBcIlBvd1wiOiBcIkEgcG93ZXIgb3BlcmF0b3JcIixcbiAgICBcIlJTaGlmdFwiOiBcIkEgcmlnaHQgc2hpZnQgb3BlcmF0b3JcIixcbiAgICBcIlJhaXNlXCI6IFwiQSByYWlzZSBzdGF0ZW1lbnRcIixcbiAgICBcIlJldHVyblwiOiBcIkEgcmV0dXJuIHN0YXRlbWVudFwiLFxuICAgIFwiU2V0XCI6IFwiQSBzZXQgbGl0ZXJhbFwiLFxuICAgIFwiU2V0Q29tcFwiOiBcIkEgc2V0IGNvbXByZWhlbnNpb25cIixcbiAgICBcIlNsaWNlXCI6IFwiQSBzbGljZVwiLFxuICAgIFwiU3RhcnJlZFwiOiBcIkEgc3RhcnJlZCBhcmd1bWVudFwiLFxuICAgIFwiU3RvcmVcIjogXCJBIHN0b3JlXCIsXG4gICAgXCJTdHJcIjogXCJBIHN0cmluZyBsaXRlcmFsXCIsXG4gICAgXCJTdWJcIjogXCJBIHN1YnRyYWN0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJTdWJzY3JpcHRcIjogXCJBIHN1YnNjcmlwdFwiLFxuICAgIFwiU3VpdGVcIjogXCJBIHN1aXRlXCIsXG4gICAgXCJUcnlcIjogXCJBIHRyeSBzdGF0ZW1lbnRcIixcbiAgICBcIlR1cGxlXCI6IFwiQSB0dXBsZSBsaXRlcmFsXCIsXG4gICAgXCJUeXBlSWdub3JlXCI6IFwiIGEgdHlwZSBpZ25vcmVcIixcbiAgICBcIlVBZGRcIjogXCJBIHVuYXJ5IGFkZGl0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJVU3ViXCI6IFwiQSB1bmFyeSBzdWJ0cmFjdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiVW5hcnlPcFwiOiBcIkEgdW5hcnkgb3BlcmF0b3JcIixcbiAgICBcIldoaWxlXCI6IFwiQSB3aGlsZSBsb29wXCIsXG4gICAgXCJXaXRoXCI6IFwiQSB3aXRoIHN0YXRlbWVudFwiLFxuICAgIFwiWWllbGRcIjogXCJBIHlpZWxkIHN0YXRlbWVudFwiLFxuICAgIFwiWWllbGRGcm9tXCI6IFwiQSB5aWVsZC9mcm9tIHN0YXRlbWVudFwiXG59O1xuXG5leHBvcnQgY2xhc3MgQmxvY2tQeVRyYWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLklHTk9SRURfR0xPQkFMUyA9IFtcIl9fbmFtZV9fXCIsIFwiX19kb2NfX1wiLCBcIl9fcGFja2FnZV9fXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NtZXRob2RcIiwgXCJwcm9wZXJ0eVwiLCBcInN0YXRpY21ldGhvZFwiLCBcIiRmcmVlXCIsIFwiJGNlbGxcIl07XG5cbiAgICAgICAgLy8gdGhpcy50cmFjZS5jbGljayh0aGlzLmJ1aWxkVHJhY2VUYWJsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgc2V0IG9mIHZhcmlhYmxlcyB0cmFjZWQgZnJvbSB0aGUgZXhlY3V0aW9uIGFuZCBwYXJzZSBvdXQgYW55XG4gICAgICogZ2xvYmFsIHZhcmlhYmxlcyBhbmQgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZXMgLSBhIG1hcHBpbmcgb2YgdmFyaWFibGUgbmFtZXMgdG8gdGhlaXIgU2t1cHQgdmFsdWUuXG4gICAgICovXG4gICAgcGFyc2VHbG9iYWxzKHZhcmlhYmxlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtb2R1bGVzID0gW107XG4gICAgICAgIC8vY29uc29sZS5sb2codmFyaWFibGVzKTtcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS50cmFjZUV4ZWN1dGlvbigpKSB7XG4gICAgICAgICAgICAvKmlmIChcIiRjZWxsXCIgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gey4uLnZhcmlhYmxlcywgLi4udmFyaWFibGVzLiRjZWxsfTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgLyppZiAoXCIkZnJlZVwiIGluIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHsuLi52YXJpYWJsZXMsIC4uLnZhcmlhYmxlcy4kZnJlZX07XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhcmlhYmxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSUdOT1JFRF9HTE9CQUxTLmluZGV4T2YocHJvcGVydHkpID09PSAtMSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZShcIl8kcnckXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIl8kcm4kXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gQmxvY2tQeVRyYWNlLnBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB7XCJuYW1lXCI6IHByb3BlcnR5LCBcInR5cGVcIjogXCJVbmtub3duXCIsIFwidmFsdWVcIjogdmFsdWUudG9TdHJpbmcoKX07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gU2suYnVpbHRpbi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaCh2YWx1ZS4kZC5fX25hbWVfXy52KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1wicHJvcGVydGllc1wiOiByZXN1bHQsIFwibW9kdWxlc1wiOiBtb2R1bGVzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFNrdWxwdCB2YWx1ZSBpbnRvIGEgbW9yZSBlYXNpbHkgcHJpbnRhYmxlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBza3VscHQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VWYWx1ZShwcm9wZXJ0eSwgdmFsdWUsIGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlVua25vd25cIixcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiVW5kZWZpbmVkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgY2FzZSBcImRhdGFjbGFzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkRlY29yYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCI8ZGF0YWNsYXNzIGRlY29yYXRvcj5cIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZ1bmM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgUGFyYW1ldGVyczogXCIrdmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzLmpvaW4oXCIsIFwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgTm8gcGFyYW1ldGVyc1wiKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubW9kdWxlOiByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5zdHI6XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxMZW5ndGggfHwgdmFsdWUudi5sZW5ndGggPD0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJbXCIrdmFsdWUuc3EkbGVuZ3RoKCkrXCIgY2hhcmFjdGVycyBub3Qgc2hvd25dXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubm9uZTpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiTm9uZVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5ib29sOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJCb29sZWFuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5ubWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50XCIgPT09IHZhbHVlLnNrVHlwZSA/IFwiSW50ZWdlclwiOiBcIkZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5pbnRfOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5mbG9hdF86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi50dXBsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiVHVwbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmxpc3Q6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnYubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImV4YWN0X3ZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiWy4uLiBcIit2YWx1ZS52Lmxlbmd0aCtcIiBlbGVtZW50cyAuLi5dXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImV4YWN0X3ZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmRpY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkRpY3Rpb25hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiB2YWx1ZSAlIDEgPT09IDAgPyBcIkludGVnZXJcIiA6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJCb29sZWFuXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogKHZhbHVlID8gXCJUcnVlXCI6IFwiRmFsc2VcIilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHZhbHVlLnRwJG5hbWUgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdmFsdWUudHAkbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kciA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuXG59XG5cbi8vIFRPRE86IHZpZXdFeGFjdFZhbHVlIiwiLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IGlzIGluIHRoZSBsaXN0LlxuICogQHBhcmFtIHthbnl0aGluZ30gbmVlZGxlIC0gVGhlIGVsZW1lbnQgdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0FycmF5fSBoYXlzdGFjayAtIFRoZSBsaXN0IHRvIHNlYXJjaC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMobmVlZGxlLCBoYXlzdGFjaykge1xuICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPiAtMTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHZhbHVlcyBmcm9tIGFuIGFycmF5LCBwcmVzZXJ2aW5nIG9yZGVyLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICogQ291cnRlc3k6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTg0MzcwL2hvdy10by1tZXJnZS10d28tYXJyYXlzLWluLWphdmFzY3JpcHQtYW5kLWRlLWR1cGxpY2F0ZS1pdGVtc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHVuaXF1aWZ5LiBFbGVtZW50cyBjb21wYXJlZCB3aXRoID09PS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICB2YXIgYSA9IGFycmF5LmNvbmNhdCgpO1xuICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yKHZhciBqPWkrMTsgajxhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZihhW2ldID09PSBhW2pdKSB7YS5zcGxpY2Uoai0tLCAxKTt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIGFuIGFycmF5IGJhc2VkXG4gKiBvbiBhbiBcImFkZEFycmF5XCIgYW5kIFwicmVtb3ZlQXJyYXlcIi4gQW55IGVsZW1lbnRcbiAqIGZvdW5kIGluIHJlbW92ZUFycmF5IGlzIHJlbW92ZWQgZnJvbSB0aGUgZmlyc3QgYXJyYXlcbiAqIGFuZCBhbGwgdGhlIGVsZW1lbnRzIG9mIGFkZEFycmF5IGFyZSBhZGRlZC5cbiAqIEFueSBkdXBsaWNhdGUgaXRlbXMgYXJlIHJlbW92ZWQuXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5LCBzbyBpcyBub24tZGVzdHJ1Y3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gbWFuaXB1bGF0ZVxuICogQHBhcmFtIHtBcnJheX0gYWRkQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlQXJyYXkgLSB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG1vZGlmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGV4cGFuZEFycmF5KGFycmF5LCBhZGRBcnJheSwgcmVtb3ZlQXJyYXkpIHtcbiAgICB2YXIgY29weUFycmF5ID0gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUFycmF5LmluZGV4T2YoaXRlbSkgPT09IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheVVuaXF1ZShjb3B5QXJyYXkuY29uY2F0KGFkZEFycmF5KSk7XG59XG5cbi8qKlxuICogRGVlcGx5IGNsb25lcyBhIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBBIG5vZGUgdG8gY2xvbmVcbiAqIEByZXR1cm4ge05vZGV9IEEgY2xvbmUgb2YgdGhlIGdpdmVuIG5vZGUgYW5kIGFsbCBpdHMgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBhIHRleHQgbm9kZSwgdGhlbiByZS1jcmVhdGUgaXQgcmF0aGVyIHRoYW4gY2xvbmUgaXRcbiAgICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLm5vZGVWYWx1ZSkgOiBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gXG4gICAgLy8gUmVjdXJzZSAgICAgXG4gICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCkpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICAgXG4gICAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEluZGVudHMgdGhlIGdpdmVuIHN0cmluZyBieSA0IHNwYWNlcy4gVGhpcyBjb3JyZWN0bHkgaGFuZGxlcyBtdWx0aS1saW5lIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHdpdGggZm91ciBzcGFjZXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IG5ldyBsaW5lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5kZW50KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXig/PS4pL2dtLCBcIiAgICBcIik7XG59XG5cbi8qKlxuICogVHVybnMgc3BhY2VzIGludG8gdW5kZXJzY29yZXMgaW4gdGhlIHN0cmluZywgbWFrZXMgaXQgbG93ZXJjYXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHRoZSBzdHJpbmcgdG8gYmUgbWFuaXB1bGF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbHVnKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzL2csIFwiX1wiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBiZSBjYXBpdGFsaXplZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHMpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIFtgbWluYCwgYG1heGBdLlxuICogXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIGxvd2VzdCBwb3NzaWJsZSBpbnRlZ2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBoaWdoZXN0IHBvc3NpYmxlIGludGVnZXIgKGluY2x1c2l2ZSkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRlZ2VyKG1pbixtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYXgtbWluKzEpK21pbik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBzb21lIHRleHQgc28gdGhhdCBpdCBjYW4gYmUgc2FmZWx5IHdyaXR0ZW4gaW50byBhbiBIVE1MIGJveC5cbiAqIFRoaXMgaW5jbHVkZXMgcmVwbGFjaW5nIHNwZWNpYWwgSFRNTCBjaGFyYWN0ZXJzICgmLCA8LCA+LCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHRleHQgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSFRNTC1zYWZlIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVIVE1MKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csIFwiJmFwb3M7XCIpO1xufVxuXG4vKipcbiAqIFNodWZmbGUgdGhlIGJsb2NrcyBpbiB0aGUgd29ya3NwYWNlXG4gKi9cbmlmICh0eXBlb2YgQmxvY2tseSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEJsb2NrbHkuV29ya3NwYWNlU3ZnLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1ldHJpY3Mudmlld1dpZHRoIC8gMixcbiAgICAgICAgICAgIGhlaWdodCA9IG1ldHJpY3Mudmlld0hlaWdodDtcbiAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuZ2V0VG9wQmxvY2tzKGZhbHNlKTtcbiAgICAgICAgdmFyIHkgPSA1LCB4ID0gMCxcbiAgICAgICAgICAgIG1heGltYWxfaW5jcmVhc2UgPSBoZWlnaHQvYmxvY2tzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gR2V0IGEgYmxvY2tcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYmxvY2suZ2V0UmVsYXRpdmVUb1N1cmZhY2VYWSgpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gLXByb3BlcnRpZXMueCtyYW5kb21JbnRlZ2VyKDEwLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5tb3ZlQnkoeCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgLXByb3BlcnRpZXMueSt5KTtcbiAgICAgICAgICAgIHkgPSB5ICsgcmFuZG9tSW50ZWdlcig1LCBtYXhpbWFsX2luY3JlYXNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogTW92ZSBlbGVtZW50cyBmcm9tIG9uZSBhcnJheSB0byBhbm90aGVyIGJhc2VkIG9uIGEgY29uZGl0aW9uYWwgY2hlY2suXG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTg4Nzk2Ny9qYXZhc2NyaXB0LW1vdmUtb2JqZWN0cy1mcm9tLW9uZS1hcnJheS10by1hbm90aGVyLWJlc3QtYXBwcm9hY2hcbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnRzKHNvdXJjZSwgdGFyZ2V0LCBtb3ZlQ2hlY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKG1vdmVDaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgICAgc291cmNlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfSBcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBvbmUgb2YgdGhlIFNrLmJ1aWx0aW4gb2JqZWN0c1xuICogVE9ETzogbWFrZSB0aGlzIHNvIHdlIGRvbid0IGhhdmUgdG8gZXhwbGljaXRseSBwdXQgb3V0IGV2ZXJ5IG9wdGlvblxuICogICAgICAgICAgb25lIHBvc3NpYmxlIHRoaW5nIHdlIGNvdWxkIGRvIGlzIGdldCBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBcbiAqICAgICAgICAgIG9mIHRoZSBjb25zdHJ1Y3RvciBhbmQgbG9vayBmb3IgdGhlIHN1YnN0cmluZyBcInJldHVybiBuZXcgU2suYnVpbHRpblwiXG4gKiAgICAgICAgICBCdXQgSSBkb24ndCBrbm93IGhvdyByZWxpYWJsZSB0aGF0IGlzLiAgUmF0aGVyLCBpdCdzIGtpbmQgb2YgaGFja2lzaC5cbiAqICAgICAgICAgIFNob3VsZCB0ZWhvcmV0aWNhbGx5IGJlbG9uZyBpbiBTay5mZmlcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGV4YW1pbmVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIHR5cGVzXG4qKi9cbmZ1bmN0aW9uIGlzU2tCdWlsdGluKG9iail7XG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ib29sKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8pIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKTtcbiAgICAvL3ZhciBjb25zX3N0ciA9IG9iai5jb25zdHJ1Y3RvciArIFwiXCI7XG4gICAgLy9yZXR1cm4gY29uc19zdHIuaW5kZXhPZihcInJldHVybiBuZXcgU2suYnVpbHRpblwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGlzQXN0Tm9kZShvYmope1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgXCJfYXN0bmFtZVwiIGluIG9iajtcbn1cblxuY29uc3QgREVGQVVMVF9TRUNUSU9OX1BBVFRFUk4gPSAvXigjIyMjIyBQYXJ0ICguKykpJC9nbTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgZ2l2ZW4gUGFydCBJRCB1c2luZyB0aGUgcGF0dGVybiBgIyMjIyBQYXJ0IHdoYXRldmVyYCAob24gaXRzIG93biBzZXBhcmF0ZSBsaW5lKS4gSWYgdGhlIHBhdHRlcm5cbiAqIGlzIG5vdCBmb3VuZCwgdGhlbiBudWxsIGlzIHJldHVybmVkLiBJZiBubyBwYXR0ZXJuIGlzIGdpdmVuIChlbXB0eSBzdHJpbmcgb3IgbnVsbCksIHRoZW4gdGhlIG9yaWdpbmFsIHRleHRcbiAqIGlzIHJldHVybmVkIHdpdGhvdXQgbW9kaWZpY2F0aW9ucy5cbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcGFyYW0gcGFydElkXG4gKiBAcmV0dXJucyB7bnVsbHwqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcnQodGV4dCwgcGFydElkKSB7XG4gICAgaWYgKHBhcnRJZCA9PT0gXCJcIiB8fCBwYXJ0SWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KERFRkFVTFRfU0VDVElPTl9QQVRURVJOKTtcbiAgICBmb3IgKGxldCBpPTI7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrPTMpIHtcbiAgICAgICAgLyogLy8gVW5uZWNlc3NhcnkgYXNzZXJ0aW9uLCBidXQgbm90IGJhZCB0byB0aGluayBhYm91dFxuICAgICAgICBpZiAoIXBhcnRzW2ktMV0uc3RhcnRzV2l0aChcIiMjIyMgUGFydCBcIikpIHtcbiAgICAgICAgICAgIHRocm93IFwiRXJyb3I6IHBhcnQgZm9ybWF0IGlzIGJyb2tlbiFcIjtcbiAgICAgICAgfSovXG4gICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gcGFydElkKSB7XG4gICAgICAgICAgICBsZXQgYm9keSA9IHBhcnRzW2krMV07XG4gICAgICAgICAgICBpZiAoYm9keSAmJiBib2R5WzBdID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gcGFydHMubGVuZ3RoIC0gMyAmJiBib2R5ICYmIGJvZHkuc2xpY2UoLTEpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogU2hvdWxkIHRoZW9yZXRpY2FsbHkgYmVsb25nIGluIFNrLmZmaSwgYnV0IEkgcHV0IGl0IGhlcmUgaW5zdGVhZCB0byBub3QgbWVzcyB1cCB0aGUgc2t1bHB0IGZpbGVzXG4gKiBsaWtlIHRoZSBub3JtYWwgU2suZmZpLnJlbWFwVG9QeSwgaXQgZG9lc24ndCB3b3JrIGZvciBmdW5jdGlvbnMgb3IgbW9yZSBjb21wbGV4IG9iamVjdHMsIGJ1dCBpdCBoYW5kbGVzXG4gKiBjYXNlcyB3aGVyZSB0aGUgdHlwZXMgaW4gb2JqIGFyZSBhIG1peCBvZiBweXRob24gU0lNUExFIG9iamVjdHMgYW5kIFNJTVBMRSBub3JtYWwgamF2YXNjcmlwdCBvYmplY3RzXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge1NrLmJ1aWx0aW4uPz8/fSAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcHl0aG9uIG9iamVjdCwgZHJvcHBpbmcgYWxsIGZ1bmN0aW9ucyBhbmQgdGhpbmdzIGl0IGNhbid0IGNvbnZlcnRcbioqL1xuZnVuY3Rpb24gbWl4ZWRSZW1hcFRvUHkob2JqKXtcbiAgICB2YXIgaztcbiAgICB2YXIga3ZzO1xuICAgIHZhciBpO1xuICAgIHZhciBhcnI7XG4gICAgLy9AVE9ETzogc2hvdWxkIHRoZW9yZXRpY2FsbHkgY2hlY2sgaWYgdGhlIG9iamVjdCBpcyBhIHB5aG9uIGRpY3Qgb3IgYXJyYXkgd2l0aCBqcyBvYmplY3RzXG4gICAgaWYgKGlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAvL29iamVjdCBpcyBhbHJlYWR5IHB5dGhvbiByZWFkeVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAvL29iamVjdCBpcyBhY3R1YWxseSBhIGphdmFzY3JpcHQgYXJyYXlcbiAgICAgICAgYXJyID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggb2JqZWN0LCBjb252ZXJ0IGl0IHRvIGEgcHl0aG9uIG9iamVjdCBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgdmFyIHN1YnZhbCA9IG9ialtpXTtcbiAgICAgICAgICAgIGlmKCFpc1NrQnVpbHRpbihzdWJ2YWwpKXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChtaXhlZFJlbWFwVG9QeShzdWJ2YWwpKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHN1YnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYXJyKTtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkgey8vbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYoIWlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAgICAgLy9hc3N1bWluZyBpdCdzIGEgc3RhbmRhcmQgZGljdGlvbmFyeVxuICAgICAgICAgICAga3ZzID0gW107Ly9Tay5idWlsdGluLmRpY3QgdXNlcyBhbiBhcnJheSBvZiBrZXktdmFsdWUsa2V5LXZhbHVlLi4uXG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBrZXkgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkoaykpO1xuICAgICAgICAgICAgICAgIC8vY292ZXJ0IGNvcnJlc3BvbmRpbmcgdmFsdWUgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkob2JqW2tdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgbmV3IGRpY3Rpb25hcnlcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KGt2cyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLmFzc2skKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChvYmopO1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihvYmoubmFtZSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IGggPSBNYXRoLmZsb29yKHRvZGF5LmdldEhvdXJzKCklMTIpO1xuICAgIGxldCBtID0gdG9kYXkuZ2V0TWludXRlcygpO1xuICAgIC8vbGV0IHMgPSB0b2RheS5nZXRTZWNvbmRzKCk7XG4gICAgaWYgKG0gPCAxMCkge20gPSBcIjBcIiArIG07fVxuICAgIC8vaWYgKHMgPCAxMCkge3MgPSBcIjBcIiArIHM7fVxuICAgIGxldCBwID0gXCJhbVwiO1xuICAgIGlmICh0b2RheS5nZXRIb3VycygpPj0xMikge1xuICAgICAgICBwID0gXCJwbVwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7aH06JHttfSR7cH1gO1xufSIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qcXVlcnlfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfa25vY2tvdXRfXzsiXSwic291cmNlUm9vdCI6IiJ9