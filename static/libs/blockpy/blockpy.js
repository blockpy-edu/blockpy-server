(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("FilePond"), require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["FilePond", "jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("FilePond"), require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["FilePond"], root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_filepond__, __WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var skulpt_modules_weakref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! skulpt_modules/weakref */ "./src/skulpt_modules/weakref.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */




 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_5__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration; //console.log(configuration, configuration["submission.code"], configuration["partId"], extractPart(configuration["submission.code"] || "", configuration["partId"]));

      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray(Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(configuration["assignment.extra_instructor_files"]) || []),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(configuration["submission.code"] || "", configuration["partId"]) || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_7__["DisplayModes"].TEXT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK),
          previousSecondRowSecondPanel: ko.observable(null),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),

          /**
           * Whether or not images should be rendered (true), or just stay as text code (false).
           */
          renderImages: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true"),

          /**
           * Uploaded files are ones that have been listed by the remote
           */
          uploadedFiles: ko.observable(null),

          /**
           * Backup copy of the latest known full code for the Submission. This is relevant if there was a
           * PartID specified, in which case the submission.code in the model is only showing what we know
           * locally.
           */
          backupSubmissionCode: ko.observable(configuration["submission.code"] || ""),

          /**
           * Controls the rating system
           */
          showRating: ko.observable(this.getSetting("display.showRating", "true").toString() === "true"),

          /**
           * Whether the student has rated this current feedback
           */
          hasRated: ko.observable(false)
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          listUploadedFiles: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          listUploadedFilesMessage: ko.observable(""),
          // @type {ServerStatus}
          downloadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          downloadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          uploadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          uploadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          renameFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          renameFileMessage: ko.observable(""),
          // @type {ServerStatus}
          externalAPI: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          externalAPIMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {},

          /**
           * Unique Part ID that can distinguish this editor instance's region of the assignment.
           * It's possible that other editors may be attached to a different Part of the same assignmnet, on the
           * same page.
           * **/
          partId: ko.observable(configuration["partId"] || ""),
          accessToken: ko.observable(configuration["access_token"] || undefined)
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.display.backupSubmissionCode(submission.code);
      this.model.submission.code(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(submission.code, this.model.configuration.partId()) || "");
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.submissionStatus(submission.submission_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.debug(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.fileSystem.loadRemoteFiles();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        smallLayout: ko.pureComputed(function () {
          return !model.display.instructor() && model.assignment.settings.smallLayout();
        }),
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.onlyInteractive();
          }),
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          toggleImages: function toggleImages() {
            if (model.display.renderImages()) {
              self.components.pythonEditor.bm.textEditor.disableImages();
            } else {
              self.components.pythonEditor.bm.textEditor.enableImages();
            }

            model.display.renderImages(!model.display.renderImages());
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          }),
          showClock: ko.pureComputed(function () {
            return !model.assignment.settings.hasClock();
          })
        },
        secondRow: {
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-5";
          }),
          hideTraceButton: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideTraceButton();
          }),
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            }
          },
          makeWide: function makeWide() {
            var currentPanel = model.display.secondRowSecondPanel;
            model.display.previousSecondRowSecondPanel(currentPanel());
            currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
          },
          restorePanel: function restorePanel() {
            var oldPanel = model.display.previousSecondRowSecondPanel;

            if (oldPanel() !== null) {
              model.display.secondRowSecondPanel(oldPanel());
              oldPanel(null);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.smallLayout() || model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          }),
          resetScore: function resetScore() {
            model.submission.score(0);
            model.submission.correct(false);
            self.components.server.updateSubmission(model.submission.score(), model.submission.correct(), true, true);
          },
          provideRatings: ko.pureComputed(function () {
            return !model.assignment.hidden();
          }),
          flipRating: function flipRating() {
            var newState = !model.display.showRating();
            model.display.showRating(newState);
            self.localSettings_.set("display.showRating", newState.toString());
          },
          rate: function rate(rating) {
            self.components.server.logEvent("X-Rating", model.execution.feedback.category(), model.execution.feedback.label(), rating);
            model.configuration.container.find(".blockpy-rating").fadeOut(500, function () {
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(this).fadeIn(500);
              model.display.hasRated(true);
            });
            var thankYou = model.configuration.container.find(".blockpy-feedback-thank-you");
            thankYou.addClass("show");
            setTimeout(function () {
              thankYou.removeClass("show");
            }, 1000);
          },
          hasRatedClass: ko.pureComputed(function () {
            return model.display.hasRated() ? "far" : "fas";
          })
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          highlightedLine: ko.pureComputed(function () {
            if (model.display.secondRowSecondPanel() !== interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              return [];
            }

            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return [];
            } else if (step === 0) {
              return [];
            } else {
              return [traceData[step - 1].line];
            }
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + traceData[step - 1].line;
            }
          }),
          ast: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return "Nothing traced.";
            }

            switch (step) {
              case 0:
                return "Starting execution";

              case lastStep:
                if (!model.execution.reports.student.success) {
                  return "Execution halted (error)";
                }

                return "Finished execution";

              default:
                return "Current step: " + _trace__WEBPACK_IMPORTED_MODULE_13__["AST_DESCRIPTIONS"][traceData[step - 1].ast];
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-6";
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?images.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?images.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?images.blockpy":
                self.components.fileSystem.newFile(path, "{}");
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          rename: function rename(newName) {
            return self.components.fileSystem.renameFile(model.display.filename(), newName);
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?images.blockpy") {
              return "Images";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-7";
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && (model.assignment.settings.hideEditors() || model.assignment.settings.onlyInteractive()) ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_10__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          images: {
            uploadFile: function uploadFile() {
              return self.components.editors.byName("image").uploadFile();
            },
            deleteFile: function deleteFile(fileInfo) {
              return self.components.editors.byName("image").deleteFile(fileInfo);
            },
            renameFile: function renameFile(fileInfo) {
              return self.components.editors.byName("image").renameFile(fileInfo);
            },
            reloadImages: function reloadImages() {
              return self.components.editors.byName("image").reloadImages();
            },
            canChoosePlacement: ko.pureComputed(function () {
              return model.display.instructor();
            }),
            canModify: function canModify(placement) {
              return model.display.instructor() || placement === "submission" || placement === "user";
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          }),
          runLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run";
          }),
          run: function run() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun();
            }
          },
          runQuietlyLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run without feedback";
          }),
          runQuietly: function runQuietly() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun(true);
            }
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.externalAPI() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        },
        footer: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.ui.smallLayout();
          })
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/weakref.js"] = weakrefModule.toString();
      //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_16__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_15__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_13__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_14__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_12__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_10__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_6__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_8__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_18__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_19__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show(); //this.model.configuration.container.find(".blockpy-file-instructor").toggle(this.model.display.instructor());
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
      this.clock = null;
      var container = this.model.configuration.container;

      var updateClock = function updateClock() {
        return container.find(".blockpy-menu-clock").text(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["getCurrentTime"])());
      };

      if (this.model.ui.menu.showClock()) {
        this.clock = setInterval(updateClock, 1000);
      }

      this.model.ui.menu.showClock.subscribe(function (changed) {
        if (_this2.model.ui.menu.showClock()) {
          if (_this2.clock) {
            clearInterval(_this2.clock);
            _this2.clock = null;
          }
        } else {
          if (!_this2.clock) {
            _this2.clock = setInterval(updateClock, 1000);
          }
        }
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  DRAFTER: "drafter",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.offset().top; //$('html').scrollTop(top);

        $("html").scrollTop(top); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLineDrafter = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLineDrafter, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLineDrafter);

  function ConsoleLineDrafter(main, size, fullscreen) {
    var _this2;

    _classCallCheck(this, ConsoleLineDrafter);

    _this2 = _super2.call(this, main, ConsoleLineType.DRAFTER);

    _this2.html.addClass("blockpy-console-drafter-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    return _this2;
  }

  _createClass(ConsoleLineDrafter, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html);
        var top = this.html.offset().top;
        $("html").scrollTop(top);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.main.model.ui.secondRow.restorePanel();
    }
  }]);

  return ConsoleLineDrafter;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLinePygame, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this3;

    _classCallCheck(this, ConsoleLinePygame);

    _this3 = _super3.call(this, main, ConsoleLineType.PYGAME);

    _this3.html.addClass("blockpy-console-pygame-output");

    _this3.size = size;
    _this3.fullscreen = fullscreen;
    _this3.pygameObj = pygameObj;
    _this3.initialized = false;
    _this3.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this3;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.offset().top;
        $("html").scrollTop(top);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};

      this.main.model.ui.secondRow.restorePanel();
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this4 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this4.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLineImage, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLineImage);

    _this5 = _super4.call(this, main, ConsoleLineType.IMAGE, content);

    _this5.html.addClass("blockpy-console-image-output");

    return _this5;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLinePlot, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this6;

    _classCallCheck(this, ConsoleLinePlot);

    _this6 = _super5.call(this, main, ConsoleLineType.PLOT, content);

    _this6.html.addClass("blockpy-console-plot-output");

    return _this6;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineText, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super6.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineValue, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super7.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineInput, _ConsoleLine8);

  var _super8 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this7;

    _classCallCheck(this, ConsoleLineInput);

    _this7 = _super8.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this7.visible = true;
    return _this7;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this8 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this8.main.model.execution.inputIndex(inputIndex + 1);

        _this8.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this8.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();
      console.log(inputIndex, this.main.model.execution.input().length);

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this8.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super9 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super9.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine9) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine9);

  var _super10 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this9;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this9 = _super10.call(this, main, ConsoleLineType.START_EVAL);

    _this9.html.append($(START_EVAL_HTML));

    _this9.html.click(function () {
      _this9.main.model.ui.execute.evaluate();

      _this9["delete"]();
    });

    return _this9;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
      this.drafterLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "handlePygameResize",
    value: function handlePygameResize(newWidth, newHeight) {
      // If the user hasn't changed the console size, and the newHeight is bigger than default, we'll change it
      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height() && newHeight > this.DEFAULT_HEIGHT) {
        this.printerTag.height(30 + newHeight);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      } // If the pygame window is wider than the console, we'll expand temporarily.


      if (newWidth > this.printerTag.width()) {
        this.main.model.ui.secondRow.makeWide();
      }
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else if (this.pygameLine) {
          var _canvas = this.pygameLine.canvas;

          var _dataUrl = _canvas.toDataURL("image/png");

          this.main.components.server.saveImage("turtle_output", _dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "drafter",
    value: function drafter(size, fullscreen) {
      if (this.drafterLine === null) {
        this.drafterLine = new ConsoleLineDrafter(this.main, size, fullscreen);
        this.drafterLine.render(this.printerTag);
      }

      return this.drafterLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_LISTING_UPLOADED_FILES = function (reason) {
  this.show("Error Listing Uploaded Files", "BlockPy encountered an error while listing the uploaded files.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_UPLOADING_FILE = function (reason) {
  this.show("Error Uploaded File", "BlockPy encountered an error while uploading the file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_DOWNLOADING_FILE = function (reason) {
  this.show("Error Downloading File", "BlockPy encountered an error while downloading a file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_RENAMING_FILE = function (reason) {
  this.show("Error Renaming File", "BlockPy encountered an error while renaming a file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_DELETING_FILE = function (reason) {
  this.show("Error Deleting File", "BlockPy encountered an error while deleting a file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["partId", "part_id", "", "string", "The Part ID of an Assignment that this editor is responsible for. Assignments can have regions (\"Parts\") that behave independently to the user but all correspond to the same assignment on the backend. Blank corresponds to the full document. Note that most assignment settings will apply UNIVERSALLY across all parts, including the on_run.py and the other settings on this page."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle (and pygame) output is saved whenever the program uses it."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["preloadAllFiles", "preload_all_files", false, "bool", "If checked, then the students can upload and use images and other files. This preloads all available files and images. You can filter them using the Preloaded Files setting."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["hideTraceButton", "hide_trace_button", false, "bool", "If checked, then the Trace button is not shown."], ["smallLayout", "small_layout", false, "bool", "If checked, then the interface fits into a smaller region."], ["hasClock", "has_clock", false, "bool", "If checked, then a clock is shown in the top right corner."], ["preloadFiles", "preload_files", "", "string", "A JSON structure representing the files that should be loaded on start from the remote, as if they were local."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-preload-files\" class=\"col-sm-2 col-form-label text-right\">Preloaded Files:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-preload-files\"\n                data-bind=\"value: assignment.settings.preloadFiles\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("preloadFiles"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-part-id\" class=\"col-sm-2 col-form-label text-right\">Part ID:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-part-id\"\n                data-bind=\"value: configuration.partId\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("partId"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/images.js":
/*!******************************!*\
  !*** ./src/editor/images.js ***!
  \******************************/
/*! exports provided: IMAGE_EDITOR_HTML, ImageEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_EDITOR_HTML", function() { return IMAGE_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageEditor", function() { return ImageEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond */ "filepond");
/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var IMAGE_EDITOR_HTML = "\n     <div>\n        <strong>Images and Files</strong>\n        <!--<div class=\"blockpy-editor-images-filepond\"></div>-->\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-label\" for=\"blockpy-editor-images-upload-file\">File:</label>\n            </div>\n            <div class=\"col-sm-10\">\n                <input type=\"file\" class=\"form-control blockpy-editor-images-upload-file\" id=\"blockpy-editor-images-upload-file\"\n            name=\"blockpy-editor-images-upload-file\">\n                <small class=\"form-text text-muted\">\n                    The file to make available in your code\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\" data-bind=\"visible: ui.editors.images.canChoosePlacement()\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-label\" for=\"blockpy-editor-images-upload-placement\">Placement:</label>\n            </div>\n            <div class=\"col-sm-10\">\n                <select id=\"blockpy-editor-images-upload-placement\" name=\"blockpy-editor-images-upload-placement\"\n                    class=\"form-control blockpy-editor-images-upload-placement\">\n                    <option value=\"submission\" selected>Only your submission</option>\n                    <option value=\"assignment\">For all submissions of this assignment</option>\n                    <option value=\"course\">Across the entire course</option>\n                    <option value=\"user\">For just your user account</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    The placement of the file in the system. This controls whether other users can see the file.\n                    If you want to provide a file to all students for just this specific problem, then you should\n                    use <code>For all submissions of this assignment</code>. If you want to use this same image\n                    across other assignments (including assignments within this assignment group), then you should\n                    use <code>Across the entire course</code>.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-label\" for=\"blockpy-editor-images-upload-filename\">Filename:</label>\n            </div>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control blockpy-editor-images-upload-filename\" id=\"blockpy-editor-images-upload-filename\"\n                             name=\"blockpy-editor-images-upload-filename\">\n                <small class=\"form-text text-muted\">\n                    The filename that will be made available in the code. This should be a valid filename for the\n                    system, and should not contain spaces or special characters. It should also have a valid file\n                    extension (e.g., <code>.png</code>, <code>.jpg</code>, <code>.txt</code>).\n                </small>\n            </div>\n        </div>\n\n        <div class=\"form-group row\">    \n            <button data-bind=\"click: ui.editors.images.uploadFile\" class=\"btn btn-success\">Upload</button>\n            \n            <button data-bind=\"click: ui.editors.images.reloadImages\"\n                class=\"btn btn-outline-secondary float-right\"\n            >Reload Available Images</button>\n        </div>\n        \n        <strong>Available Files</strong>\n        <!-- ko if: display.uploadedFiles() !== null -->\n            <ul>\n                <!-- ko foreach: { data: Object.keys(display.uploadedFiles()), as: 'placement' } -->\n                <li>\n                    <strong data-bind=\"text: $data[0].toUpperCase() + $data.slice(1)\"></strong>:\n                    <table class=\"table table-striped table-bordered table-hover table-sm\">\n                        <thead>\n                            <tr>\n                                <th>Filename</th>\n                                <th>Preview</th>\n                                <th>Actions</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                    <!-- ko foreach: { data: $root.display.uploadedFiles()[placement], as: 'filename' } -->\n                        <tr>\n                            <td>\n                                <code data-bind=\"text: filename[0]\"></code>\n                            </td>\n                            <td>\n                                <details>\n                                    <summary><img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                        width=\"30px\" height=\"30px\" onerror=\"this.style.display='none'\"/>\n                                    </summary>\n                                    <img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                        onerror=\"this.style.display='none'\"/>\n                                </details>\n                            </td>\n                            <td>\n                                <button class=\"btn btn-danger\" \n                                    data-bind=\"click: $root.ui.editors.images.deleteFile.bind(filename[0]),\n                                               visible: $root.ui.editors.images.canModify(placement)\">Delete</button>\n                                <button class=\"btn btn-danger\" \n                                    data-bind=\"click: $root.ui.editors.images.renameFile.bind(filename[0]),\n                                               visible: $root.ui.editors.images.canModify(placement)\">Rename</button>\n                            </td>\n                        </tr>\n                    <!-- /ko -->\n                    </table>\n                </li>\n                <!-- /ko -->\n            </ul>\n        <!-- /ko -->\n    </div>\n";

var ImageEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ImageEditorView, _AbstractEditor);

  var _super = _createSuper(ImageEditorView);

  function ImageEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ImageEditorView);

    _this = _super.call(this, main, tag);
    _this.tagUploadFileButton = _this.tag.find(".blockpy-editor-images-upload-file");
    _this.tagUploadFilePlacement = _this.tag.find(".blockpy-editor-images-upload-placement");
    _this.tagUploadFileName = _this.tag.find(".blockpy-editor-images-upload-filename");

    _this.tagUploadFileButton.on("change", function (event) {
      _this.tagUploadFileName.val(event.target.files[0].name);
    });

    return _this;
  }

  _createClass(ImageEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ImageEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      var uploadedFiles = this.main.model.display.uploadedFiles();

      if (uploadedFiles === null) {
        this.reloadImages();
      }

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // const target = this.tag.find(".blockpy-editor-images-filepond")[0];
      //console.log(target);

      /*const uploadUrl = new URL(this.main.model.configuration.urls["uploadFile"]);
      uploadUrl.searchParams.set("directory", this.main.model.assignment.id());
      uploadUrl.searchParams.set("placement", "submission");*/
      // this.filepond = FilePond.create(target, {
      //     //files: [],
      //     allowMultiple: true,
      //     server: {
      //         url: this.main.model.configuration.urls["downloadFile"],
      //         load: (source, load) => {
      //             const params = new URL(source, window.location.origin).searchParams;
      //             this.main.components.server.downloadFile(
      //                 params.get("placement"),
      //                 params.get("directory"),
      //                 params.get("filename"),
      //                 (response) => {
      //                     load(new File([response], params.get("filename")));
      //                 }
      //             );
      //             console.log(source, load);
      //         },
      //         process: {
      //             url: this.main.model.configuration.urls["uploadFile"],
      //             // url: "blockpy/upload_file?placement=assignment&directory="+this.main.model.assignment.id(),
      //         }
      //     }
      // });
      // console.log(this.filepond);

      /*
      this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
        // Notify relevant file of changes to BM
      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);*/
    }
  }, {
    key: "reloadImages",
    value: function reloadImages() {
      var _this2 = this;

      this.main.components.server.listUploadedFiles(function (response) {
        if (response.success) {
          _this2.main.model.display.uploadedFiles(response.files);

          _this2.main.components.fileSystem.loadRemoteFiles(response.files); // const allFiles = [];
          // Object.entries(response.files).forEach(([group, files]) => {
          //     files.forEach(([filename, url]) => allFiles.push({
          //         source: url,
          //         options: {
          //             type: "local"
          //         }
          //     }));
          // });
          // this.filepond.addFiles(allFiles);

        } else {
          _this2.main.components.dialogs.ERROR_LISTING_UPLOADED_FILES(response.message);
        }
      });
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {}
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      /*this.dirty = !this.dirty;
      if (this.dirty) {
          this.dirty = true;
          this.file.handle(this.codeMirror.getValue());
          this.dirty = false;
      }*/
    }
  }, {
    key: "getPlacementDirectory",
    value: function getPlacementDirectory(placement) {
      switch (placement) {
        case "submission":
          return this.main.model.submission.id();

        case "assignment":
          return this.main.model.assignment.id();

        case "course":
          return this.main.model.course.id();

        case "user":
          return this.main.model.user.id();

        default:
          return null;
      }
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var _this3 = this;

      this.main.components.server.uploadFile(this.tagUploadFilePlacement.val(), this.getPlacementDirectory(this.tagUploadFilePlacement.val()), this.tagUploadFileName.val(), this.tagUploadFileButton[0].files[0], function (response) {
        if (response.success) {
          _this3.reloadImages();
        } else {
          _this3.main.components.dialogs.ERROR_UPLOADING_FILE(response.message);
        }
      });
    }
  }, {
    key: "deleteFile",
    value: function deleteFile(fileInfo) {
      var _this4 = this;

      var _fileInfo = _slicedToArray(fileInfo, 2),
          filename = _fileInfo[0],
          url = _fileInfo[1];

      var queryParams = new URL(url, window.location.origin).searchParams;
      this.main.components.server.uploadFile(queryParams.get("placement"), queryParams.get("directory"), filename, "", function (response) {
        if (response.success) {
          _this4.reloadImages();
        } else {
          _this4.main.components.dialogs.ERROR_DELETING_FILE(response.message);
        }
      }, true);
    }
  }, {
    key: "renameFile",
    value: function renameFile(fileInfo) {
      var _this5 = this;

      var _fileInfo2 = _slicedToArray(fileInfo, 2),
          filename = _fileInfo2[0],
          url = _fileInfo2[1];

      var queryParams = new URL(url, window.location.origin).searchParams;
      var newFilename = prompt("Enter the new filename for this file:", filename);

      if (newFilename) {
        this.main.components.server.renameFile(queryParams.get("placement"), queryParams.get("directory"), filename, newFilename, function (response) {
          if (response.success) {
            _this5.reloadImages();
          } else {
            _this5.main.components.dialogs.ERROR_RENAMING_FILE(response.message);
          }
        });
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();

      _get(_getPrototypeOf(ImageEditorView.prototype), "exit", this).call(this, newFilename, oldEditor); // if (this.filepond) {
      //     this.filepond.destroy();
      // }

    }
  }]);

  return ImageEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ImageEditor = {
  name: "Image",
  extensions: ["?images.blockpy"],
  constructor: ImageEditorView,
  template: IMAGE_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface */ "./src/interface.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */



var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> <span data-bind=\"text: ui.execute.runLabel\"></span>\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() && !ui.smallLayout()-->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\" data-bind=\"hidden: ui.smallLayout\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\" data-bind=\"hidden: ui.smallLayout\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\">\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"fas fa-ellipsis-v\"></span>\n                    <span class=\"sr-only\">Toggle Extra Features</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-run-quietly notransition' role=\"button\"\n                        href=\"\"\n                        data-bind=\"click: ui.execute.runQuietly,\n                                    css: {'blockpy-run-running': ui.execute.isRunning}\">\n                        <span class=\"fas fa-comment-slash\"></span> <span data-bind=\"text: ui.execute.runQuietlyLabel\"></span>\n                    </a>\n                </div>\n            </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHook: function imageDownloadHook(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        //const uuid = window.URL.createObjectURL(new Blob([])).substring(31);
        return new Promise(function (resolve, reject) {
          var submissionId = main.model.submission.id();
          main.components.server.uploadFile("submission", submissionId, blob.name, blob, function (response) {
            resolve(JSON.stringify(response.endpoint)); //resolve(JSON.stringify(main.model.configuration.urls["downloadFile"] + `?placement=submission&directory=${submissionId}&filename=${blob.name}`));
          }); //return Promise.resolve("Image("+JSON.stringify(URL.createObjectURL(blob))+")");
          //return Promise.resolve(JSON.stringify(URL.createObjectURL(blob)));
        });
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        //return `Image("${oldUrl}")`;
        return "\"".concat(oldUrl, "\"");
      } //'height': '2000px'

    }); // TODO: Prevent INS and OVR mode (... this.bm.textEditor.codeMirror.

    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.lineTraceSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
        this.lineTraceSubscription = this.main.model.ui.trace.highlightedLine.subscribe(function (lines) {
          _this3.bm.clearHighlightedLines("editor-traced-line");

          _this3.bm.setHighlightedLines(lines, "editor-traced-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }

      if (this.lineTraceSubscription) {
        this.lineTraceSubscription.dispose();
        this.lineTraceSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      }); // Small Layout Stuff

      this.oldHeight = null;

      if (this.main.model.ui.smallLayout()) {
        this.useSmallLayout();
      }

      this.main.model.ui.smallLayout.subscribe(function (useSmallLayout) {
        if (useSmallLayout) {
          _this4.useSmallLayout();
        } else if (_this4.oldHeight !== null) {
          _this4.bm.configuration.height = _this4.oldHeight;

          _this4.bm.textEditor.resizeResponsively();

          _this4.oldHeight = null;
        }
      });
    }
  }, {
    key: "useSmallLayout",
    value: function useSmallLayout() {
      this.bm.textEditor.updateGutter({
        indentSidebar: false
      });
      this.oldHeight = this.bm.configuration.height;
      this.bm.configuration.height = 300; // TODO: Parameterize this

      this.bm.textEditor.resizeResponsively();
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.configuration.partId.subscribe(function (changed) {// TODO: Handle part id changing after everything is loaded
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py", ".reading"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-quiz")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
/* harmony import */ var _editor_images__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./editor/images */ "./src/editor/images.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */










/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"], _editor_images__WEBPACK_IMPORTED_MODULE_9__["ImageEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "', class: ui.editors.width\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      var disableFeedback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(disableFeedback); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var disableFeedback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback() && !disableFeedback) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          _this2.configuration.provideSecretError();

          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Function to convert filenames to URLs

      Sk.fileToURL = this.getUrlFromFilename.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // TODO: Make this set by the system so we can use our own servers in practice
        emojiProxy: function emojiProxy(part) {
          return "https://twemoji.maxcdn.com/v/13.1.0/svg/".concat(part.toLowerCase(), ".svg");
        },
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
  }, {
    key: "getUrlFromFilename",
    value: function getUrlFromFilename(filename) {
      var found = this.main.components.fileSystem.filesToUrls[filename];

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      }

      return found;
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../files */ "./src/files.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found, but not __main__ modules

      this.sysmodules = this.clearExistingStudentImports(); // Horrific hack, to prevent Tifa from caching a bad version of the students' import

      Sk.clearExistingStudentImports = this.clearExistingStudentImports;
      return this;
    }
  }, {
    key: "print",
    value: function print(value) {
      _get(_getPrototypeOf(InstructorConfiguration.prototype), "print", this).call(this, value);

      console.info("Printed:", value);
    }
  }, {
    key: "clearExistingStudentImports",
    value: function clearExistingStudentImports() {
      var sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      if (sysmodules !== undefined) {
        var _iterator = _createForOfIteratorHelper(this.getAllFilenames()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var filename = _step.value;
            var skFilename = new Sk.builtin.str(filename);
            /*if (sysmodules.quick$lookup(skFilename)) {
                sysmodules.pop$item(skFilename);
            }*/

            sysmodules.pop$item(skFilename);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return sysmodules;
    }
  }, {
    key: "getAllStudentFiles",
    value: function getAllStudentFiles() {
      var files = {
        "answer.py": this.main.model.ui.files.getStudentCode()
      }; // Skip special instructor files

      this.main.model.assignment.extraInstructorFiles().forEach(function (file) {
        if (!"!^$#".includes(file.filename()[0])) {
          files[Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(file.filename())] = file.contents();
        }
      }); // Include normal student extra files

      this.main.model.submission.extraFiles().forEach(function (file) {
        files[file.filename()] = file.contents();
      });
      return files;
    }
  }, {
    key: "getAllFilenames",
    value: function getAllFilenames() {
      function clean(filename) {
        filename = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(filename);

        if (filename.endsWith(".py")) {
          filename = filename.slice(0, -3);
        }

        return filename;
      }

      return ["__main__", "_instructor"].concat(_toConsumableArray(this.main.model.assignment.extraInstructorFiles().map(function (file) {
        return "_instructor." + clean(file.filename());
      })), _toConsumableArray(this.main.model.submission.extraFiles().map(function (file) {
        return clean(file.filename());
      })));
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      // TODO: Figure out why parameters are misaligned..?
      if (data.v === "OPENAI") {
        return this.main.components.server.openaiProxy(timeout.v);
      } else {
        return _get(_getPrototypeOf(InstructorConfiguration.prototype), "openURL", this).call(this, url, data, timeout);
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      console.log(">>>", this.main.model.execution.input(), this.main.model.execution.inputIndex());

      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\n# MAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, "['evaluation'])\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(_on_run__WEBPACK_IMPORTED_MODULE_2__["INSTRUCTOR_MARKER"], "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";

      var studentFiles = this.getAllStudentFiles();
      studentFiles["evaluation"] = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      console.log(">>>", instructorCode);
      var lineOffset = Object(_on_run__WEBPACK_IMPORTED_MODULE_2__["findActualInstructorOffset"])(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: findActualInstructorOffset, INSTRUCTOR_MARKER, NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findActualInstructorOffset", function() { return findActualInstructorOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSTRUCTOR_MARKER", function() { return INSTRUCTOR_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function findActualInstructorOffset(instructorCode) {
  var index = instructorCode.indexOf(INSTRUCTOR_MARKER);
  var before = instructorCode.slice(0, index);
  var match = before.match(NEW_LINE_REGEX);
  return match ? 1 + match.length : 0;
}
var INSTRUCTOR_MARKER = "###Run the actual instructor code###";
var NEW_LINE_REGEX = /\n/g;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentFiles);
  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom bakery import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          files=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(INSTRUCTOR_MARKER, "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa(); // Put the input index back to the front, so we can replay inputs

      this.main.model.execution.inputIndex(1);
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentFiles = this.getAllStudentFiles();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      var lineOffset = findActualInstructorOffset(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;
      //lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      /*
      TODO: Interesting situation. If you have an instructor-file (not a student-file),
      then it gets imported into sysmodules as `_instructor.MODULE_NAME`. But the instructor
      script will attempt to import it as `MODULE_NAME`, and fail. UNLESS the *student* has
      previously imported that module successfully. So there's a common case here where the
      students' code fails to import the module THEREBY breaking the instructor code.
       */

      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode();

      if (this.main.model.assignment.settings.disableStudentRun()) {
        this.code = "";
      } //this.code = this.main.model.submission.code();


      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };

      if (typeof Sk.environ == "undefined") {
        Sk.environ = new Sk.builtin.dict();
      }

      var printerTag = this.main.components.console.printerTag,
          width = printerTag.width() - 50,
          height = Math.max(300, printerTag.height() - 50);
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_WIDTH"), new Sk.builtin.int_(Math.round(width)));
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_HEIGHT"), new Sk.builtin.int_(Math.round(height)));
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      this.lastStep();
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "trace": _this2.engine.executionBuffer.trace,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        if (Sk.builtinFiles && Sk.builtinFiles["files"][filename] !== undefined) {
          return Sk.builtinFiles["files"][filename];
        } else {
          throw new Sk.builtin.OSError("File not found: " + filename);
        }
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring, astName) {
      if (filename === "answer.py") {
        /*if (execStack) {
            console.log(execStack.map(([n, o]) => [n, {...o}]));
        }*/
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(_objectSpread(_objectSpread({}, globals), locals)); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring,
          "ast": astName
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear("Execution finished. No errors to report.");
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\"\n            data-bind=\"class: ui.console.size\">\n\n    <div>\n    <!-- Feedback/Trace Visibility Control -->\n    <!-- ko ifnot: ui.secondRow.hideTraceButton -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    <!-- /ko -->\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n        <small data-bind=\"click: ui.feedback.resetScore,\n                          visible: display.instructor() && execution.feedback.label() && submission.score() > 0\"\n            class=\"text-muted\" style=\"cursor: pointer\"><u>(reset)</u></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n    </div>\n    <div style=\"position: relative;\">\n        <!-- The thank you message will appear above the span -->\n        <span class=\"blockpy-feedback-thank-you\">Thank you!</span>\n    </div>\n    <small class=\"blockpy-feedback-response-full\" style=\"text-align: right\"\n        data-bind=\"visible: ui.feedback.provideRatings() && execution.feedback.label() && display.showRating()\">\n        <span style=\"cursor: pointer;\" class=\"far fa-minus-square\"\n            data-bind=\"click: ui.feedback.flipRating\"></span>\n        Rate this Feedback:\n        <span style=\"cursor: pointer; font-size: 20px\" class=\"blockpy-rating fa-thumbs-up\"\n            data-bind=\"click: ()=>ui.feedback.rate('thumbs-up'),\n                        css: ui.feedback.hasRatedClass\"></span>\n<!--        <span style=\"cursor: pointer; font-size: 20px\" class=\"blockpy-rating fa-meh\"-->\n<!--            data-bind=\"click: ()=>ui.feedback.rate('meh'),-->\n<!--                        css: ui.feedback.hasRatedClass\"></span>-->\n        <span style=\"cursor: pointer; font-size: 20px\" class=\"blockpy-rating fa-thumbs-down\"\n            data-bind=\"click: ()=>ui.feedback.rate('thumbs-down'),\n                        css: ui.feedback.hasRatedClass\"></span>\n    </small>\n    <small class=\"blockpy-feedback-response-collapsed\" \n        style=\"position: absolute; right: 0; bottom: 0\"\n        data-bind=\"visible: execution.feedback.label() && !display.showRating()\">\n        <span style=\"cursor: pointer; vertical-align: middle\" class=\"far fa-plus-square\"\n            data-bind=\"click: ui.feedback.flipRating\"></span> Rate\n    </small>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 700);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Ready";
      this.feedbackModel.message(message);
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
      this.category.off("click");
      this.main.model.display.hasRated(false);
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults);
      this.category.off("click");

      if (this.main.model.display.instructor()) {
        this.updateFullFeedback(executionResults);
      } // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);


      this.notifyFeedbackUpdate();
    }
  }, {
    key: "processSingleFeedback",
    value: function processSingleFeedback(element) {
      var title = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("title")).toString();
      var category = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["capitalize"])(element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("category")).toString());
      var kind = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("kind")).toString();
      var active = Sk.misceval.isTrue(element);
      var message = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("message")).toString();
      var unused_message = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("unused_message")).toString();
      message = message === "None" ? unused_message : message;
      var justification = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("justification")).toString();
      var parent = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("parent"));
      var hasParent = !Sk.builtin.checkNone(parent);
      var score = element.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("resolved_score"));
      score = score === Sk.builtin.none.none$ ? "" : score.tp$name === "float" ? "+" + Math.round(score.v * 100).toString() + "%" : score.toString();
      return [element, parent, "\n        <div class=\"list-group-item flex-column align-items-start\" ".concat(hasParent ? "style='margin-left: 50px;'" : "", ">\n            <div class=\"d-flex w-100 justify-content-between align-items-center\">\n                <span><strong class=\"mb-1\" style=\"").concat(active ? "" : "text-decoration: line-through;", "\">").concat(title, "</strong> (").concat(category, " - ").concat(kind, ")</span>\n                <span class=\"badge badge-info badge-pill\">").concat(score, "</span>\n            </div>\n            ").concat(active ? "" : "<div>(Muted - Not shown to student)</div>", "\n            <div class=\"mb-1 p-1 feedback-expand-on-click feedback-shrunk\">\n                ").concat(message, "\n            </div>\n            <small style=\"white-space: pre\">").concat(justification, "</small>\n        </div>\n        ")];
    }
  }, {
    key: "updateFullFeedback",
    value: function updateFullFeedback(executionResults) {
      var _this4 = this;

      console.log(executionResults);

      if (!("MAIN_REPORT" in executionResults)) {
        return;
      }

      var mainReport = executionResults.MAIN_REPORT;
      var feedback = mainReport.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("feedback"));

      if (!feedback) {
        return;
      }

      var feedbacks = [];
      Sk.misceval.iterFor(feedback.tp$iter(), function (element) {
        feedbacks.push(_this4.processSingleFeedback(element));
      });
      Sk.misceval.iterFor(mainReport.tp$getattr(new _utilities__WEBPACK_IMPORTED_MODULE_0__["pyStr"]("ignored_feedback")).tp$iter(), function (element) {
        feedbacks.push(_this4.processSingleFeedback(element));
      });
      var parents = new Map();

      for (var i = 0; i < feedbacks.length; i += 1) {
        var _feedbacks$i = _slicedToArray(feedbacks[i], 3),
            element = _feedbacks$i[0],
            parent = _feedbacks$i[1],
            text = _feedbacks$i[2];

        var hasParent = !Sk.builtin.checkNone(parent);

        if (hasParent) {
          if (!parents.has(parent)) {
            parents.set(parent, []);
          }

          parents.get(parent).push(text);
        } else {
          if (!parents.has(element)) {
            parents.set(element, []);
          }

          parents.get(element).unshift(text);
        }
      }

      feedbacks = _toConsumableArray(parents.values()).flat();
      this.category.on("click", function () {
        _this4.main.components.dialog.show("Full Feedback Information", '<div class="list-group">' + feedbacks.join("\n") + "</div>");

        $(".feedback-expand-on-click").on("click", function (event) {
          $(event.target).toggleClass("feedback-shrunk");
        });
      });
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);

        if (this.shouldScrollIntoView()) {
          this.scrollIntoView();
        }
      }
    }
  }, {
    key: "shouldScrollIntoView",
    value: function shouldScrollIntoView() {
      return !this.main.model.ui.smallLayout();
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this5 = this;

      return error.traceback.map(function (frame) {
        if (!frame) {
          return "??";
        }

        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this5.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, chompSpecialFile, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chompSpecialFile", function() { return chompSpecialFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible, class: ui.files.width\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <!-- ko if: $root.display.instructor() -->\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?images.blockpy'),\n                           click: ui.files.add.bind($data, '?images.blockpy')\">Images</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n        <!-- /ko -->\n        <!-- ko ifnot: $root.display.instructor() -->\n        <div class=\"dropdown-menu dropdown-menu-right\">\n        <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n        <!-- /ko -->\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
function chompSpecialFile(filename) {
  if ("!^?&$*#".includes(filename[0])) {
    return filename.slice(1);
  } else {
    return filename;
  }
}
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(filename, _contents) {
  return {
    filename: function (_filename) {
      function filename() {
        return _filename.apply(this, arguments);
      }

      filename.toString = function () {
        return _filename.toString();
      };

      return filename;
    }(function () {
      return filename;
    }),
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var _filename2 in files) {
      if (files.hasOwnProperty(_filename2)) {
        modelFiles.push(makeModelFile(_filename2, files[_filename2]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    if (modelFileList) {
      modelFileList(modelFiles);
    } else {
      return modelFiles;
    }
  } else {
    if (modelFileList) {
      modelFileList([]);
    } else {
      return [];
    }
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.remoteFiles_ = {};
    this.filesToUrls = {};
    /*main.model.configuration.container.find(".blockpy-file-instructor").toggle(this.main.model.display.instructor());
    this.main.model.display.instructor.subscribe((visiblity)=> {
        main.model.configuration.container.find(".blockpy-file-instructor").toggle(visiblity);
    });*/
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "renameFile",
    value: function renameFile(source, destination) {
      if (UNRENAMABLE_FILES.indexOf(source) !== -1) {
        return false;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);
      var remoteVersion = this.remoteFiles_[name];

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(hiddenVersion, defaultVersion, studentVersion, generatedVersion, remoteVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion, remoteVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion, remoteVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }, {
    key: "loadRemoteFiles",
    value: function loadRemoteFiles() {
      var _this3 = this;

      var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // Clear existing remote files (?)

      /*
      Object.getOwnPropertyNames(this.remoteFiles_).forEach(function (prop) {
          delete this.remoteFiles_[prop];
      });*/
      var model = this.main.model;
      var preloadFiles = model.assignment.settings.preloadFiles() || model.assignment.settings.preloadAllFiles();

      if (!preloadFiles && !files) {
        return null;
      }

      if (model.assignment.settings.preloadFiles()) {
        try {
          files = JSON.parse(preloadFiles);
        } catch (e) {
          console.error("Failed to preload files, invalid structure: ", e);
          return null;
        }

        this.downloadRemoteFiles(files);
      } else if (files) {
        this.downloadRemoteFiles(this.reorganizeFiles(files));
      } else {
        this.main.components.server.listUploadedFiles(function (data) {
          _this3.downloadRemoteFiles(_this3.reorganizeFiles(data.files));
        });
      }
    }
  }, {
    key: "reorganizeFiles",
    value: function reorganizeFiles(files) {
      var _this4 = this;

      var organized = {};
      Object.entries(files).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            placement = _ref2[0],
            placedFiles = _ref2[1];

        placedFiles.forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              filename = _ref4[0],
              url = _ref4[1];

          var searchParams = new URL(url, window.location.origin).searchParams;
          var directory = searchParams.get("directory");
          var placement = searchParams.get("placement");

          if (!(placement in organized)) {
            organized[placement] = {};
          }

          if (!(directory in organized[placement])) {
            organized[placement][directory] = {};
          }

          organized[placement][directory][filename] = true;
          _this4.filesToUrls[filename] = url;
        });
      });
      return organized;
    }
  }, {
    key: "downloadRemoteFiles",
    value: function downloadRemoteFiles(files) {
      var _this5 = this;

      var oldRemainingFiles = Object.keys(this.remoteFiles_);
      Object.entries(files).forEach(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            placement = _ref6[0],
            placementData = _ref6[1];

        Object.entries(placementData).forEach(function (_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2),
              directory = _ref8[0],
              directoryData = _ref8[1];

          Object.entries(directoryData).forEach(function (_ref9) {
            var _ref10 = _slicedToArray(_ref9, 2),
                filename = _ref10[0],
                renamedFile = _ref10[1];

            if (renamedFile === true) {
              renamedFile = filename;
            }

            if (!(renamedFile in _this5.remoteFiles_)) {
              _this5.main.components.server.downloadFile(placement, directory, filename, function (data) {
                _this5.remoteFiles_[renamedFile] = makeMockModelFile(renamedFile, data);
                delete oldRemainingFiles[renamedFile];
              });
            }
          });
        });
      }); // TODO: Clean up the old files after all the new ones are loaded
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row' data-bind=\"hidden: ui.smallLayout()\">\n         \n         <!-- Description -->\n         <div class='col-md-9 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-3 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <!-- Fullscreen button -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\">\n                <span class='fas' data-bind=\"class: ui.menu.textFullscreen\"></span>\n            </button>\n            <!-- Edit Queued Inputs -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\">\n                <span class='fas fa-list-alt'></span>\n            </button>\n            <!-- Toggle Image Rendering -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-toggle=\"button\"\n                data-bind=\"click: ui.menu.toggleImages\" title=\"Toggle Images\">\n                <span class=\"fas fa-images\"></span>\n            </button>\n            <!-- Pink Bug for actual errors -->\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n            <span data-bind=\"hidden: ui.menu.showClock\" class=\"blockpy-menu-clock\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- ko if: ui.smallLayout() -->\n    <!-- Small layout View as instructor -->\n    <div class=\"form-check\"\n         data-bind=\"visible: ui.role.isGrader\">\n        <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n            data-bind=\"checked: display.instructor\">\n        <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n            View as instructor\n        </label>\n    </div>\n    <!-- ko if: ui.files.visible() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    <!-- /ko -->\n    \n    <div class='row'>\n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div data-bind=\"class: ui.secondRow.width\">\n    <div class='row'>\n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n    </div>\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible() && !ui.smallLayout() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    \n    </div>\n    \n    \n    <!-- Row 5: Footer Row -->    \n    <!-- ko if: ui.footer.visible -->\n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};

BlockPyServer.prototype.authorizeHeader = function (currentSettings) {
  if (!currentSettings) {
    currentSettings = {};
  }

  var accessToken = this.main.model.configuration.accessToken();

  if (accessToken) {
    if (!currentSettings.headers) {
      currentSettings.headers = {};
    }

    currentSettings.headers["Authorization"] = "Bearer " + accessToken;
  }

  return currentSettings;
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var configuration = this.main.model.configuration;
  var now = new Date();
  var microseconds = now.getTime();
  var result = {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode(),
    "part_id": configuration.partId()
  };
  return result;
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  if (endpoint in this.main.model.status) {
    this.main.model.status[endpoint](status);
    this.main.model.status[endpoint + "Message"](message || "");
  }
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.ajax(_objectSpread({
      url: _this4.urls[endpoint],
      type: "post",
      data: data
    }, _this4.authorizeHeader())).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.ajax(_objectSpread({
      url: _this5.urls[endpoint],
      data: data,
      type: "post"
    }, _this5.authorizeHeader())).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  var extraSettings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  this.showOverlay(attempts);
  return $.ajax(_objectSpread({
    type: "POST",
    url: this.urls[endpoint],
    data: data
  }, this.authorizeHeader(extraSettings))).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure, extraSettings);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.listUploadedFiles = function (callback) {
  var _this10 = this;

  if (this.main.model.ui.server.isEndpointConnected("listUploadedFiles")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("listUploadedFiles", data, 2, callback, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_LISTING_UPLOADED_FILES(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.uploadFile = function (placement, directory, filename, contents, callback) {
  var _this11 = this;

  var deleteInstead = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("uploadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    data["contents"] = contents;

    if (deleteInstead) {
      data["delete"] = true;
    }

    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("uploadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      if (deleteInstead) {
        _this11.main.components.dialog.ERROR_DELETING_FILE(textStatus);
      } else {
        _this11.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);
      }

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.downloadFile = function (placement, directory, filename, callback) {
  var _this12 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("downloadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("downloadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this12.main.components.dialog.ERROR_DOWNLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false,
      dataType: "text"
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.renameFile = function (placement, directory, old_filename, new_filename, callback) {
  var _this13 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("renameFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["old_filename"] = old_filename;
    data["new_filename"] = new_filename;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("renameFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this13.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("renameFile", StatusState.OFFLINE, "Server is not connected! (Rename File)");
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this14 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this14.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this14.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this15 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this15._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this15.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this15.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};

BlockPyServer.prototype.openaiProxy = function (openai_data) {
  var model = this.main.model;
  var server = this;
  var data = this.createServerData();
  data["openai_data"] = openai_data;
  return this._postBlocking(this.urls.openai_proxy, data);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  mod.clear_existing_student_imports = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("clear_existing_student_imports", arguments, 0, 0);
    Sk.clearExistingStudentImports();
  });
  mod.download_file = new Sk.builtin.func(function (placement, directory, filename) {
    Sk.builtin.pyCheckArgs("download_file", arguments, 3, 3);
    var downloadFileUrl = Sk.executionReports["model"].configuration.urls["downloadFile"];
    var combiner = downloadFileUrl.includes("?") ? "&" : "?";
    var url = "".concat(downloadFileUrl).concat(combiner, "placement=").concat(placement, "&directory=").concat(directory, "&filename=").concat(filename);
    var prom = new Promise(function (resolve, reject) {
      var xmlhttp = new XMLHttpRequest(); // TODO: Figure out if this needs headers

      xmlhttp.addEventListener("loadend", function (e) {
        resolve(Sk.ffi.remapToPy(xmlhttp.responseText));
      });
      xmlhttp.open("GET", url);
      xmlhttp.send(null);
    });
    var susp = new Sk.misceval.Suspension();
    var resolution = null;

    susp.resume = function () {
      return resolution;
    };

    susp.data = {
      type: "Sk.promise",
      promise: prom.then(function (value) {
        resolution = value;
        return value;
      }, function (err) {
        resolution = "";
        return err;
      })
    };
    return susp;
  });
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/weakref.js":
/*!***************************************!*\
  !*** ./src/skulpt_modules/weakref.js ***!
  \***************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "weakref"
  };
  /*mod.WeakSet = Sk.abstr.buildNativeClass("weakref.WeakSet", {
      constructor: function WeakSet()
  });*/

  var WeakSet = function WeakSet($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, data) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("data", "iterable", Sk.builtin.checkIterable(data));
      self.data = [];
      var iter = Sk.abstr.iter(data);
      var next;

      do {
        next = Sk.abstr.iternext(iter);

        if (next !== undefined) {
          self.data.push(new WeakRef(next));
        }
      } while (next !== undefined);

      return Sk.builtin.none.none$;
    });
    $loc.__iter__ = new Sk.builtin.func(function (self) {
      var viewOfData = [];

      for (var i = 0; i < self.data.length; i++) {
        var item = self.data[i].deref();

        if (item !== undefined) {
          viewOfData.push(item);
        }
      }

      self.data = viewOfData;
      return Sk.abstr.iter(new Sk.builtin.list(viewOfData));
    });
    /*$loc.next$ = new Sk.builtin.func(function (self) {
        return self.tp$iter();
    });*/

    $loc.add = new Sk.builtin.func(function (self, item) {
      self.data.push(new WeakRef(item));
    });
  };

  mod.WeakSet = Sk.misceval.buildClass(mod, WeakSet, "WeakSet", []);
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, AST_DESCRIPTIONS, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AST_DESCRIPTIONS", function() { return AST_DESCRIPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    <p data-bind=\"text: ui.trace.ast\"></p>\n    <p>Variables after this step:</p>\n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var AST_DESCRIPTIONS = {
  "Add": "An addition operator",
  "And": "A boolean AND operator",
  "AnnAssign": "An annotated assignment",
  "Assert": "An assert statement",
  "Assign": "An assignment statement",
  "AsyncFor": "An asychronous for loop",
  "AsyncFunctionDef": "An asychronous function definition",
  "AsyncWith": "An asychronous with statement",
  "Attribute": "An attribute lookup (access a field)",
  "AugAssign": "An augmented assignment",
  "AugLoad": "An augmented load",
  "AugStore": "An augmented store",
  "Await": "An await statement",
  "BinOp": "A binary operator",
  "BitAnd": "A bitwise AND operator",
  "BitOr": "A bitwise OR operator",
  "BitXor": "A bitwise XOR operator",
  "BoolOp": "A boolean operator",
  "Break": "A break statement",
  "Bytes": "A literal bytes string",
  "Call": "A function call",
  "ClassDef": "A class definition",
  "Compare": "A boolean comparison",
  "Constant": "A literal value",
  "Continue": "A continue statement",
  "Del": "A delete statement",
  "Delete": "A deletion",
  "Dict": "A dictionary literal",
  "DictComp": "A dictionary comprehension",
  "Div": "A division operator",
  "Ellipsis": "An ellipsis",
  "Eq": "An equality comparison operator",
  "ExceptHandler": "An except handler",
  "Expr": "An expression used as a statement",
  "Expression": "An evaluated expression",
  "ExtSlice": "A multi-dimensional slice",
  "FloorDiv": "An integer division operator",
  "For": "A FOR loop",
  "FormattedValue": "A formatted value in an f-string",
  "FunctionDef": "A function definition",
  "GeneratorExp": "A generator expression",
  "Global": "A global statement",
  "Gt": "A greater than comparison operator",
  "GtE": "A greater than or equal to comparison operator",
  "If": "An IF statement",
  "IfExp": "An IF expression",
  "Import": "An import statement",
  "ImportFrom": "An import/from statement",
  "In": "An IN operator",
  "Index": "An index",
  "Interactive": "An interactive expression",
  "Invert": "An invert operator",
  "Is": "An IS operator",
  "IsNot": "An IS NOT operator",
  "JoinedStr": "An f-string",
  "LShift": "A left shift operator",
  "Lambda": "A lambda expression",
  "List": "A list literal",
  "ListComp": "A list comprehension",
  "Load": "A load",
  "Lt": "A less than comparison operator",
  "LtE": "A less than or equal to comparison operator",
  "MatMult": "A matrix multiplication operator",
  "Mod": "A modulo operator",
  "Module": "A module",
  "Mult": "A multiplication operator",
  "Name": "A name",
  "NameConstant": "A name constant",
  "Nonlocal": "A nonlocal statement",
  "Not": "A not operator",
  "NotEq": "A not equal to comparison operator",
  "NotIn": "A NOT IN operator",
  "Num": "A numeric literal",
  "Or": "A boolean OR operator",
  "Param": "A parameter",
  "Pass": "A pass statement",
  "Pow": "A power operator",
  "RShift": "A right shift operator",
  "Raise": "A raise statement",
  "Return": "A return statement",
  "Set": "A set literal",
  "SetComp": "A set comprehension",
  "Slice": "A slice",
  "Starred": "A starred argument",
  "Store": "A store",
  "Str": "A string literal",
  "Sub": "A subtraction operator",
  "Subscript": "A subscript",
  "Suite": "A suite",
  "Try": "A try statement",
  "Tuple": "A tuple literal",
  "TypeIgnore": " a type ignore",
  "UAdd": "A unary addition operator",
  "USub": "A unary subtraction operator",
  "UnaryOp": "A unary operator",
  "While": "A while loop",
  "With": "A with statement",
  "Yield": "A yield statement",
  "YieldFrom": "A yield/from statement"
};
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod", "$free", "$cell"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = []; //console.log(variables);

      if (!this.main.model.display.traceExecution()) {
        /*if ("$cell" in variables) {
            variables = {...variables, ...variables.$cell};
        }*/

        /*if ("$free" in variables) {
            variables = {...variables, ...variables.$free};
        }*/
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1 && value !== undefined) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (property) {
        case "dataclass":
          return {
            name: property,
            type: "Decorator",
            value: "<dataclass decorator>"
          };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Parameters: " + value.func_code.co_varnames.join(", ") : " No parameters"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: arrayMove, indent, slug, capitalize, encodeHTML, firstDefinedValue, extractPart, getCurrentTime, pyInt, pyNone, pyStr, pyTuple, pyCallOrSuspend, isTrue, richCompareBool, chain, typeName, setUpModuleMethods, buildNativeClass, TypeError, ValueError, KeyError, IndexError, checkString, asnum$, remapToPy, remapToJs, getAttr, setAttr, chainOrSuspend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMove", function() { return arrayMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractPart", function() { return extractPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentTime", function() { return getCurrentTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyInt", function() { return pyInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyNone", function() { return pyNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyStr", function() { return pyStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyTuple", function() { return pyTuple; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pyCallOrSuspend", function() { return pyCallOrSuspend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTrue", function() { return isTrue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "richCompareBool", function() { return richCompareBool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeName", function() { return typeName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUpModuleMethods", function() { return setUpModuleMethods; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildNativeClass", function() { return buildNativeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeError", function() { return _TypeError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueError", function() { return ValueError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyError", function() { return KeyError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IndexError", function() { return IndexError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkString", function() { return checkString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asnum$", function() { return asnum$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remapToPy", function() { return remapToPy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remapToJs", function() { return remapToJs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAttr", function() { return getAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAttr", function() { return setAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chainOrSuspend", function() { return chainOrSuspend; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Move an element from index in an array to a new index.
 * O(n)
 * Courtesy:
 * https://stackoverflow.com/a/73877680/1718155
 * @param arr
 * @param oldIndex
 * @param newIndex
 * @returns {*}
 */
function arrayMove(arr, oldIndex, newIndex) {
  var length = arr.length;
  var itemToMove = arr[oldIndex];

  if (oldIndex === newIndex || oldIndex > length || newIndex > length) {
    return arr;
  }

  return arr.reduce(function (acc, item, index) {
    if (index === oldIndex) {
      return acc;
    }

    if (index === newIndex) {
      return oldIndex < newIndex ? [].concat(_toConsumableArray(acc), [item, itemToMove]) : [].concat(_toConsumableArray(acc), [itemToMove, item]);
    }

    return [].concat(_toConsumableArray(acc), [item]);
  }, []);
}
/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */

function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}

var DEFAULT_SECTION_PATTERN = /^(##### Part (.+))$/gm;
/**
 * Finds the given Part ID using the pattern `#### Part whatever` (on its own separate line). If the pattern
 * is not found, then null is returned. If no pattern is given (empty string or null), then the original text
 * is returned without modifications.
 * @param text
 * @param partId
 * @returns {null|*}
 */

function extractPart(text, partId) {
  if (partId === "" || partId == null) {
    return text;
  }

  var parts = text.split(DEFAULT_SECTION_PATTERN);

  for (var i = 2; i < parts.length; i += 3) {
    /* // Unnecessary assertion, but not bad to think about
    if (!parts[i-1].startsWith("#### Part ")) {
        throw "Error: part format is broken!";
    }*/
    if (parts[i] === partId) {
      var body = parts[i + 1];

      if (body && body[0] === "\n") {
        body = body.slice(1);
      }

      if (i !== parts.length - 3 && body && body.slice(-1) === "\n") {
        body = body.slice(0, -1);
      }

      return body;
    }
  }

  return null;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/

function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

function getCurrentTime() {
  var today = new Date();
  var h = Math.floor(today.getHours() % 12);
  var m = today.getMinutes(); //let s = today.getSeconds();

  if (m < 10) {
    m = "0" + m;
  } //if (s < 10) {s = "0" + s;}


  var p = "am";

  if (today.getHours() >= 12) {
    p = "pm";
  }

  return "".concat(h, ":").concat(m).concat(p);
}
var pyInt = Sk.builtin.int_;
var pyNone = Sk.builtin.none.none$;
var pyStr = Sk.builtin.str;
var pyTuple = Sk.builtin.tuple;
var pyCallOrSuspend = Sk.misceval.callsimOrSuspendArray;
var _Sk$misceval = Sk.misceval,
    isTrue = _Sk$misceval.isTrue,
    richCompareBool = _Sk$misceval.richCompareBool,
    chain = _Sk$misceval.chain;

var _Sk$abstr = Sk.abstr,
    typeName = _Sk$abstr.typeName,
    setUpModuleMethods = _Sk$abstr.setUpModuleMethods,
    buildNativeClass = _Sk$abstr.buildNativeClass;

var _Sk$builtin = Sk.builtin,
    _TypeError = _Sk$builtin.TypeError,
    ValueError = _Sk$builtin.ValueError,
    KeyError = _Sk$builtin.KeyError,
    IndexError = _Sk$builtin.IndexError,
    checkString = _Sk$builtin.checkString,
    asnum$ = _Sk$builtin.asnum$;

var _Sk$ffi = Sk.ffi,
    remapToPy = _Sk$ffi.remapToPy,
    remapToJs = _Sk$ffi.remapToJs;

var _Sk$generic = Sk.generic,
    getAttr = _Sk$generic.getAttr,
    setAttr = _Sk$generic.setAttr;

var chainOrSuspend = chain;

/***/ }),

/***/ "filepond":
/*!***************************!*\
  !*** external "FilePond" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_filepond__;

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9qc29uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL21hcmtkb3duLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3B5dGhvbi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9xdWl6LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy93ZWFrcmVmLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3RyYWNlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJGaWxlUG9uZFwiIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwia29cIiJdLCJuYW1lcyI6WyJFRElUT1JfVkVSU0lPTiIsIkJsb2NrUHkiLCJjb25maWd1cmF0aW9uIiwiYXNzaWdubWVudCIsInN1Ym1pc3Npb24iLCJpbml0TW9kZWwiLCJ1bmRlZmluZWQiLCJzZXRBc3NpZ25tZW50IiwiaW5pdE1haW4iLCJpbml0VXRpbGl0aWVzIiwiaW5pdE1vZGVsTWV0aG9kcyIsInR1cm5PbkhhY2tzIiwiaW5pdEludGVyZmFjZSIsImFwcGx5TW9kZWwiLCJpbml0Q29tcG9uZW50cyIsIm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMiLCJzdGFydCIsImtleSIsImRlZmF1bHRWYWx1ZSIsImluaXRpYWxDb25maWd1cmF0aW9uXyIsImxvY2FsU2V0dGluZ3NfIiwiaGFzIiwiZ2V0IiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsIm1vZGVsIiwidXNlciIsImlkIiwia28iLCJvYnNlcnZhYmxlIiwibmFtZSIsInJvbGUiLCJnZXRTZXR0aW5nIiwiY291cnNlSWQiLCJncm91cElkIiwiaW5zdHJ1Y3Rpb25zIiwidXJsIiwidHlwZSIsIkFzc2lnbWVudFR5cGUiLCJCTE9DS1BZIiwicG9pbnRzIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYVN0YXJ0aW5nRmlsZXMiLCJmb3JrZWRJZCIsImZvcmtlZFZlcnNpb24iLCJvd25lcklkIiwidmVyc2lvbiIsInRhZ3MiLCJzYW1wbGVTdWJtaXNzaW9ucyIsInJldmlld2VkIiwiaGlkZGVuIiwiaXBSYW5nZXMiLCJzZXR0aW5ncyIsIm1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbCIsImNvZGUiLCJleHRyYWN0UGFydCIsImV4dHJhRmlsZXMiLCJlbmRwb2ludCIsInNjb3JlIiwiY29ycmVjdCIsInN1Ym1pc3Npb25TdGF0dXMiLCJncmFkaW5nU3RhdHVzIiwiZGlzcGxheSIsImZpbGVuYW1lIiwiaW5zdHJ1Y3RvciIsIm11dGVQcmludGVyIiwicHl0aG9uTW9kZSIsIkRpc3BsYXlNb2RlcyIsIlRFWFQiLCJoaXN0b3J5TW9kZSIsImF1dG9TYXZlIiwiYmlnQ29uc29sZSIsInByZXZpb3VzQ29uc29sZUhlaWdodCIsImN1cnJlbnRDb25zb2xlSGVpZ2h0Iiwic2Vjb25kUm93U2Vjb25kUGFuZWwiLCJTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMiLCJGRUVEQkFDSyIsInByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWwiLCJ0cmFjZUV4ZWN1dGlvbiIsImxvYWRpbmdEYXRhc2V0cyIsImNoYW5nZWRJbnN0cnVjdGlvbnMiLCJ0cmlnZ2VyT25DaGFuZ2UiLCJkaXJ0eVN1Ym1pc3Npb24iLCJmdWxsc2NyZWVuIiwicGFzc2NvZGUiLCJjbGVhcklucHV0cyIsInJlbmRlckltYWdlcyIsImVkaXRvclZlcnNpb24iLCJyZWFkT25seSIsInRvU3RyaW5nIiwidXBsb2FkZWRGaWxlcyIsImJhY2t1cFN1Ym1pc3Npb25Db2RlIiwic2hvd1JhdGluZyIsImhhc1JhdGVkIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsImxpc3RVcGxvYWRlZEZpbGVzIiwibGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlIiwiZG93bmxvYWRGaWxlIiwiZG93bmxvYWRGaWxlTWVzc2FnZSIsInVwbG9hZEZpbGUiLCJ1cGxvYWRGaWxlTWVzc2FnZSIsInJlbmFtZUZpbGUiLCJyZW5hbWVGaWxlTWVzc2FnZSIsImV4dGVybmFsQVBJIiwiZXh0ZXJuYWxBUElNZXNzYWdlIiwib25FeGVjdXRpb24iLCJleGVjdXRpb24iLCJyZXBvcnRzIiwib3V0cHV0IiwiaW5wdXQiLCJpbnB1dEluZGV4Iiwic3R1ZGVudCIsImN1cnJlbnRTdGVwIiwibGFzdFN0ZXAiLCJjdXJyZW50TGluZSIsImxhc3RMaW5lIiwiY3VycmVudFRyYWNlRGF0YSIsImN1cnJlbnRUcmFjZVN0ZXAiLCJyZXN1bHRzIiwiZ2xvYmFscyIsImNhbGxzIiwic3lzbW9kdWxlcyIsImZlZWRiYWNrIiwibWVzc2FnZSIsImNhdGVnb3J5IiwibGFiZWwiLCJsaW5lc0Vycm9yIiwibGluZXNVbmNvdmVyZWQiLCJjYWxsYmFja3MiLCJzZXJ2ZXJDb25uZWN0ZWQiLCJibG9ja2x5UGF0aCIsImF0dGFjaG1lbnRQb2ludCIsImNvbnRhaW5lciIsInVybHMiLCJwYXJ0SWQiLCJhY2Nlc3NUb2tlbiIsImNvbnN0YW50cyIsImd1aSIsIm1ha2VJbnRlcmZhY2UiLCIkIiwiaHRtbCIsImFzc2lnbm1lbnRfaWQiLCJjb21wb25lbnRzIiwic2VydmVyIiwic2FtcGxlcyIsInN0YXJ0aW5nX2NvZGUiLCJleHRyYV9zdGFydGluZ19maWxlcyIsImxvYWROb1N1Ym1pc3Npb24iLCJncmFkaW5nX3N0YXR1cyIsIlN1Ym1pc3Npb25TdGF0dXNlcyIsIlVOS05PV04iLCJzdWJtaXNzaW9uX3N0YXR1cyIsInVzZXJfaWQiLCJjb3Vyc2VfaWQiLCJleHRyYV9maWxlcyIsImRhdGEiLCJjb25zb2xlIiwiZGVidWciLCJyZXNldEludGVyZmFjZSIsImZpbGVTeXN0ZW0iLCJkaXNtb3VudEV4dHJhRmlsZXMiLCJ3YXNTZXJ2ZXJDb25uZWN0ZWQiLCJmb3JrZWRfaWQiLCJmb3JrZWRfdmVyc2lvbiIsImlwX3JhbmdlcyIsIm9uX2NoYW5nZSIsIm5ld0ZpbGUiLCJvbl9ldmFsIiwib25fcnVuIiwib3duZXJfaWQiLCJsb2FkVGFncyIsImxvYWRTYW1wbGVTdWJtaXNzaW9ucyIsInNhbXBsZV9zdWJtaXNzaW9ucyIsImV4dHJhX2luc3RydWN0b3JfZmlsZXMiLCJsb2FkQXNzaWdubWVudFNldHRpbmdzIiwibG9hZFN1Ym1pc3Npb24iLCJjb3JnaXMiLCJsb2FkRGF0YXNldHMiLCJweXRob25FZGl0b3IiLCJibSIsInJlZnJlc2giLCJsb2FkUmVtb3RlRmlsZXMiLCJzZXRTdGF0dXMiLCJzZWxmIiwidWkiLCJzbWFsbExheW91dCIsInB1cmVDb21wdXRlZCIsImlzR3JhZGVyIiwiaXNDaGFuZ2VkIiwiY3VycmVudCIsInV0aWxpdGllcyIsIm1hcmtkb3duIiwicmVzZXQiLCJtZW51IiwidmlzaWJsZSIsIm9ubHlJbnRlcmFjdGl2ZSIsInRleHRGdWxsc2NyZWVuIiwiY2xpY2tGdWxsc2NyZWVuIiwiZWRpdElucHV0cyIsImRpYWxvZyIsIkVESVRfSU5QVVRTIiwidG9nZ2xlSW1hZ2VzIiwidGV4dEVkaXRvciIsImRpc2FibGVJbWFnZXMiLCJlbmFibGVJbWFnZXMiLCJjYW5NYXJrU3VibWl0dGVkIiwiY2FuQ2xvc2UiLCJ0ZXh0TWFya1N1Ym1pdHRlZCIsImlzQ29tcGxldGVkIiwiaXNTdWJtaXR0ZWQiLCJjbGlja01hcmtTdWJtaXR0ZWQiLCJhbGVydCIsImVuZ2luZSIsImRlbGF5ZWRSdW4iLCJ0b0xvd2VyQ2FzZSIsInNob3dRdWV1ZWRJbnB1dHMiLCJoaWRlUXVldWVkSW5wdXRzIiwic2hvd0Nsb2NrIiwiaGFzQ2xvY2siLCJzZWNvbmRSb3ciLCJ3aWR0aCIsImhpZGVUcmFjZUJ1dHRvbiIsImlzQWxsVmlzaWJsZSIsImhpZGVNaWRkbGVQYW5lbCIsImlzRmVlZGJhY2tWaXNpYmxlIiwiaXNUcmFjZVZpc2libGUiLCJUUkFDRSIsImlzQ29uc29sZVNob3dWaXNpYmxlIiwic3dpdGNoTGFiZWwiLCJhZHZhbmNlU3RhdGUiLCJjdXJyZW50UGFuZWwiLCJOT05FIiwibWFrZVdpZGUiLCJyZXN0b3JlUGFuZWwiLCJvbGRQYW5lbCIsInNpemUiLCJoaWRlRXZhbHVhdGUiLCJBQ1RJVkUiLCJiYWRnZSIsInJlc2V0U2NvcmUiLCJwcm92aWRlUmF0aW5ncyIsImZsaXBSYXRpbmciLCJuZXdTdGF0ZSIsInNldCIsInJhdGUiLCJyYXRpbmciLCJmaW5kIiwiZmFkZU91dCIsImZhZGVJbiIsInRoYW5rWW91IiwiYWRkQ2xhc3MiLCJzZXRUaW1lb3V0IiwicmVtb3ZlQ2xhc3MiLCJoYXNSYXRlZENsYXNzIiwidHJhY2UiLCJoaWdobGlnaHRlZExpbmUiLCJzdGVwIiwidHJhY2VEYXRhIiwibGluZSIsImFzdCIsInN1Y2Nlc3MiLCJBU1RfREVTQ1JJUFRJT05TIiwiZmlyc3QiLCJiYWNrd2FyZCIsInByZXZpb3VzIiwiTWF0aCIsIm1heCIsImZvcndhcmQiLCJuZXh0IiwibWluIiwibGFzdCIsImZpbGVzIiwiaGlkZUZpbGVzIiwiaGFzQ29udGVudHMiLCJwYXRoIiwic29tZSIsImZpbGUiLCJsZW5ndGgiLCJhZGQiLCJub3JtYWxUb29sYm94IiwiYmxvY2tFZGl0b3IiLCJUT09MQk9YRVMiLCJKU09OIiwic3RyaW5naWZ5IiwiU2FtcGxlU3VibWlzc2lvbiIsIkJsYW5rIiwibmV3RmlsZURpYWxvZyIsImRlbGV0ZUZpbGUiLCJyZW5hbWUiLCJuZXdOYW1lIiwiZ2V0U3R1ZGVudENvZGUiLCJwcmVmaXhQeSIsImdldEZpbGUiLCJzdWZmaXhQeSIsImhhbmRsZSIsImV4dHJhU3R1ZGVudEZpbGVzIiwib2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUiLCJkaXNwbGF5RmlsZW5hbWUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZGl0b3JzIiwiZ2V0RWRpdG9yIiwidmlldyIsImhpZGVFZGl0b3JzIiwibWFwIiwic3Vic3RyIiwibWFrZU1vZGVsRmlsZSIsImNvbnRlbnRzIiwiY2FuU2F2ZSIsImNhbkRlbGV0ZSIsIlVOREVMRVRBQkxFX0ZJTEVTIiwiaW5kZXhPZiIsImNhblJlbmFtZSIsIlVOUkVOQU1BQkxFX0ZJTEVTIiwidXBsb2FkIiwiYmluZCIsImRvd25sb2FkIiwiaW1wb3J0RGF0YXNldCIsIm9wZW5EaWFsb2ciLCJweXRob24iLCJjb2RlTWlycm9yIiwic2V0T3B0aW9uIiwiZ2V0T3B0aW9uIiwidXBkYXRlTW9kZSIsIm5ld01vZGUiLCJvbGRQeXRob25Nb2RlIiwiaXNIaXN0b3J5QXZhaWxhYmxlIiwiaXNFbmRwb2ludENvbm5lY3RlZCIsInR1cm5PZmZIaXN0b3J5TW9kZSIsInVwZGF0ZUVkaXRvciIsInNldFJlYWRPbmx5IiwidHVybk9uSGlzdG9yeU1vZGUiLCJyZXNwb25zZSIsImhpc3RvcnkiLCJsb2FkIiwiRVJST1JfTE9BRElOR19ISVNUT1JZIiwidG9nZ2xlSGlzdG9yeU1vZGUiLCJtb3ZlVG9TdGFydCIsIm1vdmVQcmV2aW91cyIsIm1vdmVOZXh0IiwibW9zdFJlY2VudCIsIm1vdmVUb01vc3RSZWNlbnQiLCJ1c2UiLCJpbWFnZXMiLCJieU5hbWUiLCJmaWxlSW5mbyIsInJlbG9hZEltYWdlcyIsImNhbkNob29zZVBsYWNlbWVudCIsImNhbk1vZGlmeSIsInBsYWNlbWVudCIsInNhdmUiLCJidWlsZEVkaXRvciIsIm5ld0RPTSIsImluZGV4IiwibmV3RWxlbWVudCIsImVkaXRvciIsImV4ZWN1dGUiLCJpc1J1bm5pbmciLCJydW5MYWJlbCIsInJ1biIsIlB5Z2FtZUxpYiIsInJ1bm5pbmciLCJTdG9wUHlnYW1lIiwicnVuUXVpZXRseUxhYmVsIiwicnVuUXVpZXRseSIsImV2YWx1YXRlIiwibWVzc2FnZXMiLCJjYXBpdGFsaXplIiwiZm9yY2UiLCJldmVudCIsImFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b24iLCJ0YXJnZXQiLCJwYXJlbnQiLCJmciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwiYXNzaWdubWVudFN1Ym1pc3Npb24iLCJwYXJzZSIsInJlc3VsdCIsImxvYWRBc3NpZ25tZW50RGF0YV8iLCJmaWxlTmFtZSIsInJlYWRBc1RleHQiLCJ2YWwiLCJsb2ciLCJmb290ZXIiLCJtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zIiwiU2siLCJidWlsdGluRmlsZXMiLCJpbWFnZU1vZHVsZSIsImFwcGx5QmluZGluZ3MiLCJtYWluIiwidGV4dCIsIkVhc3lNREUiLCJwcm90b3R5cGUiLCJCbG9ja1B5RGlhbG9nIiwiQmxvY2tQeUZlZWRiYWNrIiwiQmxvY2tQeVRyYWNlIiwiQmxvY2tQeUNvbnNvbGUiLCJCbG9ja1B5RW5naW5lIiwiQmxvY2tQeUZpbGVTeXN0ZW0iLCJFZGl0b3JzIiwiQmxvY2tQeVNlcnZlciIsIkJsb2NrUHlDb3JnaXMiLCJCbG9ja1B5SGlzdG9yeSIsInNob3ciLCJoaWRlIiwic3Vic2NyaWJlIiwiY2hhbmdlZCIsImNsb2NrIiwidXBkYXRlQ2xvY2siLCJnZXRDdXJyZW50VGltZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImFsdExvZ0VudHJ5IiwidXNlclN1cHBsaWVkUGFzc2NvZGUiLCJwcm9tcHQiLCJTVEFSVF9FVkFMX0hUTUwiLCJORVdfQ09OU09MRV9MSU5FX0hUTUwiLCJDT05TT0xFX0hUTUwiLCJDb25zb2xlTGluZVR5cGUiLCJIVE1MIiwiUExPVCIsIklNQUdFIiwiUFlHQU1FIiwiRFJBRlRFUiIsIlRVUlRMRSIsIkVWQUwiLCJTVEFSVF9FVkFMIiwiVkFMVUUiLCJJTlBVVCIsIlRFU1RfQ0FTRSIsIkNvbnNvbGVMaW5lIiwiY29udGVudCIsIm9yaWdpbiIsImN1cnJGaWxlbmFtZSIsImV4ZWN1dGlvbkJ1ZmZlciIsImZmaSIsInJlbWFwVG9QeSIsInJlbW92ZSIsIkNvbnNvbGVMaW5lVHVydGxlIiwid2hlcmUiLCJwcmVwZW5kIiwidG9wIiwib2Zmc2V0Iiwic2Nyb2xsVG9wIiwiQ29uc29sZUxpbmVEcmFmdGVyIiwiQ29uc29sZUxpbmVQeWdhbWUiLCJweWdhbWVPYmoiLCJpbml0aWFsaXplZCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsImNsZWFudXAiLCJjbGVhbnVwRnVuY3Rpb24iLCJsaXN0ZW5lcnMiLCJDb25zb2xlTGluZUltYWdlIiwiQ29uc29sZUxpbmVQbG90IiwiQ29uc29sZUxpbmVUZXh0IiwiZW5jb2RlZFRleHQiLCJlbmNvZGVIVE1MIiwidHJpbSIsImxpbmVEYXRhIiwidG9vbHRpcCIsIkNvbnNvbGVMaW5lVmFsdWUiLCJDb25zb2xlTGluZUlucHV0IiwicHJvbXB0TWVzc2FnZSIsImlucHV0Rm9ybSIsImlucHV0QnRuIiwiaW5wdXRHcm91cCIsImlucHV0Qm94IiwiaW5wdXRNc2ciLCJtYWtlSW50ZXJhY3RpdmUiLCJidXR0b24iLCJyZXNvbHZlT25DbGljayIsInN1Ym1pdHRlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN1Ym1pdEZvcm0iLCJ1c2VySW5wdXR0ZWRWYWx1ZSIsInF1ZXVlZElucHV0IiwicHVzaCIsInByb3AiLCJjbGljayIsImtleXVwIiwia2V5Q29kZSIsImZvY3VzIiwiQ29uc29sZUxpbmVFdmFsdWF0ZSIsIkNvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSIsInRhZyIsInByaW50ZXJUYWciLCJNSU5JTVVNX1dJRFRIIiwiTUlOSU1VTV9IRUlHSFQiLCJERUZBVUxUX0hFSUdIVCIsImhlaWdodCIsImNsZWFyIiwicmVtb3ZlQWxsIiwibGluZUJ1ZmZlciIsInBsb3RCdWZmZXIiLCJlbXB0eSIsInR1cnRsZUxpbmUiLCJUdXJ0bGVHcmFwaGljcyIsImdldFR1cnRsZUxpbmUiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImFzc2V0cyIsImxvYWRBc3NldCIsInB5Z2FtZUxpbmUiLCJkcmFmdGVyTGluZSIsInJlbmRlciIsImN1cnJlbnRQcmludGVyRGltZW5zaW9uIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJzYXZlVHVydGxlT3V0cHV0IiwiZGF0YVVybCIsInRvRGF0YVVSTCIsInBhZ2UiLCJlYWNoIiwiYXR0ciIsImxpbmVUZXh0IiwiZmx1c2giLCJjaGFyQXQiLCJzcGxpdExpbmVzIiwic3BsaXQiLCJhZGRDb250ZW50IiwiaSIsInBsb3RzIiwiaW1hZ2VEYXRhIiwiaW1hZ2UiLCJpbWFnZUJ1ZmZlciIsInZhbHVlIiwicHJpbnRlZFZhbHVlIiwiaW5wdXRCdWZmZXIiLCJzdGFydEV2YWx1YXRpb24iLCJhbmltYXRlIiwiX0lNUE9SVEVEX0RBVEFTRVRTIiwiX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTIiwic2V0QnV0dG9uTG9hZGVkIiwiYnRuIiwibG9hZGVkRGF0YXNldHMiLCJzaWxlbnRseSIsImltcG9ydHMiLCJkYXRhc2V0cyIsImZvckVhY2giLCJCbG9ja01pcnJvckJsb2NrRWRpdG9yIiwiRVhUUkFfVE9PTFMiLCJhcHBseSIsInNsdWciLCJ3aGVuIiwiZG9uZSIsImZvcmNlQmxvY2tSZWZyZXNoIiwicmVtYWtlVG9vbGJveCIsImZhaWwiLCJhcmd1bWVudHMiLCJlcnJvciIsImFsd2F5cyIsImZpbmFsaXplU3Vic2NyaXB0aW9ucyIsInVybF9yZXRyaWV2YWxzIiwicm9vdCIsImltcG9ydERhdGFzZXRzIiwiZ2V0RGF0YXNldCIsImdldFNjcmlwdCIsImdldENvbXBsZXRlIiwiZ2V0U2t1bHB0IiwiZ2V0QmxvY2tseSIsInRleHRUb0Jsb2NrcyIsImhpZGRlbkltcG9ydHMiLCJnZXRKU09OIiwiYmxvY2tweSIsImRvY3VtZW50YXRpb24iLCJib2R5IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJzbHVnZ2VkTmFtZSIsInRpdGxlTmFtZSIsImltZ1NyYyIsInRpdGxlIiwib3ZlcnZpZXciLCJhcHBlbmRUbyIsIkRJQUxPR19IVE1MIiwidGl0bGVUYWciLCJib2R5VGFnIiwiZm9vdGVyVGFnIiwib2theUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwieWVzIiwibm8iLCJtb2RhbCIsImNsb3NlIiwib25jbG9zZSIsImRyYWdnYWJsZSIsIm9uIiwiY29uZmlybSIsInllc1RleHQiLCJBU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCIsIkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQiLCJyZWFzb24iLCJFUlJPUl9MSVNUSU5HX1VQTE9BREVEX0ZJTEVTIiwiRVJST1JfVVBMT0FESU5HX0ZJTEUiLCJFUlJPUl9ET1dOTE9BRElOR19GSUxFIiwiRVJST1JfUkVOQU1JTkdfRklMRSIsIkVSUk9SX0RFTEVUSU5HX0ZJTEUiLCJFUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQiLCJFUlJPUl9TSE9XX1NUVURFTlRfRVJST1IiLCJQT1NJVElWRV9GRUVEQkFDS19GVUxMIiwiU0NSRUVOU0hPVF9CTE9DS1MiLCJFUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUyIsIk9GRkVSX0ZPUksiLCJzZXR1cFVybCIsImluc3RydWN0aW9uc0Fzc2lnbm1lbnRTZXR1cCIsImlucHV0VGV4dCIsImpvaW4iLCJjaGVja2VkIiwiaW5wdXRzIiwiZmlsZVJlYWRlciIsInNsdWdnaWZ5IiwicmVwbGFjZSIsImV4dGVuc2lvbiIsIm1pbWV0eXBlIiwiYmxvYiIsIkJsb2IiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJtc1NhdmVPck9wZW5CbG9iIiwibXNTYXZlQmxvYiIsInRlbXBvcmFyeURvd25sb2FkTGluayIsImhyZWYiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiQWJzdHJhY3RFZGl0b3IiLCJjaGFuZ2VFZGl0b3IiLCJ3YXRjaEZpbGUiLCJ1cGRhdGVkIiwib25GaWxlVXBkYXRlZCIsImRlbGV0ZWQiLCJvbkZpbGVEZWxldGVkIiwibmV3RmlsZW5hbWUiLCJvbGRFZGl0b3IiLCJ0cmFja0N1cnJlbnRGaWxlIiwibmV3RWRpdG9yIiwic3RvcFdhdGNoaW5nRmlsZSIsInBhcnNlRmlsZW5hbWUiLCJBU1NJR05NRU5UX1NFVFRJTkdTIiwiTUFaRSIsIlFVSVoiLCJSRUFESU5HIiwiZ2V0RG9jdW1lbnRhdGlvbiIsIm1ha2VTdGFydFZpZXdUYWIiLCJpY29uIiwibW9kZSIsIkFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwiLCJmaWx0ZXIiLCJzZXR0aW5nIiwicHJldHR5TmFtZSIsIndvcmQiLCJ0b1VwcGVyQ2FzZSIsIkFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUwiLCJCTE9DSyIsIlNQTElUIiwic2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyIsImNsaWVudE5hbWUiLCJzZXJ2ZXJOYW1lIiwic3RhcnRfdmlldyIsImZpZWxkVHlwZSIsImNvbmZpZ1ZhbHVlIiwiQXNzaWdubWVudFNldHRpbmdzVmlldyIsImRpcnR5IiwiY3VycmVudExpc3RlbmVyIiwidXBkYXRlSGFuZGxlIiwibmV3Q29udGVudHMiLCJBc3NpZ25tZW50U2V0dGluZ3MiLCJleHRlbnNpb25zIiwiY29uc3RydWN0b3IiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRfaGVhZGVyIiwiSU1BR0VfRURJVE9SX0hUTUwiLCJJbWFnZUVkaXRvclZpZXciLCJ0YWdVcGxvYWRGaWxlQnV0dG9uIiwidGFnVXBsb2FkRmlsZVBsYWNlbWVudCIsInRhZ1VwbG9hZEZpbGVOYW1lIiwiY3VycmVudFN1YnNjcmlwdGlvbiIsImRpYWxvZ3MiLCJjb3Vyc2UiLCJnZXRQbGFjZW1lbnREaXJlY3RvcnkiLCJxdWVyeVBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoUGFyYW1zIiwiZGlzcG9zZSIsIkltYWdlRWRpdG9yIiwiSlNPTl9FRElUT1JfSFRNTCIsIkpzb25FZGl0b3JWaWV3IiwiQ29kZU1pcnJvciIsImZyb21UZXh0QXJlYSIsInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nIiwibGluZU51bWJlcnMiLCJmaXJzdExpbmVOdW1iZXIiLCJpbmRlbnRVbml0IiwidGFiU2l6ZSIsImluZGVudFdpdGhUYWJzIiwiZXh0cmFLZXlzIiwiY20iLCJibHVyIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsIm9mZiIsIkpzb25FZGl0b3IiLCJNQVJLRE9XTl9FRElUT1JfSFRNTCIsIk1hcmtkb3duRWRpdG9yVmlldyIsIm1kZSIsImVsZW1lbnQiLCJhdXRvRG93bmxvYWRGb250QXdlc29tZSIsImZvcmNlU3luYyIsIm1pbkhlaWdodCIsInJlbmRlcmluZ0NvbmZpZyIsImNvZGVTeW50YXhIaWdobGlnaHRpbmciLCJjb2RlbWlycm9yIiwiTWFya2Rvd25FZGl0b3IiLCJtYWtlVGFiIiwiUFlUSE9OX0VESVRPUl9IVE1MIiwiSElTVE9SWV9UT09MQkFSX0hUTUwiLCJjb252ZXJ0SXB5bmJUb1B5dGhvbiIsImlweW5iIiwiaXNVc2FibGUiLCJjZWxsIiwiY2VsbF90eXBlIiwic291cmNlIiwibWFrZVB5dGhvbiIsImNlbGxzIiwiUHl0aG9uRWRpdG9yVmlldyIsIkJsb2NrbHkiLCJzZXRQYXJlbnRDb250YWluZXIiLCJCbG9ja01pcnJvciIsInRvb2xib3giLCJpbWFnZURvd25sb2FkSG9vayIsIm9sZFVybCIsImltYWdlVXBsb2FkSG9vayIsInJlamVjdCIsInN1Ym1pc3Npb25JZCIsImltYWdlTGl0ZXJhbEhvb2siLCJtYWtlU3Vic2NyaXB0aW9ucyIsImxpbmVFcnJvclN1YnNjcmlwdGlvbiIsImxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24iLCJsaW5lVHJhY2VTdWJzY3JpcHRpb24iLCJtYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMiLCJ3b3Jrc3BhY2UiLCJjb25maWd1cmVDb250ZXh0TWVudSIsIm9wdGlvbnMiLCJlbmFibGVkIiwiY2FsbGJhY2siLCJvbGRGaWxlbmFtZSIsImN1cnJlbnRCTUxpc3RlbmVyIiwiYWRkQ2hhbmdlTGlzdGVuZXIiLCJpc1BhcnNvbnMiLCJsaW5lcyIsInNldEhpZ2hsaWdodGVkTGluZXMiLCJjbGVhckhpZ2hsaWdodGVkTGluZXMiLCJkZWxldGVGaWxlTG9jYWxseV8iLCJzZXRDb2RlIiwiZ2V0Q29kZSIsInJlbW92ZUNoYW5nZUxpc3RlbmVyIiwiY2xlYXJMaW5lU3Vic2NyaXB0aW9ucyIsInNldE1vZGUiLCJlbmFibGVCbG9ja3MiLCJyZWxvYWRUb29sYm94IiwiaW1hZ2VNb2RlIiwic2V0SW1hZ2VNb2RlIiwib2xkSGVpZ2h0IiwidXNlU21hbGxMYXlvdXQiLCJyZXNpemVSZXNwb25zaXZlbHkiLCJ1cGRhdGVHdXR0ZXIiLCJpbmRlbnRTaWRlYmFyIiwiY3VzdG9tVG9vbGJveCIsImRlY2lkZUlmTm90RWRpdGFibGUiLCJvbmx5VXBsb2FkcyIsImlzUmVhZE9ubHkiLCJlbmRzV2l0aCIsIlB5dGhvbkVkaXRvciIsIlFVSVpfRURJVE9SX0hUTUwiLCJRdWl6RWRpdG9yVmlldyIsIlF1aXpFZGl0b3IiLCJQQVNTRUQiLCJGQUlMRUQiLCJFUlJPUiIsIlNLSVBQRUQiLCJjb3VudCIsIlNBTVBMRV9TVUJNSVNTSU9OU19IVE1MIiwiYmluZGluZ0hhbmRsZXJzIiwiY29kZU1pcnJvckluc3RhbmNlIiwiaW5pdCIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0Iiwic2V0U2l6ZSIsInVwZGF0ZSIsIlNhbXBsZVN1Ym1pc3Npb25zVmlldyIsImNvZGVNaXJyb3JzIiwiU2FtcGxlU3VibWlzc2lvbnMiLCJUQUdTX0VESVRPUl9IVE1MIiwiVGFnc0VkaXRvclZpZXciLCJUYWdzRWRpdG9yIiwiVEVYVF9FRElUT1JfSFRNTCIsIlRleHRFZGl0b3JWaWV3IiwiVGV4dEVkaXRvciIsIlRPT0xCT1hfRURJVE9SX0hUTUwiLCJUb29sYm94RWRpdG9yVmlldyIsIlRvb2xib3hFZGl0b3IiLCJFZGl0b3JzRW51bSIsIlNVQk1JU1NJT04iLCJBU1NJR05NRU5UIiwiSU5TVFJVQ1RJT05TIiwiT05fUlVOIiwiT05fQ0hBTkdFIiwiT05fRVZBTCIsIlNUQVJUSU5HX0NPREUiLCJTQU1QTEVfU1VCTUlTU0lPTlMiLCJJTlNUUlVDVE9SX0ZJTEUiLCJTUEVDSUFMX05BTUVTUEFDRVMiLCJBVkFJTEFCTEVfRURJVE9SUyIsIkVESVRPUlNfSFRNTCIsInJlZ2lzdGVyZWRfIiwiZXh0ZW5zaW9uc18iLCJieU5hbWVfIiwicmVnaXN0ZXJFZGl0b3IiLCJpbnN0YW5jZSIsImV4aXQiLCJlbnRlciIsInNwYWNlIiwiYXNzaWdubWVudFR5cGUiLCJBc3NpZ25tZW50VHlwZSIsImxhc3RJbmRleE9mIiwiZXhlY3V0aW9uTW9kZWwiLCJjb25maWd1cmF0aW9ucyIsIlJ1bkNvbmZpZ3VyYXRpb24iLCJldmFsIiwiRXZhbENvbmZpZ3VyYXRpb24iLCJPblJ1bkNvbmZpZ3VyYXRpb24iLCJPbkNoYW5nZUNvbmZpZ3VyYXRpb24iLCJPbkV2YWxDb25maWd1cmF0aW9uIiwiY29uZmlndXJlIiwiZ2V0U2t1bHB0T3B0aW9ucyIsIm9uRXhlY3V0aW9uQmVnaW4iLCJvbkV4ZWN1dGlvbkVuZCIsInJlcG9ydCIsInRyYWNpbmciLCJyZXNldFN0dWRlbnRNb2RlbCIsInJlc2V0UmVwb3J0cyIsInJlc2V0RXhlY3V0aW9uQnVmZmVyIiwiZGlzYWJsZUZlZWRiYWNrIiwidGhlbiIsImZhaWx1cmUiLCJwcm92aWRlU2VjcmV0RXJyb3IiLCJzaG93RXJyb3JzIiwiZXhlY3V0aW9uRW5kXyIsImV2YWx1YXRpb25JbnB1dCIsInVzZXJJbnB1dCIsIm1pc2NldmFsIiwiYXN5bmNUb1Byb21pc2UiLCJpbXBvcnRNYWluV2l0aEJvZHkiLCJGSUxFTkFNRSIsInByb2dyYW1zIiwic2F2ZUNvZGUiLCJ2ZXJpZnlDb2RlIiwidXBkYXRlUGFyc2UiLCJydW5JbnN0cnVjdG9yQ29kZSIsIm1vZHVsZSIsImV4ZWN1dGlvblJlcG9ydHMiLCJwcmVzZW50RmVlZGJhY2siLCIkZCIsIkVNUFRZX01PRFVMRSIsIkNvbmZpZ3VyYXRpb24iLCJpbkJyb3dzZXIiLCJvcGVuRmlsZSIsImZpbGVUb1VSTCIsImdldFVybEZyb21GaWxlbmFtZSIsInJlcXVlc3RzR2V0IiwidGltZW91dCIsIm9wZW5VUkwiLCJ0aW1lb3V0SGFuZGxlciIsInRpbWVQYXNzZWQiLCJleGVjTGltaXQiLCJkaXNhYmxlVGltZW91dCIsImdldFRpbWVvdXRQcm9tcHQiLCJkZWxheSIsInBhcnNlSW50IiwiZXhlY0xpbWl0RnVuY3Rpb24iLCJJbmZpbml0eSIsImJlZm9yZUNhbGwiLCJsb25nVGltZW91dCIsIl9fZnV0dXJlX18iLCJweXRob24zIiwicmVhZCIsImltcG9ydEZpbGUiLCJmaWxld3JpdGUiLCJ3cml0ZUZpbGUiLCJwcmludCIsImlucHV0ZnVuIiwiaW5wdXRmdW5UYWtlc1Byb21wdCIsImltYWdlUHJveHkiLCJnZXRJbWFnZVByb3h5IiwiZW1vamlQcm94eSIsInBhcnQiLCJyZXRhaW5HbG9iYWxzIiwiZm91bmQiLCJmaWxlc1RvVXJscyIsImJ1aWx0aW4iLCJPU0Vycm9yIiwid2FybiIsIm1vY2tVcmxEYXRhIiwiSU9FcnJvciIsImhhc093blByb3BlcnR5IiwiZmlsZURhdGEiLCJyZWFkRmlsZSIsIkVycm9yIiwic3RvcCIsImZ1bmN0aW9uTmFtZSIsInBvc2FyZ3MiLCJrd2FyZ3MiLCJzdHVkZW50TW9kZWwiLCJhcmdzIiwicG9wIiwiYWZ0ZXJTaW5nbGVFeGVjdXRpb24iLCJwcmludFZhbHVlIiwicmVtYXBUb0pzIiwiXyIsIiRyIiwieCIsImlzRG9jc3RyaW5nIiwiU3R1ZGVudENvbmZpZ3VyYXRpb24iLCJVVElMSVRZX01PRFVMRV9DT0RFIiwiJHNrX21vZF9pbnN0cnVjdG9yIiwiQ09WRVJBR0VfTU9EVUxFX0NPREUiLCIkc2tfbW9kX2NvdmVyYWdlIiwiSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24iLCJiZWZvcmVDYWxsQmFja3VwIiwiJHBlZGFsX3RyYWNlciIsImNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cyIsImluZm8iLCJnZXRBbGxGaWxlbmFtZXMiLCJza0ZpbGVuYW1lIiwic3RyIiwicG9wJGl0ZW0iLCJpbmNsdWRlcyIsImNob21wU3BlY2lhbEZpbGUiLCJjbGVhbiIsInNlYXJjaEZvckZpbGUiLCJ2Iiwib3BlbmFpUHJveHkiLCJuZXh0SW5wdXQiLCJjbGVhclRpbWVvdXQiLCJXUkFQX0lOU1RSVUNUT1JfQ09ERSIsInN0dWRlbnRDb2RlIiwiaW5zdHJ1Y3RvckNvZGUiLCJxdWljayIsImlzU2FmZSIsInNhZmVDb2RlIiwiSU5TVFJVQ1RPUl9NQVJLRVIiLCJkaXNhYmxlVGlmYSIsInN0dWRlbnRGaWxlcyIsImdldEFsbFN0dWRlbnRGaWxlcyIsImV2YWx1YXRpb24iLCJkdW1teU91dFNhbmRib3giLCJsaW5lT2Zmc2V0IiwiZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQiLCJTVUNDRVNTIiwiU0NPUkUiLCJvbGRTY29yZSIsIkhJREUiLCJzY3JvbGxpbmciLCJzY3JvbGxUb0JvdHRvbSIsInRwJG5hbWUiLCJwcmVzZW50SW50ZXJuYWxFcnJvciIsImJlZm9yZSIsIm1hdGNoIiwiTkVXX0xJTkVfUkVHRVgiLCJza2lwX3RpZmEiLCJPblNhbXBsZUNvbmZpZ3VyYXRpb24iLCJkaXNhYmxlU3R1ZGVudFJ1biIsIkJvb2xlYW4iLCJlbnZpcm9uIiwiZGljdCIsInNldCRpdGVtIiwiaW50XyIsInJvdW5kIiwiY2xlYXJJbnB1dCIsImZpbmlzaFR1cnRsZXMiLCJiZWdpbkV2YWwiLCJwYXJzZXIiLCJ2ZXJpZmllciIsIlNhbXBsZUNvbmZpZ3VyYXRpb24iLCJpc0ZvcmJpZGRlbiIsImxvY2FscyIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJhc3ROYW1lIiwicGFyc2VHbG9iYWxzIiwicHJvcGVydGllcyIsIm1vZHVsZXMiLCJ2aXNpdGVkTGluZXMiLCJTZXQiLCJ2aXNpdEJvZHkiLCJub2RlIiwibGluZW5vIiwic3RhdGVtZW50Iiwib3JlbHNlIiwiZmluYWxib2R5IiwiQXJyYXkiLCJmcm9tIiwiYXN0RnJvbVBhcnNlIiwiY3N0IiwiZmxhZ3MiLCJnZXRMaW5lcyIsInByZXNlbnRSdW5FcnJvciIsImVycm9yQnV0dG9uIiwiRkVFREJBQ0tfSFRNTCIsImZlZWRiYWNrTW9kZWwiLCJwb3NpdGl2ZSIsInZpc2liaWxpdHlCdWZmZXIiLCJ0b3BPZkVsZW1lbnQiLCJib3R0b21PZkVsZW1lbnQiLCJib3R0b21PZlNjcmVlbiIsInRvcE9mU2NyZWVuIiwiY2xlYXJQb3NpdGl2ZUZlZWRiYWNrIiwiZXhlY3V0aW9uUmVzdWx0cyIsIk1FU1NBR0UiLCJDQVRFR09SWSIsIkxBQkVMIiwiREFUQSIsInBvc2l0aXZlcyIsIlBPU0lUSVZFIiwiaGlkZVNjb3JlIiwiYmxvY2siLCJobGpzIiwiaGlnaGxpZ2h0QmxvY2siLCJmaW5kRmlyc3RFcnJvckxpbmUiLCJzdHVkZW50UmVwb3J0IiwidW5jb3ZlcmVkTGluZXMiLCJwb3NpdGl2ZURhdGEiLCJhZGRQb3NpdGl2ZUZlZWRiYWNrIiwiY29sb3IiLCJvbmNsaWNrIiwidG9FbmQiLCJjc3MiLCJob3ZlciIsInVwZGF0ZUZlZWRiYWNrIiwidXBkYXRlRnVsbEZlZWRiYWNrIiwibm90aWZ5RmVlZGJhY2tVcGRhdGUiLCJ0cCRnZXRhdHRyIiwicHlTdHIiLCJraW5kIiwiYWN0aXZlIiwiaXNUcnVlIiwidW51c2VkX21lc3NhZ2UiLCJqdXN0aWZpY2F0aW9uIiwiaGFzUGFyZW50IiwiY2hlY2tOb25lIiwibm9uZSIsIm5vbmUkIiwibWFpblJlcG9ydCIsIk1BSU5fUkVQT1JUIiwiZmVlZGJhY2tzIiwiaXRlckZvciIsInRwJGl0ZXIiLCJwcm9jZXNzU2luZ2xlRmVlZGJhY2siLCJwYXJlbnRzIiwiTWFwIiwidW5zaGlmdCIsInZhbHVlcyIsImZsYXQiLCJ0b2dnbGVDbGFzcyIsInNob3VsZFNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJqdXN0X3JldHVybiIsImNvbnZlcnRTa3VscHRFcnJvciIsImZpbGVuYW1lRXhlY3V0ZWQiLCJ0cmFjZWJhY2siLCJmcmFtZSIsInNjb3BlIiwiaXNJbnN0cnVjdG9yIiwiZXJyIiwiYWxsRnJhbWVzIiwiYnVpbGRUcmFjZWJhY2siLCJmZWVkYmFja0RhdGEiLCJxdWljayRsb29rdXAiLCJmcmllbmRseU5hbWUiLCJoaWRlSWZFbXB0eSIsIm5vdEluc3RydWN0b3IiLCJpbnN0cnVjdG9yRmlsZUNsYXNzIiwiaGlkZUlmTm90SW5zdHJ1Y3RvciIsIkZJTEVTX0hUTUwiLCJORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MIiwiU1RBUlRJTkdfRklMRVMiLCJCQVNJQ19ORVdfRklMRVMiLCJJTlNUUlVDVE9SX0RJUkVDVE9SWSIsIlNUVURFTlRfRElSRUNUT1JZIiwiU2VhcmNoTW9kZXMiLCJFVkVSWVdIRVJFIiwiU1RBUlRfV0lUSF9JTlNUUlVDVE9SIiwiT05MWV9TVFVERU5UX0ZJTEVTIiwiREVMRVRBQkxFX1NJTVBMRV9GSUxFUyIsIkJsb2NrUHlGaWxlIiwib3duZXIiLCJtYWtlTW9ja01vZGVsRmlsZSIsImNvbmNhdGVuYXRlZEZpbGUiLCJtb2RlbEZpbGVMaXN0IiwibW9kZWxGaWxlcyIsImNyZWF0ZUNvbmNhdGVuYXRlZEZpbGUiLCJmaWxlc18iLCJtb3VudEZpbGVzIiwid2F0Y2hNb2RlbCIsIndhdGNoZXNfIiwicmVtb3RlRmlsZXNfIiwiZmlsZXN5c3RlbSIsImZpbGVBcnJheSIsImNoYW5nZXMiLCJzZWNvbmQiLCJsb2NhbGVDb21wYXJlIiwiY2hhbmdlIiwibW9kZWxGaWxlIiwibm90aWZ5V2F0Y2hlcyIsIm9ic2VydmVJbkFycmF5XyIsImFycmF5IiwiY29kZUJ1bmRsZSIsImV4aXN0aW5nRmlsZSIsIm9ic2VydmVGaWxlXyIsImRlc3RpbmF0aW9uIiwic3R1ZGVudFNlYXJjaCIsInNlYXJjaE1vZGUiLCJzcGVjaWFsRmlsZSIsInNlYXJjaEZvclNwZWNpYWxGaWxlc18iLCJzdHVkZW50VmVyc2lvbiIsInNlYXJjaEZvckZpbGVJbkxpc3RfIiwiZ2VuZXJhdGVkVmVyc2lvbiIsImRlZmF1bHRWZXJzaW9uIiwiaGlkZGVuVmVyc2lvbiIsInJlbW90ZVZlcnNpb24iLCJmaXJzdERlZmluZWRWYWx1ZSIsImluc3RydWN0b3JWZXJzaW9uIiwic3RhcnRpbmdWZXJzaW9uIiwibW9kZWxMaXN0IiwiZmlsZXR5cGUiLCJuYW1lc3BhY2UiLCJleHRlbnNpb25SZWdleCIsImV4ZWMiLCJwcmVmaXgiLCJzdWJtaXQiLCJwcmV2ZW50RGVmYXVsdCIsInByZWxvYWRGaWxlcyIsInByZWxvYWRBbGxGaWxlcyIsImRvd25sb2FkUmVtb3RlRmlsZXMiLCJyZW9yZ2FuaXplRmlsZXMiLCJvcmdhbml6ZWQiLCJlbnRyaWVzIiwicGxhY2VkRmlsZXMiLCJkaXJlY3RvcnkiLCJvbGRSZW1haW5pbmdGaWxlcyIsInBsYWNlbWVudERhdGEiLCJkaXJlY3RvcnlEYXRhIiwicmVuYW1lZEZpbGUiLCJGT09URVJfSFRNTCIsImN1cnJlbnRJZCIsImVkaXRFdmVudHMiLCJzZWxlY3RvciIsImVkaXRJZCIsImVudHJ5IiwiZmlsZV9wYXRoIiwiZXZlbnRfdHlwZSIsIlJFTUFQX0VWRU5UX1RZUEVTIiwiZGlzcGxheWVkIiwicHJldHR5UHJpbnREYXRlVGltZSIsImNsaWVudF90aW1lc3RhbXAiLCJkaXNhYmxlIiwib3B0aW9uIiwiZGlzYWJsZWQiLCJpc0VkaXRFdmVudCIsImV2dCIsIm1vbnRoTmFtZXMiLCJ3ZWVrRGF5cyIsImlzU2FtZURheSIsImdldERhdGUiLCJnZXRNb250aCIsImdldEZ1bGxZZWFyIiwidGltZVN0cmluZyIsIm5vdyIsIkRhdGUiLCJwYXN0IiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiZGF5U3RyIiwiZ2V0RGF5IiwibW9udGhTdHIiLCJkYXRlIiwiZ2V0SGlzdG9yeSIsInJldmVyc2UiLCJyZWR1Y2UiLCJjb21wbGV0ZSIsImVsZW0iLCJjb21wbGV0ZV9zdHIiLCJ0aW1lIiwibmV3X2xpbmUiLCJoaWdobGlnaHRUaW1lb3V0IiwiaXNGdWxsc2NyZWVuIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsIlRSQUNFX0hUTUwiLCJSRVRSWUlORyIsIk9GRkxJTkUiLCJzdG9yYWdlIiwicXVldWUiLCJnZXREZWZhdWx0IiwiTUFYX1FVRVVFX1NJWkUiLCJUSU1FUl9ERUxBWSIsIkZBSUxfREVMQVkiLCJ0aW1lcnMiLCJvdmVybGF5IiwiYmxvY2tpbmdBdHRlbXB0cyIsImNhY2hlZEZpbGVuYW1lcyIsImNyZWF0ZVN1YnNjcmlwdGlvbnMiLCJjaGVja0NhY2hlcyIsImNoZWNrSVAiLCJvbGRJUCIsImlwIiwiX3Bvc3RMYXRlc3RSZXRyeSIsInB1c2hBbnlRdWV1ZWQiLCJfcG9zdFJldHJ5IiwiY3JlYXRlRmlsZVN1YnNjcmlwdGlvbiIsImNyZWF0ZUV2ZW50TG9ncyIsIm9uYmx1ciIsIm9uZm9jdXMiLCJhdXRob3JpemVIZWFkZXIiLCJjdXJyZW50U2V0dGluZ3MiLCJoZWFkZXJzIiwiY3JlYXRlU2VydmVyRGF0YSIsIm1pY3Jvc2Vjb25kcyIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNob3dPdmVybGF5IiwiYXR0ZW1wdCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlT3ZlcmxheSIsIl9lbnF1ZXVlRGF0YSIsImNhY2hlIiwiX2RlcXVldWVEYXRhIiwic3BsaWNlIiwicG9zdFJlcXVlc3QiLCJhamF4IiwidGV4dFN0YXR1cyIsImZhaWx1cmVGdW5jdGlvbiIsImRvbmVGdW5jdGlvbiIsInJlcXVlc3QiLCJjYWNoZWRUaW1lIiwiX3Bvc3RCbG9ja2luZyIsImF0dGVtcHRzIiwiZXh0cmFTZXR0aW5ncyIsImVycm9yVGhyb3duIiwic3RhcnRQb3NzaWJsZUZvcmsiLCJkZWxldGVJbnN0ZWFkIiwiZmQiLCJkIiwiRm9ybURhdGEiLCJwcm9jZXNzRGF0YSIsImNvbnRlbnRUeXBlIiwiZGF0YVR5cGUiLCJvbGRfZmlsZW5hbWUiLCJuZXdfZmlsZW5hbWUiLCJuZXdTdGF0dXMiLCJwb3N0U3RhdHVzQ2hhbmdlIiwiZXJyb3JDYWxsYmFjayIsImxvYWRfZmlsZSIsImZvcmthYmxlIiwiaGlkZGVuT3ZlcnJpZGUiLCJmb3JjZVVwZGF0ZSIsImdldFBuZ0Zyb21CbG9ja3MiLCJwbmdEYXRhIiwiaW1nIiwib3BlbmFpX2RhdGEiLCJvcGVuYWlfcHJveHkiLCIkYnVpbHRpbm1vZHVsZSIsIm1vZCIsInNhbXBsZVdyYXBwZXIiLCJfX25hbWVfXyIsIlBJTCIsIkluc3RhbnRQcm9taXNlIiwibGFzdFJlc3VsdCIsImxhc3RFcnJvciIsImNiIiwiYnVpbGRJbWFnZSIsImdldEFzc2V0IiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9uZXJyb3IiLCJzcmMiLCIkZ2JsIiwiJGxvYyIsIl9faW5pdF9fIiwiZnVuYyIsImZpbGVfb3JfdXJsIiwicHlDaGVja0FyZ3MiLCJweUNoZWNrVHlwZSIsImNoZWNrU3RyaW5nIiwiaW1hZ2VQcm9taXNlIiwic3VzcCIsIlN1c3BlbnNpb24iLCJyZXN1bWUiLCJwcm9taXNlIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInBpeGVscyIsImdldEltYWdlRGF0YSIsIk5hbWVFcnJvciIsImNvbnNvbGVEYXRhIiwicHJpbnRQSUxJbWFnZSIsImZsaXAiLCJzdHlsZSIsInRyYW5zZm9ybSIsImJ1aWxkQ2xhc3MiLCJwcmlvciIsInRpbWVpdCIsImRpZmZlcmVuY2UiLCJjb25zb2xlX2xvZyIsImNvbnNvbGVfZGVidWciLCJnZXRfb3V0cHV0IiwiaXRlbSIsInRvU2t1bHB0IiwibGlzdCIsInJlc2V0X291dHB1dCIsImdldF9wcm9ncmFtIiwiZ2V0X2V2YWx1YXRpb24iLCJ0cmFjZV9saW5lcyIsInJlYWxMaW5lcyIsInRyYWNlX2NhbGxzIiwic3RhcnRfdHJhY2UiLCJzdG9wX3RyYWNlIiwiZ2V0X3N0dWRlbnRfZXJyb3IiLCJ0dXBsZSIsInBvc2l0aW9uIiwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yIiwiYmFja3VwVGltZSIsImxpbWl0X2V4ZWN1dGlvbl90aW1lIiwiZXhlY1N0YXJ0IiwidW5saW1pdF9leGVjdXRpb25fdGltZSIsInN1cHByZXNzX3Njcm9sbGluZyIsImdldF9wbG90cyIsIm91dHB1dHMiLCJncmFwaCIsInBsb3QiLCJuZXdQbG90IiwieSIsIlN0dWRlbnREYXRhIiwibmV3RGljdCIsImFic3RyIiwic2F0dHIiLCJvYmplY3RTZXRJdGVtIiwidW5maXhSZXNlcnZlZCIsImNhbGxfZiIsImt3YSIsInB5Q2hlY2tBcmdzTGVuIiwiY2FsbCIsImJ1aWx0aW5zIiwibXAkbG9va3VwIiwiZnVuY3Rpb25PYmplY3QiLCJ0cCRjYWxsIiwiY29fa3dhcmdzIiwiY29fbmFtZSIsImdldF9uYW1lc19ieV90eXBlIiwiZXhjbHVkZV9idWlsdGlucyIsImNoZWNrQm9vbCIsInByb3BlcnR5IiwiZ2V0X3ZhbHVlc19ieV90eXBlIiwiY2FsbHNpbU9yU3VzcGVuZCIsImdldF9zdHVkZW50X2RhdGEiLCJzZXRfaW5zdHJ1Y3Rpb25zIiwibmV3SW5zdHJ1Y3Rpb25zIiwiZ2V0X21vZGVsX2luZm8iLCJjbGVhcl9leGlzdGluZ19zdHVkZW50X2ltcG9ydHMiLCJkb3dubG9hZF9maWxlIiwiZG93bmxvYWRGaWxlVXJsIiwiY29tYmluZXIiLCJwcm9tIiwieG1saHR0cCIsIlhNTEh0dHBSZXF1ZXN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc3BvbnNlVGV4dCIsIm9wZW4iLCJzZW5kIiwicmVzb2x1dGlvbiIsIldlYWtTZXQiLCJjaGVja0l0ZXJhYmxlIiwiaXRlciIsIml0ZXJuZXh0IiwiV2Vha1JlZiIsIl9faXRlcl9fIiwidmlld09mRGF0YSIsImRlcmVmIiwiTE9DQUxfU1RPUkFHRV9SRUYiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIl9kYXRhIiwiU3RyaW5nIiwiZ2V0SXRlbSIsImlzX25ldyIsInNlcnZlcl90aW1lIiwic3RvcmVkX3RpbWUiLCJJR05PUkVEX0dMT0JBTFMiLCJ2YXJpYWJsZXMiLCJwYXJzZWQiLCJwYXJzZVZhbHVlIiwiZnVsbExlbmd0aCIsImZ1bmNfY29kZSIsImNvX3Zhcm5hbWVzIiwic3EkbGVuZ3RoIiwiYm9vbCIsIm5tYmVyIiwic2tUeXBlIiwiZmxvYXRfIiwiTnVtYmVyIiwiYXJyYXlNb3ZlIiwiYXJyIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIml0ZW1Ub01vdmUiLCJhY2MiLCJhcnJheUNvbnRhaW5zIiwibmVlZGxlIiwiaGF5c3RhY2siLCJhcnJheVVuaXF1ZSIsImEiLCJjb25jYXQiLCJqIiwiZXhwYW5kQXJyYXkiLCJhZGRBcnJheSIsInJlbW92ZUFycmF5IiwiY29weUFycmF5IiwiY2xvbmVOb2RlIiwiY2xvbmUiLCJub2RlVHlwZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJpbmRlbnQiLCJzIiwicmFuZG9tSW50ZWdlciIsImZsb29yIiwicmFuZG9tIiwiV29ya3NwYWNlU3ZnIiwic2h1ZmZsZSIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImJsb2NrcyIsImdldFRvcEJsb2NrcyIsIm1heGltYWxfaW5jcmVhc2UiLCJnZXRSZWxhdGl2ZVRvU3VyZmFjZVhZIiwibW92ZUJ5IiwibW92ZUVsZW1lbnRzIiwibW92ZUNoZWNrIiwiaXNTa0J1aWx0aW4iLCJvYmoiLCJsbmciLCJpc0FzdE5vZGUiLCJERUZBVUxUX1NFQ1RJT05fUEFUVEVSTiIsInBhcnRzIiwibWl4ZWRSZW1hcFRvUHkiLCJrIiwia3ZzIiwic3VidmFsIiwiYXNzayQiLCJ0b2RheSIsImgiLCJnZXRIb3VycyIsIm0iLCJnZXRNaW51dGVzIiwicCIsInB5SW50IiwicHlOb25lIiwicHlUdXBsZSIsInB5Q2FsbE9yU3VzcGVuZCIsImNhbGxzaW1PclN1c3BlbmRBcnJheSIsInJpY2hDb21wYXJlQm9vbCIsImNoYWluIiwidHlwZU5hbWUiLCJzZXRVcE1vZHVsZU1ldGhvZHMiLCJidWlsZE5hdGl2ZUNsYXNzIiwiVHlwZUVycm9yIiwiVmFsdWVFcnJvciIsIktleUVycm9yIiwiSW5kZXhFcnJvciIsImFzbnVtJCIsImdlbmVyaWMiLCJnZXRBdHRyIiwic2V0QXR0ciIsImNoYWluT3JTdXNwZW5kIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtDQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSxJQUFNQSxjQUFjLEdBQUcsT0FBdkI7QUFFQTs7Ozs7Ozs7OztBQVNPLElBQU1DLE9BQWI7QUFDSTs7Ozs7QUFLQSxtQkFBWUMsYUFBWixFQUEyQkMsVUFBM0IsRUFBdUNDLFVBQXZDLEVBQW1EO0FBQUE7O0FBQy9DLFNBQUtDLFNBQUwsQ0FBZUgsYUFBZjs7QUFDQSxRQUFJQyxVQUFVLEtBQUtHLFNBQW5CLEVBQThCO0FBQzFCLFdBQUtDLGFBQUwsQ0FBbUJMLGFBQW5CLEVBQWtDQyxVQUFsQyxFQUE4Q0MsVUFBOUM7QUFDSDs7QUFDRCxTQUFLSSxRQUFMO0FBQ0g7QUFFRDs7Ozs7OztBQWRKO0FBQUE7QUFBQSwrQkFtQmU7QUFDUCxXQUFLQyxhQUFMO0FBQ0EsV0FBS0MsZ0JBQUw7QUFDQSxXQUFLQyxXQUFMO0FBQ0EsV0FBS0MsYUFBTDtBQUNBLFdBQUtDLFVBQUw7QUFDQSxXQUFLQyxjQUFMO0FBQ0EsV0FBS0Msc0JBQUw7QUFDQSxXQUFLQyxLQUFMO0FBQ0g7QUE1Qkw7QUFBQTs7QUE4Qkk7Ozs7O0FBOUJKLCtCQW1DZUMsR0FuQ2YsRUFtQ29CQyxZQW5DcEIsRUFtQ2tDO0FBQzFCLFVBQUlELEdBQUcsSUFBSSxLQUFLRSxxQkFBaEIsRUFBdUM7QUFDbkMsZUFBTyxLQUFLQSxxQkFBTCxDQUEyQkYsR0FBM0IsQ0FBUDtBQUNILE9BRkQsTUFFTyxJQUFJLEtBQUtHLGNBQUwsQ0FBb0JDLEdBQXBCLENBQXdCSixHQUF4QixDQUFKLEVBQWtDO0FBQ3JDLGVBQU8sS0FBS0csY0FBTCxDQUFvQkUsR0FBcEIsQ0FBd0JMLEdBQXhCLENBQVA7QUFDSCxPQUZNLE1BRUE7QUFDSCxlQUFPQyxZQUFQO0FBQ0g7QUFDSjtBQUVEOzs7Ozs7Ozs7Ozs7O0FBN0NKO0FBQUE7QUFBQSw4QkF5RGNoQixhQXpEZCxFQXlENkI7QUFDckI7QUFDQSxXQUFLa0IsY0FBTCxHQUFzQixJQUFJRyw4REFBSixDQUF3QixlQUF4QixDQUF0QjtBQUNBLFdBQUtKLHFCQUFMLEdBQTZCakIsYUFBN0IsQ0FIcUIsQ0FJckI7O0FBRUEsV0FBS3NCLEtBQUwsR0FBYTtBQUNUQyxZQUFJLEVBQUU7QUFDRkMsWUFBRSxFQUFFQyxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxTQUFELENBQTNCLENBREY7QUFFRjJCLGNBQUksRUFBRUYsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsV0FBRCxDQUEzQixDQUZKOztBQUdGOzs7OztBQUtBNEIsY0FBSSxFQUFFSCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFLRyxVQUFMLENBQWdCLFdBQWhCLEVBQTZCLE9BQTdCLENBQWQsQ0FSSjs7QUFTRjs7O0FBR0FDLGtCQUFRLEVBQUVMLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLGdCQUFELENBQTNCLENBWlI7O0FBYUY7OztBQUdBK0IsaUJBQU8sRUFBRU4sRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsZUFBRCxDQUEzQjtBQWhCUCxTQURHO0FBbUJUQyxrQkFBVSxFQUFFO0FBQ1J1QixZQUFFLEVBQUVDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FESTtBQUVSQyxjQUFJLEVBQUVGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLGdCQUFkLENBRkU7QUFHUk0sc0JBQVksRUFBRVAsRUFBRSxDQUFDQyxVQUFILENBQWMsNkRBQWQsQ0FITjs7QUFJUjs7O0FBR0FPLGFBQUcsRUFBRVIsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQVBHO0FBUVI7QUFDQVEsY0FBSSxFQUFFVCxFQUFFLENBQUNDLFVBQUgsQ0FBY1MsMEVBQWEsQ0FBQ0MsT0FBNUIsQ0FURTtBQVVSQyxnQkFBTSxFQUFFWixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBVkE7QUFXUlksc0JBQVksRUFBRWIsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsMEJBQUQsQ0FBYixJQUE2QyxFQUEzRCxDQVhOO0FBWVJ1QyxlQUFLLEVBQUVkLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLG1CQUFELENBQWIsSUFBc0MsRUFBcEQsQ0FaQztBQWFSd0Msa0JBQVEsRUFBRWYsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsc0JBQUQsQ0FBYixJQUF5QyxJQUF2RCxDQWJGO0FBY1J5QyxnQkFBTSxFQUFFaEIsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsb0JBQUQsQ0FBYixJQUF1QyxJQUFyRCxDQWRBO0FBZVIwQyw4QkFBb0IsRUFBRWpCLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUJDLG9FQUFvQixDQUFDNUMsYUFBYSxDQUFDLG1DQUFELENBQWQsQ0FBcEIsSUFBNEUsRUFBL0YsQ0FmZDtBQWdCUjZDLDRCQUFrQixFQUFFcEIsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQWhCWjtBQWlCUkcsa0JBQVEsRUFBRXJCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FqQkY7QUFrQlJxQix1QkFBYSxFQUFFdEIsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQWxCUDtBQW1CUnNCLGlCQUFPLEVBQUV2QixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBbkJEO0FBb0JSSSxrQkFBUSxFQUFFTCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBcEJGO0FBcUJSdUIsaUJBQU8sRUFBRXhCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FyQkQ7QUFzQlJ3QixjQUFJLEVBQUV6QixFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBdEJFO0FBdUJSUSwyQkFBaUIsRUFBRTFCLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0F2Qlg7QUF3QlJTLGtCQUFRLEVBQUUzQixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxxQkFBRCxDQUEzQixDQXhCRjtBQXlCUixvQkFBUXlCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLG1CQUFELENBQTNCLENBekJBO0FBMEJScUQsZ0JBQU0sRUFBRTVCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLG1CQUFELENBQTNCLENBMUJBO0FBMkJSc0Qsa0JBQVEsRUFBRTdCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLHNCQUFELENBQTNCLENBM0JGO0FBNEJSdUQsa0JBQVEsRUFBRUMsZ0dBQTJCLENBQUN4RCxhQUFEO0FBNUI3QixTQW5CSDtBQWlEVEUsa0JBQVUsRUFBRTtBQUNSc0IsWUFBRSxFQUFFQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBREk7QUFFUitCLGNBQUksRUFBRWhDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjZ0MsK0RBQVcsQ0FBQzFELGFBQWEsQ0FBQyxpQkFBRCxDQUFiLElBQW9DLEVBQXJDLEVBQXlDQSxhQUFhLENBQUMsUUFBRCxDQUF0RCxDQUFYLElBQWdGLEVBQTlGLENBRkU7QUFHUjJELG9CQUFVLEVBQUVsQyxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBSEo7QUFJUlYsYUFBRyxFQUFFUixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBSkc7QUFLUmtDLGtCQUFRLEVBQUVuQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBTEY7QUFNUm1DLGVBQUssRUFBRXBDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FOQztBQU9Sb0MsaUJBQU8sRUFBRXJDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FQRDtBQVFSO0FBQ0E7QUFDQTtBQUNBO0FBQ0F1QixpQkFBTyxFQUFFeEIsRUFBRSxDQUFDQyxVQUFILENBQWMsQ0FBZCxDQVpEO0FBYVJxQywwQkFBZ0IsRUFBRXRDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLFNBQWQsQ0FiVjtBQWNSc0MsdUJBQWEsRUFBRXZDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLFVBQWQsQ0FkUDtBQWVSc0IsaUJBQU8sRUFBRXZCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQ7QUFmRCxTQWpESDtBQWtFVHVDLGVBQU8sRUFBRTtBQUNMOzs7O0FBSUFDLGtCQUFRLEVBQUV6QyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBTEw7O0FBTUw7Ozs7QUFJQXlDLG9CQUFVLEVBQUUxQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFHLEtBQUtHLFVBQUwsQ0FBZ0Isb0JBQWhCLEVBQXNDLE9BQXRDLENBQUgsS0FBb0QsTUFBbEUsQ0FWUDs7QUFXTDs7O0FBR0F1QyxxQkFBVyxFQUFFM0MsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQWRSOztBQWVMOzs7O0FBSUEyQyxvQkFBVSxFQUFFNUMsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBS0csVUFBTCxDQUFnQixxQkFBaEIsRUFBdUN5Qyw2REFBWSxDQUFDQyxJQUFwRCxDQUFkLENBbkJQOztBQW9CTDs7OztBQUlBQyxxQkFBVyxFQUFFL0MsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQXhCUjs7QUF5Qkw7Ozs7OztBQU1BK0Msa0JBQVEsRUFBRWhELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0EvQkw7O0FBZ0NMOzs7QUFHQWdELG9CQUFVLEVBQUVqRCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkLENBbkNQOztBQW9DTDs7Ozs7QUFLQWlELCtCQUFxQixFQUFFbEQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXpDbEI7QUEwQ0xrRCw4QkFBb0IsRUFBRW5ELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0ExQ2pCOztBQTJDTDs7OztBQUlBbUQsOEJBQW9CLEVBQUVwRCxFQUFFLENBQUNDLFVBQUgsQ0FBY29ELHdFQUEyQixDQUFDQyxRQUExQyxDQS9DakI7QUFnRExDLHNDQUE0QixFQUFFdkQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQWhEekI7O0FBaURMOzs7QUFHQXVELHdCQUFjLEVBQUV4RCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkLENBcERYOztBQXFETDs7OztBQUlBd0QseUJBQWUsRUFBRXpELEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0F6RFo7O0FBMERMOzs7QUFHQXdDLDZCQUFtQixFQUFFMUQsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQTdEaEI7O0FBOERMOzs7QUFHQTBELHlCQUFlLEVBQUUsSUFqRVo7O0FBa0VMOzs7Ozs7QUFNQUMseUJBQWUsRUFBRTVELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0F4RVo7O0FBeUVMOzs7O0FBSUE0RCxvQkFBVSxFQUFFN0QsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQTdFUDs7QUE4RUw7OztBQUdBNkQsa0JBQVEsRUFBRTlELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FqRkw7O0FBa0ZMOzs7QUFHQThELHFCQUFXLEVBQUUvRCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBckZSOztBQXNGTDs7O0FBR0ErRCxzQkFBWSxFQUFFaEUsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXpGVDtBQTBGTGdFLHVCQUFhLEVBQUU1RixjQTFGVjtBQTJGTDZGLGtCQUFRLEVBQUVsRSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFLRyxVQUFMLENBQWdCLG1CQUFoQixFQUFxQyxPQUFyQyxFQUE4QytELFFBQTlDLE9BQTJELE1BQXpFLENBM0ZMOztBQTRGTDs7O0FBR0FDLHVCQUFhLEVBQUVwRSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBL0ZWOztBQWdHTDs7Ozs7QUFLQW9FLDhCQUFvQixFQUFFckUsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsaUJBQUQsQ0FBYixJQUFvQyxFQUFsRCxDQXJHakI7O0FBc0dMOzs7QUFHQStGLG9CQUFVLEVBQUV0RSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFLRyxVQUFMLENBQWdCLG9CQUFoQixFQUFzQyxNQUF0QyxFQUE4QytELFFBQTlDLE9BQTJELE1BQXpFLENBekdQOztBQTBHTDs7O0FBR0FJLGtCQUFRLEVBQUV2RSxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkO0FBN0dMLFNBbEVBO0FBaUxUdUUsY0FBTSxFQUFFO0FBQ0o7QUFDQUMsd0JBQWMsRUFBRXpFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FGWjtBQUdKQywrQkFBcUIsRUFBRTVFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FIbkI7QUFJSjtBQUNBNEUscUJBQVcsRUFBRTdFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FMVDtBQU1KRyw0QkFBa0IsRUFBRTlFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FOaEI7QUFPSjtBQUNBOEUsa0JBQVEsRUFBRS9FLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FSTjtBQVNKSyx5QkFBZSxFQUFFaEYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQVRiO0FBVUo7QUFDQWdGLHFCQUFXLEVBQUVqRixFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBWFQ7QUFZSk8sNEJBQWtCLEVBQUVsRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBWmhCO0FBYUo7QUFDQWtGLGtCQUFRLEVBQUVuRixFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBZE47QUFlSlMseUJBQWUsRUFBRXBGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FmYjtBQWdCSjtBQUNBb0YsbUJBQVMsRUFBRXJGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FqQlA7QUFrQkpXLDBCQUFnQixFQUFFdEYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWxCZDtBQW1CSjtBQUNBc0Ysa0JBQVEsRUFBRXZGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FwQk47QUFxQkphLHlCQUFlLEVBQUV4RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBckJiO0FBc0JKO0FBQ0F3Rix3QkFBYyxFQUFFekYsRUFBRSxDQUFDQyxVQUFILENBQWN5RSxxREFBVyxDQUFDQyxLQUExQixDQXZCWjtBQXdCSmUsK0JBQXFCLEVBQUUxRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBeEJuQjtBQXlCSjtBQUNBMEYsMEJBQWdCLEVBQUUzRixFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBMUJkO0FBMkJKaUIsaUNBQXVCLEVBQUU1RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBM0JyQjtBQTRCSjtBQUNBNEYsZ0NBQXNCLEVBQUU3RixFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBN0JwQjtBQThCSm1CLHVDQUE2QixFQUFFOUYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQTlCM0I7QUErQko7QUFDQThGLDJCQUFpQixFQUFFL0YsRUFBRSxDQUFDQyxVQUFILENBQWN5RSxxREFBVyxDQUFDQyxLQUExQixDQWhDZjtBQWlDSnFCLGtDQUF3QixFQUFFaEcsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWpDdEI7QUFrQ0o7QUFDQWdHLHNCQUFZLEVBQUVqRyxFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBbkNWO0FBb0NKdUIsNkJBQW1CLEVBQUVsRyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBcENqQjtBQXFDSjtBQUNBa0csb0JBQVUsRUFBRW5HLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjeUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0F0Q1I7QUF1Q0p5QiwyQkFBaUIsRUFBRXBHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0F2Q2Y7QUF3Q0o7QUFDQW9HLG9CQUFVLEVBQUVyRyxFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCLENBekNSO0FBMENKMkIsMkJBQWlCLEVBQUV0RyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBMUNmO0FBMkNKO0FBQ0FzRyxxQkFBVyxFQUFFdkcsRUFBRSxDQUFDQyxVQUFILENBQWN5RSxxREFBVyxDQUFDQyxLQUExQixDQTVDVDtBQTZDSjZCLDRCQUFrQixFQUFFeEcsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQTdDaEI7QUE4Q0o7QUFDQXdHLHFCQUFXLEVBQUV6RyxFQUFFLENBQUNDLFVBQUgsQ0FBY3lFLHFEQUFXLENBQUNDLEtBQTFCO0FBL0NULFNBakxDO0FBa09UK0IsaUJBQVMsRUFBRTtBQUNQO0FBQ0FDLGlCQUFPLEVBQUUsRUFGRjtBQUdQO0FBQ0FDLGdCQUFNLEVBQUU1RyxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBSkQ7QUFLUDtBQUNBMkYsZUFBSyxFQUFFN0csRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQU5BO0FBT1A0RixvQkFBVSxFQUFFOUcsRUFBRSxDQUFDQyxVQUFILENBQWMsQ0FBZCxDQVBMO0FBUVA7QUFDQThHLGlCQUFPLEVBQUU7QUFDTDtBQUNBdEUsb0JBQVEsRUFBRXpDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FGTDtBQUdMO0FBQ0ErRyx1QkFBVyxFQUFFaEgsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQUpSO0FBS0w7QUFDQWdILG9CQUFRLEVBQUVqSCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBTkw7QUFPTDtBQUNBaUgsdUJBQVcsRUFBRWxILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FSUjtBQVNMa0gsb0JBQVEsRUFBRW5ILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FUTDtBQVVMO0FBQ0FtSCw0QkFBZ0IsRUFBRXBILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FYYjtBQVlMO0FBQ0FtRyw0QkFBZ0IsRUFBRXJILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FiYjtBQWNMO0FBQ0FxSCxtQkFBTyxFQUFFLElBZko7QUFnQkxDLG1CQUFPLEVBQUV2SCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBaEJKO0FBaUJMdUgsaUJBQUssRUFBRTtBQWpCRixXQVRGO0FBNEJQOUUsb0JBQVUsRUFBRTtBQUNSNkUsbUJBQU8sRUFBRSxJQUREO0FBRVJFLHNCQUFVLEVBQUU5STtBQUZKLFdBNUJMO0FBZ0NQO0FBQ0ErSSxrQkFBUSxFQUFFO0FBQ047QUFDQUMsbUJBQU8sRUFBRTNILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLE9BQWQsQ0FGSDtBQUdOMkgsb0JBQVEsRUFBRTVILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FISjtBQUlONEgsaUJBQUssRUFBRTdILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FKRDtBQUtOMkIsa0JBQU0sRUFBRTVCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FMRjtBQU1ONkgsc0JBQVUsRUFBRTlILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FOTjtBQU9ONkcsMEJBQWMsRUFBRS9ILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FQVjtBQVFOO0FBQ0FvRyxtQkFBTyxFQUFFO0FBVEg7QUFqQ0gsU0FsT0Y7QUErUVQvSSxxQkFBYSxFQUFFO0FBQ1g7OztBQUdBeUosbUJBQVMsRUFBRTtBQUNQOzs7QUFHQSx1QkFBVyxLQUFLeEkscUJBQUwsQ0FBMkIsa0JBQTNCO0FBSkosV0FKQTs7QUFVWDs7OztBQUlBeUkseUJBQWUsRUFBRWpJLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQUtHLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDLENBQWQsQ0FkTjtBQWVYO0FBQ0E4SCxxQkFBVyxFQUFFLEtBQUsxSSxxQkFBTCxDQUEyQixjQUEzQixDQWhCRjtBQWlCWDtBQUNBMkkseUJBQWUsRUFBRSxLQUFLM0kscUJBQUwsQ0FBMkIsa0JBQTNCLENBbEJOO0FBbUJYO0FBQ0E0SSxtQkFBUyxFQUFFLElBcEJBO0FBcUJYO0FBQ0FDLGNBQUksRUFBRSxLQUFLN0kscUJBQUwsQ0FBMkIsTUFBM0IsS0FBc0MsRUF0QmpDOztBQXVCWDs7Ozs7QUFLQThJLGdCQUFNLEVBQUV0SSxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxRQUFELENBQWIsSUFBMkIsRUFBekMsQ0E1Qkc7QUE2QlhnSyxxQkFBVyxFQUFFdkksRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsY0FBRCxDQUFiLElBQWlDSSxTQUEvQztBQTdCRjtBQS9RTixPQUFiO0FBK1NIO0FBOVdMO0FBQUE7O0FBZ1hJOzs7QUFoWEosb0NBbVhvQjtBQUNaLFVBQUk2SixTQUFTLEdBQUcsS0FBSzNJLEtBQUwsQ0FBV3RCLGFBQTNCO0FBQ0EsVUFBSWtLLEdBQUcsR0FBR0Msa0VBQWEsQ0FBQyxJQUFELENBQXZCO0FBQ0FGLGVBQVMsQ0FBQ0osU0FBVixHQUFzQk8sNkNBQUMsQ0FBQ0gsU0FBUyxDQUFDTCxlQUFYLENBQUQsQ0FBNkJTLElBQTdCLENBQWtDRCw2Q0FBQyxDQUFDRixHQUFELENBQW5DLENBQXRCO0FBQ0g7QUF2WEw7QUFBQTtBQUFBLG1DQXlYbUJJLGFBelhuQixFQXlYa0M7QUFDMUIsV0FBS0MsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJ0RSxjQUF2QixDQUFzQ29FLGFBQXRDO0FBQ0g7QUEzWEw7QUFBQTtBQUFBLDZCQTZYYXBILElBN1hiLEVBNlhtQixDQUNYO0FBQ0g7QUEvWEw7QUFBQTtBQUFBLDBDQWlZMEJ1SCxPQWpZMUIsRUFpWW1DLENBQzNCO0FBQ0g7QUFuWUw7QUFBQTtBQUFBLHFDQXFZcUJ4SyxVQXJZckIsRUFxWWlDO0FBQ3pCLFdBQUtxQixLQUFMLENBQVdwQixVQUFYLENBQXNCdUQsSUFBdEIsQ0FBMkJ4RCxVQUFVLENBQUN5SyxhQUF0QztBQUNBOUgsMEVBQW9CLENBQUMzQyxVQUFVLENBQUMwSyxvQkFBWixFQUFrQyxLQUFLckosS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnlELFVBQXhELENBQXBCO0FBQ0g7QUF4WUw7QUFBQTtBQUFBLG1DQTBZbUJ6RCxVQTFZbkIsRUEwWStCRCxVQTFZL0IsRUEwWTJDO0FBQ25DLFVBQUksQ0FBQ0MsVUFBTCxFQUFpQjtBQUNiO0FBQ0EsYUFBSzBLLGdCQUFMLENBQXNCM0ssVUFBdEI7QUFDQSxlQUFPLEtBQVA7QUFDSCxPQUxrQyxDQU1uQzs7O0FBQ0EsV0FBS3FCLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0JzQixFQUF0QixDQUF5QnRCLFVBQVUsQ0FBQ3NCLEVBQXBDO0FBQ0EsV0FBS0YsS0FBTCxDQUFXMkMsT0FBWCxDQUFtQjZCLG9CQUFuQixDQUF3QzVGLFVBQVUsQ0FBQ3VELElBQW5EO0FBQ0EsV0FBS25DLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0J1RCxJQUF0QixDQUEyQkMsK0RBQVcsQ0FBQ3hELFVBQVUsQ0FBQ3VELElBQVosRUFBa0IsS0FBS25DLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUIrSixNQUF6QixFQUFsQixDQUFYLElBQW1FLEVBQTlGO0FBQ0EsV0FBS3pJLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I0RCxPQUF0QixDQUE4QjVELFVBQVUsQ0FBQzRELE9BQXpDO0FBQ0EsV0FBS3hDLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IyRCxLQUF0QixDQUE0QjNELFVBQVUsQ0FBQzJELEtBQXZDO0FBQ0EsV0FBS3ZDLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IwRCxRQUF0QixDQUErQjFELFVBQVUsQ0FBQzBELFFBQTFDO0FBQ0EsV0FBS3RDLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IrQixHQUF0QixDQUEwQi9CLFVBQVUsQ0FBQytCLEdBQXJDO0FBQ0EsV0FBS1gsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQitDLE9BQXRCLENBQThCL0MsVUFBVSxDQUFDK0MsT0FBekM7QUFDQSxXQUFLM0IsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQjhELGFBQXRCLENBQW9DOUQsVUFBVSxDQUFDMkssY0FBWCxJQUE2QkMsOEVBQWtCLENBQUNDLE9BQXBGO0FBQ0EsV0FBS3pKLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I2RCxnQkFBdEIsQ0FBdUM3RCxVQUFVLENBQUM4SyxpQkFBWCxJQUFnQ0YsOEVBQWtCLENBQUNDLE9BQTFGO0FBQ0EsV0FBS3pKLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I4QyxPQUF0QixDQUE4QjlDLFVBQVUsQ0FBQytLLE9BQXpDO0FBQ0EsV0FBSzNKLEtBQUwsQ0FBV0MsSUFBWCxDQUFnQk8sUUFBaEIsQ0FBeUI1QixVQUFVLENBQUNnTCxTQUFwQztBQUNBdEksMEVBQW9CLENBQUMxQyxVQUFVLENBQUNpTCxXQUFaLEVBQXlCLEtBQUs3SixLQUFMLENBQVdwQixVQUFYLENBQXNCeUQsVUFBL0MsQ0FBcEI7QUFDSDtBQTlaTDtBQUFBO0FBQUEsd0NBZ2F3QnlILElBaGF4QixFQWdhOEI7QUFDdEJDLGFBQU8sQ0FBQ0MsS0FBUixDQUFjRixJQUFkO0FBQ0EsV0FBS0csY0FBTDtBQUNBLFdBQUtoQixVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJDLGtCQUEzQjtBQUNBLFVBQUlDLGtCQUFrQixHQUFHLEtBQUtwSyxLQUFMLENBQVd0QixhQUFYLENBQXlCMEosZUFBekIsRUFBekI7QUFDQSxXQUFLcEksS0FBTCxDQUFXdEIsYUFBWCxDQUF5QjBKLGVBQXpCLENBQXlDLEtBQXpDO0FBQ0EsVUFBSXpKLFVBQVUsR0FBR21MLElBQUksQ0FBQ25MLFVBQXRCO0FBQ0EsV0FBS3FCLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0J1QixFQUF0QixDQUF5QnZCLFVBQVUsQ0FBQ3VCLEVBQXBDO0FBQ0EsV0FBS0YsS0FBTCxDQUFXckIsVUFBWCxDQUFzQmdELE9BQXRCLENBQThCaEQsVUFBVSxDQUFDZ0QsT0FBekM7QUFDQSxXQUFLM0IsS0FBTCxDQUFXckIsVUFBWCxDQUFzQjZCLFFBQXRCLENBQStCN0IsVUFBVSxDQUFDaUwsU0FBMUM7QUFDQSxXQUFLNUosS0FBTCxDQUFXckIsVUFBWCxDQUFzQjZDLFFBQXRCLENBQStCN0MsVUFBVSxDQUFDMEwsU0FBMUM7QUFDQSxXQUFLckssS0FBTCxDQUFXckIsVUFBWCxDQUFzQjhDLGFBQXRCLENBQW9DOUMsVUFBVSxDQUFDMkwsY0FBL0M7QUFDQSxXQUFLdEssS0FBTCxDQUFXckIsVUFBWCxDQUFzQm9ELE1BQXRCLENBQTZCcEQsVUFBVSxDQUFDb0QsTUFBeEM7QUFDQSxXQUFLL0IsS0FBTCxDQUFXckIsVUFBWCxDQUFzQm1ELFFBQXRCLENBQStCbkQsVUFBVSxDQUFDbUQsUUFBMUM7QUFDQSxXQUFLOUIsS0FBTCxDQUFXckIsVUFBWCxXQUE2QkEsVUFBVSxVQUF2QztBQUNBLFdBQUtxQixLQUFMLENBQVdyQixVQUFYLENBQXNCaUMsSUFBdEIsQ0FBMkJqQyxVQUFVLENBQUNpQyxJQUF0QztBQUNBLFdBQUtaLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JnQyxHQUF0QixDQUEwQmhDLFVBQVUsQ0FBQ2dDLEdBQXJDO0FBQ0EsV0FBS1gsS0FBTCxDQUFXckIsVUFBWCxDQUFzQm9DLE1BQXRCLENBQTZCcEMsVUFBVSxDQUFDb0MsTUFBeEM7QUFDQSxXQUFLZixLQUFMLENBQVdyQixVQUFYLENBQXNCcUQsUUFBdEIsQ0FBK0JyRCxVQUFVLENBQUM0TCxTQUExQztBQUNBLFdBQUt2SyxLQUFMLENBQVdyQixVQUFYLENBQXNCK0IsWUFBdEIsQ0FBbUMvQixVQUFVLENBQUMrQixZQUE5QztBQUNBLFdBQUtWLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0IwQixJQUF0QixDQUEyQjFCLFVBQVUsQ0FBQzBCLElBQXRDO0FBQ0EsV0FBS0wsS0FBTCxDQUFXckIsVUFBWCxDQUFzQnVDLFFBQXRCLENBQStCdkMsVUFBVSxDQUFDNkwsU0FBWCxJQUF3QixJQUF2RDs7QUFDQSxVQUFJN0wsVUFBVSxDQUFDNkwsU0FBZixFQUEwQjtBQUN0QixhQUFLdkIsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQyxlQUFuQyxFQUFvRDlMLFVBQVUsQ0FBQzZMLFNBQS9EO0FBQ0g7O0FBQ0QsV0FBS3hLLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0J3QyxNQUF0QixDQUE2QnhDLFVBQVUsQ0FBQytMLE9BQVgsSUFBc0IsSUFBbkQ7O0FBQ0EsVUFBSS9MLFVBQVUsQ0FBQytMLE9BQWYsRUFBd0I7QUFDcEIsYUFBS3pCLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUMsYUFBbkMsRUFBa0Q5TCxVQUFVLENBQUMrTCxPQUE3RDtBQUNIOztBQUNELFdBQUsxSyxLQUFMLENBQVdyQixVQUFYLENBQXNCc0MsS0FBdEIsQ0FBNEJ0QyxVQUFVLENBQUNnTSxNQUF2QztBQUNBLFdBQUszSyxLQUFMLENBQVdyQixVQUFYLENBQXNCcUMsWUFBdEIsQ0FBbUNyQyxVQUFVLENBQUN5SyxhQUE5QztBQUNBLFdBQUtwSixLQUFMLENBQVdyQixVQUFYLENBQXNCK0MsT0FBdEIsQ0FBOEIvQyxVQUFVLENBQUNpTSxRQUF6QztBQUNBLFdBQUtDLFFBQUwsQ0FBY2xNLFVBQVUsQ0FBQ2lELElBQXpCO0FBQ0EsV0FBS2tKLHFCQUFMLENBQTJCbk0sVUFBVSxDQUFDb00sa0JBQXRDO0FBQ0F6SiwwRUFBb0IsQ0FBQzNDLFVBQVUsQ0FBQ3FNLHNCQUFaLEVBQW9DLEtBQUtoTCxLQUFMLENBQVdyQixVQUFYLENBQXNCeUMsb0JBQTFELENBQXBCO0FBQ0FFLDBFQUFvQixDQUFDM0MsVUFBVSxDQUFDMEssb0JBQVosRUFBa0MsS0FBS3JKLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0I0QyxrQkFBeEQsQ0FBcEI7QUFDQTBKLGlHQUFzQixDQUFDLEtBQUtqTCxLQUFOLEVBQWFyQixVQUFVLENBQUNzRCxRQUF4QixDQUF0QjtBQUNBLFdBQUtpSixjQUFMLENBQW9CcEIsSUFBSSxDQUFDbEwsVUFBekIsRUFBcUNELFVBQXJDO0FBQ0EsV0FBS3FCLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUJvQixlQUFuQixDQUFtQyxJQUFuQztBQUNBLFdBQUsvRCxLQUFMLENBQVcyQyxPQUFYLENBQW1Ca0IsbUJBQW5CLENBQXVDLElBQXZDO0FBQ0EsV0FBSzdELEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUIwSixlQUF6QixDQUF5Q2dDLGtCQUF6QztBQUNBLFdBQUtuQixVQUFMLENBQWdCa0MsTUFBaEIsQ0FBdUJDLFlBQXZCLENBQW9DLElBQXBDO0FBQ0EsV0FBS25DLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QkMsRUFBN0IsQ0FBZ0NDLE9BQWhDO0FBQ0EsV0FBS3RDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQnNCLGVBQTNCO0FBRUEsV0FBS3ZDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCdUMsU0FBdkIsQ0FBaUMsVUFBakMsRUFBNkM1RyxxREFBVyxDQUFDQyxLQUF6RDtBQUNIO0FBOWNMO0FBQUE7QUFBQSx1Q0FnZHVCO0FBQUE7O0FBQ2YsVUFBSTRHLElBQUksR0FBRyxJQUFYO0FBQ0EsVUFBSTFMLEtBQUssR0FBRyxLQUFLQSxLQUFqQjtBQUNBQSxXQUFLLENBQUMyTCxFQUFOLEdBQVc7QUFDUEMsbUJBQVcsRUFBRXpMLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxpQkFDekIsQ0FBQzdMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxFQUFELElBQStCN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMkosV0FBMUIsRUFETjtBQUFBLFNBQWhCLENBRE47QUFHUHRMLFlBQUksRUFBRTtBQUNGd0wsa0JBQVEsRUFBRTNMLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdEI3TCxLQUFLLENBQUNDLElBQU4sQ0FBV0ssSUFBWCxPQUFzQixPQUF0QixJQUFpQ04sS0FBSyxDQUFDQyxJQUFOLENBQVdLLElBQVgsT0FBc0IsUUFEakM7QUFBQSxXQUFoQjtBQURSLFNBSEM7QUFPUEksb0JBQVksRUFBRTtBQUNWcUwsbUJBQVMsRUFBRTVMLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdkI3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNrQixtQkFBZCxPQUF3QyxJQURqQjtBQUFBLFdBQWhCLENBREQ7QUFJVm1JLGlCQUFPLEVBQUU3TCxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ3JCN0wsS0FBSyxDQUFDMkwsRUFBTixDQUFTakwsWUFBVCxDQUFzQnFMLFNBQXRCLEtBQ0lMLElBQUksQ0FBQ08sU0FBTCxDQUFlQyxRQUFmLENBQXdCbE0sS0FBSyxDQUFDMkMsT0FBTixDQUFja0IsbUJBQWQsRUFBeEIsQ0FESixHQUVJNkgsSUFBSSxDQUFDTyxTQUFMLENBQWVDLFFBQWYsQ0FBd0JsTSxLQUFLLENBQUNyQixVQUFOLENBQWlCK0IsWUFBakIsRUFBeEIsQ0FIaUI7QUFBQSxXQUFoQixDQUpDO0FBU1Z5TCxlQUFLLEVBQUU7QUFBQSxtQkFDSG5NLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY2tCLG1CQUFkLENBQWtDLElBQWxDLENBREc7QUFBQTtBQVRHLFNBUFA7QUFtQlB1SSxZQUFJLEVBQUU7QUFDRkMsaUJBQU8sRUFBRWxNLEVBQUUsQ0FBQzBMLFlBQUgsQ0FDTDtBQUFBLG1CQUNJN0wsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLE1BQThCLENBQUM3QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJxSyxlQUExQixFQURuQztBQUFBLFdBREssQ0FEUDtBQUtGQyx3QkFBYyxFQUFFcE0sRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUMzQjdMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY3FCLFVBQWQsRUFBRCxHQUErQix3QkFBL0IsR0FBMEQsc0JBRDlCO0FBQUEsV0FBaEIsQ0FMZDtBQVFGd0kseUJBQWUsRUFBRSwyQkFBSztBQUNsQnhNLGlCQUFLLENBQUMyQyxPQUFOLENBQWNxQixVQUFkLENBQXlCLENBQUNoRSxLQUFLLENBQUMyQyxPQUFOLENBQWNxQixVQUFkLEVBQTFCO0FBQ0gsV0FWQztBQVdGeUksb0JBQVUsRUFBRSxzQkFBTTtBQUNkLGlCQUFJLENBQUN4RCxVQUFMLENBQWdCeUQsTUFBaEIsQ0FBdUJDLFdBQXZCO0FBQ0gsV0FiQztBQWNGQyxzQkFBWSxFQUFFLHdCQUFNO0FBQ2hCLGdCQUFJNU0sS0FBSyxDQUFDMkMsT0FBTixDQUFjd0IsWUFBZCxFQUFKLEVBQWtDO0FBQzlCdUgsa0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QkMsRUFBN0IsQ0FBZ0N1QixVQUFoQyxDQUEyQ0MsYUFBM0M7QUFDSCxhQUZELE1BRU87QUFDSHBCLGtCQUFJLENBQUN6QyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJDLEVBQTdCLENBQWdDdUIsVUFBaEMsQ0FBMkNFLFlBQTNDO0FBQ0g7O0FBQ0QvTSxpQkFBSyxDQUFDMkMsT0FBTixDQUFjd0IsWUFBZCxDQUEyQixDQUFDbkUsS0FBSyxDQUFDMkMsT0FBTixDQUFjd0IsWUFBZCxFQUE1QjtBQUNILFdBckJDO0FBc0JGNkksMEJBQWdCLEVBQUU3TSxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQzlCN0wsS0FBSyxDQUFDckIsVUFBTixDQUFpQm9ELE1BQWpCLE1BQTZCL0IsS0FBSyxDQUFDckIsVUFBTixDQUFpQm1ELFFBQWpCLEVBQTdCLElBQ0E5QixLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJnTCxRQUExQixFQUY4QjtBQUFBLFdBQWhCLENBdEJoQjtBQTBCRkMsMkJBQWlCLEVBQUUvTSxFQUFFLENBQUMwTCxZQUFILENBQWdCLFlBQU07QUFDckMsZ0JBQUk3TCxLQUFLLENBQUMyTCxFQUFOLENBQVNTLElBQVQsQ0FBY2UsV0FBZCxFQUFKLEVBQWlDO0FBQzdCLHFCQUFPbk4sS0FBSyxDQUFDQyxJQUFOLENBQVdRLE9BQVgsS0FBdUIsZ0JBQXZCLEdBQTBDLG1CQUFqRDtBQUNILGFBRkQsTUFFTyxJQUFJVCxLQUFLLENBQUMyTCxFQUFOLENBQVNTLElBQVQsQ0FBY2dCLFdBQWQsRUFBSixFQUFpQztBQUNwQyxxQkFBTyxvQkFBUDtBQUNILGFBRk0sTUFFQSxJQUFJcE4sS0FBSyxDQUFDMkMsT0FBTixDQUFjb0IsZUFBZCxFQUFKLEVBQXFDO0FBQ3hDLHFCQUFPLEtBQVA7QUFDSCxhQUZNLE1BRUE7QUFDSCxrQkFBSSxDQUFDL0QsS0FBSyxDQUFDckIsVUFBTixDQUFpQm9ELE1BQWpCLEVBQUQsSUFBOEIvQixLQUFLLENBQUNwQixVQUFOLENBQWlCNEQsT0FBakIsRUFBbEMsRUFBOEQ7QUFDMUQsdUJBQU8sUUFBUDtBQUNILGVBRkQsTUFFTztBQUNILHVCQUFPLGNBQVA7QUFDSDtBQUNKO0FBQ0osV0Fka0IsQ0ExQmpCO0FBeUNGNkssNEJBQWtCLEVBQUUsOEJBQU07QUFDdEIsZ0JBQUlyTixLQUFLLENBQUMyTCxFQUFOLENBQVNTLElBQVQsQ0FBY2UsV0FBZCxFQUFKLEVBQWlDO0FBQzdCRyxtQkFBSyxDQUFDLHlEQUFELENBQUw7QUFDSCxhQUZELE1BRU8sSUFBSXROLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU1MsSUFBVCxDQUFjZ0IsV0FBZCxFQUFKLEVBQWlDO0FBQ3BDMUIsa0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCbEQsc0JBQXZCLENBQThDLFlBQTlDO0FBQ0gsYUFGTSxNQUVBLElBQUloRyxLQUFLLENBQUMyQyxPQUFOLENBQWNvQixlQUFkLEVBQUosRUFBcUM7QUFDeEMySCxrQkFBSSxDQUFDekMsVUFBTCxDQUFnQnNFLE1BQWhCLENBQXVCQyxVQUF2QjtBQUNILGFBRk0sTUFFQTtBQUNIOUIsa0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCbEQsc0JBQXZCLENBQThDLFdBQTlDO0FBQ0g7QUFDSixXQW5EQztBQW9ERm9ILHFCQUFXLEVBQUVqTixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ3pCLENBQUM3TCxLQUFLLENBQUNyQixVQUFOLENBQWlCbUQsUUFBakIsTUFBK0I5QixLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJnTCxRQUExQixFQUFoQyxLQUNBak4sS0FBSyxDQUFDcEIsVUFBTixDQUFpQjZELGdCQUFqQixHQUFvQ2dMLFdBQXBDLE9BQXNELFdBRjdCO0FBQUEsV0FBaEIsQ0FwRFg7QUF3REZOLHFCQUFXLEVBQUVoTixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ3pCN0wsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjZELGdCQUFqQixHQUFvQ2dMLFdBQXBDLE9BQXNELFdBRDdCO0FBQUEsV0FBaEIsQ0F4RFg7QUEyREZDLDBCQUFnQixFQUFFdk4sRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUM5QixDQUFDN0wsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMEwsZ0JBQTFCLEVBRDZCO0FBQUEsV0FBaEIsQ0EzRGhCO0FBOERGQyxtQkFBUyxFQUFFek4sRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUN2QixDQUFDN0wsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCNEwsUUFBMUIsRUFEc0I7QUFBQSxXQUFoQjtBQTlEVCxTQW5CQztBQXFGUEMsaUJBQVMsRUFBRTtBQUNQQyxlQUFLLEVBQUU1TixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ25CN0wsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLE1BQThCLENBQUM3QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIySixXQUExQixFQUEvQixHQUNJLFdBREosR0FDa0IsVUFGQztBQUFBLFdBQWhCLENBREE7QUFLUG9DLHlCQUFlLEVBQUU3TixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQzdCLENBQUM3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFBRCxJQUErQjdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQitMLGVBQTFCLEVBREY7QUFBQSxXQUFoQixDQUxWO0FBUVBDLHNCQUFZLEVBQUU5TixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQzFCLENBQUM3TCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJpTSxlQUExQixFQUR5QjtBQUFBLFdBQWhCLENBUlA7QUFXUEMsMkJBQWlCLEVBQUVoTyxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQy9CN0wsS0FBSyxDQUFDMkMsT0FBTixDQUFjWSxvQkFBZCxPQUF5Q0Msd0VBQTJCLENBQUNDLFFBRHRDO0FBQUEsV0FBaEIsQ0FYWjtBQWNQMkssd0JBQWMsRUFBRWpPLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDNUI3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNZLG9CQUFkLE9BQXlDQyx3RUFBMkIsQ0FBQzZLLEtBRHpDO0FBQUEsV0FBaEIsQ0FkVDtBQWlCUEMsOEJBQW9CLEVBQUVuTyxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ2xDN0wsS0FBSyxDQUFDMkwsRUFBTixDQUFTbUMsU0FBVCxDQUFtQkssaUJBQW5CLE1BQTBDbk8sS0FBSyxDQUFDMkwsRUFBTixDQUFTbUMsU0FBVCxDQUFtQk0sY0FBbkIsRUFEUjtBQUFBLFdBQWhCLENBakJmO0FBb0JQRyxxQkFBVyxFQUFFcE8sRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUN6QjdMLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixPQUF1QyxJQUF2QyxHQUNJLFlBREosR0FDbUIsRUFGTTtBQUFBLFdBQWhCLENBcEJOO0FBd0JQb0gsc0JBQVksRUFBRSx3QkFBWTtBQUN0QixnQkFBSUMsWUFBWSxHQUFHek8sS0FBSyxDQUFDMkMsT0FBTixDQUFjWSxvQkFBakM7O0FBQ0EsZ0JBQUlrTCxZQUFZLE9BQU9qTCx3RUFBMkIsQ0FBQ2tMLElBQW5ELEVBQXlEO0FBQ3JERCwwQkFBWSxDQUFDakwsd0VBQTJCLENBQUNDLFFBQTdCLENBQVo7QUFDSCxhQUZELE1BRU8sSUFBSWdMLFlBQVksT0FBT2pMLHdFQUEyQixDQUFDNkssS0FBbkQsRUFBMEQ7QUFDN0RJLDBCQUFZLENBQUNqTCx3RUFBMkIsQ0FBQ2tMLElBQTdCLENBQVo7QUFDSCxhQUZNLE1BRUEsSUFBSTFPLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixPQUF1QyxJQUEzQyxFQUFpRDtBQUNwRHFILDBCQUFZLENBQUNqTCx3RUFBMkIsQ0FBQzZLLEtBQTdCLENBQVo7QUFDSCxhQUZNLE1BRUE7QUFDSEksMEJBQVksQ0FBQ2pMLHdFQUEyQixDQUFDa0wsSUFBN0IsQ0FBWjtBQUNIO0FBQ0osV0FuQ007QUFvQ1BDLGtCQUFRLEVBQUUsb0JBQVk7QUFDbEIsZ0JBQU1GLFlBQVksR0FBR3pPLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY1ksb0JBQW5DO0FBQ0F2RCxpQkFBSyxDQUFDMkMsT0FBTixDQUFjZSw0QkFBZCxDQUEyQytLLFlBQVksRUFBdkQ7QUFDQUEsd0JBQVksQ0FBQ2pMLHdFQUEyQixDQUFDa0wsSUFBN0IsQ0FBWjtBQUNILFdBeENNO0FBeUNQRSxzQkFBWSxFQUFFLHdCQUFXO0FBQ3JCLGdCQUFNQyxRQUFRLEdBQUc3TyxLQUFLLENBQUMyQyxPQUFOLENBQWNlLDRCQUEvQjs7QUFDQSxnQkFBSW1MLFFBQVEsT0FBTyxJQUFuQixFQUF5QjtBQUNyQjdPLG1CQUFLLENBQUMyQyxPQUFOLENBQWNZLG9CQUFkLENBQW1Dc0wsUUFBUSxFQUEzQztBQUNBQSxzQkFBUSxDQUFDLElBQUQsQ0FBUjtBQUNIO0FBQ0o7QUEvQ00sU0FyRko7QUFzSVA5RSxlQUFPLEVBQUU7QUFDTCtFLGNBQUksRUFBRTNPLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDakIsQ0FBQzdMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxFQUFELElBQStCN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMkosV0FBMUIsRUFBaEMsSUFDQzVMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY1ksb0JBQWQsT0FBeUNDLHdFQUEyQixDQUFDa0wsSUFEdEUsR0FFSSxXQUZKLEdBR0ksVUFKYztBQUFBLFdBQWhCLENBREQ7QUFPTEssc0JBQVksRUFBRTVPLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBaUI7QUFBQSxtQkFDM0I3TCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI4TSxZQUExQixNQUE0QyxDQUFDL08sS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JRLE9BQXhCLEVBQTdDLElBQ0ExSCxLQUFLLENBQUMyRSxNQUFOLENBQWFpQyxXQUFiLE9BQStCL0IscURBQVcsQ0FBQ21LLE1BRmhCO0FBQUEsV0FBakI7QUFQVCxTQXRJRjtBQWtKUG5ILGdCQUFRLEVBQUU7QUFDTm9ILGVBQUssRUFBRTlPLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0IsWUFBWTtBQUMvQixnQkFBSTdMLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkUsUUFBekIsT0FBd0MsSUFBNUMsRUFBa0Q7QUFDOUMscUJBQU8sWUFBUDtBQUNIOztBQUNELG9CQUFRL0gsS0FBSyxDQUFDNkcsU0FBTixDQUFnQmdCLFFBQWhCLENBQXlCRSxRQUF6QixHQUFvQzBGLFdBQXBDLEVBQVI7QUFDSTtBQUNBLG1CQUFLLE1BQUw7QUFDSSx1QkFBTyxZQUFQOztBQUNKLG1CQUFLLFNBQUw7QUFDSSx1QkFBTyxxQkFBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sb0JBQVA7O0FBQ0osbUJBQUssUUFBTDtBQUNJLHVCQUFPLG9CQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxzQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0EsbUJBQUssVUFBTDtBQUNJLHVCQUFPLHNCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDQSxtQkFBSyxZQUFMO0FBQ0ksdUJBQU8sc0JBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNJLHVCQUFPLHdCQUFQOztBQUNKLG1CQUFLLGNBQUw7QUFDSSx1QkFBTyxvQkFBUDs7QUFDSixtQkFBSyxXQUFMO0FBQ0ksdUJBQU8saUJBQVA7QUF2QlI7QUF5QkgsV0E3Qk0sQ0FERDtBQStCTjFGLGtCQUFRLEVBQUU1SCxFQUFFLENBQUMwTCxZQUFILENBQWdCLFlBQVk7QUFDbEMsZ0JBQUk3TCxLQUFLLENBQUM2RyxTQUFOLENBQWdCZ0IsUUFBaEIsQ0FBeUJFLFFBQXpCLE9BQXdDLElBQTVDLEVBQWtEO0FBQzlDLHFCQUFPLEVBQVA7QUFDSDs7QUFDRCxvQkFBUS9ILEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkUsUUFBekIsR0FBb0MwRixXQUFwQyxFQUFSO0FBQ0k7QUFDQSxtQkFBSyxNQUFMO0FBQ0ksdUJBQU8sRUFBUDs7QUFDSixtQkFBSyxTQUFMO0FBQ0ksdUJBQU8sZUFBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sY0FBUDs7QUFDSixtQkFBSyxRQUFMO0FBQ0ksdUJBQU8sY0FBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0ksdUJBQU8sZ0JBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNBLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxpQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0EsbUJBQUssY0FBTDtBQUNJLHVCQUFPLGNBQVA7O0FBQ0osbUJBQUssWUFBTDtBQUNJLHVCQUFPLGtCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxVQUFQOztBQUNKLG1CQUFLLFdBQUw7QUFDSSx1QkFBTyxXQUFQO0FBdkJSO0FBeUJILFdBN0JTLENBL0JKO0FBNkROeUIsb0JBQVUsRUFBRSxzQkFBTTtBQUNkbFAsaUJBQUssQ0FBQ3BCLFVBQU4sQ0FBaUIyRCxLQUFqQixDQUF1QixDQUF2QjtBQUNBdkMsaUJBQUssQ0FBQ3BCLFVBQU4sQ0FBaUI0RCxPQUFqQixDQUF5QixLQUF6QjtBQUNBa0osZ0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCcEQsZ0JBQXZCLENBQXdDOUYsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjJELEtBQWpCLEVBQXhDLEVBQWtFdkMsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjRELE9BQWpCLEVBQWxFLEVBQThGLElBQTlGLEVBQW9HLElBQXBHO0FBQ0gsV0FqRUs7QUFrRU4yTSx3QkFBYyxFQUFFaFAsRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUM1QixDQUFDN0wsS0FBSyxDQUFDckIsVUFBTixDQUFpQm9ELE1BQWpCLEVBRDJCO0FBQUEsV0FBaEIsQ0FsRVY7QUFxRU5xTixvQkFBVSxFQUFFLHNCQUFNO0FBQ2QsZ0JBQU1DLFFBQVEsR0FBRyxDQUFDclAsS0FBSyxDQUFDMkMsT0FBTixDQUFjOEIsVUFBZCxFQUFsQjtBQUNBekUsaUJBQUssQ0FBQzJDLE9BQU4sQ0FBYzhCLFVBQWQsQ0FBeUI0SyxRQUF6QjtBQUNBM0QsZ0JBQUksQ0FBQzlMLGNBQUwsQ0FBb0IwUCxHQUFwQixDQUF3QixvQkFBeEIsRUFBOENELFFBQVEsQ0FBQy9LLFFBQVQsRUFBOUM7QUFDSCxXQXpFSztBQTBFTmlMLGNBQUksRUFBRSxjQUFDQyxNQUFELEVBQVk7QUFDZDlELGdCQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLFVBQWhDLEVBQ2dDdEYsS0FBSyxDQUFDNkcsU0FBTixDQUFnQmdCLFFBQWhCLENBQXlCRSxRQUF6QixFQURoQyxFQUVnQy9ILEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkcsS0FBekIsRUFGaEMsRUFHZ0N3SCxNQUhoQztBQUlBeFAsaUJBQUssQ0FBQ3RCLGFBQU4sQ0FBb0I2SixTQUFwQixDQUE4QmtILElBQTlCLENBQW1DLGlCQUFuQyxFQUFzREMsT0FBdEQsQ0FBOEQsR0FBOUQsRUFBbUUsWUFBVztBQUMxRTVHLDJEQUFDLENBQUMsSUFBRCxDQUFELENBQVE2RyxNQUFSLENBQWUsR0FBZjtBQUNBM1AsbUJBQUssQ0FBQzJDLE9BQU4sQ0FBYytCLFFBQWQsQ0FBdUIsSUFBdkI7QUFDSCxhQUhEO0FBSUEsZ0JBQU1rTCxRQUFRLEdBQUc1UCxLQUFLLENBQUN0QixhQUFOLENBQW9CNkosU0FBcEIsQ0FBOEJrSCxJQUE5QixDQUFtQyw2QkFBbkMsQ0FBakI7QUFDQUcsb0JBQVEsQ0FBQ0MsUUFBVCxDQUFrQixNQUFsQjtBQUNBQyxzQkFBVSxDQUFDLFlBQU07QUFDYkYsc0JBQVEsQ0FBQ0csV0FBVCxDQUFxQixNQUFyQjtBQUNILGFBRlMsRUFFUCxJQUZPLENBQVY7QUFHSCxXQXhGSztBQXlGTkMsdUJBQWEsRUFBRTdQLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDM0I3TCxLQUFLLENBQUMyQyxPQUFOLENBQWMrQixRQUFkLEtBQTJCLEtBQTNCLEdBQW1DLEtBRFI7QUFBQSxXQUFoQjtBQXpGVCxTQWxKSDtBQStPUHVMLGFBQUssRUFBRTtBQUNIcFEsYUFBRyxFQUFFTSxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ2pCN0wsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JLLGdCQUF4QixPQUErQyxJQUQ5QjtBQUFBLFdBQWhCLENBREY7QUFJSDJJLHlCQUFlLEVBQUUvUCxFQUFFLENBQUMwTCxZQUFILENBQWdCLFlBQU07QUFDbkMsZ0JBQUk3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNZLG9CQUFkLE9BQXlDQyx3RUFBMkIsQ0FBQzZLLEtBQXpFLEVBQWdGO0FBQzVFLHFCQUFPLEVBQVA7QUFDSDs7QUFDRCxnQkFBSThCLElBQUksR0FBR25RLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsRUFBWDtBQUNBLGdCQUFJSixRQUFRLEdBQUdwSCxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBZjtBQUNBLGdCQUFJZ0osU0FBUyxHQUFHcFEsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JLLGdCQUF4QixFQUFoQjs7QUFDQSxnQkFBSSxDQUFDNkksU0FBRCxJQUFjRCxJQUFJLEtBQUssSUFBM0IsRUFBaUM7QUFDN0IscUJBQU8sRUFBUDtBQUNILGFBRkQsTUFFTyxJQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNuQixxQkFBTyxFQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0gscUJBQU8sQ0FBQ0MsU0FBUyxDQUFDRCxJQUFJLEdBQUMsQ0FBTixDQUFULENBQWtCRSxJQUFuQixDQUFQO0FBQ0g7QUFDSixXQWRnQixDQUpkO0FBbUJIQSxjQUFJLEVBQUVsUSxFQUFFLENBQUMwTCxZQUFILENBQWdCLFlBQVk7QUFDOUIsZ0JBQUlzRSxJQUFJLEdBQUduUSxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLEVBQVg7QUFDQSxnQkFBSUosUUFBUSxHQUFHcEgsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JFLFFBQXhCLEVBQWY7QUFDQSxnQkFBSWdKLFNBQVMsR0FBR3BRLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCSyxnQkFBeEIsRUFBaEI7O0FBQ0EsZ0JBQUksQ0FBQzZJLFNBQUQsSUFBY0QsSUFBSSxLQUFLLElBQTNCLEVBQWlDO0FBQzdCLHFCQUFPLFVBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDWixxQkFBTyxZQUFQO0FBQ0gsYUFGRCxNQUVPLElBQUlBLElBQUksS0FBSy9JLFFBQWIsRUFBdUI7QUFDMUIscUJBQU8sY0FBUDtBQUNILGFBRk0sTUFFQTtBQUNIO0FBQ0EscUJBQU8sVUFBU2dKLFNBQVMsQ0FBQ0QsSUFBSSxHQUFDLENBQU4sQ0FBVCxDQUFrQkUsSUFBbEM7QUFDSDtBQUNKLFdBZkssQ0FuQkg7QUFtQ0hDLGFBQUcsRUFBRW5RLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0IsWUFBWTtBQUM3QixnQkFBSXNFLElBQUksR0FBR25RLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsRUFBWDtBQUNBLGdCQUFJSixRQUFRLEdBQUdwSCxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBZjtBQUNBLGdCQUFJZ0osU0FBUyxHQUFHcFEsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JLLGdCQUF4QixFQUFoQjs7QUFDQSxnQkFBSSxDQUFDNkksU0FBTCxFQUFnQjtBQUNaLHFCQUFPLGlCQUFQO0FBQ0g7O0FBQ0Qsb0JBQVFELElBQVI7QUFDSSxtQkFBSyxDQUFMO0FBQ0ksdUJBQU8sb0JBQVA7O0FBQ0osbUJBQUsvSSxRQUFMO0FBQ0ksb0JBQUksQ0FBQ3BILEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JDLE9BQWhCLENBQXdCSSxPQUF4QixDQUFnQ3FKLE9BQXJDLEVBQThDO0FBQzFDLHlCQUFPLDBCQUFQO0FBQ0g7O0FBQ0QsdUJBQU8sb0JBQVA7O0FBQ0o7QUFDSSx1QkFBTyxtQkFBbUJDLHdEQUFnQixDQUFDSixTQUFTLENBQUNELElBQUksR0FBQyxDQUFOLENBQVQsQ0FBa0JHLEdBQW5CLENBQTFDO0FBVFI7QUFXSCxXQWxCSSxDQW5DRjtBQXNESEcsZUFBSyxFQUFFLGlCQUFZO0FBQ2Z6USxpQkFBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixDQUF5QyxDQUF6QztBQUNILFdBeERFO0FBeURIa0osa0JBQVEsRUFBRSxvQkFBWTtBQUNsQixnQkFBSUMsUUFBUSxHQUFHQyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVk3USxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLEtBQTZDLENBQXpELENBQWY7QUFDQXhILGlCQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLENBQXlDbUosUUFBekM7QUFDSCxXQTVERTtBQTZESEcsaUJBQU8sRUFBRSxtQkFBWTtBQUNqQixnQkFBSUMsSUFBSSxHQUFHSCxJQUFJLENBQUNJLEdBQUwsQ0FBU2hSLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUFULEVBQTZDcEgsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixLQUE2QyxDQUExRixDQUFYO0FBQ0F4SCxpQkFBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixDQUF5Q3VKLElBQXpDO0FBQ0gsV0FoRUU7QUFpRUhFLGNBQUksRUFBRSxnQkFBWTtBQUNkalIsaUJBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsQ0FBeUN4SCxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBekM7QUFDSCxXQW5FRTtBQW9FSDBDLGNBQUksRUFBRTNKLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0IsWUFBWTtBQUM5QixnQkFBSXNFLElBQUksR0FBR25RLEtBQUssQ0FBQzZHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsRUFBWDtBQUNBLGdCQUFJSixRQUFRLEdBQUdwSCxLQUFLLENBQUM2RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBZjtBQUNBLGdCQUFJZ0osU0FBUyxHQUFHcFEsS0FBSyxDQUFDNkcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JLLGdCQUF4QixFQUFoQjs7QUFDQSxnQkFBSSxDQUFDNkksU0FBTCxFQUFnQjtBQUNaLHFCQUFPLEVBQVA7QUFDSDs7QUFDRCxvQkFBUUQsSUFBUjtBQUNJLG1CQUFLLENBQUw7QUFDSSx1QkFBTyxFQUFQOztBQUNKLG1CQUFLL0ksUUFBTDtBQUNJLHVCQUFPZ0osU0FBUyxDQUFDRCxJQUFJLEdBQUcsQ0FBUixDQUFoQjs7QUFDSjtBQUNJLHVCQUFPQyxTQUFTLENBQUNELElBQUQsQ0FBaEI7QUFOUjtBQVFILFdBZks7QUFwRUgsU0EvT0E7QUFvVVBlLGFBQUssRUFBRTtBQUNIN0UsaUJBQU8sRUFBRWxNLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDckI3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsTUFBOEIsQ0FBQzdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmtQLFNBQTFCLEVBRFY7QUFBQSxXQUFoQixDQUROO0FBSUhwRCxlQUFLLEVBQUU1TixFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ25CN0wsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLE1BQThCLENBQUM3QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIySixXQUExQixFQUEvQixHQUNJLFdBREosR0FDa0IsVUFGQztBQUFBLFdBQWhCLENBSko7QUFRSHdGLHFCQUFXLEVBQUUscUJBQVNDLElBQVQsRUFBZTtBQUN4QixvQkFBUUEsSUFBUjtBQUNJLG1CQUFLLFdBQUw7QUFBa0IsdUJBQU9yUixLQUFLLENBQUNwQixVQUFOLENBQWlCdUQsSUFBakIsRUFBUDs7QUFDbEIsbUJBQUssa0JBQUw7QUFBeUIsdUJBQU9uQyxLQUFLLENBQUNyQixVQUFOLENBQWlCK0IsWUFBakIsRUFBUDs7QUFDekIsbUJBQUssZUFBTDtBQUFzQix1QkFBT1YsS0FBSyxDQUFDckIsVUFBTixDQUFpQnVDLFFBQWpCLE9BQWdDLElBQXZDOztBQUN0QixtQkFBSyxhQUFMO0FBQW9CLHVCQUFPbEIsS0FBSyxDQUFDckIsVUFBTixDQUFpQndDLE1BQWpCLE9BQThCLElBQXJDOztBQUNwQixtQkFBSyxvQkFBTDtBQUEyQix1QkFBT25CLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBakIsR0FBd0NrUSxJQUF4QyxDQUE2QyxVQUFBQyxJQUFJO0FBQUEseUJBQy9FQSxJQUFJLENBQUMzTyxRQUFMLE9BQW9CLG9CQUQyRDtBQUFBLGlCQUFqRCxDQUFQOztBQUUzQixtQkFBSyxpQkFBTDtBQUF3Qix1QkFBTzVDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBakIsR0FBd0NrUSxJQUF4QyxDQUE2QyxVQUFBQyxJQUFJO0FBQUEseUJBQzVFQSxJQUFJLENBQUMzTyxRQUFMLE9BQW9CLGlCQUR3RDtBQUFBLGlCQUFqRCxDQUFQOztBQUV4QixtQkFBSyxtQkFBTDtBQUEwQix1QkFBTzVDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBakIsR0FBd0NrUSxJQUF4QyxDQUE2QyxVQUFBQyxJQUFJO0FBQUEseUJBQzlFQSxJQUFJLENBQUMzTyxRQUFMLE9BQW9CLG1CQUQwRDtBQUFBLGlCQUFqRCxDQUFQOztBQUUxQixtQkFBSyxtQkFBTDtBQUEwQix1QkFBTzVDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBakIsR0FBd0NrUSxJQUF4QyxDQUE2QyxVQUFBQyxJQUFJO0FBQUEseUJBQzlFQSxJQUFJLENBQUMzTyxRQUFMLE9BQW9CLG1CQUQwRDtBQUFBLGlCQUFqRCxDQUFQOztBQUUxQixtQkFBSyxrQkFBTDtBQUF5Qix1QkFBTzVDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBakIsR0FBd0NrUSxJQUF4QyxDQUE2QyxVQUFBQyxJQUFJO0FBQUEseUJBQzdFQSxJQUFJLENBQUMzTyxRQUFMLE9BQW9CLGtCQUR5RDtBQUFBLGlCQUFqRCxDQUFQOztBQUV6QixtQkFBSyxlQUFMO0FBQXNCLHVCQUFPNUMsS0FBSyxDQUFDckIsVUFBTixDQUFpQmlELElBQWpCLEdBQXdCNFAsTUFBL0I7O0FBQ3RCLG1CQUFLLDZCQUFMO0FBQW9DLHVCQUFPeFIsS0FBSyxDQUFDckIsVUFBTixDQUFpQmtELGlCQUFqQixHQUFxQzJQLE1BQTVDOztBQUNwQztBQUFTLHVCQUFPLEtBQVA7QUFqQmI7QUFtQkgsV0E1QkU7QUE2QkhDLGFBQUcsRUFBRSxhQUFTSixJQUFULEVBQWU7QUFDaEIsb0JBQVFBLElBQVI7QUFDSSxtQkFBSyxvQkFBTDtBQUNBLG1CQUFLLG1CQUFMO0FBQ0EsbUJBQUssbUJBQUw7QUFDQSxtQkFBSyxlQUFMO0FBQ0EsbUJBQUssbUJBQUw7QUFDSTNGLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEcsSUFBbkM7QUFDQTs7QUFDSixtQkFBSyxpQkFBTDtBQUNJM0Ysb0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUM0RyxJQUFuQyxFQUF5QyxJQUF6QztBQUNBOztBQUNKLG1CQUFLLGtCQUFMO0FBQ0ksb0JBQUlLLGFBQWEsR0FBR2hHLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QkMsRUFBN0IsQ0FBZ0NxRyxXQUFoQyxDQUE0Q0MsU0FBNUMsQ0FBc0QsUUFBdEQsQ0FBcEI7QUFDQUYsNkJBQWEsR0FBR0csSUFBSSxDQUFDQyxTQUFMLENBQWVKLGFBQWYsRUFBOEIsSUFBOUIsRUFBb0MsQ0FBcEMsQ0FBaEI7QUFDQWhHLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEcsSUFBbkMsRUFBeUNLLGFBQXpDO0FBQ0E7O0FBQ0osbUJBQUssNkJBQUw7QUFDSTFSLHFCQUFLLENBQUNyQixVQUFOLENBQWlCa0QsaUJBQWpCLENBQW1DLENBQUNrUSw0RUFBZ0IsQ0FBQ0MsS0FBakIsRUFBRCxDQUFuQztBQUNBdEcsb0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUM0RyxJQUFuQztBQUNBOztBQUNKLG1CQUFLLGVBQUw7QUFDSXJSLHFCQUFLLENBQUNyQixVQUFOLENBQWlCdUMsUUFBakIsQ0FBMEIsRUFBMUI7QUFDQXdLLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEcsSUFBbkM7QUFDQTtBQUNBOztBQUNKLG1CQUFLLGFBQUw7QUFDSXJSLHFCQUFLLENBQUNyQixVQUFOLENBQWlCd0MsTUFBakIsQ0FBd0IsRUFBeEI7QUFDQXVLLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEcsSUFBbkM7QUFDQTs7QUFDSixtQkFBSyxZQUFMO0FBQ0kzRixvQkFBSSxDQUFDekMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCK0gsYUFBM0IsQ0FBeUMsWUFBekM7QUFDQTs7QUFDSixtQkFBSyxTQUFMO0FBQ0l2RyxvQkFBSSxDQUFDekMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCK0gsYUFBM0IsQ0FBeUMsU0FBekM7QUFDQTs7QUFDSixtQkFBSyxVQUFMO0FBQ0l2RyxvQkFBSSxDQUFDekMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCK0gsYUFBM0IsQ0FBeUMsVUFBekM7QUFDQTs7QUFDSjtBQXRDSjs7QUF5Q0FqUyxpQkFBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLENBQXVCeU8sSUFBdkI7QUFDSCxXQXhFRTtBQXlFSCxvQkFBUSxtQkFBVztBQUNmLG1CQUFPM0YsSUFBSSxDQUFDekMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCZ0ksVUFBM0IsQ0FBc0NsUyxLQUFLLENBQUMyQyxPQUFOLENBQWNDLFFBQWQsRUFBdEMsQ0FBUDtBQUNILFdBM0VFO0FBNEVIdVAsZ0JBQU0sRUFBRSxnQkFBQ0MsT0FBRCxFQUFhO0FBQ2pCLG1CQUFPMUcsSUFBSSxDQUFDekMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCMUQsVUFBM0IsQ0FBc0N4RyxLQUFLLENBQUMyQyxPQUFOLENBQWNDLFFBQWQsRUFBdEMsRUFBZ0V3UCxPQUFoRSxDQUFQO0FBQ0gsV0E5RUU7QUErRUhDLHdCQUFjLEVBQUUsMEJBQVc7QUFDdkIsZ0JBQUlDLFFBQVEsR0FBRzVHLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQnFJLE9BQTNCLENBQW1DLG1CQUFuQyxDQUFmO0FBQ0EsZ0JBQUlDLFFBQVEsR0FBRzlHLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQnFJLE9BQTNCLENBQW1DLG1CQUFuQyxDQUFmO0FBQ0EsZ0JBQUlwUSxJQUFJLEdBQUd1SixJQUFJLENBQUMxTCxLQUFMLENBQVdwQixVQUFYLENBQXNCdUQsSUFBdEIsRUFBWDs7QUFDQSxnQkFBSW1RLFFBQVEsSUFBSUEsUUFBUSxDQUFDRyxNQUFyQixJQUErQkgsUUFBUSxDQUFDRyxNQUFULEVBQW5DLEVBQXNEO0FBQ2xEdFEsa0JBQUksR0FBR21RLFFBQVEsQ0FBQ0csTUFBVCxLQUFvQnRRLElBQTNCO0FBQ0g7O0FBQ0QsZ0JBQUlxUSxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsTUFBckIsSUFBK0JELFFBQVEsQ0FBQ0MsTUFBVCxFQUFuQyxFQUFzRDtBQUNsRHRRLGtCQUFJLEdBQUdBLElBQUksR0FBR3FRLFFBQVEsQ0FBQ0MsTUFBVCxFQUFkO0FBQ0g7O0FBQ0QsbUJBQU90USxJQUFQO0FBQ0gsV0ExRkU7QUEyRkh1USwyQkFBaUIsRUFBRUMsdUVBQXVCLENBQUMzUyxLQUFLLENBQUNwQixVQUFOLENBQWlCeUQsVUFBbEIsQ0EzRnZDO0FBNEZIakIsOEJBQW9CLEVBQUV1Uix1RUFBdUIsQ0FBQzNTLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ5QyxvQkFBbEIsQ0E1RjFDO0FBNkZIRyw0QkFBa0IsRUFBRW9SLHVFQUF1QixDQUFDM1MsS0FBSyxDQUFDckIsVUFBTixDQUFpQjRDLGtCQUFsQixDQTdGeEM7QUE4RkhxUix5QkFBZSxFQUFFLHlCQUFTdkIsSUFBVCxFQUFlO0FBQzVCLGdCQUFJQSxJQUFJLEtBQUssb0JBQWIsRUFBbUM7QUFDL0IscUJBQU8sVUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssaUJBQWIsRUFBZ0M7QUFDNUIscUJBQU8sUUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssbUJBQWIsRUFBa0M7QUFDOUIscUJBQU8sZUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssbUJBQWIsRUFBa0M7QUFDOUIscUJBQU8sZUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssa0JBQWIsRUFBaUM7QUFDN0IscUJBQU8sU0FBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLENBQUN3QixVQUFMLENBQWdCLEdBQWhCLENBQUosRUFBMEI7QUFDdEIscUJBQU94QixJQUFJLENBQUN5QixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0g7O0FBQ0QsbUJBQU96QixJQUFQO0FBQ0g7QUFsSEUsU0FwVUE7QUF3YlAwQixlQUFPLEVBQUU7QUFDTC9HLGlCQUFPLEVBQUU3TCxFQUFFLENBQUMwTCxZQUFILENBQWlCO0FBQUEsbUJBQ3RCSCxJQUFJLENBQUN6QyxVQUFMLENBQWdCOEosT0FBaEIsQ0FBd0JDLFNBQXhCLENBQWtDaFQsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEVBQWxDLENBRHNCO0FBQUEsV0FBakIsQ0FESjtBQUlMbUwsZUFBSyxFQUFFNU4sRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUNuQjdMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4QixDQUFDN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMkosV0FBMUIsRUFBL0IsR0FDSSxXQURKLEdBQ2tCLFVBRkM7QUFBQSxXQUFoQixDQUpGO0FBUUxxSCxjQUFJLEVBQUU5UyxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ2pCLENBQUM3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFBRCxLQUNHN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCaVIsV0FBMUIsTUFDQWxULEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQnFLLGVBQTFCLEVBRkgsQ0FBRCxHQUVvRCxNQUZwRCxHQUdBdE0sS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEtBQTJCNUMsS0FBSyxDQUFDMkwsRUFBTixDQUFTb0gsT0FBVCxDQUFpQi9HLE9BQWpCLEVBQTNCLEdBQXdELE1BSnRDO0FBQUEsV0FBaEIsQ0FSRDtBQWNMRyxlQUFLLEVBQUUsaUJBQVc7QUFDZFQsZ0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCNUQsUUFBdkIsQ0FBZ0MsY0FBaEMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0QsRUFBeEQsRUFBNEQsV0FBNUQ7QUFDQXRGLGlCQUFLLENBQUNwQixVQUFOLENBQWlCdUQsSUFBakIsQ0FBc0JuQyxLQUFLLENBQUNyQixVQUFOLENBQWlCcUMsWUFBakIsRUFBdEI7QUFDQWhCLGlCQUFLLENBQUNwQixVQUFOLENBQWlCeUQsVUFBakIsQ0FBNEJyQyxLQUFLLENBQUNyQixVQUFOLENBQWlCNEMsa0JBQWpCLEdBQXNDNFIsR0FBdEMsQ0FDeEIsVUFBQTVCLElBQUksRUFBSTtBQUNKLGtCQUFJM08sUUFBUSxHQUFHMk8sSUFBSSxDQUFDM08sUUFBTCxHQUFnQndRLE1BQWhCLENBQXVCLENBQXZCLENBQWY7QUFDQSxxQkFBT0MsNkRBQWEsQ0FBQ3pRLFFBQUQsRUFBVzJPLElBQUksQ0FBQytCLFFBQUwsRUFBWCxDQUFwQjtBQUNILGFBSnVCLENBQTVCO0FBTUgsV0F2Qkk7QUF3QkxDLGlCQUFPLEVBQUVwVCxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ3JCLENBQUM3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNRLFFBQWQsRUFEb0I7QUFBQSxXQUFoQixDQXhCSjtBQTBCTHFRLG1CQUFTLEVBQUVyVCxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQ3ZCLENBQUMsQ0FBQzdMLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmtQLFNBQTFCLEVBQUQsSUFBMENuUixLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFBM0MsS0FDQTRRLHlEQUFpQixDQUFDQyxPQUFsQixDQUEwQjFULEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0MsUUFBZCxFQUExQixNQUF3RCxDQUFDLENBRmxDO0FBQUEsV0FBaEIsQ0ExQk47QUE2QkwrUSxtQkFBUyxFQUFFeFQsRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLG1CQUN2QixDQUFDLENBQUM3TCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJrUCxTQUExQixFQUFELElBQTBDblIsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLEVBQTNDLEtBQ0ErUSx5REFBaUIsQ0FBQ0YsT0FBbEIsQ0FBMEIxVCxLQUFLLENBQUMyQyxPQUFOLENBQWNDLFFBQWQsRUFBMUIsTUFBd0QsQ0FBQyxDQUZsQztBQUFBLFdBQWhCLENBN0JOO0FBZ0NMaVIsZ0JBQU0sRUFBRXZOLG1FQUFVLENBQUN3TixJQUFYLENBQWdCcEksSUFBaEIsQ0FoQ0g7QUFpQ0xxSSxrQkFBUSxFQUFFM04scUVBQVksQ0FBQzBOLElBQWIsQ0FBa0JwSSxJQUFsQixDQWpDTDtBQWtDTHNJLHVCQUFhLEVBQUUseUJBQU07QUFDakJ0SSxnQkFBSSxDQUFDekMsVUFBTCxDQUFnQmtDLE1BQWhCLENBQXVCOEksVUFBdkI7QUFDSCxXQXBDSTtBQXFDTEMsZ0JBQU0sRUFBRTtBQUNKbFEsc0JBQVUsRUFBRSxzQkFBTTtBQUNkLGtCQUFJbVEsVUFBVSxHQUFHekksSUFBSSxDQUFDekMsVUFBTCxDQUFnQm9DLFlBQWhCLENBQTZCQyxFQUE3QixDQUFnQ3VCLFVBQWhDLENBQTJDc0gsVUFBNUQ7QUFDQSxxQkFBT0EsVUFBVSxDQUFDQyxTQUFYLENBQXFCLFlBQXJCLEVBQW1DLENBQUNELFVBQVUsQ0FBQ0UsU0FBWCxDQUFxQixZQUFyQixDQUFwQyxDQUFQO0FBQ0gsYUFKRztBQUtKQyxzQkFBVSxFQUFFLG9CQUFDQyxPQUFELEVBQWE7QUFDckI3SSxrQkFBSSxDQUFDekMsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUI1RCxRQUF2QixDQUFnQyxlQUFoQyxFQUFpRCxFQUFqRCxFQUFxRCxFQUFyRCxFQUF5RGlQLE9BQXpELEVBQWtFdlUsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEVBQWxFO0FBQ0E1QyxtQkFBSyxDQUFDMkMsT0FBTixDQUFjSSxVQUFkLENBQXlCd1IsT0FBekI7O0FBQ0Esa0JBQUl2VSxLQUFLLENBQUMyQyxPQUFOLENBQWNDLFFBQWQsT0FBNkIsV0FBakMsRUFBOEM7QUFDMUM4SSxvQkFBSSxDQUFDekMsVUFBTCxDQUFnQm9DLFlBQWhCLENBQTZCbUosYUFBN0IsR0FBNkNELE9BQTdDO0FBQ0g7QUFDSixhQVhHO0FBWUpFLDhCQUFrQixFQUFFdFUsRUFBRSxDQUFDMEwsWUFBSCxDQUFnQjtBQUFBLHFCQUNoQzdMLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU3pDLE1BQVQsQ0FBZ0J3TCxtQkFBaEIsQ0FBb0MsYUFBcEMsQ0FEZ0M7QUFBQSxhQUFoQixDQVpoQjtBQWNKQyw4QkFBa0IsRUFBRSw4QkFBTTtBQUN0QmpKLGtCQUFJLENBQUN6QyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJ1SixZQUE3QjtBQUNBbEosa0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QndKLFdBQTdCLENBQXlDLEtBQXpDO0FBQ0E3VSxtQkFBSyxDQUFDMkMsT0FBTixDQUFjTyxXQUFkLENBQTBCLEtBQTFCO0FBQ0gsYUFsQkc7QUFtQko0Uiw2QkFBaUIsRUFBRSw2QkFBTTtBQUNyQnBKLGtCQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QmxFLFdBQXZCLENBQW1DLFVBQUMrUCxRQUFELEVBQWE7QUFDNUMsb0JBQUlBLFFBQVEsQ0FBQ3hFLE9BQWIsRUFBc0I7QUFDbEI3RSxzQkFBSSxDQUFDekMsVUFBTCxDQUFnQitMLE9BQWhCLENBQXdCQyxJQUF4QixDQUE2QkYsUUFBUSxDQUFDQyxPQUF0QztBQUNBaFYsdUJBQUssQ0FBQzJDLE9BQU4sQ0FBY08sV0FBZCxDQUEwQixJQUExQjtBQUNBd0ksc0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QndKLFdBQTdCLENBQXlDLElBQXpDO0FBQ0gsaUJBSkQsTUFJTztBQUNIbkosc0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0J5RCxNQUFoQixDQUF1QndJLHFCQUF2QjtBQUNIO0FBQ0osZUFSRDtBQVNILGFBN0JHO0FBOEJKQyw2QkFBaUIsRUFBRSw2QkFBTTtBQUNyQixrQkFBSW5WLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY08sV0FBZCxFQUFKLEVBQWlDO0FBQzdCbEQscUJBQUssQ0FBQzJMLEVBQU4sQ0FBU29ILE9BQVQsQ0FBaUJtQixNQUFqQixDQUF3QlMsa0JBQXhCO0FBQ0gsZUFGRCxNQUVPO0FBQ0gzVSxxQkFBSyxDQUFDMkwsRUFBTixDQUFTb0gsT0FBVCxDQUFpQm1CLE1BQWpCLENBQXdCWSxpQkFBeEI7QUFDSDtBQUNKLGFBcENHO0FBcUNKRSxtQkFBTyxFQUFFO0FBQ0x4VixtQkFBSyxFQUFFLGlCQUFJO0FBQUVrTSxvQkFBSSxDQUFDekMsVUFBTCxDQUFnQitMLE9BQWhCLENBQXdCSSxXQUF4QjtBQUF3QyxlQURoRDtBQUVMekUsc0JBQVEsRUFBRSxvQkFBSTtBQUFFakYsb0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0IrTCxPQUFoQixDQUF3QkssWUFBeEI7QUFBeUMsZUFGcEQ7QUFHTHRFLGtCQUFJLEVBQUUsZ0JBQUk7QUFBRXJGLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCK0wsT0FBaEIsQ0FBd0JNLFFBQXhCO0FBQXFDLGVBSDVDO0FBSUxDLHdCQUFVLEVBQUUsc0JBQUk7QUFBRTdKLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCK0wsT0FBaEIsQ0FBd0JRLGdCQUF4QjtBQUE2QyxlQUoxRDtBQUtMQyxpQkFBRyxFQUFFLGVBQUk7QUFBRS9KLG9CQUFJLENBQUN6QyxVQUFMLENBQWdCK0wsT0FBaEIsQ0FBd0JTLEdBQXhCO0FBQWdDO0FBTHRDO0FBckNMLFdBckNIO0FBa0ZMQyxnQkFBTSxFQUFFO0FBQ0pwUCxzQkFBVSxFQUFFO0FBQUEscUJBQU1vRixJQUFJLENBQUN6QyxVQUFMLENBQWdCOEosT0FBaEIsQ0FBd0I0QyxNQUF4QixDQUErQixPQUEvQixFQUF3Q3JQLFVBQXhDLEVBQU47QUFBQSxhQURSO0FBRUo0TCxzQkFBVSxFQUFFLG9CQUFDMEQsUUFBRDtBQUFBLHFCQUFjbEssSUFBSSxDQUFDekMsVUFBTCxDQUFnQjhKLE9BQWhCLENBQXdCNEMsTUFBeEIsQ0FBK0IsT0FBL0IsRUFBd0N6RCxVQUF4QyxDQUFtRDBELFFBQW5ELENBQWQ7QUFBQSxhQUZSO0FBR0pwUCxzQkFBVSxFQUFFLG9CQUFDb1AsUUFBRDtBQUFBLHFCQUFjbEssSUFBSSxDQUFDekMsVUFBTCxDQUFnQjhKLE9BQWhCLENBQXdCNEMsTUFBeEIsQ0FBK0IsT0FBL0IsRUFBd0NuUCxVQUF4QyxDQUFtRG9QLFFBQW5ELENBQWQ7QUFBQSxhQUhSO0FBSUpDLHdCQUFZLEVBQUU7QUFBQSxxQkFBTW5LLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0I4SixPQUFoQixDQUF3QjRDLE1BQXhCLENBQStCLE9BQS9CLEVBQXdDRSxZQUF4QyxFQUFOO0FBQUEsYUFKVjtBQUtKQyw4QkFBa0IsRUFBRTNWLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxxQkFBTTdMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxFQUFOO0FBQUEsYUFBaEIsQ0FMaEI7QUFNSmtULHFCQUFTLEVBQUUsbUJBQUNDLFNBQUQ7QUFBQSxxQkFBZWhXLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4Qm1ULFNBQVMsS0FBSyxZQUE1QyxJQUE0REEsU0FBUyxLQUFLLE1BQXpGO0FBQUE7QUFOUCxXQWxGSDtBQTBGTC9ULGtCQUFRLEVBQUU7QUFDTmdVLGdCQUFJLEVBQUU7QUFBQSxxQkFBTXZLLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCdEQsY0FBdkIsRUFBTjtBQUFBO0FBREEsV0ExRkw7QUE2RkwvRCwyQkFBaUIsRUFBRTtBQUNmcVUsdUJBQVcsRUFBRSxxQkFBQ0MsTUFBRCxFQUFTQyxLQUFULEVBQWdCQyxVQUFoQixFQUErQjtBQUN4QyxrQkFBSUMsTUFBTSxHQUFHNUssSUFBSSxDQUFDekMsVUFBTCxDQUFnQjhKLE9BQWhCLENBQXdCNEMsTUFBeEIsQ0FBK0Isb0JBQS9CLENBQWI7QUFDQVcsb0JBQU0sQ0FBQ0osV0FBUCxDQUFtQkMsTUFBbkIsRUFBMkJDLEtBQTNCLEVBQWtDQyxVQUFsQztBQUNIO0FBSmM7QUE3RmQsU0F4YkY7QUE0aEJQRSxlQUFPLEVBQUU7QUFDTEMsbUJBQVMsRUFBRXJXLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdkI3TCxLQUFLLENBQUMyRSxNQUFOLENBQWFpQyxXQUFiLE9BQStCL0IscURBQVcsQ0FBQ21LLE1BRHBCO0FBQUEsV0FBaEIsQ0FETjtBQUlMeUgsa0JBQVEsRUFBRXRXLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdEI3TCxLQUFLLENBQUMyRSxNQUFOLENBQWFpQyxXQUFiLE9BQStCL0IscURBQVcsQ0FBQ21LLE1BQTNDLEdBQW9ELE1BQXBELEdBQTZELEtBRHZDO0FBQUEsV0FBaEIsQ0FKTDtBQU9MMEgsYUFBRyxFQUFFLGVBQU07QUFDUCxnQkFBSTFXLEtBQUssQ0FBQzJFLE1BQU4sQ0FBYWlDLFdBQWIsT0FBK0IvQixxREFBVyxDQUFDbUssTUFBL0MsRUFBdUQ7QUFDbkQsa0JBQUksT0FBTzJILFNBQVAsS0FBcUIsV0FBckIsSUFBb0NBLFNBQVMsQ0FBQ0MsT0FBbEQsRUFBMkQ7QUFDdkRELHlCQUFTLENBQUNFLFVBQVY7QUFDSDs7QUFDRDdXLG1CQUFLLENBQUMyRSxNQUFOLENBQWFpQyxXQUFiLENBQXlCL0IscURBQVcsQ0FBQ0MsS0FBckM7QUFDSCxhQUxELE1BS087QUFDSDRHLGtCQUFJLENBQUN6QyxVQUFMLENBQWdCc0UsTUFBaEIsQ0FBdUJDLFVBQXZCO0FBQ0g7QUFDSixXQWhCSTtBQWlCTHNKLHlCQUFlLEVBQUUzVyxFQUFFLENBQUMwTCxZQUFILENBQWdCO0FBQUEsbUJBQzdCN0wsS0FBSyxDQUFDMkUsTUFBTixDQUFhaUMsV0FBYixPQUErQi9CLHFEQUFXLENBQUNtSyxNQUEzQyxHQUFvRCxNQUFwRCxHQUE2RCxzQkFEaEM7QUFBQSxXQUFoQixDQWpCWjtBQW9CTCtILG9CQUFVLEVBQUUsc0JBQU07QUFDZCxnQkFBSS9XLEtBQUssQ0FBQzJFLE1BQU4sQ0FBYWlDLFdBQWIsT0FBK0IvQixxREFBVyxDQUFDbUssTUFBL0MsRUFBdUQ7QUFDbkQsa0JBQUksT0FBTzJILFNBQVAsS0FBcUIsV0FBckIsSUFBb0NBLFNBQVMsQ0FBQ0MsT0FBbEQsRUFBMkQ7QUFDdkRELHlCQUFTLENBQUNFLFVBQVY7QUFDSDs7QUFDRDdXLG1CQUFLLENBQUMyRSxNQUFOLENBQWFpQyxXQUFiLENBQXlCL0IscURBQVcsQ0FBQ0MsS0FBckM7QUFDSCxhQUxELE1BS087QUFDSDRHLGtCQUFJLENBQUN6QyxVQUFMLENBQWdCc0UsTUFBaEIsQ0FBdUJDLFVBQXZCLENBQWtDLElBQWxDO0FBQ0g7QUFDSixXQTdCSTtBQThCTHdKLGtCQUFRLEVBQUU7QUFBQSxtQkFDTnRMLElBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JzRSxNQUFoQixDQUF1QnlKLFFBQXZCLEVBRE07QUFBQTtBQTlCTCxTQTVoQkY7QUE2akJQOU4sY0FBTSxFQUFFO0FBQ0p2RSxnQkFBTSxFQUFHLGdCQUFBckMsUUFBUTtBQUFBLG1CQUNiLG1CQUFtQnRDLEtBQUssQ0FBQzJFLE1BQU4sQ0FBYXJDLFFBQWIsR0FETjtBQUFBLFdBRGI7QUFJSm9TLDZCQUFtQixFQUFFLDZCQUFDcFMsUUFBRDtBQUFBLG1CQUNqQnRDLEtBQUssQ0FBQ3RCLGFBQU4sQ0FBb0IwSixlQUFwQixNQUNBcEksS0FBSyxDQUFDdEIsYUFBTixDQUFvQjhKLElBQXBCLEtBQTZCMUosU0FEN0IsSUFFQWtCLEtBQUssQ0FBQ3RCLGFBQU4sQ0FBb0I4SixJQUFwQixDQUF5QmxHLFFBQXpCLE1BQXVDeEQsU0FIdEI7QUFBQSxXQUpqQjtBQVFKbVksa0JBQVEsRUFBRTlXLEVBQUUsQ0FBQzBMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdEJxTCw4REFBVSxDQUFDbFgsS0FBSyxDQUFDMkUsTUFBTixDQUFhSSxxQkFBYixNQUNQL0UsS0FBSyxDQUFDMkUsTUFBTixDQUFha0IscUJBQWIsRUFETyxJQUVQN0YsS0FBSyxDQUFDMkUsTUFBTixDQUFhTSxrQkFBYixFQUZPLElBR1BqRixLQUFLLENBQUMyRSxNQUFOLENBQWFRLGVBQWIsRUFITyxJQUlQbkYsS0FBSyxDQUFDMkUsTUFBTixDQUFhZ0IsZUFBYixFQUpPLElBS1AzRixLQUFLLENBQUMyRSxNQUFOLENBQWFVLGtCQUFiLEVBTE8sSUFNUHJGLEtBQUssQ0FBQzJFLE1BQU4sQ0FBYVksZUFBYixFQU5PLElBT1B2RixLQUFLLENBQUMyRSxNQUFOLENBQWFhLFNBQWIsRUFQTyxJQVFQeEYsS0FBSyxDQUFDMkUsTUFBTixDQUFhb0IsdUJBQWIsRUFSTyxJQVNQL0YsS0FBSyxDQUFDMkUsTUFBTixDQUFhK0IsV0FBYixFQVRPLElBVVAxRyxLQUFLLENBQUMyRSxNQUFOLENBQWFzQiw2QkFBYixFQVZPLElBVXlDLEVBVjFDLENBRFk7QUFBQSxXQUFoQixDQVJOO0FBcUJKa1IsZUFBSyxFQUFFO0FBQ0h2UywwQkFBYyxFQUFFLHdCQUFDa0YsSUFBRCxFQUFPc04sS0FBUCxFQUFpQjtBQUM3QjtBQUNBLGtCQUFJQyx5QkFBeUIsR0FBR3ZPLDZDQUFDLENBQUNzTyxLQUFLLENBQUNFLE1BQVAsQ0FBakMsQ0FGNkIsQ0FHN0I7O0FBQ0F4TywyREFBQyxDQUFDc08sS0FBSyxDQUFDRSxNQUFQLENBQUQsQ0FBZ0JDLE1BQWhCLEdBQXlCN0gsT0FBekIsQ0FBaUMsR0FBakMsRUFBc0NDLE1BQXRDLENBQTZDLEdBQTdDLEVBSjZCLENBSzdCOztBQUNBLGtCQUFJNkgsRUFBRSxHQUFHLElBQUlDLFVBQUosRUFBVDtBQUNBLGtCQUFJdkcsS0FBSyxHQUFHbUcseUJBQXlCLENBQUMsQ0FBRCxDQUF6QixDQUE2Qm5HLEtBQXpDOztBQUNBc0csZ0JBQUUsQ0FBQ0UsTUFBSCxHQUFZLFVBQVNDLENBQVQsRUFBWTtBQUNwQixvQkFBSUMsb0JBQW9CLEdBQUcvRixJQUFJLENBQUNnRyxLQUFMLENBQVdGLENBQUMsQ0FBQ0wsTUFBRixDQUFTUSxNQUFwQixDQUEzQjtBQUNBcE0sb0JBQUksQ0FBQ3FNLG1CQUFMLENBQXlCSCxvQkFBekI7QUFDSCxlQUhEOztBQUlBSixnQkFBRSxDQUFDUSxRQUFILEdBQWM5RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVM3USxJQUF2QjtBQUNBbVgsZ0JBQUUsQ0FBQ1MsVUFBSCxDQUFjL0csS0FBSyxDQUFDLENBQUQsQ0FBbkI7QUFDQW1HLHVDQUF5QixDQUFDYSxHQUExQixDQUE4QixFQUE5QjtBQUNILGFBaEJFO0FBaUJIcFMsNEJBQWdCLEVBQUUsMEJBQUNnRSxJQUFELEVBQU9zTixLQUFQLEVBQWlCO0FBQy9Cck4scUJBQU8sQ0FBQ29PLEdBQVIsQ0FBWWYsS0FBWjtBQUNBMUwsa0JBQUksQ0FBQ3pDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCcEQsZ0JBQXZCLENBQXdDNEYsSUFBSSxDQUFDMUwsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQjJELEtBQXRCLEVBQXhDLEVBQ3dDbUosSUFBSSxDQUFDMUwsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQjRELE9BQXRCLEVBRHhDLEVBRXdDLEtBRnhDLEVBRStDLElBRi9DO0FBR0FzRywyREFBQyxDQUFDc08sS0FBSyxDQUFDRSxNQUFQLENBQUQsQ0FBZ0I1SCxPQUFoQixDQUF3QixHQUF4QixFQUE2QkMsTUFBN0IsQ0FBb0MsR0FBcEM7QUFDSDtBQXZCRTtBQXJCSCxTQTdqQkQ7QUE0bUJQeUksY0FBTSxFQUFFO0FBQ0ovTCxpQkFBTyxFQUFFbE0sRUFBRSxDQUFDMEwsWUFBSCxDQUNMO0FBQUEsbUJBQ0k3TCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsTUFBOEIsQ0FBQzdDLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU0MsV0FBVCxFQURuQztBQUFBLFdBREs7QUFETDtBQTVtQkQsT0FBWDtBQW1uQkF5TSwwRkFBK0IsQ0FBQzNNLElBQUQsRUFBTzFMLEtBQVAsQ0FBL0I7QUFDSDtBQXZrQ0w7QUFBQTtBQUFBLGtDQXlrQ2tCO0FBQ1Y7QUFDQXNZLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLGtCQUF0QixJQUE0Q3NILG1FQUFXLENBQUNsVSxRQUFaLEVBQTVDLENBRlUsQ0FHVjtBQUNBO0FBQ0g7QUFFRDs7Ozs7QUFobENKO0FBQUE7QUFBQSxpQ0FvbENpQjtBQUNUbkUsUUFBRSxDQUFDc1ksYUFBSCxDQUFpQixLQUFLelksS0FBdEIsRUFBNkIsS0FBS0EsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QjZKLFNBQXpCLENBQW1DLENBQW5DLENBQTdCO0FBQ0g7QUF0bENMO0FBQUE7QUFBQSxvQ0F3bENvQjtBQUNaLFVBQUltUSxJQUFJLEdBQUcsSUFBWDtBQUNBLFdBQUt6TSxTQUFMLEdBQWlCO0FBQ2JDLGdCQUFRLEVBQUUsa0JBQUN5TSxJQUFEO0FBQUEsaUJBQVVBLElBQUksR0FBR0MsT0FBTyxDQUFDQyxTQUFSLENBQWtCM00sUUFBbEIsQ0FBMkJ5TSxJQUEzQixDQUFILEdBQXNDLFNBQXBEO0FBQUE7QUFERyxPQUFqQjtBQUdIO0FBN2xDTDtBQUFBO0FBQUEscUNBK2xDcUI7QUFDYixVQUFJcFEsU0FBUyxHQUFHLEtBQUt2SSxLQUFMLENBQVd0QixhQUFYLENBQXlCNkosU0FBekM7QUFDQSxVQUFJVSxVQUFVLEdBQUcsS0FBS0EsVUFBTCxHQUFrQixFQUFuQztBQUNBLFVBQUl5UCxJQUFJLEdBQUcsSUFBWCxDQUhhLENBSWI7QUFDQTs7QUFDQXpQLGdCQUFVLENBQUN5RCxNQUFYLEdBQW9CLElBQUlvTSxzREFBSixDQUFrQkosSUFBbEIsRUFBd0JuUSxTQUFTLENBQUNrSCxJQUFWLENBQWUsaUJBQWYsQ0FBeEIsQ0FBcEI7QUFDQXhHLGdCQUFVLENBQUNwQixRQUFYLEdBQXNCLElBQUlrUiw0REFBSixDQUFvQkwsSUFBcEIsRUFBMEJuUSxTQUFTLENBQUNrSCxJQUFWLENBQWUsbUJBQWYsQ0FBMUIsQ0FBdEI7QUFDQXhHLGdCQUFVLENBQUNnSCxLQUFYLEdBQW1CLElBQUkrSSxvREFBSixDQUFpQk4sSUFBakIsQ0FBbkI7QUFDQXpQLGdCQUFVLENBQUNjLE9BQVgsR0FBcUIsSUFBSWtQLHdEQUFKLENBQW1CUCxJQUFuQixFQUF5Qm5RLFNBQVMsQ0FBQ2tILElBQVYsQ0FBZSxrQkFBZixDQUF6QixDQUFyQjtBQUNBeEcsZ0JBQVUsQ0FBQ3NFLE1BQVgsR0FBb0IsSUFBSTJMLHdEQUFKLENBQWtCUixJQUFsQixDQUFwQjtBQUNBelAsZ0JBQVUsQ0FBQ2lCLFVBQVgsR0FBd0IsSUFBSWlQLHlEQUFKLENBQXNCVCxJQUF0QixDQUF4QjtBQUNBelAsZ0JBQVUsQ0FBQzhKLE9BQVgsR0FBcUIsSUFBSXFHLGtEQUFKLENBQVlWLElBQVosRUFBa0JuUSxTQUFTLENBQUNrSCxJQUFWLENBQWUsaUJBQWYsQ0FBbEIsQ0FBckIsQ0FaYSxDQWFiOztBQUNBeEcsZ0JBQVUsQ0FBQ29DLFlBQVgsR0FBMEIsS0FBS3BDLFVBQUwsQ0FBZ0I4SixPQUFoQixDQUF3QjRDLE1BQXhCLENBQStCLFFBQS9CLENBQTFCO0FBQ0ExTSxnQkFBVSxDQUFDQyxNQUFYLEdBQW9CLElBQUltUSx1REFBSixDQUFrQlgsSUFBbEIsQ0FBcEI7QUFDQXpQLGdCQUFVLENBQUNrQyxNQUFYLEdBQW9CLElBQUltTyxzREFBSixDQUFrQlosSUFBbEIsQ0FBcEI7QUFDQXpQLGdCQUFVLENBQUMrTCxPQUFYLEdBQXFCLElBQUl1RSx3REFBSixDQUFtQmIsSUFBbkIsRUFBeUJuUSxTQUFTLENBQUNrSCxJQUFWLENBQWUsMEJBQWYsQ0FBekIsQ0FBckI7QUFDSDtBQWpuQ0w7QUFBQTtBQUFBLDJCQW1uQ1c7QUFDSCxXQUFLelAsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QjZKLFNBQXpCLENBQW1DaVIsSUFBbkMsR0FERyxDQUVIO0FBQ0g7QUF0bkNMO0FBQUE7QUFBQSwyQkF3bkNXO0FBQ0gsV0FBS3haLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUI2SixTQUF6QixDQUFtQ2tSLElBQW5DO0FBQ0g7QUExbkNMO0FBQUE7QUFBQSw2Q0E0bkM2QjtBQUFBOztBQUNyQixXQUFLelosS0FBTCxDQUFXMkMsT0FBWCxDQUFtQmtCLG1CQUFuQixDQUF1QzZWLFNBQXZDLENBQWlELFVBQUNDLE9BQUQsRUFBYTtBQUMxRCxjQUFJLENBQUMxUSxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLHVCQUFoQyxFQUF5RCxFQUF6RCxFQUE2RCxFQUE3RCxFQUNnQ3FVLE9BRGhDLEVBQ3lDLGlCQUR6QztBQUVILE9BSEQ7QUFJQSxXQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUNBLFVBQU1yUixTQUFTLEdBQUcsS0FBS3ZJLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUI2SixTQUEzQzs7QUFDQSxVQUFNc1IsV0FBVyxHQUFHLFNBQWRBLFdBQWM7QUFBQSxlQUFNdFIsU0FBUyxDQUFDa0gsSUFBVixDQUFlLHFCQUFmLEVBQXNDa0osSUFBdEMsQ0FBMkNtQixrRUFBYyxFQUF6RCxDQUFOO0FBQUEsT0FBcEI7O0FBQ0EsVUFBSSxLQUFLOVosS0FBTCxDQUFXMkwsRUFBWCxDQUFjUyxJQUFkLENBQW1Cd0IsU0FBbkIsRUFBSixFQUFvQztBQUNoQyxhQUFLZ00sS0FBTCxHQUFhRyxXQUFXLENBQUNGLFdBQUQsRUFBYyxJQUFkLENBQXhCO0FBQ0g7O0FBRUQsV0FBSzdaLEtBQUwsQ0FBVzJMLEVBQVgsQ0FBY1MsSUFBZCxDQUFtQndCLFNBQW5CLENBQTZCOEwsU0FBN0IsQ0FBdUMsVUFBQ0MsT0FBRCxFQUFhO0FBQ2hELFlBQUksTUFBSSxDQUFDM1osS0FBTCxDQUFXMkwsRUFBWCxDQUFjUyxJQUFkLENBQW1Cd0IsU0FBbkIsRUFBSixFQUFvQztBQUNoQyxjQUFJLE1BQUksQ0FBQ2dNLEtBQVQsRUFBZ0I7QUFDWkkseUJBQWEsQ0FBQyxNQUFJLENBQUNKLEtBQU4sQ0FBYjtBQUNBLGtCQUFJLENBQUNBLEtBQUwsR0FBYSxJQUFiO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSCxjQUFJLENBQUMsTUFBSSxDQUFDQSxLQUFWLEVBQWlCO0FBQ2Isa0JBQUksQ0FBQ0EsS0FBTCxHQUFhRyxXQUFXLENBQUNGLFdBQUQsRUFBYyxJQUFkLENBQXhCO0FBQ0g7QUFDSjtBQUNKLE9BWEQ7QUFZSDtBQXBwQ0w7QUFBQTtBQUFBLDRCQXNwQ1k7QUFDSixXQUFLN1osS0FBTCxDQUFXMkMsT0FBWCxDQUFtQkMsUUFBbkIsQ0FBNEIsV0FBNUI7QUFDSDtBQXhwQ0w7QUFBQTtBQUFBLHFDQTBwQ3FCO0FBQ2IsV0FBS3FHLFVBQUwsQ0FBZ0JzRSxNQUFoQixDQUF1QnBCLEtBQXZCLEdBRGEsQ0FFYjs7QUFDQSxXQUFLbEQsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUIrUSxXQUF2QixHQUFxQyxJQUFyQztBQUNIO0FBOXBDTDtBQUFBO0FBQUEsc0NBZ3FDc0I7QUFDZCxVQUFJQyxvQkFBb0IsR0FBR0MsTUFBTSxDQUFDLDRCQUFELENBQWpDO0FBQ0EsV0FBS25hLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUJzQixRQUFuQixDQUE0QmlXLG9CQUE1QjtBQUNIO0FBbnFDTDtBQUFBO0FBQUEsOEJBcXFDYyxDQUVUO0FBdnFDTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFFQTs7Ozs7QUFJQSxJQUFNRSxlQUFlLHNIQUFyQjtBQUtBOzs7OztBQUlBLElBQU1DLHFCQUFxQixHQUFHLGFBQTlCO0FBRUE7Ozs7O0FBSU8sSUFBTUMsWUFBWSwrcEJBQWxCO0FBbUJQOzs7OztBQUlPLElBQUlDLGVBQWUsR0FBRztBQUN6QnRYLE1BQUksRUFBRSxNQURtQjtBQUV6QnVYLE1BQUksRUFBRSxNQUZtQjtBQUd6QkMsTUFBSSxFQUFFLE1BSG1CO0FBSXpCQyxPQUFLLEVBQUUsT0FKa0I7QUFLekJDLFFBQU0sRUFBRSxRQUxpQjtBQU16QkMsU0FBTyxFQUFFLFNBTmdCO0FBT3pCQyxRQUFNLEVBQUUsUUFQaUI7QUFRekJDLE1BQUksRUFBRSxNQVJtQjtBQVN6QkMsWUFBVSxFQUFFLFlBVGE7QUFVekJDLE9BQUssRUFBRSxPQVZrQjtBQVd6QkMsT0FBSyxFQUFFLE9BWGtCO0FBWXpCQyxXQUFTLEVBQUU7QUFaYyxDQUF0QjtBQWVQOzs7OztJQUlNQyxXO0FBQ0YsdUJBQVl6QyxJQUFaLEVBQWtCOVgsSUFBbEIsRUFBd0J3YSxPQUF4QixFQUFpQztBQUFBOztBQUM3Qjs7Ozs7QUFLQSxTQUFLMUMsSUFBTCxHQUFZQSxJQUFaO0FBQ0E7Ozs7O0FBSUEsU0FBSzlYLElBQUwsR0FBWUEsSUFBWjtBQUNBOzs7OztBQUlBLFNBQUt3YSxPQUFMLEdBQWVBLE9BQWY7QUFDQTs7Ozs7QUFJQSxTQUFLQyxNQUFMLEdBQWM7QUFDVnpZLGNBQVEsRUFBRTBWLEVBQUUsQ0FBQ2dELFlBREg7QUFFVm5MLFVBQUksRUFBRXVJLElBQUksQ0FBQ3pQLFVBQUwsQ0FBZ0JzRSxNQUFoQixDQUF1QmdPLGVBQXZCLENBQXVDcEwsSUFGbkM7QUFHVkUsVUFBSSxFQUFFcUksSUFBSSxDQUFDelAsVUFBTCxDQUFnQnNFLE1BQWhCLENBQXVCZ08sZUFBdkIsQ0FBdUNsTDtBQUhuQyxLQUFkO0FBS0E7Ozs7OztBQUtBLFNBQUt0SCxJQUFMLEdBQVlELENBQUMsQ0FBQyxhQUFELEVBQWdCO0FBQ3pCLGVBQVUsd0JBRGU7QUFFekIsd0JBQWtCNFAsSUFBSSxDQUFDMVksS0FBTCxDQUFXdEIsYUFBWCxDQUF5QjRKLGVBRmxCO0FBR3pCLHFCQUFlLFNBSFU7QUFJekIsd0JBQWtCLE1BSk87QUFLekIsbUJBQWEsS0FBSytTLE1BQUwsQ0FBWWxMLElBTEE7QUFNekIsZUFBUyxVQUFVLEtBQUtrTCxNQUFMLENBQVlsTCxJQUF0QixHQUE2QixTQUE3QixHQUF5QyxLQUFLa0wsTUFBTCxDQUFZaEw7QUFOckMsS0FBaEIsQ0FBYjtBQVFBOzs7OztBQUlBLFNBQUtoRSxPQUFMLEdBQWUsQ0FBQ3FNLElBQUksQ0FBQzFZLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUJHLFdBQW5CLEVBQWhCO0FBQ0E7Ozs7O0FBSUEsU0FBS3NULEtBQUwsR0FBYSxDQUFiO0FBQ0g7QUFFRDs7Ozs7Ozs7K0JBSVc7QUFDUCxhQUFPa0MsRUFBRSxDQUFDa0QsR0FBSCxDQUFPQyxTQUFQLENBQWlCLEtBQUtMLE9BQXRCLENBQVA7QUFDSDtBQUVEOzs7Ozs7OEJBR1M7QUFDTCxXQUFLclMsSUFBTCxDQUFVMlMsTUFBVjtBQUNIOzs7Ozs7SUFHQ0MsaUI7Ozs7O0FBQ0Y7QUFDQSw2QkFBWWpELElBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDZCw4QkFBTUEsSUFBTixFQUFZNkIsZUFBZSxDQUFDTSxNQUE1Qjs7QUFDQSxVQUFLOVIsSUFBTCxDQUFVOEcsUUFBVixDQUFtQiwrQkFBbkI7O0FBRmM7QUFHakI7Ozs7MkJBRU0rTCxLLEVBQU87QUFDVixVQUFJLEtBQUt2UCxPQUFULEVBQWtCO0FBQ2R1UCxhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLOVMsSUFBbkIsRUFEYyxDQUVkOztBQUNBLFlBQUkrUyxHQUFHLEdBQUcsS0FBSy9TLElBQUwsQ0FBVWdULE1BQVYsR0FBbUJELEdBQTdCLENBSGMsQ0FJZDs7QUFDQWhULFNBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVWtULFNBQVYsQ0FBb0JGLEdBQXBCLEVBTGMsQ0FNZDtBQUNIO0FBQ0o7Ozs7RUFoQjJCWCxXOztJQW1CMUJjLGtCOzs7OztBQUNGLDhCQUFZdkQsSUFBWixFQUFrQjVKLElBQWxCLEVBQXdCOUssVUFBeEIsRUFBb0M7QUFBQTs7QUFBQTs7QUFDaEMsZ0NBQU0wVSxJQUFOLEVBQVk2QixlQUFlLENBQUNLLE9BQTVCOztBQUNBLFdBQUs3UixJQUFMLENBQVU4RyxRQUFWLENBQW1CLGdDQUFuQjs7QUFDQSxXQUFLZixJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLOUssVUFBTCxHQUFrQkEsVUFBbEI7QUFKZ0M7QUFLbkM7Ozs7MkJBRU00WCxLLEVBQU87QUFDVixVQUFJLEtBQUt2UCxPQUFULEVBQWtCO0FBQ2R1UCxhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLOVMsSUFBbkI7QUFDQSxZQUFJK1MsR0FBRyxHQUFHLEtBQUsvUyxJQUFMLENBQVVnVCxNQUFWLEdBQW1CRCxHQUE3QjtBQUNBaFQsU0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVa1QsU0FBVixDQUFvQkYsR0FBcEI7QUFDSDtBQUNKOzs7OEJBRVMsQ0FDTjtBQUNIOzs7MkJBRU07QUFDSCxXQUFLcEQsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CbUMsU0FBbkIsQ0FBNkJjLFlBQTdCO0FBQ0g7Ozs7RUF0QjRCdU0sVzs7SUF5QjNCZSxpQjs7Ozs7QUFDRiw2QkFBWXhELElBQVosRUFBa0I1SixJQUFsQixFQUF3QjlLLFVBQXhCLEVBQW9DbVksU0FBcEMsRUFBK0M7QUFBQTs7QUFBQTs7QUFDM0MsZ0NBQU16RCxJQUFOLEVBQVk2QixlQUFlLENBQUNJLE1BQTVCOztBQUNBLFdBQUs1UixJQUFMLENBQVU4RyxRQUFWLENBQW1CLCtCQUFuQjs7QUFDQSxXQUFLZixJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLOUssVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxXQUFLbVksU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxXQUFLQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsV0FBS0MsTUFBTCxHQUFjQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZCxDQVAyQyxDQVEzQzs7QUFSMkM7QUFTOUM7Ozs7MkJBRU1YLEssRUFBTztBQUNWLFVBQUksS0FBS3ZQLE9BQVQsRUFBa0I7QUFDZCxhQUFLdEQsSUFBTCxDQUFVeVQsTUFBVixDQUFpQixLQUFLSCxNQUF0QjtBQUNBVCxhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLOVMsSUFBbkI7QUFDQSxZQUFJK1MsR0FBRyxHQUFHLEtBQUsvUyxJQUFMLENBQVVnVCxNQUFWLEdBQW1CRCxHQUE3QjtBQUNBaFQsU0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVa1QsU0FBVixDQUFvQkYsR0FBcEI7QUFDSDtBQUNKOzs7OEJBRVMsQ0FDTjtBQUNIOzs7MkJBRU07QUFDSCxXQUFLVyxPQUFMLEdBQWUsWUFBTSxDQUFFLENBQXZCOztBQUNBLFdBQUsvRCxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUJtQyxTQUFuQixDQUE2QmMsWUFBN0I7QUFDSDs7OzZCQUVROE4sZSxFQUFpQkMsUyxFQUFXO0FBQUE7O0FBQ2pDLFdBQUtQLFdBQUwsR0FBbUIsSUFBbkI7O0FBQ0EsV0FBS0ssT0FBTCxHQUFlO0FBQUEsZUFBTUMsZUFBZSxDQUFDLE1BQUksQ0FBQ1AsU0FBTixFQUFpQlEsU0FBakIsQ0FBckI7QUFBQSxPQUFmO0FBQ0g7Ozs7RUFqQzJCeEIsVzs7SUFxQzFCeUIsZ0I7Ozs7O0FBQ0YsNEJBQVlsRSxJQUFaLEVBQWtCMEMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQTs7QUFDdkIsZ0NBQU0xQyxJQUFOLEVBQVk2QixlQUFlLENBQUNHLEtBQTVCLEVBQW1DVSxPQUFuQzs7QUFDQSxXQUFLclMsSUFBTCxDQUFVOEcsUUFBVixDQUFtQiw4QkFBbkI7O0FBRnVCO0FBRzFCOzs7OzJCQUVNK0wsSyxFQUFPO0FBQ1YsVUFBSSxLQUFLdlAsT0FBVCxFQUFrQjtBQUNkdEMsZUFBTyxDQUFDb08sR0FBUixDQUFZLEtBQUtpRCxPQUFqQjtBQUNBLGFBQUtyUyxJQUFMLENBQVV5VCxNQUFWLENBQWlCLEtBQUtwQixPQUF0QjtBQUNBUSxhQUFLLENBQUNZLE1BQU4sQ0FBYSxLQUFLelQsSUFBbEIsRUFIYyxDQUlkO0FBQ0g7QUFDSjs7OztFQWIwQm9TLFc7O0lBZ0J6QjBCLGU7Ozs7O0FBQ0YsMkJBQVluRSxJQUFaLEVBQWtCMEMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQTs7QUFDdkIsZ0NBQU0xQyxJQUFOLEVBQVk2QixlQUFlLENBQUNFLElBQTVCLEVBQWtDVyxPQUFsQzs7QUFDQSxXQUFLclMsSUFBTCxDQUFVOEcsUUFBVixDQUFtQiw2QkFBbkI7O0FBRnVCO0FBRzFCOzs7OzJCQUVNK0wsSyxFQUFPO0FBQ1YsVUFBSSxLQUFLdlAsT0FBVCxFQUFrQjtBQUNkdVAsYUFBSyxDQUFDWSxNQUFOLENBQWEsS0FBS3pULElBQWxCLEVBRGMsQ0FFZDtBQUNIO0FBQ0o7Ozs7RUFYeUJvUyxXOztJQWN4QjJCLGU7Ozs7Ozs7Ozs7Ozs7K0JBRVMxQixPLEVBQVM7QUFDaEIsV0FBS0EsT0FBTCxHQUFlLEtBQUtBLE9BQUwsR0FBZUEsT0FBOUI7QUFDSDs7OzJCQUVNUSxLLEVBQU87QUFDVixVQUFJLEtBQUt2UCxPQUFULEVBQWtCO0FBQ2QsWUFBSTBRLFdBQVcsR0FBR0MsNkRBQVUsQ0FBQyxLQUFLNUIsT0FBTixDQUE1Qjs7QUFDQSxZQUFJLENBQUMyQixXQUFELElBQWdCQSxXQUFXLENBQUNFLElBQVosR0FBbUJ6TCxNQUFuQixJQUE2QixDQUFqRCxFQUFvRDtBQUNoRHVMLHFCQUFXLEdBQUcsSUFBZDtBQUNIOztBQUNELFlBQUlHLFFBQVEsR0FBR3BVLENBQUMsQ0FBQyxlQUFELEVBQWtCO0FBQUUsa0JBQVFpVTtBQUFWLFNBQWxCLENBQWhCO0FBQ0EsYUFBS2hVLElBQUwsQ0FBVXlULE1BQVYsQ0FBaUJVLFFBQWpCO0FBQ0F0QixhQUFLLENBQUNZLE1BQU4sQ0FBYSxLQUFLelQsSUFBbEI7QUFDQSxhQUFLQSxJQUFMLENBQVVvVSxPQUFWO0FBQ0g7QUFDSjs7OztFQWpCeUJoQyxXOztJQW9CeEJpQyxnQjs7Ozs7QUFFRiw0QkFBWTFFLElBQVosRUFBa0IwQyxPQUFsQixFQUEyQjtBQUFBOztBQUFBLDhCQUNqQjFDLElBRGlCLEVBQ1g2QixlQUFlLENBQUNTLEtBREwsRUFDWUksT0FEWjtBQUUxQjs7OzsyQkFFTVEsSyxFQUFPO0FBQ1YsVUFBSSxLQUFLdlAsT0FBVCxFQUFrQjtBQUNkLFlBQUkwUSxXQUFXLEdBQUdDLDZEQUFVLENBQUMsS0FBSzVCLE9BQU4sQ0FBNUI7QUFDQSxZQUFJOEIsUUFBUSxHQUFHcFUsQ0FBQyxDQUFDLGVBQUQsRUFBa0I7QUFBRSxrQkFBUWlVO0FBQVYsU0FBbEIsQ0FBaEI7QUFDQSxhQUFLaFUsSUFBTCxDQUFVeVQsTUFBVixDQUFpQlUsUUFBakI7QUFDQXRCLGFBQUssQ0FBQ1ksTUFBTixDQUFhLEtBQUt6VCxJQUFsQjtBQUNBLGFBQUtBLElBQUwsQ0FBVW9VLE9BQVY7QUFDSDtBQUNKOzs7O0VBZDBCaEMsVzs7SUFpQnpCa0MsZ0I7Ozs7O0FBQ0YsNEJBQVkzRSxJQUFaLEVBQWtCNEUsYUFBbEIsRUFBaUM7QUFBQTs7QUFBQTs7QUFDN0IsZ0NBQU01RSxJQUFOLEVBQVk2QixlQUFlLENBQUNVLEtBQTVCLEVBQW1DcUMsYUFBbkM7QUFDQSxXQUFLalIsT0FBTCxHQUFlLElBQWY7QUFGNkI7QUFHaEM7QUFFRDs7Ozs7Ozs7MkJBSU91UCxLLEVBQU87QUFDVjtBQUNBLFVBQUksS0FBS3ZQLE9BQVQsRUFBa0I7QUFDZDtBQUNBLFlBQUlrUixTQUFTLEdBQUd6VSxDQUFDLENBQUMsdUJBQUQsQ0FBakIsQ0FGYyxDQUdkOztBQUNBLFlBQUkwVSxRQUFRLEdBQUcxVSxDQUFDLENBQUMsbUJBQUQsRUFBc0I7QUFBQyxrQkFBUTtBQUFULFNBQXRCLENBQWhCLENBSmMsQ0FLZDs7QUFDQSxZQUFJMlUsVUFBVSxHQUFHM1UsQ0FBQyxDQUFDLGFBQUQsRUFBZ0I7QUFBQyxtQkFBUztBQUFWLFNBQWhCLENBQWxCO0FBQ0EyVSxrQkFBVSxDQUFDakIsTUFBWCxDQUFrQmUsU0FBbEI7QUFDQUUsa0JBQVUsQ0FBQ2pCLE1BQVgsQ0FBa0JnQixRQUFsQixFQVJjLENBU2Q7O0FBQ0EsWUFBSUUsUUFBUSxHQUFHNVUsQ0FBQyxDQUFDLGFBQUQsQ0FBaEI7O0FBQ0EsWUFBSSxLQUFLc1MsT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN2QixjQUFJMkIsV0FBVyxHQUFHQyw2REFBVSxDQUFDLEtBQUs1QixPQUFOLENBQTVCO0FBQ0EsY0FBSXVDLFFBQVEsR0FBRzdVLENBQUMsQ0FBQyxlQUFELEVBQW1CO0FBQUMsb0JBQVFpVTtBQUFULFdBQW5CLENBQWhCO0FBQ0FXLGtCQUFRLENBQUNsQixNQUFULENBQWdCbUIsUUFBaEI7QUFDSDs7QUFDREQsZ0JBQVEsQ0FBQ2xCLE1BQVQsQ0FBZ0IxVCxDQUFDLENBQUMsTUFBRCxDQUFqQixFQUNLMFQsTUFETCxDQUNZaUIsVUFEWixFQWhCYyxDQWtCZDs7QUFDQSxhQUFLMVUsSUFBTCxDQUFVeVQsTUFBVixDQUFpQmtCLFFBQWpCO0FBQ0E5QixhQUFLLENBQUNZLE1BQU4sQ0FBYSxLQUFLelQsSUFBbEIsRUFwQmMsQ0FxQmQ7O0FBQ0EsZUFBTyxLQUFLNlUsZUFBTCxDQUFxQkwsU0FBckIsRUFBZ0NDLFFBQWhDLENBQVA7QUFDSDs7QUFDRCxhQUFPLEVBQVA7QUFDSDs7O29DQUVleFcsSyxFQUFPNlcsTSxFQUFRO0FBQUE7O0FBQzNCLFVBQUlDLGNBQUo7QUFDQSxVQUFJQyxnQkFBZ0IsR0FBRyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFhO0FBQzVDSCxzQkFBYyxHQUFHRyxPQUFqQjtBQUNILE9BRnNCLENBQXZCO0FBR0EsVUFBSWhYLFVBQVUsR0FBRyxLQUFLeVIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCSSxVQUExQixFQUFqQjs7QUFDQSxVQUFJaVgsVUFBVSxHQUFHLFNBQWJBLFVBQWEsR0FBTTtBQUNuQixZQUFJQyxpQkFBaUIsR0FBR25YLEtBQUssQ0FBQ2tSLEdBQU4sRUFBeEI7QUFDQUksVUFBRSxDQUFDOEYsV0FBSCxDQUFlQyxJQUFmLENBQW9CRixpQkFBcEI7O0FBQ0EsY0FBSSxDQUFDekYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCSSxVQUExQixDQUFxQ0EsVUFBVSxHQUFDLENBQWhEOztBQUNBLGNBQUksQ0FBQ3lSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NxWCxJQUFsQyxDQUF1Q0YsaUJBQXZDOztBQUNBTCxzQkFBYyxDQUFDSyxpQkFBRCxDQUFkO0FBQ0FuWCxhQUFLLENBQUNzWCxJQUFOLENBQVcsVUFBWCxFQUF1QixJQUF2QjtBQUNBVCxjQUFNLENBQUNTLElBQVAsQ0FBWSxVQUFaLEVBQXdCLElBQXhCOztBQUNBLGNBQUksQ0FBQ3ZWLElBQUwsQ0FBVW9VLE9BQVY7QUFDSCxPQVREOztBQVVBVSxZQUFNLENBQUNVLEtBQVAsQ0FBYUwsVUFBYjtBQUNBbFgsV0FBSyxDQUFDd1gsS0FBTixDQUFZLFVBQUM3RyxDQUFELEVBQU87QUFDZixZQUFJQSxDQUFDLENBQUM4RyxPQUFGLEtBQWMsRUFBbEIsRUFBc0I7QUFDbEJQLG9CQUFVO0FBQ2I7QUFDSixPQUpEO0FBS0FsWCxXQUFLLENBQUMwWCxLQUFOO0FBQ0EzVSxhQUFPLENBQUNvTyxHQUFSLENBQVlsUixVQUFaLEVBQXdCLEtBQUt5UixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJHLEtBQTFCLEdBQWtDd0ssTUFBMUQ7O0FBQ0EsVUFBSXZLLFVBQVUsR0FBRyxLQUFLeVIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ3dLLE1BQW5ELEVBQTJEO0FBQ3ZELFlBQUkyTSxpQkFBaUIsR0FBRyxLQUFLekYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ0MsVUFBbEMsQ0FBeEI7QUFDQUQsYUFBSyxDQUFDa1IsR0FBTixDQUFVaUcsaUJBQVY7QUFDQSxhQUFLekYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCSSxVQUExQixDQUFxQ0EsVUFBVSxHQUFDLENBQWhEO0FBQ0EsZUFBTyxJQUFJK1csT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBYTtBQUM1QmpYLGVBQUssQ0FBQ3NYLElBQU4sQ0FBVyxVQUFYLEVBQXVCLElBQXZCO0FBQ0FULGdCQUFNLENBQUNTLElBQVAsQ0FBWSxVQUFaLEVBQXdCLElBQXhCOztBQUNBLGdCQUFJLENBQUN2VixJQUFMLENBQVVvVSxPQUFWOztBQUNBYyxpQkFBTyxDQUFDRSxpQkFBRCxDQUFQO0FBQ0gsU0FMTSxDQUFQO0FBTUg7O0FBQ0QsYUFBT0osZ0JBQVA7QUFDSDs7OztFQTNFMEI1QyxXOztJQThFekJ3RCxtQjs7Ozs7QUFDRiwrQkFBWWpHLElBQVosRUFBa0I7QUFBQTs7QUFBQSw4QkFDUkEsSUFEUSxFQUNGLFdBREU7QUFFakI7OztFQUg2QjJFLGdCOztJQU01QnVCLHdCOzs7OztBQUNGLG9DQUFZbEcsSUFBWixFQUFrQjtBQUFBOztBQUFBOztBQUNkLGlDQUFNQSxJQUFOLEVBQVk2QixlQUFlLENBQUNRLFVBQTVCOztBQUNBLFdBQUtoUyxJQUFMLENBQVV5VCxNQUFWLENBQWlCMVQsQ0FBQyxDQUFDc1IsZUFBRCxDQUFsQjs7QUFDQSxXQUFLclIsSUFBTCxDQUFVd1YsS0FBVixDQUFnQixZQUFNO0FBQ2xCLGFBQUs3RixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUI0SyxPQUFuQixDQUEyQlMsUUFBM0I7O0FBQ0E7QUFDSCxLQUhEOztBQUhjO0FBT2pCOzs7OzJCQUVNNEUsSyxFQUFPO0FBQ1ZBLFdBQUssQ0FBQ1ksTUFBTixDQUFhLEtBQUt6VCxJQUFsQjtBQUNIOzs7O0VBWmtDb1MsVzs7QUFlaEMsSUFBTWxDLGNBQWI7QUFFSTs7Ozs7Ozs7QUFRQSwwQkFBYVAsSUFBYixFQUFtQm1HLEdBQW5CLEVBQXdCO0FBQUE7O0FBQ3BCLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQkQsR0FBRyxDQUFDcFAsSUFBSixDQUFTLGtCQUFULENBQWxCO0FBRUEsU0FBS3NQLGFBQUwsR0FBcUIsR0FBckI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLEdBQXRCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixLQUFLSCxVQUFMLENBQWdCSSxNQUFoQixFQUF0QixDQVBvQixDQU80Qjs7QUFDaEQsU0FBS3hHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QlUscUJBQXhCLENBQThDLEtBQUs0YixjQUFuRDtBQUVBLFNBQUtsWSxNQUFMLEdBQWMsS0FBSzJSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkUsTUFBeEMsQ0FWb0IsQ0FXcEI7O0FBQ0EsU0FBSzlFLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxTQUFLa2QsS0FBTCxHQWJvQixDQWVwQjtBQUNIOztBQTFCTDtBQUFBOztBQTRCSTs7OztBQTVCSiw0QkFnQ1k7QUFDSixXQUFLcFksTUFBTCxDQUFZcVksU0FBWjtBQUVBLFdBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxXQUFLQyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBS1IsVUFBTCxDQUFnQlMsS0FBaEIsR0FMSSxDQU1KOztBQUNBLFVBQUksS0FBSzdHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QlUscUJBQXhCLE9BQW9ELEtBQUt5YixVQUFMLENBQWdCSSxNQUFoQixFQUF4RCxFQUFrRjtBQUM5RSxhQUFLSixVQUFMLENBQWdCSSxNQUFoQixDQUF1QixLQUFLRCxjQUE1QjtBQUNBLGFBQUt2RyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLeWIsVUFBTCxDQUFnQkksTUFBaEIsRUFBOUM7QUFDSDs7QUFFRCxXQUFLTSxVQUFMLEdBQWtCLElBQWxCO0FBQ0FsSCxRQUFFLENBQUNtSCxjQUFILEdBQW9CO0FBQ2hCbkksY0FBTSxFQUFFLEtBQUtvSSxhQUFMLENBQW1CNUwsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FEUTtBQUVoQi9GLGFBQUssRUFBRSxLQUFLNFIsUUFBTCxFQUZTO0FBR2hCVCxjQUFNLEVBQUUsS0FBS1UsU0FBTCxFQUhRO0FBSWhCQyxjQUFNLEVBQUUsS0FBS0MsU0FBTCxDQUFlaE0sSUFBZixDQUFvQixJQUFwQjtBQUpRLE9BQXBCO0FBT0EsV0FBS2lNLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxXQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0g7QUF0REw7QUFBQTtBQUFBLDhCQXdEYzNmLElBeERkLEVBd0RvQjtBQUNaLGFBQU9BLElBQVA7QUFDSDtBQTFETDtBQUFBO0FBQUEsb0NBNERvQjtBQUNaLFVBQUksS0FBS21mLFVBQUwsS0FBb0IsSUFBeEIsRUFBOEI7QUFDMUIsYUFBS0EsVUFBTCxHQUFrQixJQUFJN0QsaUJBQUosQ0FBc0IsS0FBS2pELElBQTNCLENBQWxCO0FBQ0EsYUFBSzhHLFVBQUwsQ0FBZ0JTLE1BQWhCLENBQXVCLEtBQUtuQixVQUE1QixFQUYwQixDQUcxQjs7QUFDQSxZQUFJLEtBQUtwRyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixPQUFvRCxLQUFLeWIsVUFBTCxDQUFnQkksTUFBaEIsRUFBeEQsRUFBa0Y7QUFDOUUsY0FBSWdCLHVCQUF1QixHQUFHLEtBQUtwQixVQUFMLENBQWdCL1EsS0FBaEIsRUFBOUI7QUFDQSxlQUFLK1EsVUFBTCxDQUFnQkksTUFBaEIsQ0FBdUJnQix1QkFBdkI7QUFDQSxlQUFLeEgsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCVSxxQkFBeEIsQ0FBOEMsS0FBS3liLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQTlDO0FBQ0E1RyxZQUFFLENBQUNtSCxjQUFILENBQWtCUCxNQUFsQixHQUEyQmdCLHVCQUF1QixHQUFDLEVBQW5EO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLEtBQUtWLFVBQUwsQ0FBZ0J6VyxJQUFoQixDQUFxQixDQUFyQixDQUFQO0FBQ0g7QUF6RUw7QUFBQTtBQUFBLHVDQTJFdUJvWCxRQTNFdkIsRUEyRWlDQyxTQTNFakMsRUEyRTRDO0FBQ3BDO0FBQ0EsVUFBSSxLQUFLMUgsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCVSxxQkFBeEIsT0FBb0QsS0FBS3liLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQXBELElBQ0FrQixTQUFTLEdBQUcsS0FBS25CLGNBRHJCLEVBQ3FDO0FBQ2pDLGFBQUtILFVBQUwsQ0FBZ0JJLE1BQWhCLENBQXVCLEtBQUdrQixTQUExQjtBQUNBLGFBQUsxSCxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLeWIsVUFBTCxDQUFnQkksTUFBaEIsRUFBOUM7QUFDSCxPQU5tQyxDQU9wQzs7O0FBQ0EsVUFBSWlCLFFBQVEsR0FBRyxLQUFLckIsVUFBTCxDQUFnQi9RLEtBQWhCLEVBQWYsRUFBd0M7QUFDcEMsYUFBSzJLLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQm1DLFNBQW5CLENBQTZCYSxRQUE3QjtBQUNIO0FBQ0o7QUF0Rkw7QUFBQTtBQUFBLG9DQXdGb0I7QUFDWixVQUFJLEtBQUsrSixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ29lLGdCQUFwQyxFQUFKLEVBQTREO0FBQ3hELFlBQUksS0FBS2IsVUFBVCxFQUFxQjtBQUNqQixjQUFJbkQsTUFBTSxHQUFHLEtBQUttRCxVQUFMLENBQWdCelcsSUFBaEIsQ0FBcUIwRyxJQUFyQixDQUEwQixRQUExQixFQUFvQ3dCLElBQXBDLEdBQTJDLENBQTNDLENBQWI7QUFDQSxjQUFJcVAsT0FBTyxHQUFHakUsTUFBTSxDQUFDa0UsU0FBUCxDQUFpQixXQUFqQixDQUFkO0FBQ0EsZUFBSzdILElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCMUQsU0FBNUIsQ0FBc0MsZUFBdEMsRUFBdUQ4YSxPQUF2RDtBQUNILFNBSkQsTUFJTyxJQUFJLEtBQUtQLFVBQVQsRUFBcUI7QUFDeEIsY0FBSTFELE9BQU0sR0FBRyxLQUFLMEQsVUFBTCxDQUFnQjFELE1BQTdCOztBQUNBLGNBQUlpRSxRQUFPLEdBQUdqRSxPQUFNLENBQUNrRSxTQUFQLENBQWlCLFdBQWpCLENBQWQ7O0FBQ0EsZUFBSzdILElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCMUQsU0FBNUIsQ0FBc0MsZUFBdEMsRUFBdUQ4YSxRQUF2RDtBQUNILFNBSk0sTUFJQSxDQUNIO0FBQ0g7QUFDSjtBQUNKLEtBdEdMLENBd0dJOztBQXhHSjtBQUFBO0FBQUEsZ0NBeUdnQjtBQUNSLGFBQU8sSUFBUDtBQUNIO0FBM0dMO0FBQUE7QUFBQSwrQkE2R2U7QUFDUCxhQUFPMVAsSUFBSSxDQUFDQyxHQUFMLENBQVMsS0FBS2tPLGFBQWQsRUFBNkIsS0FBS0QsVUFBTCxDQUFnQi9RLEtBQWhCLEtBQXdCLEVBQXJELENBQVA7QUFDSDtBQS9HTDtBQUFBO0FBQUEsZ0NBaUhnQjtBQUNSLGFBQU82QyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxLQUFLbU8sY0FBZCxFQUE4QixLQUFLRixVQUFMLENBQWdCSSxNQUFoQixLQUF5QixFQUF2RCxDQUFQO0FBQ0g7QUFuSEw7QUFBQTtBQUFBLDhCQXFIYztBQUNOLGFBQU8sS0FBS3hHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkcsV0FBeEIsRUFBUDtBQUNIO0FBRUQ7Ozs7Ozs7O0FBekhKO0FBQUE7QUFBQSxnQ0FnSWdCcU4sSUFoSWhCLEVBZ0lzQnFRLElBaEl0QixFQWdJNEI7QUFDcEIsV0FBSzFCLFVBQUwsQ0FBZ0JyUCxJQUFoQixDQUFxQix5QkFBckIsRUFBZ0RnUixJQUFoRCxDQUFxRCxZQUFXO0FBQzVELFlBQUkzWCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVE0WCxJQUFSLENBQWEsV0FBYixLQUE2QnZRLElBQWpDLEVBQXVDO0FBQ25DckgsV0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRMFEsSUFBUjtBQUNILFNBRkQsTUFFTztBQUNIMVEsV0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRMlEsSUFBUjtBQUNIO0FBQ0osT0FORDtBQU9IO0FBeElMO0FBQUE7O0FBMElJOzs7O0FBMUlKLDBCQThJVWtILFFBOUlWLEVBOElvQjtBQUNaO0FBQ0E7QUFDQSxVQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNYO0FBQ0g7O0FBQ0QsVUFBSUMsS0FBSyxHQUFHLEtBQVo7O0FBQ0EsVUFBSUQsUUFBUSxDQUFDRSxNQUFULENBQWdCRixRQUFRLENBQUNuUCxNQUFULEdBQWdCLENBQWhDLE1BQXVDLElBQTNDLEVBQWlEO0FBQzdDb1AsYUFBSyxHQUFHLElBQVI7QUFDSDs7QUFDRCxVQUFJRSxVQUFVLEdBQUdILFFBQVEsQ0FBQ0ksS0FBVCxDQUFlLElBQWYsQ0FBakI7O0FBQ0EsVUFBSSxLQUFLMUIsVUFBTCxLQUFvQixJQUF4QixFQUE4QjtBQUMxQixhQUFLQSxVQUFMLEdBQWtCLElBQUl2QyxlQUFKLENBQW9CLEtBQUtwRSxJQUF6QixFQUErQjZCLGVBQWUsQ0FBQ3RYLElBQS9DLEVBQXFENmQsVUFBVSxDQUFDLENBQUQsQ0FBL0QsQ0FBbEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLekIsVUFBTCxDQUFnQjJCLFVBQWhCLENBQTJCRixVQUFVLENBQUMsQ0FBRCxDQUFyQztBQUNIOztBQUNELFdBQUssSUFBSUcsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHSCxVQUFVLENBQUN0UCxNQUFYLEdBQWtCLENBQXBDLEVBQXVDeVAsQ0FBQyxFQUF4QyxFQUE0QztBQUN4QyxhQUFLbGEsTUFBTCxDQUFZc1gsSUFBWixDQUFpQixLQUFLZ0IsVUFBdEI7QUFDQSxhQUFLQSxVQUFMLENBQWdCWSxNQUFoQixDQUF1QixLQUFLbkIsVUFBNUI7QUFDQSxhQUFLTyxVQUFMLEdBQWtCLElBQUl2QyxlQUFKLENBQW9CLEtBQUtwRSxJQUF6QixFQUErQjZCLGVBQWUsQ0FBQ3RYLElBQS9DLEVBQXFENmQsVUFBVSxDQUFDRyxDQUFELENBQS9ELENBQWxCO0FBQ0g7O0FBQ0QsVUFBSUwsS0FBSixFQUFXO0FBQ1AsYUFBSzdaLE1BQUwsQ0FBWXNYLElBQVosQ0FBaUIsS0FBS2dCLFVBQXRCO0FBQ0EsYUFBS0EsVUFBTCxDQUFnQlksTUFBaEIsQ0FBdUIsS0FBS25CLFVBQTVCO0FBQ0EsYUFBS08sVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0o7QUF4S0w7QUFBQTtBQUFBLHlCQTJLUzZCLEtBM0tULEVBMktnQjtBQUNSLFdBQUs1QixVQUFMLEdBQWtCLElBQUl6QyxlQUFKLENBQW9CLEtBQUtuRSxJQUF6QixFQUErQndJLEtBQS9CLENBQWxCO0FBQ0EsV0FBSzVCLFVBQUwsQ0FBZ0JXLE1BQWhCLENBQXVCLEtBQUtuQixVQUE1QjtBQUNBLGFBQU8sS0FBS1EsVUFBWjtBQUNIO0FBL0tMO0FBQUE7QUFBQSwyQkFpTFd4USxJQWpMWCxFQWlMaUI5SyxVQWpMakIsRUFpTDZCbVksU0FqTDdCLEVBaUx3QztBQUNoQyxVQUFJLEtBQUs0RCxVQUFMLEtBQW9CLElBQXhCLEVBQThCO0FBQzFCLGFBQUtBLFVBQUwsR0FBa0IsSUFBSTdELGlCQUFKLENBQXNCLEtBQUt4RCxJQUEzQixFQUFpQzVKLElBQWpDLEVBQXVDOUssVUFBdkMsRUFBbURtWSxTQUFuRCxDQUFsQjtBQUNBLGFBQUs0RCxVQUFMLENBQWdCRSxNQUFoQixDQUF1QixLQUFLbkIsVUFBNUI7QUFDSDs7QUFDRCxhQUFPLEtBQUtpQixVQUFaO0FBQ0g7QUF2TEw7QUFBQTtBQUFBLDRCQXlMWWpSLElBekxaLEVBeUxrQjlLLFVBekxsQixFQXlMOEI7QUFDdEIsVUFBSSxLQUFLZ2MsV0FBTCxLQUFxQixJQUF6QixFQUErQjtBQUMzQixhQUFLQSxXQUFMLEdBQW1CLElBQUkvRCxrQkFBSixDQUF1QixLQUFLdkQsSUFBNUIsRUFBa0M1SixJQUFsQyxFQUF3QzlLLFVBQXhDLENBQW5CO0FBQ0EsYUFBS2djLFdBQUwsQ0FBaUJDLE1BQWpCLENBQXdCLEtBQUtuQixVQUE3QjtBQUNIOztBQUNELGFBQU8sS0FBS2tCLFdBQVo7QUFDSDtBQS9MTDtBQUFBO0FBQUEsa0NBaU1rQm1CLFNBak1sQixFQWlNNkI7QUFDckJwWCxhQUFPLENBQUNvTyxHQUFSLENBQVksTUFBWixFQUFvQmdKLFNBQVMsQ0FBQ0MsS0FBOUI7QUFDQSxXQUFLQyxXQUFMLEdBQW1CLElBQUl6RSxnQkFBSixDQUFxQixLQUFLbEUsSUFBMUIsRUFBZ0N5SSxTQUFTLENBQUNDLEtBQTFDLENBQW5CO0FBQ0EsV0FBS0MsV0FBTCxDQUFpQnBCLE1BQWpCLENBQXdCLEtBQUtuQixVQUE3QjtBQUNBLGFBQU8sS0FBS3VDLFdBQVo7QUFDSDtBQXRNTDtBQUFBO0FBQUEsK0JBd01lQyxLQXhNZixFQXdNc0I7QUFDZCxVQUFJQyxZQUFZLEdBQUcsSUFBSW5FLGdCQUFKLENBQXFCLEtBQUsxRSxJQUExQixFQUFnQzRJLEtBQWhDLENBQW5CO0FBQ0FDLGtCQUFZLENBQUN0QixNQUFiLENBQW9CLEtBQUtuQixVQUF6QjtBQUNBLGFBQU95QyxZQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBOU1KO0FBQUE7QUFBQSwwQkFtTlVqRSxhQW5OVixFQW1OeUI7QUFDakIsV0FBS2tFLFdBQUwsR0FBbUIsSUFBSW5FLGdCQUFKLENBQXFCLEtBQUszRSxJQUExQixFQUFnQzRFLGFBQWhDLENBQW5CO0FBQ0EsYUFBTyxLQUFLa0UsV0FBTCxDQUFpQnZCLE1BQWpCLENBQXdCLEtBQUtuQixVQUE3QixDQUFQO0FBQ0g7QUF0Tkw7QUFBQTtBQUFBLCtCQXlOZTtBQUNQLFdBQUswQyxXQUFMLEdBQW1CLElBQUk3QyxtQkFBSixDQUF3QixLQUFLakcsSUFBN0IsQ0FBbkI7QUFDQSxhQUFPLEtBQUs4SSxXQUFMLENBQWlCdkIsTUFBakIsQ0FBd0IsS0FBS25CLFVBQTdCLENBQVA7QUFDSDtBQTVOTDtBQUFBO0FBQUEsZ0NBOE5nQjtBQUNSLFVBQUkyQyxlQUFlLEdBQUcsSUFBSTdDLHdCQUFKLENBQTZCLEtBQUtsRyxJQUFsQyxDQUF0QjtBQUNBLGFBQU8rSSxlQUFlLENBQUN4QixNQUFoQixDQUF1QixLQUFLbkIsVUFBNUIsQ0FBUDtBQUNIO0FBRUQ7Ozs7O0FBbk9KO0FBQUE7QUFBQSxxQ0F1T3FCO0FBQ2IsV0FBS0QsR0FBTCxDQUFTNkMsT0FBVCxDQUFpQjtBQUNiMUYsaUJBQVMsRUFBRSxLQUFLNkMsR0FBTCxDQUFTUCxJQUFULENBQWMsY0FBZCxJQUFnQyxLQUFLTyxHQUFMLENBQVNQLElBQVQsQ0FBYyxjQUFkO0FBRDlCLE9BQWpCLEVBRUcsR0FGSDtBQUdIO0FBM09MOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7OztBQzFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0NBRUE7O0FBRU8sSUFBSXFELGtCQUFrQixHQUFHLEVBQXpCO0FBQ0EsSUFBSUMsMkJBQTJCLEdBQUcsRUFBbEM7QUFFUDs7Ozs7OztBQU1BLElBQUlDLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0IsQ0FBVUMsR0FBVixFQUFlO0FBQ2pDQSxLQUFHLENBQUNqUyxRQUFKLENBQWEsUUFBYixFQUNLQSxRQURMLENBQ2MsYUFEZCxFQUVLRSxXQUZMLENBRWlCLGFBRmpCLEVBR0t1TyxJQUhMLENBR1UsVUFIVixFQUdzQixJQUh0QixFQUlLM0YsSUFKTCxDQUlVLFFBSlYsRUFLSytILElBTEwsQ0FLVSxjQUxWLEVBSzBCLE1BTDFCO0FBTUgsQ0FQRDtBQVVBOzs7Ozs7Ozs7OztBQVNPLFNBQVNwSCxhQUFULENBQXVCWixJQUF2QixFQUE2QjtBQUNoQyxPQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFFQSxPQUFLcUosY0FBTCxHQUFzQixFQUF0QjtBQUNBLE9BQUszVyxZQUFMO0FBQ0g7O0FBRURrTyxhQUFhLENBQUNULFNBQWQsQ0FBd0J6TixZQUF4QixHQUF1QyxVQUFVNFcsUUFBVixFQUFvQjtBQUFBOztBQUN2RDtBQUNBLE1BQUloaUIsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0QjtBQUFBLE1BQ0lzVyxNQUFNLEdBQUcsS0FBS29DLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJvQyxZQURsQztBQUFBLE1BRUluQyxNQUFNLEdBQUcsS0FBS3dQLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BRmxDO0FBR0EsTUFBSStZLE9BQU8sR0FBRyxFQUFkO0FBQ0FqaUIsT0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCaWdCLFFBQTFCLEdBQXFDbkIsS0FBckMsQ0FBMkMsR0FBM0MsRUFBZ0RvQixPQUFoRCxDQUF3RCxVQUFDOWhCLElBQUQsRUFBVTtBQUM5RCxRQUFJQSxJQUFJLElBQUksRUFBRUEsSUFBSSxJQUFJK2hCLHNCQUFzQixDQUFDQyxXQUFqQyxDQUFaLEVBQTJEO0FBQ3ZESixhQUFPLENBQUM1RCxJQUFSLENBQWFpRSxLQUFiLENBQW1CTCxPQUFuQixFQUE0QixLQUFJLENBQUNqTyxhQUFMLENBQW1CdU8sdURBQUksQ0FBQ2xpQixJQUFELENBQXZCLEVBQStCQSxJQUEvQixFQUFxQzJoQixRQUFyQyxDQUE1QjtBQUNIO0FBQ0osR0FKRCxFQU51RCxDQVl2RDs7QUFDQWxaLEdBQUMsQ0FBQzBaLElBQUYsQ0FBT0YsS0FBUCxDQUFheFosQ0FBYixFQUFnQm1aLE9BQWhCLEVBQXlCUSxJQUF6QixDQUE4QixZQUFZO0FBQ3RDO0FBQ0FuTSxVQUFNLENBQUNoTCxFQUFQLENBQVVvWCxpQkFBVjtBQUNBcE0sVUFBTSxDQUFDaEwsRUFBUCxDQUFVcUcsV0FBVixDQUFzQmdSLGFBQXRCO0FBQ0gsR0FKRCxFQUlHQyxJQUpILENBSVEsVUFBVWpMLENBQVYsRUFBYTtBQUNqQjVOLFdBQU8sQ0FBQ29PLEdBQVIsQ0FBWTBLLFNBQVo7QUFDQTlZLFdBQU8sQ0FBQytZLEtBQVIsQ0FBY25MLENBQWQ7QUFDSCxHQVBELEVBT0dvTCxNQVBILENBT1UsWUFBWTtBQUNsQjdaLFVBQU0sQ0FBQzhaLHFCQUFQO0FBQ0gsR0FURDtBQVVILENBdkJEO0FBeUJBOzs7Ozs7Ozs7Ozs7OztBQVlBMUosYUFBYSxDQUFDVCxTQUFkLENBQXdCN0UsYUFBeEIsR0FBd0MsVUFBVXVPLElBQVYsRUFBZ0JsaUIsSUFBaEIsRUFBc0I7QUFBQTs7QUFDMUQsTUFBSTRpQixjQUFjLEdBQUcsRUFBckI7O0FBQ0EsTUFBSSxLQUFLdkssSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CekMsTUFBbkIsQ0FBMEJ3TCxtQkFBMUIsQ0FBOEMsZ0JBQTlDLENBQUosRUFBcUU7QUFDakUsUUFBSXdPLElBQUksR0FBRyxLQUFLeEssSUFBTCxDQUFVMVksS0FBVixDQUFnQnRCLGFBQWhCLENBQThCOEosSUFBOUIsQ0FBbUMyYSxjQUFuQyxHQUFvRCxVQUFwRCxHQUFpRVosSUFBakUsR0FBd0UsR0FBeEUsR0FBOEVBLElBQXpGO0FBQ0EsU0FBSzdKLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QmlCLGVBQXhCLENBQXdDeWEsSUFBeEMsQ0FBNkNoZSxJQUE3QyxFQUZpRSxDQUdqRTs7QUFDQSxRQUFJK2lCLFVBQVUsR0FBR3RhLENBQUMsQ0FBQ3VhLFNBQUYsQ0FBWUgsSUFBSSxHQUFHLGFBQW5CLENBQWpCLENBSmlFLENBS2pFOztBQUNBLFFBQUlJLFdBQVcsR0FBR3hhLENBQUMsQ0FBQ3VhLFNBQUYsQ0FBWUgsSUFBSSxHQUFHLGNBQW5CLENBQWxCO0FBQ0EsUUFBSUssU0FBUyxHQUFHemEsQ0FBQyxDQUFDaEosR0FBRixDQUFNb2pCLElBQUksR0FBRyxZQUFiLEVBQTJCLFVBQVVwWixJQUFWLEVBQWdCO0FBQ3ZEd08sUUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCLGFBQWFnSyxJQUFiLEdBQW9CLGNBQTdDLElBQStEelksSUFBL0Q7QUFDSCxLQUZlLENBQWhCO0FBR0EsUUFBSTBaLFVBQVUsR0FBRzFhLENBQUMsQ0FBQ3VhLFNBQUYsQ0FBWUgsSUFBSSxHQUFHLGFBQW5CLENBQWpCLENBVmlFLENBV2pFOztBQUNBcGEsS0FBQyxDQUFDMFosSUFBRixDQUFPWSxVQUFQLEVBQW1CRyxTQUFuQixFQUE4QkMsVUFBOUIsRUFBMENmLElBQTFDLENBQStDLFlBQU07QUFDakQsWUFBSSxDQUFDVixjQUFMLENBQW9CMUQsSUFBcEIsQ0FBeUJrRSxJQUF6Qjs7QUFDQSxZQUFJLENBQUM3SixJQUFMLENBQVV6UCxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDbVksWUFBckMsQ0FBa0RDLGFBQWxELENBQWdFckYsSUFBaEUsQ0FBcUVrRSxJQUFyRTs7QUFDQSxZQUFJLENBQUM3SixJQUFMLENBQVV6UCxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDb1gsaUJBQXJDOztBQUNBLFlBQUksQ0FBQ2hLLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJvQyxZQUFyQixDQUFrQ0MsRUFBbEMsQ0FBcUNxRyxXQUFyQyxDQUFpRGdSLGFBQWpEOztBQUNBLFlBQUksQ0FBQ2pLLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QmlCLGVBQXhCLENBQXdDOFgsTUFBeEMsQ0FBK0NyYixJQUEvQztBQUNILEtBTkQ7QUFPQTRpQixrQkFBYyxDQUFDNUUsSUFBZixDQUFvQitFLFVBQXBCLEVBQWdDRyxTQUFoQyxFQUEyQ0MsVUFBM0M7QUFDSDs7QUFDRCxTQUFPUCxjQUFQO0FBQ0gsQ0F4QkQ7QUEwQkE7Ozs7Ozs7OztBQU9BM0osYUFBYSxDQUFDVCxTQUFkLENBQXdCNUUsVUFBeEIsR0FBcUMsWUFBWTtBQUFBOztBQUM3QyxNQUFJLEtBQUt5RSxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUJ6QyxNQUFuQixDQUEwQndMLG1CQUExQixDQUE4QyxnQkFBOUMsQ0FBSixFQUFxRTtBQUNqRSxRQUFJd08sSUFBSSxHQUFHLEtBQUt4SyxJQUFMLENBQVUxWSxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEI4SixJQUE5QixDQUFtQzJhLGNBQTlDO0FBQ0FyYSxLQUFDLENBQUM2YSxPQUFGLENBQVVULElBQUksR0FBRyxZQUFqQixFQUFnQyxVQUFDcFosSUFBRCxFQUFVO0FBQ3RDO0FBQ0EsVUFBSW9ZLFFBQVEsR0FBR3BZLElBQUksQ0FBQzhaLE9BQXBCO0FBQ0EsVUFBSUMsYUFBYSxHQUFHWCxJQUFJLEdBQUMsb0JBQXpCO0FBQ0EsVUFBSTFqQixLQUFLLEdBQUdzSixDQUFDLHFEQUE4QythLGFBQTlDLGlDQUFiO0FBQ0EsVUFBSUMsSUFBSSxHQUFHaGIsQ0FBQyxDQUFDLGlCQUFELEVBQW9CO0FBQUMsaUJBQVM7QUFBVixPQUFwQixDQUFaO0FBQ0FpYixZQUFNLENBQUNDLElBQVAsQ0FBWTlCLFFBQVosRUFBc0IrQixJQUF0QixHQUE2QjlRLEdBQTdCLENBQWlDLFVBQUM5UyxJQUFELEVBQVU7QUFDdkMsWUFBSTZqQixXQUFXLEdBQUczQix1REFBSSxDQUFDTCxRQUFRLENBQUM3aEIsSUFBRCxDQUFSLENBQWVBLElBQWhCLENBQXRCO0FBQ0EsWUFBSThqQixTQUFTLEdBQUc5akIsSUFBaEI7QUFDQSxZQUFJeWhCLEdBQUcsR0FBR2haLENBQUMsQ0FBQywwSEFBRCxDQUFYO0FBQ0EsWUFBSXNiLE1BQU0sR0FBR2xCLElBQUksR0FBQyxxQkFBTCxHQUEyQjdpQixJQUEzQixHQUFnQyxXQUE3Qzs7QUFDQSxZQUFJLE1BQUksQ0FBQzBoQixjQUFMLENBQW9Cck8sT0FBcEIsQ0FBNEJ3USxXQUE1QixJQUEyQyxDQUFDLENBQWhELEVBQW1EO0FBQy9DckMseUJBQWUsQ0FBQ0MsR0FBRCxDQUFmO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLGFBQUcsQ0FBQ3ZELEtBQUosQ0FBVyxZQUFNO0FBQ2Isa0JBQUksQ0FBQ3ZLLGFBQUwsQ0FBbUJrUSxXQUFuQixFQUFnQyxZQUFZaEMsUUFBUSxDQUFDN2hCLElBQUQsQ0FBUixDQUFlZ2tCLEtBQTNEOztBQUNBeEMsMkJBQWUsQ0FBQ0MsR0FBRCxDQUFmO0FBQ0gsV0FIRDtBQUlILFNBWnNDLENBYXZDOzs7QUFDQWhaLFNBQUMsQ0FBQyxXQUFELENBQUQsQ0FDSTtBQURKLFNBRUswVCxNQUZMLENBRVkxVCxDQUFDLENBQUMsU0FBU29aLFFBQVEsQ0FBQzdoQixJQUFELENBQVIsQ0FBZWdrQixLQUF4QixHQUFnQyxPQUFqQyxDQUZiLEVBR0s3SCxNQUhMLENBR1kxVCxDQUFDLENBQUMsU0FBU29aLFFBQVEsQ0FBQzdoQixJQUFELENBQVIsQ0FBZWlrQixRQUF4QixHQUFtQyxPQUFwQyxDQUhiLEVBSUs5SCxNQUpMLENBSVkxVCxDQUFDLENBQUMsV0FBRCxDQUFELENBQWUwVCxNQUFmLENBQXNCc0YsR0FBdEIsQ0FKWixFQUtLeUMsUUFMTCxDQUtjVCxJQUxkO0FBTUgsT0FwQkQ7QUFxQkFBLFVBQUksQ0FBQ1MsUUFBTCxDQUFjL2tCLEtBQWQsRUEzQnNDLENBNEJ0Qzs7QUFDQSxZQUFJLENBQUNrWixJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEI4TSxJQUE1QixDQUFpQyxpQkFBakMsRUFBb0RoYSxLQUFwRCxFQUEyRCxJQUEzRDtBQUNILEtBOUJEO0FBK0JIO0FBQ0osQ0FuQ0QsQzs7Ozs7Ozs7Ozs7O0FDN0dBO0FBQ0EsT0FBTyxLQUFVLEVBQUUsa0JBS2Q7Ozs7Ozs7Ozs7OztBQ05MO0FBQ0EsT0FBTyxLQUFVLEVBQUUsa0JBS2Q7Ozs7Ozs7Ozs7Ozs7QUNOTDtBQUFBO0FBQUE7QUFBQTtBQUVPLElBQUlnbEIsV0FBVyw0a0NBQWY7QUF5QlA7Ozs7Ozs7Ozs7OztBQVdPLFNBQVMxTCxhQUFULENBQXVCSixJQUF2QixFQUE2Qm1HLEdBQTdCLEVBQWtDO0FBQUE7O0FBQ3JDLE9BQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxPQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBRUEsT0FBSzRGLFFBQUwsR0FBZ0I1RixHQUFHLENBQUNwUCxJQUFKLENBQVMsY0FBVCxDQUFoQjtBQUNBLE9BQUtpVixPQUFMLEdBQWU3RixHQUFHLENBQUNwUCxJQUFKLENBQVMsYUFBVCxDQUFmO0FBQ0EsT0FBS2tWLFNBQUwsR0FBaUI5RixHQUFHLENBQUNwUCxJQUFKLENBQVMsZUFBVCxDQUFqQjtBQUNBLE9BQUttVixVQUFMLEdBQWtCL0YsR0FBRyxDQUFDcFAsSUFBSixDQUFTLGFBQVQsQ0FBbEI7QUFDQSxPQUFLb1YsV0FBTCxHQUFtQmhHLEdBQUcsQ0FBQ3BQLElBQUosQ0FBUyxjQUFULENBQW5COztBQUVBLE9BQUtxVixHQUFMLEdBQVcsWUFBTSxDQUFFLENBQW5COztBQUNBLE9BQUtDLEVBQUwsR0FBVSxZQUFNLENBQUUsQ0FBbEI7O0FBQ0EsT0FBS0gsVUFBTCxDQUFnQnJHLEtBQWhCLENBQXNCLFlBQU07QUFDeEIsU0FBSSxDQUFDdUcsR0FBTDs7QUFDQSxTQUFJLENBQUNqRyxHQUFMLENBQVNtRyxLQUFULENBQWUsTUFBZjtBQUNILEdBSEQ7QUFJQSxPQUFLSCxXQUFMLENBQWlCdEcsS0FBakIsQ0FBdUIsWUFBTTtBQUN6QixTQUFJLENBQUN3RyxFQUFMLEdBRHlCLENBRXpCOztBQUNILEdBSEQ7QUFJSDs7QUFFRGpNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3Qm9NLEtBQXhCLEdBQWdDLFlBQVk7QUFDeEMsT0FBS3BHLEdBQUwsQ0FBU21HLEtBQVQsQ0FBZSxNQUFmO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7Ozs7O0FBUUFsTSxhQUFhLENBQUNELFNBQWQsQ0FBd0JXLElBQXhCLEdBQStCLFVBQVU2SyxLQUFWLEVBQWlCUCxJQUFqQixFQUF1Qm9CLE9BQXZCLEVBQWdDO0FBQzNELE9BQUtULFFBQUwsQ0FBYzFiLElBQWQsQ0FBbUJzYixLQUFuQjtBQUNBLE9BQUtLLE9BQUwsQ0FBYTNiLElBQWIsQ0FBa0IrYSxJQUFsQjtBQUNBLE9BQUtqRixHQUFMLENBQVNtRyxLQUFULENBQWUsTUFBZjtBQUNBLE9BQUtKLFVBQUwsQ0FBZ0JuTCxJQUFoQjtBQUNBLE9BQUtvRixHQUFMLENBQVNzRyxTQUFULENBQW1CO0FBQ2YsY0FBVTtBQURLLEdBQW5CO0FBSUEsT0FBS3RHLEdBQUwsQ0FBU3VHLEVBQVQsQ0FBWSxpQkFBWixFQUErQixVQUFVek4sQ0FBVixFQUFhO0FBQ3hDLFFBQUl1TixPQUFPLEtBQUtwbUIsU0FBWixJQUF5Qm9tQixPQUFPLEtBQUssSUFBekMsRUFBK0M7QUFDM0NBLGFBQU87QUFDVjtBQUNKLEdBSkQ7QUFLSCxDQWREOztBQWdCQXBNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QndNLE9BQXhCLEdBQWtDLFVBQVVoQixLQUFWLEVBQWlCUCxJQUFqQixFQUF1QmdCLEdBQXZCLEVBQTRCQyxFQUE1QixFQUFnQ08sT0FBaEMsRUFBeUM7QUFDdkUsTUFBSUEsT0FBTyxLQUFLeG1CLFNBQWhCLEVBQTJCO0FBQ3ZCd21CLFdBQU8sR0FBRyxNQUFWO0FBQ0g7O0FBQ0QsT0FBSzlMLElBQUwsQ0FBVTZLLEtBQVYsRUFBaUJQLElBQWpCLEVBQXVCaUIsRUFBdkI7QUFDQSxPQUFLRCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxPQUFLQyxFQUFMLEdBQVVBLEVBQVY7QUFDQSxPQUFLSCxVQUFMLENBQWdCcEwsSUFBaEIsR0FBdUJ6USxJQUF2QixDQUE0QnVjLE9BQTVCLEVBUHVFLENBUXZFO0FBQ0gsQ0FURDs7QUFXQXhNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QjBNLDBCQUF4QixHQUFxRCxZQUFZO0FBQzdELE9BQUtGLE9BQUwsQ0FBYSxvQkFBYixFQUFtQyw4R0FBbkM7QUFDSCxDQUZEOztBQUlBdk0sYUFBYSxDQUFDRCxTQUFkLENBQXdCMk0seUJBQXhCLEdBQW9ELFVBQVVDLE1BQVYsRUFBa0I7QUFDbEUsT0FBS2pNLElBQUwsQ0FBVSwwQkFBVix1SkFDeUVpTSxNQUR6RTtBQUVILENBSEQ7O0FBS0EzTSxhQUFhLENBQUNELFNBQWQsQ0FBd0I2TSw0QkFBeEIsR0FBdUQsVUFBVUQsTUFBVixFQUFrQjtBQUNyRSxPQUFLak0sSUFBTCxDQUFVLDhCQUFWLDJKQUN5RWlNLE1BRHpFO0FBRUgsQ0FIRDs7QUFLQTNNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QjhNLG9CQUF4QixHQUErQyxVQUFVRixNQUFWLEVBQWtCO0FBQzdELE9BQUtqTSxJQUFMLENBQVUscUJBQVYsK0hBQ3FEaU0sTUFEckQ7QUFFSCxDQUhEOztBQUtBM00sYUFBYSxDQUFDRCxTQUFkLENBQXdCK00sc0JBQXhCLEdBQWlELFVBQVVILE1BQVYsRUFBa0I7QUFDL0QsT0FBS2pNLElBQUwsQ0FBVSx3QkFBViwrSEFDcURpTSxNQURyRDtBQUVILENBSEQ7O0FBS0EzTSxhQUFhLENBQUNELFNBQWQsQ0FBd0JnTixtQkFBeEIsR0FBOEMsVUFBVUosTUFBVixFQUFrQjtBQUM1RCxPQUFLak0sSUFBTCxDQUFVLHFCQUFWLDRIQUNxRGlNLE1BRHJEO0FBRUgsQ0FIRDs7QUFLQTNNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QmlOLG1CQUF4QixHQUE4QyxVQUFVTCxNQUFWLEVBQWtCO0FBQzVELE9BQUtqTSxJQUFMLENBQVUscUJBQVYsNEhBQ3FEaU0sTUFEckQ7QUFFSCxDQUhEOztBQUtBM00sYUFBYSxDQUFDRCxTQUFkLENBQXdCa04sd0JBQXhCLEdBQW1ELFVBQVVOLE1BQVYsRUFBa0I7QUFDakUsT0FBS2pNLElBQUwsQ0FBVSx5QkFBVixzSkFDeUVpTSxNQUR6RTtBQUVILENBSEQ7O0FBS0EzTSxhQUFhLENBQUNELFNBQWQsQ0FBd0JtTix3QkFBeEIsR0FBbUQsVUFBVWxELEtBQVYsRUFBaUI7QUFDaEUsT0FBS3RKLElBQUwsQ0FBVSxnQkFBVixpSEFBa0lzSixLQUFsSTtBQUNILENBRkQ7O0FBSUFoSyxhQUFhLENBQUNELFNBQWQsQ0FBd0JvTixzQkFBeEIsR0FBaUQsVUFBVTVCLEtBQVYsRUFBaUJ2YyxPQUFqQixFQUEwQjtBQUN2RSxPQUFLMFIsSUFBTCxDQUFVNkssS0FBVixFQUFpQnZjLE9BQWpCO0FBQ0gsQ0FGRDs7QUFJQWdSLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QnFOLGlCQUF4QixHQUE0QyxZQUFZLENBQ3BEO0FBQ0gsQ0FGRDs7QUFJQXBOLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QnNOLGdDQUF4QixHQUEyRCxZQUFZO0FBQ25FLE9BQUszTSxJQUFMLENBQVUsa0NBQVY7QUFFSCxDQUhEOztBQUtBVixhQUFhLENBQUNELFNBQWQsQ0FBd0IzRCxxQkFBeEIsR0FBZ0QsWUFBWTtBQUN4RCxPQUFLc0UsSUFBTCxDQUFVLHVCQUFWO0FBRUgsQ0FIRDs7QUFLQVYsYUFBYSxDQUFDRCxTQUFkLENBQXdCdU4sVUFBeEIsR0FBcUMsWUFBWTtBQUM3QyxNQUFJQyxRQUFRLEdBQUcsS0FBSzNOLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QjhKLElBQTlCLENBQW1DOGQsMkJBQWxEO0FBQ0FELFVBQVEsR0FBR0EsUUFBUSx5QkFBaUJBLFFBQWpCLG1EQUFzRSxFQUF6RjtBQUNBLE9BQUs3TSxJQUFMLENBQVUsNkJBQVYsc2FBUStFNk0sUUFSL0UsMHlCQXVCeUQsS0FBSzNOLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JDLElBQWhCLENBQXFCTyxRQUFyQixFQXZCekQ7QUEwQkgsQ0E3QkQ7O0FBK0JBc1ksYUFBYSxDQUFDRCxTQUFkLENBQXdCbE0sV0FBeEIsR0FBc0MsWUFBWTtBQUFBOztBQUM5QyxNQUFJNFosU0FBUyxHQUFHLEtBQUs3TixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJHLEtBQTFCLEdBQWtDd2YsSUFBbEMsQ0FBdUMsSUFBdkMsQ0FBaEI7QUFDQSxNQUFJdGlCLFdBQVcsR0FBRyxLQUFLd1UsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCdUIsV0FBeEIsS0FBd0MsRUFBeEMsR0FBNkMsU0FBL0Q7O0FBQ0EsTUFBSTRnQixHQUFHLEdBQUcsU0FBTkEsR0FBTSxHQUFNO0FBQ1osUUFBSTJCLE9BQU8sR0FBRyxNQUFJLENBQUM1SCxHQUFMLENBQVNwUCxJQUFULENBQWMsMEJBQWQsRUFBMEM2TyxJQUExQyxDQUErQyxTQUEvQyxDQUFkOztBQUNBLFFBQUlvSSxNQUFNLEdBQUcsTUFBSSxDQUFDN0gsR0FBTCxDQUFTcFAsSUFBVCxDQUFjLHFCQUFkLEVBQXFDeUksR0FBckMsR0FBMkM2SSxLQUEzQyxDQUFpRCxJQUFqRCxDQUFiOztBQUNBLFVBQUksQ0FBQ3JJLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QnVCLFdBQXhCLENBQW9DLENBQUN1aUIsT0FBckM7O0FBQ0EsVUFBSSxDQUFDL04sSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCRyxLQUExQixDQUFnQzBmLE1BQWhDO0FBQ0gsR0FMRDs7QUFNQSxPQUFLckIsT0FBTCxDQUFhLHdCQUFiLGtLQUlxQ25oQixXQUpyQyxvTUFReURxaUIsU0FSekQsOE1BYUR6QixHQWJDLEVBYUksS0FBS0MsRUFiVCxFQWFhLE1BYmIsRUFUOEMsQ0F1QjlDO0FBQ0gsQ0F4QkQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0xBO0FBRU8sU0FBU3plLFVBQVQsQ0FBb0J0RyxLQUFwQixFQUEyQm9YLEtBQTNCLEVBQWtDO0FBQ3JDLE1BQUl1UCxVQUFVLEdBQUcsSUFBSWxQLFVBQUosRUFBakI7QUFDQSxNQUFJdkcsS0FBSyxHQUFHa0csS0FBSyxDQUFDRSxNQUFOLENBQWFwRyxLQUF6Qjs7QUFDQXlWLFlBQVUsQ0FBQ2pQLE1BQVgsR0FBcUIsVUFBQUMsQ0FBQztBQUFBLFdBQ2xCM1gsS0FBSyxDQUFDMkwsRUFBTixDQUFTb0gsT0FBVCxDQUFpQi9HLE9BQWpCLEdBQTJCMUYsVUFBM0IsQ0FBc0NxUixDQUF0QyxDQURrQjtBQUFBLEdBQXRCOztBQUdBZ1AsWUFBVSxDQUFDM08sUUFBWCxHQUFzQjlHLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzdRLElBQS9CO0FBQ0FzbUIsWUFBVSxDQUFDMU8sVUFBWCxDQUFzQi9HLEtBQUssQ0FBQyxDQUFELENBQTNCO0FBQ0FrRyxPQUFLLENBQUNFLE1BQU4sQ0FBYWdLLEtBQWIsR0FBcUIsRUFBckI7QUFDSDtBQUVNLFNBQVNzRixRQUFULENBQWtCak8sSUFBbEIsRUFBd0I7QUFDM0IsU0FBT0EsSUFBSSxDQUFDa08sT0FBTCxDQUFhLGFBQWIsRUFBNEIsR0FBNUIsRUFBaUNwWixXQUFqQyxFQUFQO0FBQ0g7QUFFTSxTQUFTckgsWUFBVCxDQUFzQnBHLEtBQXRCLEVBQTZCb1gsS0FBN0IsRUFBb0M7QUFBQSw4QkFDS3BYLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU29ILE9BQVQsQ0FBaUIvRyxPQUFqQixHQUEyQjVGLFlBQTNCLEVBREw7QUFBQSxNQUNsQy9GLElBRGtDLHlCQUNsQ0EsSUFEa0M7QUFBQSxNQUM1QnltQixTQUQ0Qix5QkFDNUJBLFNBRDRCO0FBQUEsTUFDakJ4VCxRQURpQix5QkFDakJBLFFBRGlCO0FBQUEsTUFDUHlULFFBRE8seUJBQ1BBLFFBRE8sRUFFdkM7OztBQUNBMW1CLE1BQUksR0FBR3VtQixRQUFRLENBQUN2bUIsSUFBRCxDQUFmO0FBQ0FBLE1BQUksR0FBR0EsSUFBSSxHQUFHeW1CLFNBQWQsQ0FKdUMsQ0FLdkM7O0FBQ0EsTUFBSUUsSUFBSSxHQUFHLElBQUlDLElBQUosQ0FBUyxDQUFDM1QsUUFBRCxDQUFULEVBQXFCO0FBQUMxUyxRQUFJLEVBQUVtbUI7QUFBUCxHQUFyQixDQUFYOztBQUNBLE1BQUlHLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsZ0JBQXJCLEVBQXVDO0FBQ25DRixVQUFNLENBQUNDLFNBQVAsQ0FBaUJFLFVBQWpCLENBQTRCTCxJQUE1QixFQUFrQzNtQixJQUFsQztBQUNILEdBRkQsTUFFTTtBQUNGLFFBQUlpbkIscUJBQXFCLEdBQUdKLE1BQU0sQ0FBQzVLLFFBQVAsQ0FBZ0JDLGFBQWhCLENBQThCLEdBQTlCLENBQTVCO0FBQ0ErSyx5QkFBcUIsQ0FBQ0MsSUFBdEIsR0FBNkJMLE1BQU0sQ0FBQ00sR0FBUCxDQUFXQyxlQUFYLENBQTJCVCxJQUEzQixDQUE3QjtBQUNBTSx5QkFBcUIsQ0FBQ3ZULFFBQXRCLEdBQWlDMVQsSUFBakM7QUFDQWljLFlBQVEsQ0FBQ3dILElBQVQsQ0FBYzRELFdBQWQsQ0FBMEJKLHFCQUExQjtBQUNBQSx5QkFBcUIsQ0FBQy9JLEtBQXRCO0FBQ0FqQyxZQUFRLENBQUN3SCxJQUFULENBQWM2RCxXQUFkLENBQTBCTCxxQkFBMUI7QUFDSDtBQUNKO0FBRU0sSUFBTU0sY0FBYjtBQUNJLDBCQUFZbFAsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBRUEsU0FBSzNVLFVBQUwsR0FBa0J3TyxJQUFJLENBQUN6UCxVQUFMLENBQWdCaUIsVUFBbEM7QUFDQSxTQUFLdEgsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUsyTyxJQUFMLEdBQVksSUFBWjtBQUNIOztBQVJMO0FBQUE7QUFBQSxpQ0FVaUI7QUFDVCxXQUFLckgsVUFBTCxDQUFnQmdJLFVBQWhCLENBQTJCLEtBQUt0UCxRQUFoQztBQUNBLFdBQUs4VixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JDLFFBQXhCLENBQWlDLFdBQWpDO0FBQ0EsV0FBSzhWLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUI4SixPQUFyQixDQUE2QjhVLFlBQTdCLENBQTBDLFdBQTFDO0FBQ0g7QUFkTDtBQUFBO0FBQUEsb0NBZ0JvQjtBQUNaO0FBQ0EsV0FBS25QLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkMsUUFBeEIsQ0FBaUMsV0FBakM7QUFDQSxXQUFLOFYsSUFBTCxDQUFVelAsVUFBVixDQUFxQjhKLE9BQXJCLENBQTZCOFUsWUFBN0IsQ0FBMEMsV0FBMUM7QUFDSDtBQXBCTDtBQUFBO0FBQUEsa0NBc0JrQnRXLElBdEJsQixFQXNCd0I7QUFDaEIsVUFBSUEsSUFBSSxDQUFDM08sUUFBTCxLQUFrQixLQUFLQSxRQUEzQixFQUFxQztBQUNqQztBQUNBLGFBQUs4VixJQUFMLENBQVV6UCxVQUFWLENBQXFCOEosT0FBckIsQ0FBNkI4VSxZQUE3QixDQUEwQyxLQUFLamxCLFFBQS9DLEVBRmlDLENBR2pDO0FBQ0E7QUFDSDtBQUNKO0FBN0JMO0FBQUE7QUFBQSx1Q0ErQnVCO0FBQ2YsV0FBS3NILFVBQUwsQ0FBZ0I0ZCxTQUFoQixDQUEwQixLQUFLbGxCLFFBQS9CLEVBQXlDO0FBQ3JDbWxCLGVBQU8sRUFBRSxLQUFLQyxhQUFMLENBQW1CbFUsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FENEI7QUFFckNtVSxlQUFPLEVBQUUsS0FBS0MsYUFBTCxDQUFtQnBVLElBQW5CLENBQXdCLElBQXhCO0FBRjRCLE9BQXpDO0FBSUg7QUFwQ0w7QUFBQTtBQUFBLDBCQXNDVXFVLFdBdENWLEVBc0N1QkMsU0F0Q3ZCLEVBc0NrQztBQUMxQixXQUFLeGxCLFFBQUwsR0FBZ0J1bEIsV0FBaEI7QUFDQSxXQUFLNVcsSUFBTCxHQUFZLEtBQUtySCxVQUFMLENBQWdCcUksT0FBaEIsQ0FBd0I0VixXQUF4QixDQUFaO0FBQ0EsV0FBS0UsZ0JBQUw7QUFDSDtBQUVEOzs7Ozs7O0FBNUNKO0FBQUE7QUFBQSx5QkFrRFNGLFdBbERULEVBa0RzQkMsU0FsRHRCLEVBa0RpQ0UsU0FsRGpDLEVBa0Q0QztBQUNwQyxXQUFLcGUsVUFBTCxDQUFnQnFlLGdCQUFoQixDQUFpQyxLQUFLM2xCLFFBQXRDO0FBQ0EsV0FBSzJPLElBQUwsR0FBWSxJQUFaO0FBQ0EsV0FBSzNPLFFBQUwsR0FBZ0IsSUFBaEI7QUFDSDtBQXRETDtBQUFBO0FBQUEsK0JBd0Rld1UsS0F4RGYsRUF3RHNCO0FBQ2QsVUFBSXhVLFFBQVEsR0FBR3dVLEtBQUssQ0FBQ0UsTUFBTixDQUFhVSxRQUE1QjtBQUNBLFVBQUkxRSxRQUFRLEdBQUc4RCxLQUFLLENBQUNFLE1BQU4sQ0FBYVEsTUFBNUI7QUFDQSxXQUFLdkcsSUFBTCxDQUFVa0IsTUFBVixDQUFpQmEsUUFBakI7QUFDSDtBQTVETDtBQUFBO0FBQUEsbUNBOERtQjtBQUNYLFVBQUkxUSxRQUFRLEdBQUd3VyxnREFBTyxDQUFDb1AsYUFBUixDQUFzQixLQUFLNWxCLFFBQTNCLENBQWY7QUFDQSxhQUFPO0FBQ0h2QyxZQUFJLEVBQUV1QyxRQUFRLENBQUN2QyxJQURaO0FBRUh5bUIsaUJBQVMsRUFBRWxrQixRQUFRLENBQUNoQyxJQUZqQjtBQUdIMFMsZ0JBQVEsRUFBRSxLQUFLL0IsSUFBTCxDQUFVa0IsTUFBVixFQUhQO0FBSUhzVSxnQkFBUSxFQUFFO0FBSlAsT0FBUDtBQU1IO0FBdEVMOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUVBLElBQU0wQixtQkFBbUIsR0FBRyxDQUN4QixDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFFBQXZCLEVBQWlDLFNBQWpDLEVBQTRDLHNEQUE1QyxDQUR3QixFQUV4QixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLFNBQWpCLEVBQTRCLE1BQTVCLEVBQW9DLDJJQUFwQyxDQUZ3QixFQUd4QixDQUFDLFVBQUQsRUFBYSxVQUFiLEVBQXlCLEVBQXpCLEVBQTZCLFFBQTdCLEVBQXVDLGtHQUF2QyxDQUh3QixFQUl4QjtBQUNBLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEJ6bEIsb0RBQVksQ0FBQ0MsSUFBekMsRUFBK0NELG9EQUEvQyxFQUE2RCx5RUFBN0QsQ0FMd0IsRUFNeEIsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixFQUF6QixFQUE2QixRQUE3QixFQUF1Qyw2RUFBdkMsQ0FOd0IsRUFPeEIsQ0FBQyxnQkFBRCxFQUFtQixpQkFBbkIsRUFBc0MsS0FBdEMsRUFBNkMsTUFBN0MsRUFBcUQsMEdBQXJELENBUHdCLEVBUXhCLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsRUFBdEIsRUFBMEIsUUFBMUIsRUFBb0MsNlhBQXBDLENBUndCLEVBU3hCLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIsS0FBNUIsRUFBbUMsTUFBbkMsRUFBMkMsK0RBQTNDLENBVHdCLEVBVXhCLENBQUMsa0JBQUQsRUFBcUIsb0JBQXJCLEVBQTJDLEtBQTNDLEVBQWtELE1BQWxELEVBQTBELG9GQUExRCxDQVZ3QixFQVd4QixDQUFDLGlCQUFELEVBQW9CLGtCQUFwQixFQUF3QyxLQUF4QyxFQUErQyxNQUEvQyxFQUF1RCw0RUFBdkQsQ0FYd0IsRUFZeEIsQ0FBQyxzQkFBRCxFQUF5Qix3QkFBekIsRUFBbUQsS0FBbkQsRUFBMEQsTUFBMUQsRUFBa0UsMk5BQWxFLENBWndCLEVBYXhCLENBQUMsbUJBQUQsRUFBc0IscUJBQXRCLEVBQTZDLEtBQTdDLEVBQW9ELE1BQXBELEVBQTRELDRIQUE1RCxDQWJ3QixFQWN4QixDQUFDLGFBQUQsRUFBZ0IsY0FBaEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MscUVBQS9DLENBZHdCLEVBZXhCLENBQUMsY0FBRCxFQUFpQixlQUFqQixFQUFrQyxLQUFsQyxFQUF5QyxNQUF6QyxFQUFpRCxxSEFBakQsQ0Fmd0IsRUFnQnhCLENBQUMsYUFBRCxFQUFnQixjQUFoQixFQUFnQyxLQUFoQyxFQUF1QyxNQUF2QyxFQUErQywyREFBL0MsQ0FoQndCLEVBaUJ4QixDQUFDLGlCQUFELEVBQW9CLG1CQUFwQixFQUF5QyxLQUF6QyxFQUFnRCxNQUFoRCxFQUF3RCwrS0FBeEQsQ0FqQndCLEVBa0J4QixDQUFDLGNBQUQsRUFBaUIsV0FBakIsRUFBOEIsS0FBOUIsRUFBcUMsTUFBckMsRUFBNkMsNkVBQTdDLENBbEJ3QixFQW1CeEIsQ0FBQyxjQUFELEVBQWlCLFlBQWpCLEVBQStCLElBQS9CLEVBQXFDLE1BQXJDLEVBQTZDLDBHQUE3QyxDQW5Cd0IsRUFvQnhCLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEIsS0FBMUIsRUFBaUMsTUFBakMsRUFBeUMsd0xBQXpDLENBcEJ3QixFQXFCeEIsQ0FBQyxpQkFBRCxFQUFvQixrQkFBcEIsRUFBd0MsS0FBeEMsRUFBK0MsTUFBL0MsRUFBdUQsNEhBQXZELENBckJ3QixFQXNCeEIsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDLEVBQStDLDJHQUEvQyxDQXRCd0IsRUF1QnhCO0FBQ0EsQ0FBQyxnQkFBRCxFQUFtQixpQkFBbkIsRUFBc0MsS0FBdEMsRUFBNkMsTUFBN0MsRUFBcUQsaUdBQXJELENBeEJ3QixFQXlCeEIsQ0FBQyxXQUFELEVBQWMsWUFBZCxFQUE0QixJQUE1QixFQUFrQyxNQUFsQyxFQUEwQyxnRUFBMUMsQ0F6QndCLEVBMEJ4QixDQUFDLGtCQUFELEVBQXFCLG9CQUFyQixFQUEyQyxLQUEzQyxFQUFrRCxNQUFsRCxFQUEwRCw2SEFBMUQsQ0ExQndCLEVBMkJ4QixDQUFDLGFBQUQsRUFBZ0IsY0FBaEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsaURBQS9DLENBM0J3QixFQTRCeEIsQ0FBQyxpQkFBRCxFQUFvQixtQkFBcEIsRUFBeUMsS0FBekMsRUFBZ0QsTUFBaEQsRUFBd0QsNERBQXhELENBNUJ3QixFQTZCeEIsQ0FBQyxTQUFELEVBQVksVUFBWixFQUF3QixLQUF4QixFQUErQixNQUEvQixFQUF1Qyw4REFBdkMsQ0E3QndCLEVBOEJ4QixDQUFDLGNBQUQsRUFBaUIsZUFBakIsRUFBa0MsS0FBbEMsRUFBeUMsTUFBekMsRUFBaUQsbUVBQWpELENBOUJ3QixFQStCeEIsQ0FBQywwQkFBRCxFQUE2Qiw2QkFBN0IsRUFBNEQsS0FBNUQsRUFBbUUsTUFBbkUsRUFBMkUsa0VBQTNFLENBL0J3QixFQWdDeEI7QUFDQSxDQUFDLHNCQUFELEVBQXlCLHdCQUF6QixFQUFtRCxLQUFuRCxFQUEwRCxNQUExRCxFQUFrRSxpSUFBbEUsQ0FqQ3dCLEVBa0N4QixDQUFDLG9CQUFELEVBQXVCLHNCQUF2QixFQUErQyxLQUEvQyxFQUFzRCxNQUF0RCxFQUE4RCwyREFBOUQsQ0FsQ3dCLEVBbUN4QixDQUFDLGlCQUFELEVBQW9CLG1CQUFwQixFQUF5QyxLQUF6QyxFQUFnRCxNQUFoRCxFQUF3RCxpREFBeEQsQ0FuQ3dCLEVBb0N4QixDQUFDLGFBQUQsRUFBZ0IsY0FBaEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsNERBQS9DLENBcEN3QixFQXFDeEIsQ0FBQyxVQUFELEVBQWEsV0FBYixFQUEwQixLQUExQixFQUFpQyxNQUFqQyxFQUF5Qyw0REFBekMsQ0FyQ3dCLEVBc0N4QixDQUFDLGNBQUQsRUFBaUIsZUFBakIsRUFBa0MsRUFBbEMsRUFBc0MsUUFBdEMsRUFBZ0QsZ0hBQWhELENBdEN3QixDQUE1QjtBQXlDTyxJQUFJbkMsYUFBYSxHQUFHO0FBQ3ZCQyxTQUFPLEVBQUUsU0FEYztBQUV2QjRuQixNQUFJLEVBQUUsTUFGaUI7QUFHdkJDLE1BQUksRUFBRSxNQUhpQjtBQUl2QkMsU0FBTyxFQUFFO0FBSmMsQ0FBcEI7O0FBT1AsU0FBU0MsZ0JBQVQsQ0FBMEJ4b0IsSUFBMUIsRUFBZ0M7QUFDNUIsT0FBSyxJQUFJNGdCLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR3dILG1CQUFtQixDQUFDalgsTUFBdEMsRUFBOEN5UCxDQUFDLEVBQS9DLEVBQW1EO0FBQy9DLFFBQUl3SCxtQkFBbUIsQ0FBQ3hILENBQUQsQ0FBbkIsQ0FBdUIsQ0FBdkIsTUFBOEI1Z0IsSUFBbEMsRUFBd0M7QUFDcEMsYUFBT29vQixtQkFBbUIsQ0FBQ3hILENBQUQsQ0FBbkIsQ0FBdUIsQ0FBdkIsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsU0FBTyxtQ0FBUDtBQUNIOztBQUVELFNBQVM2SCxnQkFBVCxDQUEwQnpvQixJQUExQixFQUFnQzBvQixJQUFoQyxFQUFzQ0MsSUFBdEMsRUFBNEM7QUFDeEMsc0tBQzRFQSxJQUQ1RSwrRkFFMkVBLElBRjNFLHdEQUdrQ0QsSUFIbEMsNEhBSTRGMW9CLElBSjVGO0FBTUg7O0FBRUQsSUFBTTRvQiwyQ0FBMkMsR0FBR1IsbUJBQW1CLENBQ25FO0FBRG1FLENBRWxFUyxNQUYrQyxDQUV4QyxVQUFDQyxPQUFEO0FBQUEsU0FBYUEsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLE1BQTVCO0FBQUEsQ0FGd0MsRUFHL0NoVyxHQUgrQyxDQUczQyxVQUFDZ1csT0FBRCxFQUFhO0FBQ2QsTUFBSUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdwSSxLQUFYLENBQWlCLEdBQWpCLEVBQXNCNU4sR0FBdEIsQ0FBMEIsVUFBQWtXLElBQUk7QUFBQSxXQUFHQSxJQUFJLENBQUN4SSxNQUFMLENBQVksQ0FBWixFQUFleUksV0FBZixLQUE2QkQsSUFBSSxDQUFDdlcsS0FBTCxDQUFXLENBQVgsQ0FBaEM7QUFBQSxHQUE5QixFQUE4RTBULElBQTlFLENBQW1GLEdBQW5GLENBQWpCO0FBQ0EsdUxBR2dFMkMsT0FBTyxDQUFDLENBQUQsQ0FIdkUsZ0JBRytFQyxVQUgvRSwyTkFPbUZELE9BQU8sQ0FBQyxDQUFELENBUDFGLDhFQVFzREEsT0FBTyxDQUFDLENBQUQsQ0FSN0QsOExBYWNBLE9BQU8sQ0FBQyxDQUFELENBYnJCO0FBa0JILENBdkIrQyxFQXVCN0MzQyxJQXZCNkMsQ0F1QnhDLE1BdkJ3QyxDQUFwRDtBQXlCTyxJQUFNK0MsK0JBQStCLG0wSkF1R3RCVCxnQkFBZ0IsQ0FBQyxRQUFELEVBQVcsVUFBWCxFQUF1QjlsQixvREFBWSxDQUFDd21CLEtBQXBDLENBdkdNLG1DQXdHdEJWLGdCQUFnQixDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCOWxCLG9EQUFZLENBQUN5bUIsS0FBbEMsQ0F4R00sbUNBeUd0QlgsZ0JBQWdCLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUI5bEIsb0RBQVksQ0FBQ0MsSUFBcEMsQ0F6R00sMExBOEd0QjRsQixnQkFBZ0IsQ0FBQyxXQUFELENBOUdNLHE0Q0F1SXRCQSxnQkFBZ0IsQ0FBQyxVQUFELENBdklNLG1oQkFrSnRCQSxnQkFBZ0IsQ0FBQyxVQUFELENBbEpNLDhoQkE2SnRCQSxnQkFBZ0IsQ0FBQyxjQUFELENBN0pNLHc2QkErS3RCQSxnQkFBZ0IsQ0FBQyxTQUFELENBL0tNLHN3QkErTHRCQSxnQkFBZ0IsQ0FBQyxNQUFELENBL0xNLDhmQTBNdEJBLGdCQUFnQixDQUFDLFFBQUQsQ0ExTU0sK0ZBK01sQ0ksMkNBL01rQyxzQ0FBckM7QUFxTkEsU0FBU1Msc0JBQVQsQ0FBZ0MxcEIsS0FBaEMsRUFBdUM7QUFDMUMsTUFBSWlDLFFBQVEsR0FBRyxFQUFmO0FBQ0F3bUIscUJBQW1CLENBQUN0RyxPQUFwQixDQUE0QixVQUFBZ0gsT0FBTyxFQUFJO0FBQ25DLFFBQUlRLFVBQVUsR0FBR1IsT0FBTyxDQUFDLENBQUQsQ0FBeEI7QUFBQSxRQUE2QlMsVUFBVSxHQUFHVCxPQUFPLENBQUMsQ0FBRCxDQUFqRDtBQUFBLFFBQXNEenBCLFlBQVksR0FBR3lwQixPQUFPLENBQUMsQ0FBRCxDQUE1RTtBQUNBLFFBQUk3SCxLQUFLLEdBQUd0aEIsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMG5CLFVBQTFCLEdBQVosQ0FGbUMsQ0FHbkM7O0FBQ0EsUUFBSXJJLEtBQUssS0FBSzVoQixZQUFkLEVBQTRCO0FBQ3hCdUMsY0FBUSxDQUFDMm5CLFVBQUQsQ0FBUixHQUF1QnRJLEtBQXZCO0FBQ0g7QUFDSixHQVBEO0FBUUEsU0FBT3pQLElBQUksQ0FBQ0MsU0FBTCxDQUFlN1AsUUFBZixDQUFQO0FBQ0g7QUFFTSxTQUFTZ0osc0JBQVQsQ0FBZ0NqTCxLQUFoQyxFQUF1Q2lDLFFBQXZDLEVBQWlEO0FBQ3BELE1BQUlBLFFBQUosRUFBYztBQUNWQSxZQUFRLEdBQUc0UCxJQUFJLENBQUNnRyxLQUFMLENBQVc1VixRQUFYLENBQVg7QUFDQXdtQix1QkFBbUIsQ0FBQ3RHLE9BQXBCLENBQTRCLFVBQUFnSCxPQUFPLEVBQUk7QUFDbkMsVUFBSVEsVUFBVSxHQUFHUixPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFVBQTZCUyxVQUFVLEdBQUdULE9BQU8sQ0FBQyxDQUFELENBQWpEOztBQUNBLFVBQUlTLFVBQVUsSUFBSTNuQixRQUFsQixFQUE0QjtBQUN4QmpDLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjBuQixVQUExQixFQUFzQzFuQixRQUFRLENBQUMybkIsVUFBRCxDQUE5QztBQUNILE9BRkQsTUFFTztBQUNINXBCLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjBuQixVQUExQixFQUFzQ1IsT0FBTyxDQUFDLENBQUQsQ0FBN0M7QUFDSDtBQUNKLEtBUEQ7O0FBU0EsUUFBSWxuQixRQUFRLENBQUM0bkIsVUFBYixFQUF5QjtBQUNyQjdwQixXQUFLLENBQUMyQyxPQUFOLENBQWNJLFVBQWQsQ0FBeUJkLFFBQVEsQ0FBQzRuQixVQUFsQztBQUNIO0FBQ0o7QUFDSjtBQUVNLFNBQVMzbkIsMkJBQVQsQ0FBcUN4RCxhQUFyQyxFQUFvRDtBQUN2RCxNQUFJdUQsUUFBUSxHQUFHLEVBQWY7QUFDQXdtQixxQkFBbUIsQ0FBQ3RHLE9BQXBCLENBQTRCLFVBQUFnSCxPQUFPLEVBQUk7QUFDbkMsUUFBSVEsVUFBVSxHQUFHUixPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFFBQTZCUyxVQUFVLEdBQUdULE9BQU8sQ0FBQyxDQUFELENBQWpEO0FBQUEsUUFBc0R6cEIsWUFBWSxHQUFHeXBCLE9BQU8sQ0FBQyxDQUFELENBQTVFO0FBQUEsUUFDSVcsU0FBUyxHQUFHWCxPQUFPLENBQUMsQ0FBRCxDQUR2Qjs7QUFFQSxRQUFJenFCLGFBQWEsQ0FBQyx5QkFBdUJrckIsVUFBeEIsQ0FBYixLQUFxRDlxQixTQUF6RCxFQUFvRTtBQUNoRW1ELGNBQVEsQ0FBQzBuQixVQUFELENBQVIsR0FBdUJ4cEIsRUFBRSxDQUFDQyxVQUFILENBQWNWLFlBQWQsQ0FBdkI7QUFDSCxLQUZELE1BRU87QUFDSCxVQUFJcXFCLFdBQVcsR0FBR3JyQixhQUFhLENBQUMseUJBQXVCa3JCLFVBQXhCLENBQS9COztBQUNBLFVBQUlFLFNBQVMsS0FBSyxNQUFsQixFQUEwQjtBQUN0QkMsbUJBQVcsR0FBR0EsV0FBVyxDQUFDdGMsV0FBWixPQUE4QixNQUE1QztBQUNIOztBQUNEeEwsY0FBUSxDQUFDMG5CLFVBQUQsQ0FBUixHQUF1QnhwQixFQUFFLENBQUNDLFVBQUgsQ0FBYzJwQixXQUFkLENBQXZCO0FBQ0g7QUFDSixHQVpEO0FBY0EsU0FBTzluQixRQUFQO0FBQ0g7O0lBRUsrbkIsc0I7Ozs7O0FBQ0Ysa0NBQVl0UixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBS29MLEtBQUwsR0FBYSxLQUFiO0FBRm1CO0FBR3RCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsd0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYixDQUYwQixDQUcxQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFLQyxlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0JyVyxJQUFsQixDQUF1QixJQUF2QixDQUF2QixDQVAwQixDQVMxQjtBQUNIOzs7aUNBRVlzVyxXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWIsQ0FEWSxDQUVaOztBQUVBLGFBQUtBLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZN1MsSyxFQUFPO0FBQ2hCLFdBQUs2UyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYixDQURZLENBRVo7QUFDQTs7QUFDQSxhQUFLQSxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTlCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBV0gsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQTVDZ0NSLCtEOztBQStDOUIsSUFBTXlDLGtCQUFrQixHQUFHO0FBQzlCaHFCLE1BQUksRUFBRSxxQkFEd0I7QUFFOUJpcUIsWUFBVSxFQUFFLENBQUMsOEJBQUQsQ0FGa0I7QUFHOUJDLGFBQVcsRUFBRVAsc0JBSGlCO0FBSTlCUSxVQUFRLEVBQUVqQjtBQUpvQixDQUEzQixDOzs7Ozs7Ozs7Ozs7O0FDbFpQO0FBQUE7QUFBTyxJQUFNa0IsY0FBYyxnNUNBQXBCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRlA7QUFDQTtBQUVPLElBQU1DLGlCQUFpQiwrL0xBQXZCOztJQThHREMsZTs7Ozs7QUFDRiwyQkFBWWpTLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTW5HLElBQU4sRUFBWW1HLEdBQVo7QUFFQSxVQUFLK0wsbUJBQUwsR0FBMkIsTUFBSy9MLEdBQUwsQ0FBU3BQLElBQVQsQ0FBYyxvQ0FBZCxDQUEzQjtBQUNBLFVBQUtvYixzQkFBTCxHQUE4QixNQUFLaE0sR0FBTCxDQUFTcFAsSUFBVCxDQUFjLHlDQUFkLENBQTlCO0FBQ0EsVUFBS3FiLGlCQUFMLEdBQXlCLE1BQUtqTSxHQUFMLENBQVNwUCxJQUFULENBQWMsd0NBQWQsQ0FBekI7O0FBRUEsVUFBS21iLG1CQUFMLENBQXlCeEYsRUFBekIsQ0FBNEIsUUFBNUIsRUFBc0MsVUFBQ2hPLEtBQUQsRUFBVztBQUM3QyxZQUFLMFQsaUJBQUwsQ0FBdUI1UyxHQUF2QixDQUEyQmQsS0FBSyxDQUFDRSxNQUFOLENBQWFwRyxLQUFiLENBQW1CLENBQW5CLEVBQXNCN1EsSUFBakQ7QUFDSCxLQUZEOztBQVBtQjtBQVV0Qjs7OzswQkFFSzhuQixXLEVBQWFDLFMsRUFBVztBQUMxQixpRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBRUEsVUFBSTdqQixhQUFhLEdBQUcsS0FBS21VLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QjRCLGFBQXhCLEVBQXBCOztBQUNBLFVBQUlBLGFBQWEsS0FBSyxJQUF0QixFQUE0QjtBQUN4QixhQUFLc1IsWUFBTDtBQUNIOztBQUVELFdBQUtrVixtQkFBTCxHQUEyQixLQUFLeFosSUFBTCxDQUFVa0IsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQVIwQixDQVUxQjtBQUNBOztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7Ozs7OztBQU9IOzs7bUNBRWM7QUFBQTs7QUFDWCxXQUFLNEUsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJoRCxpQkFBNUIsQ0FBOEMsVUFBQzZPLFFBQUQsRUFBYztBQUN4RCxZQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLGdCQUFJLENBQUNtSSxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0I0QixhQUF4QixDQUFzQ3dRLFFBQVEsQ0FBQzdELEtBQS9DOztBQUNBLGdCQUFJLENBQUN3SCxJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NzQixlQUFoQyxDQUFnRHVKLFFBQVEsQ0FBQzdELEtBQXpELEVBRmtCLENBR2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNILFNBYkQsTUFhTztBQUNILGdCQUFJLENBQUN3SCxJQUFMLENBQVV6UCxVQUFWLENBQXFCK2hCLE9BQXJCLENBQTZCdEYsNEJBQTdCLENBQTBEM1EsUUFBUSxDQUFDak4sT0FBbkU7QUFDSDtBQUNKLE9BakJEO0FBa0JIOzs7aUNBRVlzaUIsVyxFQUFhLENBRXpCOzs7aUNBRVloVCxLLEVBQU87QUFDaEI7Ozs7OztBQU1IOzs7MENBRXFCcEIsUyxFQUFXO0FBQzdCLGNBQVFBLFNBQVI7QUFDSSxhQUFLLFlBQUw7QUFDSSxpQkFBTyxLQUFLMEMsSUFBTCxDQUFVMVksS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCc0IsRUFBM0IsRUFBUDs7QUFDSixhQUFLLFlBQUw7QUFDSSxpQkFBTyxLQUFLd1ksSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUIsRUFBM0IsRUFBUDs7QUFDSixhQUFLLFFBQUw7QUFDSSxpQkFBTyxLQUFLd1ksSUFBTCxDQUFVMVksS0FBVixDQUFnQmlyQixNQUFoQixDQUF1Qi9xQixFQUF2QixFQUFQOztBQUNKLGFBQUssTUFBTDtBQUNJLGlCQUFPLEtBQUt3WSxJQUFMLENBQVUxWSxLQUFWLENBQWdCQyxJQUFoQixDQUFxQkMsRUFBckIsRUFBUDs7QUFDSjtBQUNJLGlCQUFPLElBQVA7QUFWUjtBQVlIOzs7K0JBRVVrWCxLLEVBQU87QUFBQTs7QUFDZCxXQUFLc0IsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1QyxVQUE1QixDQUNJLEtBQUt1a0Isc0JBQUwsQ0FBNEIzUyxHQUE1QixFQURKLEVBRUksS0FBS2dULHFCQUFMLENBQTJCLEtBQUtMLHNCQUFMLENBQTRCM1MsR0FBNUIsRUFBM0IsQ0FGSixFQUdJLEtBQUs0UyxpQkFBTCxDQUF1QjVTLEdBQXZCLEVBSEosRUFJSSxLQUFLMFMsbUJBQUwsQ0FBeUIsQ0FBekIsRUFBNEIxWixLQUE1QixDQUFrQyxDQUFsQyxDQUpKLEVBS0ksVUFBQzZELFFBQUQsRUFBYztBQUNWLFlBQUlBLFFBQVEsQ0FBQ3hFLE9BQWIsRUFBc0I7QUFDbEIsZ0JBQUksQ0FBQ3NGLFlBQUw7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBSSxDQUFDNkMsSUFBTCxDQUFVelAsVUFBVixDQUFxQitoQixPQUFyQixDQUE2QnJGLG9CQUE3QixDQUFrRDVRLFFBQVEsQ0FBQ2pOLE9BQTNEO0FBQ0g7QUFDSixPQVhMO0FBYUg7OzsrQkFFVThOLFEsRUFBVTtBQUFBOztBQUFBLHFDQUNPQSxRQURQO0FBQUEsVUFDVmhULFFBRFU7QUFBQSxVQUNBakMsR0FEQTs7QUFFakIsVUFBTXdxQixXQUFXLEdBQUcsSUFBSTNELEdBQUosQ0FBUTdtQixHQUFSLEVBQWF1bUIsTUFBTSxDQUFDa0UsUUFBUCxDQUFnQi9QLE1BQTdCLEVBQXFDZ1EsWUFBekQ7QUFDQSxXQUFLM1MsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1QyxVQUE1QixDQUNJNmtCLFdBQVcsQ0FBQ3JyQixHQUFaLENBQWdCLFdBQWhCLENBREosRUFFSXFyQixXQUFXLENBQUNyckIsR0FBWixDQUFnQixXQUFoQixDQUZKLEVBR0k4QyxRQUhKLEVBSUksRUFKSixFQUtJLFVBQUNtUyxRQUFELEVBQWM7QUFDVixZQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLGdCQUFJLENBQUNzRixZQUFMO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQUksQ0FBQzZDLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUIraEIsT0FBckIsQ0FBNkJsRixtQkFBN0IsQ0FBaUQvUSxRQUFRLENBQUNqTixPQUExRDtBQUNIO0FBQ0osT0FYTCxFQVlJLElBWko7QUFjSDs7OytCQUNVOE4sUSxFQUFVO0FBQUE7O0FBQUEsc0NBQ09BLFFBRFA7QUFBQSxVQUNWaFQsUUFEVTtBQUFBLFVBQ0FqQyxHQURBOztBQUVqQixVQUFNd3FCLFdBQVcsR0FBRyxJQUFJM0QsR0FBSixDQUFRN21CLEdBQVIsRUFBYXVtQixNQUFNLENBQUNrRSxRQUFQLENBQWdCL1AsTUFBN0IsRUFBcUNnUSxZQUF6RDtBQUNBLFVBQU1sRCxXQUFXLEdBQUdoTyxNQUFNLENBQUMsdUNBQUQsRUFBMEN2WCxRQUExQyxDQUExQjs7QUFDQSxVQUFJdWxCLFdBQUosRUFBaUI7QUFDYixhQUFLelAsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEIxQyxVQUE1QixDQUNJMmtCLFdBQVcsQ0FBQ3JyQixHQUFaLENBQWdCLFdBQWhCLENBREosRUFFSXFyQixXQUFXLENBQUNyckIsR0FBWixDQUFnQixXQUFoQixDQUZKLEVBR0k4QyxRQUhKLEVBSUl1bEIsV0FKSixFQUtJLFVBQUNwVCxRQUFELEVBQWM7QUFDVixjQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLGtCQUFJLENBQUNzRixZQUFMO0FBQ0gsV0FGRCxNQUVPO0FBQ0gsa0JBQUksQ0FBQzZDLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUIraEIsT0FBckIsQ0FBNkJuRixtQkFBN0IsQ0FBaUQ5USxRQUFRLENBQUNqTixPQUExRDtBQUNIO0FBQ0osU0FYTDtBQWFIO0FBQ0o7Ozt5QkFFSXFnQixXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3lDLG1CQUFMLENBQXlCTyxPQUF6Qjs7QUFDQSxnRkFBV25ELFdBQVgsRUFBd0JDLFNBQXhCLEVBSG9DLENBSXBDO0FBQ0E7QUFDQTs7QUFDSDs7OztFQTVLeUJSLCtEOztBQStLdkIsSUFBTTJELFdBQVcsR0FBRztBQUN2QmxyQixNQUFJLEVBQUUsT0FEaUI7QUFFdkJpcUIsWUFBVSxFQUFFLENBQUMsaUJBQUQsQ0FGVztBQUd2QkMsYUFBVyxFQUFFSSxlQUhVO0FBSXZCSCxVQUFRLEVBQUVFO0FBSmEsQ0FBcEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hTUDtBQUNBO0FBRU8sSUFBTWMsZ0JBQWdCLG1CQUN2QmYsOERBRHVCLDRGQUF0Qjs7SUFPRGdCLGM7Ozs7O0FBQ0YsMEJBQVkvUyxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBSzFLLFVBQUwsR0FBa0J1WCxVQUFVLENBQUNDLFlBQVgsQ0FBd0I5TSxHQUFHLENBQUNwUCxJQUFKLENBQVMsc0JBQVQsRUFBaUMsQ0FBakMsQ0FBeEIsRUFBNkQ7QUFDM0VtYyw2QkFBdUIsRUFBRSxJQURrRDtBQUUzRUMsaUJBQVcsRUFBRSxJQUY4RDtBQUczRUMscUJBQWUsRUFBRSxDQUgwRDtBQUkzRUMsZ0JBQVUsRUFBRSxDQUorRDtBQUszRUMsYUFBTyxFQUFFLENBTGtFO0FBTTNFQyxvQkFBYyxFQUFFLEtBTjJEO0FBTzNFakQsVUFBSSxFQUFFLE1BUHFFO0FBUTNFa0QsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUI4WCxjQUFFLENBQUMvWCxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIK1gsY0FBRSxDQUFDeHBCLE9BQUgsQ0FBV3FFLEtBQVgsQ0FBaUJvbEIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDL1gsU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQytYLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVJnRSxLQUE3RCxDQUFsQjtBQXVCQSxVQUFLNFYsS0FBTCxHQUFhLEtBQWI7QUF6Qm1CO0FBMEJ0Qjs7OzswQkFFSzlCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLGdGQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNkIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLclYsWUFBTCxDQUFrQixLQUFLckQsSUFBTCxDQUFVa0IsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLc1ksbUJBQUwsR0FBMkIsS0FBS3haLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS29XLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnJXLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBS0ssVUFBTCxDQUFnQmlSLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLEtBQUs4RSxlQUFsQzs7QUFDQSxVQUFJOUIsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F0WSxrQkFBVSxDQUFDLEtBQUtxRSxVQUFMLENBQWdCNUksT0FBaEIsQ0FBd0J1SSxJQUF4QixDQUE2QixLQUFLSyxVQUFsQyxDQUFELEVBQWdELENBQWhELENBQVY7QUFDSCxPQVp5QixDQWExQjs7O0FBQ0EsV0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MrVCxXQUFXLENBQUN0VixVQUFaLENBQXVCLEdBQXZCLEtBQStCLENBQUMsS0FBSzZGLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBdEU7QUFFSDs7O2lDQUVZdW5CLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUs5VixVQUFMLENBQWdCa1ksUUFBaEIsQ0FBeUJqQyxXQUF6QjtBQUNBLGFBQUtqVyxVQUFMLENBQWdCNUksT0FBaEI7QUFDQSxhQUFLMGUsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVk3UyxLLEVBQU87QUFDaEIsV0FBSzZTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFZLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUIsS0FBSzBCLFVBQUwsQ0FBZ0JtWSxRQUFoQixFQUFqQjtBQUNBLGFBQUtyQyxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTlCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLeUMsbUJBQUwsQ0FBeUJPLE9BQXpCO0FBQ0EsV0FBS25YLFVBQUwsQ0FBZ0JvWSxHQUFoQixDQUFvQixRQUFwQixFQUE4QixLQUFLckMsZUFBbkM7QUFDQSxXQUFLL1YsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEM7O0FBQ0EsK0VBQVcrVCxXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBeEV3QlIsK0Q7O0FBMkV0QixJQUFNNEUsVUFBVSxHQUFHO0FBQ3RCbnNCLE1BQUksRUFBRSxNQURnQjtBQUV0QmlxQixZQUFVLEVBQUUsQ0FBQyxPQUFELENBRlU7QUFHdEJDLGFBQVcsRUFBRWtCLGNBSFM7QUFJdEJqQixVQUFRLEVBQUVnQjtBQUpZLENBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRlA7QUFDQTtBQUVPLElBQU1pQixvQkFBb0IsbUJBQzNCaEMsOERBRDJCLHdFQUExQjs7SUFNRGlDLGtCOzs7OztBQUNGLDhCQUFZaFUsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNbkcsSUFBTixFQUFZbUcsR0FBWjtBQUNBLFVBQUs4TixHQUFMLEdBQVcsSUFBSS9ULE9BQUosQ0FBWTtBQUNuQmdVLGFBQU8sRUFBRS9OLEdBQUcsQ0FBQ3BQLElBQUosQ0FBUywwQkFBVCxFQUFxQyxDQUFyQyxDQURVO0FBRW5Cb2QsNkJBQXVCLEVBQUUsS0FGTjtBQUduQkMsZUFBUyxFQUFFLElBSFE7QUFJbkJDLGVBQVMsRUFBRSxPQUpRO0FBS25CO0FBQ0E7QUFDQUMscUJBQWUsRUFBRTtBQUNiQyw4QkFBc0IsRUFBRTtBQURYLE9BUEU7QUFVbkJoQixvQkFBYyxFQUFFLEtBVkc7QUFXbkJELGFBQU8sRUFBRTtBQVhVLEtBQVosQ0FBWDtBQWFBLFVBQUsvQixLQUFMLEdBQWEsS0FBYjtBQWZtQjtBQWdCdEI7Ozs7MEJBRUs5QixXLEVBQWFDLFMsRUFBVztBQUMxQixvRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzZCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS3JWLFlBQUwsQ0FBa0IsS0FBS3JELElBQUwsQ0FBVWtCLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBS3NZLG1CQUFMLEdBQTJCLEtBQUt4WixJQUFMLENBQVVrQixNQUFWLENBQWlCaUgsU0FBakIsQ0FBMkIsS0FBSzlFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUtvVyxlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0JyVyxJQUFsQixDQUF1QixJQUF2QixDQUF2QjtBQUNBLFdBQUs2WSxHQUFMLENBQVNPLFVBQVQsQ0FBb0I5SCxFQUFwQixDQUF1QixRQUF2QixFQUFpQyxLQUFLOEUsZUFBdEM7O0FBQ0EsVUFBSTlCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBdFksa0JBQVUsQ0FBQyxLQUFLNmMsR0FBTCxDQUFTTyxVQUFULENBQW9CM2hCLE9BQXBCLENBQTRCdUksSUFBNUIsQ0FBaUMsS0FBSzZZLEdBQUwsQ0FBU08sVUFBMUMsQ0FBRCxFQUF3RCxDQUF4RCxDQUFWO0FBQ0g7QUFDSjs7O2lDQUVZOUMsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzBDLEdBQUwsQ0FBU3JMLEtBQVQsQ0FBZThJLFdBQWY7QUFDQSxhQUFLdUMsR0FBTCxDQUFTTyxVQUFULENBQW9CM2hCLE9BQXBCO0FBQ0EsYUFBSzBlLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZN1MsSyxFQUFPO0FBQ2hCLFdBQUs2UyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUsxWSxJQUFMLENBQVVrQixNQUFWLENBQWlCLEtBQUtrYSxHQUFMLENBQVNyTCxLQUFULEVBQWpCO0FBQ0EsYUFBSzJJLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUt5QyxtQkFBTCxDQUF5Qk8sT0FBekI7QUFDQSxXQUFLcUIsR0FBTCxDQUFTTyxVQUFULENBQW9CWCxHQUFwQixDQUF3QixRQUF4QixFQUFrQyxLQUFLckMsZUFBdkM7O0FBQ0EsbUZBQVcvQixXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBMUQ0QlIsK0Q7O0FBNkQxQixJQUFNdUYsY0FBYyxHQUFHO0FBQzFCOXNCLE1BQUksRUFBRSxVQURvQjtBQUUxQmlxQixZQUFVLEVBQUUsQ0FBQyxLQUFELENBRmM7QUFHMUJDLGFBQVcsRUFBRW1DLGtCQUhhO0FBSTFCbEMsVUFBUSxFQUFFaUM7QUFKZ0IsQ0FBdkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEVQOzs7Ozs7QUFNQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVPLElBQUl6cEIsWUFBWSxHQUFHO0FBQ3RCd21CLE9BQUssRUFBRSxPQURlO0FBRXRCQyxPQUFLLEVBQUUsT0FGZTtBQUd0QnhtQixNQUFJLEVBQUU7QUFIZ0IsQ0FBbkI7O0FBTVAsU0FBU21xQixPQUFULENBQWlCL3NCLElBQWpCLEVBQXVCMG9CLElBQXZCLEVBQTZCQyxJQUE3QixFQUFtQztBQUMvQiwySkFDaUVBLElBRGpFLDhGQUUwRUEsSUFGMUUsd0RBR2tDRCxJQUhsQyxzSEFJc0Yxb0IsSUFKdEY7QUFNSDs7QUFFTSxJQUFNZ3RCLGtCQUFrQiw4dkJBZWpCRCxPQUFPLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUJwcUIsWUFBWSxDQUFDd21CLEtBQXBDLENBZlUsMkJBZ0JqQjRELE9BQU8sQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQnBxQixZQUFZLENBQUN5bUIsS0FBbEMsQ0FoQlUsMkJBaUJqQjJELE9BQU8sQ0FBQyxNQUFELEVBQVMsWUFBVCxFQUF1QnBxQixZQUFZLENBQUNDLElBQXBDLENBakJVLDZtS0F5SHpCcXFCLDZEQXpIeUIsMEhBQXhCOztBQW1JUCxTQUFTQyxvQkFBVCxDQUE4QnByQixJQUE5QixFQUFvQztBQUNoQyxNQUFJcXJCLEtBQUssR0FBRzNiLElBQUksQ0FBQ2dHLEtBQUwsQ0FBVzFWLElBQVgsQ0FBWjs7QUFDQSxNQUFJc3JCLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVNDLElBQVQsRUFBZTtBQUMxQixRQUFJQSxJQUFJLENBQUNDLFNBQUwsS0FBbUIsTUFBdkIsRUFBK0I7QUFDM0IsYUFBT0QsSUFBSSxDQUFDRSxNQUFMLENBQVlwYyxNQUFaLEdBQXFCLENBQXJCLElBQ0gsQ0FBQ2tjLElBQUksQ0FBQ0UsTUFBTCxDQUFZLENBQVosRUFBZS9hLFVBQWYsQ0FBMEIsR0FBMUIsQ0FETDtBQUVILEtBSEQsTUFHTztBQUNILGFBQU82YSxJQUFJLENBQUNDLFNBQUwsS0FBbUIsVUFBbkIsSUFDSEQsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLEtBRHZCO0FBRUg7QUFDSixHQVJEOztBQVNBLE1BQUlFLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVNILElBQVQsRUFBZTtBQUM1QixRQUFJQSxJQUFJLENBQUNDLFNBQUwsS0FBbUIsTUFBdkIsRUFBK0I7QUFDM0IsYUFBT0QsSUFBSSxDQUFDRSxNQUFMLENBQVlwSCxJQUFaLENBQWlCLElBQWpCLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSWtILElBQUksQ0FBQ0MsU0FBTCxLQUFtQixVQUFuQixJQUNQRCxJQUFJLENBQUNDLFNBQUwsS0FBbUIsS0FEaEIsRUFDdUI7QUFDMUIsYUFBTyxRQUFNRCxJQUFJLENBQUNFLE1BQUwsQ0FBWXBILElBQVosQ0FBaUIsSUFBakIsQ0FBTixHQUE2QixLQUFwQztBQUNIO0FBQ0osR0FQRDs7QUFRQSxTQUFPZ0gsS0FBSyxDQUFDTSxLQUFOLENBQVk1RSxNQUFaLENBQW1CdUUsUUFBbkIsRUFBNkJ0YSxHQUE3QixDQUFpQzBhLFVBQWpDLEVBQTZDckgsSUFBN0MsQ0FBa0QsSUFBbEQsQ0FBUDtBQUNIOztJQUVLdUgsZ0I7Ozs7O0FBQ0YsNEJBQVlyVixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFHLENBQUNwUCxJQUFKLENBQVMsNkJBQVQsQ0FBWjtBQUNBdWUsV0FBTyxDQUFDQyxrQkFBUixDQUEyQnZWLElBQUksQ0FBQzFZLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUI2SixTQUF6QixDQUFtQyxDQUFuQyxDQUEzQjtBQUNBLFVBQUsrQyxFQUFMLEdBQVUsSUFBSTRpQixXQUFKLENBQWdCO0FBQ3RCLG1CQUFhLE1BQUtyUCxHQUFMLENBQVMsQ0FBVCxDQURTO0FBRXRCLGFBQU9uRyxJQUFJLENBQUN6UCxVQUFMLENBQWdCc0UsTUFBaEIsQ0FBdUJtSixHQUF2QixDQUEyQjVDLElBQTNCLENBQWdDNEUsSUFBSSxDQUFDelAsVUFBTCxDQUFnQnNFLE1BQWhELENBRmU7QUFHdEIsb0JBQWMsSUFIUTtBQUl0QiwwQkFBb0JtTCxJQUFJLENBQUMxWSxLQUFMLENBQVd0QixhQUFYLENBQXlCMkosV0FKdkI7QUFLdEIsaUJBQVdxUSxJQUFJLENBQUMxWSxLQUFMLENBQVdyQixVQUFYLENBQXNCc0QsUUFBdEIsQ0FBK0Jrc0IsT0FBL0IsRUFMVztBQU10QixtQkFBYSxJQU5TO0FBT3RCQyx1QkFBaUIsRUFBRSwyQkFBQ0MsTUFBRCxFQUFZO0FBQzNCLGVBQU9BLE1BQVA7QUFDSCxPQVRxQjtBQVV0QkMscUJBQWUsRUFBRSx5QkFBQ3RILElBQUQsRUFBVTtBQUN2QjtBQUNBLGVBQU8sSUFBSWhKLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVzUSxNQUFWLEVBQXFCO0FBQ3BDLGNBQU1DLFlBQVksR0FBRzlWLElBQUksQ0FBQzFZLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0JzQixFQUF0QixFQUFyQjtBQUNBd1ksY0FBSSxDQUFDelAsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUI1QyxVQUF2QixDQUFrQyxZQUFsQyxFQUFnRGtvQixZQUFoRCxFQUE4RHhILElBQUksQ0FBQzNtQixJQUFuRSxFQUF5RTJtQixJQUF6RSxFQUErRSxVQUFDalMsUUFBRCxFQUFjO0FBQ3pGa0osbUJBQU8sQ0FBQ3BNLElBQUksQ0FBQ0MsU0FBTCxDQUFlaUQsUUFBUSxDQUFDelMsUUFBeEIsQ0FBRCxDQUFQLENBRHlGLENBRXpGO0FBQ0gsV0FIRCxFQUZvQyxDQU1wQztBQUNBO0FBQ0gsU0FSTSxDQUFQO0FBU0gsT0FyQnFCO0FBc0J0Qm1zQixzQkFBZ0IsRUFBRSwwQkFBQ0osTUFBRCxFQUFZO0FBQzFCO0FBQ0EsMkJBQVdBLE1BQVg7QUFDSCxPQXpCcUIsQ0EwQnRCOztBQTFCc0IsS0FBaEIsQ0FBVixDQUhtQixDQStCbkI7O0FBRUEsVUFBS3BFLEtBQUwsR0FBYSxLQUFiO0FBQ0EsVUFBSzVsQixRQUFMLEdBQWdCLEtBQWhCOztBQUNBLFVBQUtxcUIsaUJBQUw7O0FBQ0EsVUFBS0MscUJBQUwsR0FBNkIsSUFBN0I7QUFDQSxVQUFLQyx5QkFBTCxHQUFpQyxJQUFqQztBQUNBLFVBQUtDLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0EsVUFBS3JhLGFBQUwsR0FBcUIsTUFBS2tFLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBckI7O0FBRUEsVUFBSytyQiw4QkFBTDs7QUF6Q21CO0FBMEN0Qjs7Ozs0Q0FFdUI7QUFBQTs7QUFDcEIsV0FBS3hqQixFQUFMLENBQVFxRyxXQUFSLENBQW9Cb2QsU0FBcEIsQ0FBOEJDLG9CQUE5QixHQUFxRCxVQUFDQyxPQUFELEVBQWE7QUFDOURBLGVBQU8sQ0FBQzVRLElBQVIsQ0FBYTtBQUNUNlEsaUJBQU8sRUFBRSxJQURBO0FBRVR2VyxjQUFJLEVBQUUsWUFGRztBQUdUd1csa0JBQVEsRUFBRTtBQUFBLG1CQUFNLE1BQUksQ0FBQ3pXLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QndaLGlCQUFsQztBQUFBO0FBSEQsU0FBYjtBQUtILE9BTkQ7QUFPSDs7OzBCQUVLaUMsVyxFQUFhQyxTLEVBQVc7QUFBQTs7QUFDMUIsVUFBSWdILFdBQVcsR0FBRyxLQUFLeHNCLFFBQXZCOztBQUNBLGtGQUFZdWxCLFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjs7QUFFQSxVQUFJOUIsV0FBVyxLQUFLLFdBQXBCLEVBQWlDO0FBQzdCLFlBQUlpSCxXQUFXLEtBQUssV0FBcEIsRUFBaUM7QUFDN0IsZUFBSzVhLGFBQUwsR0FBcUIsS0FBS2tFLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBckI7QUFDSDs7QUFDRCxhQUFLMlYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCSSxVQUF4QixDQUFtQ0MsWUFBWSxDQUFDQyxJQUFoRDtBQUNILE9BTEQsTUFLTztBQUNILGFBQUt5VixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JJLFVBQXhCLENBQW1DLEtBQUt5UixhQUF4QztBQUNIOztBQUVELFdBQUtJLFlBQUwsQ0FBa0IsS0FBS3JELElBQUwsQ0FBVWtCLE1BQVYsRUFBbEIsRUFkMEIsQ0FnQjFCOztBQUNBLFdBQUtzWSxtQkFBTCxHQUEyQixLQUFLeFosSUFBTCxDQUFVa0IsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQWpCMEIsQ0FtQjFCOztBQUNBLFdBQUt1YixpQkFBTCxHQUF5QixLQUFLbEYsWUFBTCxDQUFrQnJXLElBQWxCLENBQXVCLElBQXZCLENBQXpCO0FBQ0EsV0FBS3hJLEVBQUwsQ0FBUWdrQixpQkFBUixDQUEwQixLQUFLRCxpQkFBL0I7O0FBRUEsVUFBSWxILFdBQVcsS0FBSyxXQUFwQixFQUFpQztBQUM3QixhQUFLN2MsRUFBTCxDQUFRaWtCLFNBQVIsR0FBb0I7QUFBQSxpQkFBTSxLQUFOO0FBQUEsU0FBcEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLamtCLEVBQUwsQ0FBUWlrQixTQUFSLEdBQW9CLEtBQUs3VyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ3N0QixTQUF4RDtBQUVBLGFBQUtaLHFCQUFMLEdBQTZCLEtBQUtqVyxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0ksVUFBbkMsQ0FBOEN5UixTQUE5QyxDQUF3RCxVQUFDOFYsS0FBRCxFQUFVO0FBQzNGLGlCQUFPLE1BQUksQ0FBQ2xrQixFQUFMLENBQVFta0IsbUJBQVIsQ0FBNEJELEtBQTVCLEVBQW1DLG1CQUFuQyxDQUFQO0FBQ0gsU0FGNEIsQ0FBN0I7QUFHQSxhQUFLWix5QkFBTCxHQUFpQyxLQUFLbFcsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNLLGNBQW5DLENBQWtEd1IsU0FBbEQsQ0FBNEQsVUFBQzhWLEtBQUQ7QUFBQSxpQkFDekYsTUFBSSxDQUFDbGtCLEVBQUwsQ0FBUW1rQixtQkFBUixDQUE0QkQsS0FBNUIsRUFBbUMsdUJBQW5DLENBRHlGO0FBQUEsU0FBNUQsQ0FBakM7QUFJQSxhQUFLWCxxQkFBTCxHQUE2QixLQUFLblcsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1Cc0UsS0FBbkIsQ0FBeUJDLGVBQXpCLENBQXlDd0osU0FBekMsQ0FBbUQsVUFBQzhWLEtBQUQsRUFBVztBQUN2RixnQkFBSSxDQUFDbGtCLEVBQUwsQ0FBUW9rQixxQkFBUixDQUE4QixvQkFBOUI7O0FBQ0EsZ0JBQUksQ0FBQ3BrQixFQUFMLENBQVFta0IsbUJBQVIsQ0FBNEJELEtBQTVCLEVBQW1DLG9CQUFuQztBQUNILFNBSDRCLENBQTdCO0FBSUgsT0F2Q3lCLENBMEMxQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ExZixnQkFBVSxDQUFDO0FBQUEsZUFBTSxNQUFJLENBQUN4RSxFQUFMLENBQVFDLE9BQVIsRUFBTjtBQUFBLE9BQUQsRUFBMEIsQ0FBMUIsQ0FBVjtBQUNIOzs7aUNBRVk2ZSxXLEVBQWE7QUFDdEIsVUFBSUEsV0FBVyxLQUFLdHJCLFNBQXBCLEVBQStCO0FBQzNCLFlBQUksS0FBS3lTLElBQUwsS0FBYyxJQUFsQixFQUF3QjtBQUNwQjZZLHFCQUFXLEdBQUcsS0FBSzdZLElBQUwsQ0FBVWtCLE1BQVYsRUFBZDtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0EyWCxxQkFBVyxHQUFHLEVBQWQ7QUFDSDtBQUNKLE9BUEQsTUFPTyxJQUFJQSxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDN0I7QUFDQSxhQUFLMVIsSUFBTCxDQUFVelAsVUFBVixDQUFxQmlCLFVBQXJCLENBQWdDeWxCLGtCQUFoQyxDQUFtRCxLQUFLL3NCLFFBQXhEO0FBQ0E7QUFDSDs7QUFDRCxXQUFLcW5CLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzNlLEVBQUwsQ0FBUXNrQixPQUFSLENBQWdCeEYsV0FBaEIsRUFGWSxDQUdaOztBQUNBLGFBQUtILEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZN1MsSyxFQUFPO0FBQ2hCLFdBQUs5TCxFQUFMLENBQVFva0IscUJBQVI7QUFFQSxXQUFLekYsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7O0FBQ0EsWUFBSSxDQUFDLEtBQUt2UixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JPLFdBQXhCLEVBQUwsRUFBNEM7QUFDeEMsZUFBS3FPLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUIsS0FBS25ILEVBQUwsQ0FBUXVrQixPQUFSLEVBQWpCO0FBQ0g7O0FBQ0QsYUFBSzVGLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUsyQixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtjLG1CQUFMLENBQXlCTyxPQUF6QjtBQUNBLFdBQUtoZ0IsRUFBTCxDQUFRd2tCLG9CQUFSLENBQTZCLEtBQUtULGlCQUFsQzs7QUFDQSxVQUFJLEtBQUszVyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JPLFdBQXhCLEVBQUosRUFBMkM7QUFDdkMsYUFBS3dWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQm9ILE9BQW5CLENBQTJCbUIsTUFBM0IsQ0FBa0NTLGtCQUFsQztBQUNIOztBQUNELFdBQUtvYixzQkFBTDs7QUFDQSxpRkFBVzVILFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs2Q0FFd0I7QUFDckIsV0FBSzljLEVBQUwsQ0FBUW9rQixxQkFBUjs7QUFDQSxVQUFJLEtBQUtmLHFCQUFULEVBQWdDO0FBQzVCLGFBQUtBLHFCQUFMLENBQTJCckQsT0FBM0I7QUFDQSxhQUFLcUQscUJBQUwsR0FBNkIsSUFBN0I7QUFDSDs7QUFDRCxVQUFJLEtBQUtDLHlCQUFULEVBQW9DO0FBQ2hDLGFBQUtBLHlCQUFMLENBQStCdEQsT0FBL0I7QUFDQSxhQUFLc0QseUJBQUwsR0FBaUMsSUFBakM7QUFDSDs7QUFDRCxVQUFJLEtBQUtDLHFCQUFULEVBQWdDO0FBQzVCLGFBQUtBLHFCQUFMLENBQTJCdkQsT0FBM0I7QUFDQSxhQUFLdUQscUJBQUwsR0FBNkIsSUFBN0I7QUFDSDtBQUNKOzs7d0NBRW1CO0FBQUE7O0FBQ2hCLFdBQUt2akIsRUFBTCxDQUFRMGtCLE9BQVIsQ0FBZ0IsS0FBS3RYLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBaEI7QUFDQSxXQUFLMlYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCSSxVQUF4QixDQUFtQzJXLFNBQW5DLENBQTZDLFVBQUFzUCxJQUFJLEVBQUk7QUFDakQsY0FBSSxDQUFDMWQsRUFBTCxDQUFRMGtCLE9BQVIsQ0FBZ0JoSCxJQUFoQjtBQUNILE9BRkQ7QUFHQSxXQUFLdFEsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0NndUIsWUFBcEMsQ0FBaUR2VyxTQUFqRCxDQUEyRCxVQUFBd1YsT0FBTyxFQUFJO0FBQ2xFLFlBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1YsZ0JBQUksQ0FBQzVqQixFQUFMLENBQVEwa0IsT0FBUixDQUFnQmh0QixZQUFZLENBQUNDLElBQTdCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQUksQ0FBQ3FJLEVBQUwsQ0FBUTBrQixPQUFSLENBQWdCLE1BQUksQ0FBQ3RYLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBaEI7QUFDSDtBQUNKLE9BTkQ7QUFPQSxXQUFLMlYsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0Nrc0IsT0FBcEMsQ0FBNEN6VSxTQUE1QyxDQUFzRCxLQUFLd1csYUFBTCxDQUFtQnBjLElBQW5CLENBQXdCLElBQXhCLENBQXREO0FBQ0EsV0FBSzRFLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DOEssWUFBcEMsQ0FBaUQyTSxTQUFqRCxDQUEyRCxVQUFBeVcsU0FBUyxFQUFJO0FBQ3BFLGNBQUksQ0FBQzdrQixFQUFMLENBQVE4a0IsWUFBUixDQUFxQkQsU0FBckI7QUFDSCxPQUZELEVBYmdCLENBaUJoQjs7QUFDQSxXQUFLRSxTQUFMLEdBQWlCLElBQWpCOztBQUNBLFVBQUksS0FBSzNYLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQkMsV0FBbkIsRUFBSixFQUFzQztBQUNsQyxhQUFLMGtCLGNBQUw7QUFDSDs7QUFDRCxXQUFLNVgsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CQyxXQUFuQixDQUErQjhOLFNBQS9CLENBQXlDLFVBQUE0VyxjQUFjLEVBQUk7QUFDdkQsWUFBSUEsY0FBSixFQUFvQjtBQUNoQixnQkFBSSxDQUFDQSxjQUFMO0FBQ0gsU0FGRCxNQUVPLElBQUksTUFBSSxDQUFDRCxTQUFMLEtBQW1CLElBQXZCLEVBQTZCO0FBQ2hDLGdCQUFJLENBQUMva0IsRUFBTCxDQUFRNU0sYUFBUixDQUFzQndnQixNQUF0QixHQUErQixNQUFJLENBQUNtUixTQUFwQzs7QUFDQSxnQkFBSSxDQUFDL2tCLEVBQUwsQ0FBUXVCLFVBQVIsQ0FBbUIwakIsa0JBQW5COztBQUNBLGdCQUFJLENBQUNGLFNBQUwsR0FBaUIsSUFBakI7QUFDSDtBQUNKLE9BUkQ7QUFTSDs7O3FDQUVnQjtBQUNiLFdBQUsva0IsRUFBTCxDQUFRdUIsVUFBUixDQUFtQjJqQixZQUFuQixDQUFnQztBQUFDQyxxQkFBYSxFQUFFO0FBQWhCLE9BQWhDO0FBQ0EsV0FBS0osU0FBTCxHQUFpQixLQUFLL2tCLEVBQUwsQ0FBUTVNLGFBQVIsQ0FBc0J3Z0IsTUFBdkM7QUFDQSxXQUFLNVQsRUFBTCxDQUFRNU0sYUFBUixDQUFzQndnQixNQUF0QixHQUErQixHQUEvQixDQUhhLENBR3VCOztBQUNwQyxXQUFLNVQsRUFBTCxDQUFRdUIsVUFBUixDQUFtQjBqQixrQkFBbkI7QUFDSDs7O2tDQUVhcEMsTyxFQUFTO0FBQ25CLFVBQUlBLE9BQU8sS0FBSyxRQUFoQixFQUEwQjtBQUN0QixZQUFJdUMsYUFBYSxHQUFHLEtBQUtoWSxJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NxSSxPQUFoQyxDQUF3QyxrQkFBeEMsQ0FBcEI7O0FBQ0EsWUFBSW1lLGFBQWEsSUFBSSxJQUFyQixFQUEyQjtBQUN2QnZDLGlCQUFPLEdBQUcsT0FBVjtBQUNILFNBRkQsTUFFTztBQUNILGNBQUk7QUFDQUEsbUJBQU8sR0FBR3RjLElBQUksQ0FBQ2dHLEtBQUwsQ0FBVzZZLGFBQWEsQ0FBQ2plLE1BQWQsRUFBWCxDQUFWO0FBQ0gsV0FGRCxDQUVFLE9BQU9rRixDQUFQLEVBQVU7QUFDUjVOLG1CQUFPLENBQUMrWSxLQUFSLENBQWNuTCxDQUFkLEVBRFEsQ0FDVTs7QUFDbEJ3VyxtQkFBTyxHQUFHLFNBQVY7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsV0FBSzdpQixFQUFMLENBQVE1TSxhQUFSLENBQXNCeXZCLE9BQXRCLEdBQWdDQSxPQUFoQyxDQWRtQixDQWVuQjs7QUFDQSxVQUFJO0FBQ0EsYUFBSzdpQixFQUFMLENBQVFxRyxXQUFSLENBQW9CZ1IsYUFBcEI7QUFDSCxPQUZELENBRUUsT0FBT2hMLENBQVAsRUFBVTtBQUNSNU4sZUFBTyxDQUFDK1ksS0FBUixDQUFjbkwsQ0FBZDtBQUNBLGFBQUtyTSxFQUFMLENBQVE1TSxhQUFSLENBQXNCeXZCLE9BQXRCLEdBQWdDLE9BQWhDO0FBQ0EsYUFBSzdpQixFQUFMLENBQVFxRyxXQUFSLENBQW9CZ1IsYUFBcEI7QUFDSDtBQUNKOzs7cURBRWdDO0FBQUE7O0FBQzdCLFdBQUtqSyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JFLFVBQXhCLENBQW1DNlcsU0FBbkMsQ0FBNkMsVUFBQ0MsT0FBRCxFQUFhO0FBQ3RELGNBQUksQ0FBQzlFLFdBQUwsQ0FBaUIsTUFBSSxDQUFDOGIsbUJBQUwsRUFBakI7QUFDSCxPQUZEO0FBR0EsV0FBS2pZLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DMnVCLFdBQXBDLENBQWdEbFgsU0FBaEQsQ0FBMEQsVUFBQ0MsT0FBRCxFQUFhO0FBQ25FLGNBQUksQ0FBQzlFLFdBQUwsQ0FBaUIsTUFBSSxDQUFDOGIsbUJBQUwsRUFBakI7QUFDSCxPQUZEO0FBR0EsV0FBS2pZLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QitKLE1BQTlCLENBQXFDaVIsU0FBckMsQ0FBK0MsVUFBQ0MsT0FBRCxFQUFhLENBQ3hEO0FBQ0gsT0FGRDtBQUdIOzs7MENBRXFCO0FBQ2xCLFVBQUkzWixLQUFLLEdBQUcsS0FBSzBZLElBQUwsQ0FBVTFZLEtBQXRCO0FBQ0EsYUFBT0EsS0FBSyxDQUFDMkMsT0FBTixDQUFjTyxXQUFkLE1BQ0hsRCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIydUIsV0FBMUIsTUFBMkMsQ0FBQzV3QixLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFEaEQ7QUFHSDs7O2dDQUVXZ3VCLFUsRUFBWTtBQUNwQixXQUFLeHNCLFFBQUwsR0FBZ0J3c0IsVUFBaEI7QUFDQSxXQUFLdmxCLEVBQUwsQ0FBUXVKLFdBQVIsQ0FBb0JnYyxVQUFwQjtBQUNIOzs7K0JBRVV6WixLLEVBQU87QUFDZCxVQUFJeFUsUUFBUSxHQUFHd1UsS0FBSyxDQUFDRSxNQUFOLENBQWFVLFFBQTVCO0FBQ0EsVUFBSTdWLElBQUksR0FBR2lWLEtBQUssQ0FBQ0UsTUFBTixDQUFhUSxNQUF4Qjs7QUFDQSxVQUFJbFYsUUFBUSxDQUFDa3VCLFFBQVQsQ0FBa0IsUUFBbEIsQ0FBSixFQUFpQztBQUM3QjN1QixZQUFJLEdBQUdvckIsb0JBQW9CLENBQUNwckIsSUFBRCxDQUEzQjtBQUNIOztBQUNELFdBQUt1VyxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjVELFFBQTVCLENBQXFDLGVBQXJDLEVBQXNELEVBQXRELEVBQTBELEVBQTFELEVBQThEbkQsSUFBOUQsRUFBb0UsS0FBS1MsUUFBekU7QUFDQSxXQUFLMk8sSUFBTCxDQUFVa0IsTUFBVixDQUFpQnRRLElBQWpCO0FBQ0EsV0FBS3VXLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJzRSxNQUFyQixDQUE0Qm1KLEdBQTVCLEdBUmMsQ0FTZDtBQUNIOzs7bUNBRWM7QUFDWCxVQUFJb0IsTUFBTSxxRkFBVjs7QUFDQSxVQUFJQSxNQUFNLENBQUN6WCxJQUFQLEtBQWdCLFFBQWhCLElBQTRCeVgsTUFBTSxDQUFDZ1AsU0FBUCxLQUFxQixLQUFyRCxFQUE0RDtBQUN4RGhQLGNBQU0sQ0FBQ3pYLElBQVAsR0FBY3VtQixpRUFBUSxDQUFDLEtBQUtsTyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkIwQixJQUEzQixFQUFELENBQXRCO0FBQ0g7O0FBQ0R5WCxZQUFNLENBQUNpUCxRQUFQLEdBQWtCLGVBQWxCO0FBQ0EsV0FBS3JPLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCNUQsUUFBNUIsQ0FBcUMsaUJBQXJDLEVBQXdELEVBQXhELEVBQTRELEVBQTVELEVBQWdFLEVBQWhFLEVBQW9Fd1MsTUFBTSxDQUFDelgsSUFBM0U7QUFDQSxhQUFPeVgsTUFBUDtBQUNIOzs7O0VBcFIwQjhQLCtEOztBQXdSeEIsSUFBTW1KLFlBQVksR0FBRztBQUN4QjF3QixNQUFJLEVBQUUsUUFEa0I7QUFFeEJpcUIsWUFBVSxFQUFFLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FGWTtBQUd4QkMsYUFBVyxFQUFFd0QsZ0JBSFc7QUFJeEJ2RCxVQUFRLEVBQUU2QztBQUpjLENBQXJCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzljUDtBQUVPLElBQU0yRCxnQkFBZ0IsdUZBQXRCOztJQU1EQyxjOzs7OztBQUNGLDBCQUFZdlksSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNbkcsSUFBTixFQUFZbUcsR0FBWjtBQUNBLFVBQUsxSyxVQUFMLEdBQWtCdVgsVUFBVSxDQUFDQyxZQUFYLENBQXdCOU0sR0FBRyxDQUFDcFAsSUFBSixDQUFTLHNCQUFULEVBQWlDLENBQWpDLENBQXhCLEVBQTZEO0FBQzNFbWMsNkJBQXVCLEVBQUUsSUFEa0Q7QUFFM0VDLGlCQUFXLEVBQUUsSUFGOEQ7QUFHM0VDLHFCQUFlLEVBQUUsQ0FIMEQ7QUFJM0VDLGdCQUFVLEVBQUUsQ0FKK0Q7QUFLM0VDLGFBQU8sRUFBRSxDQUxrRTtBQU0zRUMsb0JBQWMsRUFBRSxLQU4yRDtBQU8zRUMsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUI4WCxjQUFFLENBQUMvWCxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIK1gsY0FBRSxDQUFDeHBCLE9BQUgsQ0FBV3FFLEtBQVgsQ0FBaUJvbEIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDL1gsU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQytYLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVBnRSxLQUE3RCxDQUFsQjtBQXNCQSxVQUFLNFYsS0FBTCxHQUFhLEtBQWI7QUF4Qm1CO0FBeUJ0Qjs7OzswQkFFSzlCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLGdGQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNkIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLclYsWUFBTCxDQUFrQixLQUFLckQsSUFBTCxDQUFVa0IsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLc1ksbUJBQUwsR0FBMkIsS0FBS3haLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS29XLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnJXLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBS0ssVUFBTCxDQUFnQmlSLEVBQWhCLENBQW1CLFFBQW5CLEVBQTZCLEtBQUs4RSxlQUFsQzs7QUFDQSxVQUFJOUIsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F0WSxrQkFBVSxDQUFDLEtBQUtxRSxVQUFMLENBQWdCNUksT0FBaEIsQ0FBd0J1SSxJQUF4QixDQUE2QixLQUFLSyxVQUFsQyxDQUFELEVBQWdELENBQWhELENBQVY7QUFDSCxPQVp5QixDQWExQjs7O0FBQ0EsV0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MrVCxXQUFXLENBQUN0VixVQUFaLENBQXVCLEdBQXZCLEtBQStCLENBQUMsS0FBSzZGLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBdEU7QUFDSDs7O2lDQUVZdW5CLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUs5VixVQUFMLENBQWdCa1ksUUFBaEIsQ0FBeUJqQyxXQUF6QjtBQUNBLGFBQUtqVyxVQUFMLENBQWdCNUksT0FBaEI7QUFDQSxhQUFLMGUsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVk3UyxLLEVBQU87QUFDaEIsV0FBSzZTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFZLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUIsS0FBSzBCLFVBQUwsQ0FBZ0JtWSxRQUFoQixFQUFqQjtBQUNBLGFBQUtyQyxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTlCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLeUMsbUJBQUwsQ0FBeUJPLE9BQXpCO0FBQ0EsV0FBS25YLFVBQUwsQ0FBZ0JvWSxHQUFoQixDQUFvQixRQUFwQixFQUE4QixLQUFLckMsZUFBbkM7QUFDQSxXQUFLL1YsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEM7O0FBQ0EsK0VBQVcrVCxXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBdEV3QlIsK0Q7O0FBeUV0QixJQUFNc0osVUFBVSxHQUFHO0FBQ3RCN3dCLE1BQUksRUFBRSxNQURnQjtBQUV0QmlxQixZQUFVLEVBQUUsQ0FBQyxPQUFELENBRlU7QUFHdEJDLGFBQVcsRUFBRTBHLGNBSFM7QUFJdEJ6RyxVQUFRLEVBQUV3RztBQUpZLENBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakZQOzs7O0FBS0E7QUFFTyxJQUFNeG5CLGtCQUFrQixHQUFHO0FBQzlCQyxTQUFPLEVBQUUsU0FEcUI7QUFFOUIwbkIsUUFBTSxFQUFFLFFBRnNCO0FBRzlCQyxRQUFNLEVBQUUsUUFIc0I7QUFJOUJDLE9BQUssRUFBRSxPQUp1QjtBQUs5QkMsU0FBTyxFQUFFO0FBTHFCLENBQTNCO0FBUUEsSUFBTXZmLGdCQUFiO0FBQ0ksNEJBQVkxUixJQUFaLEVBQWtCc0UsTUFBbEIsRUFBMEJ4QyxJQUExQixFQUFnQztBQUFBOztBQUM1QixTQUFLOUIsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS3NFLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUt4QyxJQUFMLEdBQVlBLElBQVo7QUFDSDs7QUFMTDtBQUFBO0FBQUEsZ0NBZ0JnQjtBQUNSLGFBQU87QUFDSDlCLFlBQUksRUFBRSxLQUFLQSxJQURSO0FBRUhzRSxjQUFNLEVBQUUsS0FBS0EsTUFGVjtBQUdIeEMsWUFBSSxFQUFFLEtBQUtBO0FBSFIsT0FBUDtBQUtIO0FBdEJMO0FBQUE7QUFBQSwwQkFPaUJvdkIsS0FQakIsRUFPd0I7QUFDaEIsYUFBTyxJQUFJeGYsZ0JBQUosQ0FBcUIsY0FBWXdmLEtBQUssSUFBSSxDQUFyQixDQUFyQixFQUNxQi9uQixrQkFBa0IsQ0FBQ0MsT0FEeEMsRUFDaUQsS0FEakQsQ0FBUDtBQUVIO0FBVkw7QUFBQTtBQUFBLGdDQVl1QkssSUFadkIsRUFZNkI7QUFDckIsYUFBTyxJQUFJaUksZ0JBQUosQ0FBcUJqSSxJQUFJLENBQUN6SixJQUExQixFQUFnQ3lKLElBQUksQ0FBQ25GLE1BQXJDLEVBQTZDbUYsSUFBSSxDQUFDM0gsSUFBbEQsQ0FBUDtBQUNIO0FBZEw7O0FBQUE7QUFBQTtBQXlCTyxJQUFNcXZCLHVCQUF1QixrZUFBN0I7QUFnQlByeEIsRUFBRSxDQUFDc3hCLGVBQUgsQ0FBbUJDLGtCQUFuQixHQUF3QztBQUNwQ0MsTUFBSSxFQUFFLGNBQVMvRSxPQUFULEVBQWtCZ0YsYUFBbEIsRUFBaUNDLFdBQWpDLEVBQThDQyxTQUE5QyxFQUF5REMsY0FBekQsRUFBeUU7QUFDM0U7QUFDQTtBQUNBaG9CLFdBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxNQUFaO0FBQ0EsUUFBSWdVLEVBQUUsR0FBR1QsVUFBVSxDQUFDQyxZQUFYLENBQXdCaUIsT0FBeEIsRUFBaUM7QUFDdENoQiw2QkFBdUIsRUFBRSxJQURhO0FBRXRDQyxpQkFBVyxFQUFFLElBRnlCO0FBR3RDQyxxQkFBZSxFQUFFLENBSHFCO0FBSXRDQyxnQkFBVSxFQUFFLENBSjBCO0FBS3RDQyxhQUFPLEVBQUUsQ0FMNkI7QUFNdENDLG9CQUFjLEVBQUUsS0FOc0I7QUFPdENDLGVBQVMsRUFBRTtBQUNQLGVBQU8sWUFEQTtBQUVQLHFCQUFhLFlBRk47QUFHUCxlQUFPLGFBQVVDLEVBQVYsRUFBYztBQUNqQixjQUFJQSxFQUFFLENBQUM5WCxTQUFILENBQWEsWUFBYixDQUFKLEVBQWdDO0FBQzVCOFgsY0FBRSxDQUFDL1gsU0FBSCxDQUFhLFlBQWIsRUFBMkIsS0FBM0I7QUFDSCxXQUZELE1BRU87QUFDSCtYLGNBQUUsQ0FBQ3hwQixPQUFILENBQVdxRSxLQUFYLENBQWlCb2xCLElBQWpCO0FBQ0g7QUFDSixTQVRNO0FBVVAsZUFBTyxhQUFVRCxFQUFWLEVBQWM7QUFDakJBLFlBQUUsQ0FBQy9YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLENBQUMrWCxFQUFFLENBQUM5WCxTQUFILENBQWEsWUFBYixDQUE1QjtBQUNIO0FBWk07QUFQMkIsS0FBakMsQ0FBVDtBQXNCQThYLE1BQUUsQ0FBQzZGLE9BQUgsQ0FBVyxNQUFYLEVBQW1CLE9BQW5CO0FBQ0EsV0FBTzdGLEVBQVA7QUFDSCxHQTdCbUM7QUE4QnBDOEYsUUFBTSxFQUFFLGdCQUFTckYsT0FBVCxFQUFrQmdGLGFBQWxCLEVBQWlDQyxXQUFqQyxFQUE4Q0MsU0FBOUMsRUFBeURDLGNBQXpELEVBQXlFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBaG9CLFdBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxRQUFaO0FBQ0g7QUFuQ21DLENBQXhDOztJQXNDTStaLHFCOzs7OztBQUNGLGlDQUFZeFosSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNbkcsSUFBTixFQUFZbUcsR0FBWjtBQUNBLFVBQUtBLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFVBQUtzVCxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsVUFBS2xJLEtBQUwsR0FBYSxLQUFiO0FBSm1CO0FBS3RCOzs7O2dDQUVXOVQsTSxFQUFRQyxLLEVBQU9DLFUsRUFBWSxDQUV0Qzs7O3FDQUVnQjtBQUNidE0sYUFBTyxDQUFDb08sR0FBUixDQUFZLG9CQUFaO0FBQ0g7OzswQkFFS2dRLFcsRUFBYUMsUyxFQUFXO0FBQUE7O0FBQzFCLHVGQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNkIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLclYsWUFBTCxDQUFrQixLQUFLckQsSUFBTCxDQUFVa0IsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLc1ksbUJBQUwsR0FBMkIsS0FBS3haLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS29XLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnJXLElBQWxCLENBQXVCLElBQXZCLENBQXZCLENBUDBCLENBUTFCO0FBQ0E7O0FBQ0EsVUFBSXNVLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQnJlLGVBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxLQUFLMEcsR0FBakI7QUFDQTlVLGVBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxLQUFLMEcsR0FBTCxDQUFTcFAsSUFBVCxDQUFjLGFBQWQsQ0FBWjtBQUNBMUYsZUFBTyxDQUFDb08sR0FBUixDQUFZLEtBQUswRyxHQUFMLENBQVNwUCxJQUFULENBQWMsYUFBZCxFQUE2QjBELEdBQTdCLENBQWlDLFVBQUM4TixDQUFELEVBQUdrTCxFQUFIO0FBQUEsaUJBQVVwaUIsT0FBTyxDQUFDb08sR0FBUixDQUFZLEtBQVosRUFBbUJnVSxFQUFFLENBQUNULFVBQXRCLENBQVY7QUFBQSxTQUFqQyxDQUFaO0FBQ0EsYUFBSzdNLEdBQUwsQ0FBU3BQLElBQVQsQ0FBYyxhQUFkLEVBQTZCMEQsR0FBN0IsQ0FBaUMsVUFBQzhOLENBQUQsRUFBSWtMLEVBQUo7QUFBQSxpQkFBV0EsRUFBRSxDQUFDVCxVQUFILENBQWNuZ0IsT0FBZCxFQUFYO0FBQUEsU0FBakM7QUFDQXhCLGVBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxTQUFaLEVBTG9CLENBTXBCOztBQUNBckksa0JBQVUsQ0FBQztBQUFBLGlCQUFNLE1BQUksQ0FBQytPLEdBQUwsQ0FBU3BQLElBQVQsQ0FBYyxhQUFkLEVBQTZCMEQsR0FBN0IsQ0FBaUMsVUFBQzhOLENBQUQsRUFBSWtMLEVBQUo7QUFBQSxtQkFBV0EsRUFBRSxDQUFDVCxVQUFILENBQWNuZ0IsT0FBZCxFQUFYO0FBQUEsV0FBakMsQ0FBTjtBQUFBLFNBQUQsRUFBNkUsQ0FBN0UsQ0FBVjtBQUNILE9BbEJ5QixDQW1CMUI7QUFDQTs7QUFDSDs7O2lDQUVZNmUsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0FsZ0IsZUFBTyxDQUFDb08sR0FBUixDQUFZLEtBQUtnYSxXQUFqQixFQUZZLENBR1o7QUFDQTs7QUFDQSxhQUFLbEksS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVk3UyxLLEVBQU87QUFDaEIsV0FBSzZTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFZLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUIsS0FBSzBmLFdBQUwsQ0FBaUJoZixHQUFqQixDQUFxQixVQUFBZ1osRUFBRTtBQUFBLGlCQUFJQSxFQUFFLENBQUNHLFFBQUgsRUFBSjtBQUFBLFNBQXZCLENBQWpCO0FBQ0EsYUFBS3JDLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUt5QyxtQkFBTCxDQUF5Qk8sT0FBekI7QUFDQSxXQUFLNkcsV0FBTCxHQUFtQixFQUFuQixDQUhvQyxDQUlwQztBQUNBOztBQUNBLHNGQUFXaEssV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQWxFK0JSLCtEOztBQXFFN0IsSUFBTXdLLGlCQUFpQixHQUFHO0FBQzdCL3hCLE1BQUksRUFBRSxvQkFEdUI7QUFFN0JpcUIsWUFBVSxFQUFFLENBQUMsNkJBQUQsQ0FGaUI7QUFHN0JDLGFBQVcsRUFBRTJILHFCQUhnQjtBQUk3QjFILFVBQVEsRUFBRWdIO0FBSm1CLENBQTFCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbktQO0FBRU8sSUFBTWEsZ0JBQWdCLGlPQUF0Qjs7SUFrQkRDLGM7Ozs7O0FBQ0YsMEJBQVk1WixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQSw2QkFDYm5HLElBRGEsRUFDUG1HLEdBQUcsQ0FBQ3BQLElBQUosQ0FBUyxzQkFBVCxDQURPO0FBRXRCOzs7RUFId0JtWSwrRDs7QUFNdEIsSUFBTTJLLFVBQVUsR0FBRztBQUN0Qmx5QixNQUFJLEVBQUUsTUFEZ0I7QUFFdEJpcUIsWUFBVSxFQUFFLENBQUMsZUFBRCxDQUZVO0FBR3RCQyxhQUFXLEVBQUUrSCxjQUhTO0FBSXRCOUgsVUFBUSxFQUFFNkg7QUFKWSxDQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJQO0FBQ0E7QUFFTyxJQUFNRyxnQkFBZ0IsbUJBQ3ZCL0gsOERBRHVCLHVGQUF0Qjs7SUFPRGdJLGM7Ozs7O0FBQ0YsMEJBQVkvWixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBSzFLLFVBQUwsR0FBa0J1WCxVQUFVLENBQUNDLFlBQVgsQ0FBd0I5TSxHQUFHLENBQUNwUCxJQUFKLENBQVMsc0JBQVQsRUFBaUMsQ0FBakMsQ0FBeEIsRUFBNkQ7QUFDM0VtYyw2QkFBdUIsRUFBRSxJQURrRDtBQUUzRUMsaUJBQVcsRUFBRSxJQUY4RDtBQUczRUMscUJBQWUsRUFBRSxDQUgwRDtBQUkzRUMsZ0JBQVUsRUFBRSxDQUorRDtBQUszRUMsYUFBTyxFQUFFLENBTGtFO0FBTTNFQyxvQkFBYyxFQUFFLEtBTjJEO0FBTzNFQyxlQUFTLEVBQUU7QUFDUCxlQUFPLFlBREE7QUFFUCxxQkFBYSxZQUZOO0FBR1AsZUFBTyxhQUFVQyxFQUFWLEVBQWM7QUFDakIsY0FBSUEsRUFBRSxDQUFDOVgsU0FBSCxDQUFhLFlBQWIsQ0FBSixFQUFnQztBQUM1QjhYLGNBQUUsQ0FBQy9YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLEtBQTNCO0FBQ0gsV0FGRCxNQUVPO0FBQ0grWCxjQUFFLENBQUN4cEIsT0FBSCxDQUFXcUUsS0FBWCxDQUFpQm9sQixJQUFqQjtBQUNIO0FBQ0osU0FUTTtBQVVQLGVBQU8sYUFBVUQsRUFBVixFQUFjO0FBQ2pCQSxZQUFFLENBQUMvWCxTQUFILENBQWEsWUFBYixFQUEyQixDQUFDK1gsRUFBRSxDQUFDOVgsU0FBSCxDQUFhLFlBQWIsQ0FBNUI7QUFDSDtBQVpNO0FBUGdFLEtBQTdELENBQWxCO0FBc0JBLFVBQUs0VixLQUFMLEdBQWEsS0FBYjtBQXhCbUI7QUF5QnRCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsZ0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtyVixZQUFMLENBQWtCLEtBQUtyRCxJQUFMLENBQVVrQixNQUFWLEVBQWxCLEVBSDBCLENBSTFCOztBQUNBLFdBQUtzWSxtQkFBTCxHQUEyQixLQUFLeFosSUFBTCxDQUFVa0IsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQUwwQixDQU0xQjs7QUFDQSxXQUFLb1csZUFBTCxHQUF1QixLQUFLQyxZQUFMLENBQWtCclcsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBdkI7QUFDQSxXQUFLSyxVQUFMLENBQWdCaVIsRUFBaEIsQ0FBbUIsUUFBbkIsRUFBNkIsS0FBSzhFLGVBQWxDOztBQUNBLFVBQUk5QixTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEI7QUFDQXRZLGtCQUFVLENBQUMsS0FBS3FFLFVBQUwsQ0FBZ0I1SSxPQUFoQixDQUF3QnVJLElBQXhCLENBQTZCLEtBQUtLLFVBQWxDLENBQUQsRUFBZ0QsQ0FBaEQsQ0FBVjtBQUNILE9BWnlCLENBYTFCOzs7QUFDQSxXQUFLQSxVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQytULFdBQVcsQ0FBQ3RWLFVBQVosQ0FBdUIsR0FBdkIsS0FBK0IsQ0FBQyxLQUFLNkYsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRSxVQUF4QixFQUF0RTtBQUNIOzs7aUNBRVl1bkIsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzlWLFVBQUwsQ0FBZ0JrWSxRQUFoQixDQUF5QmpDLFdBQXpCO0FBQ0EsYUFBS2pXLFVBQUwsQ0FBZ0I1SSxPQUFoQjtBQUNBLGFBQUswZSxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTdTLEssRUFBTztBQUNoQixXQUFLNlMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLMVksSUFBTCxDQUFVa0IsTUFBVixDQUFpQixLQUFLMEIsVUFBTCxDQUFnQm1ZLFFBQWhCLEVBQWpCO0FBQ0EsYUFBS3JDLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUt5QyxtQkFBTCxDQUF5Qk8sT0FBekI7QUFDQSxXQUFLblgsVUFBTCxDQUFnQm9ZLEdBQWhCLENBQW9CLFFBQXBCLEVBQThCLEtBQUtyQyxlQUFuQztBQUNBLFdBQUsvVixVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQyxLQUF0Qzs7QUFDQSwrRUFBVytULFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUF0RXdCUiwrRDs7QUF5RXRCLElBQU04SyxVQUFVLEdBQUc7QUFDdEJyeUIsTUFBSSxFQUFFLE1BRGdCO0FBRXRCaXFCLFlBQVUsRUFBRSxDQUFDLE1BQUQsQ0FGVTtBQUd0QkMsYUFBVyxFQUFFa0ksY0FIUztBQUl0QmpJLFVBQVEsRUFBRWdJO0FBSlksQ0FBbkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkZQO0FBRU8sSUFBTUcsbUJBQW1CLDZmQUF6Qjs7SUFjREMsaUI7Ozs7O0FBQ0YsNkJBQVlsYSxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBSzFLLFVBQUwsR0FBa0J1WCxVQUFVLENBQUNDLFlBQVgsQ0FBd0I5TSxHQUFHLENBQUNwUCxJQUFKLENBQVMseUJBQVQsRUFBb0MsQ0FBcEMsQ0FBeEIsRUFBZ0U7QUFDOUVtYyw2QkFBdUIsRUFBRSxJQURxRDtBQUU5RUMsaUJBQVcsRUFBRSxJQUZpRTtBQUc5RUMscUJBQWUsRUFBRSxDQUg2RDtBQUk5RUMsZ0JBQVUsRUFBRSxDQUprRTtBQUs5RUMsYUFBTyxFQUFFLENBTHFFO0FBTTlFQyxvQkFBYyxFQUFFLEtBTjhEO0FBTzlFakQsVUFBSSxFQUFFLE1BUHdFO0FBUTlFa0QsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUI4WCxjQUFFLENBQUMvWCxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIK1gsY0FBRSxDQUFDeHBCLE9BQUgsQ0FBV3FFLEtBQVgsQ0FBaUJvbEIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDL1gsU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQytYLEVBQUUsQ0FBQzlYLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVJtRSxLQUFoRSxDQUFsQjtBQXVCQSxVQUFLNFYsS0FBTCxHQUFhLEtBQWI7QUF6Qm1CO0FBMEJ0Qjs7OzswQkFFSzlCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLG1GQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNkIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLclYsWUFBTCxDQUFrQixLQUFLckQsSUFBTCxDQUFVa0IsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLc1ksbUJBQUwsR0FBMkIsS0FBS3haLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS29XLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQnJXLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBSytLLEdBQUwsQ0FBU3BQLElBQVQsQ0FBYyx1QkFBZCxFQUF1QzJWLEVBQXZDLENBQTBDLE9BQTFDLEVBQW1ELEtBQUs4RSxlQUF4RCxFQVIwQixDQVMxQjs7QUFDQSxVQUFJOUIsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F0WSxrQkFBVSxDQUFDLEtBQUtxRSxVQUFMLENBQWdCNUksT0FBaEIsQ0FBd0J1SSxJQUF4QixDQUE2QixLQUFLSyxVQUFsQyxDQUFELEVBQWdELENBQWhELENBQVY7QUFDSCxPQWJ5QixDQWMxQjs7O0FBQ0EsV0FBS0EsVUFBTCxDQUFnQkMsU0FBaEIsQ0FBMEIsVUFBMUIsRUFBc0MrVCxXQUFXLENBQUN0VixVQUFaLENBQXVCLEdBQXZCLEtBQStCLENBQUMsS0FBSzZGLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBdEU7QUFFSDs7O2lDQUVZdW5CLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUs5VixVQUFMLENBQWdCa1ksUUFBaEIsQ0FBeUJqQyxXQUF6QjtBQUNBLGFBQUtqVyxVQUFMLENBQWdCNUksT0FBaEI7QUFDQSxhQUFLMGUsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7aUNBRVk3UyxLLEVBQU87QUFDaEIsV0FBSzZTLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFZLElBQUwsQ0FBVWtCLE1BQVYsQ0FBaUIsS0FBSzBCLFVBQUwsQ0FBZ0JtWSxRQUFoQixFQUFqQjs7QUFDQSxZQUFJLEtBQUs1VCxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ2tzQixPQUFwQyxPQUFrRCxRQUF0RCxFQUFnRTtBQUM1RCxlQUFLelYsSUFBTCxDQUFVelAsVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDNmtCLGFBQWxDLENBQWdELFFBQWhEO0FBQ0g7O0FBQ0QsYUFBS2pHLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUt5QyxtQkFBTCxDQUF5Qk8sT0FBekI7QUFDQSxXQUFLek0sR0FBTCxDQUFTcFAsSUFBVCxDQUFjLDBCQUFkLEVBQTBDOGMsR0FBMUMsQ0FBOEMsT0FBOUMsRUFBdUQsS0FBS3JDLGVBQTVELEVBSG9DLENBSXBDOztBQUNBLFdBQUsvVixVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQyxLQUF0Qzs7QUFDQSxrRkFBVytULFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUE3RTJCUiwrRDs7QUFnRnpCLElBQU1pTCxhQUFhLEdBQUc7QUFDekJ4eUIsTUFBSSxFQUFFLFNBRG1CO0FBRXpCaXFCLFlBQVUsRUFBRSxDQUFDLGtCQUFELENBRmE7QUFHekJDLGFBQVcsRUFBRXFJLGlCQUhZO0FBSXpCcEksVUFBUSxFQUFFbUk7QUFKZSxDQUF0QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hHUDs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBSU8sSUFBSUcsV0FBVyxHQUFHO0FBQ3JCQyxZQUFVLEVBQUUsWUFEUztBQUVyQkMsWUFBVSxFQUFFLFlBRlM7QUFHckJDLGNBQVksRUFBRSxjQUhPO0FBSXJCQyxRQUFNLEVBQUUsUUFKYTtBQUtyQkMsV0FBUyxFQUFFLFdBTFU7QUFNckJDLFNBQU8sRUFBRSxTQU5ZO0FBT3JCQyxlQUFhLEVBQUUsZUFQTTtBQVFyQkMsb0JBQWtCLEVBQUUsb0JBUkM7QUFTckJDLGlCQUFlLEVBQUU7QUFUSSxDQUFsQjtBQVlQLElBQU1DLGtCQUFrQixHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLENBQTNCO0FBRUEsSUFBTUMsaUJBQWlCLEdBQUcsQ0FDdEJmLHVEQURzQixFQUNWM0IsMkRBRFUsRUFDSTFHLDhFQURKLEVBQ3dCa0ksdURBRHhCLEVBQ29DcEYsK0RBRHBDLEVBRXRCaUYsNEVBRnNCLEVBRUg1Rix1REFGRyxFQUVTcUcsNkRBRlQsRUFFd0IzQix1REFGeEIsRUFFb0MzRiwwREFGcEMsQ0FBMUI7QUFLTyxJQUFNbUksWUFBWSxHQUFHRCxpQkFBaUIsQ0FBQ3RnQixHQUFsQixDQUFzQixVQUFBbUQsTUFBTTtBQUFBLHlIQUVEQSxNQUFNLENBQUNqVyxJQUZOLDJEQUlsRGlXLE1BQU0sQ0FBQ2tVLFFBSjJDO0FBQUE7QUFRcEQ7Ozs7O0FBUndCLEVBYTFCaEUsSUFiMEIsQ0FhckIsSUFicUIsQ0FBckI7QUFlQSxJQUFNcE4sT0FBYjtBQUNJLG1CQUFZVixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsU0FBS25HLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUttRyxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLN1MsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLMm5CLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQUoscUJBQWlCLENBQUN0UixPQUFsQixDQUEwQixVQUFBN0wsTUFBTTtBQUFBLGFBQUksS0FBSSxDQUFDd2QsY0FBTCxDQUFvQnhkLE1BQXBCLENBQUo7QUFBQSxLQUFoQztBQUNBLFNBQUtvQyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JDLFFBQXhCLENBQWlDOFcsU0FBakMsQ0FBMkMsS0FBS21PLFlBQWhELEVBQThELElBQTlEO0FBQ0g7O0FBVkw7QUFBQTtBQUFBLG1DQVltQi9kLElBWm5CLEVBWXlCO0FBQ2pCLFVBQUl3Z0IsVUFBVSxHQUFHeGdCLElBQUksQ0FBQ3dnQixVQUF0QjtBQUNBLFVBQUl5SixRQUFRLEdBQUcsSUFBSWpxQixJQUFJLENBQUN5Z0IsV0FBVCxDQUFxQixLQUFLN1IsSUFBMUIsRUFBZ0MsS0FBS21HLEdBQXJDLENBQWY7QUFDQWtWLGNBQVEsQ0FBQzF6QixJQUFULEdBQWdCeUosSUFBSSxDQUFDekosSUFBckI7QUFDQSxXQUFLc3pCLFdBQUwsQ0FBaUJ0VixJQUFqQixDQUFzQjBWLFFBQXRCO0FBQ0EsV0FBS0YsT0FBTCxDQUFhL3BCLElBQUksQ0FBQ3pKLElBQUwsQ0FBVW9OLFdBQVYsRUFBYixJQUF3Q3NtQixRQUF4Qzs7QUFDQSxXQUFLLElBQUk5UyxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUdxSixVQUFVLENBQUM5WSxNQUE3QixFQUFxQ3lQLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsYUFBSzJTLFdBQUwsQ0FBaUJ0SixVQUFVLENBQUNySixDQUFELENBQTNCLElBQWtDOFMsUUFBbEM7QUFDSDtBQUNKO0FBckJMO0FBQUE7QUFBQSwyQkF1QlcxekIsSUF2QlgsRUF1QmlCO0FBQ1QsYUFBTyxLQUFLd3pCLE9BQUwsQ0FBYXh6QixJQUFJLENBQUNvTixXQUFMLEVBQWIsQ0FBUDtBQUNIO0FBekJMO0FBQUE7QUFBQSxpQ0EyQmlCMGEsV0EzQmpCLEVBMkI4QjtBQUN0QixVQUFJQyxTQUFTLEdBQUcsS0FBS3BjLE9BQXJCO0FBQ0EsVUFBSXNjLFNBQVMsR0FBRyxLQUFLdFYsU0FBTCxDQUFlbVYsV0FBZixFQUE0QkMsU0FBNUIsQ0FBaEI7O0FBQ0EsVUFBSUEsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCQSxpQkFBUyxDQUFDNEwsSUFBVixDQUFlN0wsV0FBZixFQUE0QkMsU0FBNUIsRUFBdUNFLFNBQXZDO0FBQ0g7O0FBQ0QsV0FBS3RjLE9BQUwsR0FBZXNjLFNBQWY7QUFDQSxXQUFLdGMsT0FBTCxDQUFhaW9CLEtBQWIsQ0FBbUI5TCxXQUFuQixFQUFnQ0MsU0FBaEM7QUFDSDtBQW5DTDtBQUFBO0FBQUEsOEJBaURjL1csSUFqRGQsRUFpRG9CO0FBQUEsa0NBQ2MrSCxPQUFPLENBQUNvUCxhQUFSLENBQXNCblgsSUFBdEIsQ0FEZDtBQUFBLFVBQ1A2aUIsS0FETyx5QkFDUEEsS0FETztBQUFBLFVBQ0E3ekIsSUFEQSx5QkFDQUEsSUFEQTtBQUFBLFVBQ01PLElBRE4seUJBQ01BLElBRE47O0FBRVosVUFBSUEsSUFBSSxLQUFLLFVBQVQsSUFBdUJ5USxJQUFJLElBQUksS0FBS3VpQixXQUF4QyxFQUFxRDtBQUNqRCxlQUFPLEtBQUtBLFdBQUwsQ0FBaUJ2aUIsSUFBakIsQ0FBUDtBQUNIOztBQUNELFVBQUk4aUIsY0FBYyxHQUFHLEtBQUt6YixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJpQyxJQUEzQixFQUFyQjs7QUFDQSxVQUFJdXpCLGNBQWMsS0FBS0MseUVBQWMsQ0FBQ3R6QixPQUF0QyxFQUErQztBQUMzQyxZQUFJVCxJQUFJLEtBQUssUUFBVCxJQUFxQk8sSUFBSSxLQUFLLEtBQWxDLEVBQXlDO0FBQ3JDLGNBQUksTUFBSXV6QixjQUFKLElBQXNCLEtBQUtQLFdBQS9CLEVBQTRDO0FBQ3hDLG1CQUFPLEtBQUtBLFdBQUwsQ0FBaUIsTUFBSU8sY0FBckIsQ0FBUDtBQUNILFdBRkQsTUFFTztBQUNIcHFCLG1CQUFPLENBQUMrWSxLQUFSLENBQWMsMkNBQWQsRUFBMkRxUixjQUEzRDtBQUNBLG1CQUFPLEtBQUtSLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxVQUFJL3lCLElBQUksSUFBSSxLQUFLZ3pCLFdBQWpCLEVBQThCO0FBQzFCLGVBQU8sS0FBS0EsV0FBTCxDQUFpQmh6QixJQUFqQixDQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxLQUFLK3lCLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNILE9BcEJXLENBcUJaOztBQUNIO0FBdkVMO0FBQUE7QUFBQSxrQ0FxQ3lCdGlCLElBckN6QixFQXFDK0I7QUFDdkIsVUFBSTZpQixLQUFLLEdBQUc3aUIsSUFBSSxDQUFDd1AsTUFBTCxDQUFZLENBQVosQ0FBWjs7QUFDQSxVQUFJMlMsa0JBQWtCLENBQUM5ZixPQUFuQixDQUEyQndnQixLQUEzQixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDN2lCLFlBQUksR0FBR0EsSUFBSSxDQUFDK0IsTUFBTCxDQUFZLENBQVosQ0FBUDtBQUNILE9BRkQsTUFFTztBQUNIOGdCLGFBQUssR0FBRyxFQUFSO0FBQ0g7O0FBQ0QsVUFBSTd6QixJQUFJLEdBQUdnUixJQUFJLENBQUMrQixNQUFMLENBQVksQ0FBWixFQUFlL0IsSUFBSSxDQUFDZ2pCLFdBQUwsQ0FBaUIsR0FBakIsQ0FBZixDQUFYO0FBQ0EsVUFBSXp6QixJQUFJLEdBQUd5USxJQUFJLENBQUMrQixNQUFMLENBQVkvQixJQUFJLENBQUNnakIsV0FBTCxDQUFpQixHQUFqQixDQUFaLENBQVg7QUFDQSxhQUFPO0FBQUMsaUJBQVNILEtBQVY7QUFBaUIsZ0JBQVE3ekIsSUFBekI7QUFBK0IsZ0JBQVFPO0FBQXZDLE9BQVA7QUFDSDtBQS9DTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBWU8sSUFBTXNZLGFBQWI7QUFDSSx5QkFBWVIsSUFBWixFQUFrQjtBQUFBOztBQUNkLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUs0YixjQUFMLEdBQXNCLEtBQUs1YixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBdEM7QUFFQSxTQUFLMHRCLGNBQUwsR0FBc0I7QUFDbEI3ZCxTQUFHLEVBQUUsSUFBSThkLDREQUFKLENBQXFCOWIsSUFBckIsQ0FEYTtBQUVsQitiLFVBQUksRUFBRSxJQUFJQyw4REFBSixDQUFzQmhjLElBQXRCLENBRlk7QUFHbEJ6WCxXQUFLLEVBQUUsSUFBSTB6QixpRUFBSixDQUF1QmpjLElBQXZCLENBSFc7QUFJbEJ4WCxjQUFRLEVBQUUsSUFBSTB6Qix1RUFBSixDQUEwQmxjLElBQTFCLENBSlE7QUFLbEJ2WCxZQUFNLEVBQUUsSUFBSTB6QixtRUFBSixDQUF3Qm5jLElBQXhCO0FBTFUsS0FBdEIsQ0FKYyxDQVlkOztBQUNBSixNQUFFLENBQUN3YyxTQUFILENBQWEsS0FBS1AsY0FBTCxDQUFvQjdkLEdBQXBCLENBQXdCcWUsZ0JBQXhCLEVBQWIsRUFiYyxDQWVkOztBQUNBLFNBQUt4WixlQUFMLEdBQXVCLEVBQXZCO0FBRUE7Ozs7O0FBSUEsU0FBS3laLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixJQUF0QjtBQUNIO0FBRUQ7Ozs7O0FBM0JKO0FBQUE7QUFBQSxtQ0E4Qm1CO0FBQ1gsVUFBSUMsTUFBTSxHQUFHLEtBQUtaLGNBQUwsQ0FBb0J4dEIsT0FBakM7QUFDQW91QixZQUFNLENBQUMsVUFBRCxDQUFOLEdBQXFCLEVBQXJCO0FBQ0FBLFlBQU0sQ0FBQyxRQUFELENBQU4sR0FBbUIsRUFBbkI7QUFDQUEsWUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQixFQUFwQjtBQUNBQSxZQUFNLENBQUMsWUFBRCxDQUFOLEdBQXVCLEVBQXZCO0FBQ0FBLFlBQU0sQ0FBQyxPQUFELENBQU4sR0FBa0IsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQTVCO0FBQ0g7QUFyQ0w7QUFBQTtBQUFBLHdDQXVDd0I7QUFDaEIsVUFBSWtILE9BQU8sR0FBRyxLQUFLb3RCLGNBQUwsQ0FBb0JwdEIsT0FBbEM7QUFDQUEsYUFBTyxDQUFDUyxLQUFSLEdBQWdCLEVBQWhCO0FBQ0FULGFBQU8sQ0FBQ0MsV0FBUixDQUFvQixJQUFwQjtBQUNBRCxhQUFPLENBQUNNLGdCQUFSLENBQXlCLENBQXpCO0FBQ0FOLGFBQU8sQ0FBQ0UsUUFBUixDQUFpQixDQUFqQjtBQUNBRixhQUFPLENBQUNHLFdBQVIsQ0FBb0IsSUFBcEI7QUFDQUgsYUFBTyxDQUFDSyxnQkFBUixDQUF5QjZYLFNBQXpCO0FBQ0FsWSxhQUFPLENBQUNPLE9BQVIsR0FBa0IsSUFBbEI7QUFDQVAsYUFBTyxDQUFDaXVCLE9BQVIsR0FBa0IsRUFBbEI7QUFDSDtBQWpETDtBQUFBO0FBQUEsMkNBbUQyQjtBQUNuQixXQUFLNVosZUFBTCxHQUF1QjtBQUNuQixpQkFBUyxFQURVO0FBRW5CLGdCQUFRLENBRlc7QUFHbkIsZ0JBQVE7QUFIVyxPQUF2QjtBQUtIO0FBekRMO0FBQUE7O0FBMkRJOzs7QUEzREosNEJBOERZO0FBQ0o7QUFDQTtBQUNBLFdBQUs2WixpQkFBTCxHQUhJLENBSUo7O0FBQ0EsV0FBS0MsWUFBTCxHQUxJLENBTUo7O0FBQ0EsV0FBS0Msb0JBQUwsR0FQSSxDQVFKOztBQUNBLFdBQUs1YyxJQUFMLENBQVV6UCxVQUFWLENBQXFCYyxPQUFyQixDQUE2Qm9WLEtBQTdCLEdBVEksQ0FVSjs7QUFDQSxXQUFLekcsSUFBTCxDQUFVelAsVUFBVixDQUFxQnBCLFFBQXJCLENBQThCc1gsS0FBOUI7QUFDSDtBQTFFTDtBQUFBO0FBQUEsaUNBNEVzQztBQUFBLFVBQXZCb1csZUFBdUIsdUVBQVAsS0FBTztBQUM5QjtBQUNBO0FBQ0EsV0FBSzdlLEdBQUwsQ0FBUzZlLGVBQVQsRUFIOEIsQ0FJOUI7QUFDSDtBQWpGTDtBQUFBO0FBQUEsMkJBbUZXLENBRU47QUFyRkw7QUFBQTtBQUFBLDBCQXVGK0I7QUFBQTs7QUFBQSxVQUF2QkEsZUFBdUIsdUVBQVAsS0FBTztBQUN2QixXQUFLNzJCLGFBQUwsR0FBcUIsS0FBSzYxQixjQUFMLENBQW9CN2QsR0FBcEIsQ0FBd0JqQixHQUF4QixDQUE0QixJQUE1QixDQUFyQjtBQUNBLFVBQUk1TyxTQUFTLEdBQUcsS0FBSzBQLE9BQUwsR0FBZWlmLElBQWYsQ0FDWixLQUFLOTJCLGFBQUwsQ0FBbUI2UixPQUFuQixDQUEyQnVELElBQTNCLENBQWdDLEtBQUtwVixhQUFyQyxDQURZLEVBRVosS0FBS0EsYUFBTCxDQUFtQisyQixPQUFuQixDQUEyQjNoQixJQUEzQixDQUFnQyxLQUFLcFYsYUFBckMsQ0FGWSxDQUFoQjs7QUFJQSxVQUFJLENBQUMsS0FBS2dhLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Dc3pCLGVBQXBDLEVBQUQsSUFBMEQsQ0FBQ0EsZUFBL0QsRUFBZ0Y7QUFDNUUxdUIsaUJBQVMsQ0FBQzJ1QixJQUFWLENBQWUsWUFBTTtBQUNqQixlQUFJLENBQUM5MkIsYUFBTCxDQUFtQmczQixrQkFBbkI7O0FBQ0EsaUJBQU8sS0FBSSxDQUFDejBCLEtBQUwsRUFBUDtBQUNILFNBSEQ7QUFJSCxPQUxELE1BS087QUFDSDRGLGlCQUFTLENBQUMydUIsSUFBVixDQUFlLEtBQUs5MkIsYUFBTCxDQUFtQmkzQixVQUFuQixDQUE4QjdoQixJQUE5QixDQUFtQyxLQUFLcFYsYUFBeEMsQ0FBZjtBQUNIOztBQUNEbUksZUFBUyxDQUFDMnVCLElBQVYsQ0FBZSxLQUFLOTJCLGFBQUwsWUFBMkJvVixJQUEzQixDQUFnQyxLQUFLcFYsYUFBckMsQ0FBZjtBQUNIO0FBdEdMO0FBQUE7QUFBQSw0QkF3R1k7QUFDSixXQUFLQSxhQUFMLEdBQXFCLEtBQUs2MUIsY0FBTCxDQUFvQnR6QixLQUFwQixDQUEwQndVLEdBQTFCLENBQThCLElBQTlCLENBQXJCO0FBQ0EsV0FBS2MsT0FBTCxHQUFlaWYsSUFBZixDQUNJLEtBQUs5MkIsYUFBTCxDQUFtQjZSLE9BQW5CLENBQTJCdUQsSUFBM0IsQ0FBZ0MsS0FBS3BWLGFBQXJDLENBREosRUFFSSxLQUFLQSxhQUFMLENBQW1CKzJCLE9BQW5CLENBQTJCM2hCLElBQTNCLENBQWdDLEtBQUtwVixhQUFyQyxDQUZKLEVBSUs4MkIsSUFKTCxDQUlVLEtBQUs5MkIsYUFBTCxZQUEyQm9WLElBQTNCLENBQWdDLEtBQUtwVixhQUFyQyxDQUpWLEVBS0s4MkIsSUFMTCxDQUtVLEtBQUtJLGFBQUwsQ0FBbUI5aEIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FMVjtBQU1IO0FBaEhMO0FBQUE7QUFBQSwrQkFrSGU7QUFBQTs7QUFDUCxXQUFLNEUsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDbUssTUFBL0M7QUFDQSxVQUFJNm1CLGVBQWUsR0FBRyxLQUFLbmQsSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJpTixRQUE3QixFQUF0QjtBQUNBak4sYUFBTyxDQUFDb08sR0FBUixDQUFZMGQsZUFBWjtBQUNBQSxxQkFBZSxDQUFDTCxJQUFoQixDQUFxQixVQUFDTSxTQUFELEVBQWU7QUFDaEMsY0FBSSxDQUFDcDNCLGFBQUwsR0FBcUIsTUFBSSxDQUFDNjFCLGNBQUwsQ0FBb0JFLElBQXBCLENBQXlCaGYsR0FBekIsQ0FBNkIsTUFBN0IsRUFBbUNxZ0IsU0FBbkMsQ0FBckI7O0FBQ0EsWUFBSWp2QixTQUFTLEdBQUcsTUFBSSxDQUFDMFAsT0FBTCxHQUFlaWYsSUFBZixDQUNaLE1BQUksQ0FBQzkyQixhQUFMLENBQW1CNlIsT0FBbkIsQ0FBMkJ1RCxJQUEzQixDQUFnQyxNQUFJLENBQUNwVixhQUFyQyxDQURZLEVBRVosTUFBSSxDQUFDQSxhQUFMLENBQW1CKzJCLE9BQW5CLENBQTJCM2hCLElBQTNCLENBQWdDLE1BQUksQ0FBQ3BWLGFBQXJDLENBRlksQ0FBaEI7O0FBSUEsWUFBSSxDQUFDLE1BQUksQ0FBQ2dhLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Dc3pCLGVBQXBDLEVBQUQsSUFDQSxNQUFJLENBQUM3YyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ3QyxNQUEzQixFQURKLEVBQ3lDO0FBQ3JDLGdCQUFJLENBQUN6QyxhQUFMLENBQW1CZzNCLGtCQUFuQjs7QUFDQTd1QixtQkFBUyxDQUFDMnVCLElBQVYsQ0FBZSxNQUFJLENBQUNyMEIsTUFBTCxDQUFZMlMsSUFBWixDQUFpQixNQUFqQixDQUFmO0FBQ0gsU0FKRCxNQUlPO0FBQ0hqTixtQkFBUyxDQUFDMnVCLElBQVYsQ0FBZSxNQUFJLENBQUM5MkIsYUFBTCxDQUFtQmkzQixVQUFuQixDQUE4QjdoQixJQUE5QixDQUFtQyxNQUFJLENBQUNwVixhQUF4QyxDQUFmLEVBQ0s4MkIsSUFETCxDQUNVLE1BQUksQ0FBQ3hlLFFBQUwsQ0FBY2xELElBQWQsQ0FBbUIsTUFBbkIsQ0FEVjtBQUVIOztBQUNEak4saUJBQVMsQ0FBQzJ1QixJQUFWLENBQWUsTUFBSSxDQUFDOTJCLGFBQUwsWUFBMkJvVixJQUEzQixDQUFnQyxNQUFJLENBQUNwVixhQUFyQyxDQUFmO0FBQ0gsT0FmRDtBQWdCSDtBQXRJTDtBQUFBO0FBQUEsNkJBd0lhO0FBQ0wsV0FBS0EsYUFBTCxHQUFxQixLQUFLNjFCLGNBQUwsQ0FBb0JwekIsTUFBcEIsQ0FBMkJzVSxHQUEzQixDQUErQixJQUEvQixDQUFyQjtBQUNBLFdBQUtjLE9BQUwsR0FBZWlmLElBQWYsQ0FDSSxLQUFLOTJCLGFBQUwsQ0FBbUI2UixPQUFuQixDQUEyQnVELElBQTNCLENBQWdDLEtBQUtwVixhQUFyQyxDQURKLEVBRUksS0FBS0EsYUFBTCxDQUFtQisyQixPQUFuQixDQUEyQjNoQixJQUEzQixDQUFnQyxLQUFLcFYsYUFBckMsQ0FGSixFQUlLODJCLElBSkwsQ0FJVSxLQUFLeGUsUUFBTCxDQUFjbEQsSUFBZCxDQUFtQixJQUFuQixDQUpWLEVBS0swaEIsSUFMTCxDQUtVLEtBQUs5MkIsYUFBTCxZQUEyQm9WLElBQTNCLENBQWdDLEtBQUtwVixhQUFyQyxDQUxWO0FBTUg7QUFoSkw7QUFBQTtBQUFBLCtCQWtKZTtBQUNQLFdBQUtBLGFBQUwsR0FBcUIsS0FBSzYxQixjQUFMLENBQW9CcnpCLFFBQXBCLENBQTZCdVUsR0FBN0IsQ0FBaUMsSUFBakMsQ0FBckI7QUFDSDtBQXBKTDtBQUFBO0FBQUEsOEJBc0pjO0FBQUE7O0FBQ04sV0FBS2lELElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyRSxNQUFoQixDQUF1QmlDLFdBQXZCLENBQW1DL0IsbURBQVcsQ0FBQ21LLE1BQS9DO0FBQ0EsYUFBT3NKLEVBQUUsQ0FBQ3lkLFFBQUgsQ0FBWUMsY0FBWixDQUEyQjtBQUFBLGVBQzlCMWQsRUFBRSxDQUFDMmQsa0JBQUgsQ0FBc0IsTUFBSSxDQUFDdjNCLGFBQUwsQ0FBbUJrRSxRQUF6QyxFQUFtRCxLQUFuRCxFQUNzQixNQUFJLENBQUNsRSxhQUFMLENBQW1CeUQsSUFEekMsRUFDK0MsSUFEL0MsRUFFc0IsTUFBSSxDQUFDekQsYUFBTCxDQUFtQmtKLFVBRnpDLENBRDhCO0FBQUEsT0FBM0IsQ0FBUDtBQUtIO0FBRUQ7Ozs7QUEvSko7QUFBQTtBQUFBLGdDQWtLZ0I7QUFDUixVQUFJc3VCLFFBQVEsR0FBRyxXQUFmLENBRFEsQ0FFUjs7QUFDQSxVQUFJLENBQUMsS0FBS3hkLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JtMkIsUUFBaEIsQ0FBeUJELFFBQXpCLElBQXFDalosSUFBckMsRUFBTCxFQUFrRDtBQUM5QyxlQUFPLEtBQVA7QUFDSDs7QUFDRCxXQUFLdkUsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCbEMsTUFBMUIsQ0FBaUMsVUFBakM7QUFDQSxXQUFLK1QsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJrdEIsUUFBNUIsR0FQUSxDQVFSOztBQUNBLFVBQUk3b0IsTUFBTSxHQUFHLElBQWI7QUFDQSxVQUFJMUYsUUFBUSxHQUFHLEtBQUs2USxJQUFMLENBQVV6UCxVQUFWLENBQXFCcEIsUUFBcEM7QUFDQTBGLFlBQU0sQ0FBQzhuQixZQUFQO0FBQ0E5bkIsWUFBTSxDQUFDOG9CLFVBQVA7QUFDQTlvQixZQUFNLENBQUMrb0IsV0FBUDtBQUNBL29CLFlBQU0sQ0FBQ2dwQixpQkFBUCxDQUF5QkwsUUFBekIsRUFBbUMsSUFBbkMsRUFBeUMsVUFBVU0sTUFBVixFQUFrQjtBQUN2RCxZQUFJbGUsRUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsWUFBcEIsRUFBa0MsU0FBbEMsQ0FBSixFQUFrRDtBQUM5QztBQUNBO0FBQ0EsY0FBSSxDQUFDbG1CLE9BQUQsSUFDQSxFQUFFeEksUUFBUSxLQUFLLFlBQWIsSUFBNkJDLEtBQUssS0FBSyxXQUF6QyxDQURKLEVBQzJEO0FBQ3ZESCxvQkFBUSxDQUFDNnVCLGVBQVQsQ0FBeUIzdUIsUUFBekIsRUFBbUNDLEtBQW5DLEVBQTBDRixPQUExQyxFQUFtRHVJLElBQW5EO0FBQ0g7O0FBQ0Q5QyxnQkFBTSxDQUFDbUwsSUFBUCxDQUFZelAsVUFBWixDQUF1QnBCLFFBQXZCLENBQWdDNnVCLGVBQWhDLENBQWdERixNQUFNLENBQUNHLEVBQXZEO0FBQ0FwcEIsZ0JBQU0sQ0FBQ21MLElBQVAsQ0FBWTFZLEtBQVosQ0FBa0I2RyxTQUFsQixDQUE0QmxDLE1BQTVCLENBQW1DLFVBQW5DO0FBQ0g7QUFDSixPQVhEO0FBWUE0SSxZQUFNLENBQUNtTCxJQUFQLENBQVl6UCxVQUFaLENBQXVCQyxNQUF2QixDQUE4QjVELFFBQTlCLENBQXVDLFFBQXZDLEVBQWlELFdBQWpEO0FBQ0g7QUE3TEw7QUFBQTs7QUFnTUk7Ozs7QUFoTUosb0NBb01vQjtBQUNaLFVBQUksS0FBSzJ2QixjQUFMLEtBQXdCLElBQTVCLEVBQWtDO0FBQzlCLGFBQUtBLGNBQUw7QUFDSDtBQUNKO0FBRUQ7Ozs7QUExTUo7QUFBQTtBQUFBLHNDQTZNc0I7QUFDZCxVQUFJLEtBQUtELGdCQUFMLEtBQTBCLElBQTlCLEVBQW9DO0FBQ2hDLGFBQUtBLGdCQUFMO0FBQ0g7QUFDSjtBQWpOTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCTyxJQUFNNEIsWUFBWSxHQUFHLG1EQUFyQjtBQUVQOzs7OztBQUlPLElBQU1DLGFBQWI7QUFFSSx5QkFBWW5lLElBQVosRUFBa0I7QUFBQTs7QUFDZCxTQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLOVYsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUtULElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBS3lGLFVBQUwsR0FBa0I5SSxTQUFsQjtBQUNIOztBQVBMO0FBQUE7QUFBQSx3QkFTUXlPLE1BVFIsRUFTZ0I7QUFBQTs7QUFDUjtBQUNBLFdBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBK0ssUUFBRSxDQUFDbWUsZ0JBQUgsR0FBc0IsS0FBSy9kLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBaEQ7QUFDQXdSLFFBQUUsQ0FBQ3ZPLE9BQUgsR0FBYSxLQUFLMk8sSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBbEM7QUFDQXVPLFFBQUUsQ0FBQzhGLFdBQUgsR0FBaUIsRUFBakI7QUFDQTlGLFFBQUUsQ0FBQ3djLFNBQUgsQ0FBYSxLQUFLQyxnQkFBTCxFQUFiLEVBTlEsQ0FPUjs7QUFDQXpjLFFBQUUsQ0FBQ3dlLFNBQUgsR0FBZSxLQUFLQyxRQUFMLENBQWNqakIsSUFBZCxDQUFtQixJQUFuQixDQUFmLENBUlEsQ0FTUjs7QUFDQXdFLFFBQUUsQ0FBQzBlLFNBQUgsR0FBZSxLQUFLQyxrQkFBTCxDQUF3Qm5qQixJQUF4QixDQUE2QixJQUE3QixDQUFmLENBVlEsQ0FXUjs7QUFDQXdFLFFBQUUsQ0FBQzRlLFdBQUgsR0FBaUIsVUFBQ3YyQixHQUFELEVBQU1tSixJQUFOLEVBQVlxdEIsT0FBWjtBQUFBLGVBQXdCLEtBQUksQ0FBQ0MsT0FBTCxDQUFhejJCLEdBQWIsRUFBa0JtSixJQUFsQixFQUF3QnF0QixPQUF4QixDQUF4QjtBQUFBLE9BQWpCLENBWlEsQ0FhUjs7O0FBQ0E3ZSxRQUFFLENBQUMrZSxjQUFILEdBQW9CLFVBQUNDLFVBQUQsRUFBYUMsU0FBYixFQUEyQjtBQUMzQyxZQUFJLEtBQUksQ0FBQzdlLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DdTFCLGNBQXBDLEVBQUosRUFBMEQ7QUFDdEQsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQUlsYSxhQUFhLEdBQUcsS0FBSSxDQUFDbWEsZ0JBQUwsQ0FBc0JILFVBQVUsR0FBQyxJQUFYLEdBQWtCLEVBQXhDLENBQXBCOztBQUNBLFlBQUlJLEtBQUssR0FBR3ZkLE1BQU0sQ0FBQ21ELGFBQUQsRUFBZ0JoRixFQUFFLENBQUNpZixTQUFILEdBQWEsSUFBN0IsQ0FBbEI7O0FBQ0EsWUFBSUcsS0FBSyxLQUFLLElBQVYsSUFBa0JBLEtBQUssSUFBRSxDQUE3QixFQUFnQztBQUM1QkEsZUFBSyxHQUFHcGYsRUFBRSxDQUFDaWYsU0FBSCxHQUFlSSxRQUFRLENBQUNELEtBQUQsRUFBUSxFQUFSLENBQVIsR0FBc0IsSUFBN0M7QUFDQXBmLFlBQUUsQ0FBQ2lmLFNBQUgsR0FBZUcsS0FBZjs7QUFDQXBmLFlBQUUsQ0FBQ3NmLGlCQUFILEdBQXVCO0FBQUEsbUJBQ25CLEtBQUksQ0FBQ2xmLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DdTFCLGNBQXBDLEtBQXVESyxRQUF2RCxHQUFrRUgsS0FEL0M7QUFBQSxXQUF2QjtBQUVIOztBQUNELGVBQU9BLEtBQVA7QUFDSCxPQWJELENBZFEsQ0E0QlI7OztBQUNBcGYsUUFBRSxDQUFDd2YsVUFBSCxHQUFnQixLQUFLQSxVQUFMLENBQWdCaGtCLElBQWhCLENBQXFCLElBQXJCLENBQWhCO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7QUF4Q0w7QUFBQTtBQUFBLHFDQTBDcUJpa0IsV0ExQ3JCLEVBMENrQztBQUMxQixVQUFJQSxXQUFKLEVBQWlCO0FBQ2IsZUFBTyxpS0FBUDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8scUZBQVA7QUFDSDtBQUNKO0FBaERMO0FBQUE7QUFBQSx1Q0FrRHVCO0FBQ2YsYUFBTztBQUNIQyxrQkFBVSxFQUFFMWYsRUFBRSxDQUFDMmYsT0FEWjtBQUVIO0FBQ0FDLFlBQUksRUFBRSxLQUFLQyxVQUFMLENBQWdCcmtCLElBQWhCLENBQXFCLElBQXJCLENBSEg7QUFJSDtBQUNBO0FBQ0E7QUFDQXNrQixpQkFBUyxFQUFFLEtBQUtDLFNBQUwsQ0FBZXZrQixJQUFmLENBQW9CLElBQXBCLENBUFI7QUFRSDtBQUNBL00sY0FBTSxFQUFFLEtBQUt1eEIsS0FBTCxDQUFXeGtCLElBQVgsQ0FBZ0IsSUFBaEIsQ0FUTDtBQVVIO0FBQ0F5a0IsZ0JBQVEsRUFBRSxLQUFLdnhCLEtBQUwsQ0FBVzhNLElBQVgsQ0FBZ0IsSUFBaEIsQ0FYUDtBQVlIMGtCLDJCQUFtQixFQUFFLElBWmxCO0FBYUg7QUFDQUMsa0JBQVUsRUFBRSxLQUFLQyxhQUFMLENBQW1CNWtCLElBQW5CLENBQXdCLElBQXhCLENBZFQ7QUFlSDtBQUNBNmtCLGtCQUFVLEVBQUUsb0JBQUNDLElBQUQ7QUFBQSxtRUFBcURBLElBQUksQ0FBQ25yQixXQUFMLEVBQXJEO0FBQUEsU0FoQlQ7QUFpQkg7QUFDQW9yQixxQkFBYSxFQUFFO0FBbEJaLE9BQVA7QUFvQkg7QUF2RUw7QUFBQTtBQUFBLHVDQXlFdUJqMkIsUUF6RXZCLEVBeUVpQztBQUN6QixVQUFNazJCLEtBQUssR0FBRyxLQUFLcGdCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQzZ1QixXQUFoQyxDQUE0Q24yQixRQUE1QyxDQUFkOztBQUNBLFVBQUlrMkIsS0FBSyxLQUFLaDZCLFNBQWQsRUFBeUI7QUFDckIsY0FBTSxJQUFJd1osRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV0MsT0FBZixDQUF1QixxQkFBcUJyMkIsUUFBNUMsQ0FBTjtBQUNIOztBQUNELGFBQU9rMkIsS0FBUDtBQUNIO0FBRUQ7Ozs7Ozs7OztBQWpGSjtBQUFBO0FBQUEsK0JBeUZlbDJCLFFBekZmLEVBeUZ5QjtBQUNqQm1ILGFBQU8sQ0FBQ212QixJQUFSLENBQWEsdUJBQWIsRUFEaUIsQ0FFakI7QUFDSDtBQTVGTDtBQUFBO0FBQUEsNEJBOEZZdjRCLEdBOUZaLEVBOEZpQm1KLElBOUZqQixFQThGdUJxdEIsT0E5RnZCLEVBOEZnQztBQUN4QjtBQUNBLFVBQUlnQyxXQUFXLEdBQUcsS0FBS3pnQixJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NxSSxPQUFoQyxDQUF3QyxvQkFBeEMsQ0FBbEI7O0FBQ0EsVUFBSTRtQixXQUFXLElBQUksSUFBbkIsRUFBeUI7QUFDckIsY0FBTyxJQUFJN2dCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdJLE9BQWYsQ0FBdUIsd0VBQXZCLENBQVA7QUFDSDs7QUFDREQsaUJBQVcsR0FBR3RuQixJQUFJLENBQUNnRyxLQUFMLENBQVdzaEIsV0FBVyxDQUFDMW1CLE1BQVosRUFBWCxDQUFkOztBQUNBLFdBQUssSUFBSTdQLFFBQVQsSUFBcUJ1MkIsV0FBckIsRUFBa0M7QUFDOUIsWUFBSUEsV0FBVyxDQUFDRSxjQUFaLENBQTJCejJCLFFBQTNCLENBQUosRUFBMEM7QUFDdEMsZUFBSyxJQUFJcWUsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHa1ksV0FBVyxDQUFDdjJCLFFBQUQsQ0FBWCxDQUFzQjRPLE1BQXhDLEVBQWdEeVAsQ0FBQyxJQUFHLENBQXBELEVBQXVEO0FBQ25ELGdCQUFJa1ksV0FBVyxDQUFDdjJCLFFBQUQsQ0FBWCxDQUFzQnFlLENBQXRCLE1BQTZCdGdCLEdBQWpDLEVBQXNDO0FBQ2xDLGtCQUFJMjRCLFFBQVEsR0FBRyxLQUFLNWdCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3F2QixRQUFoQyxDQUF5QzMyQixRQUF6QyxDQUFmO0FBQ0EscUJBQVEwMkIsUUFBUjtBQUNIO0FBQ0o7QUFDSjtBQUNKLE9BaEJ1QixDQWlCeEI7OztBQUNBLFlBQU8sSUFBSWhoQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXSSxPQUFmLENBQXVCLHdCQUFzQno0QixHQUF0QixHQUEwQiw2Q0FBakQsQ0FBUCxDQWxCd0IsQ0FtQnhCO0FBQ0g7QUFsSEw7QUFBQTtBQUFBLCtCQW9IZTtBQUNQb0osYUFBTyxDQUFDbXZCLElBQVIsQ0FBYSx1QkFBYixFQURPLENBRVA7QUFDSDtBQXZITDtBQUFBO0FBQUEsZ0NBeUhnQjtBQUNSbnZCLGFBQU8sQ0FBQ212QixJQUFSLENBQWEsdUJBQWIsRUFEUSxDQUVSO0FBQ0g7QUE1SEw7QUFBQTtBQUFBLDBCQThIVTVYLEtBOUhWLEVBOEhpQjtBQUNULFdBQUs1SSxJQUFMLENBQVV6UCxVQUFWLENBQXFCYyxPQUFyQixDQUE2QnV1QixLQUE3QixDQUFtQ2hYLEtBQW5DO0FBQ0g7QUFoSUw7QUFBQTtBQUFBLDRCQWtJWTtBQUNKdlgsYUFBTyxDQUFDbXZCLElBQVIsQ0FBYSx1QkFBYixFQURJLENBRUo7QUFDSDtBQXJJTDtBQUFBO0FBQUEsaUNBdUlpQjtBQUNULFVBQUksS0FBS3hnQixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0J1QixXQUF4QixFQUFKLEVBQTJDO0FBQ3ZDLGFBQUt3VSxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJHLEtBQTFCLENBQWdDLEVBQWhDO0FBQ0g7O0FBQ0QsV0FBSzBSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkksVUFBMUIsQ0FBcUMsQ0FBckM7QUFDSDtBQTVJTDtBQUFBO0FBQUEsa0NBc0prQnRHLEdBdEpsQixFQXNKdUI7QUFDZjtBQUNBLGFBQU9BLEdBQVA7QUFDSDtBQXpKTDtBQUFBO0FBQUEsMkJBMkpXLENBRU47QUE3Skw7QUFBQTtBQUFBLCtCQStKZSxDQUVWO0FBaktMO0FBQUE7QUFBQSxnQ0FtS2dCaUMsUUFuS2hCLEVBbUswQjtBQUNsQixhQUFPLEtBQVA7QUFDSDtBQXJLTDtBQUFBO0FBQUEsNEJBdUtZNHpCLE1BdktaLEVBdUtvQjtBQUNaLFlBQU0sSUFBSWdELEtBQUosQ0FBVSw0QkFBVixDQUFOO0FBQ0g7QUF6S0w7QUFBQTtBQUFBLDRCQTJLWTFXLEtBM0taLEVBMkttQjtBQUNYLFlBQU0sSUFBSTBXLEtBQUosQ0FBVSw0QkFBVixDQUFOO0FBQ0g7QUE3S0w7QUFBQTtBQUFBLDZCQStLWTFoQixNQS9LWixFQStLb0I7QUFDWjtBQUNBLFVBQUksS0FBS1ksSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJnVyxVQUFqQyxFQUE2QztBQUN6QyxhQUFLckgsSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJnVyxVQUE3QixDQUF3Q3RELE9BQXhDO0FBQ0EsYUFBSy9ELElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCZ1csVUFBN0IsQ0FBd0MwWixJQUF4QztBQUNIO0FBQ0o7QUFyTEw7QUFBQTtBQUFBLHNDQXVMc0IsQ0FDZDtBQUNIO0FBekxMO0FBQUE7QUFBQSwrQkEyTGVDLFlBM0xmLEVBMkw2QkMsT0EzTDdCLEVBMkxzQ0MsTUEzTHRDLEVBMkw4QztBQUN0QztBQUNBO0FBQ0EsVUFBSUMsWUFBWSxHQUFHLEtBQUtuaEIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQ0ksT0FBckQ7O0FBQ0EsVUFBSSxFQUFFLFdBQVcyeUIsWUFBYixDQUFKLEVBQWdDO0FBQzVCQSxvQkFBWSxDQUFDbHlCLEtBQWIsR0FBcUIsRUFBckI7QUFDSDs7QUFDRCxVQUFJLEVBQUUreEIsWUFBWSxJQUFJRyxZQUFZLENBQUNseUIsS0FBL0IsQ0FBSixFQUEyQztBQUN2Q2t5QixvQkFBWSxDQUFDbHlCLEtBQWIsQ0FBbUIreEIsWUFBbkIsSUFBbUMsRUFBbkM7QUFDSDs7QUFDRCxVQUFJSSxJQUFJLEdBQUcsRUFBWCxDQVZzQyxDQVd0Qzs7QUFDQSxXQUFLLElBQUk3WSxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUcwWSxPQUFPLENBQUNub0IsTUFBMUIsRUFBa0N5UCxDQUFDLElBQUcsQ0FBdEMsRUFBeUM7QUFDckM2WSxZQUFJLENBQUMsVUFBUTdZLENBQVQsQ0FBSixHQUFrQjBZLE9BQU8sQ0FBQzFZLENBQUQsQ0FBekI7QUFDSDs7QUFDRCxVQUFJMlksTUFBTSxJQUFJQSxNQUFNLENBQUMsQ0FBRCxDQUFOLElBQWEsSUFBM0IsRUFBaUM7QUFDN0JFLFlBQUksQ0FBQyxRQUFELENBQUosR0FBaUJGLE1BQU0sQ0FBQyxDQUFELENBQXZCO0FBQ0g7O0FBQ0QsVUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUMsQ0FBRCxDQUFOLElBQWEsSUFBM0IsRUFBaUM7QUFDN0JFLFlBQUksQ0FBQyxVQUFELENBQUosR0FBbUJGLE1BQU0sQ0FBQyxDQUFELENBQXpCO0FBQ0gsT0FwQnFDLENBcUJ0Qzs7O0FBQ0FDLGtCQUFZLENBQUNseUIsS0FBYixDQUFtQit4QixZQUFuQixFQUFpQ3JiLElBQWpDLENBQXNDeWIsSUFBdEM7QUFDSDtBQWxOTDtBQUFBO0FBQUEsd0NBOEkrQjtBQUN2QixVQUFJeGhCLEVBQUUsQ0FBQzhGLFdBQUgsQ0FBZTVNLE1BQW5CLEVBQTJCO0FBQ3ZCLGVBQU84RyxFQUFFLENBQUM4RixXQUFILENBQWUyYixHQUFmLEVBQVA7QUFDSCxPQUZELE1BRU87QUFDSCxlQUFPLEVBQVA7QUFDSDtBQUNKO0FBcEpMOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUVPLElBQU1yRixpQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1FubkIsTUFEUixFQUNnQnBMLElBRGhCLEVBQ3NCO0FBQ2Q7QUFDQSxXQUFLdVcsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNDLE9BQW5DLENBQTJDLFlBQTNDO0FBQ0EsV0FBS2xGLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxXQUFLVCxJQUFMLEdBQVksU0FBU0EsSUFBckI7QUFDQW1XLFFBQUUsQ0FBQzBoQixvQkFBSCxHQUEwQixJQUExQjtBQUNBMWhCLFFBQUUsQ0FBQ3dmLFVBQUgsR0FBZ0IsSUFBaEI7O0FBRUEsaUZBQVV2cUIsTUFBVjs7QUFFQStLLFFBQUUsQ0FBQ3VnQixhQUFILEdBQW1CLElBQW5CO0FBQ0F2Z0IsUUFBRSxDQUFDNVEsT0FBSCxHQUFhLEtBQUtnUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUSxPQUFsQyxFQUFiO0FBRUEsV0FBS2dSLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCNUQsUUFBNUIsQ0FBcUMsWUFBckMsRUFBbUQsRUFBbkQsRUFBdUQsRUFBdkQsRUFBMkRuRCxJQUEzRCxFQUFpRSxhQUFqRTtBQUNBLFdBQUt1VyxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjVELFFBQTVCLENBQXFDLFNBQXJDLEVBQWdELEVBQWhELEVBQW9ELEVBQXBELEVBQXdELEtBQUtuRCxJQUE3RCxFQUFtRSxhQUFuRTtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBbEJMO0FBQUE7QUFBQSw0QkFvQllxMEIsTUFwQlosRUFvQm9CO0FBQUE7O0FBQ1p6c0IsYUFBTyxDQUFDb08sR0FBUixDQUFZLGNBQVo7QUFDQSxXQUFLTyxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjVELFFBQTVCLENBQXFDLG9CQUFyQyxFQUEyRCxFQUEzRCxFQUErRCxFQUEvRCxFQUFtRSxFQUFuRSxFQUF1RSxhQUF2RTtBQUNBLFdBQUtvVCxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkUsTUFBaEIsQ0FBdUJpQyxXQUF2QixDQUFtQy9CLG1EQUFXLENBQUNDLEtBQS9DO0FBQ0EsV0FBSzRULElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NRLE9BQWxDLENBQTBDNFEsRUFBRSxDQUFDNVEsT0FBN0M7QUFDQTRRLFFBQUUsQ0FBQzVRLE9BQUgsR0FBYSxFQUFiO0FBQ0EsVUFBSXd0QixNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkM7QUFDQSxVQUFJbEUsUUFBUSxHQUFHLEtBQUtBLFFBQXBCO0FBQ0EsV0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NPLE9BQWxDLEdBQTRDK3VCLE1BQTVDO0FBQ0EsV0FBSzlkLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCa3dCLFVBQTdCLENBQXdDM2hCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUIxRCxNQUFNLENBQUNHLEVBQVAsQ0FBVXdELENBQVYsQ0FBWUMsRUFBWixFQUFqQixDQUF4QztBQUNBLGFBQU8sSUFBSXBjLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVzUSxNQUFWLEVBQXFCO0FBQ3BDO0FBQ0EsYUFBSSxDQUFDbm5CLFFBQUw7O0FBQ0E4dEIsY0FBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjtBQUNoQixxQkFBVyxJQURLO0FBRWhCLG1CQUFTLEtBQUksQ0FBQzNuQixNQUFMLENBQVlnTyxlQUFaLENBQTRCdEwsS0FGckI7QUFHaEIsbUJBQVMsS0FBSSxDQUFDMUMsTUFBTCxDQUFZZ08sZUFBWixDQUE0QnRMLEtBQTVCLENBQWtDa0QsR0FBbEMsQ0FBc0MsVUFBQWtuQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ2hxQixJQUFOO0FBQUEsV0FBdkMsQ0FITztBQUloQix1QkFBYSxLQUFJLENBQUM5QyxNQUFMLENBQVlnTyxlQUFaLENBQTRCdEwsS0FBNUIsQ0FBa0NpWixNQUFsQyxDQUF5QyxVQUFBbVIsQ0FBQztBQUFBLG1CQUFJLENBQUNBLENBQUMsQ0FBQ0MsV0FBUDtBQUFBLFdBQTFDLEVBQThEbm5CLEdBQTlELENBQWtFLFVBQUFrbkIsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLENBQUNocUIsSUFBTjtBQUFBLFdBQW5FLENBSkc7QUFLaEIscUJBQVdtbUIsTUFMSztBQU1oQixvQkFBVSxLQUFJLENBQUM5ZCxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJFLE1BTnBCO0FBT2hCLHdCQUFjLEtBQUksQ0FBQzVFLElBUEg7QUFRaEIsbUJBQVMsS0FBSSxDQUFDdVcsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ1MsS0FSM0I7QUFTaEIscUJBQVc7QUFUSyxTQUFwQjtBQVdBc1csZUFBTztBQUNWLE9BZk0sQ0FBUDtBQWdCSDtBQTlDTDtBQUFBO0FBQUEsNEJBZ0RZNkUsS0FoRFosRUFnRG1CO0FBQUE7O0FBQ1gvWSxhQUFPLENBQUNvTyxHQUFSLENBQVksY0FBWixFQUE0QjJLLEtBQTVCO0FBQ0EsV0FBS3BLLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyRSxNQUFoQixDQUF1QmlDLFdBQXZCLENBQW1DL0IsbURBQVcsQ0FBQ3VzQixNQUEvQztBQUNBLFVBQUk4RCxNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkM7QUFDQSxXQUFLNFIsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1RCxRQUE1QixDQUFxQyxlQUFyQyxFQUFzRCxFQUF0RCxFQUEwRCxFQUExRCxFQUE4RHdkLEtBQUssQ0FBQ3hlLFFBQU4sRUFBOUQsRUFBZ0YsYUFBaEY7QUFDQSxhQUFPLElBQUkwWixPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVc1EsTUFBVixFQUFxQjtBQUNwQzJHLGNBQU0sQ0FBQyxTQUFELENBQU4sR0FBb0I7QUFDaEIscUJBQVcsS0FESztBQUVoQixtQkFBU3BTLEtBRk87QUFHaEIsd0JBQWMsTUFBSSxDQUFDM2dCLElBSEg7QUFJaEIscUJBQVc7QUFKSyxTQUFwQjtBQU1BOGIsZUFBTztBQUNWLE9BUk0sQ0FBUDtBQVNIO0FBOURMOztBQUFBO0FBQUEsRUFBdUNzYyw2REFBdkMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBTUMsbUJBQW1CLEdBQUcsMEJBQTBCQyxvRkFBa0IsQ0FBQ24yQixRQUFuQixFQUF0RDtBQUNBLElBQU1vMkIsb0JBQW9CLEdBQUdDLHlFQUE3QjtBQUVPLElBQU1DLHVCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUXJ0QixNQURSLEVBQ2dCO0FBQUE7O0FBQ1IsdUZBQVVBLE1BQVYsRUFEUSxDQUVSOzs7QUFDQStLLFFBQUUsQ0FBQ3NmLGlCQUFILEdBQXVCO0FBQUEsZUFDbkIsS0FBSSxDQUFDbGYsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0N1MUIsY0FBcEMsS0FBdURLLFFBQXZELEdBQWtFLElBRC9DO0FBQUEsT0FBdkI7O0FBRUF2ZixRQUFFLENBQUNpZixTQUFILEdBQWVqZixFQUFFLENBQUNzZixpQkFBSCxFQUFmLENBTFEsQ0FNUjs7QUFDQXRmLFFBQUUsQ0FBQzBoQixvQkFBSCxHQUEwQixJQUExQixDQVBRLENBT3dCO0FBQ2hDOztBQUNBLFdBQUt0aEIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRyxXQUF4QixDQUFvQyxJQUFwQyxFQVRRLENBVVI7O0FBQ0F3VixRQUFFLENBQUM4RixXQUFILEdBQWlCLEVBQWpCLENBWFEsQ0FZUjtBQUNBO0FBQ0E7O0FBQ0E5RixRQUFFLENBQUN1aUIsZ0JBQUgsR0FBc0J2aUIsRUFBRSxDQUFDd2YsVUFBekI7QUFDQXhmLFFBQUUsQ0FBQ3dmLFVBQUgsR0FBZ0IsSUFBaEIsQ0FoQlEsQ0FpQlI7O0FBQ0F4ZixRQUFFLENBQUNDLFlBQUgsQ0FBZ0JySCxLQUFoQixDQUFzQiw2QkFBdEIsSUFBdURzcEIsbUJBQXZEO0FBQ0FsaUIsUUFBRSxDQUFDQyxZQUFILENBQWdCckgsS0FBaEIsQ0FBc0IscUJBQXRCLElBQStDd3BCLG9CQUEvQyxDQW5CUSxDQW9CUjtBQUNBOztBQUNBcGlCLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLGlDQUF0QixJQUEyRDRwQiwwRUFBM0Q7QUFDQSxhQUFPeGlCLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLGlDQUF0QixDQUFQLENBdkJRLENBd0JSOztBQUNBb0gsUUFBRSxDQUFDQyxZQUFILENBQWdCckgsS0FBaEIsQ0FBc0IsMkJBQXRCLElBQXFEMGxCLCtEQUFyRCxDQXpCUSxDQTBCUjs7QUFDQSxXQUFLaHZCLFVBQUwsR0FBa0IsS0FBS216QiwyQkFBTCxFQUFsQixDQTNCUSxDQTRCUjs7QUFDQXppQixRQUFFLENBQUN5aUIsMkJBQUgsR0FBaUMsS0FBS0EsMkJBQXRDO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7QUFoQ0w7QUFBQTtBQUFBLDBCQWtDVXpaLEtBbENWLEVBa0NpQjtBQUNULHlGQUFZQSxLQUFaOztBQUNBdlgsYUFBTyxDQUFDaXhCLElBQVIsQ0FBYSxVQUFiLEVBQXlCMVosS0FBekI7QUFDSDtBQXJDTDtBQUFBO0FBQUEsa0RBdUNrQztBQUMxQixVQUFJMVosVUFBVSxHQUFHLEtBQUs4USxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJoRSxVQUExQixDQUFxQytFLFVBQXRELENBRDBCLENBRTFCOztBQUNBLFVBQUlBLFVBQVUsS0FBSzlJLFNBQW5CLEVBQThCO0FBQUEsbURBQ0wsS0FBS204QixlQUFMLEVBREs7QUFBQTs7QUFBQTtBQUMxQiw4REFBNkM7QUFBQSxnQkFBcENyNEIsUUFBb0M7QUFDekMsZ0JBQUlzNEIsVUFBVSxHQUFHLElBQUk1aUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21DLEdBQWYsQ0FBbUJ2NEIsUUFBbkIsQ0FBakI7QUFDQTs7OztBQUdBZ0Ysc0JBQVUsQ0FBQ3d6QixRQUFYLENBQW9CRixVQUFwQjtBQUNIO0FBUHlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRN0I7O0FBQ0QsYUFBT3R6QixVQUFQO0FBQ0g7QUFwREw7QUFBQTtBQUFBLHlDQXNEeUI7QUFDakIsVUFBTXNKLEtBQUssR0FBRztBQUNWLHFCQUFhLEtBQUt3SCxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUJ1RixLQUFuQixDQUF5Qm1CLGNBQXpCO0FBREgsT0FBZCxDQURpQixDQUlqQjs7QUFDQSxXQUFLcUcsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQTNCLEdBQWtEK2dCLE9BQWxELENBQTBELFVBQUE1USxJQUFJLEVBQUk7QUFDOUQsWUFBSSxDQUFFLE9BQU84cEIsUUFBUCxDQUFnQjlwQixJQUFJLENBQUMzTyxRQUFMLEdBQWdCLENBQWhCLENBQWhCLENBQU4sRUFBNEM7QUFDeENzTyxlQUFLLENBQUNvcUIsK0RBQWdCLENBQUMvcEIsSUFBSSxDQUFDM08sUUFBTCxFQUFELENBQWpCLENBQUwsR0FBMkMyTyxJQUFJLENBQUMrQixRQUFMLEVBQTNDO0FBQ0g7QUFDSixPQUpELEVBTGlCLENBVWpCOztBQUNBLFdBQUtvRixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUEzQixHQUF3QzhmLE9BQXhDLENBQWdELFVBQUE1USxJQUFJLEVBQUk7QUFDcERMLGFBQUssQ0FBQ0ssSUFBSSxDQUFDM08sUUFBTCxFQUFELENBQUwsR0FBeUIyTyxJQUFJLENBQUMrQixRQUFMLEVBQXpCO0FBQ0gsT0FGRDtBQUdBLGFBQU9wQyxLQUFQO0FBQ0g7QUFyRUw7QUFBQTtBQUFBLHNDQXVFc0I7QUFDZCxlQUFTcXFCLEtBQVQsQ0FBZTM0QixRQUFmLEVBQXlCO0FBQ3JCQSxnQkFBUSxHQUFHMDRCLCtEQUFnQixDQUFDMTRCLFFBQUQsQ0FBM0I7O0FBQ0EsWUFBSUEsUUFBUSxDQUFDa3VCLFFBQVQsQ0FBa0IsS0FBbEIsQ0FBSixFQUE4QjtBQUMxQmx1QixrQkFBUSxHQUFHQSxRQUFRLENBQUNrUSxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFDLENBQW5CLENBQVg7QUFDSDs7QUFDRCxlQUFPbFEsUUFBUDtBQUNIOztBQUNELGNBQ0ksVUFESixFQUVJLGFBRkosNEJBR08sS0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUEzQixHQUFrRCtSLEdBQWxELENBQXNELFVBQUE1QixJQUFJO0FBQUEsZUFBSSxpQkFBaUJncUIsS0FBSyxDQUFDaHFCLElBQUksQ0FBQzNPLFFBQUwsRUFBRCxDQUExQjtBQUFBLE9BQTFELENBSFAsc0JBSU8sS0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnlELFVBQTNCLEdBQXdDOFEsR0FBeEMsQ0FBNEMsVUFBQTVCLElBQUk7QUFBQSxlQUFJZ3FCLEtBQUssQ0FBQ2hxQixJQUFJLENBQUMzTyxRQUFMLEVBQUQsQ0FBVDtBQUFBLE9BQWhELENBSlA7QUFNSDtBQXJGTDtBQUFBO0FBQUEscUNBdUZxQm0xQixXQXZGckIsRUF1RmtDO0FBQzFCLFVBQUlBLFdBQUosRUFBaUI7QUFDYixlQUFPLHNOQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyx1SkFBUDtBQUNIO0FBQ0o7QUE3Rkw7QUFBQTtBQUFBLDZCQStGYW4xQixRQS9GYixFQStGdUI7QUFDZixVQUFJazJCLEtBQUssR0FBRyxLQUFLcGdCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3N4QixhQUFoQyxDQUE4QzU0QixRQUE5QyxFQUF3RCxLQUF4RCxDQUFaOztBQUNBLFVBQUlrMkIsS0FBSyxLQUFLaDZCLFNBQWQsRUFBeUI7QUFDckIsY0FBTSxJQUFJd1osRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV0MsT0FBZixDQUF1QixxQkFBbUJyMkIsUUFBMUMsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNILGVBQU9rMkIsS0FBSyxDQUFDeGxCLFFBQU4sRUFBUDtBQUNIO0FBQ0o7QUF0R0w7QUFBQTtBQUFBLDRCQXdHWTNTLEdBeEdaLEVBd0dpQm1KLElBeEdqQixFQXdHdUJxdEIsT0F4R3ZCLEVBd0dnQztBQUN4QjtBQUNBLFVBQUlydEIsSUFBSSxDQUFDMnhCLENBQUwsS0FBVyxRQUFmLEVBQXlCO0FBQ3JCLGVBQU8sS0FBSy9pQixJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0Qnd5QixXQUE1QixDQUF3Q3ZFLE9BQU8sQ0FBQ3NFLENBQWhELENBQVA7QUFDSCxPQUZELE1BRU87QUFDSCxvR0FBcUI5NkIsR0FBckIsRUFBMEJtSixJQUExQixFQUFnQ3F0QixPQUFoQztBQUNIO0FBQ0o7QUEvR0w7QUFBQTtBQUFBLCtCQWlIZXYwQixRQWpIZixFQWlIeUI7QUFDakIsVUFBSUEsUUFBUSxLQUFLLGFBQWpCLEVBQWdDO0FBQzVCLGVBQU8sS0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLEVBQVA7QUFDSCxPQUZELE1BRU8sSUFBSVMsUUFBUSxLQUFLLHlCQUFqQixFQUE0QztBQUMvQyxlQUFPLEtBQUs4VixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUEzQixFQUFQO0FBQ0gsT0FGTSxNQUVBLElBQUkyQixRQUFRLEtBQUssMEJBQWpCLEVBQTZDO0FBQ2hELGVBQU8sS0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQTNCLE1BQXVDLEVBQTlDO0FBQ0gsT0FGTSxNQUVBLElBQUl5QixRQUFRLEtBQUssMkJBQWpCLEVBQThDO0FBQ2pELGVBQU9nMEIsK0RBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSXRlLEVBQUUsQ0FBQ0MsWUFBSCxLQUFvQnpaLFNBQXhCLEVBQW1DO0FBQ3RDLGNBQU0sSUFBSXdaLEVBQUUsQ0FBQzBnQixPQUFILENBQVdDLE9BQWYsQ0FBdUIsa0NBQXZCLENBQU47QUFDSCxPQUZNLE1BRUEsSUFBSTNnQixFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIzVixRQUF6QixNQUF1QzlELFNBQTNDLEVBQXNEO0FBQ3pELGVBQU93WixFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIzVixRQUF6QixDQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsWUFBSWsyQixLQUFLLEdBQUcsS0FBS3BnQixJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NzeEIsYUFBaEMsQ0FBOEM1NEIsUUFBOUMsRUFBd0QsS0FBeEQsQ0FBWjs7QUFDQSxZQUFJazJCLEtBQUssS0FBS2g2QixTQUFkLEVBQXlCO0FBQ3JCLGdCQUFNLElBQUl3WixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXQyxPQUFmLENBQXVCLHNCQUFvQnIyQixRQUFwQixHQUErQixHQUF0RCxDQUFOO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQU9rMkIsS0FBSyxDQUFDeGxCLFFBQU4sRUFBUDtBQUNIO0FBQ0o7QUFDSjtBQXRJTDtBQUFBO0FBQUEsMEJBd0lVZ0ssYUF4SVYsRUF3SXlCO0FBQ2pCO0FBQ0F2VCxhQUFPLENBQUNvTyxHQUFSLENBQVksS0FBWixFQUFtQixLQUFLTyxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJHLEtBQTFCLEVBQW5CLEVBQXNELEtBQUswUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJJLFVBQTFCLEVBQXREOztBQUNBLFVBQUksS0FBS3lSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkksVUFBMUIsS0FBeUMsS0FBS3lSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0N3SyxNQUEvRSxFQUF1RjtBQUNuRixZQUFJdkssVUFBVSxHQUFHLEtBQUt5UixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJJLFVBQTFCLEVBQWpCO0FBQ0EsWUFBSTAwQixTQUFTLEdBQUcsS0FBS2pqQixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJHLEtBQTFCLEdBQWtDQyxVQUFsQyxDQUFoQjtBQUNBLGFBQUt5UixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJJLFVBQTFCLENBQXFDQSxVQUFVLEdBQUMsQ0FBaEQ7QUFDQSxlQUFPMDBCLFNBQVA7QUFDSCxPQUxELE1BS087QUFDSCxlQUFPLFVBQVA7QUFDSDtBQUNEOzs7O0FBR0g7QUF0Skw7QUFBQTtBQUFBLCtCQXdKZWpDLFlBeEpmLEVBd0o2QkMsT0F4SjdCLEVBd0pzQ0MsTUF4SnRDLEVBd0o4QztBQUN0QyxVQUFJQyxZQUFZLEdBQUcsS0FBS25oQixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDSSxPQUFyRCxDQURzQyxDQUV0Qzs7QUFDQSxVQUFJMnlCLFlBQVksQ0FBQzFFLE9BQWIsSUFBd0IwRSxZQUFZLENBQUMxRSxPQUFiLENBQXFCM2pCLE1BQWpELEVBQXlEO0FBQ3JELGdHQUFpQmtvQixZQUFqQixFQUErQkMsT0FBL0IsRUFBd0NDLE1BQXhDO0FBQ0g7QUFDSjtBQTlKTDs7QUFBQTtBQUFBLEVBQTZDL0MsZ0VBQTdDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFFTyxJQUFNakMscUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRcm5CLE1BRFIsRUFDZ0I7QUFDUixxRkFBVUEsTUFBVjs7QUFDQSxXQUFLM0ssUUFBTCxHQUFnQixjQUFoQjtBQUNBLFdBQUtULElBQUwsR0FBWSxLQUFLdVcsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBM0IsRUFBWjtBQUVBMDZCLGtCQUFZLENBQUMsS0FBS2xqQixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JtQixlQUF6QixDQUFaO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFUTDs7QUFBQTtBQUFBLEVBQTJDODJCLG1FQUEzQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR08sSUFBTWlCLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVUMsV0FBVixFQUF1QkMsY0FBdkIsRUFBdUNDLEtBQXZDLEVBQThDQyxNQUE5QyxFQUFzRDtBQUN0RixNQUFJQyxRQUFRLEdBQUdycUIsSUFBSSxDQUFDQyxTQUFMLENBQWVncUIsV0FBZixDQUFmO0FBRUEsMGtCQWtCNkNJLFFBbEI3Qyx3QkFtQk9BLFFBbkJQLHlMQTBCRkMseURBMUJFLGVBMkJGSixjQTNCRTtBQWdFSCxDQW5FTTtBQXFFQSxJQUFNbEgsbUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRdG5CLE1BRFIsRUFDZ0I7QUFDUixtRkFBVUEsTUFBVjs7QUFDQSxXQUFLM0ssUUFBTCxHQUFnQixxQkFBaEI7QUFDQSxXQUFLVCxJQUFMLEdBQVksS0FBS3VXLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQTNCLE1BQXVDLEVBQW5EO0FBRUEsVUFBSWk3QixXQUFXLEdBQUcsS0FBSzFqQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ202QixXQUFwQyxFQUFsQjtBQUVBLFVBQUlsSCxNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FQUSxDQVFSOztBQUNBLFVBQUl1MUIsWUFBWSxHQUFHLEtBQUtDLGtCQUFMLEVBQW5CO0FBQ0FELGtCQUFZLENBQUMsWUFBRCxDQUFaLEdBQTZCLEtBQUszakIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQ0ksT0FBbEMsQ0FBMENxMUIsVUFBMUMsSUFBd0QsTUFBckY7QUFDQSxXQUFLQyxlQUFMO0FBQ0EsVUFBSVQsY0FBYyxHQUFHLEtBQUs1NUIsSUFBMUI7QUFDQSxVQUFJODVCLE1BQU0sR0FBRyxDQUFDL0csTUFBTSxDQUFDLFFBQUQsQ0FBTixDQUFpQjNWLEtBQWxCLElBQTJCMlYsTUFBTSxDQUFDLFVBQUQsQ0FBTixDQUFtQjNrQixPQUEzRDtBQUNBd3JCLG9CQUFjLEdBQUdGLG9CQUFvQixDQUFDUSxZQUFELEVBQWVOLGNBQWYsRUFBK0JLLFdBQS9CLEVBQTRDSCxNQUE1QyxDQUFyQztBQUNBbHlCLGFBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxLQUFaLEVBQW1CNGpCLGNBQW5CO0FBQ0EsVUFBSVUsVUFBVSxHQUFHQywwRUFBMEIsQ0FBQ1gsY0FBRCxDQUEzQyxDQWhCUSxDQWdCcUQ7O0FBQzdEN0csWUFBTSxDQUFDLFlBQUQsQ0FBTixHQUF1QjtBQUNuQix1QkFBZSxFQURJO0FBRW5CLG9CQUFZLDBCQUZPO0FBR25CLGdCQUFRNkcsY0FIVztBQUluQixzQkFBY1UsVUFKSyxDQUtuQjs7QUFMbUIsT0FBdkI7QUFPQSxXQUFLdDZCLElBQUwsR0FBWTQ1QixjQUFaOztBQUVBLG1GQUFVeHVCLE1BQVYsRUExQlEsQ0E0QlI7OztBQUNBK0ssUUFBRSxDQUFDNVEsT0FBSCxHQUFhLEtBQUtnUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJoRSxVQUExQixDQUFxQzZFLE9BQWxEO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFqQ0w7QUFBQTtBQUFBLDRCQW1DWTh1QixNQW5DWixFQW1Db0I7QUFDWnpzQixhQUFPLENBQUNvTyxHQUFSLENBQVksZ0JBQVosRUFEWSxDQUVaOztBQUNBLFdBQUtPLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQmhFLFVBQTFCLENBQXFDNkUsT0FBckMsR0FBK0M0USxFQUFFLENBQUM1USxPQUFsRDtBQUNBLFdBQUtnUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJoRSxVQUExQixDQUFxQytFLFVBQXJDLEdBQWtEMFEsRUFBRSxDQUFDMVEsVUFBckQ7QUFDQW1DLGFBQU8sQ0FBQ29PLEdBQVIsQ0FBWXFlLE1BQVo7QUFDQSxVQUFJL3VCLE9BQU8sR0FBRyt1QixNQUFNLENBQUNHLEVBQVAsQ0FBVWpzQixPQUFWLENBQWtCaXNCLEVBQWhDO0FBQ0E1c0IsYUFBTyxDQUFDb08sR0FBUixDQUFZcWUsTUFBTSxDQUFDRyxFQUFuQjtBQUNBLFdBQUtqZSxJQUFMLENBQVV6UCxVQUFWLENBQXFCcEIsUUFBckIsQ0FBOEI2dUIsZUFBOUIsQ0FBOENqdkIsT0FBOUM7QUFDQSxXQUFLaVIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQyxZQUFsQyxFQUFnRCxTQUFoRCxJQUE2RCxJQUE3RDtBQUNBLFVBQUl5SixPQUFPLEdBQUcrSCxFQUFFLENBQUNrRCxHQUFILENBQU8wZSxTQUFQLENBQWlCenlCLE9BQU8sQ0FBQ2sxQixPQUF6QixDQUFkO0FBQ0EsV0FBS2prQixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkI0RCxPQUEzQixDQUFtQytOLE9BQU8sSUFBSSxLQUFLbUksSUFBTCxDQUFVMVksS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCNEQsT0FBM0IsRUFBOUMsRUFYWSxDQVlaOztBQUNBLFVBQUlELEtBQUssR0FBRytWLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJ6eUIsT0FBTyxDQUFDbTFCLEtBQXpCLENBQVo7QUFDQXI2QixXQUFLLEdBQUdxTyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxHQUFULEVBQWNELElBQUksQ0FBQ0ksR0FBTCxDQUFTLEdBQVQsRUFBY3pPLEtBQWQsQ0FBZCxDQUFSO0FBQ0EsVUFBSXM2QixRQUFRLEdBQUcsS0FBS25rQixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIyRCxLQUEzQixFQUFmO0FBQ0EsV0FBS21XLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjJELEtBQTNCLENBQWlDcU8sSUFBSSxDQUFDQyxHQUFMLENBQVNnc0IsUUFBVCxFQUFtQnQ2QixLQUFuQixDQUFqQyxFQWhCWSxDQWlCWjs7QUFDQSxVQUFJa1gsSUFBSSxHQUFHbkIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQnp5QixPQUFPLENBQUNxMUIsSUFBekIsQ0FBWCxDQWxCWSxDQW1CWjs7QUFDQSxXQUFLcGtCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCcEQsZ0JBQTVCLENBQTZDdkQsS0FBN0MsRUFBb0RnTyxPQUFwRCxFQUE2RGtKLElBQTdELEVBQW1FLEtBQW5FO0FBQ0EsV0FBS2YsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDQyxLQUEvQyxFQXJCWSxDQXNCWjs7QUFFQTs7OztBQUlBLFVBQUksQ0FBQ3dULEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CNXpCLFVBQXBCLENBQStCazZCLFNBQXBDLEVBQStDO0FBQzNDLFlBQUk7QUFDQSxlQUFLcmtCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCaXpCLGNBQTdCO0FBQ0gsU0FGRCxDQUVFLE9BQU9ybEIsQ0FBUCxFQUFVLENBQ1g7QUFDSjtBQUNKO0FBckVMO0FBQUE7QUFBQSw0QkF1RVltTCxLQXZFWixFQXVFbUI7QUFDWC9ZLGFBQU8sQ0FBQ29PLEdBQVIsQ0FBWSxnQkFBWixFQUE4QjJLLEtBQTlCO0FBQ0EsVUFBSW9TLE1BQU0sR0FBRyxLQUFLeGMsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUF2Qzs7QUFDQSxVQUFJZ2MsS0FBSyxDQUFDbWEsT0FBTixLQUFrQixjQUF0QixFQUFzQztBQUNsQy9ILGNBQU0sQ0FBQyxZQUFELENBQU4sQ0FBcUIsU0FBckIsSUFBa0MsSUFBbEM7QUFDQSxhQUFLeGMsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDQyxLQUEvQztBQUNILE9BSEQsTUFHTztBQUNILGFBQUs0VCxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkUsTUFBaEIsQ0FBdUJpQyxXQUF2QixDQUFtQy9CLG1EQUFXLENBQUN1c0IsTUFBL0MsRUFERyxDQUVIOztBQUNBLGFBQUsxWSxJQUFMLENBQVV6UCxVQUFWLENBQXFCcEIsUUFBckIsQ0FBOEJxMUIsb0JBQTlCLENBQW1EcGEsS0FBbkQsRUFBMEQsS0FBS2xnQixRQUEvRCxFQUhHLENBSUg7QUFDQTtBQUNBO0FBQ0gsT0FiVSxDQWNYOztBQUNIO0FBdEZMOztBQUFBO0FBQUEsRUFBeUNnNEIsbUVBQXpDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUVPLFNBQVM4QiwwQkFBVCxDQUFvQ1gsY0FBcEMsRUFBb0Q7QUFDdkQsTUFBTTNsQixLQUFLLEdBQUcybEIsY0FBYyxDQUFDcm9CLE9BQWYsQ0FBdUJ5b0IsaUJBQXZCLENBQWQ7QUFDQSxNQUFNZ0IsTUFBTSxHQUFHcEIsY0FBYyxDQUFDanBCLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0JzRCxLQUF4QixDQUFmO0FBQ0EsTUFBTWduQixLQUFLLEdBQUdELE1BQU0sQ0FBQ0MsS0FBUCxDQUFhQyxjQUFiLENBQWQ7QUFDQSxTQUFPRCxLQUFLLEdBQUksSUFBRUEsS0FBSyxDQUFDNXJCLE1BQVosR0FBc0IsQ0FBbEM7QUFDSDtBQUVNLElBQU0ycUIsaUJBQWlCLEdBQUcsc0NBQTFCO0FBQ0EsSUFBTWtCLGNBQWMsR0FBRyxLQUF2QjtBQUNQOzs7O0FBR08sSUFBTXhCLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVVEsWUFBVixFQUF3Qk4sY0FBeEIsRUFBd0NDLEtBQXhDLEVBQStDQyxNQUEvQyxFQUF1RDtBQUN2RixNQUFJQyxRQUFRLEdBQUdycUIsSUFBSSxDQUFDQyxTQUFMLENBQWV1cUIsWUFBZixDQUFmO0FBQ0EsTUFBSWlCLFNBQVMsR0FBR3RCLEtBQUssR0FBRyxNQUFILEdBQVcsT0FBaEMsQ0FGdUYsQ0FJdkY7O0FBRUEsMDBCQXlCa0NzQixTQXpCbEMsMExBNkI4QnBCLFFBN0I5Qiw4TUFxQ0ZDLGlCQXJDRSxlQXNDRkosY0F0Q0U7QUEyRUgsQ0FqRk07QUFtRkEsSUFBTXBILGtCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUXBuQixNQURSLEVBQ2dCO0FBQ1Isa0ZBQVVBLE1BQVY7O0FBQ0EsV0FBSzNLLFFBQUwsR0FBZ0Isb0JBQWhCO0FBQ0EsV0FBS1QsSUFBTCxHQUFZLEtBQUt1VyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUEzQixFQUFaO0FBRUEsVUFBSW03QixXQUFXLEdBQUcsS0FBSzFqQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ202QixXQUFwQyxFQUFsQixDQUxRLENBTVI7O0FBQ0EsV0FBSzFqQixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJJLFVBQTFCLENBQXFDLENBQXJDO0FBRUEsVUFBSWl1QixNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FUUSxDQVVSOztBQUNBLFVBQUl1MUIsWUFBWSxHQUFHLEtBQUtDLGtCQUFMLEVBQW5CO0FBQ0EsV0FBS0UsZUFBTDtBQUNBLFVBQUlULGNBQWMsR0FBRyxLQUFLNTVCLElBQTFCO0FBQ0EsVUFBSTg1QixNQUFNLEdBQUcsQ0FBQy9HLE1BQU0sQ0FBQyxRQUFELENBQU4sQ0FBaUIzVixLQUFsQixJQUEyQjJWLE1BQU0sQ0FBQyxVQUFELENBQU4sQ0FBbUIza0IsT0FBM0Q7QUFDQXdyQixvQkFBYyxHQUFHRixvQkFBb0IsQ0FBQ1EsWUFBRCxFQUFlTixjQUFmLEVBQStCSyxXQUEvQixFQUE0Q0gsTUFBNUMsQ0FBckM7QUFDQSxVQUFJUSxVQUFVLEdBQUdDLDBCQUEwQixDQUFDWCxjQUFELENBQTNDLENBaEJRLENBZ0JxRDtBQUM3RDs7QUFDQTdHLFlBQU0sQ0FBQyxZQUFELENBQU4sR0FBdUI7QUFDbkIsdUJBQWUsRUFESTtBQUVuQixvQkFBWSx5QkFGTztBQUduQixnQkFBUTZHLGNBSFc7QUFJbkIsc0JBQWNVLFVBSkssQ0FLbkI7O0FBTG1CLE9BQXZCO0FBT0E7Ozs7Ozs7O0FBUUEsV0FBS3Q2QixJQUFMLEdBQVk0NUIsY0FBWjtBQUVBempCLFFBQUUsQ0FBQ3VnQixhQUFILEdBQW1CLEtBQW5CO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUF2Q0w7QUFBQTtBQUFBLDRCQXlDWXJDLE1BekNaLEVBeUNvQjtBQUNaO0FBQ0E7QUFDQTtBQUNBLFdBQUs5ZCxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJoRSxVQUExQixDQUFxQzZFLE9BQXJDLEdBQStDNFEsRUFBRSxDQUFDNVEsT0FBbEQ7QUFDQSxXQUFLZ1IsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCaEUsVUFBMUIsQ0FBcUMrRSxVQUFyQyxHQUFrRDBRLEVBQUUsQ0FBQzFRLFVBQXJEO0FBQ0EwUSxRQUFFLENBQUM1USxPQUFILEdBQWEsRUFBYjtBQUNBLFVBQUlELE9BQU8sR0FBRyt1QixNQUFNLENBQUNHLEVBQVAsQ0FBVWhzQixNQUFWLENBQWlCZ3NCLEVBQS9CO0FBQ0EsV0FBS2plLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJwQixRQUFyQixDQUE4QjZ1QixlQUE5QixDQUE4Q2p2QixPQUE5QztBQUNBLFdBQUtpUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDLFlBQWxDLEVBQWdELFNBQWhELElBQTZELElBQTdEO0FBQ0EsVUFBSXlKLE9BQU8sR0FBRytILEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJ6eUIsT0FBTyxDQUFDazFCLE9BQXpCLENBQWQ7QUFDQSxXQUFLamtCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjRELE9BQTNCLENBQW1DK04sT0FBTyxJQUFJLEtBQUttSSxJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkI0RCxPQUEzQixFQUE5QyxFQVhZLENBWVo7O0FBQ0EsVUFBSUQsS0FBSyxHQUFHK1YsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQnp5QixPQUFPLENBQUNtMUIsS0FBekIsQ0FBWjtBQUNBcjZCLFdBQUssR0FBR3FPLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWUQsSUFBSSxDQUFDSSxHQUFMLENBQVMsQ0FBVCxFQUFZek8sS0FBWixDQUFaLENBQVI7QUFDQSxVQUFJczZCLFFBQVEsR0FBRyxLQUFLbmtCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjJELEtBQTNCLEVBQWY7QUFDQUEsV0FBSyxHQUFHcU8sSUFBSSxDQUFDQyxHQUFMLENBQVNnc0IsUUFBVCxFQUFtQnQ2QixLQUFuQixDQUFSO0FBQ0EsV0FBS21XLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjJELEtBQTNCLENBQWlDQSxLQUFqQyxFQWpCWSxDQWtCWjs7QUFDQSxVQUFJa1gsSUFBSSxHQUFHbkIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQnp5QixPQUFPLENBQUNxMUIsSUFBekIsQ0FBWCxDQW5CWSxDQW9CWjs7QUFDQSxXQUFLcGtCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCcEQsZ0JBQTVCLENBQTZDdkQsS0FBN0MsRUFBb0RnTyxPQUFwRCxFQUE2RGtKLElBQTdELEVBQW1FLEtBQW5FO0FBQ0EsV0FBS2YsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDQyxLQUEvQyxFQXRCWSxDQXVCWjs7QUFFQTs7OztBQUlBLFVBQUksQ0FBQ3dULEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CNXpCLFVBQXBCLENBQStCazZCLFNBQXBDLEVBQStDO0FBQzNDLFlBQUk7QUFDQSxlQUFLcmtCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCaXpCLGNBQTdCO0FBQ0gsU0FGRCxDQUVFLE9BQU9ybEIsQ0FBUCxFQUFVLENBQ1g7QUFDSjtBQUNKO0FBNUVMO0FBQUE7QUFBQSw0QkE4RVltTCxLQTlFWixFQThFbUI7QUFDWC9ZLGFBQU8sQ0FBQytZLEtBQVIsQ0FBYyxlQUFkLEVBQStCQSxLQUEvQjtBQUNBLFVBQUlvUyxNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSWdjLEtBQUssQ0FBQ21hLE9BQU4sS0FBa0IsY0FBdEIsRUFBc0M7QUFDbEMvSCxjQUFNLENBQUMsWUFBRCxDQUFOLENBQXFCLFNBQXJCLElBQWtDLElBQWxDO0FBQ0EsYUFBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyRSxNQUFoQixDQUF1QmlDLFdBQXZCLENBQW1DL0IsbURBQVcsQ0FBQ0MsS0FBL0M7QUFDSCxPQUhELE1BR087QUFDSCxhQUFLNFQsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDdXNCLE1BQS9DLEVBREcsQ0FFSDs7QUFDQSxhQUFLMVksSUFBTCxDQUFVelAsVUFBVixDQUFxQnBCLFFBQXJCLENBQThCcTFCLG9CQUE5QixDQUFtRHBhLEtBQW5ELEVBQTBELEtBQUtsZ0IsUUFBL0QsRUFIRyxDQUlIO0FBQ0E7QUFDQTtBQUNILE9BYlUsQ0FjWDs7QUFDSDtBQTdGTDs7QUFBQTtBQUFBLEVBQXdDZzRCLG1FQUF4QztBQWlHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcE1BO0FBRU8sSUFBTTJDLHFCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUWh3QixNQURSLEVBQ2dCO0FBQ1IscUZBQVVBLE1BQVY7O0FBQ0EsV0FBSzNLLFFBQUwsR0FBZ0IsV0FBaEI7QUFDQSxXQUFLVCxJQUFMLEdBQVksS0FBS3VXLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNDLEtBQTNCLEVBQVo7QUFFQSxhQUFPLElBQVA7QUFDSDtBQVBMOztBQUFBO0FBQUEsRUFBMkMwekIsMERBQTNDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFFTyxJQUFNSCxnQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1FqbkIsTUFEUixFQUNnQjtBQUNSLFdBQUttTCxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0MsT0FBbkMsQ0FBMkMsWUFBM0M7QUFDQSxXQUFLbEYsUUFBTCxHQUFnQixRQUFoQjtBQUNBLFdBQUtULElBQUwsR0FBWSxLQUFLdVcsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CdUYsS0FBbkIsQ0FBeUJtQixjQUF6QixFQUFaOztBQUNBLFVBQUksS0FBS3FHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DdTdCLGlCQUFwQyxFQUFKLEVBQTZEO0FBQ3pELGFBQUtyN0IsSUFBTCxHQUFZLEVBQVo7QUFDSCxPQU5PLENBT1I7OztBQUNBLFdBQUt1VyxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QnhELFFBQTVCLENBQXFDLFdBQXJDLEVBQWtELEtBQUtnVCxJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixFQUFsRCxFQUFxRixJQUFyRjtBQUNBLFdBQUt1VyxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjVELFFBQTVCLENBQXFDLFNBQXJDLEVBQWdELEVBQWhELEVBQW9ELEVBQXBELEVBQXdELEVBQXhELEVBQTRELFdBQTVELEVBVFEsQ0FVUjs7QUFDQSxnRkFBVWlJLE1BQVY7O0FBRUFBLFlBQU0sQ0FBQ3BCLEtBQVA7QUFDQSxXQUFLbXFCLFdBQUw7QUFFQSxXQUFLNWQsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQyxVQUFsQyxJQUFnRDtBQUM1QyxtQkFBVzIyQixPQUFPLENBQUMsS0FBS3Q3QixJQUFMLENBQVU4YSxJQUFWLEVBQUQsQ0FEMEI7QUFFNUMsZ0JBQVEsS0FBSzlhO0FBRitCLE9BQWhEOztBQUtBLFVBQUksT0FBT21XLEVBQUUsQ0FBQ29sQixPQUFWLElBQXFCLFdBQXpCLEVBQXNDO0FBQ2xDcGxCLFVBQUUsQ0FBQ29sQixPQUFILEdBQWEsSUFBSXBsQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXMkUsSUFBZixFQUFiO0FBQ0g7O0FBQ0QsVUFBTTdlLFVBQVUsR0FBRyxLQUFLcEcsSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBckIsQ0FBNkIrVSxVQUFoRDtBQUFBLFVBQ0kvUSxLQUFLLEdBQUcrUSxVQUFVLENBQUMvUSxLQUFYLEtBQW1CLEVBRC9CO0FBQUEsVUFFSW1SLE1BQU0sR0FBR3RPLElBQUksQ0FBQ0MsR0FBTCxDQUFTLEdBQVQsRUFBY2lPLFVBQVUsQ0FBQ0ksTUFBWCxLQUFvQixFQUFsQyxDQUZiO0FBR0E1RyxRQUFFLENBQUNvbEIsT0FBSCxDQUFXRSxRQUFYLENBQW9CLElBQUl0bEIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21DLEdBQWYsQ0FBbUIsdUJBQW5CLENBQXBCLEVBQWlFLElBQUk3aUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzZFLElBQWYsQ0FBb0JqdEIsSUFBSSxDQUFDa3RCLEtBQUwsQ0FBVy92QixLQUFYLENBQXBCLENBQWpFO0FBQ0F1SyxRQUFFLENBQUNvbEIsT0FBSCxDQUFXRSxRQUFYLENBQW9CLElBQUl0bEIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21DLEdBQWYsQ0FBbUIsd0JBQW5CLENBQXBCLEVBQWtFLElBQUk3aUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzZFLElBQWYsQ0FBb0JqdEIsSUFBSSxDQUFDa3RCLEtBQUwsQ0FBVzVlLE1BQVgsQ0FBcEIsQ0FBbEU7QUFFQTVHLFFBQUUsQ0FBQ3VnQixhQUFILEdBQW1CLEtBQW5CO0FBRUEsV0FBS2tGLFVBQUw7QUFFQSxhQUFPLElBQVA7QUFDSDtBQXBDTDtBQUFBO0FBQUEsNEJBc0NZdkgsTUF0Q1osRUFzQ29CO0FBQUE7O0FBQ1p6c0IsYUFBTyxDQUFDb08sR0FBUixDQUFZLGFBQVo7QUFDQSxVQUFJclEsT0FBTyxHQUFHO0FBQ1Ysa0JBQVUsS0FBSzRRLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0N3ZixJQUFsQyxDQUF1QyxJQUF2QyxDQURBO0FBRVYsbUJBQVcsS0FBSzlOLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkUsTUFBMUIsR0FBbUNvTSxHQUFuQyxDQUF1QyxVQUFBOUMsSUFBSTtBQUFBLGlCQUFJQSxJQUFJLENBQUMrSyxPQUFUO0FBQUEsU0FBM0MsRUFBNkRvTCxJQUE3RCxDQUFrRSxJQUFsRTtBQUZELE9BQWQ7QUFJQSxXQUFLOU4sSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1RCxRQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxFQUFwRCxFQUF3RCxFQUF4RCxFQUE0RHVNLElBQUksQ0FBQ0MsU0FBTCxDQUFlaEssT0FBZixDQUE1RCxFQUFxRixXQUFyRjtBQUNBLFdBQUs0USxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JvQixlQUF4QixDQUF3QyxLQUF4QztBQUNBLFdBQUsyVSxJQUFMLENBQVV6UCxVQUFWLENBQXFCYyxPQUFyQixDQUE2QmkwQixhQUE3QjtBQUNBLFdBQUt0bEIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCaUMsV0FBdkIsQ0FBbUMvQixtREFBVyxDQUFDQyxLQUEvQztBQUNBLFdBQUs0VCxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUSxPQUFsQyxDQUEwQzRRLEVBQUUsQ0FBQzVRLE9BQTdDO0FBQ0E0USxRQUFFLENBQUM1USxPQUFILEdBQWEsRUFBYjtBQUNBLFVBQUl3dEIsTUFBTSxHQUFHLEtBQUt4YyxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsVUFBSWxFLFFBQVEsR0FBRyxLQUFLQSxRQUFwQjtBQUNBLFdBQUs4VixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDTyxPQUFsQyxHQUE0Qyt1QixNQUE1Qzs7QUFDQSxVQUFJLENBQUMsS0FBSzlkLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DOE0sWUFBcEMsRUFBTCxFQUF5RDtBQUNyRCxhQUFLMkosSUFBTCxDQUFVelAsVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJrMEIsU0FBN0I7QUFDSDs7QUFDRCxhQUFPLElBQUlqZ0IsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVXNRLE1BQVYsRUFBcUI7QUFDcEMsYUFBSSxDQUFDcGUsSUFBTCxDQUFVcW1CLE1BQU0sQ0FBQ0csRUFBakIsRUFBcUJILE1BQU0sQ0FBQ0csRUFBNUIsRUFBK0IsQ0FBQyxDQUFoQyxFQUFtQyxDQUFuQyxFQUFzQy96QixRQUFRLEdBQUcsS0FBakQ7O0FBQ0EsYUFBSSxDQUFDd0UsUUFBTDs7QUFDQTh0QixjQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CO0FBQ2hCLHFCQUFXLElBREs7QUFFaEIsbUJBQVMsS0FBSSxDQUFDM25CLE1BQUwsQ0FBWWdPLGVBQVosQ0FBNEJ0TCxLQUZyQjtBQUdoQixtQkFBUyxLQUFJLENBQUMxQyxNQUFMLENBQVlnTyxlQUFaLENBQTRCdEwsS0FBNUIsQ0FBa0NrRCxHQUFsQyxDQUFzQyxVQUFBa25CLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDaHFCLElBQU47QUFBQSxXQUF2QyxDQUhPO0FBSWhCLHVCQUFhLEtBQUksQ0FBQzlDLE1BQUwsQ0FBWWdPLGVBQVosQ0FBNEJ0TCxLQUE1QixDQUFrQ2laLE1BQWxDLENBQXlDLFVBQUFtUixDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxXQUFQO0FBQUEsV0FBMUMsRUFBOERubkIsR0FBOUQsQ0FBa0UsVUFBQWtuQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ2hxQixJQUFOO0FBQUEsV0FBbkUsQ0FKRztBQUtoQixxQkFBV21tQixNQUxLO0FBTWhCLG9CQUFVLEtBQUksQ0FBQzlkLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkUsTUFOcEI7QUFPaEIsbUJBQVMsS0FBSSxDQUFDMlIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCRyxLQVBuQjtBQVFoQixtQkFBUyxLQUFJLENBQUMwUixJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUyxLQVIzQjtBQVNoQixxQkFBVztBQVRLLFNBQXBCO0FBV0FzVyxlQUFPO0FBQ1YsT0FmTSxDQUFQO0FBZ0JIO0FBeEVMO0FBQUE7QUFBQSw0QkEwRVk2RSxLQTFFWixFQTBFbUI7QUFBQTs7QUFDWC9ZLGFBQU8sQ0FBQytZLEtBQVIsQ0FBYyxhQUFkLEVBQTZCQSxLQUE3QjtBQUNBLFdBQUtwSyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkUsTUFBaEIsQ0FBdUJpQyxXQUF2QixDQUFtQy9CLG1EQUFXLENBQUN1c0IsTUFBL0M7QUFDQSxVQUFJOEQsTUFBTSxHQUFHLEtBQUt4YyxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJDLE9BQXZDOztBQUNBLFVBQUlvdUIsTUFBTSxDQUFDZ0osTUFBUCxDQUFjM3RCLE9BQWQsSUFBeUIya0IsTUFBTSxDQUFDaUosUUFBUCxDQUFnQjV0QixPQUE3QyxFQUFzRDtBQUNsRCxhQUFLbUksSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1RCxRQUE1QixDQUFxQyxlQUFyQyxFQUFzRCxFQUF0RCxFQUEwRCxFQUExRCxFQUE4RHdkLEtBQUssQ0FBQ3hlLFFBQU4sRUFBOUQsRUFBZ0YsV0FBaEY7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLb1UsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1RCxRQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxvQkFBcEQsRUFBMEUsRUFBMUUsRUFBOEV3ZCxLQUFLLENBQUN4ZSxRQUFOLEVBQTlFLEVBQWdHLFdBQWhHO0FBQ0g7O0FBQ0QsV0FBSzhDLFFBQUw7QUFDQSxhQUFPLElBQUk0VyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVc1EsTUFBVixFQUFxQjtBQUNwQzJHLGNBQU0sQ0FBQyxTQUFELENBQU4sR0FBb0I7QUFDaEIscUJBQVcsS0FESztBQUVoQixtQkFBU3BTLEtBRk87QUFHaEIsbUJBQVMsTUFBSSxDQUFDdlYsTUFBTCxDQUFZZ08sZUFBWixDQUE0QnRMLEtBSHJCO0FBSWhCLG1CQUFTLE1BQUksQ0FBQzFDLE1BQUwsQ0FBWWdPLGVBQVosQ0FBNEJ0TCxLQUE1QixDQUFrQ2tELEdBQWxDLENBQXNDLFVBQUFrbkIsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLENBQUNocUIsSUFBTjtBQUFBLFdBQXZDLENBSk87QUFLaEIsdUJBQWEsTUFBSSxDQUFDOUMsTUFBTCxDQUFZZ08sZUFBWixDQUE0QnRMLEtBQTVCLENBQWtDaVosTUFBbEMsQ0FBeUMsVUFBQW1SLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFDLENBQUNDLFdBQVA7QUFBQSxXQUExQyxFQUE4RG5uQixHQUE5RCxDQUFrRSxVQUFBa25CLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDaHFCLElBQU47QUFBQSxXQUFuRSxDQUxHO0FBTWhCLG1CQUFTLE1BQUksQ0FBQ3FJLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkcsS0FObkI7QUFPaEIsbUJBQVMsTUFBSSxDQUFDMFIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ1MsS0FQM0I7QUFRaEIscUJBQVc7QUFSSyxTQUFwQjtBQVVBc1csZUFBTztBQUNWLE9BWk0sQ0FBUDtBQWFIO0FBakdMOztBQUFBO0FBQUEsRUFBc0NzYyw2REFBdEMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUVPLElBQU02RCxtQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1E3d0IsTUFEUixFQUNnQjtBQUNSLG1GQUFVQSxNQUFWLEVBRFEsQ0FFUjs7O0FBQ0EsV0FBSzNLLFFBQUwsR0FBZ0IsV0FBaEI7QUFDQSxXQUFLVCxJQUFMLEdBQVkseUJBQVo7QUFFQSxhQUFPLElBQVA7QUFDSDtBQVJMOztBQUFBO0FBQUEsRUFBeUNvNEIsNkRBQXpDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFFTyxJQUFNQSxvQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1FodEIsTUFEUixFQUNnQjtBQUFBOztBQUNSLG9GQUFVQSxNQUFWLEVBRFEsQ0FFUjs7O0FBQ0EsVUFBSXRMLFFBQVEsR0FBRyxLQUFLeVcsSUFBTCxDQUFVMVksS0FBVixDQUFnQmlDLFFBQS9COztBQUNBcVcsUUFBRSxDQUFDc2YsaUJBQUgsR0FBdUI7QUFBQSxlQUNuQixLQUFJLENBQUNsZixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ3UxQixjQUFwQyxLQUF1REssUUFBdkQsR0FBa0UsSUFEL0M7QUFBQSxPQUF2Qjs7QUFFQXZmLFFBQUUsQ0FBQ2lmLFNBQUgsR0FBZWpmLEVBQUUsQ0FBQ3NmLGlCQUFILEVBQWYsQ0FOUSxDQU9SOztBQUNBdGYsUUFBRSxDQUFDMGhCLG9CQUFILEdBQTBCLEtBQUs3cEIsSUFBTCxDQUFVMkQsSUFBVixDQUFlLElBQWYsQ0FBMUIsQ0FSUSxDQVVSOztBQUNBLFdBQUs0RSxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JHLFdBQXhCLENBQW9DLEtBQXBDLEVBWFEsQ0FhUjtBQUNBOztBQUVBd1YsUUFBRSxDQUFDQyxZQUFILENBQWdCckgsS0FBaEIsQ0FBc0IsNkJBQXRCLElBQXVEMGxCLDREQUF2RDtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBcEJMO0FBQUE7QUFBQSw2QkFzQmFoMEIsUUF0QmIsRUFzQnVCO0FBQ2YsVUFBSWsyQixLQUFLLEdBQUcsS0FBS3BnQixJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NzeEIsYUFBaEMsQ0FBOEM1NEIsUUFBOUMsRUFBd0QsSUFBeEQsQ0FBWixDQURlLENBRWY7O0FBQ0EsVUFBSWsyQixLQUFLLEtBQUtoNkIsU0FBZCxFQUF5QjtBQUNyQixZQUFJd1osRUFBRSxDQUFDQyxZQUFILElBQW1CRCxFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIzVixRQUF6QixNQUF1QzlELFNBQTlELEVBQXlFO0FBQ3JFLGlCQUFPd1osRUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCM1YsUUFBekIsQ0FBUDtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFNLElBQUkwVixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXQyxPQUFmLENBQXVCLHFCQUFxQnIyQixRQUE1QyxDQUFOO0FBQ0g7QUFDSixPQU5ELE1BTU87QUFDSCxlQUFPazJCLEtBQUssQ0FBQ3hsQixRQUFOLEVBQVA7QUFDSDtBQUNKO0FBbENMO0FBQUE7QUFBQSwrQkFvQ2UxUSxRQXBDZixFQW9DeUI7QUFDakIsVUFBSSxLQUFLeTdCLFdBQUwsQ0FBaUJ6N0IsUUFBakIsQ0FBSixFQUFnQztBQUM1QixjQUFNLDJCQUEyQkEsUUFBM0IsR0FBc0MsR0FBNUM7QUFDSCxPQUZELE1BRU8sSUFBSUEsUUFBUSxLQUFLLGFBQWpCLEVBQWdDO0FBQ25DLGVBQU8sS0FBSzhWLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLEVBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSW1XLEVBQUUsQ0FBQ0MsWUFBSCxLQUFvQnpaLFNBQXhCLEVBQW1DO0FBQ3RDLGNBQU0sSUFBSXdaLEVBQUUsQ0FBQzBnQixPQUFILENBQVdDLE9BQWYsQ0FBdUIsa0NBQXZCLENBQU47QUFDSCxPQUZNLE1BRUEsSUFBSTNnQixFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIzVixRQUF6QixNQUF1QzlELFNBQTNDLEVBQXNEO0FBQ3pELGVBQU93WixFQUFFLENBQUNDLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIzVixRQUF6QixDQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsWUFBSWsyQixLQUFLLEdBQUcsS0FBS3BnQixJQUFMLENBQVV6UCxVQUFWLENBQXFCaUIsVUFBckIsQ0FBZ0NzeEIsYUFBaEMsQ0FBOEM1NEIsUUFBOUMsRUFBd0QsSUFBeEQsQ0FBWjs7QUFDQSxZQUFJazJCLEtBQUssS0FBS2g2QixTQUFkLEVBQXlCO0FBQ3JCLGdCQUFNLElBQUl3WixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXQyxPQUFmLENBQXVCLHNCQUFvQnIyQixRQUFwQixHQUErQixHQUF0RCxDQUFOO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQU9rMkIsS0FBSyxDQUFDeGxCLFFBQU4sRUFBUDtBQUNIO0FBQ0o7QUFDSjtBQXJETDtBQUFBO0FBQUEsMEJBdURVZ0ssYUF2RFYsRUF1RHlCO0FBQ2pCLGFBQU8sS0FBSzVFLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCL0MsS0FBN0IsQ0FBbUNzVyxhQUFuQyxDQUFQO0FBQ0g7QUF6REw7QUFBQTtBQUFBLGdDQTJEZ0IxYSxRQTNEaEIsRUEyRDBCO0FBQ2xCLGFBQU9BLFFBQVEsQ0FBQ2lRLFVBQVQsQ0FBb0Isa0JBQXBCLEtBQ0hqUSxRQUFRLENBQUNpUSxVQUFULENBQW9CLGdCQUFwQixDQURHLElBRUhqUSxRQUFRLENBQUNpUSxVQUFULENBQW9CLGdCQUFwQixDQUZKO0FBR0g7QUFFRDs7Ozs7Ozs7Ozs7OztBQWpFSjtBQUFBO0FBQUEseUJBNkVTbkwsT0E3RVQsRUE2RWtCNDJCLE1BN0VsQixFQTZFMEJDLFVBN0UxQixFQTZFc0NDLFlBN0V0QyxFQTZFb0Q1N0IsUUE3RXBELEVBNkU4RDAzQixXQTdFOUQsRUE2RTJFbUUsT0E3RTNFLEVBNkVvRjtBQUM1RSxVQUFJNzdCLFFBQVEsS0FBSyxXQUFqQixFQUE4QjtBQUMxQjs7O0FBR0EsWUFBSXVFLFdBQVcsR0FBRyxLQUFLb0csTUFBTCxDQUFZZ08sZUFBWixDQUE0QnBMLElBQTlDO0FBQ0F6SSxlQUFPLEdBQUcsS0FBS2dSLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJnSCxLQUFyQixDQUEyQnl1QixZQUEzQixpQ0FBNENoM0IsT0FBNUMsR0FBd0Q0MkIsTUFBeEQsRUFBVixDQUwwQixDQU0xQjtBQUNBO0FBQ0E7O0FBQ0EsYUFBSy93QixNQUFMLENBQVlnTyxlQUFaLENBQTRCdEwsS0FBNUIsQ0FBa0NvTyxJQUFsQyxDQUF1QztBQUNuQyxrQkFBUWxYLFdBRDJCO0FBRW5DLHNCQUFZdkUsUUFGdUI7QUFHbkM7QUFDQSxrQkFBUTI3QixVQUoyQjtBQUtuQyxvQkFBVUMsWUFMeUI7QUFNbkMsd0JBQWM5MkIsT0FBTyxDQUFDaTNCLFVBTmE7QUFPbkMscUJBQVdqM0IsT0FBTyxDQUFDazNCLE9BUGdCO0FBUW5DLHlCQUFldEUsV0FSb0I7QUFTbkMsaUJBQU9tRTtBQVQ0QixTQUF2QztBQVdBLGFBQUtseEIsTUFBTCxDQUFZZ08sZUFBWixDQUE0QnBMLElBQTVCLEdBQW1DaEosV0FBVyxHQUFHLENBQWpEO0FBQ0EsYUFBS29HLE1BQUwsQ0FBWWdPLGVBQVosQ0FBNEJsTCxJQUE1QixHQUFtQ2t1QixVQUFuQztBQUNIO0FBQ0o7QUFyR0w7QUFBQTs7QUF5R0k7Ozs7QUF6R0osK0JBNkdlO0FBQ1AsVUFBSTEzQixTQUFTLEdBQUcsS0FBSzZSLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQztBQUNBQSxlQUFTLENBQUNLLE9BQVYsQ0FBa0JLLGdCQUFsQixDQUFtQyxLQUFLZ0csTUFBTCxDQUFZZ08sZUFBWixDQUE0QnRMLEtBQS9EO0FBQ0FwSixlQUFTLENBQUNLLE9BQVYsQ0FBa0JDLFdBQWxCLENBQThCLEtBQUtvRyxNQUFMLENBQVlnTyxlQUFaLENBQTRCcEwsSUFBMUQ7QUFDQXRKLGVBQVMsQ0FBQ0ssT0FBVixDQUFrQkUsUUFBbEIsQ0FBMkIsS0FBS21HLE1BQUwsQ0FBWWdPLGVBQVosQ0FBNEJwTCxJQUF2RDtBQUNBdEosZUFBUyxDQUFDSyxPQUFWLENBQWtCRyxXQUFsQixDQUE4QixLQUFLa0csTUFBTCxDQUFZZ08sZUFBWixDQUE0QmxMLElBQTFEO0FBQ0F4SixlQUFTLENBQUNLLE9BQVYsQ0FBa0JJLFFBQWxCLENBQTJCLEtBQUtpRyxNQUFMLENBQVlnTyxlQUFaLENBQTRCbEwsSUFBdkQ7QUFDQXhKLGVBQVMsQ0FBQ0ssT0FBVixDQUFrQk0sZ0JBQWxCLENBQW1DLEtBQUsrRixNQUFMLENBQVlnTyxlQUFaLENBQTRCcEwsSUFBL0Q7QUFDSDtBQXJITDtBQUFBO0FBQUEsNkJBdUhhRyxHQXZIYixFQXVIa0I7QUFDVixVQUFJdXVCLFlBQVksR0FBRyxJQUFJQyxHQUFKLEVBQW5COztBQUNBLFVBQUlDLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQUNDLElBQUQsRUFBVTtBQUN0QixZQUFJQSxJQUFJLENBQUNDLE1BQUwsS0FBZ0JuZ0MsU0FBcEIsRUFBK0I7QUFDM0IrL0Isc0JBQVksQ0FBQ3B0QixHQUFiLENBQWlCdXRCLElBQUksQ0FBQ0MsTUFBdEI7QUFDSDs7QUFDRCxZQUFJRCxJQUFJLENBQUNsYixJQUFULEVBQWU7QUFDWGtiLGNBQUksQ0FBQ2xiLElBQUwsQ0FBVTNCLE9BQVYsQ0FBa0IsVUFBQytjLFNBQUQ7QUFBQSxtQkFBZUgsU0FBUyxDQUFDRyxTQUFELENBQXhCO0FBQUEsV0FBbEI7QUFDSDs7QUFDRCxZQUFJRixJQUFJLENBQUNHLE1BQVQsRUFBaUI7QUFDYkgsY0FBSSxDQUFDRyxNQUFMLENBQVloZCxPQUFaLENBQW9CLFVBQUMrYyxTQUFEO0FBQUEsbUJBQWVILFNBQVMsQ0FBQ0csU0FBRCxDQUF4QjtBQUFBLFdBQXBCO0FBQ0g7O0FBQ0QsWUFBSUYsSUFBSSxDQUFDSSxTQUFULEVBQW9CO0FBQ2hCSixjQUFJLENBQUNJLFNBQUwsQ0FBZWpkLE9BQWYsQ0FBdUIsVUFBQytjLFNBQUQ7QUFBQSxtQkFBZUgsU0FBUyxDQUFDRyxTQUFELENBQXhCO0FBQUEsV0FBdkI7QUFDSDtBQUNKLE9BYkQ7O0FBY0FILGVBQVMsQ0FBQ3p1QixHQUFELENBQVQ7QUFDQSxhQUFPK3VCLEtBQUssQ0FBQ0MsSUFBTixDQUFXVCxZQUFYLENBQVA7QUFDSDtBQUVEOzs7O0FBM0lKO0FBQUE7QUFBQSxrQ0E4SWtCO0FBQ1YsVUFBSTNKLE1BQU0sR0FBRyxLQUFLeGMsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUF2QyxDQURVLENBRVY7O0FBQ0EsVUFBSTBvQixLQUFLLEdBQUcsRUFBWixDQUhVLENBSVY7O0FBQ0EsVUFBSWxmLEdBQUo7O0FBQ0EsVUFBSTtBQUNBLFlBQUl1SCxLQUFLLEdBQUdTLEVBQUUsQ0FBQ1QsS0FBSCxDQUFTLEtBQUtqVixRQUFkLEVBQXdCLEtBQUtULElBQTdCLENBQVo7QUFDQW1PLFdBQUcsR0FBR2dJLEVBQUUsQ0FBQ2luQixZQUFILENBQWdCMW5CLEtBQUssQ0FBQzJuQixHQUF0QixFQUEyQixLQUFLNThCLFFBQWhDLEVBQTBDaVYsS0FBSyxDQUFDNG5CLEtBQWhELENBQU47QUFDQWpRLGFBQUssR0FBRyxLQUFLa1EsUUFBTCxDQUFjcHZCLEdBQWQsQ0FBUjtBQUNILE9BSkQsQ0FJRSxPQUFPd1MsS0FBUCxFQUFjO0FBQ1o7QUFDQW9TLGNBQU0sQ0FBQyxRQUFELENBQU4sR0FBbUI7QUFDZixxQkFBVyxLQURJO0FBRWYsbUJBQVNwUyxLQUZNO0FBR2YsbUJBQVMsSUFITTtBQUlmLG1CQUFTME07QUFKTSxTQUFuQjtBQU1BemxCLGVBQU8sQ0FBQytZLEtBQVIsQ0FBY0EsS0FBZDtBQUNBL1ksZUFBTyxDQUFDb08sR0FBUixDQUFZLEtBQUt2VixRQUFqQixFQUEyQixLQUFLVCxJQUFoQztBQUNBLGVBQU8sS0FBUDtBQUNILE9BckJTLENBc0JWOzs7QUFDQSt5QixZQUFNLENBQUMsUUFBRCxDQUFOLEdBQW1CO0FBQ2YsbUJBQVcsSUFESTtBQUVmLGVBQU81a0IsR0FGUTtBQUdmLGlCQUFTQSxHQUFHLENBQUN3VCxJQUFKLENBQVN0UyxNQUFULEtBQW9CLENBSGQ7QUFJZixpQkFBU2dlO0FBSk0sT0FBbkI7QUFNQSxhQUFPLElBQVA7QUFDSDtBQTVLTDtBQUFBO0FBQUEsaUNBOEtpQjtBQUNULFVBQUkwRixNQUFNLEdBQUcsS0FBS3hjLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSW91QixNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCM2tCLE9BQXRCLEVBQStCO0FBQzNCLGFBQUttSSxJQUFMLENBQVV6UCxVQUFWLENBQXFCcEIsUUFBckIsQ0FBOEJzWCxLQUE5QixDQUFvQywwQ0FBcEM7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLekcsSUFBTCxDQUFVelAsVUFBVixDQUFxQnBCLFFBQXJCLENBQThCODNCLGVBQTlCLENBQThDekssTUFBTSxDQUFDaHVCLE9BQVAsQ0FBZTRiLEtBQTdEO0FBQ0g7QUFDSjtBQXJMTDtBQUFBO0FBQUEseUNBdUx5QjtBQUFBOztBQUNqQixVQUFJb1MsTUFBTSxHQUFHLEtBQUt4YyxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsVUFBSWUsUUFBUSxHQUFHLEtBQUs2USxJQUFMLENBQVV6UCxVQUFWLENBQXFCcEIsUUFBcEM7O0FBQ0EsVUFBSSxDQUFDcXRCLE1BQU0sQ0FBQyxTQUFELENBQU4sQ0FBa0Iza0IsT0FBdkIsRUFBZ0M7QUFDNUIsWUFBSXF2QixXQUFXLEdBQUcsS0FBS2xuQixJQUFMLENBQVUxWSxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEI2SixTQUE5QixDQUF3Q2tILElBQXhDLENBQTZDLHdCQUE3QyxDQUFsQjtBQUNBLFlBQUkzSCxPQUFPLEdBQUdELFFBQVEsQ0FBQzgzQixlQUFULENBQXlCekssTUFBTSxDQUFDaHVCLE9BQVAsQ0FBZTRiLEtBQXhDLEVBQStDLElBQS9DLENBQWQ7QUFDQThjLG1CQUFXLENBQUNsZixJQUFaLENBQWlCLE9BQWpCLEVBQTBCLDZCQUExQjtBQUNBa2YsbUJBQVcsQ0FBQ3ppQixPQUFaLENBQW9CO0FBQUMscUJBQVcsT0FBWjtBQUFxQix1QkFBYSxLQUFLekUsSUFBTCxDQUFVMVksS0FBVixDQUFnQnRCLGFBQWhCLENBQThCNEo7QUFBaEUsU0FBcEI7QUFDQXMzQixtQkFBVyxDQUFDcmhCLEtBQVosQ0FBa0I7QUFBQSxpQkFBTSxNQUFJLENBQUM3RixJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEJzWix3QkFBNUIsQ0FBcURsZSxPQUFyRCxDQUFOO0FBQUEsU0FBbEI7QUFDQTgzQixtQkFBVyxDQUFDcG1CLElBQVo7QUFDSDtBQUNKO0FBbE1MOztBQUFBO0FBQUEsRUFBMENxZCw2REFBMUMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFFTyxJQUFJZ0osYUFBYSxtakhBQWpCO0FBNkVBLElBQU05bUIsZUFBYjtBQUVJOzs7Ozs7Ozs7QUFTQSwyQkFBWUwsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBRUEsU0FBS2loQixhQUFMLEdBQXFCLEtBQUtwbkIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCZ0IsUUFBL0M7QUFFQSxTQUFLRSxRQUFMLEdBQWdCLEtBQUs4VyxHQUFMLENBQVNwUCxJQUFULENBQWMsNEJBQWQsQ0FBaEI7QUFDQSxTQUFLekgsS0FBTCxHQUFhLEtBQUs2VyxHQUFMLENBQVNwUCxJQUFULENBQWMseUJBQWQsQ0FBYjtBQUNBLFNBQUszSCxPQUFMLEdBQWUsS0FBSytXLEdBQUwsQ0FBU3BQLElBQVQsQ0FBYywyQkFBZCxDQUFmO0FBQ0EsU0FBS3N3QixRQUFMLEdBQWdCLEtBQUtsaEIsR0FBTCxDQUFTcFAsSUFBVCxDQUFjLDRCQUFkLENBQWhCLENBVG1CLENBV25COztBQUNBLFNBQUtpSixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixDQUFnQ3VYLFNBQWhDLENBQTBDO0FBQUEsYUFBTSxLQUFJLENBQUNoQixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JvQixlQUF4QixDQUF3QyxJQUF4QyxDQUFOO0FBQUEsS0FBMUM7QUFDSDs7QUF4Qkw7QUFBQTs7QUEwQkk7OztBQTFCSixxQ0E2QnFCO0FBQ2IrRSxPQUFDLENBQUMsWUFBRCxDQUFELENBQWdCNFksT0FBaEIsQ0FBd0I7QUFDcEIxRixpQkFBUyxFQUFFLEtBQUs2QyxHQUFMLENBQVM5QyxNQUFULEdBQWtCRDtBQURULE9BQXhCLEVBRUcsR0FGSDtBQUdIO0FBakNMO0FBQUE7O0FBbUNJOzs7O0FBbkNKLHdDQXVDd0I7QUFDaEIsVUFBSWtrQixnQkFBZ0IsR0FBRyxHQUF2QjtBQUNBLFVBQUlDLFlBQVksR0FBRyxLQUFLcGhCLEdBQUwsQ0FBUzlDLE1BQVQsR0FBa0JELEdBQXJDLENBRmdCLENBR2hCOztBQUNBLFVBQUlva0IsZUFBZSxHQUFHRCxZQUFZLEdBQUdELGdCQUFyQztBQUNBLFVBQUlHLGNBQWMsR0FBR3IzQixDQUFDLENBQUNvZSxNQUFELENBQUQsQ0FBVWxMLFNBQVYsS0FBd0JsVCxDQUFDLENBQUNvZSxNQUFELENBQUQsQ0FBVWhJLE1BQVYsRUFBN0M7QUFDQSxVQUFJa2hCLFdBQVcsR0FBR3QzQixDQUFDLENBQUNvZSxNQUFELENBQUQsQ0FBVWxMLFNBQVYsRUFBbEIsQ0FOZ0IsQ0FPaEI7O0FBQ0EsYUFDS2lrQixZQUFZLEdBQUdFLGNBQWhCLElBQ0NDLFdBQVcsR0FBR0YsZUFGbkI7QUFHSDtBQWxETDtBQUFBOztBQW9ESTs7OztBQXBESiw0QkF3RDJCO0FBQUEsVUFBakJwNEIsT0FBaUIsdUVBQVQsT0FBUztBQUNuQixXQUFLZzRCLGFBQUwsQ0FBbUJoNEIsT0FBbkIsQ0FBMkJBLE9BQTNCO0FBQ0EsV0FBS2c0QixhQUFMLENBQW1CLzNCLFFBQW5CLENBQTRCLElBQTVCO0FBQ0EsV0FBSyszQixhQUFMLENBQW1COTNCLEtBQW5CLENBQXlCLElBQXpCO0FBQ0EsV0FBSzgzQixhQUFMLENBQW1CLzlCLE1BQW5CLENBQTBCLEtBQTFCO0FBQ0EsV0FBSys5QixhQUFMLENBQW1CNzNCLFVBQW5CLENBQThCbVgsU0FBOUI7QUFDQSxXQUFLMGdCLGFBQUwsQ0FBbUI1M0IsY0FBbkIsQ0FBa0NrWCxTQUFsQztBQUNBLFdBQUtpaEIscUJBQUw7QUFDQSxXQUFLdDRCLFFBQUwsQ0FBY3drQixHQUFkLENBQWtCLE9BQWxCO0FBQ0EsV0FBSzdULElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QitCLFFBQXhCLENBQWlDLEtBQWpDO0FBQ0g7QUFsRUw7QUFBQTtBQUFBLDRDQXVGNEIsQ0FFdkI7QUFFRDs7Ozs7QUEzRko7QUFBQTtBQUFBLG1DQStGbUI0N0IsZ0JBL0ZuQixFQStGcUM7QUFBQTs7QUFDN0I7QUFDQSxVQUFJeDRCLE9BQU8sR0FBR3dRLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJvRyxnQkFBZ0IsQ0FBQ0MsT0FBbEMsQ0FBZDtBQUNBLFVBQUl4NEIsUUFBUSxHQUFHdVEsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQm9HLGdCQUFnQixDQUFDRSxRQUFsQyxDQUFmO0FBQ0EsVUFBSXg0QixLQUFLLEdBQUdzUSxFQUFFLENBQUNrRCxHQUFILENBQU8wZSxTQUFQLENBQWlCb0csZ0JBQWdCLENBQUNHLEtBQWxDLENBQVo7QUFDQSxVQUFJaG5CLElBQUksR0FBR25CLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJvRyxnQkFBZ0IsQ0FBQ3hELElBQWxDLENBQVg7QUFDQSxVQUFJaHpCLElBQUksR0FBR3cyQixnQkFBZ0IsQ0FBQ0ksSUFBNUI7QUFDQSxVQUFJQyxTQUFTLEdBQUdyb0IsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQm9HLGdCQUFnQixDQUFDTSxRQUFsQyxDQUFoQixDQVA2QixDQVM3Qjs7QUFDQSxVQUFJQyxTQUFTLEdBQUcsS0FBS25vQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJvRCxNQUEzQixFQUFoQjs7QUFDQSxVQUFJOCtCLFNBQVMsSUFBSTk0QixRQUFRLENBQUMwRixXQUFULE9BQTJCLFVBQTVDLEVBQXdEO0FBQ3BEMUYsZ0JBQVEsR0FBRyxXQUFYO0FBQ0FDLGFBQUssR0FBRyxXQUFSO0FBQ0FGLGVBQU8sR0FBRyxxQkFBVjtBQUNILE9BZjRCLENBaUI3Qjs7O0FBQ0EsVUFBSUMsUUFBUSxDQUFDMEYsV0FBVCxPQUEyQixZQUEzQixJQUEyQ3pGLEtBQUssQ0FBQ3lGLFdBQU4sT0FBd0IsU0FBdkUsRUFBa0Y7QUFDOUV6RixhQUFLLEdBQUcscUJBQVI7QUFDSCxPQXBCNEIsQ0FzQjdCOzs7QUFDQSxVQUFJRCxRQUFRLEtBQUssWUFBYixJQUE2QkMsS0FBSyxLQUFLLFdBQTNDLEVBQXdEO0FBQ3BERCxnQkFBUSxHQUFHLFdBQVg7QUFDSCxPQXpCNEIsQ0EyQjdCOzs7QUFDQUQsYUFBTyxHQUFHLEtBQUs0USxJQUFMLENBQVV6TSxTQUFWLENBQW9CQyxRQUFwQixDQUE2QnBFLE9BQTdCLEVBQXNDK2UsT0FBdEMsQ0FBOEMsVUFBOUMsRUFBMEQsV0FBMUQsQ0FBVjtBQUNBLFdBQUtpWixhQUFMLENBQW1CaDRCLE9BQW5CLENBQTJCQSxPQUEzQjtBQUNBLFdBQUtnNEIsYUFBTCxDQUFtQi8zQixRQUFuQixDQUE0QkEsUUFBNUI7QUFDQSxXQUFLKzNCLGFBQUwsQ0FBbUI5M0IsS0FBbkIsQ0FBeUJBLEtBQXpCLEVBL0I2QixDQWdDN0I7O0FBQ0EsV0FBS0YsT0FBTCxDQUFhMkgsSUFBYixDQUFrQixVQUFsQixFQUE4QjBELEdBQTlCLENBQW1DLFVBQUM4TixDQUFELEVBQUk2ZixLQUFKLEVBQWM7QUFDN0M1WixjQUFNLENBQUM2WixJQUFQLENBQVlDLGNBQVosQ0FBMkJGLEtBQTNCO0FBQ0gsT0FGRCxFQWpDNkIsQ0FvQzdCO0FBQ0E7O0FBQ0EsV0FBS3BvQixJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjVELFFBQTVCLENBQXFDLGNBQXJDLEVBQXFEeUMsUUFBckQsRUFBK0RDLEtBQS9ELEVBQXNFRixPQUF0RSxFQUErRSxXQUEvRSxFQXRDNkIsQ0F3QzdCOztBQUNBLFdBQUs0USxJQUFMLENBQVV6UCxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDb2tCLHFCQUFyQyxHQXpDNkIsQ0EyQzdCOztBQUNBLFVBQUlyZixJQUFJLEdBQUcwSSxlQUFlLENBQUNrb0Isa0JBQWhCLENBQW1DbjNCLElBQW5DLENBQVg7QUFDQSxXQUFLZzJCLGFBQUwsQ0FBbUI3M0IsVUFBbkIsQ0FBOEJtWCxTQUE5Qjs7QUFDQSxVQUFJL08sSUFBSSxLQUFLLElBQVQsSUFBaUJBLElBQUksS0FBS3ZSLFNBQTlCLEVBQXlDO0FBQ3JDLGFBQUtnaEMsYUFBTCxDQUFtQjczQixVQUFuQixDQUE4Qm9XLElBQTlCLENBQW1DaE8sSUFBbkM7QUFDSCxPQWhENEIsQ0FrRDdCOzs7QUFDQSxVQUFJNndCLGFBQWEsR0FBRyxLQUFLeG9CLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NJLE9BQXREO0FBQ0EsV0FBSzQ0QixhQUFMLENBQW1CNTNCLGNBQW5CLENBQWtDa1gsU0FBbEM7O0FBQ0EsVUFBSThoQixhQUFhLENBQUMzd0IsT0FBbEIsRUFBMkI7QUFDdkIsWUFBSTR3QixjQUFjLEdBQUcsRUFBckI7QUFDQSxhQUFLem9CLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NvM0IsTUFBbEMsQ0FBeUMxTyxLQUF6QyxDQUErQ3JOLE9BQS9DLENBQXVELFVBQUM5UixJQUFELEVBQVU7QUFDN0QsY0FBSTZ3QixhQUFhLENBQUMxUixLQUFkLENBQW9COWIsT0FBcEIsQ0FBNEJyRCxJQUE1QixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDOHdCLDBCQUFjLENBQUM5aUIsSUFBZixDQUFvQmhPLElBQXBCO0FBQ0g7QUFDSixTQUpEO0FBS0EsYUFBS3l2QixhQUFMLENBQW1CNTNCLGNBQW5CLENBQWtDaTVCLGNBQWxDO0FBQ0g7O0FBN0Q0QixpQ0ErRHBCbGdCLENBL0RvQjtBQWdFekIsWUFBSW1nQixZQUFZLEdBQUdULFNBQVMsQ0FBQzFmLENBQUQsQ0FBNUI7O0FBQ0EsY0FBSSxDQUFDb2dCLG1CQUFMLENBQXlCRCxZQUFZLENBQUN0NUIsT0FBdEMsRUFBK0MsTUFBL0MsRUFBdUQsT0FBdkQsRUFBZ0U7QUFBQSxpQkFBTSxNQUFJLENBQUM0USxJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEJ1WixzQkFBNUIsQ0FBbURtYixZQUFZLENBQUMvYyxLQUFoRSxFQUF1RStjLFlBQVksQ0FBQ3Q1QixPQUFwRixDQUFOO0FBQUEsU0FBaEU7QUFqRXlCOztBQStEN0IsV0FBSyxJQUFJbVosQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFDMGYsU0FBUyxDQUFDbnZCLE1BQTFCLEVBQWtDeVAsQ0FBQyxJQUFFLENBQXJDLEVBQXdDO0FBQUEsY0FBL0JBLENBQStCO0FBR3ZDO0FBQ0o7QUFsS0w7QUFBQTtBQUFBLDRDQW9LNEI7QUFDcEIsV0FBSzhlLFFBQUwsQ0FBY3hnQixLQUFkO0FBQ0EsV0FBSzdHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QjZKLFNBQTlCLENBQXdDa0gsSUFBeEMsQ0FBNkMsd0JBQTdDLEVBQXVFZ0ssSUFBdkU7QUFDSDtBQXZLTDtBQUFBO0FBQUEsd0NBeUt3QmQsSUF6S3hCLEVBeUs4Qm9RLElBeks5QixFQXlLb0N1WSxLQXpLcEMsRUF5SzJDQyxPQXpLM0MsRUF5S29EQyxLQXpLcEQsRUF5SzJEO0FBQUE7O0FBQ25ELFVBQUl6QixRQUFRLEdBQUdqM0IsQ0FBQyxDQUFDLGVBQUQsQ0FBaEI7QUFDQWkzQixjQUFRLENBQUNsd0IsUUFBVCxDQUFrQiwyQ0FBeUNrWixJQUEzRDtBQUNBZ1gsY0FBUSxDQUFDMEIsR0FBVCxDQUFhLE9BQWIsRUFBc0JILEtBQXRCO0FBQ0F2QixjQUFRLENBQUNyZixJQUFULENBQWMsT0FBZCxFQUF1Qi9ILElBQXZCOztBQUNBLFVBQUk2b0IsS0FBSixFQUFXO0FBQ1AsYUFBS3pCLFFBQUwsQ0FBY3ZqQixNQUFkLENBQXFCdWpCLFFBQXJCO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBS0EsUUFBTCxDQUFjbGtCLE9BQWQsQ0FBc0Jra0IsUUFBdEI7QUFDSDs7QUFDREEsY0FBUSxDQUFDNWlCLE9BQVQsQ0FBaUI7QUFBQyxtQkFBVyxPQUFaO0FBQXFCLHFCQUFhLEtBQUt6RSxJQUFMLENBQVUxWSxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEI0SjtBQUFoRSxPQUFqQjs7QUFDQSxVQUFJaTVCLE9BQU8sS0FBS3ppQyxTQUFoQixFQUEyQjtBQUN2QmloQyxnQkFBUSxDQUFDeGhCLEtBQVQsQ0FBZWdqQixPQUFmO0FBQ0g7O0FBQ0R4QixjQUFRLENBQUMyQixLQUFULENBQWUsWUFBTTtBQUNqQixjQUFJLENBQUNocEIsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEI1RCxRQUE1QixDQUFxQyxZQUFyQyxFQUFtRCxVQUFuRCxFQUErRCxPQUEvRCxFQUF3RXFULElBQXhFLEVBQThFLEVBQTlFO0FBQ0gsT0FGRDtBQUdIO0FBRUQ7Ozs7QUE1TEo7QUFBQTtBQUFBLG9DQStMb0IybkIsZ0JBL0xwQixFQStMc0M7QUFDOUIsV0FBS3FCLGNBQUwsQ0FBb0JyQixnQkFBcEI7QUFFQSxXQUFLdjRCLFFBQUwsQ0FBY3drQixHQUFkLENBQWtCLE9BQWxCOztBQUNBLFVBQUksS0FBSzdULElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkUsVUFBeEIsRUFBSixFQUEwQztBQUN0QyxhQUFLKytCLGtCQUFMLENBQXdCdEIsZ0JBQXhCO0FBQ0gsT0FONkIsQ0FROUI7QUFDQTs7O0FBRUEsV0FBS3VCLG9CQUFMO0FBQ0g7QUEzTUw7QUFBQTtBQUFBLDBDQTZNMEJqVixPQTdNMUIsRUE2TW1DO0FBQzNCLFVBQU12SSxLQUFLLEdBQUd1SSxPQUFPLENBQUNrVixVQUFSLENBQW1CLElBQUlDLGdEQUFKLENBQVUsT0FBVixDQUFuQixFQUF1Q3o5QixRQUF2QyxFQUFkO0FBQ0EsVUFBTXlELFFBQVEsR0FBR21QLDZEQUFVLENBQUMwVixPQUFPLENBQUNrVixVQUFSLENBQW1CLElBQUlDLGdEQUFKLENBQVUsVUFBVixDQUFuQixFQUEwQ3o5QixRQUExQyxFQUFELENBQTNCO0FBQ0EsVUFBTTA5QixJQUFJLEdBQUdwVixPQUFPLENBQUNrVixVQUFSLENBQW1CLElBQUlDLGdEQUFKLENBQVUsTUFBVixDQUFuQixFQUFzQ3o5QixRQUF0QyxFQUFiO0FBQ0EsVUFBTTI5QixNQUFNLEdBQUczcEIsRUFBRSxDQUFDeWQsUUFBSCxDQUFZbU0sTUFBWixDQUFtQnRWLE9BQW5CLENBQWY7QUFDQSxVQUFJOWtCLE9BQU8sR0FBRzhrQixPQUFPLENBQUNrVixVQUFSLENBQW1CLElBQUlDLGdEQUFKLENBQVUsU0FBVixDQUFuQixFQUF5Q3o5QixRQUF6QyxFQUFkO0FBQ0EsVUFBTTY5QixjQUFjLEdBQUd2VixPQUFPLENBQUNrVixVQUFSLENBQW1CLElBQUlDLGdEQUFKLENBQVUsZ0JBQVYsQ0FBbkIsRUFBZ0R6OUIsUUFBaEQsRUFBdkI7QUFDQXdELGFBQU8sR0FBR0EsT0FBTyxLQUFLLE1BQVosR0FBcUJxNkIsY0FBckIsR0FBc0NyNkIsT0FBaEQ7QUFDQSxVQUFNczZCLGFBQWEsR0FBR3hWLE9BQU8sQ0FBQ2tWLFVBQVIsQ0FBbUIsSUFBSUMsZ0RBQUosQ0FBVSxlQUFWLENBQW5CLEVBQStDejlCLFFBQS9DLEVBQXRCO0FBQ0EsVUFBTWlULE1BQU0sR0FBR3FWLE9BQU8sQ0FBQ2tWLFVBQVIsQ0FBbUIsSUFBSUMsZ0RBQUosQ0FBVSxRQUFWLENBQW5CLENBQWY7QUFDQSxVQUFNTSxTQUFTLEdBQUcsQ0FBQy9wQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXc0osU0FBWCxDQUFxQi9xQixNQUFyQixDQUFuQjtBQUNBLFVBQUloVixLQUFLLEdBQUdxcUIsT0FBTyxDQUFDa1YsVUFBUixDQUFtQixJQUFJQyxnREFBSixDQUFVLGdCQUFWLENBQW5CLENBQVo7QUFDQXgvQixXQUFLLEdBQUdBLEtBQUssS0FBSytWLEVBQUUsQ0FBQzBnQixPQUFILENBQVd1SixJQUFYLENBQWdCQyxLQUExQixHQUFrQyxFQUFsQyxHQUNGamdDLEtBQUssQ0FBQzA2QixPQUFOLEtBQWtCLE9BQWxCLEdBQ0ksTUFBTXJzQixJQUFJLENBQUNrdEIsS0FBTCxDQUFXdjdCLEtBQUssQ0FBQ2s1QixDQUFOLEdBQVEsR0FBbkIsRUFBd0JuM0IsUUFBeEIsRUFBTixHQUEyQyxHQUQvQyxHQUVJL0IsS0FBSyxDQUFDK0IsUUFBTixFQUhWO0FBSUEsYUFBTyxDQUFDc29CLE9BQUQsRUFBVXJWLE1BQVYsbUZBQ3NEOHFCLFNBQVMsR0FBRyw0QkFBSCxHQUFrQyxFQURqRywwSkFHcUNKLE1BQU0sR0FBRyxFQUFILEdBQVEsZ0NBSG5ELGdCQUd3RjVkLEtBSHhGLHdCQUcyR3RjLFFBSDNHLGdCQUd5SGk2QixJQUh6SCxtRkFJNkN6L0IsS0FKN0Msc0RBTUQwL0IsTUFBTSxHQUFHLEVBQUgsR0FBUSwyQ0FOYiw4R0FRR242QixPQVJILGlGQVUrQnM2QixhQVYvQix3Q0FBUDtBQWFIO0FBMU9MO0FBQUE7QUFBQSx1Q0E0T3VCOUIsZ0JBNU92QixFQTRPeUM7QUFBQTs7QUFDakN2MkIsYUFBTyxDQUFDb08sR0FBUixDQUFZbW9CLGdCQUFaOztBQUNBLFVBQUksRUFBRSxpQkFBaUJBLGdCQUFuQixDQUFKLEVBQTBDO0FBQ3RDO0FBQ0g7O0FBQ0QsVUFBSW1DLFVBQVUsR0FBR25DLGdCQUFnQixDQUFDb0MsV0FBbEM7QUFDQSxVQUFNNzZCLFFBQVEsR0FBRzQ2QixVQUFVLENBQUNYLFVBQVgsQ0FBc0IsSUFBSUMsZ0RBQUosQ0FBVSxVQUFWLENBQXRCLENBQWpCOztBQUNBLFVBQUksQ0FBQ2w2QixRQUFMLEVBQWU7QUFDWDtBQUNIOztBQUNELFVBQUk4NkIsU0FBUyxHQUFHLEVBQWhCO0FBQ0FycUIsUUFBRSxDQUFDeWQsUUFBSCxDQUFZNk0sT0FBWixDQUFvQi82QixRQUFRLENBQUNnN0IsT0FBVCxFQUFwQixFQUF3QyxVQUFDalcsT0FBRCxFQUFhO0FBQ2pEK1YsaUJBQVMsQ0FBQ3RrQixJQUFWLENBQWUsTUFBSSxDQUFDeWtCLHFCQUFMLENBQTJCbFcsT0FBM0IsQ0FBZjtBQUNILE9BRkQ7QUFHQXRVLFFBQUUsQ0FBQ3lkLFFBQUgsQ0FBWTZNLE9BQVosQ0FBb0JILFVBQVUsQ0FBQ1gsVUFBWCxDQUFzQixJQUFJQyxnREFBSixDQUFVLGtCQUFWLENBQXRCLEVBQXFEYyxPQUFyRCxFQUFwQixFQUFvRixVQUFDalcsT0FBRCxFQUFhO0FBQzdGK1YsaUJBQVMsQ0FBQ3RrQixJQUFWLENBQWUsTUFBSSxDQUFDeWtCLHFCQUFMLENBQTJCbFcsT0FBM0IsQ0FBZjtBQUNILE9BRkQ7QUFHQSxVQUFNbVcsT0FBTyxHQUFHLElBQUlDLEdBQUosRUFBaEI7O0FBQ0EsV0FBSyxJQUFJL2hCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwaEIsU0FBUyxDQUFDbnhCLE1BQTlCLEVBQXNDeVAsQ0FBQyxJQUFJLENBQTNDLEVBQThDO0FBQUEsMENBQ1YwaEIsU0FBUyxDQUFDMWhCLENBQUQsQ0FEQztBQUFBLFlBQ25DMkwsT0FEbUM7QUFBQSxZQUMxQnJWLE1BRDBCO0FBQUEsWUFDbEJvQixJQURrQjs7QUFFMUMsWUFBTTBwQixTQUFTLEdBQUcsQ0FBQy9wQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXc0osU0FBWCxDQUFxQi9xQixNQUFyQixDQUFuQjs7QUFDQSxZQUFJOHFCLFNBQUosRUFBZTtBQUNYLGNBQUksQ0FBQ1UsT0FBTyxDQUFDbGpDLEdBQVIsQ0FBWTBYLE1BQVosQ0FBTCxFQUEwQjtBQUN0QndyQixtQkFBTyxDQUFDenpCLEdBQVIsQ0FBWWlJLE1BQVosRUFBb0IsRUFBcEI7QUFDSDs7QUFDRHdyQixpQkFBTyxDQUFDampDLEdBQVIsQ0FBWXlYLE1BQVosRUFBb0I4RyxJQUFwQixDQUF5QjFGLElBQXpCO0FBQ0gsU0FMRCxNQUtPO0FBQ0gsY0FBSSxDQUFDb3FCLE9BQU8sQ0FBQ2xqQyxHQUFSLENBQVkrc0IsT0FBWixDQUFMLEVBQTJCO0FBQ3ZCbVcsbUJBQU8sQ0FBQ3p6QixHQUFSLENBQVlzZCxPQUFaLEVBQXFCLEVBQXJCO0FBQ0g7O0FBQ0RtVyxpQkFBTyxDQUFDampDLEdBQVIsQ0FBWThzQixPQUFaLEVBQXFCcVcsT0FBckIsQ0FBNkJ0cUIsSUFBN0I7QUFDSDtBQUNKOztBQUNEZ3FCLGVBQVMsR0FBRyxtQkFBSUksT0FBTyxDQUFDRyxNQUFSLEVBQUosRUFBc0JDLElBQXRCLEVBQVo7QUFDQSxXQUFLcDdCLFFBQUwsQ0FBY3FkLEVBQWQsQ0FBaUIsT0FBakIsRUFBMEIsWUFBTTtBQUM1QixjQUFJLENBQUMxTSxJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEI4TSxJQUE1QixDQUFpQywyQkFBakMsRUFBOEQsNkJBQzFEbXBCLFNBQVMsQ0FBQ25jLElBQVYsQ0FBZSxJQUFmLENBRDBELEdBQ25DLFFBRDNCOztBQUVBMWQsU0FBQyxDQUFDLDJCQUFELENBQUQsQ0FBK0JzYyxFQUEvQixDQUFrQyxPQUFsQyxFQUEyQyxVQUFDaE8sS0FBRCxFQUFXO0FBQ2xEdE8sV0FBQyxDQUFDc08sS0FBSyxDQUFDRSxNQUFQLENBQUQsQ0FBZ0I4ckIsV0FBaEIsQ0FBNEIsaUJBQTVCO0FBQ0gsU0FGRDtBQUdILE9BTkQ7QUFPSDtBQXJSTDtBQUFBO0FBQUEsMkNBdVIyQjtBQUNuQixVQUFJLENBQUMsS0FBS2oxQixpQkFBTCxFQUFMLEVBQStCO0FBQzNCLGFBQUswUSxHQUFMLENBQVNwUCxJQUFULENBQWMsNEJBQWQsRUFBNEMrSixJQUE1QyxHQUFtRDlKLE9BQW5ELENBQTJELElBQTNEOztBQUNBLFlBQUksS0FBSzJ6QixvQkFBTCxFQUFKLEVBQWlDO0FBQzdCLGVBQUtDLGNBQUw7QUFDSDtBQUNKO0FBQ0o7QUE5Ukw7QUFBQTtBQUFBLDJDQWdTMkI7QUFDbkIsYUFBTyxDQUFDLEtBQUs1cUIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CQyxXQUFuQixFQUFSO0FBQ0g7QUFsU0w7QUFBQTtBQUFBLG9DQW9Tb0JrWCxLQXBTcEIsRUFvUzJCeWdCLFdBcFMzQixFQW9Td0M7QUFDaEMsVUFBSUEsV0FBVyxLQUFLemtDLFNBQXBCLEVBQStCO0FBQzNCeWtDLG1CQUFXLEdBQUcsS0FBZDtBQUNIOztBQUNELFVBQUl6N0IsT0FBSixFQUFhRSxLQUFiLEVBQW9CRCxRQUFwQixFQUE4QmszQixNQUE5QjtBQUNBajNCLFdBQUssR0FBRzhhLEtBQUssQ0FBQ21hLE9BQWQ7QUFDQWwxQixjQUFRLEdBQUcsU0FBWDtBQUNBRCxhQUFPLEdBQUcsS0FBSzA3QixrQkFBTCxDQUF3QjFnQixLQUF4QixDQUFWOztBQUVBLFVBQUl5Z0IsV0FBSixFQUFpQjtBQUNiLGVBQU96N0IsT0FBUDtBQUNIOztBQUNELFdBQUtnNEIsYUFBTCxDQUFtQmg0QixPQUFuQixDQUEyQkEsT0FBM0I7QUFDQSxXQUFLZzRCLGFBQUwsQ0FBbUIvM0IsUUFBbkIsQ0FBNEJBLFFBQTVCO0FBQ0EsV0FBSyszQixhQUFMLENBQW1COTNCLEtBQW5CLENBQXlCQSxLQUF6QjtBQUNBLFdBQUs4M0IsYUFBTCxDQUFtQjczQixVQUFuQixDQUE4Qm1YLFNBQTlCOztBQUNBLFVBQUk2ZixNQUFNLEtBQUtuZ0MsU0FBWCxJQUF3Qm1nQyxNQUFNLEtBQUssSUFBdkMsRUFBNkM7QUFDekMsYUFBS2EsYUFBTCxDQUFtQjczQixVQUFuQixDQUE4Qm9XLElBQTlCLENBQW1DNGdCLE1BQW5DO0FBQ0g7QUFDSjtBQXZUTDtBQUFBO0FBQUEsbUNBeVRtQm5jLEtBelRuQixFQXlUMEIyZ0IsZ0JBelQxQixFQXlUNEM7QUFBQTs7QUFDcEMsYUFBTzNnQixLQUFLLENBQUM0Z0IsU0FBTixDQUFnQnZ3QixHQUFoQixDQUFvQixVQUFBd3dCLEtBQUssRUFBSTtBQUNoQyxZQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNSLGlCQUFPLElBQVA7QUFDSDs7QUFDRCxZQUFJMUUsTUFBTSxHQUFHMEUsS0FBSyxDQUFDMUUsTUFBbkI7O0FBQ0EsWUFBSTBFLEtBQUssQ0FBQy9nQyxRQUFOLENBQWVrUSxLQUFmLENBQXFCLENBQXJCLEVBQXdCLENBQUMsQ0FBekIsTUFBZ0Myd0IsZ0JBQXBDLEVBQXNEO0FBQ2xEeEUsZ0JBQU0sSUFBSSxNQUFJLENBQUN2bUIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQ2pFLFVBQWxDLENBQTZDNDVCLFVBQXZEO0FBQ0g7O0FBQ0QsWUFBSWxyQixJQUFJLDZDQUFtQ295QixLQUFLLENBQUMvZ0MsUUFBekMsZ0JBQVI7QUFDQSxZQUFJeU4sSUFBSSw0Q0FBbUM0dUIsTUFBbkMsY0FBUjtBQUNBLFlBQUkyRSxLQUFLLEdBQUlELEtBQUssQ0FBQ0MsS0FBTixLQUFnQixVQUFoQixJQUNiRCxLQUFLLENBQUNDLEtBQU4sS0FBZ0I5a0MsU0FESixzQkFDNkI2a0MsS0FBSyxDQUFDQyxLQURuQyxJQUM2QyxFQUR6RDtBQUVBLFlBQUloVyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxZQUFJK1YsS0FBSyxDQUFDL1YsTUFBTixLQUFpQjl1QixTQUFyQixFQUFnQztBQUM1Qjh1QixnQkFBTSwwQkFBbUIrVixLQUFLLENBQUMvVixNQUF6QixrQkFBTjtBQUNIOztBQUNELGVBQU9yYyxJQUFJLEdBQUdsQixJQUFQLEdBQWN1ekIsS0FBZCxHQUFzQmhXLE1BQTdCO0FBQ0gsT0FqQk0sQ0FBUDtBQWtCSDtBQTVVTDtBQUFBO0FBQUEsdUNBOFV1QjlLLEtBOVV2QixFQThVOEIyZ0IsZ0JBOVU5QixFQThVZ0RJLFlBOVVoRCxFQThVOEQ7QUFDdEQsVUFBSXhqQyxJQUFJLEdBQUd5aUIsS0FBSyxDQUFDbWEsT0FBakI7QUFDQSxVQUFJbkQsSUFBSSxHQUFHeGhCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJwWCxLQUFLLENBQUNnWCxJQUF2QixDQUFYO0FBQ0EsVUFBSWhlLEdBQUcsYUFBTXpiLElBQU4sZUFBZXk1QixJQUFJLENBQUMsQ0FBRCxDQUFuQixpQkFBUDtBQUNBLFVBQUk0SixTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsVUFBSXJqQyxJQUFJLEtBQUssY0FBYixFQUE2QjtBQUN6QixZQUFJeWlCLEtBQUssQ0FBQ2doQixHQUFOLElBQWFoaEIsS0FBSyxDQUFDZ2hCLEdBQU4sQ0FBVUosU0FBdkIsSUFBb0M1Z0IsS0FBSyxDQUFDZ2hCLEdBQU4sQ0FBVUosU0FBVixDQUFvQmx5QixNQUE1RCxFQUFvRTtBQUNoRSxjQUFNdXlCLFNBQVMsR0FBRyxLQUFLQyxjQUFMLENBQW9CbGhCLEtBQUssQ0FBQ2doQixHQUExQixFQUErQkwsZ0JBQS9CLENBQWxCO0FBQ0EsY0FBTTNyQixNQUFNLEdBQUcsQ0FBQyxZQUFELENBQWY7O0FBQ0EsY0FBSWlzQixTQUFTLENBQUN2eUIsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QnNHLGtCQUFNLENBQUN1RyxJQUFQLE9BQUF2RyxNQUFNLHFCQUFTaXNCLFNBQVMsQ0FBQ2p4QixLQUFWLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLENBQVQsK0JBQ29CaXhCLFNBQVMsQ0FBQ3Z5QixNQUFWLEdBQW1CLENBRHZDLG1EQUVTdXlCLFNBQVMsQ0FBQ2p4QixLQUFWLENBQWdCLENBQUMsQ0FBakIsRUFBb0IsQ0FBQyxDQUFyQixDQUZULEdBQU47QUFHSCxXQUpELE1BSU87QUFDSGdGLGtCQUFNLENBQUN1RyxJQUFQLE9BQUF2RyxNQUFNLHFCQUFTaXNCLFNBQVQsRUFBTjtBQUNIOztBQUNETCxtQkFBUyxHQUFHNXJCLE1BQU0sQ0FBQzBPLElBQVAsQ0FBWSxRQUFaLENBQVo7QUFDSDtBQUNKLE9BYkQsTUFhTztBQUNILFlBQUlxZCxZQUFKLEVBQWtCO0FBQ2QvbkIsYUFBRyxHQUFHLG9GQUFrRkEsR0FBeEY7QUFDSDs7QUFDRCxZQUFJZ0gsS0FBSyxDQUFDNGdCLFNBQU4sSUFBbUI1Z0IsS0FBSyxDQUFDNGdCLFNBQU4sQ0FBZ0JseUIsTUFBdkMsRUFBK0M7QUFDM0NreUIsbUJBQVMsR0FBRyxxQkFBcUIsS0FBS00sY0FBTCxDQUFvQmxoQixLQUFwQixFQUEyQjJnQixnQkFBM0IsRUFBNkNqZCxJQUE3QyxDQUFrRCxRQUFsRCxDQUFqQztBQUNIO0FBQ0o7O0FBQ0QsYUFBTzFLLEdBQUcsR0FBQyxJQUFKLEdBQVM0bkIsU0FBaEI7QUFDSDtBQXpXTDtBQUFBO0FBQUEseUNBMld5QjVnQixLQTNXekIsRUEyV2dDMmdCLGdCQTNXaEMsRUEyV2tEO0FBQzFDLFVBQUkzZ0IsS0FBSyxDQUFDbWEsT0FBTixLQUFrQixjQUF0QixFQUFzQztBQUNsQyxhQUFLdmtCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DRSxRQUFuQyxDQUE0QyxTQUE1QztBQUNBLGFBQUsyUSxJQUFMLENBQVUxWSxLQUFWLENBQWdCNkcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0csS0FBbkMsQ0FBeUMsZUFBekM7QUFDSCxPQUhELE1BR087QUFDSCxhQUFLMFEsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNFLFFBQW5DLENBQTRDLFVBQTVDO0FBQ0EsYUFBSzJRLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0I2RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DRyxLQUFuQyxDQUF5QyxnQkFBekM7QUFDSDs7QUFDRCxVQUFJRixPQUFPLEdBQUcsS0FBSzA3QixrQkFBTCxDQUF3QjFnQixLQUF4QixFQUErQjJnQixnQkFBL0IsRUFBaUQsSUFBakQsQ0FBZDtBQUNBLFdBQUsvcUIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjZHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNDLE9BQW5DLENBQTJDQSxPQUEzQztBQUVBLFdBQUsrNUIsb0JBQUw7QUFFQSxXQUFLbnBCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCNUQsUUFBNUIsQ0FBcUMsZ0JBQXJDLEVBQXVELFVBQXZELEVBQW1FLGdCQUFuRSxFQUFxRndDLE9BQXJGLEVBQThGMjdCLGdCQUE5RjtBQUNIO0FBelhMO0FBQUE7QUFBQSx1Q0FvRThCUSxZQXBFOUIsRUFvRTRDO0FBQ3BDLFVBQUlBLFlBQVksQ0FBQ0MsWUFBakIsRUFBK0I7QUFDM0IsWUFBSTlZLFFBQVEsR0FBRzZZLFlBQVksQ0FBQ0MsWUFBYixDQUEwQixJQUFJNXJCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1CLFVBQW5CLENBQTFCLENBQWY7O0FBQ0EsWUFBSS9QLFFBQUosRUFBYztBQUNWLGNBQUkvYSxJQUFJLEdBQUcrYSxRQUFRLENBQUMwVyxVQUFULENBQW9CLElBQUl4cEIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21DLEdBQWYsQ0FBbUIsTUFBbkIsQ0FBcEIsQ0FBWDs7QUFDQSxjQUFJOXFCLElBQUosRUFBVTtBQUNOLG1CQUFPaUksRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQjdwQixJQUFqQixDQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNBOzs7Ozs7QUFNSDtBQXJGTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NDN0VBOztBQUVBLElBQU0rYyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFTeHFCLFFBQVQsRUFBbUJ1aEMsWUFBbkIsRUFBaUNDLFdBQWpDLEVBQThDQyxhQUE5QyxFQUE2RDtBQUN6RSxNQUFJRixZQUFZLEtBQUtybEMsU0FBckIsRUFBZ0M7QUFDNUJxbEMsZ0JBQVksR0FBR3ZoQyxRQUFmO0FBQ0g7O0FBQ0QsTUFBSTBoQyxtQkFBbUIsR0FBRyxFQUExQjtBQUNBLE1BQUlDLG1CQUFtQixHQUFHLE1BQTFCOztBQUNBLE1BQUksQ0FBQ0YsYUFBTCxFQUFvQjtBQUNoQkMsdUJBQW1CLEdBQUcseUJBQXRCO0FBQ0FDLHVCQUFtQixHQUFHLHNCQUF0QjtBQUNIOztBQUNELDhDQUNzQkQsbUJBRHRCLDJKQUkyRDFoQyxRQUozRCx1RUFLbURBLFFBTG5ELDZDQU15QndoQyxXQU56Qix1Q0FNaUV4aEMsUUFOakUsb0JBTW1GMmhDLG1CQU5uRiw4QkFPVUosWUFQVjtBQVNILENBbkJEOztBQXFCTyxJQUFJSyxVQUFVLCtQQVNmcFgsT0FBTyxDQUFDLFdBQUQsRUFBY3R1QixTQUFkLEVBQXlCQSxTQUF6QixFQUFvQyxJQUFwQyxDQVRRLG1CQVVmc3VCLE9BQU8sQ0FBQyxrQkFBRCxFQUFxQixjQUFyQixDQVZRLG1CQVdmQSxPQUFPLENBQUMsOEJBQUQsRUFBaUMsVUFBakMsQ0FYUSxtQkFZZkEsT0FBTyxDQUFDLG1CQUFELEVBQXNCLGVBQXRCLENBWlEsbUJBYWZBLE9BQU8sQ0FBQyxZQUFELEVBQWUsUUFBZixDQWJRLG1CQWNmQSxPQUFPLENBQUMsZUFBRCxFQUFrQixXQUFsQixFQUErQixJQUEvQixDQWRRLG1CQWVmQSxPQUFPLENBQUMsYUFBRCxFQUFnQixTQUFoQixFQUEyQixJQUEzQixDQWZRLG1CQWdCZkEsT0FBTyxDQUFDLDZCQUFELEVBQWdDLG9CQUFoQyxFQUFzRCxJQUF0RCxDQWhCUSxtQkFpQmZBLE9BQU8sQ0FBQyxlQUFELEVBQWtCLE1BQWxCLEVBQTBCLElBQTFCLENBakJRLHVuS0FBZDtBQThHUCxJQUFNcVgsK0JBQStCLDQyQ0FBckM7QUFtQ0E7Ozs7Ozs7Ozs7OztBQVlPLElBQUlDLGNBQWMsR0FBRyxDQUN4QjtBQUNBLFdBRndCLEVBR3hCO0FBQ0Esa0JBSndCLEVBS3hCLDhCQUx3QixFQU14QixtQkFOd0IsRUFPeEIsWUFQd0IsRUFReEIsbUJBUndCLENBQXJCO0FBV0EsSUFBTUMsZUFBZSxHQUFHLENBQzNCLGVBRDJCLEVBRTNCLGFBRjJCLEVBRzNCLG9CQUgyQixFQUkzQixrQkFKMkIsRUFLM0IsZUFMMkIsRUFNM0IsNkJBTjJCLEVBTzNCLG1CQVAyQixFQVEzQixtQkFSMkIsQ0FBeEI7QUFXQSxTQUFTckosZ0JBQVQsQ0FBMEIxNEIsUUFBMUIsRUFBb0M7QUFDdkMsTUFBSSxVQUFVeTRCLFFBQVYsQ0FBbUJ6NEIsUUFBUSxDQUFDLENBQUQsQ0FBM0IsQ0FBSixFQUFxQztBQUNqQyxXQUFPQSxRQUFRLENBQUNrUSxLQUFULENBQWUsQ0FBZixDQUFQO0FBQ0gsR0FGRCxNQUVPO0FBQ0gsV0FBT2xRLFFBQVA7QUFDSDtBQUNKO0FBRUQsSUFBTWdpQyxvQkFBb0IsR0FBRyxjQUE3QjtBQUNBLElBQU1DLGlCQUFpQixHQUFHLFdBQTFCO0FBRUEsSUFBTUMsV0FBVyxHQUFHO0FBQ2hCQyxZQUFVLEVBQUUsWUFESTtBQUVoQkMsdUJBQXFCLEVBQUUsdUJBRlA7QUFHaEJDLG9CQUFrQixFQUFFO0FBSEosQ0FBcEI7QUFNQSxJQUFNQyxzQkFBc0IsR0FBRyxDQUFDLGVBQUQsRUFBa0IsYUFBbEIsQ0FBL0I7QUFFTyxJQUFNenhCLGlCQUFpQixHQUFHLENBQUMsV0FBRCxFQUFjLGtCQUFkLEVBQWtDLHlCQUFsQyxFQUNDLG1CQURELEVBQ3NCLFlBRHRCLEVBQ29DLG1CQURwQyxDQUExQjtBQUdBLElBQU1HLGlCQUFpQixHQUFHLENBQUMsV0FBRCxFQUFjLGtCQUFkLEVBQWtDLHlCQUFsQyxFQUNDLG1CQURELEVBQ3NCLFlBRHRCLEVBQ29DLG1CQURwQyxFQUVDLGVBRkQsRUFFa0IsYUFGbEIsRUFHQyxvQkFIRCxFQUd1QixrQkFIdkIsRUFJQyxlQUpELEVBSWtCLDZCQUpsQixFQUtDLG1CQUxELEVBS3NCLG1CQUx0QixDQUExQjs7SUFPRHV4QixXLEdBQ0YscUJBQVl6c0IsSUFBWixFQUFrQjlWLFFBQWxCLEVBQTRCMFEsUUFBNUIsRUFBc0M7QUFBQTs7QUFDbEMsT0FBS29GLElBQUwsR0FBWUEsSUFBWjtBQUNBLE9BQUs5VixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUswUSxRQUFMLEdBQWdCQSxRQUFRLElBQUksRUFBNUI7QUFDQSxPQUFLOHhCLEtBQUwsR0FBYSxJQUFiO0FBQ0EsT0FBSzN5QixNQUFMLEdBQWMsSUFBZDtBQUNILEM7O0FBR0UsU0FBU1ksYUFBVCxDQUF1QnpRLFFBQXZCLEVBQWlDMFEsUUFBakMsRUFBMkM7QUFDOUMsU0FBTztBQUFDLGdCQUFZblQsRUFBRSxDQUFDQyxVQUFILENBQWN3QyxRQUFkLENBQWI7QUFBc0MwUSxZQUFRLEVBQUVuVCxFQUFFLENBQUNDLFVBQUgsQ0FBY2tULFFBQVEsSUFBSSxFQUExQjtBQUFoRCxHQUFQO0FBQ0g7O0FBRUQsU0FBUyt4QixpQkFBVCxDQUEyQnppQyxRQUEzQixFQUFxQzBRLFNBQXJDLEVBQStDO0FBQzNDLFNBQU87QUFBRTFRLFlBQVE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsTUFBRTtBQUFBLGFBQU1BLFFBQU47QUFBQSxLQUFGLENBQVY7QUFBNEIwUSxZQUFRLEVBQUU7QUFBQSxhQUFNQSxTQUFOO0FBQUE7QUFBdEMsR0FBUDtBQUNIOztBQUVNLFNBQVNoUyxvQkFBVCxDQUE4QmdrQyxnQkFBOUIsRUFBZ0RDLGFBQWhELEVBQStEO0FBQ2xFLE1BQUlELGdCQUFKLEVBQXNCO0FBQ2xCLFFBQUlwMEIsS0FBSyxHQUFHVyxJQUFJLENBQUNnRyxLQUFMLENBQVd5dEIsZ0JBQVgsQ0FBWjtBQUNBLFFBQUlFLFVBQVUsR0FBRyxFQUFqQjs7QUFDQSxTQUFLLElBQUk1aUMsVUFBVCxJQUFxQnNPLEtBQXJCLEVBQTRCO0FBQ3hCLFVBQUlBLEtBQUssQ0FBQ21vQixjQUFOLENBQXFCejJCLFVBQXJCLENBQUosRUFBb0M7QUFDaEM0aUMsa0JBQVUsQ0FBQ25uQixJQUFYLENBQWdCaEwsYUFBYSxDQUFDelEsVUFBRCxFQUFXc08sS0FBSyxDQUFDdE8sVUFBRCxDQUFoQixDQUE3QjtBQUNIO0FBQ0osS0FQaUIsQ0FRbEI7OztBQUNBLFFBQUkyaUMsYUFBSixFQUFtQjtBQUNmQSxtQkFBYSxDQUFDQyxVQUFELENBQWI7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFPQSxVQUFQO0FBQ0g7QUFDSixHQWRELE1BY087QUFDSCxRQUFJRCxhQUFKLEVBQW1CO0FBQ2ZBLG1CQUFhLENBQUMsRUFBRCxDQUFiO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBTyxFQUFQO0FBQ0g7QUFDSjtBQUNKO0FBRU0sU0FBU0Usc0JBQVQsQ0FBZ0NGLGFBQWhDLEVBQStDO0FBQ2xELFNBQU8xekIsSUFBSSxDQUFDQyxTQUFMLENBQWV5ekIsYUFBYSxHQUFHcHlCLEdBQWhCLENBQW9CLFVBQUE1QixJQUFJLEVBQUk7QUFDOUMsV0FBTztBQUNIM08sY0FBUSxFQUFFMk8sSUFBSSxDQUFDM08sUUFBTCxFQURQO0FBRUgwUSxjQUFRLEVBQUUvQixJQUFJLENBQUMrQixRQUFMO0FBRlAsS0FBUDtBQUlILEdBTHFCLENBQWYsQ0FBUDtBQU1IO0FBRU0sU0FBU1gsdUJBQVQsQ0FBaUM0eUIsYUFBakMsRUFBZ0Q7QUFDbkQsU0FBT3BsQyxFQUFFLENBQUMwTCxZQUFILENBQWdCLFlBQU07QUFDekIsUUFBSWlNLE1BQU0sR0FBRyxFQUFiO0FBQ0F5dEIsaUJBQWEsR0FBR3BqQixPQUFoQixDQUF3QixVQUFBNVEsSUFBSTtBQUFBLGFBQ3hCdUcsTUFBTSxDQUFDdkcsSUFBSSxDQUFDM08sUUFBTCxFQUFELENBQU4sR0FBMEIyTyxJQUFJLENBQUMrQixRQUFMLEVBREY7QUFBQSxLQUE1QjtBQUVBLFdBQU96QixJQUFJLENBQUNDLFNBQUwsQ0FBZWdHLE1BQWYsQ0FBUDtBQUNILEdBTE0sQ0FBUDtBQU1IO0FBRUQ7Ozs7QUFHTyxJQUFNcUIsaUJBQWI7QUFDSSw2QkFBWVQsSUFBWixFQUFrQjtBQUFBOztBQUNkLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtndEIsTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLQyxVQUFMO0FBRUEsU0FBS0MsVUFBTDtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7QUFFQSxTQUFLQyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0EsU0FBSy9NLFdBQUwsR0FBbUIsRUFBbkI7QUFFQTs7OztBQUlIOztBQWhCTDtBQUFBO0FBQUEsOEJBa0JjbjJCLFFBbEJkLEVBa0J3QnVzQixRQWxCeEIsRUFrQmtDO0FBQzFCLFVBQUksRUFBRXZzQixRQUFRLElBQUksS0FBS2lqQyxRQUFuQixDQUFKLEVBQWtDO0FBQzlCLGFBQUtBLFFBQUwsQ0FBY2pqQyxRQUFkLElBQTBCLEVBQTFCO0FBQ0g7O0FBQ0QsV0FBS2lqQyxRQUFMLENBQWNqakMsUUFBZCxFQUF3QnliLElBQXhCLENBQTZCOFEsUUFBN0I7QUFDSDtBQXZCTDtBQUFBO0FBQUEscUNBeUJxQnZzQixRQXpCckIsRUF5QitCO0FBQ3ZCLGFBQU8sS0FBS2lqQyxRQUFMLENBQWNqakMsUUFBZCxDQUFQO0FBQ0g7QUEzQkw7QUFBQTtBQUFBLGlDQTZCaUI7QUFBQTs7QUFDVCxVQUFJbWpDLFVBQVUsR0FBRyxJQUFqQjtBQUNBLE9BQUMsS0FBS3J0QixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUE1QixFQUNDLEtBQUtxVyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkI0QyxrQkFENUIsRUFFQyxLQUFLbVgsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBRjVCLEVBRWtEK2dCLE9BRmxELENBRTBELFVBQUE2akIsU0FBUztBQUFBLGVBQy9EQSxTQUFTLENBQUN0c0IsU0FBVixDQUFvQixVQUFTdXNCLE9BQVQsRUFBa0I7QUFDbENBLGlCQUFPLENBQUNoaUIsSUFBUixDQUFhLFVBQUN4VCxLQUFELEVBQVF5MUIsTUFBUjtBQUFBLG1CQUFtQkEsTUFBTSxDQUFDdmhDLE1BQVAsQ0FBY3doQyxhQUFkLENBQTRCMTFCLEtBQUssQ0FBQzlMLE1BQWxDLENBQW5CO0FBQUEsV0FBYixFQUNLd2QsT0FETCxDQUNhLFVBQVVpa0IsTUFBVixFQUFrQjtBQUN2QixnQkFBSUMsU0FBUyxHQUFHRCxNQUFNLENBQUM5a0IsS0FBdkI7O0FBQ0EsZ0JBQUk4a0IsTUFBTSxDQUFDemhDLE1BQVAsS0FBa0IsT0FBdEIsRUFBK0I7QUFDM0I7QUFDQSxrQkFBSTRNLElBQUksR0FBR3cwQixVQUFVLENBQUN0N0IsT0FBWCxDQUFtQjQ3QixTQUFTLENBQUN6akMsUUFBVixFQUFuQixFQUF5Q3lqQyxTQUFTLENBQUMveUIsUUFBVixFQUF6QyxFQUErRCt5QixTQUFTLENBQUMveUIsUUFBekUsQ0FBWDtBQUNBeXlCLHdCQUFVLENBQUNPLGFBQVgsQ0FBeUIvMEIsSUFBekI7QUFDSCxhQUpELE1BSU8sSUFBSTYwQixNQUFNLENBQUN6aEMsTUFBUCxLQUFrQixTQUF0QixFQUFpQztBQUNwQztBQUNBLGtCQUFJNE0sS0FBSSxHQUFHdzBCLFVBQVUsQ0FBQ3BXLGtCQUFYLENBQThCMFcsU0FBUyxDQUFDempDLFFBQVYsRUFBOUIsQ0FBWDs7QUFDQSxrQkFBSW1qQyxVQUFVLENBQUNydEIsSUFBWCxDQUFnQjFZLEtBQWhCLENBQXNCMkMsT0FBdEIsQ0FBOEJDLFFBQTlCLE9BQTZDeWpDLFNBQVMsQ0FBQ3pqQyxRQUFWLEVBQWpELEVBQXVFO0FBQ25FbWpDLDBCQUFVLENBQUNydEIsSUFBWCxDQUFnQjFZLEtBQWhCLENBQXNCMkMsT0FBdEIsQ0FBOEJDLFFBQTlCLENBQXVDLFdBQXZDO0FBQ0g7QUFDSjtBQUNKLFdBZEw7QUFlSCxTQWhCRCxFQWdCRyxLQWhCSCxFQWdCUyxhQWhCVCxDQUQrRDtBQUFBLE9BRm5FO0FBcUJILEtBcERMLENBc0RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7Ozs7O0FBbEVKO0FBQUE7QUFBQSxpQ0F1RWlCMk8sSUF2RWpCLEVBdUV1QjtBQUNmLFVBQUlBLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsV0FBdEIsRUFBbUM7QUFDL0IyTyxZQUFJLENBQUNrQixNQUFMLEdBQWMsS0FBS2lHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQXpDO0FBQ0gsT0FGRCxNQUVPLElBQUlvUCxJQUFJLENBQUMzTyxRQUFMLEtBQWtCLFlBQXRCLEVBQW9DO0FBQ3ZDMk8sWUFBSSxDQUFDa0IsTUFBTCxHQUFjLEtBQUtpRyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzQyxLQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJc1EsSUFBSSxDQUFDM08sUUFBTCxLQUFrQixlQUF0QixFQUF1QztBQUMxQzJPLFlBQUksQ0FBQ2tCLE1BQUwsR0FBYyxLQUFLaUcsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSXFRLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsYUFBdEIsRUFBcUM7QUFDeEMyTyxZQUFJLENBQUNrQixNQUFMLEdBQWMsS0FBS2lHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUlvUSxJQUFJLENBQUMzTyxRQUFMLEtBQWtCLGtCQUF0QixFQUEwQztBQUM3QzJPLFlBQUksQ0FBQ2tCLE1BQUwsR0FBYyxLQUFLaUcsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCK0IsWUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSTZRLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsbUJBQXRCLEVBQTJDO0FBQzlDMk8sWUFBSSxDQUFDa0IsTUFBTCxHQUFjLEtBQUtpRyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJxQyxZQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJdVEsSUFBSSxDQUFDM08sUUFBTCxLQUFrQixvQkFBdEIsRUFBNEM7QUFDL0MsYUFBSzJqQyxlQUFMLENBQXFCaDFCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSW1RLElBQUksQ0FBQzNPLFFBQUwsS0FBa0Isa0JBQXRCLEVBQTBDO0FBQzdDLGFBQUsyakMsZUFBTCxDQUFxQmgxQixJQUFyQixFQUEyQixLQUFLbUgsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQXREO0FBQ0gsT0FGTSxNQUVBLElBQUltUSxJQUFJLENBQUMzTyxRQUFMLEtBQWtCLG1CQUF0QixFQUEyQztBQUM5QyxhQUFLMmpDLGVBQUwsQ0FBcUJoMUIsSUFBckIsRUFBMkIsS0FBS21ILElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUF0RDtBQUNILE9BRk0sTUFFQSxJQUFJbVEsSUFBSSxDQUFDM08sUUFBTCxLQUFrQixtQkFBdEIsRUFBMkM7QUFDOUMsYUFBSzJqQyxlQUFMLENBQXFCaDFCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSW1RLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsZUFBdEIsRUFBdUM7QUFDMUMyTyxZQUFJLENBQUNrQixNQUFMLEdBQWMsS0FBS2lHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQmlELElBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUkyUCxJQUFJLENBQUMzTyxRQUFMLEtBQWtCLDhCQUF0QixFQUFzRDtBQUN6RDJPLFlBQUksQ0FBQ2tCLE1BQUwsR0FBYyxLQUFLaUcsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSXNQLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsNkJBQXRCLEVBQXFEO0FBQ3hEMk8sWUFBSSxDQUFDa0IsTUFBTCxHQUFjLEtBQUtpRyxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJrRCxpQkFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSTBQLElBQUksQ0FBQzNPLFFBQUwsS0FBa0IsbUJBQXRCLEVBQTJDO0FBQzlDMk8sWUFBSSxDQUFDa0IsTUFBTCxHQUFjLEtBQUtpRyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBOUI7QUFDSCxPQUZNLE1BRUEsSUFBSTRPLElBQUksQ0FBQzNPLFFBQUwsQ0FBY2lRLFVBQWQsQ0FBeUIsR0FBekIsQ0FBSixFQUFtQztBQUN0QyxhQUFLMHpCLGVBQUwsQ0FBcUJoMUIsSUFBckIsRUFBMkIsS0FBS21ILElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjRDLGtCQUF0RDtBQUNILE9BRk0sTUFFQSxJQUFJZ1EsSUFBSSxDQUFDM08sUUFBTCxDQUFjaVEsVUFBZCxDQUF5QixHQUF6QixLQUNBdEIsSUFBSSxDQUFDM08sUUFBTCxDQUFjaVEsVUFBZCxDQUF5QixHQUF6QixDQURBLElBRUF0QixJQUFJLENBQUMzTyxRQUFMLENBQWNpUSxVQUFkLENBQXlCLEdBQXpCLENBRkosRUFFbUM7QUFDdEMsYUFBSzB6QixlQUFMLENBQXFCaDFCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUpNLE1BSUE7QUFDSCxhQUFLbWxDLGVBQUwsQ0FBcUJoMUIsSUFBckIsRUFBMkIsS0FBS21ILElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnlELFVBQXREO0FBQ0g7QUFDSjtBQTdHTDtBQUFBO0FBQUEsb0NBK0dvQmtQLElBL0dwQixFQStHMEJpMUIsS0EvRzFCLEVBK0dpQztBQUN6QmoxQixVQUFJLENBQUM2ekIsS0FBTCxHQUFhb0IsS0FBYjtBQUNBLFVBQUlDLFVBQVUsR0FBR2wxQixJQUFJLENBQUM2ekIsS0FBTCxFQUFqQjs7QUFDQSxXQUFLLElBQUlua0IsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHd2xCLFVBQVUsQ0FBQ2oxQixNQUE3QixFQUFxQ3lQLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsWUFBSXdsQixVQUFVLENBQUN4bEIsQ0FBRCxDQUFWLENBQWNyZSxRQUFkLE9BQTZCMk8sSUFBSSxDQUFDM08sUUFBdEMsRUFBZ0Q7QUFDNUMyTyxjQUFJLENBQUNrQixNQUFMLEdBQWNnMEIsVUFBVSxDQUFDeGxCLENBQUQsQ0FBVixDQUFjM04sUUFBNUI7QUFDSDtBQUNKOztBQUNELFVBQUkvQixJQUFJLENBQUNrQixNQUFMLEtBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLFlBQUloSSxPQUFPLEdBQUc0SSxhQUFhLENBQUM5QixJQUFJLENBQUMzTyxRQUFOLENBQTNCO0FBQ0EyTyxZQUFJLENBQUNrQixNQUFMLEdBQWNoSSxPQUFPLENBQUM2SSxRQUF0QjtBQUNBa3pCLGFBQUssQ0FBQ25vQixJQUFOLENBQVc1VCxPQUFYO0FBQ0g7QUFDSjtBQTVITDtBQUFBO0FBQUEsaUNBOEhpQjtBQUNULFdBQUtBLE9BQUwsQ0FBYSxXQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLG1CQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLFlBQWI7QUFDQSxXQUFLQSxPQUFMLENBQWEsa0JBQWI7QUFDQSxXQUFLQSxPQUFMLENBQWEsOEJBQWI7QUFDSDtBQXBJTDtBQUFBO0FBQUEseUNBc0l5QjtBQUNqQixXQUFLLElBQUlwSyxJQUFULElBQWlCLEtBQUtxbEMsTUFBdEIsRUFBOEI7QUFDMUIsWUFBSSxLQUFLQSxNQUFMLENBQVlyTSxjQUFaLENBQTJCaDVCLElBQTNCLENBQUosRUFBc0M7QUFDbEMsY0FBSW9ULGlCQUFpQixDQUFDQyxPQUFsQixDQUEwQnJULElBQTFCLE1BQW9DLENBQUMsQ0FBekMsRUFBNEM7QUFDeEMsbUJBQU8sS0FBS3FsQyxNQUFMLENBQVlybEMsSUFBWixDQUFQO0FBQ0EsbUJBQU8sS0FBS3dsQyxRQUFMLENBQWN4bEMsSUFBZCxDQUFQO0FBQ0g7QUFDSjtBQUNKLE9BUmdCLENBU2pCOztBQUNIO0FBaEpMO0FBQUE7QUFBQSw0QkFrSll1QyxRQWxKWixFQWtKc0IwUSxRQWxKdEIsRUFrSmdDK3lCLFNBbEpoQyxFQWtKMkM7QUFDbkMsVUFBSXpqQyxRQUFRLElBQUksS0FBSzhpQyxNQUFyQixFQUE2QjtBQUN6QjtBQUNBLFlBQUlnQixZQUFZLEdBQUcsS0FBS2hCLE1BQUwsQ0FBWTlpQyxRQUFaLENBQW5COztBQUNBLFlBQUl5akMsU0FBUyxLQUFLdm5DLFNBQWxCLEVBQTZCO0FBQ3pCLGVBQUs2bkMsWUFBTCxDQUFrQkQsWUFBbEI7QUFDSCxTQUZELE1BRU87QUFDSEEsc0JBQVksQ0FBQ2owQixNQUFiLEdBQXNCNHpCLFNBQXRCO0FBQ0g7O0FBQ0RLLG9CQUFZLENBQUNqMEIsTUFBYixDQUFvQmEsUUFBUSxJQUFJLEVBQWhDO0FBQ0EsZUFBT296QixZQUFQO0FBQ0gsT0FWRCxNQVVPO0FBQ0g7QUFDQSxZQUFJajhCLE9BQU8sR0FBRyxJQUFJMDZCLFdBQUosQ0FBZ0IsS0FBS3pzQixJQUFyQixFQUEyQjlWLFFBQTNCLENBQWQ7QUFDQSxhQUFLOGlDLE1BQUwsQ0FBWTlpQyxRQUFaLElBQXdCNkgsT0FBeEI7O0FBQ0EsWUFBSTQ3QixTQUFTLEtBQUt2bkMsU0FBbEIsRUFBNkI7QUFDekIsZUFBSzZuQyxZQUFMLENBQWtCbDhCLE9BQWxCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLGlCQUFPLENBQUNnSSxNQUFSLEdBQWlCNHpCLFNBQWpCO0FBQ0g7O0FBQ0QsWUFBSS95QixRQUFRLEtBQUt4VSxTQUFqQixFQUE0QjtBQUN4QjJMLGlCQUFPLENBQUNnSSxNQUFSLENBQWVhLFFBQWY7QUFDSDs7QUFDRCxlQUFPN0ksT0FBUDtBQUNIO0FBQ0o7QUEzS0w7QUFBQTtBQUFBLDhCQTZLYzdILFFBN0tkLEVBNkt3QjBRLFFBN0t4QixFQTZLa0M7QUFDMUJBLGNBQVEsR0FBR0EsUUFBUSxJQUFJLEVBQXZCO0FBQ0EsV0FBS295QixNQUFMLENBQVk5aUMsUUFBWixFQUFzQjZQLE1BQXRCLENBQTZCYSxRQUE3QjtBQUNIO0FBaExMO0FBQUE7QUFBQSw2QkFrTGExUSxRQWxMYixFQWtMdUI7QUFDZixhQUFPLEtBQUs4aUMsTUFBTCxDQUFZOWlDLFFBQVosRUFBc0I2UCxNQUF0QixFQUFQO0FBQ0g7QUFwTEw7QUFBQTtBQUFBLDRCQXNMWTdQLFFBdExaLEVBc0xzQjtBQUNkLGFBQU8sS0FBSzhpQyxNQUFMLENBQVk5aUMsUUFBWixDQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBMUxKO0FBQUE7QUFBQSwrQkErTGVBLFFBL0xmLEVBK0x5QjtBQUNqQixVQUFJc2lDLHNCQUFzQixDQUFDeHhCLE9BQXZCLENBQStCOVEsUUFBL0IsTUFBNkMsQ0FBQyxDQUFsRCxFQUFxRDtBQUNqRCxZQUFJMk8sSUFBSSxHQUFHLEtBQUtvZSxrQkFBTCxDQUF3Qi9zQixRQUF4QixDQUFYO0FBQ0EyTyxZQUFJLENBQUNrQixNQUFMLENBQVksSUFBWjtBQUNBLGVBQU8sSUFBUDtBQUNILE9BSkQsTUFJTyxJQUFJLEtBQUtpekIsTUFBTCxDQUFZOWlDLFFBQVosRUFBc0J3aUMsS0FBdEIsS0FBZ0MsSUFBcEMsRUFBMEM7QUFDN0MsZUFBTyxLQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0g7QUFDQSxZQUFJdE0sS0FBSyxHQUFHLEtBQUs0TSxNQUFMLENBQVk5aUMsUUFBWixFQUFzQndpQyxLQUF0QixDQUE0QjFwQixNQUE1QixDQUFtQyxVQUFBMnFCLFNBQVM7QUFBQSxpQkFBSUEsU0FBUyxDQUFDempDLFFBQVYsT0FBeUJBLFFBQTdCO0FBQUEsU0FBNUMsQ0FBWjtBQUNBLGVBQU9rMkIsS0FBSyxJQUFJLEtBQWhCO0FBQ0g7QUFDSjtBQTNNTDtBQUFBO0FBQUEsdUNBNk11QmwyQixRQTdNdkIsRUE2TWlDO0FBQ3pCLFVBQUkyTyxJQUFJLEdBQUcsS0FBS20wQixNQUFMLENBQVk5aUMsUUFBWixDQUFYO0FBQ0EsYUFBTyxLQUFLOGlDLE1BQUwsQ0FBWTlpQyxRQUFaLENBQVA7O0FBQ0EsVUFBSUEsUUFBUSxJQUFJLEtBQUtpakMsUUFBckIsRUFBK0I7QUFDM0IsYUFBS0EsUUFBTCxDQUFjampDLFFBQWQsRUFBd0J1ZixPQUF4QixDQUFnQyxVQUFBZ04sUUFBUTtBQUFBLGlCQUFJQSxRQUFRLENBQUNsSCxPQUFULEVBQUo7QUFBQSxTQUF4QztBQUNIOztBQUNELGFBQU8xVyxJQUFQO0FBQ0g7QUFwTkw7QUFBQTtBQUFBLCtCQXNOZXFjLE1BdE5mLEVBc051QmdaLFdBdE52QixFQXNOb0M7QUFDNUIsVUFBSWh6QixpQkFBaUIsQ0FBQ0YsT0FBbEIsQ0FBMEJrYSxNQUExQixNQUFzQyxDQUFDLENBQTNDLEVBQThDO0FBQzFDLGVBQU8sS0FBUDtBQUNILE9BRkQsTUFFTyxJQUFJLEtBQUs4WCxNQUFMLENBQVk5aUMsUUFBWixFQUFzQndpQyxLQUF0QixLQUFnQyxJQUFwQyxFQUEwQztBQUM3QyxlQUFPLEtBQVA7QUFDSCxPQUZNLE1BRUE7QUFDSDtBQUNBLFlBQUl0TSxLQUFLLEdBQUcsS0FBSzRNLE1BQUwsQ0FBWTlpQyxRQUFaLEVBQXNCd2lDLEtBQXRCLENBQTRCMXBCLE1BQTVCLENBQW1DLFVBQUEycUIsU0FBUztBQUFBLGlCQUFJQSxTQUFTLENBQUN6akMsUUFBVixPQUF5QkEsUUFBN0I7QUFBQSxTQUE1QyxDQUFaO0FBQ0EsZUFBT2syQixLQUFLLElBQUksS0FBaEI7QUFDSDtBQUNKO0FBaE9MO0FBQUE7QUFBQSxrQ0FrT2tCdm5CLElBbE9sQixFQWtPd0I7QUFDaEIsVUFBSUEsSUFBSSxDQUFDM08sUUFBTCxJQUFpQixLQUFLaWpDLFFBQTFCLEVBQW9DO0FBQ2hDLGFBQUtBLFFBQUwsQ0FBY3QwQixJQUFJLENBQUMzTyxRQUFuQixFQUE2QnVmLE9BQTdCLENBQXFDLFVBQUFnTixRQUFRO0FBQUEsaUJBQUlBLFFBQVEsQ0FBQ3BILE9BQVQsQ0FBaUJ4VyxJQUFqQixDQUFKO0FBQUEsU0FBN0M7QUFDSDtBQUNKO0FBdE9MO0FBQUE7QUFBQSxrQ0F3T2tCbFIsSUF4T2xCLEVBd093QndtQyxhQXhPeEIsRUF3T3VDO0FBQy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQSxVQUFJeG1DLElBQUksQ0FBQ3dTLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN2QnhTLFlBQUksR0FBR0EsSUFBSSxDQUFDeVMsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUNELFVBQUlnMEIsVUFBVSxHQUFHaEMsV0FBVyxDQUFDQyxVQUE3QixDQXpCK0IsQ0EwQi9COztBQUNBLFVBQUkxa0MsSUFBSSxDQUFDd1MsVUFBTCxDQUFnQit4QixvQkFBaEIsQ0FBSixFQUEyQztBQUN2Q3ZrQyxZQUFJLEdBQUdBLElBQUksQ0FBQ3lTLEtBQUwsQ0FBVzh4QixvQkFBb0IsQ0FBQ3B6QixNQUFoQyxDQUFQO0FBQ0FzMUIsa0JBQVUsR0FBR2hDLFdBQVcsQ0FBQ0UscUJBQXpCO0FBQ0gsT0E5QjhCLENBK0IvQjs7O0FBQ0EsVUFBSTNrQyxJQUFJLENBQUN3UyxVQUFMLENBQWdCZ3lCLGlCQUFoQixDQUFKLEVBQXdDO0FBQ3BDeGtDLFlBQUksR0FBR0EsSUFBSSxDQUFDeVMsS0FBTCxDQUFXK3hCLGlCQUFpQixDQUFDcnpCLE1BQTdCLENBQVA7QUFDQXMxQixrQkFBVSxHQUFHaEMsV0FBVyxDQUFDRyxrQkFBekI7QUFDSCxPQUhELE1BR08sSUFBSTRCLGFBQUosRUFBbUI7QUFDdEJDLGtCQUFVLEdBQUdoQyxXQUFXLENBQUNHLGtCQUF6QjtBQUNILE9BckM4QixDQXNDL0I7OztBQUNBLFVBQUl2eUIsaUJBQWlCLEdBQUcsS0FBS2dHLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnlELFVBQTNCLEVBQXhCO0FBQ0EsVUFBSWpCLG9CQUFvQixHQUFHLEtBQUtzWCxJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBM0IsRUFBM0I7QUFDQSxVQUFJRyxrQkFBa0IsR0FBRyxLQUFLbVgsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCNEMsa0JBQTNCLEVBQXpCLENBekMrQixDQTBDL0I7O0FBQ0EsVUFBSXdsQyxXQUFXLEdBQUcsS0FBS0Msc0JBQUwsQ0FBNEIzbUMsSUFBNUIsRUFBa0N5bUMsVUFBbEMsQ0FBbEI7O0FBQ0EsVUFBSUMsV0FBVyxLQUFLam9DLFNBQXBCLEVBQStCO0FBQzNCLGVBQU9pb0MsV0FBUDtBQUNILE9BOUM4QixDQStDL0I7OztBQUNBLFVBQUlFLGNBQWMsR0FBRyxLQUFLQyxvQkFBTCxDQUEwQngwQixpQkFBMUIsRUFBNkNyUyxJQUE3QyxDQUFyQjtBQUNBLFVBQUk4bUMsZ0JBQWdCLEdBQUcsS0FBS0Qsb0JBQUwsQ0FBMEJ4MEIsaUJBQTFCLEVBQTZDLE1BQUlyUyxJQUFqRCxDQUF2QjtBQUNBLFVBQUkrbUMsY0FBYyxHQUFHLEtBQUtGLG9CQUFMLENBQTBCOWxDLG9CQUExQixFQUFnRCxNQUFJZixJQUFwRCxDQUFyQjtBQUNBLFVBQUlnbkMsYUFBYSxHQUFHLEtBQUtILG9CQUFMLENBQTBCOWxDLG9CQUExQixFQUFnRCxNQUFJZixJQUFwRCxDQUFwQjtBQUNBLFVBQUlpbkMsYUFBYSxHQUFHLEtBQUt4QixZQUFMLENBQWtCemxDLElBQWxCLENBQXBCOztBQUNBLFVBQUl5bUMsVUFBVSxLQUFLaEMsV0FBVyxDQUFDRyxrQkFBL0IsRUFBbUQ7QUFDL0MsZUFBT3NDLHNFQUFpQixDQUFDRixhQUFELEVBQWdCRCxjQUFoQixFQUFnQ0gsY0FBaEMsRUFBZ0RFLGdCQUFoRCxFQUFrRUcsYUFBbEUsQ0FBeEI7QUFDSDs7QUFDRCxVQUFJRSxpQkFBaUIsR0FBRyxLQUFLTixvQkFBTCxDQUEwQjlsQyxvQkFBMUIsRUFBZ0QsTUFBSWYsSUFBcEQsQ0FBeEI7QUFDQSxVQUFJb25DLGVBQWUsR0FBRyxLQUFLUCxvQkFBTCxDQUEwQjNsQyxrQkFBMUIsRUFBOEMsTUFBSWxCLElBQWxELENBQXRCOztBQUNBLFVBQUl5bUMsVUFBVSxLQUFLaEMsV0FBVyxDQUFDRSxxQkFBL0IsRUFBc0Q7QUFDbEQsZUFBT3VDLHNFQUFpQixDQUFDQyxpQkFBRCxFQUFvQkgsYUFBcEIsRUFBbUNJLGVBQW5DLEVBQ0NMLGNBREQsRUFDaUJILGNBRGpCLEVBQ2lDRSxnQkFEakMsRUFDbURHLGFBRG5ELENBQXhCO0FBRUgsT0FIRCxNQUdPLElBQUlSLFVBQVUsS0FBS2hDLFdBQVcsQ0FBQ0MsVUFBL0IsRUFBMkM7QUFDOUMsZUFBT3dDLHNFQUFpQixDQUFDSCxjQUFELEVBQWlCSCxjQUFqQixFQUFpQ0UsZ0JBQWpDLEVBQ0NLLGlCQURELEVBQ29CSCxhQURwQixFQUNtQ0ksZUFEbkMsRUFDb0RILGFBRHBELENBQXhCO0FBRUg7QUFDSjtBQXpTTDtBQUFBO0FBQUEseUNBMlN5QkksU0EzU3pCLEVBMlNvQzlrQyxRQTNTcEMsRUEyUzhDO0FBQ3RDLFdBQUssSUFBSXFlLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR3ltQixTQUFTLENBQUNsMkIsTUFBNUIsRUFBb0N5UCxDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDLFlBQUl5bUIsU0FBUyxDQUFDem1CLENBQUQsQ0FBVCxDQUFhcmUsUUFBYixPQUE0QkEsUUFBaEMsRUFBMEM7QUFDdEMsaUJBQU84a0MsU0FBUyxDQUFDem1CLENBQUQsQ0FBaEI7QUFDSDtBQUNKOztBQUNELGFBQU9uaUIsU0FBUDtBQUNIO0FBbFRMO0FBQUE7QUFBQSwyQ0FvVDJCOEQsUUFwVDNCLEVBb1RxQ2trQyxVQXBUckMsRUFvVGlEO0FBQ3pDLFVBQUlBLFVBQVUsS0FBS2hDLFdBQVcsQ0FBQ0csa0JBQS9CLEVBQW1EO0FBQy9DLFlBQUlyaUMsUUFBUSxLQUFLLFdBQWpCLEVBQThCO0FBQzFCLGlCQUFPeWlDLGlCQUFpQixDQUFDLHVCQUFELEVBQTBCLEtBQUszc0IsSUFBTCxDQUFVMVksS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCdUQsSUFBM0IsRUFBMUIsQ0FBeEI7QUFDSDs7QUFDRCxlQUFPckQsU0FBUDtBQUNIOztBQUNELGNBQVE4RCxRQUFSO0FBQ0ksYUFBSyxXQUFMO0FBQ0ksaUJBQU95aUMsaUJBQWlCLENBQUMsdUJBQUQsRUFBMEIsS0FBSzNzQixJQUFMLENBQVUxWSxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixFQUExQixDQUF4Qjs7QUFDSixhQUFLLFdBQUw7QUFDSSxpQkFBT2tqQyxpQkFBaUIsQ0FBQyx1QkFBRCxFQUEwQixLQUFLM3NCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNDLEtBQTNCLEVBQTFCLENBQXhCOztBQUNKLGFBQUssY0FBTDtBQUNJLGlCQUFPb2tDLGlCQUFpQixDQUFDLDBCQUFELEVBQTZCLEtBQUszc0IsSUFBTCxDQUFVMVksS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCdUMsUUFBM0IsRUFBN0IsQ0FBeEI7O0FBQ0osYUFBSyxZQUFMO0FBQ0ksaUJBQU9ta0MsaUJBQWlCLENBQUMsd0JBQUQsRUFBMkIsS0FBSzNzQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ3QyxNQUEzQixFQUEzQixDQUF4Qjs7QUFDSixhQUFLLGlCQUFMO0FBQ0ksaUJBQU9ra0MsaUJBQWlCLENBQUMsNkJBQUQsRUFBZ0MsS0FBSzNzQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkIrQixZQUEzQixFQUFoQyxDQUF4Qjs7QUFDSixhQUFLLGtCQUFMO0FBQ0ksaUJBQU8ya0MsaUJBQWlCLENBQUMsOEJBQUQsRUFBaUMsS0FBSzNzQixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJxQyxZQUEzQixFQUFqQyxDQUF4QjtBQVpSOztBQWNBLGFBQU9sQyxTQUFQO0FBQ0g7QUExVUw7QUFBQTtBQUFBLGtDQTRVa0JrakMsSUE1VWxCLEVBNFV3QjtBQUFBOztBQUNoQixVQUFJbGUsSUFBSSxHQUFHaGIsQ0FBQyxDQUFDMjdCLCtCQUFELENBQVo7QUFDQSxVQUFJN2hDLFFBQVEsR0FBR2toQixJQUFJLENBQUNyVSxJQUFMLENBQVUsMENBQVYsQ0FBZjtBQUNBLFVBQUlrNEIsUUFBUSxHQUFHN2pCLElBQUksQ0FBQ3JVLElBQUwsQ0FBVSwwQ0FBVixDQUFmO0FBQ0EsVUFBSW00QixTQUFTLEdBQUc5akIsSUFBSSxDQUFDclUsSUFBTCxDQUFVLDJDQUFWLENBQWhCO0FBQ0EsVUFBSW80QixjQUFjLEdBQUcsaUJBQXJCO0FBQ0FqbEMsY0FBUSxDQUFDd2lCLEVBQVQsQ0FBWSxPQUFaLEVBQXFCLFlBQU07QUFDdkIsWUFBSTBCLFNBQVMsR0FBRytnQixjQUFjLENBQUNDLElBQWYsQ0FBb0JsbEMsUUFBUSxDQUFDc1YsR0FBVCxFQUFwQixFQUFvQyxDQUFwQyxDQUFoQjtBQUNBNE8saUJBQVMsR0FBR0EsU0FBUyxLQUFLaG9CLFNBQWQsR0FBMEIsY0FBMUIsR0FBMkNnb0IsU0FBdkQsQ0FGdUIsQ0FHdkI7O0FBQ0E2Z0IsZ0JBQVEsQ0FBQ2h2QixJQUFULENBQWNtTyxTQUFkO0FBQ0gsT0FMRDs7QUFNQSxVQUFJaEMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sR0FBTTtBQUNaLFlBQUlpakIsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsWUFBSS9GLElBQUksS0FBSyxZQUFiLEVBQTJCO0FBQ3ZCK0YsZ0JBQU0sR0FBR0gsU0FBUyxDQUFDMXZCLEdBQVYsRUFBVDtBQUNILFNBRkQsTUFFTyxJQUFJOHBCLElBQUksS0FBSyxVQUFiLEVBQXlCO0FBQzVCK0YsZ0JBQU0sR0FBRyxHQUFUO0FBQ0g7O0FBRUQsWUFBSW5sQyxRQUFRLENBQUNzVixHQUFULEVBQUosRUFBb0I7QUFDaEJ0VixrQkFBUSxHQUFHbWxDLE1BQU0sR0FBQ25sQyxRQUFRLENBQUNzVixHQUFULEVBQWxCOztBQUNBLGdCQUFJLENBQUN6TixPQUFMLENBQWE3SCxRQUFiO0FBQ0g7QUFDSixPQVpEOztBQWFBa2hCLFVBQUksQ0FBQ2trQixNQUFMLENBQVksVUFBQ3J3QixDQUFELEVBQU87QUFDZkEsU0FBQyxDQUFDc3dCLGNBQUY7QUFDQW5qQixXQUFHOztBQUNILGNBQUksQ0FBQ3BNLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QnVZLEtBQTVCO0FBQ0gsT0FKRDtBQUtBLFdBQUt2TSxJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEIyWSxPQUE1QixDQUFvQyxlQUFwQyxFQUFxRHZCLElBQXJELEVBQTJEZ0IsR0FBM0QsRUFBZ0UsWUFBSSxDQUFFLENBQXRFLEVBQXdFLEtBQXhFO0FBQ0g7QUEzV0w7QUFBQTtBQUFBLHNDQTZXZ0M7QUFBQTs7QUFBQSxVQUFaNVQsS0FBWSx1RUFBTixJQUFNO0FBQ3hCOztBQUNBOzs7O0FBSUEsVUFBSWxSLEtBQUssR0FBRyxLQUFLMFksSUFBTCxDQUFVMVksS0FBdEI7QUFFQSxVQUFNa29DLFlBQVksR0FBR2xvQyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJpbUMsWUFBMUIsTUFBNENsb0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCa21DLGVBQTFCLEVBQWpFOztBQUNBLFVBQUksQ0FBQ0QsWUFBRCxJQUFpQixDQUFDaDNCLEtBQXRCLEVBQTZCO0FBQ3pCLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQUlsUixLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJpbUMsWUFBMUIsRUFBSixFQUE4QztBQUMxQyxZQUFJO0FBQ0FoM0IsZUFBSyxHQUFHVyxJQUFJLENBQUNnRyxLQUFMLENBQVdxd0IsWUFBWCxDQUFSO0FBQ0gsU0FGRCxDQUVFLE9BQU92d0IsQ0FBUCxFQUFVO0FBQ1I1TixpQkFBTyxDQUFDK1ksS0FBUixDQUFjLDhDQUFkLEVBQThEbkwsQ0FBOUQ7QUFDQSxpQkFBTyxJQUFQO0FBQ0g7O0FBQ0QsYUFBS3l3QixtQkFBTCxDQUF5QmwzQixLQUF6QjtBQUNILE9BUkQsTUFRTyxJQUFJQSxLQUFKLEVBQVc7QUFDZCxhQUFLazNCLG1CQUFMLENBQXlCLEtBQUtDLGVBQUwsQ0FBcUJuM0IsS0FBckIsQ0FBekI7QUFDSCxPQUZNLE1BRUE7QUFDSCxhQUFLd0gsSUFBTCxDQUFVelAsVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJoRCxpQkFBNUIsQ0FBOEMsVUFBQzRELElBQUQsRUFBVTtBQUNwRCxnQkFBSSxDQUFDcytCLG1CQUFMLENBQXlCLE1BQUksQ0FBQ0MsZUFBTCxDQUFxQnYrQixJQUFJLENBQUNvSCxLQUExQixDQUF6QjtBQUNILFNBRkQ7QUFHSDtBQUNKO0FBeFlMO0FBQUE7QUFBQSxvQ0EwWW9CQSxLQTFZcEIsRUEwWTJCO0FBQUE7O0FBQ25CLFVBQU1vM0IsU0FBUyxHQUFHLEVBQWxCO0FBQ0F2a0IsWUFBTSxDQUFDd2tCLE9BQVAsQ0FBZXIzQixLQUFmLEVBQXNCaVIsT0FBdEIsQ0FBOEIsZ0JBQThCO0FBQUE7QUFBQSxZQUE1Qm5NLFNBQTRCO0FBQUEsWUFBakJ3eUIsV0FBaUI7O0FBQ3hEQSxtQkFBVyxDQUFDcm1CLE9BQVosQ0FBb0IsaUJBQXFCO0FBQUE7QUFBQSxjQUFuQnZmLFFBQW1CO0FBQUEsY0FBVGpDLEdBQVM7O0FBQ3JDLGNBQU0wcUIsWUFBWSxHQUFHLElBQUk3RCxHQUFKLENBQVE3bUIsR0FBUixFQUFhdW1CLE1BQU0sQ0FBQ2tFLFFBQVAsQ0FBZ0IvUCxNQUE3QixFQUFxQ2dRLFlBQTFEO0FBQ0EsY0FBTW9kLFNBQVMsR0FBR3BkLFlBQVksQ0FBQ3ZyQixHQUFiLENBQWlCLFdBQWpCLENBQWxCO0FBQ0EsY0FBTWtXLFNBQVMsR0FBR3FWLFlBQVksQ0FBQ3ZyQixHQUFiLENBQWlCLFdBQWpCLENBQWxCOztBQUNBLGNBQUksRUFBRWtXLFNBQVMsSUFBSXN5QixTQUFmLENBQUosRUFBK0I7QUFDM0JBLHFCQUFTLENBQUN0eUIsU0FBRCxDQUFULEdBQXVCLEVBQXZCO0FBQ0g7O0FBQ0QsY0FBSSxFQUFFeXlCLFNBQVMsSUFBSUgsU0FBUyxDQUFDdHlCLFNBQUQsQ0FBeEIsQ0FBSixFQUEwQztBQUN0Q3N5QixxQkFBUyxDQUFDdHlCLFNBQUQsQ0FBVCxDQUFxQnl5QixTQUFyQixJQUFrQyxFQUFsQztBQUNIOztBQUNESCxtQkFBUyxDQUFDdHlCLFNBQUQsQ0FBVCxDQUFxQnl5QixTQUFyQixFQUFnQzdsQyxRQUFoQyxJQUE0QyxJQUE1QztBQUNBLGdCQUFJLENBQUNtMkIsV0FBTCxDQUFpQm4yQixRQUFqQixJQUE2QmpDLEdBQTdCO0FBQ0gsU0FaRDtBQWFILE9BZEQ7QUFlQSxhQUFPMm5DLFNBQVA7QUFDSDtBQTVaTDtBQUFBO0FBQUEsd0NBOFp3QnAzQixLQTlaeEIsRUE4WitCO0FBQUE7O0FBQ3ZCLFVBQU13M0IsaUJBQWlCLEdBQUcza0IsTUFBTSxDQUFDQyxJQUFQLENBQVksS0FBSzhoQixZQUFqQixDQUExQjtBQUNBL2hCLFlBQU0sQ0FBQ3drQixPQUFQLENBQWVyM0IsS0FBZixFQUFzQmlSLE9BQXRCLENBQThCLGlCQUFnQztBQUFBO0FBQUEsWUFBOUJuTSxTQUE4QjtBQUFBLFlBQW5CMnlCLGFBQW1COztBQUMxRDVrQixjQUFNLENBQUN3a0IsT0FBUCxDQUFlSSxhQUFmLEVBQThCeG1CLE9BQTlCLENBQXNDLGlCQUFnQztBQUFBO0FBQUEsY0FBOUJzbUIsU0FBOEI7QUFBQSxjQUFuQkcsYUFBbUI7O0FBQ2xFN2tCLGdCQUFNLENBQUN3a0IsT0FBUCxDQUFlSyxhQUFmLEVBQThCem1CLE9BQTlCLENBQXNDLGlCQUE2QjtBQUFBO0FBQUEsZ0JBQTNCdmYsUUFBMkI7QUFBQSxnQkFBakJpbUMsV0FBaUI7O0FBQy9ELGdCQUFJQSxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDdEJBLHlCQUFXLEdBQUdqbUMsUUFBZDtBQUNIOztBQUNELGdCQUFJLEVBQUVpbUMsV0FBVyxJQUFJLE1BQUksQ0FBQy9DLFlBQXRCLENBQUosRUFBeUM7QUFDckMsb0JBQUksQ0FBQ3B0QixJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjlDLFlBQTVCLENBQXlDNFAsU0FBekMsRUFBb0R5eUIsU0FBcEQsRUFBK0Q3bEMsUUFBL0QsRUFBeUUsVUFBQ2tILElBQUQsRUFBVTtBQUMvRSxzQkFBSSxDQUFDZzhCLFlBQUwsQ0FBa0IrQyxXQUFsQixJQUFpQ3hELGlCQUFpQixDQUFDd0QsV0FBRCxFQUFjLytCLElBQWQsQ0FBbEQ7QUFDQSx1QkFBTzQrQixpQkFBaUIsQ0FBQ0csV0FBRCxDQUF4QjtBQUNILGVBSEQ7QUFJSDtBQUNKLFdBVkQ7QUFXSCxTQVpEO0FBYUgsT0FkRCxFQUZ1QixDQWlCdkI7QUFDSDtBQWhiTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7QUN4U0E7QUFBQTtBQUFBO0FBQ08sSUFBSUMsV0FBVyxrM0VBQWYsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRFA7QUFFTyxJQUFNeGIsb0JBQW9CLDA0Q0FBMUI7QUE4QlA7Ozs7Ozs7OztBQVFPLElBQU0vVCxjQUFiO0FBQ0ksMEJBQVliLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUNuQixTQUFLbkcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS21HLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtrcUIsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQUsvekIsT0FBTCxHQUFlLEVBQWY7QUFDQSxTQUFLZzBCLFVBQUwsR0FBa0IsRUFBbEI7QUFDSDs7QUFQTDtBQUFBO0FBQUEseUJBU1NoMEIsT0FUVCxFQVNrQjtBQUFBOztBQUNWLFdBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFdBQUtnMEIsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFdBQUtDLFFBQUwsR0FBZ0JuZ0MsQ0FBQyxDQUFDLDJCQUFELENBQUQsQ0FBK0J5VyxLQUEvQixFQUFoQjtBQUNBLFVBQUkycEIsTUFBTSxHQUFHLENBQWI7QUFDQWwwQixhQUFPLENBQ0ZrVSxNQURMLENBQ1ksVUFBQ2lnQixLQUFEO0FBQUEsZUFDSixDQUFDQSxLQUFLLENBQUNDLFNBQU4sQ0FBZ0J2MkIsVUFBaEIsQ0FBMkIsY0FBM0IsQ0FBRCxJQUNJczJCLEtBQUssQ0FBQ0UsVUFBTixLQUFxQixTQUR6QixJQUVJRixLQUFLLENBQUNFLFVBQU4sS0FBcUIsY0FGekIsS0FHSyxDQUFDLEtBQUksQ0FBQzN3QixJQUFMLENBQVUxWSxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJvRCxNQUEzQixFQUFELElBQXdDb25DLEtBQUssQ0FBQ0UsVUFBTixLQUFxQixrQkFIbEUsQ0FESTtBQUFBLE9BRFosRUFPS2xuQixPQVBMLENBT2EsVUFBQ2duQixLQUFELEVBQVEveUIsS0FBUixFQUFrQjtBQUN2QixZQUFJaXpCLFVBQVUsR0FBR0MsaUJBQWlCLENBQUNILEtBQUssQ0FBQ0UsVUFBUCxDQUFqQixJQUF1Q0YsS0FBSyxDQUFDRSxVQUE5RDtBQUNBLFlBQUlFLFNBQVMsR0FBR0MsbUJBQW1CLENBQUNMLEtBQUssQ0FBQ00sZ0JBQVAsQ0FBbkIsR0FBNkMsS0FBN0MsR0FBbURKLFVBQW5FO0FBQ0EsWUFBSUssT0FBTyxHQUFJUCxLQUFLLENBQUNFLFVBQU4sS0FBcUIsV0FBcEM7QUFDQSxZQUFJTSxNQUFNLEdBQUc3Z0MsQ0FBQyxDQUFDLG1CQUFELEVBQXNCO0FBQUM2UCxjQUFJLEVBQUU0d0IsU0FBUDtBQUFrQkssa0JBQVEsRUFBRUY7QUFBNUIsU0FBdEIsQ0FBZDs7QUFDQSxZQUFJLEtBQUksQ0FBQ0csV0FBTCxDQUFpQlYsS0FBakIsQ0FBSixFQUE2QjtBQUN6QlEsZ0JBQU0sQ0FBQ2pwQixJQUFQLENBQVksT0FBWixFQUFxQndvQixNQUFyQjs7QUFDQSxlQUFJLENBQUNGLFVBQUwsQ0FBZ0IzcUIsSUFBaEIsQ0FBcUI4cUIsS0FBckI7O0FBQ0FELGdCQUFNLElBQUksQ0FBVjtBQUNIOztBQUNELGFBQUksQ0FBQ0QsUUFBTCxDQUFjenNCLE1BQWQsQ0FBcUJtdEIsTUFBckI7QUFDSCxPQWxCTDtBQW1CQSxXQUFLVixRQUFMLENBQWMvd0IsR0FBZCxDQUFrQnRILElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWXE0QixNQUFNLEdBQUMsQ0FBbkIsQ0FBbEI7QUFDQSxXQUFLRCxRQUFMLENBQWM3QyxNQUFkLENBQXFCLFVBQUMwRCxHQUFELEVBQVM7QUFDMUIsYUFBSSxDQUFDbDFCLFlBQUw7QUFDSCxPQUZEO0FBR0g7QUFyQ0w7QUFBQTtBQUFBLGtDQXVDa0I7QUFDVixXQUFLcTBCLFFBQUwsQ0FBYy93QixHQUFkLENBQWtCLENBQWxCO0FBQ0EsV0FBS3RELFlBQUw7QUFDSDtBQTFDTDtBQUFBO0FBQUEsbUNBNENtQjtBQUNYLFVBQUltMEIsU0FBUyxHQUFHcFIsUUFBUSxDQUFDLEtBQUtzUixRQUFMLENBQWMvd0IsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsV0FBSyt3QixRQUFMLENBQWMvd0IsR0FBZCxDQUFrQnRILElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWWs0QixTQUFTLEdBQUMsQ0FBdEIsQ0FBbEI7QUFDQSxXQUFLbjBCLFlBQUw7QUFDSDtBQWhETDtBQUFBO0FBQUEsK0JBa0RlO0FBQ1AsVUFBSW0wQixTQUFTLEdBQUdwUixRQUFRLENBQUMsS0FBS3NSLFFBQUwsQ0FBYy93QixHQUFkLEVBQUQsRUFBc0IsRUFBdEIsQ0FBeEI7QUFDQSxXQUFLK3dCLFFBQUwsQ0FBYy93QixHQUFkLENBQWtCdEgsSUFBSSxDQUFDSSxHQUFMLENBQVMsS0FBS2c0QixVQUFMLENBQWdCeDNCLE1BQWhCLEdBQXVCLENBQWhDLEVBQW1DdTNCLFNBQVMsR0FBQyxDQUE3QyxDQUFsQjtBQUNBLFdBQUtuMEIsWUFBTDtBQUNIO0FBdERMO0FBQUE7QUFBQSx1Q0F3RHVCO0FBQ2YsV0FBS3EwQixRQUFMLENBQWMvd0IsR0FBZCxDQUFrQixLQUFLOHdCLFVBQUwsQ0FBZ0J4M0IsTUFBaEIsR0FBdUIsQ0FBekM7QUFDQSxXQUFLb0QsWUFBTDtBQUNIO0FBM0RMO0FBQUE7QUFBQSxtQ0E2RG1CO0FBQ1gsVUFBSSxLQUFLbzBCLFVBQUwsQ0FBZ0J4M0IsTUFBcEIsRUFBNEI7QUFDeEIsWUFBSXUzQixTQUFTLEdBQUdwUixRQUFRLENBQUMsS0FBS3NSLFFBQUwsQ0FBYy93QixHQUFkLEVBQUQsRUFBc0IsRUFBdEIsQ0FBeEI7QUFDQSxhQUFLUSxJQUFMLENBQVV6UCxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDc2tCLE9BQXJDLENBQTZDLEtBQUtvWixVQUFMLENBQWdCRCxTQUFoQixFQUEyQmpoQyxPQUF4RTtBQUNIO0FBQ0o7QUFsRUw7QUFBQTtBQUFBLDBCQW9FVTtBQUNGLFVBQUksS0FBS2toQyxVQUFMLENBQWdCeDNCLE1BQXBCLEVBQTRCO0FBQ3hCLFlBQUl1M0IsU0FBUyxHQUFHcFIsUUFBUSxDQUFDLEtBQUtzUixRQUFMLENBQWMvd0IsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsWUFBSS9WLElBQUksR0FBRyxLQUFLNm1DLFVBQUwsQ0FBZ0JELFNBQWhCLEVBQTJCamhDLE9BQXRDO0FBQ0EsYUFBSzRRLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQm9ILE9BQW5CLENBQTJCbUIsTUFBM0IsQ0FBa0NTLGtCQUFsQztBQUNBLGFBQUsrRCxJQUFMLENBQVV6UCxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NrRyxJQUFsQyxDQUF1Q2tCLE1BQXZDLENBQThDdFEsSUFBOUM7QUFDSDtBQUNKO0FBM0VMO0FBQUE7QUFBQSxnQ0E2RWdCZ25DLEtBN0VoQixFQTZFdUI7QUFDZixhQUFRLENBQUNBLEtBQUssQ0FBQ0UsVUFBTixLQUFxQixXQUFyQixJQUNBRixLQUFLLENBQUNFLFVBQU4sS0FBcUIsYUFEdEIsS0FFQSxLQUFLM3dCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkMsUUFBeEIsT0FBdUN1bUMsS0FBSyxDQUFDQyxTQUZyRDtBQUdIO0FBakZMOztBQUFBO0FBQUE7QUFxRkEsSUFBTUUsaUJBQWlCLEdBQUc7QUFDdEIsbUJBQWlCLGVBREs7QUFFdEIsaUJBQWUsb0JBRk87QUFHdEIsZUFBYSxhQUhTO0FBSXRCLGlCQUFlLG9CQUpPO0FBS3RCLGlCQUFlLGFBTE87QUFNdEIsbUJBQWlCLGNBTks7QUFPdEIsc0JBQW9CO0FBUEUsQ0FBMUI7QUFVQSxJQUFNUyxVQUFVLEdBQUcsQ0FDZixLQURlLEVBQ1IsS0FEUSxFQUNELEtBREMsRUFFZixLQUZlLEVBRVIsS0FGUSxFQUVELE1BRkMsRUFFTyxNQUZQLEVBR2YsS0FIZSxFQUdSLE1BSFEsRUFHQSxLQUhBLEVBSWYsS0FKZSxFQUlSLEtBSlEsQ0FBbkI7QUFNQSxJQUFNQyxRQUFRLEdBQUcsQ0FDYixLQURhLEVBQ04sS0FETSxFQUNDLEtBREQsRUFFYixLQUZhLEVBRU4sS0FGTSxFQUVDLEtBRkQsRUFHYixLQUhhLENBQWpCOztBQU1BLFNBQVNDLFNBQVQsQ0FBbUJ4NUIsS0FBbkIsRUFBMEJ5MUIsTUFBMUIsRUFBa0M7QUFDOUIsU0FBT3oxQixLQUFLLENBQUN5NUIsT0FBTixPQUFvQmhFLE1BQU0sQ0FBQ2dFLE9BQVAsRUFBcEIsSUFDSHo1QixLQUFLLENBQUMwNUIsUUFBTixPQUFxQmpFLE1BQU0sQ0FBQ2lFLFFBQVAsRUFEbEIsSUFFSDE1QixLQUFLLENBQUMyNUIsV0FBTixPQUF3QmxFLE1BQU0sQ0FBQ2tFLFdBQVAsRUFGNUI7QUFHSDtBQUVEOzs7Ozs7OztBQU1BLFNBQVNaLG1CQUFULENBQTZCYSxVQUE3QixFQUF5QztBQUNyQzs7Ozs7O0FBTUE7QUFDQSxNQUFJQSxVQUFVLEtBQUt2ckMsU0FBbkIsRUFBOEI7QUFDMUIsV0FBTyxnQkFBUDtBQUNIOztBQUNELE1BQUl3ckMsR0FBRyxHQUFHLElBQUlDLElBQUosRUFBVjtBQUNBLE1BQUlDLElBQUksR0FBRyxJQUFJRCxJQUFKLENBQVM1UyxRQUFRLENBQUMwUyxVQUFELEVBQWEsRUFBYixDQUFqQixDQUFYOztBQUNBLE1BQUlKLFNBQVMsQ0FBQ0ssR0FBRCxFQUFNRSxJQUFOLENBQWIsRUFBMEI7QUFDdEIsV0FBTyxjQUFZQSxJQUFJLENBQUNDLGtCQUFMLEVBQW5CO0FBQ0gsR0FGRCxNQUVPO0FBQ0gsUUFBSUMsTUFBTSxHQUFHVixRQUFRLENBQUNRLElBQUksQ0FBQ0csTUFBTCxFQUFELENBQXJCO0FBQ0EsUUFBSUMsUUFBUSxHQUFHYixVQUFVLENBQUNTLElBQUksQ0FBQ0wsUUFBTCxFQUFELENBQXpCO0FBQ0EsUUFBSVUsSUFBSSxHQUFHSCxNQUFNLEdBQUcsSUFBVCxHQUFnQkUsUUFBaEIsR0FBMkIsR0FBM0IsR0FBaUNKLElBQUksQ0FBQ04sT0FBTCxFQUE1Qzs7QUFDQSxRQUFJSSxHQUFHLENBQUNGLFdBQUosT0FBc0JJLElBQUksQ0FBQ0osV0FBTCxFQUExQixFQUE4QztBQUMxQyxhQUFPUyxJQUFJLEdBQUcsTUFBUCxHQUFjTCxJQUFJLENBQUNDLGtCQUFMLEVBQXJCO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBT0ksSUFBSSxHQUFHLElBQVAsR0FBWUwsSUFBSSxDQUFDSixXQUFMLEVBQVosR0FBaUMsTUFBakMsR0FBd0NJLElBQUksQ0FBQ0Msa0JBQUwsRUFBL0M7QUFDSDtBQUNKO0FBQ0o7QUFHRDs7Ozs7OztBQUtBbHhCLGNBQWMsQ0FBQ1YsU0FBZixDQUF5QjVFLFVBQXpCLEdBQXNDLFlBQVc7QUFDN0MsTUFBSXZILE1BQU0sR0FBRyxLQUFLZ00sSUFBTCxDQUFVelAsVUFBVixDQUFxQnlELE1BQWxDO0FBQ0EsTUFBSW9YLElBQUksR0FBRyxrQkFBWDtBQUNBLE9BQUtwTCxJQUFMLENBQVV6UCxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjRoQyxVQUE1QixDQUF1QyxVQUFVaGhDLElBQVYsRUFBZ0I7QUFDbkRnYSxRQUFJLEdBQUdoYSxJQUFJLENBQUNpaEMsT0FBTCxHQUFlQyxNQUFmLENBQXNCLFVBQVVDLFFBQVYsRUFBb0JDLElBQXBCLEVBQTBCO0FBQ25ELFVBQUlDLFlBQVksR0FBRzNCLG1CQUFtQixDQUFDMEIsSUFBSSxDQUFDRSxJQUFOLENBQXRDO0FBQ0EsVUFBSUMsUUFBUSxHQUFHLFFBQU1GLFlBQU4sR0FBbUIsZUFBbkIsR0FBbUNELElBQUksQ0FBQy9vQyxJQUF4QyxHQUE2QyxRQUE1RDtBQUNBLGFBQU84b0MsUUFBUSxHQUFDLElBQVQsR0FBY0ksUUFBckI7QUFDSCxLQUpNLEVBSUosRUFKSSxDQUFQO0FBS0EzK0IsVUFBTSxDQUFDOE0sSUFBUCxDQUFZLGNBQVosRUFBNEJzSyxJQUE1QixFQUFrQyxZQUFXLENBQUUsQ0FBL0M7QUFDSCxHQVBEO0FBUUgsQ0FYRCxDOzs7Ozs7Ozs7Ozs7O0FDaE1BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlPLElBQUl0Z0IsMkJBQTJCLEdBQUc7QUFDckNDLFVBQVEsRUFBRSxVQUQyQjtBQUVyQzRLLE9BQUssRUFBRSxPQUY4QjtBQUdyQ0ssTUFBSSxFQUFFO0FBSCtCLENBQWxDO0FBTVA7Ozs7OztBQUtPLFNBQVMySiwrQkFBVCxDQUF5QzNNLElBQXpDLEVBQStDMUwsS0FBL0MsRUFBc0Q7QUFDekQ7QUFDQSxNQUFJc3JDLGdCQUFnQixHQUFHLElBQXZCO0FBQ0F0ckMsT0FBSyxDQUFDMkwsRUFBTixDQUFTakwsWUFBVCxDQUFzQnNMLE9BQXRCLENBQThCME4sU0FBOUIsQ0FBd0MsWUFBTTtBQUMxQyxRQUFJNHhCLGdCQUFnQixLQUFLLElBQXpCLEVBQStCO0FBQzNCMVAsa0JBQVksQ0FBQzBQLGdCQUFELENBQVo7QUFDSDs7QUFDREEsb0JBQWdCLEdBQUd4N0IsVUFBVSxDQUFDLFlBQU07QUFDaEM5UCxXQUFLLENBQUN0QixhQUFOLENBQW9CNkosU0FBcEIsQ0FBOEJrSCxJQUE5QixDQUFtQyxnQ0FBbkMsRUFBcUUwRCxHQUFyRSxDQUEwRSxVQUFDOE4sQ0FBRCxFQUFJNmYsS0FBSixFQUFjO0FBQ3BGNVosY0FBTSxDQUFDNlosSUFBUCxDQUFZQyxjQUFaLENBQTJCRixLQUEzQjtBQUNILE9BRkQ7QUFHSCxLQUo0QixFQUkxQixHQUowQixDQUE3QjtBQUtILEdBVEQsRUFIeUQsQ0FhekQ7O0FBQ0E5Z0MsT0FBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QjBWLFNBQXpCLENBQW1DLFVBQUM2eEIsWUFBRCxFQUFrQjtBQUNqRDcvQixRQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQ2ltQyxZQUFZLENBQUNqbkMsUUFBYixFQURoQyxFQUN5RCxFQUR6RDs7QUFFQSxRQUFJaW5DLFlBQUosRUFBa0I7QUFDZDtBQUNBdnJDLFdBQUssQ0FBQ3RCLGFBQU4sQ0FBb0I2SixTQUFwQixDQUE4QmdQLE1BQTlCLEdBQXVDLENBQXZDLEVBQTBDaTBCLGlCQUExQyxZQUFvRSxVQUFBMUgsR0FBRyxFQUFJO0FBQ3ZFLFlBQUloOEIsT0FBTywwREFBbURnOEIsR0FBRyxDQUFDaDhCLE9BQXZELGVBQW1FZzhCLEdBQUcsQ0FBQ3pqQyxJQUF2RSxNQUFYO0FBQ0FxTCxZQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLDRCQUFoQyxFQUE4RCxFQUE5RCxFQUFrRSxFQUFsRSxFQUNnQ3dDLE9BRGhDLEVBQzBDLEVBRDFDO0FBRUF3RixhQUFLLENBQUN4RixPQUFELENBQUw7QUFDSCxPQUxELEVBS0cwdEIsSUFMSCxDQUtRLFlBQU07QUFDVjlwQixZQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQyxFQURoQyxFQUNvQyxFQURwQztBQUVBdEYsYUFBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixJQUF6QjtBQUNBaEUsYUFBSyxDQUFDdEIsYUFBTixDQUFvQjZKLFNBQXBCLENBQThCazVCLEdBQTlCLENBQWtDLFlBQWxDLEVBQWdELE1BQWhEO0FBQ0gsT0FWRDtBQVdILEtBYkQsTUFhTztBQUNIbmxCLGNBQVEsQ0FBQ212QixjQUFULEdBQTBCalcsSUFBMUIsQ0FBK0IsWUFBTTtBQUNqQzlwQixZQUFJLENBQUN6QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjVELFFBQXZCLENBQWdDLDJCQUFoQyxFQUE2RCxFQUE3RCxFQUFpRSxFQUFqRSxFQUNnQ2ltQyxZQUFZLENBQUNqbkMsUUFBYixFQURoQyxFQUN5RCxFQUR6RDtBQUVBdEUsYUFBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixLQUF6QjtBQUNILE9BSkQ7QUFLSDtBQUNKLEdBdkJEO0FBd0JILEMsQ0FFRDs7QUFFTyxTQUFTNkUsYUFBVCxDQUF1QjZQLElBQXZCLEVBQTZCO0FBQ2hDLCtGQUlFOEwscURBSkYsZ3JKQTBHRWdnQixtREExR0YscVJBb0hNbHFCLHVEQXBITiwwR0F1SE11bEIseURBdkhOLDBIQTJITTZMLG1EQTNITiwyTEFtSUVsSCxtREFuSUYseUVBdUlFOVEsdURBdklGLHlKQStJTW9WLHFEQS9JTjtBQXFKSCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25PRDtBQUNBO0FBRUE7Ozs7O0FBSU8sSUFBSWprQyxXQUFXLEdBQUc7QUFDckJDLE9BQUssRUFBRSxPQURjO0FBRXJCa0ssUUFBTSxFQUFFLFFBRmE7QUFHckIyOEIsVUFBUSxFQUFFLFVBSFc7QUFJckJ2YSxRQUFNLEVBQUUsUUFKYTtBQUtyQndhLFNBQU8sRUFBRTtBQUxZLENBQWxCO0FBUVA7Ozs7Ozs7OztBQVFPLFNBQVN2eUIsYUFBVCxDQUF1QlgsSUFBdkIsRUFBNkI7QUFDaEMsT0FBS0EsSUFBTCxHQUFZQSxJQUFaLENBRGdDLENBR2hDOztBQUNBLE9BQUtsUSxJQUFMLEdBQVlrUSxJQUFJLENBQUMxWSxLQUFMLENBQVd0QixhQUFYLENBQXlCOEosSUFBckMsQ0FKZ0MsQ0FNaEM7O0FBQ0EsT0FBS3FqQyxPQUFMLEdBQWUsSUFBSTlyQyw0REFBSixDQUF3QixTQUF4QixDQUFmLENBUGdDLENBU2hDOztBQUNBLE9BQUsrckMsS0FBTCxHQUFhO0FBQ1QsZ0JBQVlqNkIsSUFBSSxDQUFDZ0csS0FBTCxDQUFXLEtBQUtnMEIsT0FBTCxDQUFhRSxVQUFiLENBQXdCLFVBQXhCLEVBQW9DLElBQXBDLENBQVgsQ0FESDtBQUVULHdCQUFvQmw2QixJQUFJLENBQUNnRyxLQUFMLENBQVcsS0FBS2cwQixPQUFMLENBQWFFLFVBQWIsQ0FBd0Isa0JBQXhCLEVBQTRDLElBQTVDLENBQVg7QUFGWCxHQUFiO0FBSUEsT0FBS0MsY0FBTCxHQUFzQjtBQUNsQixnQkFBWSxHQURNO0FBRWxCLHdCQUFvQjtBQUZGLEdBQXRCO0FBS0EsT0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLE9BQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFFQSxPQUFLQyxNQUFMLEdBQWMsRUFBZDtBQUVBLE9BQUtDLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS0MsZ0JBQUwsR0FBd0IsQ0FBeEI7QUFFQSxPQUFLQyxlQUFMLEdBQXVCLEVBQXZCO0FBQ0EsT0FBS0MsbUJBQUw7QUFDQSxPQUFLQyxXQUFMO0FBRUEsT0FBS3Z5QixXQUFMLEdBQW1CLElBQW5CO0FBQ0g7QUFFRDs7Ozs7QUFJQVosYUFBYSxDQUFDUixTQUFkLENBQXdCNHpCLE9BQXhCLEdBQWtDLFVBQVUxM0IsUUFBVixFQUFvQjtBQUNsRCxNQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLFFBQUksS0FBS3M3QixPQUFMLENBQWFoc0MsR0FBYixDQUFpQixJQUFqQixDQUFKLEVBQTRCO0FBQ3hCLFVBQUk2c0MsS0FBSyxHQUFHLEtBQUtiLE9BQUwsQ0FBYS9yQyxHQUFiLENBQWlCLElBQWpCLENBQVo7O0FBQ0EsVUFBSTRzQyxLQUFLLEtBQUszM0IsUUFBUSxDQUFDNDNCLEVBQXZCLEVBQTJCO0FBQ3ZCLFlBQUk3a0MsT0FBTyxHQUFHK0osSUFBSSxDQUFDQyxTQUFMLENBQWU7QUFDekIsaUJBQU80NkIsS0FEa0I7QUFFekIsaUJBQU8zM0IsUUFBUSxDQUFDNDNCO0FBRlMsU0FBZixDQUFkOztBQUlBLFlBQUksS0FBSzF5QixXQUFULEVBQXNCO0FBQ2xCLGVBQUtBLFdBQUwsQ0FBaUIsYUFBakIsRUFBZ0NuYixTQUFoQyxFQUEyQ0EsU0FBM0MsRUFBc0RnSixPQUF0RDtBQUNILFNBRkQsTUFFTztBQUNILGVBQUt4QyxRQUFMLENBQWMsYUFBZCxFQUE2QnhHLFNBQTdCLEVBQXdDQSxTQUF4QyxFQUFtRGdKLE9BQW5EO0FBQ0g7O0FBQ0QsYUFBSytqQyxPQUFMLENBQWF2OEIsR0FBYixDQUFpQixJQUFqQixFQUF1QnlGLFFBQVEsQ0FBQzQzQixFQUFoQztBQUNIO0FBQ0osS0FkRCxNQWNPO0FBQ0gsV0FBS2QsT0FBTCxDQUFhdjhCLEdBQWIsQ0FBaUIsSUFBakIsRUFBdUJ5RixRQUFRLENBQUM0M0IsRUFBaEM7QUFDSDtBQUNKO0FBQ0osQ0FwQkQ7QUFzQkE7Ozs7OztBQUlBdHpCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QjJ6QixXQUF4QixHQUFzQyxZQUFZO0FBQUE7O0FBQzlDLE1BQUksS0FBS1gsT0FBTCxDQUFhaHNDLEdBQWIsQ0FBaUIsZ0JBQWpCLENBQUosRUFBd0M7QUFDcEMsUUFBSWlLLElBQUksR0FBRytILElBQUksQ0FBQ2dHLEtBQUwsQ0FBVyxLQUFLZzBCLE9BQUwsQ0FBYS9yQyxHQUFiLENBQWlCLGdCQUFqQixDQUFYLENBQVg7O0FBQ0EsU0FBSzhzQyxnQkFBTCxDQUFzQjlpQyxJQUF0QixFQUE0QixZQUE1QixFQUNzQixnQkFEdEIsRUFDd0MsS0FBS21pQyxXQUQ3QztBQUVIOztBQUNELE9BQUtLLGVBQUwsQ0FBcUJucUIsT0FBckIsQ0FBNkIsVUFBQ3ZmLFFBQUQsRUFBYztBQUN2QyxRQUFJLEtBQUksQ0FBQ2lwQyxPQUFMLENBQWFoc0MsR0FBYixDQUFpQixhQUFhK0MsUUFBOUIsQ0FBSixFQUE2QztBQUN6QyxVQUFJa0gsS0FBSSxHQUFHK0gsSUFBSSxDQUFDZ0csS0FBTCxDQUFXLEtBQUksQ0FBQ2cwQixPQUFMLENBQWEvckMsR0FBYixDQUFpQixhQUFhOEMsUUFBOUIsQ0FBWCxDQUFYOztBQUNBLFdBQUksQ0FBQ2dxQyxnQkFBTCxDQUFzQjlpQyxLQUF0QixFQUE0QmxILFFBQTVCLEVBQXNDLFVBQXRDLEVBQWtELEtBQUksQ0FBQ3FwQyxXQUF2RDtBQUNIO0FBQ0osR0FMRDtBQU1BLE1BQUkvaUMsTUFBTSxHQUFHLElBQWI7QUFDQTZhLFFBQU0sQ0FBQ0MsSUFBUCxDQUFZLEtBQUs4bkIsS0FBakIsRUFBd0IzcEIsT0FBeEIsQ0FBZ0MsVUFBVTdmLFFBQVYsRUFBb0I7QUFDaEQsS0FBQyxTQUFTdXFDLGFBQVQsQ0FBdUI5M0IsUUFBdkIsRUFBaUM7QUFDOUIsVUFBSUEsUUFBUSxDQUFDeEUsT0FBYixFQUFzQjtBQUNsQixZQUFJckgsTUFBTSxDQUFDNGlDLEtBQVAsQ0FBYXhwQyxRQUFiLEVBQXVCa1AsTUFBM0IsRUFBbUM7QUFDL0IsY0FBSTFILElBQUksR0FBRytILElBQUksQ0FBQ2dHLEtBQUwsQ0FBVzNPLE1BQU0sQ0FBQzRpQyxLQUFQLENBQWF4cEMsUUFBYixFQUF1QnkzQixHQUF2QixFQUFYLENBQVg7QUFDQSxjQUFJcDVCLEdBQUcsR0FBR3VJLE1BQU0sQ0FBQ1YsSUFBUCxDQUFZbEcsUUFBWixDQUFWOztBQUNBNEcsZ0JBQU0sQ0FBQzRqQyxVQUFQLENBQWtCaGpDLElBQWxCLEVBQXdCeEgsUUFBeEIsRUFBa0MsSUFBbEMsRUFBd0N1cUMsYUFBeEM7QUFDSDtBQUNKO0FBQ0osS0FSRCxFQVFHO0FBQUMsaUJBQVc7QUFBWixLQVJIO0FBU0gsR0FWRDtBQVdILENBeEJEOztBQTBCQXh6QixhQUFhLENBQUNSLFNBQWQsQ0FBd0JrMEIsc0JBQXhCLEdBQWlELFVBQVUvc0MsS0FBVixFQUFpQjRDLFFBQWpCLEVBQTJCO0FBQUE7O0FBQ3hFNUMsT0FBSyxDQUFDMFosU0FBTixDQUFnQixVQUFDcEcsUUFBRDtBQUFBLFdBQ1osTUFBSSxDQUFDb0YsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCUSxRQUF4QixLQUFxQyxNQUFJLENBQUN1QyxRQUFMLENBQWM5QyxRQUFkLEVBQXdCMFEsUUFBeEIsQ0FBckMsR0FBeUUsS0FEN0Q7QUFBQSxHQUFoQixFQUNvRixJQURwRjtBQUVBLE9BQUtnNUIsZUFBTCxDQUFxQmp1QixJQUFyQixDQUEwQnpiLFFBQTFCO0FBQ0gsQ0FKRDtBQU1BOzs7OztBQUdBeVcsYUFBYSxDQUFDUixTQUFkLENBQXdCMHpCLG1CQUF4QixHQUE4QyxZQUFZO0FBQ3RELE1BQUl2c0MsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0QjtBQUNBLE9BQUsrc0Msc0JBQUwsQ0FBNEIvc0MsS0FBSyxDQUFDcEIsVUFBTixDQUFpQnVELElBQTdDLEVBQW1ELFdBQW5EO0FBQ0EsT0FBSzRxQyxzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0MsS0FBN0MsRUFBb0QsWUFBcEQ7QUFDQSxPQUFLOHJDLHNCQUFMLENBQTRCL3NDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ3QyxNQUE3QyxFQUFxRCxhQUFyRDtBQUNBLE9BQUs0ckMsc0JBQUwsQ0FBNEIvc0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnVDLFFBQTdDLEVBQXVELGVBQXZEO0FBQ0EsT0FBSzZyQyxzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCK0IsWUFBN0MsRUFBMkQsa0JBQTNEO0FBQ0EsT0FBS3FzQyxzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUNyQixVQUFOLENBQWlCcUMsWUFBN0MsRUFBMkQsbUJBQTNEO0FBQ0EsT0FBSytyQyxzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUMyTCxFQUFOLENBQVN1RixLQUFULENBQWV3QixpQkFBM0MsRUFBOEQsOEJBQTlEO0FBQ0EsT0FBS3E2QixzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUMyTCxFQUFOLENBQVN1RixLQUFULENBQWUzUCxrQkFBM0MsRUFBK0QsK0JBQS9EO0FBQ0EsT0FBS3dyQyxzQkFBTCxDQUE0Qi9zQyxLQUFLLENBQUMyTCxFQUFOLENBQVN1RixLQUFULENBQWU5UCxvQkFBM0MsRUFBaUUsaUNBQWpFO0FBQ0gsQ0FYRDs7QUFhQWlZLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3Qm0wQixlQUF4QixHQUEwQyxZQUFXO0FBQUE7O0FBQ2pEOWxCLFFBQU0sQ0FBQytsQixNQUFQLEdBQWdCLFlBQU07QUFDbEIsVUFBSSxDQUFDM25DLFFBQUwsQ0FBYyxhQUFkLEVBQTZCeEcsU0FBN0IsRUFBd0NBLFNBQXhDLEVBQW1EQSxTQUFuRDtBQUNILEdBRkQ7O0FBR0Fvb0IsUUFBTSxDQUFDZ21CLE9BQVAsR0FBaUIsWUFBTTtBQUNuQixVQUFJLENBQUM1bkMsUUFBTCxDQUFjLGVBQWQsRUFBK0J4RyxTQUEvQixFQUEwQ0EsU0FBMUMsRUFBcURBLFNBQXJEO0FBQ0gsR0FGRCxDQUppRCxDQVFqRDs7QUFDSCxDQVREO0FBV0E7Ozs7Ozs7Ozs7O0FBU0F1YSxhQUFhLENBQUNSLFNBQWQsQ0FBd0JtSyxxQkFBeEIsR0FBZ0QsWUFBWSxDQUN4RDtBQUNILENBRkQ7O0FBSUEzSixhQUFhLENBQUNSLFNBQWQsQ0FBd0JzMEIsZUFBeEIsR0FBMEMsVUFBU0MsZUFBVCxFQUEwQjtBQUNoRSxNQUFJLENBQUNBLGVBQUwsRUFBc0I7QUFDbEJBLG1CQUFlLEdBQUcsRUFBbEI7QUFDSDs7QUFDRCxNQUFNMWtDLFdBQVcsR0FBRyxLQUFLZ1EsSUFBTCxDQUFVMVksS0FBVixDQUFnQnRCLGFBQWhCLENBQThCZ0ssV0FBOUIsRUFBcEI7O0FBQ0EsTUFBSUEsV0FBSixFQUFpQjtBQUNiLFFBQUksQ0FBQzBrQyxlQUFlLENBQUNDLE9BQXJCLEVBQThCO0FBQzFCRCxxQkFBZSxDQUFDQyxPQUFoQixHQUEwQixFQUExQjtBQUNIOztBQUNERCxtQkFBZSxDQUFDQyxPQUFoQixDQUF3QixlQUF4QixJQUEyQyxZQUFZM2tDLFdBQXZEO0FBQ0g7O0FBQ0QsU0FBTzBrQyxlQUFQO0FBQ0gsQ0FaRDtBQWNBOzs7Ozs7QUFJQS96QixhQUFhLENBQUNSLFNBQWQsQ0FBd0J5MEIsZ0JBQXhCLEdBQTJDLFlBQVk7QUFDbkQsTUFBSTN1QyxVQUFVLEdBQUcsS0FBSytaLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JyQixVQUFqQztBQUNBLE1BQUlzQixJQUFJLEdBQUcsS0FBS3lZLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JDLElBQTNCO0FBQ0EsTUFBSXJCLFVBQVUsR0FBRyxLQUFLOFosSUFBTCxDQUFVMVksS0FBVixDQUFnQnBCLFVBQWpDO0FBQ0EsTUFBSStELE9BQU8sR0FBRyxLQUFLK1YsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQTlCO0FBQ0EsTUFBTWpFLGFBQWEsR0FBRyxLQUFLZ2EsSUFBTCxDQUFVMVksS0FBVixDQUFnQnRCLGFBQXRDO0FBQ0EsTUFBSTRyQyxHQUFHLEdBQUcsSUFBSUMsSUFBSixFQUFWO0FBQ0EsTUFBSWdELFlBQVksR0FBR2pELEdBQUcsQ0FBQ2tELE9BQUosRUFBbkI7QUFDQSxNQUFJMTFCLE1BQU0sR0FBRztBQUNULHFCQUFpQm5aLFVBQVUsQ0FBQ3VCLEVBQVgsRUFEUjtBQUVULDJCQUF1QkQsSUFBSSxDQUFDUSxPQUFMLEVBRmQ7QUFHVCxpQkFBYVIsSUFBSSxDQUFDTyxRQUFMLEVBSEo7QUFJVCxxQkFBaUI1QixVQUFVLENBQUNzQixFQUFYLEVBSlI7QUFLVCxlQUFXRCxJQUFJLENBQUNDLEVBQUwsRUFMRjtBQU1ULGVBQVd2QixVQUFVLENBQUNnRCxPQUFYLEVBTkY7QUFPVCxpQkFBYTRyQyxZQVBKO0FBUVQsZ0JBQVlqRCxHQUFHLENBQUNtRCxpQkFBSixFQVJIO0FBU1QsZ0JBQVk5cUMsT0FBTyxDQUFDc0IsUUFBUixFQVRIO0FBVVQsZUFBV3ZGLGFBQWEsQ0FBQytKLE1BQWQ7QUFWRixHQUFiO0FBWUEsU0FBT3FQLE1BQVA7QUFDSCxDQXJCRDtBQXVCQTs7Ozs7Ozs7QUFNQXVCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QnBOLFNBQXhCLEdBQW9DLFVBQVVuSixRQUFWLEVBQW9CcUMsTUFBcEIsRUFBNEJtRCxPQUE1QixFQUFxQztBQUNyRSxNQUFJeEYsUUFBUSxJQUFJLEtBQUtvVyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkUsTUFBaEMsRUFBd0M7QUFDcEMsU0FBSytULElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyRSxNQUFoQixDQUF1QnJDLFFBQXZCLEVBQWlDcUMsTUFBakM7QUFDQSxTQUFLK1QsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJFLE1BQWhCLENBQXVCckMsUUFBUSxHQUFHLFNBQWxDLEVBQTZDd0YsT0FBTyxJQUFJLEVBQXhEO0FBQ0g7QUFDSixDQUxEO0FBT0E7Ozs7OztBQUlBdVIsYUFBYSxDQUFDUixTQUFkLENBQXdCNjBCLFdBQXhCLEdBQXNDLFVBQVVDLE9BQVYsRUFBbUI7QUFDckQsT0FBS3RCLGdCQUFMLElBQXlCLENBQXpCOztBQUNBLE1BQUksQ0FBQy92QixRQUFRLENBQUNzeEIsc0JBQVQsQ0FBZ0MsaUJBQWhDLEVBQW1EcDhCLE1BQXhELEVBQWdFO0FBQzVELFNBQUs0NkIsT0FBTCxHQUFldGpDLENBQUMsQ0FBQyxzQ0FBRCxDQUFoQjtBQUNBLFNBQUtzakMsT0FBTCxDQUFhN25CLFFBQWIsQ0FBc0JqSSxRQUFRLENBQUN3SCxJQUEvQjtBQUNIOztBQUNELFVBQVE2cEIsT0FBUjtBQUNJLFNBQUssQ0FBTDtBQUNJLFdBQUt2QixPQUFMLENBQWEzSyxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUsySyxPQUFMLENBQWEzSyxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUsySyxPQUFMLENBQWEzSyxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKO0FBQ0ksV0FBSzJLLE9BQUwsQ0FBYTNLLEdBQWIsQ0FBaUIsa0JBQWpCLEVBQXFDLE9BQXJDO0FBQ0E7QUFaUjtBQWNILENBcEJEO0FBc0JBOzs7OztBQUdBcG9CLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QmcxQixXQUF4QixHQUFzQyxZQUFZO0FBQzlDLE9BQUt4QixnQkFBTCxJQUF5QixDQUF6Qjs7QUFDQSxNQUFJLEtBQUtBLGdCQUFMLElBQXlCLENBQTdCLEVBQWdDO0FBQzVCLFNBQUtELE9BQUwsQ0FBYTF3QixNQUFiO0FBQ0g7QUFDSixDQUxEOztBQU9BckMsYUFBYSxDQUFDUixTQUFkLENBQXdCaTFCLFlBQXhCLEdBQXVDLFVBQVVDLEtBQVYsRUFBaUJqa0MsSUFBakIsRUFBdUI7QUFDMUQ7QUFDQSxNQUFJMEgsTUFBTSxHQUFHLEtBQUtzNkIsS0FBTCxDQUFXaUMsS0FBWCxFQUFrQnY4QixNQUEvQjtBQUNBLE1BQUlYLEdBQUcsR0FBRyxLQUFLbTdCLGNBQUwsQ0FBb0IrQixLQUFwQixDQUFWOztBQUNBLE1BQUl2OEIsTUFBTSxHQUFHWCxHQUFiLEVBQWtCO0FBQ2QsU0FBS2k3QixLQUFMLENBQVdpQyxLQUFYLElBQW9CLEtBQUtqQyxLQUFMLENBQVdpQyxLQUFYLEVBQWtCajdCLEtBQWxCLENBQXdCdEIsTUFBTSxHQUFHWCxHQUFqQyxFQUFzQ0EsR0FBdEMsQ0FBcEI7QUFDSCxHQU55RCxDQU8xRDs7O0FBQ0EsTUFBSXBSLEdBQUcsR0FBR29TLElBQUksQ0FBQ0MsU0FBTCxDQUFlaEksSUFBZixDQUFWO0FBQ0EsTUFBSXNNLEtBQUssR0FBRyxLQUFLMDFCLEtBQUwsQ0FBV2lDLEtBQVgsRUFBa0JyNkIsT0FBbEIsQ0FBMEJqVSxHQUExQixDQUFaOztBQUNBLE1BQUkyVyxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2QsU0FBSzAxQixLQUFMLENBQVdpQyxLQUFYLEVBQWtCMXZCLElBQWxCLENBQXVCNWUsR0FBdkI7QUFDQSxTQUFLb3NDLE9BQUwsQ0FBYXY4QixHQUFiLENBQWlCeStCLEtBQWpCLEVBQXdCbDhCLElBQUksQ0FBQ0MsU0FBTCxDQUFlLEtBQUtnNkIsS0FBTCxDQUFXaUMsS0FBWCxDQUFmLENBQXhCO0FBQ0g7QUFDSixDQWREOztBQWdCQTEwQixhQUFhLENBQUNSLFNBQWQsQ0FBd0JtMUIsWUFBeEIsR0FBdUMsVUFBVUQsS0FBVixFQUFpQmprQyxJQUFqQixFQUF1QjtBQUMxRCxNQUFJckssR0FBRyxHQUFHb1MsSUFBSSxDQUFDQyxTQUFMLENBQWVoSSxJQUFmLENBQVY7QUFDQSxNQUFJc00sS0FBSyxHQUFHLEtBQUswMUIsS0FBTCxDQUFXaUMsS0FBWCxFQUFrQnI2QixPQUFsQixDQUEwQmpVLEdBQTFCLENBQVo7O0FBQ0EsTUFBSTJXLEtBQUssSUFBSSxDQUFiLEVBQWdCO0FBQ1osU0FBSzAxQixLQUFMLENBQVdpQyxLQUFYLEVBQWtCRSxNQUFsQixDQUF5QjczQixLQUF6QjtBQUNBLFNBQUt5MUIsT0FBTCxDQUFhdjhCLEdBQWIsQ0FBaUJ5K0IsS0FBakIsRUFBd0JsOEIsSUFBSSxDQUFDQyxTQUFMLENBQWUsS0FBS2c2QixLQUFMLENBQVdpQyxLQUFYLENBQWYsQ0FBeEI7QUFDSDtBQUNKLENBUEQ7O0FBVUExMEIsYUFBYSxDQUFDUixTQUFkLENBQXdCaTBCLFVBQXhCLEdBQXFDLFVBQVVoakMsSUFBVixFQUFnQnhILFFBQWhCLEVBQTBCbzFCLEtBQTFCLEVBQWlDdkksUUFBakMsRUFBMkM7QUFBQTs7QUFDNUU7QUFDQSxNQUFJK2UsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBTTtBQUNwQjtBQUNBLFVBQUksQ0FBQ0osWUFBTCxDQUFrQnhyQyxRQUFsQixFQUE0QndILElBQTVCOztBQUNBaEIsS0FBQyxDQUFDcWxDLElBQUY7QUFBUXh0QyxTQUFHLEVBQUUsTUFBSSxDQUFDNkgsSUFBTCxDQUFVbEcsUUFBVixDQUFiO0FBQWtDMUIsVUFBSSxFQUFFLE1BQXhDO0FBQWdEa0osVUFBSSxFQUFFQTtBQUF0RCxPQUErRCxNQUFJLENBQUNxakMsZUFBTCxFQUEvRCxHQUNLMXFCLElBREwsQ0FDVSxVQUFDMU4sUUFBRCxFQUFjO0FBQ2hCLFlBQUksQ0FBQ2k1QixZQUFMLENBQWtCMXJDLFFBQWxCLEVBQTRCd0gsSUFBNUI7O0FBQ0EsVUFBSWlMLFFBQVEsQ0FBQ3hFLE9BQWIsRUFBc0I7QUFDbEIsY0FBSSxDQUFDOUUsU0FBTCxDQUFlbkosUUFBZixFQUF5QnVDLFdBQVcsQ0FBQ0MsS0FBckM7QUFDSCxPQUZELE1BRU87QUFDSGlGLGVBQU8sQ0FBQytZLEtBQVIsQ0FBYy9OLFFBQWQ7O0FBQ0EsY0FBSSxDQUFDdEosU0FBTCxDQUFlbkosUUFBZixFQUF5QnVDLFdBQVcsQ0FBQ3VzQixNQUFyQyxFQUE2Q3JjLFFBQVEsQ0FBQ2pOLE9BQXREO0FBQ0g7O0FBQ0QsVUFBSXFuQixRQUFKLEVBQWM7QUFDVkEsZ0JBQVEsQ0FBQ3BhLFFBQUQsQ0FBUjtBQUNIOztBQUNELFVBQUlBLFFBQVEsQ0FBQ3hFLE9BQWIsRUFBc0I7QUFDbEIsY0FBSSxDQUFDazhCLE9BQUwsQ0FBYTEzQixRQUFRLENBQUM0M0IsRUFBdEI7QUFDSDtBQUNKLEtBZkwsRUFnQkk7QUFoQkosS0FpQksvcEIsSUFqQkwsQ0FpQlUsVUFBQ0UsS0FBRCxFQUFRc3JCLFVBQVIsRUFBdUI7QUFDekIsWUFBSSxDQUFDM2lDLFNBQUwsQ0FBZW5KLFFBQWYsRUFBeUJ1QyxXQUFXLENBQUM4bUMsUUFBckMsRUFBK0N5QyxVQUFVLENBQUM5cEMsUUFBWCxFQUEvQzs7QUFDQSxZQUFJLENBQUN3b0MsVUFBTCxDQUFnQmhqQyxJQUFoQixFQUFzQnhILFFBQXRCLEVBQWdDbzFCLEtBQUssR0FBRyxNQUFJLENBQUN3VSxVQUE3QyxFQUF5RC9jLFFBQXpEO0FBQ0gsS0FwQkw7QUFxQkgsR0F4QkQ7O0FBeUJBLE1BQUl1SSxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNoQndXLGVBQVc7QUFDZCxHQUZELE1BRU87QUFDSHArQixjQUFVLENBQUNvK0IsV0FBRCxFQUFjeFcsS0FBZCxDQUFWO0FBQ0g7QUFDSixDQWhDRDtBQWtDQTs7Ozs7Ozs7Ozs7OztBQVdBcmUsYUFBYSxDQUFDUixTQUFkLENBQXdCK3pCLGdCQUF4QixHQUEyQyxVQUFVOWlDLElBQVYsRUFBZ0JsSCxRQUFoQixFQUEwQk4sUUFBMUIsRUFBb0NvMUIsS0FBcEMsRUFBMkMyVyxlQUEzQyxFQUE0REMsWUFBNUQsRUFBMEU7QUFBQTs7QUFDakgsTUFBSVAsS0FBSyxHQUFHenJDLFFBQVEsR0FBR00sUUFBdkI7O0FBQ0EsTUFBSTJyQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFNO0FBQ2hCO0FBQ0EsVUFBSSxDQUFDMUMsT0FBTCxDQUFhdjhCLEdBQWIsQ0FBaUJ5K0IsS0FBakIsRUFBd0JsOEIsSUFBSSxDQUFDQyxTQUFMLENBQWVoSSxJQUFmLENBQXhCOztBQUNBLFFBQUlzaEMsSUFBSSxHQUFHLE1BQUksQ0FBQ1MsT0FBTCxDQUFhMkIsT0FBYixDQUFxQk8sS0FBckIsQ0FBWCxDQUhnQixDQUloQjs7O0FBQ0FqbEMsS0FBQyxDQUFDcWxDLElBQUY7QUFBUXh0QyxTQUFHLEVBQUUsTUFBSSxDQUFDNkgsSUFBTCxDQUFVbEcsUUFBVixDQUFiO0FBQWtDd0gsVUFBSSxFQUFFQSxJQUF4QztBQUE4Q2xKLFVBQUksRUFBRTtBQUFwRCxPQUErRCxNQUFJLENBQUN1c0MsZUFBTCxFQUEvRCxHQUNLMXFCLElBREwsQ0FDVSxVQUFDMU4sUUFBRCxFQUFjO0FBQ2hCLFVBQUlBLFFBQVEsQ0FBQ3hFLE9BQWIsRUFBc0I7QUFDbEIsY0FBSSxDQUFDazhCLE9BQUwsQ0FBYTEzQixRQUFiLEVBRGtCLENBRWxCOzs7QUFDQSxZQUFJeTVCLFVBQVUsR0FBRyxNQUFJLENBQUMzQyxPQUFMLENBQWEyQixPQUFiLENBQXFCTyxLQUFyQixDQUFqQjs7QUFDQSxZQUFJM0MsSUFBSSxJQUFJb0QsVUFBWixFQUF3QjtBQUNwQixnQkFBSSxDQUFDM0MsT0FBTCxDQUFhbndCLE1BQWIsQ0FBb0JxeUIsS0FBcEI7QUFDSDs7QUFDRCxjQUFJLENBQUN0aUMsU0FBTCxDQUFlbkosUUFBZixFQUF5QnVDLFdBQVcsQ0FBQ0MsS0FBckM7QUFDSCxPQVJELE1BUU87QUFDSDtBQUNBLGNBQUksQ0FBQzJHLFNBQUwsQ0FBZW5KLFFBQWYsRUFBeUJ1QyxXQUFXLENBQUN1c0IsTUFBckMsRUFBNkNyYyxRQUFRLENBQUNqTixPQUF0RDs7QUFDQSxZQUFJaU4sUUFBUSxDQUFDeEUsT0FBVCxLQUFxQixLQUF6QixFQUFnQztBQUM1QjtBQUNBLGNBQUlpK0IsV0FBVSxHQUFHLE1BQUksQ0FBQzNDLE9BQUwsQ0FBYTJCLE9BQWIsQ0FBcUJPLEtBQXJCLENBQWpCOztBQUNBLGNBQUkzQyxJQUFJLElBQUlvRCxXQUFaLEVBQXdCO0FBQ3BCLGtCQUFJLENBQUMzQyxPQUFMLENBQWFud0IsTUFBYixDQUFvQnF5QixLQUFwQjtBQUNIOztBQUNELGNBQUlNLGVBQUosRUFBcUI7QUFDakJBLDJCQUFlLENBQUN0NUIsUUFBRCxDQUFmO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0F4QkwsRUF5Qks2TixJQXpCTCxDQXlCVSxVQUFDRSxLQUFELEVBQVFzckIsVUFBUixFQUF1QjtBQUN6QixZQUFJLENBQUMzaUMsU0FBTCxDQUFlbkosUUFBZixFQUF5QnVDLFdBQVcsQ0FBQzhtQyxRQUFyQyxFQUErQ3lDLFVBQVUsQ0FBQzlwQyxRQUFYLEVBQS9DLEVBRHlCLENBRXpCOzs7QUFDQSxVQUFJa3FDLFVBQVUsR0FBRyxNQUFJLENBQUMzQyxPQUFMLENBQWEyQixPQUFiLENBQXFCTyxLQUFyQixDQUFqQjs7QUFDQSxVQUFJM0MsSUFBSSxJQUFJb0QsVUFBWixFQUF3QjtBQUNwQixjQUFJLENBQUM1QixnQkFBTCxDQUFzQjlpQyxJQUF0QixFQUE0QmxILFFBQTVCLEVBQXNDTixRQUF0QyxFQUFnRG8xQixLQUFLLEdBQUcsTUFBSSxDQUFDd1UsVUFBN0Q7QUFDSDtBQUNKLEtBaENMLEVBaUNLenBCLElBakNMLENBaUNVNnJCLFlBakNWO0FBa0NILEdBdkNEOztBQXdDQTFTLGNBQVksQ0FBQyxLQUFLdVEsTUFBTCxDQUFZNEIsS0FBWixDQUFELENBQVo7O0FBQ0EsTUFBSXJXLEtBQUssS0FBSyxJQUFkLEVBQW9CO0FBQ2hCLFdBQU82VyxPQUFPLEVBQWQ7QUFDSCxHQUZELE1BRU87QUFDSCxTQUFLcEMsTUFBTCxDQUFZNEIsS0FBWixJQUFxQmorQixVQUFVLENBQUN5K0IsT0FBRCxFQUFVN1csS0FBVixDQUEvQjtBQUNIO0FBQ0osQ0FoREQ7O0FBa0RBcmUsYUFBYSxDQUFDUixTQUFkLENBQXdCNDFCLGFBQXhCLEdBQXdDLFVBQVVuc0MsUUFBVixFQUFvQndILElBQXBCLEVBQTBCNGtDLFFBQTFCLEVBQW9DbitCLE9BQXBDLEVBQTZDa2xCLE9BQTdDLEVBQXdFO0FBQUE7O0FBQUEsTUFBbEJrWixhQUFrQix1RUFBSixFQUFJO0FBQzVHLE9BQUtqQixXQUFMLENBQWlCZ0IsUUFBakI7QUFDQSxTQUFPNWxDLENBQUMsQ0FBQ3FsQyxJQUFGO0FBQ0h2dEMsUUFBSSxFQUFFLE1BREg7QUFFSEQsT0FBRyxFQUFFLEtBQUs2SCxJQUFMLENBQVVsRyxRQUFWLENBRkY7QUFHSHdILFFBQUksRUFBRUE7QUFISCxLQUlBLEtBQUtxakMsZUFBTCxDQUFxQndCLGFBQXJCLENBSkEsR0FNRmxzQixJQU5FLENBTUcsVUFBQzFOLFFBQUQsRUFBYztBQUNoQixVQUFJLENBQUM4NEIsV0FBTDs7QUFDQSxVQUFJLENBQUNwaUMsU0FBTCxDQUFlbkosUUFBZixFQUF5QnVDLFdBQVcsQ0FBQ0MsS0FBckM7O0FBQ0F5TCxXQUFPLENBQUN3RSxRQUFELENBQVA7O0FBQ0EsVUFBSSxDQUFDMDNCLE9BQUwsQ0FBYTEzQixRQUFiO0FBQ0gsR0FYRSxFQVlGNk4sSUFaRSxDQVlHLFVBQUNqTCxDQUFELEVBQUl5MkIsVUFBSixFQUFnQlEsV0FBaEIsRUFBZ0M7QUFDbEMsUUFBSUYsUUFBUSxJQUFJLENBQWhCLEVBQW1CO0FBQ2YsWUFBSSxDQUFDYixXQUFMOztBQUNBLFlBQUksQ0FBQ3BpQyxTQUFMLENBQWVuSixRQUFmLEVBQXlCdUMsV0FBVyxDQUFDdXNCLE1BQXJDLEVBQTZDZ2QsVUFBVSxDQUFDOXBDLFFBQVgsRUFBN0M7O0FBQ0EsVUFBSW14QixPQUFKLEVBQWE7QUFDVEEsZUFBTyxDQUFDOWQsQ0FBRCxFQUFJeTJCLFVBQUosRUFBZ0JRLFdBQWhCLENBQVA7QUFDSDtBQUNKLEtBTkQsTUFNTztBQUNIOStCLGdCQUFVLENBQUMsWUFBTTtBQUNiLGNBQUksQ0FBQys5QixXQUFMOztBQUNBLGNBQUksQ0FBQ3BpQyxTQUFMLENBQWVuSixRQUFmLEVBQXlCdUMsV0FBVyxDQUFDOG1DLFFBQXJDLEVBQStDeUMsVUFBVSxDQUFDOXBDLFFBQVgsRUFBL0M7O0FBQ0EsY0FBSSxDQUFDbXFDLGFBQUwsQ0FBbUJuc0MsUUFBbkIsRUFBNkJ3SCxJQUE3QixFQUFtQzRrQyxRQUFRLEdBQUcsQ0FBOUMsRUFBaURuK0IsT0FBakQsRUFBMERrbEIsT0FBMUQsRUFBbUVrWixhQUFuRTtBQUNILE9BSlMsRUFJUCxNQUFJLENBQUN6QyxVQUpFLENBQVY7QUFLSDtBQUNKLEdBMUJFLENBQVA7QUEyQkgsQ0E3QkQ7O0FBZ0NBN3lCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QmpVLGNBQXhCLEdBQXlDLFVBQVVvRSxhQUFWLEVBQXlCO0FBQUE7O0FBQzlELE1BQUloSixLQUFLLEdBQUcsS0FBSzBZLElBQUwsQ0FBVTFZLEtBQXRCOztBQUNBLE1BQUlBLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU3pDLE1BQVQsQ0FBZ0J3TCxtQkFBaEIsQ0FBb0MsZ0JBQXBDLENBQUosRUFBMkQ7QUFDdkQsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsZUFBRCxDQUFKLEdBQXdCZCxhQUF4Qjs7QUFDQSxTQUFLeWxDLGFBQUwsQ0FBbUIsZ0JBQW5CLEVBQXFDM2tDLElBQXJDLEVBQTJDLENBQTNDLEVBQ21CLFVBQUNpTCxRQUFELEVBQWM7QUFDVixVQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLGNBQUksQ0FBQ21JLElBQUwsQ0FBVVgsbUJBQVYsQ0FBOEJoRCxRQUE5QjtBQUNILE9BRkQsTUFFTztBQUNILGNBQUksQ0FBQ3RKLFNBQUwsQ0FBZSxnQkFBZixFQUFpQzVHLFdBQVcsQ0FBQ3VzQixNQUE3QyxFQUFxRHJjLFFBQVEsQ0FBQ2pOLE9BQTlEOztBQUNBLGNBQUksQ0FBQzRRLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QjhZLHlCQUE1QixDQUFzRHpRLFFBQVEsQ0FBQ2pOLE9BQS9EO0FBQ0g7QUFDSixLQVJwQixFQVNtQixVQUFDNlAsQ0FBRCxFQUFJeTJCLFVBQUosRUFBZ0JRLFdBQWhCLEVBQWdDO0FBQzVCLFlBQUksQ0FBQ2wyQixJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEI4WSx5QkFBNUIsQ0FBc0Q0b0IsVUFBdEQ7O0FBQ0Fya0MsYUFBTyxDQUFDK1ksS0FBUixDQUFjbkwsQ0FBZCxFQUFpQnkyQixVQUFqQixFQUE2QlEsV0FBN0I7QUFDSCxLQVpwQjtBQWFILEdBaEJELE1BZ0JPO0FBQ0gsU0FBS25qQyxTQUFMLENBQWUsZ0JBQWYsRUFBaUM1RyxXQUFXLENBQUMrbUMsT0FBN0M7QUFDSDtBQUNKLENBckJEOztBQXVCQXZ5QixhQUFhLENBQUNSLFNBQWQsQ0FBd0JqVCxjQUF4QixHQUF5QyxZQUFZO0FBQUE7O0FBQ2pELE1BQUk1RixLQUFLLEdBQUcsS0FBSzBZLElBQUwsQ0FBVTFZLEtBQXRCOztBQUNBLE1BQUlBLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU3pDLE1BQVQsQ0FBZ0J3TCxtQkFBaEIsQ0FBb0MsZ0JBQXBDLENBQUosRUFBMkQ7QUFDdkQsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCOUosS0FBSyxDQUFDckIsVUFBTixDQUFpQm9ELE1BQWpCLEVBQWpCO0FBQ0ErSCxRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1COUosS0FBSyxDQUFDckIsVUFBTixDQUFpQm1ELFFBQWpCLEVBQW5CO0FBQ0FnSSxRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCOUosS0FBSyxDQUFDckIsVUFBTixZQUFqQjtBQUNBbUwsUUFBSSxDQUFDLEtBQUQsQ0FBSixHQUFjOUosS0FBSyxDQUFDckIsVUFBTixDQUFpQmdDLEdBQWpCLEVBQWQ7QUFDQW1KLFFBQUksQ0FBQyxRQUFELENBQUosR0FBaUI5SixLQUFLLENBQUNyQixVQUFOLENBQWlCb0MsTUFBakIsRUFBakI7QUFDQStJLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0I5SixLQUFLLENBQUNyQixVQUFOLENBQWlCcUQsUUFBakIsRUFBcEI7QUFDQThILFFBQUksQ0FBQyxNQUFELENBQUosR0FBZTlKLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUIwQixJQUFqQixFQUFmO0FBQ0F5SixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CNGYsMEZBQXNCLENBQUMxcEIsS0FBRCxDQUF6Qzs7QUFFQSxTQUFLeXVDLGFBQUwsQ0FBbUIsZ0JBQW5CLEVBQXFDM2tDLElBQXJDLEVBQTJDLENBQTNDLEVBQ21CLEtBQUsra0MsaUJBQUwsQ0FBdUIvNkIsSUFBdkIsQ0FBNEIsSUFBNUIsQ0FEbkIsRUFFbUIsVUFBQzZELENBQUQsRUFBSXkyQixVQUFKLEVBQWdCUSxXQUFoQixFQUFnQztBQUM1QixZQUFJLENBQUNsMkIsSUFBTCxDQUFVelAsVUFBVixDQUFxQnlELE1BQXJCLENBQTRCcVosd0JBQTVCLENBQXFEcW9CLFVBQXJEOztBQUNBcmtDLGFBQU8sQ0FBQytZLEtBQVIsQ0FBY25MLENBQWQsRUFBaUJ5MkIsVUFBakIsRUFBNkJRLFdBQTdCO0FBQ0gsS0FMcEI7QUFNSCxHQWpCRCxNQWlCTztBQUNILFNBQUtuakMsU0FBTCxDQUFlLGdCQUFmLEVBQWlDNUcsV0FBVyxDQUFDK21DLE9BQTdDLEVBQXNELDRDQUF0RDtBQUNIO0FBQ0osQ0F0QkQ7O0FBd0JBdnlCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QjdULFdBQXhCLEdBQXNDLFVBQVVtcUIsUUFBVixFQUFvQjtBQUFBOztBQUN0RCxNQUFJLEtBQUt6VyxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUJ6QyxNQUFuQixDQUEwQndMLG1CQUExQixDQUE4QyxhQUE5QyxDQUFKLEVBQWtFO0FBQzlELFFBQUkxVSxLQUFLLEdBQUcsS0FBSzBZLElBQUwsQ0FBVTFZLEtBQXRCO0FBQ0EsUUFBSThKLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7O0FBQ0EsU0FBS21CLGFBQUwsQ0FBbUIsYUFBbkIsRUFBa0Mza0MsSUFBbEMsRUFBd0MsQ0FBeEMsRUFBMkNxbEIsUUFBM0MsRUFDbUIsVUFBQ3hYLENBQUQsRUFBSXkyQixVQUFKLEVBQWdCUSxXQUFoQixFQUFnQztBQUM1QixZQUFJLENBQUNsMkIsSUFBTCxDQUFVelAsVUFBVixDQUFxQnlELE1BQXJCLENBQTRCd0kscUJBQTVCOztBQUNBbkwsYUFBTyxDQUFDK1ksS0FBUixDQUFjbkwsQ0FBZCxFQUFpQnkyQixVQUFqQixFQUE2QlEsV0FBN0I7QUFDSCxLQUpwQjtBQUtIO0FBQ0osQ0FWRDs7QUFZQXYxQixhQUFhLENBQUNSLFNBQWQsQ0FBd0IzUyxpQkFBeEIsR0FBNEMsVUFBVWlwQixRQUFWLEVBQW9CO0FBQUE7O0FBQzVELE1BQUksS0FBS3pXLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQnpDLE1BQW5CLENBQTBCd0wsbUJBQTFCLENBQThDLG1CQUE5QyxDQUFKLEVBQXdFO0FBQ3BFLFFBQUkxVSxLQUFLLEdBQUcsS0FBSzBZLElBQUwsQ0FBVTFZLEtBQXRCO0FBQ0EsUUFBSThKLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7O0FBQ0EsU0FBS21CLGFBQUwsQ0FBbUIsbUJBQW5CLEVBQXdDM2tDLElBQXhDLEVBQThDLENBQTlDLEVBQWlEcWxCLFFBQWpELEVBQ21CLFVBQUN4WCxDQUFELEVBQUl5MkIsVUFBSixFQUFnQlEsV0FBaEIsRUFBZ0M7QUFDNUIsYUFBSSxDQUFDbDJCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QmdaLDRCQUE1QixDQUF5RDBvQixVQUF6RDs7QUFDQXJrQyxhQUFPLENBQUMrWSxLQUFSLENBQWNuTCxDQUFkLEVBQWlCeTJCLFVBQWpCLEVBQTZCUSxXQUE3QjtBQUNILEtBSnBCO0FBS0g7QUFDSixDQVZEOztBQVlBdjFCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QnZTLFVBQXhCLEdBQXFDLFVBQVUwUCxTQUFWLEVBQXFCeXlCLFNBQXJCLEVBQWdDN2xDLFFBQWhDLEVBQTBDMFEsUUFBMUMsRUFBb0Q2YixRQUFwRCxFQUFtRjtBQUFBOztBQUFBLE1BQXJCMmYsYUFBcUIsdUVBQVAsS0FBTztBQUNwSCxNQUFJOXVDLEtBQUssR0FBRyxLQUFLMFksSUFBTCxDQUFVMVksS0FBdEI7O0FBQ0EsTUFBSUEsS0FBSyxDQUFDMkwsRUFBTixDQUFTekMsTUFBVCxDQUFnQndMLG1CQUFoQixDQUFvQyxZQUFwQyxDQUFKLEVBQXVEO0FBQ25ELFFBQUk1SyxJQUFJLEdBQUcsS0FBS3dqQyxnQkFBTCxFQUFYO0FBQ0F4akMsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQmtNLFNBQXBCO0FBQ0FsTSxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CMitCLFNBQXBCO0FBQ0EzK0IsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQmxILFFBQW5CO0FBQ0FrSCxRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1Cd0osUUFBbkI7O0FBQ0EsUUFBSXc3QixhQUFKLEVBQW1CO0FBQ2ZobEMsVUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQixJQUFqQjtBQUNIOztBQUNELFFBQUlpbEMsRUFBRSxHQUFHaHJCLE1BQU0sQ0FBQ3drQixPQUFQLENBQWV6K0IsSUFBZixFQUFxQmtoQyxNQUFyQixDQUE0QixVQUFDZ0UsQ0FBRCxFQUFHcjNCLENBQUg7QUFBQSxhQUFVcTNCLENBQUMsQ0FBQ3h5QixNQUFGLE9BQUF3eUIsQ0FBQyxxQkFBV3IzQixDQUFYLEVBQUQsRUFBZ0JxM0IsQ0FBMUI7QUFBQSxLQUE1QixFQUEwRCxJQUFJQyxRQUFKLEVBQTFELENBQVQ7QUFDQSxXQUFPLEtBQUtSLGFBQUwsQ0FBbUIsWUFBbkIsRUFBaUNNLEVBQWpDLEVBQXFDLENBQXJDLEVBQ21CNWYsUUFEbkIsRUFFbUIsVUFBQ3hYLENBQUQsRUFBSXkyQixVQUFKLEVBQWdCUSxXQUFoQixFQUFnQztBQUM1QixVQUFJRSxhQUFKLEVBQW1CO0FBQ2YsZUFBSSxDQUFDcDJCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0Qm9aLG1CQUE1QixDQUFnRHNvQixVQUFoRDtBQUNILE9BRkQsTUFFTztBQUNILGVBQUksQ0FBQzExQixJQUFMLENBQVV6UCxVQUFWLENBQXFCeUQsTUFBckIsQ0FBNEJpWixvQkFBNUIsQ0FBaUR5b0IsVUFBakQ7QUFDSDs7QUFDRHJrQyxhQUFPLENBQUMrWSxLQUFSLENBQWNuTCxDQUFkLEVBQWlCeTJCLFVBQWpCLEVBQTZCUSxXQUE3QjtBQUNILEtBVHBCLEVBU3NCO0FBQUNNLGlCQUFXLEVBQUUsS0FBZDtBQUFxQkMsaUJBQVcsRUFBRTtBQUFsQyxLQVR0QixDQUFQO0FBVUgsR0FwQkQsTUFvQk87QUFDSCxTQUFLMWpDLFNBQUwsQ0FBZSxZQUFmLEVBQTZCNUcsV0FBVyxDQUFDK21DLE9BQXpDLEVBQWtELHdDQUFsRDtBQUNIO0FBQ0osQ0F6QkQ7O0FBMkJBdnlCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QnpTLFlBQXhCLEdBQXVDLFVBQVU0UCxTQUFWLEVBQXFCeXlCLFNBQXJCLEVBQWdDN2xDLFFBQWhDLEVBQTBDdXNCLFFBQTFDLEVBQW9EO0FBQUE7O0FBQ3ZGLE1BQUludkIsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUMyTCxFQUFOLENBQVN6QyxNQUFULENBQWdCd0wsbUJBQWhCLENBQW9DLGNBQXBDLENBQUosRUFBeUQ7QUFDckQsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9Ca00sU0FBcEI7QUFDQWxNLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0IyK0IsU0FBcEI7QUFDQTMrQixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CbEgsUUFBbkI7QUFDQSxRQUFJbXNDLEVBQUUsR0FBR2hyQixNQUFNLENBQUN3a0IsT0FBUCxDQUFleitCLElBQWYsRUFBcUJraEMsTUFBckIsQ0FBNEIsVUFBQ2dFLENBQUQsRUFBR3IzQixDQUFIO0FBQUEsYUFBVXEzQixDQUFDLENBQUN4eUIsTUFBRixPQUFBd3lCLENBQUMscUJBQVdyM0IsQ0FBWCxFQUFELEVBQWdCcTNCLENBQTFCO0FBQUEsS0FBNUIsRUFBMEQsSUFBSUMsUUFBSixFQUExRCxDQUFUO0FBQ0EsV0FBTyxLQUFLUixhQUFMLENBQW1CLGNBQW5CLEVBQW1DTSxFQUFuQyxFQUF1QyxDQUF2QyxFQUNtQjVmLFFBRG5CLEVBRW1CLFVBQUN4WCxDQUFELEVBQUl5MkIsVUFBSixFQUFnQlEsV0FBaEIsRUFBZ0M7QUFDNUIsYUFBSSxDQUFDbDJCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QmtaLHNCQUE1QixDQUFtRHdvQixVQUFuRDs7QUFDQXJrQyxhQUFPLENBQUMrWSxLQUFSLENBQWNuTCxDQUFkLEVBQWlCeTJCLFVBQWpCLEVBQTZCUSxXQUE3QjtBQUNILEtBTHBCLEVBS3NCO0FBQUNNLGlCQUFXLEVBQUUsS0FBZDtBQUFxQkMsaUJBQVcsRUFBRSxLQUFsQztBQUF5Q0MsY0FBUSxFQUFFO0FBQW5ELEtBTHRCLENBQVA7QUFNSCxHQVpELE1BWU87QUFDSCxTQUFLM2pDLFNBQUwsQ0FBZSxZQUFmLEVBQTZCNUcsV0FBVyxDQUFDK21DLE9BQXpDLEVBQWtELHdDQUFsRDtBQUNIO0FBQ0osQ0FqQkQ7O0FBbUJBdnlCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QnJTLFVBQXhCLEdBQXFDLFVBQVV3UCxTQUFWLEVBQXFCeXlCLFNBQXJCLEVBQWdDNEcsWUFBaEMsRUFBOENDLFlBQTlDLEVBQTREbmdCLFFBQTVELEVBQXNFO0FBQUE7O0FBQ3ZHLE1BQUludkIsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUMyTCxFQUFOLENBQVN6QyxNQUFULENBQWdCd0wsbUJBQWhCLENBQW9DLFlBQXBDLENBQUosRUFBdUQ7QUFDbkQsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9Ca00sU0FBcEI7QUFDQWxNLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0IyK0IsU0FBcEI7QUFDQTMrQixRQUFJLENBQUMsY0FBRCxDQUFKLEdBQXVCdWxDLFlBQXZCO0FBQ0F2bEMsUUFBSSxDQUFDLGNBQUQsQ0FBSixHQUF1QndsQyxZQUF2QjtBQUNBLFFBQUlQLEVBQUUsR0FBR2hyQixNQUFNLENBQUN3a0IsT0FBUCxDQUFleitCLElBQWYsRUFBcUJraEMsTUFBckIsQ0FBNEIsVUFBQ2dFLENBQUQsRUFBR3IzQixDQUFIO0FBQUEsYUFBVXEzQixDQUFDLENBQUN4eUIsTUFBRixPQUFBd3lCLENBQUMscUJBQVdyM0IsQ0FBWCxFQUFELEVBQWdCcTNCLENBQTFCO0FBQUEsS0FBNUIsRUFBMEQsSUFBSUMsUUFBSixFQUExRCxDQUFUO0FBQ0EsV0FBTyxLQUFLUixhQUFMLENBQW1CLFlBQW5CLEVBQWlDTSxFQUFqQyxFQUFxQyxDQUFyQyxFQUNtQjVmLFFBRG5CLEVBRW1CLFVBQUN4WCxDQUFELEVBQUl5MkIsVUFBSixFQUFnQlEsV0FBaEIsRUFBZ0M7QUFDNUIsYUFBSSxDQUFDbDJCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QmlaLG9CQUE1QixDQUFpRHlvQixVQUFqRDs7QUFDQXJrQyxhQUFPLENBQUMrWSxLQUFSLENBQWNuTCxDQUFkLEVBQWlCeTJCLFVBQWpCLEVBQTZCUSxXQUE3QjtBQUNILEtBTHBCLEVBS3NCO0FBQUNNLGlCQUFXLEVBQUUsS0FBZDtBQUFxQkMsaUJBQVcsRUFBRTtBQUFsQyxLQUx0QixDQUFQO0FBTUgsR0FiRCxNQWFPO0FBQ0gsU0FBSzFqQyxTQUFMLENBQWUsWUFBZixFQUE2QjVHLFdBQVcsQ0FBQyttQyxPQUF6QyxFQUFrRCx3Q0FBbEQ7QUFDSDtBQUNKLENBbEJEOztBQW9CQXZ5QixhQUFhLENBQUNSLFNBQWQsQ0FBd0J2VCxRQUF4QixHQUFtQyxVQUFVK2pDLFVBQVYsRUFBc0J0aEMsUUFBdEIsRUFBZ0NDLEtBQWhDLEVBQXVDRixPQUF2QyxFQUFnRHNoQyxTQUFoRCxFQUEyRDtBQUMxRixNQUFJLEtBQUsxd0IsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCMEIsUUFBeEIsRUFBSixFQUF3QztBQUNwQyxTQUFLb0gsU0FBTCxDQUFlLFVBQWYsRUFBMkI1RyxXQUFXLENBQUMrbUMsT0FBdkM7QUFDQTtBQUNIOztBQUNELE1BQUksS0FBS2x6QixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkwsRUFBaEIsQ0FBbUJ6QyxNQUFuQixDQUEwQndMLG1CQUExQixDQUE4QyxVQUE5QyxDQUFKLEVBQStEO0FBQzNELFFBQUk1SyxJQUFJLEdBQUcsS0FBS3dqQyxnQkFBTCxFQUFYO0FBQ0F4akMsUUFBSSxDQUFDLFlBQUQsQ0FBSixHQUFxQnUvQixVQUFyQjtBQUNBdi9CLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUIvQixRQUFuQjtBQUNBK0IsUUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQjlCLEtBQWhCO0FBQ0E4QixRQUFJLENBQUMsU0FBRCxDQUFKLEdBQWtCaEMsT0FBbEI7QUFDQWdDLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0JzL0IsU0FBcEI7QUFDQSxTQUFLMzlCLFNBQUwsQ0FBZSxVQUFmLEVBQTJCNUcsV0FBVyxDQUFDbUssTUFBdkMsRUFQMkQsQ0FRM0Q7O0FBQ0EsU0FBSzg5QixVQUFMLENBQWdCaGpDLElBQWhCLEVBQXNCLFVBQXRCLEVBQWtDLENBQWxDLEVBQXFDLFlBQU0sQ0FDMUMsQ0FERDtBQUVILEdBWEQsTUFXTztBQUNILFNBQUsyQixTQUFMLENBQWUsVUFBZixFQUEyQjVHLFdBQVcsQ0FBQyttQyxPQUF2QztBQUNIO0FBQ0osQ0FuQkQ7O0FBcUJBdnlCLGFBQWEsQ0FBQ1IsU0FBZCxDQUF3QnJULFNBQXhCLEdBQW9DLFVBQVVpakMsU0FBVixFQUFxQnJuQixLQUFyQixFQUE0QjtBQUM1RCxNQUFJLEtBQUsxSSxJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0IwQixRQUF4QixFQUFKLEVBQXdDO0FBQ3BDLFNBQUtvSCxTQUFMLENBQWUsV0FBZixFQUE0QjVHLFdBQVcsQ0FBQyttQyxPQUF4QztBQUNBO0FBQ0g7O0FBQ0QsTUFBSSxLQUFLbHpCLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQnpDLE1BQW5CLENBQTBCd0wsbUJBQTFCLENBQThDLFdBQTlDLENBQUosRUFBZ0U7QUFDNUQsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CMitCLFNBQXBCO0FBQ0EzK0IsUUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQnNYLEtBQWhCO0FBQ0EsU0FBSzNWLFNBQUwsQ0FBZSxXQUFmLEVBQTRCNUcsV0FBVyxDQUFDbUssTUFBeEMsRUFKNEQsQ0FLNUQ7O0FBQ0EsU0FBSzQ5QixnQkFBTCxDQUFzQjlpQyxJQUF0QixFQUE0QixlQUE1QixFQUE2QyxXQUE3QyxFQUEwRCxDQUExRDtBQUNILEdBUEQsTUFPTztBQUNILFNBQUsyQixTQUFMLENBQWUsV0FBZixFQUE0QjVHLFdBQVcsQ0FBQyttQyxPQUF4QztBQUNIO0FBQ0osQ0FmRDs7QUFpQkF2eUIsYUFBYSxDQUFDUixTQUFkLENBQXdCN1Msc0JBQXhCLEdBQWlELFVBQVN1cEMsU0FBVCxFQUFvQjtBQUFBOztBQUNqRSxNQUFJLEtBQUs3MkIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCMEIsUUFBeEIsRUFBSixFQUF3QztBQUNwQyxTQUFLb0gsU0FBTCxDQUFlLHdCQUFmLEVBQXlDNUcsV0FBVyxDQUFDK21DLE9BQXJEO0FBQ0E7QUFDSDs7QUFDRCxNQUFJLEtBQUtsekIsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJMLEVBQWhCLENBQW1CekMsTUFBbkIsQ0FBMEJ3TCxtQkFBMUIsQ0FBOEMsd0JBQTlDLENBQUosRUFBNkU7QUFDekUsUUFBSTVLLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCeWxDLFNBQWpCOztBQUNBLFFBQUlDLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQzFsQyxJQUFELEVBQVU7QUFDN0IsVUFBSUEsSUFBSSxDQUFDeUcsT0FBVCxFQUFrQjtBQUNkLGVBQUksQ0FBQ21JLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjZELGdCQUEzQixDQUE0QzhzQyxTQUE1QztBQUNIO0FBQ0osS0FKRDs7QUFLQSxTQUFLZCxhQUFMLENBQW1CLHdCQUFuQixFQUE2QzNrQyxJQUE3QyxFQUFtRCxDQUFuRCxFQUFzRDBsQyxnQkFBdEQsRUFDbUIsVUFBQzczQixDQUFELEVBQUl5MkIsVUFBSixFQUFnQlEsV0FBaEIsRUFBZ0M7QUFDNUIsYUFBSSxDQUFDbDJCLElBQUwsQ0FBVXpQLFVBQVYsQ0FBcUJ5RCxNQUFyQixDQUE0QnlaLGdDQUE1Qjs7QUFDQXBjLGFBQU8sQ0FBQytZLEtBQVIsQ0FBY25MLENBQWQsRUFBaUJ5MkIsVUFBakIsRUFBNkJRLFdBQTdCO0FBQ0gsS0FKcEI7QUFLSDtBQUNKLENBbkJEO0FBcUJBOzs7Ozs7O0FBS0F2MUIsYUFBYSxDQUFDUixTQUFkLENBQXdCM1QsUUFBeEIsR0FBbUMsVUFBVXRDLFFBQVYsRUFBb0JoQyxJQUFwQixFQUEwQnV1QixRQUExQixFQUFvQ3NnQixhQUFwQyxFQUFtRDtBQUNsRixNQUFJenZDLEtBQUssR0FBRyxLQUFLMFksSUFBTCxDQUFVMVksS0FBdEI7QUFDQSxNQUFJa0osTUFBTSxHQUFHLElBQWI7O0FBQ0EsTUFBSWxKLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU3pDLE1BQVQsQ0FBZ0J3TCxtQkFBaEIsQ0FBb0MsV0FBcEMsQ0FBSixFQUFzRDtBQUNsRCxRQUFJNUssSUFBSSxHQUFHLEtBQUt3akMsZ0JBQUwsRUFBWDtBQUNBeGpDLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUJsSCxRQUFuQjtBQUNBa0gsUUFBSSxDQUFDLE1BQUQsQ0FBSixHQUFlbEosSUFBZjs7QUFDQSxTQUFLNnRDLGFBQUwsQ0FBbUIsS0FBS2ptQyxJQUFMLENBQVVrbkMsU0FBN0IsRUFBd0M1bEMsSUFBeEMsRUFBOEMsQ0FBOUMsRUFDbUIsVUFBVWlMLFFBQVYsRUFBb0I7QUFDaEIsVUFBSUEsUUFBUSxDQUFDeEUsT0FBYixFQUFzQjtBQUNsQjRlLGdCQUFRLENBQUNwYSxRQUFRLENBQUNqTCxJQUFWLENBQVI7QUFDSCxPQUZELE1BRU87QUFDSDJsQyxxQkFBYSxDQUFDMTZCLFFBQVEsQ0FBQ2pOLE9BQVYsQ0FBYjtBQUNBb0IsY0FBTSxDQUFDdUMsU0FBUCxDQUFpQixVQUFqQixFQUE2QjVHLFdBQVcsQ0FBQ3VzQixNQUF6QyxFQUFpRHJjLFFBQVEsQ0FBQ2pOLE9BQTFEO0FBQ0g7QUFDSixLQVJwQixFQVNtQixVQUFVNlAsQ0FBVixFQUFheTJCLFVBQWIsRUFBeUJRLFdBQXpCLEVBQXNDO0FBQ2xDYSxtQkFBYSxDQUFDLHNDQUFELENBQWI7QUFDQTFsQyxhQUFPLENBQUMrWSxLQUFSLENBQWM4ckIsV0FBZDtBQUNILEtBWnBCO0FBYUgsR0FqQkQsTUFpQk87QUFDSGEsaUJBQWEsQ0FBQywyQkFBRCxDQUFiO0FBQ0EsU0FBS2hrQyxTQUFMLENBQWUsVUFBZixFQUEyQjVHLFdBQVcsQ0FBQyttQyxPQUF2QyxFQUFnRCxzQ0FBaEQ7QUFDSDtBQUNKLENBeEJEOztBQTBCQXZ5QixhQUFhLENBQUNSLFNBQWQsQ0FBd0JuVCxRQUF4QixHQUFtQyxVQUFVOUMsUUFBVixFQUFvQjBRLFFBQXBCLEVBQThCb2tCLEtBQTlCLEVBQXFDO0FBQ3BFLE1BQUlBLEtBQUssS0FBSzU0QixTQUFkLEVBQXlCO0FBQ3JCNDRCLFNBQUssR0FBRyxLQUFLdVUsV0FBYjtBQUNIOztBQUNELE1BQUlqc0MsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUMyQyxPQUFOLENBQWMwQixRQUFkLEVBQUosRUFBOEI7QUFDMUIsU0FBS29ILFNBQUwsQ0FBZSxVQUFmLEVBQTJCNUcsV0FBVyxDQUFDK21DLE9BQXZDO0FBQ0E7QUFDSDs7QUFDRCxNQUFJNXJDLEtBQUssQ0FBQzJMLEVBQU4sQ0FBU3pDLE1BQVQsQ0FBZ0J3TCxtQkFBaEIsQ0FBb0MsVUFBcEMsQ0FBSixFQUFxRDtBQUNqRCxRQUFJNUssSUFBSSxHQUFHLEtBQUt3akMsZ0JBQUwsRUFBWDtBQUNBeGpDLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUJsSCxRQUFuQjtBQUNBa0gsUUFBSSxDQUFDLE1BQUQsQ0FBSixHQUFld0osUUFBZjtBQUNBLFNBQUs3SCxTQUFMLENBQWUsVUFBZixFQUEyQjVHLFdBQVcsQ0FBQ21LLE1BQXZDO0FBQ0EsV0FBTyxLQUFLNDlCLGdCQUFMLENBQXNCOWlDLElBQXRCLEVBQTRCbEgsUUFBNUIsRUFBc0MsVUFBdEMsRUFBa0Q4MEIsS0FBbEQsRUFBeUQsS0FBS21YLGlCQUFMLENBQXVCLzZCLElBQXZCLENBQTRCLElBQTVCLENBQXpELENBQVA7QUFDSCxHQU5ELE1BTU87QUFDSCxXQUFPLEtBQUtySSxTQUFMLENBQWUsVUFBZixFQUEyQjVHLFdBQVcsQ0FBQyttQyxPQUF2QyxDQUFQO0FBQ0g7QUFDSixDQWxCRDs7QUFvQkF2eUIsYUFBYSxDQUFDUixTQUFkLENBQXdCZzJCLGlCQUF4QixHQUE0QyxVQUFVOTVCLFFBQVYsRUFBb0I7QUFDNUQsTUFBSSxDQUFDQSxRQUFRLENBQUN4RSxPQUFWLElBQXFCd0UsUUFBUSxDQUFDNDZCLFFBQWxDLEVBQTRDO0FBQ3hDLFNBQUtqM0IsSUFBTCxDQUFVelAsVUFBVixDQUFxQnlELE1BQXJCLENBQTRCMFosVUFBNUI7QUFDSDtBQUNKLENBSkQ7O0FBTUEvTSxhQUFhLENBQUNSLFNBQWQsQ0FBd0IvUyxnQkFBeEIsR0FBMkMsVUFBVXZELEtBQVYsRUFBaUJDLE9BQWpCLEVBQTBCb3RDLGNBQTFCLEVBQTBDQyxXQUExQyxFQUF1RDtBQUFBOztBQUM5RixNQUFJLEtBQUtuM0IsSUFBTCxDQUFVMVksS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCMEIsUUFBeEIsRUFBSixFQUF3QztBQUNwQyxTQUFLb0gsU0FBTCxDQUFlLGtCQUFmLEVBQW1DNUcsV0FBVyxDQUFDK21DLE9BQS9DO0FBQ0E7QUFDSDs7QUFDRCxNQUFJemMsUUFBUSxHQUFHLEtBQUt6VyxJQUFMLENBQVUxWSxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJ5SixTQUE5QixDQUF3Q29JLE9BQXZEOztBQUNBLE1BQUksS0FBS21JLElBQUwsQ0FBVTFZLEtBQVYsQ0FBZ0IyTCxFQUFoQixDQUFtQnpDLE1BQW5CLENBQTBCd0wsbUJBQTFCLENBQThDLGtCQUE5QyxDQUFKLEVBQXVFO0FBQ25FLFFBQUk1SyxJQUFJLEdBQUcsS0FBS3dqQyxnQkFBTCxFQUFYO0FBQ0F4akMsUUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQnZILEtBQWhCO0FBQ0F1SCxRQUFJLENBQUMsU0FBRCxDQUFKLEdBQWtCdEgsT0FBbEI7QUFDQXNILFFBQUksQ0FBQyxpQkFBRCxDQUFKLEdBQTBCOGxDLGNBQTFCO0FBQ0E5bEMsUUFBSSxDQUFDLGNBQUQsQ0FBSixHQUF1QitsQyxXQUF2QjtBQUNBLFNBQUtuM0IsSUFBTCxDQUFVelAsVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQ3FHLFdBQXJDLENBQWlEbStCLGdCQUFqRCxDQUFrRSxVQUFDQyxPQUFELEVBQVVDLEdBQVYsRUFBa0I7QUFDaEZsbUMsVUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQmltQyxPQUFoQjs7QUFDQSxVQUFJQyxHQUFHLENBQUN0MEIsTUFBUixFQUFnQjtBQUNaczBCLFdBQUcsQ0FBQ3QwQixNQUFKO0FBQ0g7O0FBQ0QsYUFBSSxDQUFDb3hCLFVBQUwsQ0FBZ0JoakMsSUFBaEIsRUFBc0Isa0JBQXRCLEVBQTBDLENBQTFDLEVBQ2dCLFVBQUNpTCxRQUFELEVBQWM7QUFDVixZQUFJQSxRQUFRLENBQUN4RSxPQUFiLEVBQXNCO0FBQ2xCLGlCQUFJLENBQUM5RSxTQUFMLENBQWUsa0JBQWYsRUFBbUM1RyxXQUFXLENBQUNDLEtBQS9DO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUksQ0FBQzJHLFNBQUwsQ0FBZSxrQkFBZixFQUFtQzVHLFdBQVcsQ0FBQ3VzQixNQUEvQyxFQUF1RHJjLFFBQVEsQ0FBQ2pOLE9BQWhFO0FBQ0g7O0FBQ0QsWUFBSSxDQUFDOG5DLGNBQUQsSUFBbUJwdEMsT0FBbkIsSUFBOEIyc0IsUUFBbEMsRUFBNEM7QUFDeENBLGtCQUFRLENBQUNybEIsSUFBSSxDQUFDLGVBQUQsQ0FBTCxDQUFSO0FBQ0g7QUFDSixPQVZqQjtBQVdILEtBaEJEO0FBaUJIO0FBQ0osQ0E5QkQ7O0FBZ0NBdVAsYUFBYSxDQUFDUixTQUFkLENBQXdCNmlCLFdBQXhCLEdBQXNDLFVBQVV1VSxXQUFWLEVBQXVCO0FBQ3pELE1BQUlqd0MsS0FBSyxHQUFHLEtBQUswWSxJQUFMLENBQVUxWSxLQUF0QjtBQUNBLE1BQUlrSixNQUFNLEdBQUcsSUFBYjtBQUNBLE1BQUlZLElBQUksR0FBRyxLQUFLd2pDLGdCQUFMLEVBQVg7QUFDQXhqQyxNQUFJLENBQUMsYUFBRCxDQUFKLEdBQXNCbW1DLFdBQXRCO0FBQ0EsU0FBTyxLQUFLeEIsYUFBTCxDQUFtQixLQUFLam1DLElBQUwsQ0FBVTBuQyxZQUE3QixFQUEyQ3BtQyxJQUEzQyxDQUFQO0FBQ0gsQ0FORCxDOzs7Ozs7Ozs7Ozs7O0FDL3FCQTtBQUFBO0FBQU8sSUFBTTZ3QixnQkFBZ0Isc3NDQUF0QixDOzs7Ozs7Ozs7Ozs7QUNBUDtBQUFBO0FBQU8sSUFBSXdWLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBUzl2QyxJQUFULEVBQWU7QUFDdkMsTUFBSSt2QyxHQUFKLEVBQVNDLGFBQVQ7QUFDQUQsS0FBRyxHQUFHO0FBQUNFLFlBQVEsRUFBRTtBQUFYLEdBQU47O0FBRUEsTUFBSSxDQUFDaDRCLEVBQUUsQ0FBQ2k0QixHQUFSLEVBQWE7QUFDVGo0QixNQUFFLENBQUNpNEIsR0FBSCxHQUFTO0FBQUMxd0IsWUFBTSxFQUFFO0FBQVQsS0FBVDtBQUNILEdBTnNDLENBUXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTMndCLGNBQVQsQ0FBd0IxTSxHQUF4QixFQUE2QmhzQixNQUE3QixFQUFxQztBQUNqQyxTQUFLMjRCLFVBQUwsR0FBa0IzNEIsTUFBbEI7QUFDQSxTQUFLNDRCLFNBQUwsR0FBa0I1TSxHQUFsQjtBQUNIOztBQUVEME0sZ0JBQWMsQ0FBQzMzQixTQUFmLENBQXlCMmMsSUFBekIsR0FBZ0MsVUFBU21iLEVBQVQsRUFBYTtBQUN6QyxRQUFJLEtBQUtELFNBQVQsRUFBb0I7QUFDaEIsYUFBTyxJQUFQO0FBQ0g7O0FBRUQsUUFBSTtBQUNBLFdBQUtELFVBQUwsR0FBa0JFLEVBQUUsQ0FBQyxLQUFLRixVQUFOLENBQXBCO0FBQ0gsS0FGRCxDQUVFLE9BQU05NEIsQ0FBTixFQUFTO0FBQ1AsV0FBSzg0QixVQUFMLEdBQWtCM3hDLFNBQWxCO0FBQ0EsV0FBSzR4QyxTQUFMLEdBQWtCLzRCLENBQWxCO0FBQ0g7O0FBRUQsV0FBTyxLQUFLODRCLFVBQUwsWUFBMkJ6eUIsT0FBM0IsR0FBcUMsS0FBS3l5QixVQUExQyxHQUF1RCxJQUE5RDtBQUNILEdBYkQ7O0FBZUFELGdCQUFjLENBQUMzM0IsU0FBZixZQUFpQyxVQUFTODNCLEVBQVQsRUFBYTtBQUMxQyxRQUFJLEtBQUtELFNBQVQsRUFBb0I7QUFDaEIsVUFBSTtBQUNBLGFBQUtELFVBQUwsR0FBa0JFLEVBQUUsQ0FBQyxLQUFLRCxTQUFOLENBQXBCO0FBQ0EsYUFBS0EsU0FBTCxHQUFrQjV4QyxTQUFsQjtBQUNILE9BSEQsQ0FHRSxPQUFNNlksQ0FBTixFQUFTO0FBQ1AsYUFBSzg0QixVQUFMLEdBQWtCM3hDLFNBQWxCO0FBQ0EsYUFBSzR4QyxTQUFMLEdBQWlCLzRCLENBQWpCO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLEtBQUs4NEIsVUFBTCxZQUEyQnp5QixPQUEzQixHQUFxQyxLQUFLeXlCLFVBQTFDLEdBQXVELElBQTlEO0FBQ0gsR0FaRDs7QUFjQSxNQUFJRyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFTenZCLFNBQVQsRUFBb0IsQ0FFcEMsQ0FGRDs7QUFJQSxXQUFTMHZCLFFBQVQsQ0FBa0J4d0MsSUFBbEIsRUFBd0I7QUFDcEIsV0FBTyxJQUFJMmQsT0FBSixDQUFZLFVBQVNDLE9BQVQsRUFBa0JzUSxNQUFsQixFQUEwQjtBQUN6QyxVQUFJalcsRUFBRSxDQUFDaTRCLEdBQUgsQ0FBTzF3QixNQUFQLENBQWN4ZixJQUFkLE1BQXdCdkIsU0FBNUIsRUFBdUM7QUFDbkM7QUFDQW1mLGVBQU8sQ0FBQzNGLEVBQUUsQ0FBQ2k0QixHQUFILENBQU8xd0IsTUFBUCxDQUFjeGYsSUFBZCxDQUFELENBQVA7QUFDSCxPQUhELE1BR087QUFDSCxZQUFJMnZDLEdBQUcsR0FBRyxJQUFJYyxLQUFKLEVBQVY7QUFDQWQsV0FBRyxDQUFDZSxXQUFKLEdBQWtCLFdBQWxCOztBQUNBZixXQUFHLENBQUN0NEIsTUFBSixHQUFhLFlBQVk7QUFDckJZLFlBQUUsQ0FBQ2k0QixHQUFILENBQU8xd0IsTUFBUCxDQUFjeGYsSUFBZCxJQUFzQjJ2QyxHQUF0QjtBQUNBL3hCLGlCQUFPLENBQUMreEIsR0FBRCxDQUFQO0FBQ0gsU0FIRDs7QUFJQUEsV0FBRyxDQUFDZ0IsT0FBSixHQUFjLFlBQVk7QUFDdEI7QUFDQXppQixnQkFBTSxDQUFDbHVCLElBQUQsQ0FBTjtBQUNILFNBSEQ7O0FBSUEydkMsV0FBRyxDQUFDaUIsR0FBSixHQUFVNXdDLElBQVY7QUFDSDtBQUNKLEtBakJNLENBQVA7QUFrQkg7O0FBRUQsTUFBSStnQixLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFTOHZCLElBQVQsRUFBZUMsSUFBZixFQUFxQjtBQUM3QjtBQUNBO0FBRUFBLFFBQUksQ0FBQ0MsUUFBTCxHQUFnQixJQUFJOTRCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVUzbEMsSUFBVixFQUFnQjRsQyxXQUFoQixFQUE2QjtBQUM3RGg1QixRQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QixVQUF2QixFQUFtQzF1QixTQUFuQyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRDtBQUNBdkssUUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3dZLFdBQVgsQ0FBdUIsYUFBdkIsRUFBc0MsUUFBdEMsRUFBZ0RsNUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3lZLFdBQVgsQ0FBdUJILFdBQXZCLENBQWhEO0FBQ0E1bEMsVUFBSSxDQUFDNGxDLFdBQUwsR0FBbUJBLFdBQW5CLENBSDZELENBSTdEOztBQUNBLFVBQUlJLFlBQVksR0FBR2IsUUFBUSxDQUFDdjRCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJvWCxXQUFqQixDQUFELENBQTNCO0FBQ0EsVUFBSUssSUFBSSxHQUFHLElBQUlyNUIsRUFBRSxDQUFDeWQsUUFBSCxDQUFZNmIsVUFBaEIsRUFBWDtBQUNBbG1DLFVBQUksQ0FBQzBWLEtBQUwsR0FBYTlJLEVBQUUsQ0FBQzBnQixPQUFILENBQVd1SixJQUFYLENBQWdCQyxLQUE3Qjs7QUFDQW1QLFVBQUksQ0FBQ0UsTUFBTCxHQUFjLFlBQVc7QUFDckIsWUFBSUYsSUFBSSxDQUFDN25DLElBQUwsQ0FBVSxPQUFWLENBQUosRUFBd0I7QUFDcEI7QUFDQSxnQkFBTTZuQyxJQUFJLENBQUM3bkMsSUFBTCxDQUFVLE9BQVYsQ0FBTjtBQUNILFNBSEQsTUFHTyxDQUNIO0FBQ0g7QUFDSixPQVBEOztBQVFBNm5DLFVBQUksQ0FBQzduQyxJQUFMLEdBQVk7QUFDUmxKLFlBQUksRUFBRSxZQURFO0FBRVJreEMsZUFBTyxFQUFFSixZQUFZLENBQUNsYyxJQUFiLENBQWtCLFVBQVNsVSxLQUFULEVBQWdCO0FBQ3ZDNVYsY0FBSSxDQUFDMFYsS0FBTCxHQUFhRSxLQUFiO0FBQ0E1VixjQUFJLENBQUMyUSxNQUFMLEdBQWNDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFkO0FBQ0E3USxjQUFJLENBQUMyUSxNQUFMLENBQVl0TyxLQUFaLEdBQW9CckMsSUFBSSxDQUFDMFYsS0FBTCxDQUFXclQsS0FBL0I7QUFDQXJDLGNBQUksQ0FBQzJRLE1BQUwsQ0FBWTZDLE1BQVosR0FBcUJ4VCxJQUFJLENBQUMwVixLQUFMLENBQVdsQyxNQUFoQztBQUNBeFQsY0FBSSxDQUFDMlEsTUFBTCxDQUFZMDFCLFVBQVosQ0FBdUIsSUFBdkIsRUFBNkJDLFNBQTdCLENBQXVDdG1DLElBQUksQ0FBQzBWLEtBQTVDLEVBQW1ELENBQW5ELEVBQXNELENBQXRELEVBQXlEMVYsSUFBSSxDQUFDMFYsS0FBTCxDQUFXclQsS0FBcEUsRUFBMkVyQyxJQUFJLENBQUMwVixLQUFMLENBQVdsQyxNQUF0RjtBQUNBeFQsY0FBSSxDQUFDdW1DLE1BQUwsR0FBY3ZtQyxJQUFJLENBQUMyUSxNQUFMLENBQVkwMUIsVUFBWixDQUF1QixJQUF2QixFQUE2QkcsWUFBN0IsQ0FBMEMsQ0FBMUMsRUFBNkMsQ0FBN0MsRUFBZ0R4bUMsSUFBSSxDQUFDMFYsS0FBTCxDQUFXclQsS0FBM0QsRUFBa0VyQyxJQUFJLENBQUMwVixLQUFMLENBQVdsQyxNQUE3RSxFQUFxRnBWLElBQW5HLENBTnVDLENBT3ZDO0FBQ0gsU0FSUSxFQVFOLFVBQVNnNkIsR0FBVCxFQUFjO0FBQ2JwNEIsY0FBSSxDQUFDMFYsS0FBTCxHQUFhLEVBQWI7QUFDQSxnQkFBTTBpQixHQUFOLENBRmEsQ0FHYjtBQUNILFNBWlE7QUFGRCxPQUFaO0FBaUJBLGFBQU82TixJQUFQO0FBQ0gsS0FsQ2UsQ0FBaEI7QUFvQ0FSLFFBQUksQ0FBQzMzQixJQUFMLEdBQVksSUFBSWxCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVMzbEMsSUFBVCxFQUFlO0FBQzNDLFVBQUk0TSxFQUFFLENBQUN2TyxPQUFILEtBQWVqTCxTQUFuQixFQUE4QjtBQUMxQixjQUFNLElBQUl3WixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXbVosU0FBZixDQUF5Qix3REFBekIsQ0FBTjtBQUNIOztBQUVELFVBQUlDLFdBQVcsR0FBRztBQUNkaHhCLGFBQUssRUFBRTFWLElBQUksQ0FBQzBWLEtBREU7QUFFZGt3QixtQkFBVyxFQUFFNWxDLElBQUksQ0FBQzRsQztBQUZKLE9BQWxCO0FBS0FoNUIsUUFBRSxDQUFDdk8sT0FBSCxDQUFXc29DLGFBQVgsQ0FBeUJELFdBQXpCO0FBQ0gsS0FYVyxDQUFaO0FBYUFqQixRQUFJLENBQUNtQixJQUFMLEdBQVksSUFBSWg2QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixVQUFTM2xDLElBQVQsRUFBZTtBQUMzQ0EsVUFBSSxDQUFDMFYsS0FBTCxDQUFXbXhCLEtBQVgsQ0FBaUJDLFNBQWpCLEdBQTZCLFlBQTdCOztBQUNBLFVBQUlsNkIsRUFBRSxDQUFDdk8sT0FBSCxLQUFlakwsU0FBbkIsRUFBOEI7QUFDMUIsY0FBTSxJQUFJd1osRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21aLFNBQWYsQ0FBeUIsd0RBQXpCLENBQU47QUFDSDs7QUFDRCxhQUFPem1DLElBQVA7QUFDSCxLQU5XLENBQVo7QUFPSCxHQTVERDs7QUE2REEwa0MsS0FBRyxDQUFDVSxLQUFKLEdBQVl4NEIsRUFBRSxDQUFDeWQsUUFBSCxDQUFZMGMsVUFBWixDQUF1QnJDLEdBQXZCLEVBQTRCaHZCLEtBQTVCLEVBQW1DLE9BQW5DLEVBQTRDLEVBQTVDLENBQVo7QUFFQSxTQUFPZ3ZCLEdBQVA7QUFDSCxDQTdJTSxDOzs7Ozs7Ozs7Ozs7QUNBUDtBQUFBO0FBQU8sSUFBTXRWLGFBQWEsNDVDQUFuQixDOzs7Ozs7Ozs7Ozs7QUNBUDtBQUFBO0FBQUE7Ozs7Ozs7O0FBUU8sSUFBSUwsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixHQUFXO0FBQ3ZDO0FBQ0EsTUFBSTJWLEdBQUcsR0FBRyxFQUFWO0FBQ0EsTUFBSTdOLElBQUksR0FBR2pxQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXdUosSUFBWCxDQUFnQkMsS0FBM0I7QUFFQSxNQUFJa1EsS0FBSyxHQUFHLElBQVo7QUFDQXRDLEtBQUcsQ0FBQ3VDLE1BQUosR0FBYSxJQUFJcjZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVNoeEMsSUFBVCxFQUFlO0FBQzVDaVksTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsUUFBdkIsRUFBaUMxdUIsU0FBakMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0M7QUFDQSxRQUFJK3ZCLFVBQUo7O0FBQ0EsUUFBSUYsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEJFLGdCQUFVLEdBQUcsQ0FBYjtBQUNILEtBRkQsTUFFTztBQUNIQSxnQkFBVSxHQUFHckksSUFBSSxDQUFDRCxHQUFMLEtBQWFvSSxLQUExQjtBQUNIOztBQUNEM29DLFdBQU8sQ0FBQ29PLEdBQVIsQ0FBWUcsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQjc1QixJQUFqQixDQUFaLEVBQW9DdXlDLFVBQVUsR0FBQyxJQUEvQztBQUNBRixTQUFLLEdBQUduSSxJQUFJLENBQUNELEdBQUwsRUFBUjtBQUNILEdBVlksQ0FBYjtBQVlBOzs7O0FBR0E4RixLQUFHLENBQUN5QyxXQUFKLEdBQWtCLElBQUl2NkIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUM3Q3RuQyxXQUFPLENBQUNvTyxHQUFSLENBQVksMkJBQUswSyxTQUFMLEVBQWlCMVAsR0FBakIsQ0FBcUJtRixFQUFFLENBQUNrRCxHQUFILENBQU8wZSxTQUE1QixDQUFaO0FBQ0gsR0FGaUIsQ0FBbEI7QUFJQTs7OztBQUdBa1csS0FBRyxDQUFDMEMsYUFBSixHQUFvQixJQUFJeDZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFlBQVc7QUFDL0N0bkMsV0FBTyxDQUFDb08sR0FBUixDQUFZMEssU0FBWjtBQUNILEdBRm1CLENBQXBCO0FBSUE7Ozs7O0FBSUF1dEIsS0FBRyxDQUFDMkMsVUFBSixHQUFpQixJQUFJejZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFlBQVc7QUFDNUMvNEIsTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsWUFBdkIsRUFBcUMxdUIsU0FBckMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQ7O0FBQ0EsUUFBSXZLLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbG1CLE9BQW5DLEVBQTRDO0FBQ3hDLFVBQUl4SixNQUFNLEdBQUd1UixFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQixRQUEvQixHQUFiO0FBQ0ExdkIsWUFBTSxHQUFHQSxNQUFNLENBQUNvTSxHQUFQLENBQVcsVUFBUzYvQixJQUFULEVBQWU7QUFBRSxlQUFPQSxJQUFJLENBQUNDLFFBQUwsRUFBUDtBQUF5QixPQUFyRCxDQUFUO0FBQ0EsYUFBTyxJQUFJMzZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdrYSxJQUFmLENBQW9CbnNDLE1BQXBCLENBQVA7QUFDSCxLQUpELE1BSU87QUFDSCxhQUFPLElBQUl1UixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXa2EsSUFBZixDQUFvQixFQUFwQixDQUFQO0FBQ0g7QUFDSixHQVRnQixDQUFqQjtBQVdBOzs7OztBQUlBOUMsS0FBRyxDQUFDK0MsWUFBSixHQUFtQixJQUFJNzZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFlBQVc7QUFDOUMvNEIsTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsY0FBdkIsRUFBdUMxdUIsU0FBdkMsRUFBa0QsQ0FBbEQsRUFBcUQsQ0FBckQ7O0FBQ0EsUUFBSXZLLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbG1CLE9BQW5DLEVBQTRDO0FBQ3hDK0gsUUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0IxdkIsTUFBL0IsQ0FBc0NxWSxTQUF0QztBQUNIOztBQUNELFdBQU85RyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXdUosSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxHQU5rQixDQUFuQjtBQVFBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFHQTROLEtBQUcsQ0FBQ2dELFdBQUosR0FBa0IsSUFBSTk2QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQzdDLzRCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLGFBQXZCLEVBQXNDMXVCLFNBQXRDLEVBQWlELENBQWpELEVBQW9ELENBQXBEO0FBQ0EsV0FBT3ZLLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQm5ELEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFVBQXBCLEVBQWdDdDBCLElBQWpELENBQVA7QUFDSCxHQUhpQixDQUFsQjtBQUtBOzs7O0FBR0FpdUMsS0FBRyxDQUFDaUQsY0FBSixHQUFxQixJQUFJLzZCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFlBQVc7QUFDaEQvNEIsTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDMXVCLFNBQXpDLEVBQW9ELENBQXBELEVBQXVELENBQXZEO0FBQ0EsV0FBT3ZLLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQm5ELEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCOEYsVUFBL0IsSUFBNkMsRUFBOUQsQ0FBUDtBQUNILEdBSG9CLENBQXJCO0FBS0E2VCxLQUFHLENBQUNrRCxXQUFKLEdBQWtCLElBQUloN0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUM3QyxRQUFJLzRCLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbG1CLE9BQW5DLEVBQTRDO0FBQ3hDLFVBQUlpZixLQUFLLEdBQUdsWCxFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQjhjLFNBQTNDO0FBQ0EsYUFBT2o3QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUIrVCxLQUFqQixDQUFQO0FBQ0gsS0FIRCxNQUdPO0FBQ0gsYUFBTyxJQUFJbFgsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV2thLElBQWYsQ0FBb0IsRUFBcEIsQ0FBUDtBQUNIO0FBQ0osR0FQaUIsQ0FBbEI7QUFTQTlDLEtBQUcsQ0FBQ29ELFdBQUosR0FBa0IsSUFBSWw3QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQzdDO0FBQ0E7QUFDQSxRQUFJLzRCLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbG1CLE9BQW5DLEVBQTRDO0FBQ3hDLFVBQUk1SSxLQUFLLEdBQUcyUSxFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQjl1QixLQUEzQztBQUNBLGFBQU8yUSxFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUI5VCxLQUFqQixDQUFQO0FBQ0g7O0FBQ0QsV0FBTyxJQUFJMlEsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzJFLElBQWYsQ0FBb0IsRUFBcEIsQ0FBUDtBQUNILEdBUmlCLENBQWxCO0FBVUF5UyxLQUFHLENBQUNxRCxXQUFKLEdBQWtCLElBQUluN0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUM3QztBQUNBLFFBQUkvNEIsRUFBRSxDQUFDd2YsVUFBSCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QnhmLFFBQUUsQ0FBQ3dmLFVBQUgsR0FBZ0J4ZixFQUFFLENBQUN1aUIsZ0JBQW5CO0FBQ0g7O0FBQ0R2aUIsTUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0J0QixPQUEvQixDQUF1QzlXLElBQXZDLENBQTRDLElBQTVDLEVBTDZDLENBTTdDO0FBQ0gsR0FQaUIsQ0FBbEI7QUFTQSt4QixLQUFHLENBQUNzRCxVQUFKLEdBQWlCLElBQUlwN0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUM1QztBQUNBLzRCLE1BQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCdEIsT0FBL0IsQ0FBdUM0RSxHQUF2Qzs7QUFDQSxRQUFJemhCLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCdEIsT0FBL0IsQ0FBdUMzakIsTUFBdkMsS0FBa0QsQ0FBdEQsRUFBeUQ7QUFDckQ4RyxRQUFFLENBQUN3ZixVQUFILEdBQWdCLElBQWhCO0FBQ0gsS0FMMkMsQ0FNNUM7O0FBQ0gsR0FQZ0IsQ0FBakI7QUFTQTs7OztBQUdBc1ksS0FBRyxDQUFDdUQsaUJBQUosR0FBd0IsSUFBSXI3QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQ25ELzRCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLG1CQUF2QixFQUE0QzF1QixTQUE1QyxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDs7QUFDQSxRQUFJdkssRUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JsbUIsT0FBbkMsRUFBNEM7QUFDeEMsYUFBTyxJQUFJK0gsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzRhLEtBQWYsQ0FBcUIsQ0FBQ3JSLElBQUQsRUFBT0EsSUFBUCxDQUFyQixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSXpmLEtBQUssR0FBR3hLLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLFNBQXBCLEVBQStCM1QsS0FBM0M7QUFBQSxVQUNJK3dCLFFBQVEsR0FBRyxFQURmOztBQUVBLFVBQUkvd0IsS0FBSyxJQUFJQSxLQUFLLENBQUM0Z0IsU0FBZixJQUE0QjVnQixLQUFLLENBQUM0Z0IsU0FBTixDQUFnQmx5QixNQUFoQixHQUF5QixDQUF6RCxFQUE0RDtBQUN4RHFpQyxnQkFBUSxDQUFDLE1BQUQsQ0FBUixHQUFtQi93QixLQUFLLENBQUM0Z0IsU0FBTixDQUFnQixDQUFoQixFQUFtQnpFLE1BQXRDO0FBQ0gsT0FGRCxNQUVPO0FBQ0huYyxhQUFLLEdBQUd5ZixJQUFSO0FBQ0g7O0FBQ0RzUixjQUFRLEdBQUd2N0IsRUFBRSxDQUFDa0QsR0FBSCxDQUFPQyxTQUFQLENBQWlCbzRCLFFBQWpCLENBQVg7QUFDQSxhQUFPLElBQUl2N0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzRhLEtBQWYsQ0FBcUIsQ0FBQzl3QixLQUFELEVBQVErd0IsUUFBUixDQUFyQixDQUFQO0FBQ0g7QUFDSixHQWZ1QixDQUF4QjtBQWtCQXpELEtBQUcsQ0FBQzBELHdCQUFKLEdBQStCLElBQUl4N0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUMxRC80QixNQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QiwwQkFBdkIsRUFBbUQxdUIsU0FBbkQsRUFBOEQsQ0FBOUQsRUFBaUUsQ0FBakU7QUFDQSxXQUFPLENBQUN2SyxFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQmxtQixPQUFoQyxJQUNDK0gsRUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0IzVCxLQURoQyxJQUVDeEssRUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0IzVCxLQUEvQixDQUFxQ21hLE9BQXJDLEtBQWlELGdCQUZ6RDtBQUdILEdBTDhCLENBQS9CO0FBT0EsTUFBSThXLFVBQVUsR0FBR2oxQyxTQUFqQjtBQUNBc3hDLEtBQUcsQ0FBQzRELG9CQUFKLEdBQTJCLElBQUkxN0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUN0RC80QixNQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QixzQkFBdkIsRUFBK0MxdUIsU0FBL0MsRUFBMEQsQ0FBMUQsRUFBNkQsQ0FBN0Q7QUFDQWt4QixjQUFVLEdBQUd6N0IsRUFBRSxDQUFDaWYsU0FBaEI7O0FBQ0EsUUFBSWpmLEVBQUUsQ0FBQ3NmLGlCQUFQLEVBQTBCO0FBQ3RCdGYsUUFBRSxDQUFDaWYsU0FBSCxHQUFlamYsRUFBRSxDQUFDc2YsaUJBQUgsRUFBZjtBQUNBdGYsUUFBRSxDQUFDMjdCLFNBQUgsR0FBZTFKLElBQUksQ0FBQ0QsR0FBTCxFQUFmO0FBQ0g7QUFDSixHQVAwQixDQUEzQjtBQVFBOEYsS0FBRyxDQUFDOEQsc0JBQUosR0FBNkIsSUFBSTU3QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQ3hELzRCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLHdCQUF2QixFQUFpRDF1QixTQUFqRCxFQUE0RCxDQUE1RCxFQUErRCxDQUEvRDtBQUNBdkssTUFBRSxDQUFDaWYsU0FBSCxHQUFld2MsVUFBZjtBQUNBejdCLE1BQUUsQ0FBQzI3QixTQUFILEdBQWUxSixJQUFJLENBQUNELEdBQUwsRUFBZjtBQUNILEdBSjRCLENBQTdCO0FBTUE4RixLQUFHLENBQUMrRCxrQkFBSixHQUF5QixJQUFJNzdCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFlBQVc7QUFDcEQvNEIsTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsb0JBQXZCLEVBQTZDMXVCLFNBQTdDLEVBQXdELENBQXhELEVBQTJELENBQTNEO0FBQ0F2SyxNQUFFLENBQUNtZSxnQkFBSCxDQUFvQjV6QixVQUFwQixDQUErQms2QixTQUEvQixHQUEyQyxJQUEzQztBQUNILEdBSHdCLENBQXpCO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQXFULEtBQUcsQ0FBQ2dFLFNBQUosR0FBZ0IsSUFBSTk3QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQzNDLzRCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLFdBQXZCLEVBQW9DMXVCLFNBQXBDLEVBQStDLENBQS9DLEVBQWtELENBQWxEOztBQUNBLFFBQUl2SyxFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQmxtQixPQUFuQyxFQUE0QztBQUN4QyxVQUFJOGpDLE9BQU8sR0FBRy83QixFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixTQUFwQixFQUErQixRQUEvQixHQUFkO0FBQ0E0ZCxhQUFPLEdBQUdBLE9BQU8sQ0FBQ25yQixNQUFSLENBQWUsVUFBU25pQixNQUFULEVBQWlCO0FBQ3RDLGVBQU9BLE1BQU0sQ0FBQ25HLElBQVAsS0FBZ0IsTUFBdkI7QUFDSCxPQUZTLEVBRVB1UyxHQUZPLENBRUgsVUFBU21oQyxLQUFULEVBQWdCO0FBQ25CLGVBQU87QUFBQyxrQkFBUUEsS0FBSyxDQUFDbDVCLE9BQU4sQ0FBY2pJLEdBQWQsQ0FBa0IsVUFBU29oQyxJQUFULEVBQWU7QUFDN0MsZ0JBQUlDLE9BQU8sR0FBRztBQUFFLHNCQUFRRCxJQUFJLENBQUMzekMsSUFBZjtBQUNWLHVCQUFTO0FBREMsYUFBZDs7QUFFQSxnQkFBSTJ6QyxJQUFJLENBQUMzekMsSUFBTCxLQUFjLE1BQWQsSUFBd0IyekMsSUFBSSxDQUFDM3pDLElBQUwsS0FBYyxTQUExQyxFQUFxRDtBQUNqRDR6QyxxQkFBTyxDQUFDLEdBQUQsQ0FBUCxHQUFlRCxJQUFJLENBQUN6cUMsSUFBTCxDQUFVcUosR0FBVixDQUFjLFVBQVNzb0IsQ0FBVCxFQUFZO0FBQUUsdUJBQU9BLENBQUMsQ0FBQ3BCLENBQVQ7QUFBYSxlQUF6QyxDQUFmO0FBQ0FtYSxxQkFBTyxDQUFDLEdBQUQsQ0FBUCxHQUFlRCxJQUFJLENBQUN6cUMsSUFBTCxDQUFVcUosR0FBVixDQUFjLFVBQVNzb0IsQ0FBVCxFQUFZO0FBQUUsdUJBQU9BLENBQUMsQ0FBQ2daLENBQVQ7QUFBYSxlQUF6QyxDQUFmO0FBQ0gsYUFIRCxNQUdPLElBQUlGLElBQUksQ0FBQzN6QyxJQUFMLEtBQWMsTUFBbEIsRUFBMEI7QUFDN0I0ekMscUJBQU8sQ0FBQyxRQUFELENBQVAsR0FBb0JELElBQUksQ0FBQ3pxQyxJQUF6QjtBQUNIOztBQUNELG1CQUFPMHFDLE9BQVA7QUFDSCxXQVZlLENBQVQ7QUFXUCxvQkFBVSxFQVhIO0FBV08sb0JBQVUsRUFYakI7QUFZUCxtQkFBUyxFQVpGO0FBWU0sb0JBQVU7QUFaaEIsU0FBUDtBQWNILE9BakJTLENBQVY7QUFrQkEsYUFBT2w4QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUI0NEIsT0FBakIsQ0FBUDtBQUNILEtBckJELE1BcUJPO0FBQ0gsYUFBTy83QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUIsRUFBakIsQ0FBUDtBQUNIO0FBQ0osR0ExQmUsQ0FBaEIsQ0ExTHVDLENBdU52Qzs7QUFDQTIwQixLQUFHLENBQUNzRSxXQUFKLEdBQWtCcDhCLEVBQUUsQ0FBQ3lkLFFBQUgsQ0FBWTBjLFVBQVosQ0FBdUJyQyxHQUF2QixFQUE0QixVQUFTYyxJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDL0RBLFFBQUksQ0FBQ0MsUUFBTCxHQUFnQixJQUFJOTRCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVMzbEMsSUFBVCxFQUFlO0FBQy9DO0FBQ0EsVUFBSWlwQyxPQUFPLEdBQUcsSUFBSXI4QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXMkUsSUFBZixFQUFkO0FBQ0FybEIsUUFBRSxDQUFDczhCLEtBQUgsQ0FBU0MsS0FBVCxDQUFlbnBDLElBQWYsRUFBcUIsSUFBSTRNLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1CLE1BQW5CLENBQXJCLEVBQWlEd1osT0FBakQsRUFBMEQsSUFBMUQ7QUFDQWpwQyxVQUFJLENBQUM4cUIsTUFBTCxHQUFjbGUsRUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JodkIsT0FBN0M7O0FBQ0EsVUFBSWlFLElBQUksQ0FBQzhxQixNQUFMLEtBQWdCMTNCLFNBQXBCLEVBQStCO0FBQzNCNE0sWUFBSSxDQUFDOHFCLE1BQUwsR0FBYzlxQixJQUFJLENBQUM4cUIsTUFBTCxDQUFZRyxFQUExQjs7QUFDQSxhQUFLLElBQUlsM0IsR0FBVCxJQUFnQmlNLElBQUksQ0FBQzhxQixNQUFyQixFQUE2QjtBQUN6QixjQUFJOXFCLElBQUksQ0FBQzhxQixNQUFMLENBQVk2QyxjQUFaLENBQTJCNTVCLEdBQTNCLENBQUosRUFBcUM7QUFDakM2WSxjQUFFLENBQUNzOEIsS0FBSCxDQUFTRSxhQUFULENBQXVCSCxPQUF2QixFQUFnQ3I4QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJuRCxFQUFFLENBQUN5OEIsYUFBSCxDQUFpQnQxQyxHQUFqQixDQUFqQixDQUFoQyxFQUN1QmlNLElBQUksQ0FBQzhxQixNQUFMLENBQVkvMkIsR0FBWixDQUR2QjtBQUVIO0FBQ0o7QUFDSixPQVJELE1BUU87QUFDSGlNLFlBQUksQ0FBQzhxQixNQUFMLEdBQWMsRUFBZDtBQUNIOztBQUNELGFBQU9sZSxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXdUosSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxLQWpCZSxDQUFoQjs7QUFrQkEsUUFBSXdTLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVNDLEdBQVQsRUFBYztBQUN2QjM4QixRQUFFLENBQUMwZ0IsT0FBSCxDQUFXa2MsY0FBWCxDQUEwQixNQUExQixFQUFrQ3J5QixTQUFTLENBQUNyUixNQUE1QyxFQUFvRCxDQUFwRCxFQUF1RHFtQixRQUF2RCxFQUFpRSxJQUFqRSxFQUF1RSxJQUF2RTtBQUNBLFVBQUlpQyxJQUFJLEdBQUd1RixLQUFLLENBQUN4bUIsU0FBTixDQUFnQi9GLEtBQWhCLENBQXNCcWlDLElBQXRCLENBQTJCdHlCLFNBQTNCLEVBQXNDLENBQXRDLENBQVg7QUFDQSxVQUFJK1csTUFBTSxHQUFHLElBQUl0aEIsRUFBRSxDQUFDODhCLFFBQUgsQ0FBWXpYLElBQWhCLENBQXFCc1gsR0FBckIsQ0FBYjtBQUVBLFVBQUl2cEMsSUFBSSxHQUFHb3VCLElBQUksQ0FBQyxDQUFELENBQWY7QUFDQSxVQUFJSixZQUFZLEdBQUdJLElBQUksQ0FBQyxDQUFELENBQXZCO0FBQ0FBLFVBQUksR0FBR0EsSUFBSSxDQUFDaG5CLEtBQUwsQ0FBVyxDQUFYLENBQVA7QUFFQSxVQUFJNFQsTUFBTSxHQUFHa1QsTUFBTSxDQUFDeWIsU0FBUCxDQUFpQixJQUFJLzhCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1CLFFBQW5CLENBQWpCLENBQWI7O0FBQ0EsVUFBSXpVLE1BQU0sS0FBSzVuQixTQUFmLEVBQTBCO0FBQ3RCNG5CLGNBQU0sR0FBR3BPLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJ4VCxNQUFqQixDQUFUOztBQUNBLFlBQUlBLE1BQU0sQ0FBQzZELFdBQVAsS0FBdUI4VSxLQUEzQixFQUFrQztBQUM5QjNZLGdCQUFNLENBQUN2RSxPQUFQLENBQWUsVUFBUzZ3QixJQUFULEVBQWU7QUFDMUIxNkIsY0FBRSxDQUFDOEYsV0FBSCxDQUFlQyxJQUFmLENBQW9CMjBCLElBQXBCO0FBQ0gsV0FGRDtBQUdILFNBSkQsTUFJTztBQUNIMTZCLFlBQUUsQ0FBQzhGLFdBQUgsQ0FBZUMsSUFBZixDQUFvQnJYLEtBQXBCO0FBQ0g7QUFDSjs7QUFFRCxVQUFJOEMsSUFBSSxHQUFHNEIsSUFBSSxDQUFDbzJCLFVBQUwsQ0FBZ0IsSUFBSXhwQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXbUMsR0FBZixDQUFtQixNQUFuQixDQUFoQixDQUFYO0FBQ0EsVUFBSW1hLGNBQWMsR0FBR3hyQyxJQUFJLENBQUN1ckMsU0FBTCxDQUFlM2IsWUFBZixDQUFyQjtBQUNBLFVBQUk1aEIsTUFBTSxHQUFHdzlCLGNBQWMsQ0FBQ0MsT0FBZixDQUF1QnpiLElBQXZCLENBQWI7QUFDQSxhQUFPaGlCLE1BQVA7QUFDSCxLQXpCRDs7QUEwQkFrOUIsVUFBTSxDQUFDUSxTQUFQLEdBQW1CLElBQW5CLENBN0MrRCxDQThDL0Q7O0FBQ0FSLFVBQU0sQ0FBQ1MsT0FBUCxHQUFnQixJQUFJbjlCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1CLE1BQW5CLENBQWhCO0FBQ0FnVyxRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CLElBQUk3NEIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IyRCxNQUFwQixDQUFwQjtBQUVBN0QsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQixJQUFJNzRCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVMzbEMsSUFBVCxFQUFlO0FBQ2xELGFBQU8sSUFBSTRNLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1CLEVBQW5CLENBQVA7QUFDSCxLQUZrQixDQUFuQjtBQUlBZ1csUUFBSSxDQUFDdUUsaUJBQUwsR0FBeUIsSUFBSXA5QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixVQUFTM2xDLElBQVQsRUFBZTlLLElBQWYsRUFBcUIrMEMsZ0JBQXJCLEVBQXVDO0FBQ2hGcjlCLFFBQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLG1CQUF2QixFQUE0QzF1QixTQUE1QyxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDs7QUFDQSxVQUFJOHlCLGdCQUFnQixLQUFLNzJDLFNBQXpCLEVBQW9DO0FBQ2hDNjJDLHdCQUFnQixHQUFHLElBQW5CO0FBQ0gsT0FGRCxNQUVPO0FBQ0hyOUIsVUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3dZLFdBQVgsQ0FBdUIsa0JBQXZCLEVBQTJDLFNBQTNDLEVBQXNEbDVCLEVBQUUsQ0FBQzBnQixPQUFILENBQVc0YyxTQUFYLENBQXFCRCxnQkFBckIsQ0FBdEQ7QUFDQUEsd0JBQWdCLEdBQUdyOUIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQnliLGdCQUFqQixDQUFuQjtBQUNIOztBQUNELFVBQUk3OUIsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsV0FBSyxJQUFJKzlCLFFBQVQsSUFBcUJucUMsSUFBSSxDQUFDOHFCLE1BQTFCLEVBQWtDO0FBQzlCLFlBQUk5cUIsSUFBSSxDQUFDOHFCLE1BQUwsQ0FBWTZDLGNBQVosQ0FBMkJ3YyxRQUEzQixDQUFKLEVBQTBDO0FBQ3RDLGNBQUlucUMsSUFBSSxDQUFDOHFCLE1BQUwsQ0FBWXFmLFFBQVosRUFBc0I1WSxPQUF0QixLQUFrQ3I4QixJQUFJLENBQUNxOEIsT0FBM0MsRUFBb0Q7QUFDaEQ7QUFDQSxnQkFBSTBZLGdCQUFnQixJQUFJRSxRQUFRLENBQUNoakMsVUFBVCxDQUFvQixJQUFwQixDQUF4QixFQUFtRDtBQUMvQztBQUNIOztBQUNEaUYsa0JBQU0sQ0FBQ3VHLElBQVAsQ0FBWS9GLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQm5ELEVBQUUsQ0FBQ3k4QixhQUFILENBQWlCYyxRQUFqQixDQUFqQixDQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sSUFBSXY5QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXa2EsSUFBZixDQUFvQnA3QixNQUFwQixDQUFQO0FBQ0gsS0FyQndCLENBQXpCO0FBdUJBcTVCLFFBQUksQ0FBQzJFLGtCQUFMLEdBQTBCLElBQUl4OUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsVUFBUzNsQyxJQUFULEVBQWU5SyxJQUFmLEVBQXFCKzBDLGdCQUFyQixFQUF1QztBQUNqRnI5QixRQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QixvQkFBdkIsRUFBNkMxdUIsU0FBN0MsRUFBd0QsQ0FBeEQsRUFBMkQsQ0FBM0Q7O0FBQ0EsVUFBSTh5QixnQkFBZ0IsS0FBSzcyQyxTQUF6QixFQUFvQztBQUNoQzYyQyx3QkFBZ0IsR0FBRyxJQUFuQjtBQUNILE9BRkQsTUFFTztBQUNIcjlCLFVBQUUsQ0FBQzBnQixPQUFILENBQVd3WSxXQUFYLENBQXVCLGtCQUF2QixFQUEyQyxTQUEzQyxFQUFzRGw1QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXNGMsU0FBWCxDQUFxQkQsZ0JBQXJCLENBQXREO0FBQ0FBLHdCQUFnQixHQUFHcjlCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzBlLFNBQVAsQ0FBaUJ5YixnQkFBakIsQ0FBbkI7QUFDSDs7QUFDRCxVQUFJNzlCLE1BQU0sR0FBRyxFQUFiOztBQUNBLFdBQUssSUFBSSs5QixRQUFULElBQXFCbnFDLElBQUksQ0FBQzhxQixNQUExQixFQUFrQztBQUM5QixZQUFJOXFCLElBQUksQ0FBQzhxQixNQUFMLENBQVk2QyxjQUFaLENBQTJCd2MsUUFBM0IsQ0FBSixFQUEwQztBQUN0QyxjQUFJbnFDLElBQUksQ0FBQzhxQixNQUFMLENBQVlxZixRQUFaLEVBQXNCNVksT0FBdEIsS0FBa0NyOEIsSUFBSSxDQUFDcThCLE9BQTNDLEVBQW9EO0FBQ2hELGdCQUFJMFksZ0JBQWdCLElBQUlFLFFBQVEsQ0FBQ2hqQyxVQUFULENBQW9CLElBQXBCLENBQXhCLEVBQW1EO0FBQy9DO0FBQ0g7O0FBQ0RpRixrQkFBTSxDQUFDdUcsSUFBUCxDQUFZM1MsSUFBSSxDQUFDOHFCLE1BQUwsQ0FBWXFmLFFBQVosQ0FBWjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxhQUFPLElBQUl2OUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV2thLElBQWYsQ0FBb0JwN0IsTUFBcEIsQ0FBUDtBQUNILEtBcEJ5QixDQUExQjtBQXFCSCxHQWxHaUIsRUFrR2YsYUFsR2UsQ0FBbEI7QUFtR0FzNEIsS0FBRyxDQUFDbHBDLE9BQUosR0FBY29SLEVBQUUsQ0FBQ3lkLFFBQUgsQ0FBWWdnQixnQkFBWixDQUE2QjNGLEdBQUcsQ0FBQ3NFLFdBQWpDLENBQWQ7QUFFQXRFLEtBQUcsQ0FBQzRGLGdCQUFKLEdBQXVCLElBQUkxOUIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsWUFBVztBQUNsRC80QixNQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QixrQkFBdkIsRUFBMkMxdUIsU0FBM0MsRUFBc0QsQ0FBdEQsRUFBeUQsQ0FBekQ7QUFDQSxXQUFPdXRCLEdBQUcsQ0FBQ2xwQyxPQUFYO0FBQ0gsR0FIc0IsQ0FBdkI7QUFLQWtwQyxLQUFHLENBQUM2RixnQkFBSixHQUF1QixJQUFJMzlCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVM2RSxlQUFULEVBQTBCO0FBQ2pFNTlCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLGtCQUF2QixFQUEyQzF1QixTQUEzQyxFQUFzRCxDQUF0RCxFQUF5RCxDQUF6RDtBQUNBcXpCLG1CQUFlLEdBQUc1OUIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMGUsU0FBUCxDQUFpQmdjLGVBQWpCLENBQWxCO0FBQ0E1OUIsTUFBRSxDQUFDbWUsZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkI5ekIsT0FBN0IsQ0FBcUNrQixtQkFBckMsQ0FBeURxeUMsZUFBekQ7QUFDSCxHQUpzQixDQUF2QjtBQU1BOUYsS0FBRyxDQUFDK0YsY0FBSixHQUFxQixJQUFJNzlCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVNydEIsSUFBVCxFQUFlO0FBQ3BEMUwsTUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDMXVCLFNBQXpDLEVBQW9ELENBQXBELEVBQXVELENBQXZEO0FBQ0EsUUFBSTdpQixLQUFLLEdBQUdzWSxFQUFFLENBQUNtZSxnQkFBSCxDQUFvQixPQUFwQixDQUFaO0FBQ0F6UyxRQUFJLEdBQUcxTCxFQUFFLENBQUNrRCxHQUFILENBQU8wZSxTQUFQLENBQWlCbFcsSUFBakIsRUFBdUJqRCxLQUF2QixDQUE2QixHQUE3QixDQUFQOztBQUNBLFNBQUssSUFBSUUsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHK0MsSUFBSSxDQUFDeFMsTUFBdkIsRUFBK0J5UCxDQUFDLEVBQWhDLEVBQW9DO0FBQ2hDamhCLFdBQUssR0FBR0EsS0FBSyxDQUFDZ2tCLElBQUksQ0FBQy9DLENBQUQsQ0FBTCxDQUFiO0FBQ0g7O0FBQ0QsV0FBTzNJLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQnpiLEtBQUssRUFBdEIsQ0FBUDtBQUNILEdBUm9CLENBQXJCO0FBVUFvd0MsS0FBRyxDQUFDZ0csOEJBQUosR0FBcUMsSUFBSTk5QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixZQUFXO0FBQ2hFLzRCLE1BQUUsQ0FBQzBnQixPQUFILENBQVd1WSxXQUFYLENBQXVCLGdDQUF2QixFQUF5RDF1QixTQUF6RCxFQUFvRSxDQUFwRSxFQUF1RSxDQUF2RTtBQUNBdkssTUFBRSxDQUFDeWlCLDJCQUFIO0FBQ0gsR0FIb0MsQ0FBckM7QUFLQXFWLEtBQUcsQ0FBQ2lHLGFBQUosR0FBb0IsSUFBSS85QixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXcVksSUFBZixDQUFvQixVQUFTcjdCLFNBQVQsRUFBb0J5eUIsU0FBcEIsRUFBK0I3bEMsUUFBL0IsRUFBeUM7QUFDN0UwVixNQUFFLENBQUMwZ0IsT0FBSCxDQUFXdVksV0FBWCxDQUF1QixlQUF2QixFQUF3QzF1QixTQUF4QyxFQUFtRCxDQUFuRCxFQUFzRCxDQUF0RDtBQUNBLFFBQU15ekIsZUFBZSxHQUFHaCtCLEVBQUUsQ0FBQ21lLGdCQUFILENBQW9CLE9BQXBCLEVBQTZCLzNCLGFBQTdCLENBQTJDOEosSUFBM0MsQ0FBZ0QsY0FBaEQsQ0FBeEI7QUFDQSxRQUFNK3RDLFFBQVEsR0FBR0QsZUFBZSxDQUFDamIsUUFBaEIsQ0FBeUIsR0FBekIsSUFBZ0MsR0FBaEMsR0FBc0MsR0FBdkQ7QUFDQSxRQUFNMTZCLEdBQUcsYUFBTTIxQyxlQUFOLFNBQXdCQyxRQUF4Qix1QkFBNkN2Z0MsU0FBN0Msd0JBQW9FeXlCLFNBQXBFLHVCQUEwRjdsQyxRQUExRixDQUFUO0FBQ0EsUUFBTTR6QyxJQUFJLEdBQUcsSUFBSXg0QixPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQnNRLE1BQW5CLEVBQTJCO0FBQ2hELFVBQU1rb0IsT0FBTyxHQUFHLElBQUlDLGNBQUosRUFBaEIsQ0FEZ0QsQ0FFaEQ7O0FBRUFELGFBQU8sQ0FBQ0UsZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0MsVUFBVWgvQixDQUFWLEVBQWE7QUFDN0NzRyxlQUFPLENBQUMzRixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJnN0IsT0FBTyxDQUFDRyxZQUF6QixDQUFELENBQVA7QUFDSCxPQUZEO0FBSUFILGFBQU8sQ0FBQ0ksSUFBUixDQUFhLEtBQWIsRUFBb0JsMkMsR0FBcEI7QUFDQTgxQyxhQUFPLENBQUNLLElBQVIsQ0FBYSxJQUFiO0FBQ0gsS0FWWSxDQUFiO0FBV0EsUUFBTW5GLElBQUksR0FBRyxJQUFJcjVCLEVBQUUsQ0FBQ3lkLFFBQUgsQ0FBWTZiLFVBQWhCLEVBQWI7QUFDQSxRQUFJbUYsVUFBVSxHQUFHLElBQWpCOztBQUNBcEYsUUFBSSxDQUFDRSxNQUFMLEdBQWM7QUFBQSxhQUFJa0YsVUFBSjtBQUFBLEtBQWQ7O0FBQ0FwRixRQUFJLENBQUM3bkMsSUFBTCxHQUFZO0FBQ1JsSixVQUFJLEVBQUUsWUFERTtBQUVSa3hDLGFBQU8sRUFBRTBFLElBQUksQ0FBQ2hoQixJQUFMLENBQVUsVUFBQ2xVLEtBQUQsRUFBVztBQUMxQnkxQixrQkFBVSxHQUFHejFCLEtBQWI7QUFDQSxlQUFPQSxLQUFQO0FBQ0gsT0FIUSxFQUdOLFVBQUN3aUIsR0FBRCxFQUFTO0FBQ1JpVCxrQkFBVSxHQUFFLEVBQVo7QUFDQSxlQUFPalQsR0FBUDtBQUNILE9BTlE7QUFGRCxLQUFaO0FBVUEsV0FBTzZOLElBQVA7QUFDSCxHQTlCbUIsQ0FBcEI7QUFnQ0EsU0FBT3ZCLEdBQVA7QUFDSCxDQXhYTSxDOzs7Ozs7Ozs7Ozs7QUNSUDtBQUFBO0FBQU8sSUFBSUQsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixDQUFTOXZDLElBQVQsRUFBZTtBQUN2QyxNQUFJK3ZDLEdBQUosRUFBU0MsYUFBVDtBQUNBRCxLQUFHLEdBQUc7QUFBQ0UsWUFBUSxFQUFFO0FBQVgsR0FBTjtBQUVBOzs7O0FBSUEsTUFBSTBHLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVM5RixJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDL0JBLFFBQUksQ0FBQ0MsUUFBTCxHQUFnQixJQUFJOTRCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVUzbEMsSUFBVixFQUFnQjVCLElBQWhCLEVBQXNCO0FBQ3REd08sUUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VZLFdBQVgsQ0FBdUIsVUFBdkIsRUFBbUMxdUIsU0FBbkMsRUFBOEMsQ0FBOUMsRUFBaUQsQ0FBakQ7QUFDQXZLLFFBQUUsQ0FBQzBnQixPQUFILENBQVd3WSxXQUFYLENBQXVCLE1BQXZCLEVBQStCLFVBQS9CLEVBQTJDbDVCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdpZSxhQUFYLENBQXlCbnRDLElBQXpCLENBQTNDO0FBQ0E0QixVQUFJLENBQUM1QixJQUFMLEdBQVksRUFBWjtBQUNBLFVBQUlvdEMsSUFBSSxHQUFHNStCLEVBQUUsQ0FBQ3M4QixLQUFILENBQVNzQyxJQUFULENBQWNwdEMsSUFBZCxDQUFYO0FBQ0EsVUFBSWlILElBQUo7O0FBQ0EsU0FBRztBQUNDQSxZQUFJLEdBQUd1SCxFQUFFLENBQUNzOEIsS0FBSCxDQUFTdUMsUUFBVCxDQUFrQkQsSUFBbEIsQ0FBUDs7QUFDQSxZQUFJbm1DLElBQUksS0FBS2pTLFNBQWIsRUFBd0I7QUFDcEI0TSxjQUFJLENBQUM1QixJQUFMLENBQVV1VSxJQUFWLENBQWUsSUFBSSs0QixPQUFKLENBQVlybUMsSUFBWixDQUFmO0FBQ0g7QUFDSixPQUxELFFBS1NBLElBQUksS0FBS2pTLFNBTGxCOztBQU1BLGFBQU93WixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXdUosSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxLQWJlLENBQWhCO0FBZUEyTyxRQUFJLENBQUNrRyxRQUFMLEdBQWdCLElBQUkvK0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWYsQ0FBb0IsVUFBUzNsQyxJQUFULEVBQWU7QUFDL0MsVUFBTTRyQyxVQUFVLEdBQUcsRUFBbkI7O0FBQ0EsV0FBSyxJQUFJcjJCLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR3ZWLElBQUksQ0FBQzVCLElBQUwsQ0FBVTBILE1BQTVCLEVBQW9DeVAsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQyxZQUFNK3hCLElBQUksR0FBR3RuQyxJQUFJLENBQUM1QixJQUFMLENBQVVtWCxDQUFWLEVBQWFzMkIsS0FBYixFQUFiOztBQUNBLFlBQUl2RSxJQUFJLEtBQUtsMEMsU0FBYixFQUF3QjtBQUNwQnc0QyxvQkFBVSxDQUFDajVCLElBQVgsQ0FBZ0IyMEIsSUFBaEI7QUFDSDtBQUNKOztBQUNEdG5DLFVBQUksQ0FBQzVCLElBQUwsR0FBWXd0QyxVQUFaO0FBQ0EsYUFBT2gvQixFQUFFLENBQUNzOEIsS0FBSCxDQUFTc0MsSUFBVCxDQUFjLElBQUk1K0IsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV2thLElBQWYsQ0FBb0JvRSxVQUFwQixDQUFkLENBQVA7QUFDSCxLQVZlLENBQWhCO0FBWUE7Ozs7QUFJQW5HLFFBQUksQ0FBQzEvQixHQUFMLEdBQVcsSUFBSTZHLEVBQUUsQ0FBQzBnQixPQUFILENBQVdxWSxJQUFmLENBQW9CLFVBQVMzbEMsSUFBVCxFQUFlc25DLElBQWYsRUFBcUI7QUFDaER0bkMsVUFBSSxDQUFDNUIsSUFBTCxDQUFVdVUsSUFBVixDQUFlLElBQUkrNEIsT0FBSixDQUFZcEUsSUFBWixDQUFmO0FBQ0gsS0FGVSxDQUFYO0FBR0gsR0FuQ0Q7O0FBb0NBNUMsS0FBRyxDQUFDNEcsT0FBSixHQUFjMStCLEVBQUUsQ0FBQ3lkLFFBQUgsQ0FBWTBjLFVBQVosQ0FBdUJyQyxHQUF2QixFQUE0QjRHLE9BQTVCLEVBQXFDLFNBQXJDLEVBQWdELEVBQWhELENBQWQ7QUFFQSxTQUFPNUcsR0FBUDtBQUNILENBL0NNLEM7Ozs7Ozs7Ozs7OztBQ0FQO0FBQUE7QUFBQSxJQUFJb0gsaUJBQUo7O0FBQ0EsSUFBSTtBQUNBQSxtQkFBaUIsR0FBR0MsWUFBcEI7QUFDQSxNQUFJckgsR0FBRyxHQUFHLDJCQUFWO0FBQ0FvSCxtQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEJ0SCxHQUExQixFQUErQkEsR0FBL0I7QUFDQW9ILG1CQUFpQixDQUFDRyxVQUFsQixDQUE2QnZILEdBQTdCO0FBQ0gsQ0FMRCxDQUtFLE9BQU16NEIsQ0FBTixFQUFTO0FBQ1A2L0IsbUJBQWlCLEdBQUc7QUFDaEJJLFNBQUssRUFBUyxFQURFO0FBRWhCRixXQUFPLEVBQU8saUJBQVN4M0MsRUFBVCxFQUFhZ1ksR0FBYixFQUFrQjtBQUFFLGFBQU8sS0FBSzAvQixLQUFMLENBQVcxM0MsRUFBWCxJQUFpQjIzQyxNQUFNLENBQUMzL0IsR0FBRCxDQUE5QjtBQUFzQyxLQUZ4RDtBQUdoQjQvQixXQUFPLEVBQU8saUJBQVM1M0MsRUFBVCxFQUFhO0FBQUUsYUFBTyxLQUFLMDNDLEtBQUwsQ0FBV3ZlLGNBQVgsQ0FBMEJuNUIsRUFBMUIsSUFBZ0MsS0FBSzAzQyxLQUFMLENBQVcxM0MsRUFBWCxDQUFoQyxHQUFpRCxJQUF4RDtBQUErRCxLQUg1RTtBQUloQnkzQyxjQUFVLEVBQUksb0JBQVN6M0MsRUFBVCxFQUFhO0FBQUUsYUFBTyxPQUFPLEtBQUswM0MsS0FBTCxDQUFXMTNDLEVBQVgsQ0FBZDtBQUErQixLQUo1QztBQUtoQmlmLFNBQUssRUFBUyxpQkFBVztBQUFFLGFBQU8sS0FBS3k0QixLQUFMLEdBQWEsRUFBcEI7QUFBeUI7QUFMcEMsR0FBcEI7QUFPSDtBQUVEOzs7Ozs7Ozs7Ozs7O0FBV08sU0FBUzczQyxtQkFBVCxDQUE2QjZuQyxTQUE3QixFQUF3QztBQUMzQyxPQUFLQSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNIO0FBQ0Q7Ozs7Ozs7O0FBT0E3bkMsbUJBQW1CLENBQUM4WSxTQUFwQixDQUE4QnZKLEdBQTlCLEdBQXFDLFVBQVM3UCxHQUFULEVBQWM2aEIsS0FBZCxFQUFxQjtBQUN0RGsyQixtQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEIsS0FBSzlQLFNBQUwsR0FBZSxHQUFmLEdBQW1Cbm9DLEdBQW5CLEdBQXVCLFFBQWpELEVBQTJENmhCLEtBQTNEO0FBQ0FrMkIsbUJBQWlCLENBQUNFLE9BQWxCLENBQTBCLEtBQUs5UCxTQUFMLEdBQWUsR0FBZixHQUFtQm5vQyxHQUFuQixHQUF1QixZQUFqRCxFQUErRHFKLENBQUMsQ0FBQ3doQyxHQUFGLEVBQS9EO0FBQ0gsQ0FIRDtBQUtBOzs7Ozs7O0FBS0F2cUMsbUJBQW1CLENBQUM4WSxTQUFwQixDQUE4QjZDLE1BQTlCLEdBQXVDLFVBQVNqYyxHQUFULEVBQWM7QUFDakQrM0MsbUJBQWlCLENBQUNHLFVBQWxCLENBQTZCLEtBQUsvUCxTQUFMLEdBQWUsR0FBZixHQUFtQm5vQyxHQUFuQixHQUF1QixRQUFwRDtBQUNBKzNDLG1CQUFpQixDQUFDRyxVQUFsQixDQUE2QixLQUFLL1AsU0FBTCxHQUFlLEdBQWYsR0FBbUJub0MsR0FBbkIsR0FBdUIsWUFBcEQ7QUFDSCxDQUhEO0FBS0E7Ozs7Ozs7QUFLQU0sbUJBQW1CLENBQUM4WSxTQUFwQixDQUE4Qi9ZLEdBQTlCLEdBQW9DLFVBQVNMLEdBQVQsRUFBYztBQUM5QyxTQUFPKzNDLGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLbFEsU0FBTCxHQUFlLEdBQWYsR0FBbUJub0MsR0FBbkIsR0FBdUIsUUFBakQsQ0FBUDtBQUNILENBRkQ7QUFJQTs7Ozs7Ozs7QUFNQU0sbUJBQW1CLENBQUM4WSxTQUFwQixDQUE4QjIwQixPQUE5QixHQUF3QyxVQUFTL3RDLEdBQVQsRUFBYztBQUNsRCxTQUFPazRCLFFBQVEsQ0FBQzZmLGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLbFEsU0FBTCxHQUFlLEdBQWYsR0FBbUJub0MsR0FBbkIsR0FBdUIsWUFBakQsQ0FBRCxDQUFmO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7Ozs7O0FBUUFNLG1CQUFtQixDQUFDOFksU0FBcEIsQ0FBOEJrekIsVUFBOUIsR0FBMkMsVUFBU3RzQyxHQUFULEVBQWNDLFlBQWQsRUFBNEI7QUFDbkUsTUFBSSxLQUFLRyxHQUFMLENBQVNKLEdBQVQsQ0FBSixFQUFtQjtBQUNmLFdBQU8sS0FBS0ssR0FBTCxDQUFTTCxHQUFULENBQVA7QUFDSCxHQUZELE1BRU87QUFDSCxTQUFLNlAsR0FBTCxDQUFTN1AsR0FBVCxFQUFjQyxZQUFkO0FBQ0EsV0FBT0EsWUFBUDtBQUNIO0FBQ0osQ0FQRDtBQVNBOzs7Ozs7O0FBS0FLLG1CQUFtQixDQUFDOFksU0FBcEIsQ0FBOEJoWixHQUE5QixHQUFvQyxVQUFTSixHQUFULEVBQWM7QUFDOUMsU0FBTyszQyxpQkFBaUIsQ0FBQ00sT0FBbEIsQ0FBMEIsS0FBS2xRLFNBQUwsR0FBZSxHQUFmLEdBQW1Cbm9DLEdBQW5CLEdBQXVCLFFBQWpELE1BQStELElBQXRFO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7Ozs7O0FBUUFNLG1CQUFtQixDQUFDOFksU0FBcEIsQ0FBOEJrL0IsTUFBOUIsR0FBdUMsVUFBU3Q0QyxHQUFULEVBQWN1NEMsV0FBZCxFQUEyQjtBQUM5RCxNQUFJQyxXQUFXLEdBQUdULGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLbFEsU0FBTCxHQUFlLEdBQWYsR0FBbUJub0MsR0FBbkIsR0FBdUIsWUFBakQsQ0FBbEI7QUFDQSxTQUFRdTRDLFdBQVcsSUFBSUMsV0FBVyxHQUFDLElBQW5DO0FBQ0gsQ0FIRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHTyxJQUFNdk0sVUFBVSw4M0ZBQWhCO0FBd0VBLElBQU1sN0IsZ0JBQWdCLEdBQUc7QUFDNUIsU0FBTyxzQkFEcUI7QUFFNUIsU0FBTyx3QkFGcUI7QUFHNUIsZUFBYSx5QkFIZTtBQUk1QixZQUFVLHFCQUprQjtBQUs1QixZQUFVLHlCQUxrQjtBQU01QixjQUFZLHlCQU5nQjtBQU81QixzQkFBb0Isb0NBUFE7QUFRNUIsZUFBYSwrQkFSZTtBQVM1QixlQUFhLHNDQVRlO0FBVTVCLGVBQWEseUJBVmU7QUFXNUIsYUFBVyxtQkFYaUI7QUFZNUIsY0FBWSxvQkFaZ0I7QUFhNUIsV0FBUyxvQkFibUI7QUFjNUIsV0FBUyxtQkFkbUI7QUFlNUIsWUFBVSx3QkFma0I7QUFnQjVCLFdBQVMsdUJBaEJtQjtBQWlCNUIsWUFBVSx3QkFqQmtCO0FBa0I1QixZQUFVLG9CQWxCa0I7QUFtQjVCLFdBQVMsbUJBbkJtQjtBQW9CNUIsV0FBUyx3QkFwQm1CO0FBcUI1QixVQUFRLGlCQXJCb0I7QUFzQjVCLGNBQVksb0JBdEJnQjtBQXVCNUIsYUFBVyxzQkF2QmlCO0FBd0I1QixjQUFZLGlCQXhCZ0I7QUF5QjVCLGNBQVksc0JBekJnQjtBQTBCNUIsU0FBTyxvQkExQnFCO0FBMkI1QixZQUFVLFlBM0JrQjtBQTRCNUIsVUFBUSxzQkE1Qm9CO0FBNkI1QixjQUFZLDRCQTdCZ0I7QUE4QjVCLFNBQU8scUJBOUJxQjtBQStCNUIsY0FBWSxhQS9CZ0I7QUFnQzVCLFFBQU0saUNBaENzQjtBQWlDNUIsbUJBQWlCLG1CQWpDVztBQWtDNUIsVUFBUSxtQ0FsQ29CO0FBbUM1QixnQkFBYyx5QkFuQ2M7QUFvQzVCLGNBQVksMkJBcENnQjtBQXFDNUIsY0FBWSw4QkFyQ2dCO0FBc0M1QixTQUFPLFlBdENxQjtBQXVDNUIsb0JBQWtCLGtDQXZDVTtBQXdDNUIsaUJBQWUsdUJBeENhO0FBeUM1QixrQkFBZ0Isd0JBekNZO0FBMEM1QixZQUFVLG9CQTFDa0I7QUEyQzVCLFFBQU0sb0NBM0NzQjtBQTRDNUIsU0FBTyxnREE1Q3FCO0FBNkM1QixRQUFNLGlCQTdDc0I7QUE4QzVCLFdBQVMsa0JBOUNtQjtBQStDNUIsWUFBVSxxQkEvQ2tCO0FBZ0Q1QixnQkFBYywwQkFoRGM7QUFpRDVCLFFBQU0sZ0JBakRzQjtBQWtENUIsV0FBUyxVQWxEbUI7QUFtRDVCLGlCQUFlLDJCQW5EYTtBQW9ENUIsWUFBVSxvQkFwRGtCO0FBcUQ1QixRQUFNLGdCQXJEc0I7QUFzRDVCLFdBQVMsb0JBdERtQjtBQXVENUIsZUFBYSxhQXZEZTtBQXdENUIsWUFBVSx1QkF4RGtCO0FBeUQ1QixZQUFVLHFCQXpEa0I7QUEwRDVCLFVBQVEsZ0JBMURvQjtBQTJENUIsY0FBWSxzQkEzRGdCO0FBNEQ1QixVQUFRLFFBNURvQjtBQTZENUIsUUFBTSxpQ0E3RHNCO0FBOEQ1QixTQUFPLDZDQTlEcUI7QUErRDVCLGFBQVcsa0NBL0RpQjtBQWdFNUIsU0FBTyxtQkFoRXFCO0FBaUU1QixZQUFVLFVBakVrQjtBQWtFNUIsVUFBUSwyQkFsRW9CO0FBbUU1QixVQUFRLFFBbkVvQjtBQW9FNUIsa0JBQWdCLGlCQXBFWTtBQXFFNUIsY0FBWSxzQkFyRWdCO0FBc0U1QixTQUFPLGdCQXRFcUI7QUF1RTVCLFdBQVMsb0NBdkVtQjtBQXdFNUIsV0FBUyxtQkF4RW1CO0FBeUU1QixTQUFPLG1CQXpFcUI7QUEwRTVCLFFBQU0sdUJBMUVzQjtBQTJFNUIsV0FBUyxhQTNFbUI7QUE0RTVCLFVBQVEsa0JBNUVvQjtBQTZFNUIsU0FBTyxrQkE3RXFCO0FBOEU1QixZQUFVLHdCQTlFa0I7QUErRTVCLFdBQVMsbUJBL0VtQjtBQWdGNUIsWUFBVSxvQkFoRmtCO0FBaUY1QixTQUFPLGVBakZxQjtBQWtGNUIsYUFBVyxxQkFsRmlCO0FBbUY1QixXQUFTLFNBbkZtQjtBQW9GNUIsYUFBVyxvQkFwRmlCO0FBcUY1QixXQUFTLFNBckZtQjtBQXNGNUIsU0FBTyxrQkF0RnFCO0FBdUY1QixTQUFPLHdCQXZGcUI7QUF3RjVCLGVBQWEsYUF4RmU7QUF5RjVCLFdBQVMsU0F6Rm1CO0FBMEY1QixTQUFPLGlCQTFGcUI7QUEyRjVCLFdBQVMsaUJBM0ZtQjtBQTRGNUIsZ0JBQWMsZ0JBNUZjO0FBNkY1QixVQUFRLDJCQTdGb0I7QUE4RjVCLFVBQVEsOEJBOUZvQjtBQStGNUIsYUFBVyxrQkEvRmlCO0FBZ0c1QixXQUFTLGNBaEdtQjtBQWlHNUIsVUFBUSxrQkFqR29CO0FBa0c1QixXQUFTLG1CQWxHbUI7QUFtRzVCLGVBQWE7QUFuR2UsQ0FBekI7QUFzR0EsSUFBTXdJLFlBQWI7QUFFSSx3QkFBWU4sSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBRUEsU0FBS3E1QixlQUFMLEdBQXVCLENBQUMsVUFBRCxFQUFhLFNBQWIsRUFBd0IsYUFBeEIsRUFDQyxhQURELEVBQ2dCLFVBRGhCLEVBQzRCLGNBRDVCLEVBQzRDLE9BRDVDLEVBQ3FELE9BRHJELENBQXZCLENBSm1CLENBT25CO0FBQ0g7QUFFRDs7Ozs7Ozs7QUFaSjtBQUFBO0FBQUEsaUNBa0JpQkMsU0FsQmpCLEVBa0I0QjtBQUNwQixVQUFJcmdDLE1BQU0sR0FBRyxFQUFiO0FBQ0EsVUFBSThtQixPQUFPLEdBQUcsRUFBZCxDQUZvQixDQUdwQjs7QUFDQSxVQUFJLENBQUMsS0FBS2xtQixJQUFMLENBQVUxWSxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JnQixjQUF4QixFQUFMLEVBQStDO0FBQzNDOzs7O0FBR0E7OztBQUdBLGFBQUssSUFBSWt5QyxRQUFULElBQXFCc0MsU0FBckIsRUFBZ0M7QUFDNUIsY0FBSTcyQixLQUFLLEdBQUc2MkIsU0FBUyxDQUFDdEMsUUFBRCxDQUFyQjs7QUFDQSxjQUFJLEtBQUtxQyxlQUFMLENBQXFCeGtDLE9BQXJCLENBQTZCbWlDLFFBQTdCLE1BQTJDLENBQUMsQ0FBNUMsSUFBaUR2MEIsS0FBSyxLQUFLeGlCLFNBQS9ELEVBQTBFO0FBQ3RFKzJDLG9CQUFRLEdBQUdBLFFBQVEsQ0FBQ2h2QixPQUFULENBQWlCLE9BQWpCLEVBQTBCLEVBQTFCLEVBQ05BLE9BRE0sQ0FDRSxPQURGLEVBQ1csRUFEWCxDQUFYO0FBRUEsZ0JBQUl1eEIsTUFBTSxTQUFWOztBQUNBLGdCQUFJO0FBQ0FBLG9CQUFNLEdBQUdwL0IsWUFBWSxDQUFDcS9CLFVBQWIsQ0FBd0J4QyxRQUF4QixFQUFrQ3YwQixLQUFsQyxDQUFUO0FBQ0gsYUFGRCxDQUVFLGdCQUFNO0FBQ0o4MkIsb0JBQU0sR0FBRztBQUFDLHdCQUFRdkMsUUFBVDtBQUFtQix3QkFBUSxTQUEzQjtBQUFzQyx5QkFBU3YwQixLQUFLLENBQUNoZCxRQUFOO0FBQS9DLGVBQVQ7QUFDSDs7QUFDRCxnQkFBSTh6QyxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNqQnRnQyxvQkFBTSxDQUFDdUcsSUFBUCxDQUFZKzVCLE1BQVo7QUFDSCxhQUZELE1BRU8sSUFBSTkyQixLQUFLLENBQUNpSixXQUFOLEtBQXNCalMsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3hDLE1BQXJDLEVBQTZDO0FBQ2hEb0kscUJBQU8sQ0FBQ3ZnQixJQUFSLENBQWFpRCxLQUFLLENBQUNxVixFQUFOLENBQVMyWixRQUFULENBQWtCN1UsQ0FBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxhQUFPO0FBQUMsc0JBQWMzakIsTUFBZjtBQUF1QixtQkFBVzhtQjtBQUFsQyxPQUFQO0FBQ0g7QUFqREw7QUFBQTs7QUFtREk7Ozs7OztBQW5ESiwrQkF5RHNCaVgsUUF6RHRCLEVBeURnQ3YwQixLQXpEaEMsRUF5RHVDZzNCLFVBekR2QyxFQXlEbUQ7QUFDM0MsVUFBSWgzQixLQUFLLEtBQUt4aUIsU0FBZCxFQUF5QjtBQUNyQixlQUFPO0FBQUMsa0JBQVErMkMsUUFBVDtBQUNILGtCQUFRLFNBREw7QUFFSCxtQkFBUztBQUZOLFNBQVA7QUFJSDs7QUFDRCxjQUFRQSxRQUFSO0FBQ0ksYUFBSyxXQUFMO0FBQ0ksaUJBQU87QUFDSHgxQyxnQkFBSSxFQUFFdzFDLFFBREg7QUFFSGoxQyxnQkFBSSxFQUFFLFdBRkg7QUFHSDBnQixpQkFBSyxFQUFFO0FBSEosV0FBUDtBQUZSOztBQVFBLGNBQVFBLEtBQUssQ0FBQ2lKLFdBQWQ7QUFDSSxhQUFLalMsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3FZLElBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUXdFLFFBQVQ7QUFDSCxvQkFBUSxVQURMO0FBRUgscUJBQ0t2MEIsS0FBSyxDQUFDaTNCLFNBQU4sQ0FBZ0JDLFdBQWhCLEtBQWdDMTVDLFNBQWhDLEdBQ0csa0JBQWdCd2lCLEtBQUssQ0FBQ2kzQixTQUFOLENBQWdCQyxXQUFoQixDQUE0Qmh5QixJQUE1QixDQUFpQyxJQUFqQyxDQURuQixHQUVHO0FBTEwsV0FBUDs7QUFPSixhQUFLbE8sRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3hDLE1BQWhCO0FBQXdCLGlCQUFPLElBQVA7O0FBQ3hCLGFBQUtsZSxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXbUMsR0FBaEI7QUFDSSxjQUFJbWQsVUFBVSxJQUFJaDNCLEtBQUssQ0FBQ21hLENBQU4sQ0FBUWpxQixNQUFSLElBQWtCLEVBQXBDLEVBQXdDO0FBQ3BDLG1CQUFPO0FBQUMsc0JBQVFxa0MsUUFBVDtBQUNILHNCQUFRLFFBREw7QUFFSCx1QkFBU3YwQixLQUFLLENBQUM4WSxFQUFOLEdBQVdxQjtBQUZqQixhQUFQO0FBSUgsV0FMRCxNQUtPO0FBQ0gsbUJBQU87QUFBQyxzQkFBUW9hLFFBQVQ7QUFDSCxzQkFBUSxRQURMO0FBRUgsdUJBQVMsTUFBSXYwQixLQUFLLENBQUNtM0IsU0FBTixFQUFKLEdBQXNCO0FBRjVCLGFBQVA7QUFJSDs7QUFDTCxhQUFLbmdDLEVBQUUsQ0FBQzBnQixPQUFILENBQVd1SixJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVFzVCxRQUFUO0FBQ0gsb0JBQVEsTUFETDtBQUVILHFCQUFTO0FBRk4sV0FBUDs7QUFJSixhQUFLdjlCLEVBQUUsQ0FBQzBnQixPQUFILENBQVcwZixJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVE3QyxRQUFUO0FBQ0gsb0JBQVEsU0FETDtBQUVILHFCQUFTdjBCLEtBQUssQ0FBQzhZLEVBQU4sR0FBV3FCO0FBRmpCLFdBQVA7O0FBSUosYUFBS25qQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXMmYsS0FBaEI7QUFDSSxpQkFBTztBQUFDLG9CQUFROUMsUUFBVDtBQUNILG9CQUFRLFVBQVV2MEIsS0FBSyxDQUFDczNCLE1BQWhCLEdBQXlCLFNBQXpCLEdBQW9DLE9BRHpDO0FBRUgscUJBQVN0M0IsS0FBSyxDQUFDOFksRUFBTixHQUFXcUI7QUFGakIsV0FBUDs7QUFJSixhQUFLbmpCLEVBQUUsQ0FBQzBnQixPQUFILENBQVc2RSxJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVFnWSxRQUFUO0FBQ0gsb0JBQVEsU0FETDtBQUVILHFCQUFTdjBCLEtBQUssQ0FBQzhZLEVBQU4sR0FBV3FCO0FBRmpCLFdBQVA7O0FBSUosYUFBS25qQixFQUFFLENBQUMwZ0IsT0FBSCxDQUFXNmYsTUFBaEI7QUFDSSxpQkFBTztBQUFDLG9CQUFRaEQsUUFBVDtBQUNILG9CQUFRLE9BREw7QUFFSCxxQkFBU3YwQixLQUFLLENBQUM4WSxFQUFOLEdBQVdxQjtBQUZqQixXQUFQOztBQUlKLGFBQUtuakIsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzRhLEtBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUWlDLFFBQVQ7QUFDSCxvQkFBUSxPQURMO0FBRUgscUJBQVN2MEIsS0FBSyxDQUFDOFksRUFBTixHQUFXcUI7QUFGakIsV0FBUDs7QUFJSixhQUFLbmpCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdrYSxJQUFoQjtBQUNJLGNBQUk1eEIsS0FBSyxDQUFDbWEsQ0FBTixDQUFRanFCLE1BQVIsSUFBa0IsRUFBdEIsRUFBMEI7QUFDdEIsbUJBQU87QUFBQyxzQkFBUXFrQyxRQUFUO0FBQ0gsc0JBQVEsTUFETDtBQUVILHVCQUFTdjBCLEtBQUssQ0FBQzhZLEVBQU4sR0FBV3FCLENBRmpCO0FBR0gsNkJBQWVuYTtBQUhaLGFBQVA7QUFLSCxXQU5ELE1BTU87QUFDSCxtQkFBTztBQUFDLHNCQUFRdTBCLFFBQVQ7QUFDSCxzQkFBUSxNQURMO0FBRUgsdUJBQVMsVUFBUXYwQixLQUFLLENBQUNtYSxDQUFOLENBQVFqcUIsTUFBaEIsR0FBdUIsZ0JBRjdCO0FBR0gsNkJBQWU4UDtBQUhaLGFBQVA7QUFLSDs7QUFDTCxhQUFLaEosRUFBRSxDQUFDMGdCLE9BQUgsQ0FBVzJFLElBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUWtZLFFBQVQ7QUFDSCxvQkFBUSxZQURMO0FBRUgscUJBQVN2MEIsS0FBSyxDQUFDOFksRUFBTixHQUFXcUI7QUFGakIsV0FBUDs7QUFJSixhQUFLcWQsTUFBTDtBQUNJLGlCQUFPO0FBQUMsb0JBQVFqRCxRQUFUO0FBQ0gsb0JBQVF2MEIsS0FBSyxHQUFHLENBQVIsS0FBYyxDQUFkLEdBQWtCLFNBQWxCLEdBQThCLE9BRG5DO0FBRUgscUJBQVNBO0FBRk4sV0FBUDs7QUFJSixhQUFLdTJCLE1BQUw7QUFDSSxpQkFBTztBQUFDLG9CQUFRaEMsUUFBVDtBQUNILG9CQUFRLFFBREw7QUFFSCxxQkFBU3YwQjtBQUZOLFdBQVA7O0FBSUosYUFBS21jLE9BQUw7QUFDSSxpQkFBTztBQUFDLG9CQUFRb1ksUUFBVDtBQUNILG9CQUFRLFNBREw7QUFFSCxxQkFBVXYwQixLQUFLLEdBQUcsTUFBSCxHQUFXO0FBRnZCLFdBQVA7O0FBSUo7QUFDSSxpQkFBTztBQUFDLG9CQUFRdTBCLFFBQVQ7QUFDSCxvQkFBUXYwQixLQUFLLENBQUMyYixPQUFOLEtBQWtCbitCLFNBQWxCLEdBQThCd2lCLEtBQTlCLEdBQXNDQSxLQUFLLENBQUMyYixPQURqRDtBQUVILHFCQUFTM2IsS0FBSyxDQUFDOFksRUFBTixLQUFhdDdCLFNBQWIsR0FBeUJ3aUIsS0FBekIsR0FBaUNBLEtBQUssQ0FBQzhZLEVBQU4sR0FBV3FCO0FBRmxELFdBQVA7QUF2RlI7QUE0Rkg7QUFwS0w7O0FBQUE7QUFBQSxJLENBeUtBLHVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2VkE7Ozs7Ozs7Ozs7QUFVTyxTQUFTc2QsU0FBVCxDQUFtQkMsR0FBbkIsRUFBd0JDLFFBQXhCLEVBQWtDQyxRQUFsQyxFQUE0QztBQUMvQyxNQUFNMW5DLE1BQU0sR0FBR3duQyxHQUFHLENBQUN4bkMsTUFBbkI7QUFDQSxNQUFNMm5DLFVBQVUsR0FBR0gsR0FBRyxDQUFDQyxRQUFELENBQXRCOztBQUVBLE1BQUlBLFFBQVEsS0FBS0MsUUFBYixJQUF5QkQsUUFBUSxHQUFHem5DLE1BQXBDLElBQThDMG5DLFFBQVEsR0FBRzFuQyxNQUE3RCxFQUFxRTtBQUNqRSxXQUFPd25DLEdBQVA7QUFDSDs7QUFFRCxTQUFPQSxHQUFHLENBQUNoTyxNQUFKLENBQVcsVUFBQ29PLEdBQUQsRUFBTXBHLElBQU4sRUFBWTU4QixLQUFaLEVBQXNCO0FBQ3BDLFFBQUlBLEtBQUssS0FBSzZpQyxRQUFkLEVBQXdCO0FBQUMsYUFBT0csR0FBUDtBQUFZOztBQUNyQyxRQUFJaGpDLEtBQUssS0FBSzhpQyxRQUFkLEVBQXdCO0FBQUMsYUFBT0QsUUFBUSxHQUFHQyxRQUFYLGdDQUEwQkUsR0FBMUIsSUFBK0JwRyxJQUEvQixFQUFxQ21HLFVBQXJDLGtDQUF1REMsR0FBdkQsSUFBNERELFVBQTVELEVBQXdFbkcsSUFBeEUsRUFBUDtBQUFzRjs7QUFDL0csd0NBQVdvRyxHQUFYLElBQWdCcEcsSUFBaEI7QUFDSCxHQUpNLEVBSUosRUFKSSxDQUFQO0FBS0g7QUFFRDs7Ozs7OztBQU1BLFNBQVNxRyxhQUFULENBQXVCQyxNQUF2QixFQUErQkMsUUFBL0IsRUFBeUM7QUFDckMsU0FBT0EsUUFBUSxDQUFDN2xDLE9BQVQsQ0FBaUI0bEMsTUFBakIsSUFBMkIsQ0FBQyxDQUFuQztBQUNIO0FBRUQ7Ozs7Ozs7Ozs7QUFRQSxTQUFTRSxXQUFULENBQXFCaFQsS0FBckIsRUFBNEI7QUFDeEIsTUFBSWlULENBQUMsR0FBR2pULEtBQUssQ0FBQ2tULE1BQU4sRUFBUjs7QUFDQSxPQUFJLElBQUl6NEIsQ0FBQyxHQUFDLENBQVYsRUFBYUEsQ0FBQyxHQUFDdzRCLENBQUMsQ0FBQ2pvQyxNQUFqQixFQUF5QixFQUFFeVAsQ0FBM0IsRUFBOEI7QUFDMUIsU0FBSSxJQUFJMDRCLENBQUMsR0FBQzE0QixDQUFDLEdBQUMsQ0FBWixFQUFlMDRCLENBQUMsR0FBQ0YsQ0FBQyxDQUFDam9DLE1BQW5CLEVBQTJCLEVBQUVtb0MsQ0FBN0IsRUFBZ0M7QUFDNUIsVUFBR0YsQ0FBQyxDQUFDeDRCLENBQUQsQ0FBRCxLQUFTdzRCLENBQUMsQ0FBQ0UsQ0FBRCxDQUFiLEVBQWtCO0FBQUNGLFNBQUMsQ0FBQ3hMLE1BQUYsQ0FBUzBMLENBQUMsRUFBVixFQUFjLENBQWQ7QUFBa0I7QUFDeEM7QUFDSjs7QUFFRCxTQUFPRixDQUFQO0FBQ0g7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBU0csV0FBVCxDQUFxQnBULEtBQXJCLEVBQTRCcVQsUUFBNUIsRUFBc0NDLFdBQXRDLEVBQW1EO0FBQy9DLE1BQUlDLFNBQVMsR0FBR3ZULEtBQUssQ0FBQ3RkLE1BQU4sQ0FBYSxVQUFTOHBCLElBQVQsRUFBZTtBQUN4QyxXQUFPOEcsV0FBVyxDQUFDcG1DLE9BQVosQ0FBb0JzL0IsSUFBcEIsTUFBOEIsQ0FBQyxDQUF0QztBQUNILEdBRmUsQ0FBaEI7QUFHQSxTQUFPd0csV0FBVyxDQUFDTyxTQUFTLENBQUNMLE1BQVYsQ0FBaUJHLFFBQWpCLENBQUQsQ0FBbEI7QUFDSDtBQUVEOzs7Ozs7O0FBS0EsU0FBU0csU0FBVCxDQUFtQmhiLElBQW5CLEVBQXlCO0FBQ3JCO0FBQ0EsTUFBSWliLEtBQUssR0FBR2piLElBQUksQ0FBQ2tiLFFBQUwsSUFBaUIsQ0FBakIsR0FBcUI1OUIsUUFBUSxDQUFDNjlCLGNBQVQsQ0FBd0JuYixJQUFJLENBQUNvYixTQUE3QixDQUFyQixHQUErRHBiLElBQUksQ0FBQ2diLFNBQUwsQ0FBZSxLQUFmLENBQTNFLENBRnFCLENBSXJCOztBQUNBLE1BQUlLLEtBQUssR0FBR3JiLElBQUksQ0FBQ3NiLFVBQWpCOztBQUNBLFNBQU1ELEtBQU4sRUFBYTtBQUNUSixTQUFLLENBQUN2eUIsV0FBTixDQUFrQnN5QixTQUFTLENBQUNLLEtBQUQsQ0FBM0I7QUFDQUEsU0FBSyxHQUFHQSxLQUFLLENBQUNFLFdBQWQ7QUFDSDs7QUFFRCxTQUFPTixLQUFQO0FBQ0g7QUFFRDs7Ozs7Ozs7QUFNTyxTQUFTTyxNQUFULENBQWdCcmYsR0FBaEIsRUFBcUI7QUFDeEIsU0FBT0EsR0FBRyxDQUFDdFUsT0FBSixDQUFZLFVBQVosRUFBd0IsTUFBeEIsQ0FBUDtBQUNIO0FBRUQ7Ozs7OztBQUtPLFNBQVN0RSxJQUFULENBQWM0WSxHQUFkLEVBQW1CO0FBQ3RCLFNBQU9BLEdBQUcsQ0FBQ3RVLE9BQUosQ0FBWSxLQUFaLEVBQW1CLEdBQW5CLEVBQXdCcFosV0FBeEIsRUFBUDtBQUNIO0FBRUQ7Ozs7OztBQUtPLFNBQVN5SixVQUFULENBQW9CdWpDLENBQXBCLEVBQXVCO0FBQzFCLE1BQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQ3ZCLFdBQU8sRUFBUDtBQUNIOztBQUNELFNBQU9BLENBQUMsQ0FBQzU1QixNQUFGLENBQVMsQ0FBVCxFQUFZeUksV0FBWixLQUE0Qm14QixDQUFDLENBQUMzbkMsS0FBRixDQUFRLENBQVIsQ0FBbkM7QUFDSDtBQUVEOzs7Ozs7OztBQU9BLFNBQVM0bkMsYUFBVCxDQUF1QjFwQyxHQUF2QixFQUEyQkgsR0FBM0IsRUFBZ0M7QUFDNUIsU0FBT0QsSUFBSSxDQUFDK3BDLEtBQUwsQ0FBVy9wQyxJQUFJLENBQUNncUMsTUFBTCxNQUFlL3BDLEdBQUcsR0FBQ0csR0FBSixHQUFRLENBQXZCLElBQTBCQSxHQUFyQyxDQUFQO0FBQ0g7QUFFRDs7Ozs7Ozs7O0FBT08sU0FBU2dNLFVBQVQsQ0FBb0JtZSxHQUFwQixFQUF5QjtBQUM1QixTQUFPQSxHQUFHLENBQUN0VSxPQUFKLENBQVksSUFBWixFQUFrQixPQUFsQixFQUNGQSxPQURFLENBQ00sSUFETixFQUNZLE1BRFosRUFFRkEsT0FGRSxDQUVNLElBRk4sRUFFWSxNQUZaLEVBR0ZBLE9BSEUsQ0FHTSxJQUhOLEVBR1ksUUFIWixFQUlGQSxPQUpFLENBSU0sSUFKTixFQUlZLFFBSlosQ0FBUDtBQUtIO0FBRUQ7Ozs7QUFHQSxJQUFJLE9BQU9tSCxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDQSxTQUFPLENBQUM2c0IsWUFBUixDQUFxQmhpQyxTQUFyQixDQUErQmlpQyxPQUEvQixHQUF5QyxZQUFXO0FBQ2hELFFBQUlDLE9BQU8sR0FBRyxLQUFLQyxVQUFMLEVBQWQ7QUFDQSxRQUFJanRDLEtBQUssR0FBR2d0QyxPQUFPLENBQUNFLFNBQVIsR0FBb0IsQ0FBaEM7QUFBQSxRQUNJLzdCLE1BQU0sR0FBRzY3QixPQUFPLENBQUNHLFVBRHJCO0FBRUEsUUFBSUMsTUFBTSxHQUFHLEtBQUtDLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBYjtBQUNBLFFBQUkzRyxDQUFDLEdBQUcsQ0FBUjtBQUFBLFFBQVdwYSxDQUFDLEdBQUcsQ0FBZjtBQUFBLFFBQ0lnaEIsZ0JBQWdCLEdBQUduOEIsTUFBTSxHQUFDaThCLE1BQU0sQ0FBQzNwQyxNQURyQzs7QUFFQSxTQUFLLElBQUl5UCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHazZCLE1BQU0sQ0FBQzNwQyxNQUEzQixFQUFtQ3lQLENBQUMsRUFBcEMsRUFBdUM7QUFDbkM7QUFDQSxVQUFJNmYsS0FBSyxHQUFHcWEsTUFBTSxDQUFDbDZCLENBQUQsQ0FBbEI7QUFDQSxVQUFJMGQsVUFBVSxHQUFHbUMsS0FBSyxDQUFDd2Esc0JBQU4sRUFBakI7O0FBQ0EsVUFBSXI2QixDQUFDLElBQUksQ0FBVCxFQUFZO0FBQ1JvWixTQUFDLEdBQUcsQ0FBSjtBQUNILE9BRkQsTUFFTztBQUNIQSxTQUFDLEdBQUcsQ0FBQ3NFLFVBQVUsQ0FBQ3RFLENBQVosR0FBY3FnQixhQUFhLENBQUMsRUFBRCxFQUFLM3NDLEtBQUwsQ0FBL0I7QUFDSDs7QUFDRCt5QixXQUFLLENBQUN5YSxNQUFOLENBQWFsaEIsQ0FBYixFQUNhLENBQUNzRSxVQUFVLENBQUM4VixDQUFaLEdBQWNBLENBRDNCO0FBRUFBLE9BQUMsR0FBR0EsQ0FBQyxHQUFHaUcsYUFBYSxDQUFDLENBQUQsRUFBSVcsZ0JBQUosQ0FBckI7QUFDSDtBQUNKLEdBcEJEO0FBcUJIO0FBRUQ7Ozs7OztBQUlBLFNBQVNHLFlBQVQsQ0FBc0I1dEIsTUFBdEIsRUFBOEJ0VyxNQUE5QixFQUFzQ21rQyxTQUF0QyxFQUFpRDtBQUM3QyxPQUFLLElBQUl4NkIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJNLE1BQU0sQ0FBQ3BjLE1BQTNCLEVBQW1DeVAsQ0FBQyxFQUFwQyxFQUF3QztBQUNwQyxRQUFJMkwsT0FBTyxHQUFHZ0IsTUFBTSxDQUFDM00sQ0FBRCxDQUFwQjs7QUFDQSxRQUFJdzZCLFNBQVMsQ0FBQzd1QixPQUFELENBQWIsRUFBd0I7QUFDcEJnQixZQUFNLENBQUNxZ0IsTUFBUCxDQUFjaHRCLENBQWQsRUFBaUIsQ0FBakI7QUFDQTNKLFlBQU0sQ0FBQytHLElBQVAsQ0FBWXVPLE9BQVo7QUFDQTNMLE9BQUM7QUFDSjtBQUNKO0FBQ0o7O0FBR00sU0FBU3NtQixpQkFBVCxHQUE2QjtBQUNoQyxPQUFLLElBQUl0bUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRCLFNBQVMsQ0FBQ3JSLE1BQTlCLEVBQXNDeVAsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxRQUFJNEIsU0FBUyxDQUFDNUIsQ0FBRCxDQUFULElBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLGFBQU80QixTQUFTLENBQUM1QixDQUFELENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxTQUFPbmlCLFNBQVA7QUFDSDtBQUVEOzs7Ozs7Ozs7OztBQVVBLFNBQVM0OEMsV0FBVCxDQUFxQkMsR0FBckIsRUFBeUI7QUFDckIsU0FBUUEsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVcyRSxJQUEzQixJQUNGZ2UsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVdrYSxJQUR4QixJQUVGeUksR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVc0YSxLQUZ4QixJQUdGK0gsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVcwZixJQUh4QixJQUlGaUQsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVc2RSxJQUp4QixJQUtGOGQsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVc2ZixNQUx4QixJQU1GOEMsR0FBRyxZQUFZcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQU54QixJQU9Gd2dCLEdBQUcsWUFBWXJqQyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXNGlCLEdBUC9CLENBRHFCLENBU3JCO0FBQ0E7QUFDSDs7QUFFRCxTQUFTQyxTQUFULENBQW1CRixHQUFuQixFQUF1QjtBQUNuQixTQUFPQSxHQUFHLFlBQVk1M0IsTUFBZixJQUF5QixjQUFjNDNCLEdBQTlDO0FBQ0g7O0FBRUQsSUFBTUcsdUJBQXVCLEdBQUcsdUJBQWhDO0FBRUE7Ozs7Ozs7OztBQVFPLFNBQVMxNUMsV0FBVCxDQUFxQnVXLElBQXJCLEVBQTJCbFEsTUFBM0IsRUFBbUM7QUFDdEMsTUFBSUEsTUFBTSxLQUFLLEVBQVgsSUFBaUJBLE1BQU0sSUFBSSxJQUEvQixFQUFxQztBQUNqQyxXQUFPa1EsSUFBUDtBQUNIOztBQUNELE1BQU1vakMsS0FBSyxHQUFHcGpDLElBQUksQ0FBQ29JLEtBQUwsQ0FBVys2Qix1QkFBWCxDQUFkOztBQUNBLE9BQUssSUFBSTc2QixDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUc4NkIsS0FBSyxDQUFDdnFDLE1BQXhCLEVBQWdDeVAsQ0FBQyxJQUFFLENBQW5DLEVBQXNDO0FBQ2xDOzs7O0FBSUEsUUFBSTg2QixLQUFLLENBQUM5NkIsQ0FBRCxDQUFMLEtBQWF4WSxNQUFqQixFQUF5QjtBQUNyQixVQUFJcWIsSUFBSSxHQUFHaTRCLEtBQUssQ0FBQzk2QixDQUFDLEdBQUMsQ0FBSCxDQUFoQjs7QUFDQSxVQUFJNkMsSUFBSSxJQUFJQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEtBQVksSUFBeEIsRUFBOEI7QUFDMUJBLFlBQUksR0FBR0EsSUFBSSxDQUFDaFIsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUNELFVBQUltTyxDQUFDLEtBQUs4NkIsS0FBSyxDQUFDdnFDLE1BQU4sR0FBZSxDQUFyQixJQUEwQnNTLElBQTFCLElBQWtDQSxJQUFJLENBQUNoUixLQUFMLENBQVcsQ0FBQyxDQUFaLE1BQW1CLElBQXpELEVBQStEO0FBQzNEZ1IsWUFBSSxHQUFHQSxJQUFJLENBQUNoUixLQUFMLENBQVcsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUFQO0FBQ0g7O0FBQ0QsYUFBT2dSLElBQVA7QUFDSDtBQUNKOztBQUNELFNBQU8sSUFBUDtBQUNIO0FBRUQ7Ozs7Ozs7O0FBT0EsU0FBU2s0QixjQUFULENBQXdCTCxHQUF4QixFQUE0QjtBQUN4QixNQUFJTSxDQUFKO0FBQ0EsTUFBSUMsR0FBSjtBQUNBLE1BQUlqN0IsQ0FBSjtBQUNBLE1BQUkrM0IsR0FBSixDQUp3QixDQUt4Qjs7QUFDQSxNQUFJMEMsV0FBVyxDQUFDQyxHQUFELENBQWYsRUFBcUI7QUFDakI7QUFDQSxXQUFPQSxHQUFQO0FBQ0gsR0FIRCxNQUdPLElBQUk1M0IsTUFBTSxDQUFDbEwsU0FBUCxDQUFpQnZVLFFBQWpCLENBQTBCNndDLElBQTFCLENBQStCd0csR0FBL0IsTUFBd0MsZ0JBQTVDLEVBQThEO0FBQ2pFO0FBQ0EzQyxPQUFHLEdBQUcsRUFBTjs7QUFDQSxTQUFLLzNCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzA2QixHQUFHLENBQUNucUMsTUFBcEIsRUFBNEIsRUFBRXlQLENBQTlCLEVBQWlDO0FBQzdCO0FBQ0EsVUFBSWs3QixNQUFNLEdBQUdSLEdBQUcsQ0FBQzE2QixDQUFELENBQWhCOztBQUNBLFVBQUcsQ0FBQ3k2QixXQUFXLENBQUNTLE1BQUQsQ0FBZixFQUF3QjtBQUNwQm5ELFdBQUcsQ0FBQzM2QixJQUFKLENBQVMyOUIsY0FBYyxDQUFDRyxNQUFELENBQXZCO0FBQ0gsT0FGRCxNQUVLO0FBQ0RuRCxXQUFHLENBQUMzNkIsSUFBSixDQUFTODlCLE1BQVQ7QUFDSDtBQUNKOztBQUNELFdBQU8sSUFBSTdqQyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXa2EsSUFBZixDQUFvQjhGLEdBQXBCLENBQVA7QUFDSCxHQWJNLE1BYUEsSUFBSTJDLEdBQUcsS0FBSyxJQUFaLEVBQWtCO0FBQUM7QUFDdEIsV0FBT3JqQyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXdUosSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxHQUZNLE1BRUEsSUFBSSxRQUFPbVosR0FBUCxNQUFlLFFBQW5CLEVBQTZCO0FBQ2hDLFFBQUcsQ0FBQ0QsV0FBVyxDQUFDQyxHQUFELENBQWYsRUFBcUI7QUFDakI7QUFDQU8sU0FBRyxHQUFHLEVBQU4sQ0FGaUIsQ0FFUjs7QUFDVCxXQUFLRCxDQUFMLElBQVVOLEdBQVYsRUFBZTtBQUNYO0FBQ0FPLFdBQUcsQ0FBQzc5QixJQUFKLENBQVMyOUIsY0FBYyxDQUFDQyxDQUFELENBQXZCLEVBRlcsQ0FHWDs7QUFDQUMsV0FBRyxDQUFDNzlCLElBQUosQ0FBUzI5QixjQUFjLENBQUNMLEdBQUcsQ0FBQ00sQ0FBRCxDQUFKLENBQXZCO0FBQ0gsT0FSZ0IsQ0FTakI7OztBQUNBLGFBQU8sSUFBSTNqQyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXMkUsSUFBZixDQUFvQnVlLEdBQXBCLENBQVA7QUFDSCxLQVhELE1BV0s7QUFDRCxhQUFPUCxHQUFQO0FBQ0g7QUFDSixHQWZNLE1BZUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDaEMsV0FBTyxJQUFJcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUFmLENBQW1Cd2dCLEdBQW5CLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDaEMsV0FBT3JqQyxFQUFFLENBQUMwZ0IsT0FBSCxDQUFXb2pCLEtBQVgsQ0FBaUJULEdBQWpCLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDakMsV0FBTyxJQUFJcmpDLEVBQUUsQ0FBQzBnQixPQUFILENBQVcwZixJQUFmLENBQW9CaUQsR0FBcEIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFHLE9BQU9BLEdBQVAsS0FBZSxVQUFsQixFQUE4QjtBQUNqQyxXQUFPLElBQUlyakMsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV21DLEdBQWYsQ0FBbUJ3Z0IsR0FBRyxDQUFDdDdDLElBQXZCLENBQVA7QUFDSDtBQUNKOztBQUdNLFNBQVN5WixjQUFULEdBQTBCO0FBQzdCLE1BQU11aUMsS0FBSyxHQUFHLElBQUk5UixJQUFKLEVBQWQ7QUFDQSxNQUFJK1IsQ0FBQyxHQUFHMXJDLElBQUksQ0FBQytwQyxLQUFMLENBQVcwQixLQUFLLENBQUNFLFFBQU4sS0FBaUIsRUFBNUIsQ0FBUjtBQUNBLE1BQUlDLENBQUMsR0FBR0gsS0FBSyxDQUFDSSxVQUFOLEVBQVIsQ0FINkIsQ0FJN0I7O0FBQ0EsTUFBSUQsQ0FBQyxHQUFHLEVBQVIsRUFBWTtBQUFDQSxLQUFDLEdBQUcsTUFBTUEsQ0FBVjtBQUFhLEdBTEcsQ0FNN0I7OztBQUNBLE1BQUlFLENBQUMsR0FBRyxJQUFSOztBQUNBLE1BQUlMLEtBQUssQ0FBQ0UsUUFBTixNQUFrQixFQUF0QixFQUEwQjtBQUN0QkcsS0FBQyxHQUFHLElBQUo7QUFDSDs7QUFDRCxtQkFBVUosQ0FBVixjQUFlRSxDQUFmLFNBQW1CRSxDQUFuQjtBQUNIO0FBRU0sSUFBTUMsS0FBSyxHQUFHcmtDLEVBQUUsQ0FBQzBnQixPQUFILENBQVc2RSxJQUF6QjtBQUNBLElBQU0rZSxNQUFNLEdBQUd0a0MsRUFBRSxDQUFDMGdCLE9BQUgsQ0FBV3VKLElBQVgsQ0FBZ0JDLEtBQS9CO0FBQ0EsSUFBTVQsS0FBSyxHQUFHenBCLEVBQUUsQ0FBQzBnQixPQUFILENBQVdtQyxHQUF6QjtBQUNBLElBQU0waEIsT0FBTyxHQUFHdmtDLEVBQUUsQ0FBQzBnQixPQUFILENBQVc0YSxLQUEzQjtBQUNBLElBQU1rSixlQUFlLEdBQUd4a0MsRUFBRSxDQUFDeWQsUUFBSCxDQUFZZ25CLHFCQUFwQzttQkFFMkN6a0MsRUFBRSxDQUFDeWQsUTtJQUF0Q21NLE0sZ0JBQUFBLE07SUFBUThhLGUsZ0JBQUFBLGU7SUFBaUJDLEssZ0JBQUFBLEs7O2dCQUMwQjNrQyxFQUFFLENBQUNzOEIsSztJQUF0RHNJLFEsYUFBQUEsUTtJQUFVQyxrQixhQUFBQSxrQjtJQUFvQkMsZ0IsYUFBQUEsZ0I7O2tCQUN1QzlrQyxFQUFFLENBQUMwZ0IsTztJQUF4RXFrQixVLGVBQUFBLFM7SUFBV0MsVSxlQUFBQSxVO0lBQVlDLFEsZUFBQUEsUTtJQUFVQyxVLGVBQUFBLFU7SUFBWS9MLFcsZUFBQUEsVztJQUFhZ00sTSxlQUFBQSxNOztjQUNqQ25sQyxFQUFFLENBQUNrRCxHO0lBQTVCQyxTLFdBQUFBLFM7SUFBV3llLFMsV0FBQUEsUzs7a0JBQ1U1aEIsRUFBRSxDQUFDb2xDLE87SUFBeEJDLE8sZUFBQUEsTztJQUFTQyxPLGVBQUFBLE87O0FBQ2pCLElBQU1DLGNBQWMsR0FBR1osS0FBdkIsQzs7Ozs7Ozs7Ozs7QUMxVlAsc0Q7Ozs7Ozs7Ozs7O0FDQUEsb0Q7Ozs7Ozs7Ozs7O0FDQUEsc0QiLCJmaWxlIjoiYmxvY2tweS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIkZpbGVQb25kXCIpLCByZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJibG9ja3B5XCIsIFtcIkZpbGVQb25kXCIsIFwialF1ZXJ5XCIsIFwia29cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYmxvY2tweVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkZpbGVQb25kXCIpLCByZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImJsb2NrcHlcIl0gPSBmYWN0b3J5KHJvb3RbXCJGaWxlUG9uZFwiXSwgcm9vdFtcImpRdWVyeVwiXSwgcm9vdFtcImtvXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2ZpbGVwb25kX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfa25vY2tvdXRfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2Jsb2NrcHkuanNcIik7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhcnRpbmcgcG9pbnQgb2YgdGhlIEJsb2NrUHkgYXBwbGljYXRpb24sIGNvbnRhaW5pbmcgdGhlIG1haW5cbiAqIEJsb2NrUHkgY2xhc3MuXG4gKi9cbmltcG9ydCBcIi4vY3NzL2Jsb2NrcHkuY3NzXCI7XG5pbXBvcnQgXCIuL2Nzcy9ib290c3RyYXBfcmV0aGVtZS5jc3NcIjtcbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcbmltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgaW1hZ2VNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9pbWFnZVwiO1xuaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyB3ZWFrcmVmTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvd2Vha3JlZlwiO1xuLy9pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIG1hdHBsb3RsaWJNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9tYXRwbG90bGliMlwiO1xuaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwic3RvcmFnZS5qc1wiO1xuaW1wb3J0IHtFZGl0b3JzRW51bX0gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7RGlzcGxheU1vZGVzfSBmcm9tIFwiZWRpdG9yL3B5dGhvbi5qc1wiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcInNlcnZlci5qc1wiO1xuaW1wb3J0IHttYWtlSW50ZXJmYWNlLCBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zLCBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9IGZyb20gXCJpbnRlcmZhY2UuanNcIjtcbmltcG9ydCB7RWRpdG9yc30gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7XG4gICAgQmxvY2tQeUZpbGVTeXN0ZW0sXG4gICAgbG9hZENvbmNhdGVuYXRlZEZpbGUsXG4gICAgbWFrZU1vZGVsRmlsZSxcbiAgICBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZSxcbiAgICBVTkRFTEVUQUJMRV9GSUxFUyxcbiAgICBVTlJFTkFNQUJMRV9GSUxFU1xufSBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0IHt1cGxvYWRGaWxlLCBkb3dubG9hZEZpbGV9IGZyb20gXCIuL2VkaXRvci9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7QmxvY2tQeUVuZ2luZX0gZnJvbSBcImVuZ2luZS5qc1wiO1xuaW1wb3J0IHtBU1RfREVTQ1JJUFRJT05TLCBCbG9ja1B5VHJhY2V9IGZyb20gXCIuL3RyYWNlXCI7XG5pbXBvcnQge0Jsb2NrUHlDb25zb2xlfSBmcm9tIFwiLi9jb25zb2xlXCI7XG5pbXBvcnQge0Jsb2NrUHlGZWVkYmFja30gZnJvbSBcImZlZWRiYWNrLmpzXCI7XG5pbXBvcnQge0Jsb2NrUHlTZXJ2ZXJ9IGZyb20gXCIuL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5RGlhbG9nfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7QXNzaWdtZW50VHlwZSwgbG9hZEFzc2lnbm1lbnRTZXR0aW5ncywgbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuaW1wb3J0IHtCbG9ja1B5Q29yZ2lzLCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMsIF9JTVBPUlRFRF9EQVRBU0VUU30gZnJvbSBcIi4vY29yZ2lzXCI7XG5pbXBvcnQge0Jsb2NrUHlIaXN0b3J5fSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge2NhcGl0YWxpemUsIGV4dHJhY3RQYXJ0LCBnZXRDdXJyZW50VGltZX0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1NhbXBsZVN1Ym1pc3Npb24sIFN1Ym1pc3Npb25TdGF0dXNlc30gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuXG5leHBvcnQge19JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfTtcblxuY29uc3QgRURJVE9SX1ZFUlNJT04gPSBcIjUuMS4yXCI7XG5cbi8qKlxuICogTWFqb3IgZW50cnkgcG9pbnQgZm9yIGNyZWF0aW5nIGEgQmxvY2tQeSBpbnN0YW5jZS5cbiAqIFR3byBtb3N0IGltcG9ydGFudCBmaWVsZHMgYXJlIGBtb2RlbGAgYW5kIGBjb21wb25lbnRzYC5cbiAqIFRoZSBgbW9kZWxgIGhvbGRzIGFsbCB0aGUgZGF0YSBhYm91dCB0aGUgaW50ZXJmYWNlLlxuICogVGhlIGBjb21wb25lbnRzYCBhcmUgcmVmZXJlbmNlcyB0byB0aGUgZGlzcGFyYXRlIHBhcnRzIG9mIEJsb2NrUHkuXG4gKlxuICogTW9zdCBvZiB0aGlzIGNsYXNzZXMgZGVmaW5pdGlvbiBpcyBqdXN0IGluaXRpYWxpemluZyB0aGUgbW9kZWwgYW5kIHVwZGF0aW5nXG4gKiBpdCBvbiBhbiBhc3NpZ25tZW50IHN3aXRjaC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIC0gVXNlciBsZXZlbCBzZXR0aW5ncyAoZS5nLiwgd2hhdCBlZGl0b3IgbW9kZSwgd2hldGhlciB0byBtdXRlIHNlbWFudGljIGVycm9ycywgZXRjLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudCAtIEFzc2lnbm1lbnQgbGV2ZWwgc2V0dGluZ3MgKGRhdGEgYWJvdXQgdGhlIGxvYWRlZCBhc3NpZ25tZW50LCB1c2VyLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIC0gSW5jbHVkZXMgdGhlIHNvdXJjZSBjb2RlIG9mIGFueSBwcm9ncmFtcyB0byBiZSBsb2FkZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAoYXNzaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFzc2lnbm1lbnQoY29uZmlndXJhdGlvbiwgYXNzaWdubWVudCwgc3VibWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWFpbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBCbG9ja1B5IG9iamVjdCBieSBpbml0aWFsaXppbmcgaXRzIGludGVyZmFjZSxcbiAgICAgKiBtb2RlbCwgYW5kIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0TWFpbigpIHtcbiAgICAgICAgdGhpcy5pbml0VXRpbGl0aWVzKCk7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsTWV0aG9kcygpO1xuICAgICAgICB0aGlzLnR1cm5PbkhhY2tzKCk7XG4gICAgICAgIHRoaXMuaW5pdEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmFwcGx5TW9kZWwoKTtcbiAgICAgICAgdGhpcy5pbml0Q29tcG9uZW50cygpO1xuICAgICAgICB0aGlzLm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBkZWZhdWx0IHZhbHVlIG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdG8gbG9vayB1cCBhIHZhbHVlIGZvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0VmFsdWUgLSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBhbnl3aGVyZSwgdXNlIHRoaXMgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5nKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxTZXR0aW5nc18uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU2V0dGluZ3NfLmdldChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RlbCB0byBpdHMgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBDYXRlZ29yaWVzOlxuICAgICAqICAgKiB1c2VyOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIgKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGFzc2lnbm1lbnQ6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgYXNzaWdubWVudCAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogc3VibWlzc2lvbjogdmFsdWVzIGZvciB0aGUgY3VycmVudCBzdWJtaXNzaW9uIChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBkaXNwbGF5OiBmbGFncyByZWxhdGVkIHRvIGN1cnJlbnQgdmlzaWJpbGl0eSAoc3RvcmVkIHRvIGxvY2FsU2V0dGluZ3MpXG4gICAgICogICAqIHN0YXR1czogbWVzc2FnZXMgcmVsYXRlZCB0byBjdXJyZW50IHN0YXR1cyAobm90IHN0b3JlZClcbiAgICAgKiAgICogZXhlY3V0aW9uOiB2YWx1ZXMgcmVsYXRlZCB0byBsYXN0IHJ1biAobm90IHN0b3JlZClcbiAgICAgKiAgICogY29uZmlndXJhdGlvbjogY29uc3RhbnQgdmFsdWVzIHJlbGF0ZWQgdG8gc2V0dXAgKG5vdCBzdG9yZWQpXG4gICAgICovXG4gICAgaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgLy8gQ29ubmVjdCB0byBsb2NhbCBzdG9yYWdlXG4gICAgICAgIHRoaXMubG9jYWxTZXR0aW5nc18gPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcImxvY2FsU2V0dGluZ3NcIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhjb25maWd1cmF0aW9uLCBjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdLCBjb25maWd1cmF0aW9uW1wicGFydElkXCJdLCBleHRyYWN0UGFydChjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdIHx8IFwiXCIsIGNvbmZpZ3VyYXRpb25bXCJwYXJ0SWRcIl0pKTtcblxuICAgICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmlkXCJdKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLm5hbWVcIl0pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgeW91IGFyZSBhbiBPd25lciAoY2FuIG1vZGlmeSB0aGUgYXNzaWdubWVudCksIEdyYWRlciAoY2FuIHZpZXdcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXNzaWdubWVudHMnIGluZm9ybWF0aW9uKSBvciBTdHVkZW50IChjYW4gbm90IHNlZSBhbnkgaW5zdHJ1Y3RvciBzdHVmZikuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcm9sZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJ1c2VyLnJvbGVcIiwgXCJvd25lclwiKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBjb3Vyc2UgZm9yIHRoaXMgdXNlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmNvdXJzZV9pZFwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBhc3NpZ25tZW50IGdyb3VwIHRoYXQgdGhpcyB1c2VyIGlzIGluc2lkZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuZ3JvdXBfaWRcIl0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWdubWVudDoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoXCJTY3JhdGNoIENhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUoXCJXZWxjb21lIHRvIEJsb2NrUHkuIFRyeSBlZGl0aW5nIGFuZCBydW5uaW5nIHRoZSBjb2RlIGJlbG93LlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaHVtYW4tZnJpZW5kbHkgVVJMIHRvIHVzZSBhcyBhIHNob3J0Y3V0IGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybmluZyBtZXNzYWdlIGlmIG1hemVcbiAgICAgICAgICAgICAgICB0eXBlOiBrby5vYnNlcnZhYmxlKEFzc2lnbWVudFR5cGUuQkxPQ0tQWSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQ29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zdGFydGluZ19jb2RlXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uUnVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX3J1blwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9jaGFuZ2VcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgb25FdmFsOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2V2YWxcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShsb2FkQ29uY2F0ZW5hdGVkRmlsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzXCJdKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgZXh0cmFTdGFydGluZ0ZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGZvcmtlZElkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGZvcmtlZFZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgcmV2aWV3ZWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQucmV2aWV3ZWRcIl0pLFxuICAgICAgICAgICAgICAgIHB1YmxpYzoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5wdWJsaWNcIl0pLFxuICAgICAgICAgICAgICAgIGhpZGRlbjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5oaWRkZW5cIl0pLFxuICAgICAgICAgICAgICAgIGlwUmFuZ2VzOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmlwX3Jhbmdlc1wiXSksXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBrby5vYnNlcnZhYmxlKGV4dHJhY3RQYXJ0KGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0gfHwgXCJcIiwgY29uZmlndXJhdGlvbltcInBhcnRJZFwiXSkgfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgZXh0cmFGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgc2NvcmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgY29ycmVjdDoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudElkIGluZmVycmVkIGZyb20gYXNzaWdubWVudC5pZFxuICAgICAgICAgICAgICAgIC8vIGNvdXJzZUlkIGluZmVycmVkIGZyb20gdXNlci5jb3Vyc2VJZFxuICAgICAgICAgICAgICAgIC8vIHVzZXJJZCBpbmZlcnJlZCBmcm9tIHVzZXIuaWRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50VmVyc2lvbiBpbmZlcnJlZCBmcm9tIGFzc2lnbm1lbnQudmVyc2lvblxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShcIlN0YXJ0ZWRcIiksXG4gICAgICAgICAgICAgICAgZ3JhZGluZ1N0YXR1czoga28ub2JzZXJ2YWJsZShcIk5vdFJlYWR5XCIpLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IGtvLm9ic2VydmFibGUobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudGx5IHZpc2libGUgRmlsZSwgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgcHJlc2VudGVkIHdpdGggdGhlIGluc3RydWN0b3Igc2V0dGluZ3MgYW5kIGZpbGVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoga28ub2JzZXJ2YWJsZShcIlwiK3RoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkuaW5zdHJ1Y3RvclwiLCBcImZhbHNlXCIpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHByZXZlbnQgdGhlIHByaW50ZXIgZnJvbSBzaG93aW5nIHRoaW5nc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG11dGVQcmludGVyOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAoUHl0aG9uIFZpZXdzKSBUaGUgY3VycmVudCBlZGl0b3IgbW9kZS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7RGlzcGxheU1vZGVzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHB5dGhvbk1vZGU6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5weXRob24ubW9kZVwiLCBEaXNwbGF5TW9kZXMuVEVYVCkpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEhpc3RvcnkgbW9kZSBpcyBlbmdhZ2VkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGhpc3RvcnlNb2RlOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSBhdXRvLXNhdmluZyBjaGFuZ2VzIGluIFB5dGhvbiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgKiBJZiBhbiBpbnRlZ2VyLCBzcGVjaWZpZXMgdGhlIGRlbGF5IHRoYXQgc2hvdWxkIGJlIHVzZWQgKG1pY3Jvc2Vjb25kcykuXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBuZXZlciBvbiBpbiBub24tUHl0aG9uIGVkaXRvcnMuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x8aW50fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGF1dG9TYXZlOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjb25zb2xlIGlzIGZ1bGwgd2lkdGggYW5kIGZlZWRiYWNrIGlzIGhpZGRlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJpZ0NvbnNvbGU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAgICAgKiAgICBJZiBudWxsLCB0aGVuIGxldCB0aGUgaGVpZ2h0IHJlbWFpbiB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICAgKiAgICBJZiBhIG51bWJlciwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hpY2ggcGFuZWwgdG8gc2hvdyBpbiB0aGUgc2Vjb25kIHJvdydzIHNlY29uZCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7U2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlY29uZFJvd1NlY29uZFBhbmVsOiBrby5vYnNlcnZhYmxlKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDSyksXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSB0cmFjaW5nIHRoZSBjb2RlIHJpZ2h0IG5vd1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyYWNlRXhlY3V0aW9uOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbGlzdCBvZiBwcm9taXNlcyB0byBzdGlsbCByZXNvbHZlIHdoaWxlIGxvYWRpbmcgZGF0YXNldHNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8UHJvbWlzZT59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbG9hZGluZ0RhdGFzZXRzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSB0ZW1wb3JhcnkgY2hhbmdlZCB2YWx1ZSBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGhhdmUgYmVlbiBjaGFuZ2VkIGZyb20gd2hhdCBpcyBpbiB0aGUgYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNoYW5nZWRJbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQSBob2xkZXIgZm9yIHRoZSB0aW1lciB0byB0cmlnZ2VyIG9uLWNoYW5nZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0cmlnZ2VyT25DaGFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB0aGUgY3VycmVudCBmZWVkYmFjayBhbmQgb3V0cHV0IGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgICogVGhpcyB3b3VsZCBiZSBmYWxzZSBpZiB0aGVyZSBpcyBubyBmZWVkYmFjay9vdXRwdXQgKGkuZS4sIGNvZGUgaGFzIG5vdCBiZWVuIHJ1biksXG4gICAgICAgICAgICAgICAgICogb3IgaWYgdGhlIHVzZXIgaGFzIG1vZGlmaWVkIHRoZSBzdWJtaXNzaW9uIGFmdGVyIHRoZSBsYXN0IHJ1biAoZS5nLiwgYnkgZWRpdGluZ1xuICAgICAgICAgICAgICAgICAqIHRoZSB0ZXh0KS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXJ0eVN1Ym1pc3Npb246IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIFdoZXRoZXIgb3Igbm90IHRvIG1ha2UgdGhlIEJsb2NrUHkgZWxlbWVudCBpbiBGVUxMIFNDUkVFTiBtb2RlLiBTYWRseSwgbm90IGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAgKiAgd2l0aGluIHRoZSB3aW5kb3csIGJ1dCBGVUxMIFNDUkVFTi4gVmVyeSBhZ2dyZXNzaXZlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZXItc3VwcGxpZWQgcGFzc2NvZGUgdG8gY29tcGFyZSBvbiB0aGUgc2VydmVyIGFnYWluc3QgdGhlIGN1cnJlbnQgcGFzc2NvZGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGFzc2NvZGU6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gY2xlYXIgb3V0IGlucHV0cyBhZnRlciBhIHJ1bi9vbl9ydW4gY3ljbGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjbGVhcklucHV0czoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBpbWFnZXMgc2hvdWxkIGJlIHJlbmRlcmVkICh0cnVlKSwgb3IganVzdCBzdGF5IGFzIHRleHQgY29kZSAoZmFsc2UpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbmRlckltYWdlczoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICBlZGl0b3JWZXJzaW9uOiBFRElUT1JfVkVSU0lPTixcbiAgICAgICAgICAgICAgICByZWFkT25seToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJkaXNwbGF5LnJlYWRfb25seVwiLCBcImZhbHNlXCIpLnRvU3RyaW5nKCk9PT1cInRydWVcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXBsb2FkZWQgZmlsZXMgYXJlIG9uZXMgdGhhdCBoYXZlIGJlZW4gbGlzdGVkIGJ5IHRoZSByZW1vdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cGxvYWRlZEZpbGVzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJhY2t1cCBjb3B5IG9mIHRoZSBsYXRlc3Qga25vd24gZnVsbCBjb2RlIGZvciB0aGUgU3VibWlzc2lvbi4gVGhpcyBpcyByZWxldmFudCBpZiB0aGVyZSB3YXMgYVxuICAgICAgICAgICAgICAgICAqIFBhcnRJRCBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgdGhlIHN1Ym1pc3Npb24uY29kZSBpbiB0aGUgbW9kZWwgaXMgb25seSBzaG93aW5nIHdoYXQgd2Uga25vd1xuICAgICAgICAgICAgICAgICAqIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYmFja3VwU3VibWlzc2lvbkNvZGU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInN1Ym1pc3Npb24uY29kZVwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb250cm9scyB0aGUgcmF0aW5nIHN5c3RlbVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNob3dSYXRpbmc6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5zaG93UmF0aW5nXCIsIFwidHJ1ZVwiKS50b1N0cmluZygpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIHN0dWRlbnQgaGFzIHJhdGVkIHRoaXMgY3VycmVudCBmZWVkYmFja1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGhhc1JhdGVkOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEhpc3RvcnlNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkRGF0YXNldE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2dFdmVudDoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9nRXZlbnRNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2VNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBzYXZlQXNzaWdubWVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXM6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbGlzdFVwbG9hZGVkRmlsZXM6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxpc3RVcGxvYWRlZEZpbGVzTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGRvd25sb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgZG93bmxvYWRGaWxlTWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwbG9hZEZpbGU6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwbG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgcmVuYW1lRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgcmVuYW1lRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBleHRlcm5hbEFQSToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxBUElNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgb25FeGVjdXRpb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IGluLXByb2dyZXNzIGV4ZWN1dGlvbnNcbiAgICAgICAgICAgICAgICByZXBvcnRzOiB7fSxcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIE91dHB1dCBvYmplY3RzXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIC8vIExpc3Qgb2YgaW5wdXR0ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIGlucHV0OiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXg6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBhIHN0dWRlbnQgcnVuXG4gICAgICAgICAgICAgICAgc3R1ZGVudDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHI6IHRoZSBmaWxlbmFtZSB0aGF0IHdhcyBsYXN0IGV4ZWN1dGVkIGFuZCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RlcDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZToga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdExpbmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIHNpbXBsZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjZURhdGE6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlU3RlcDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsIGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGNhbGxzOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gZmVlZGJhY2sgZnJvbSB0aGUgaW5zdHJ1Y3RvciBydW5cbiAgICAgICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHIgKG1hcmtkb3duKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiUmVhZHlcIiksXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNFcnJvcjoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNVbmNvdmVyZWQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBudWxsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyB0byBmaXJlIHdoZW4gY2VydGFpbiBldmVudHMgb2NjdXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdGhlIHN0dWRlbnQgZ2V0cyBhIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImNhbGxiYWNrLnN1Y2Nlc3NcIl0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2VydmVyIGlzIGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb25uZWN0ZWQ6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwic2VydmVyLmNvbm5lY3RlZFwiLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYmxvY2tseVBhdGg6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiYmxvY2tseS5wYXRoXCJdLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRQb2ludDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJhdHRhY2htZW50LnBvaW50XCJdLFxuICAgICAgICAgICAgICAgIC8vIEpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgLy8gTWFwcyBjb2RlcyAoJ2xvZ19ldmVudCcsICdzYXZlX2NvZGUnKSB0byBVUkxzXG4gICAgICAgICAgICAgICAgdXJsczogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJ1cmxzXCJdIHx8IHt9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBQYXJ0IElEIHRoYXQgY2FuIGRpc3Rpbmd1aXNoIHRoaXMgZWRpdG9yIGluc3RhbmNlJ3MgcmVnaW9uIG9mIHRoZSBhc3NpZ25tZW50LlxuICAgICAgICAgICAgICAgICAqIEl0J3MgcG9zc2libGUgdGhhdCBvdGhlciBlZGl0b3JzIG1heSBiZSBhdHRhY2hlZCB0byBhIGRpZmZlcmVudCBQYXJ0IG9mIHRoZSBzYW1lIGFzc2lnbm1uZXQsIG9uIHRoZVxuICAgICAgICAgICAgICAgICAqIHNhbWUgcGFnZS5cbiAgICAgICAgICAgICAgICAgKiAqKi9cbiAgICAgICAgICAgICAgICBwYXJ0SWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInBhcnRJZFwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYWNjZXNzX3Rva2VuXCJdIHx8IHVuZGVmaW5lZCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGludGVyZmFjZVxuICAgICAqL1xuICAgIGluaXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIGxldCBjb25zdGFudHMgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGxldCBndWkgPSBtYWtlSW50ZXJmYWNlKHRoaXMpO1xuICAgICAgICBjb25zdGFudHMuY29udGFpbmVyID0gJChjb25zdGFudHMuYXR0YWNobWVudFBvaW50KS5odG1sKCQoZ3VpKSk7XG4gICAgfTtcblxuICAgIGxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5sb2FkQXNzaWdubWVudChhc3NpZ25tZW50X2lkKTtcbiAgICB9XG5cbiAgICBsb2FkVGFncyh0YWdzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHRhZ3NcbiAgICB9XG5cbiAgICBsb2FkU2FtcGxlU3VibWlzc2lvbnMoc2FtcGxlcykge1xuICAgICAgICAvLyBBbHJlYWR5IGEgSlNPTiBsaXN0IHJlcHJlc2VudGluZyBzYW1wbGVzXG4gICAgfVxuXG4gICAgbG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICB9XG5cbiAgICBsb2FkU3VibWlzc2lvbihzdWJtaXNzaW9uLCBhc3NpZ25tZW50KSB7XG4gICAgICAgIGlmICghc3VibWlzc2lvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogU2NhcmllciBcIllvdSBhcmUgbm90IGxvZ2dlZCBpbiBtZXNzYWdlXCJcbiAgICAgICAgICAgIHRoaXMubG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHN1Ym1pc3Npb25zJyBhc3NpZ25tZW50IHZlcnNpb24gYW5kIHRoZSBhc3NpZ25tZW50cycgdmVyc2lvbiBjb25mbGljdD9cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmlkKHN1Ym1pc3Npb24uaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuYmFja3VwU3VibWlzc2lvbkNvZGUoc3VibWlzc2lvbi5jb2RlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoZXh0cmFjdFBhcnQoc3VibWlzc2lvbi5jb2RlLCB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24ucGFydElkKCkpIHx8IFwiXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWJtaXNzaW9uLmNvcnJlY3QpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc3VibWlzc2lvbi5zY29yZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5lbmRwb2ludChzdWJtaXNzaW9uLmVuZHBvaW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnVybChzdWJtaXNzaW9uLnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi52ZXJzaW9uKHN1Ym1pc3Npb24udmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5ncmFkaW5nU3RhdHVzKHN1Ym1pc3Npb24uZ3JhZGluZ19zdGF0dXMgfHwgU3VibWlzc2lvblN0YXR1c2VzLlVOS05PV04pO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhzdWJtaXNzaW9uLnN1Ym1pc3Npb25fc3RhdHVzIHx8IFN1Ym1pc3Npb25TdGF0dXNlcy5VTktOT1dOKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLm93bmVySWQoc3VibWlzc2lvbi51c2VyX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC51c2VyLmNvdXJzZUlkKHN1Ym1pc3Npb24uY291cnNlX2lkKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoc3VibWlzc2lvbi5leHRyYV9maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRBc3NpZ25tZW50RGF0YV8oZGF0YSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGRhdGEpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLmRpc21vdW50RXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgd2FzU2VydmVyQ29ubmVjdGVkID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSBkYXRhLmFzc2lnbm1lbnQ7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pZChhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnZlcnNpb24oYXNzaWdubWVudC52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmNvdXJzZUlkKGFzc2lnbm1lbnQuY291cnNlX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZElkKGFzc2lnbm1lbnQuZm9ya2VkX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZFZlcnNpb24oYXNzaWdubWVudC5mb3JrZWRfdmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oYXNzaWdubWVudC5oaWRkZW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoYXNzaWdubWVudC5yZXZpZXdlZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wdWJsaWMoYXNzaWdubWVudC5wdWJsaWMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudHlwZShhc3NpZ25tZW50LnR5cGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudXJsKGFzc2lnbm1lbnQudXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnBvaW50cyhhc3NpZ25tZW50LnBvaW50cyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcyhhc3NpZ25tZW50LmlwX3Jhbmdlcyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoYXNzaWdubWVudC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQubmFtZShhc3NpZ25tZW50Lm5hbWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoYXNzaWdubWVudC5vbl9jaGFuZ2UgfHwgbnVsbCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50Lm9uX2NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShcIiFvbl9jaGFuZ2UucHlcIiwgYXNzaWdubWVudC5vbl9jaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoYXNzaWdubWVudC5vbl9ldmFsIHx8IG51bGwpO1xuICAgICAgICBpZiAoYXNzaWdubWVudC5vbl9ldmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKFwiIW9uX2V2YWwucHlcIiwgYXNzaWdubWVudC5vbl9ldmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oYXNzaWdubWVudC5vbl9ydW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vd25lcklkKGFzc2lnbm1lbnQub3duZXJfaWQpO1xuICAgICAgICB0aGlzLmxvYWRUYWdzKGFzc2lnbm1lbnQudGFncyk7XG4gICAgICAgIHRoaXMubG9hZFNhbXBsZVN1Ym1pc3Npb25zKGFzc2lnbm1lbnQuc2FtcGxlX3N1Ym1pc3Npb25zKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShhc3NpZ25tZW50LmV4dHJhX3N0YXJ0aW5nX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKTtcbiAgICAgICAgbG9hZEFzc2lnbm1lbnRTZXR0aW5ncyh0aGlzLm1vZGVsLCBhc3NpZ25tZW50LnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5sb2FkU3VibWlzc2lvbihkYXRhLnN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCh3YXNTZXJ2ZXJDb25uZWN0ZWQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuY29yZ2lzLmxvYWREYXRhc2V0cyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLmxvYWRSZW1vdGVGaWxlcygpO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgIH1cblxuICAgIGluaXRNb2RlbE1ldGhvZHMoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgbW9kZWwudWkgPSB7XG4gICAgICAgICAgICBzbWFsbExheW91dDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAhbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpKSxcbiAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICBpc0dyYWRlcjoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudXNlci5yb2xlKCkgPT09IFwib3duZXJcIiB8fCBtb2RlbC51c2VyLnJvbGUoKSA9PT0gXCJncmFkZXJcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBpc0NoYW5nZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMoKSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgY3VycmVudDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLmluc3RydWN0aW9ucy5pc0NoYW5nZWQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnV0aWxpdGllcy5tYXJrZG93bihtb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMoKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51dGlsaXRpZXMubWFya2Rvd24obW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJlc2V0OiAoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZToga28ucHVyZUNvbXB1dGVkKFxuICAgICAgICAgICAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Mub25seUludGVyYWN0aXZlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRGdWxsc2NyZWVuOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKSA/IFwiZmEtY29tcHJlc3MtYXJyb3dzLWFsdFwiIDogXCJmYS1leHBhbmQtYXJyb3dzLWFsdFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjbGlja0Z1bGxzY3JlZW46ICgpID0+e1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oIW1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbigpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVkaXRJbnB1dHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmRpYWxvZy5FRElUX0lOUFVUUygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9nZ2xlSW1hZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlbmRlckltYWdlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuZGlzYWJsZUltYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0RWRpdG9yLmVuYWJsZUltYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCFtb2RlbC5kaXNwbGF5LnJlbmRlckltYWdlcygpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbk1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpIHx8IG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRNYXJrU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWwudXNlci5ncm91cElkKCkgPyBcIlByb2JsZW0gY2xvc2VkXCIgOiBcIkFzc2lnbm1lbnQgY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSZW9wZW4gZm9yIGVkaXRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC5kaXNwbGF5LmRpcnR5U3VibWlzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJSdW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSAmJiBtb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdWJtaXQgZWFybHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNsaWNrTWFya1N1Ym1pdHRlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudWkubWVudS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIllvdSBjYW5ub3QgcmVvcGVuIGNsb3NlZCBhc3NpZ25tZW50cy4gQ29udGFjdCBhIGdyYWRlciFcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwudWkubWVudS5pc1N1Ym1pdHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJpblByb2dyZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZGVsYXllZFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uU3RhdHVzKFwiU3VibWl0dGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCkgfHwgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5jYW5DbG9zZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcInN1Ym1pdHRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXRlZDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZWRcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2hvd1F1ZXVlZElucHV0czoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVRdWV1ZWRJbnB1dHMoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2hvd0Nsb2NrOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGFzQ2xvY2soKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWNvbmRSb3c6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC0xMlwiIDogXCJjb2wtbWQtNVwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoaWRlVHJhY2VCdXR0b246IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVUcmFjZUJ1dHRvbigpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0FsbFZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlTWlkZGxlUGFuZWwoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNGZWVkYmFja1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDS1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNUcmFjZVZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaXNDb25zb2xlU2hvd1Zpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUoKSB8fCBtb2RlbC51aS5zZWNvbmRSb3cuaXNUcmFjZVZpc2libGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc3dpdGNoTGFiZWw6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVmlldyBUcmFjZVwiIDogXCJcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYWR2YW5jZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFuZWwgPSBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWFrZVdpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhbmVsID0gbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbDtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5wcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsKGN1cnJlbnRQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc3RvcmVQYW5lbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhbmVsID0gbW9kZWwuZGlzcGxheS5wcmV2aW91c1NlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUGFuZWwoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbChvbGRQYW5lbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBhbmVsKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnNvbGU6IHtcbiAgICAgICAgICAgICAgICBzaXplOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKCkgPT09IFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5OT05FKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC0xMlwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTZcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGlkZUV2YWx1YXRlOiBrby5wdXJlQ29tcHV0ZWQoICgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRXZhbHVhdGUoKSB8fCAhbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscygpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmVlZGJhY2s6IHtcbiAgICAgICAgICAgICAgICBiYWRnZToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1ub25lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnVudGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXJ1bnRpbWUtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW50YXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zeW50YXgtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlZGl0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1zeW50YXgtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRlcm5hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWludGVybmFsLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VtYW50aWNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbmFseXplclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXNlbWFudGljLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmVlZGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtZmVlZGJhY2stZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXByb2JsZW0tY29tcGxldGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1pbnN0cnVjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJubyBlcnJvcnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1uby1lcnJvcnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicnVudGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJ1bnRpbWUgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzeW50YXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTeW50YXggRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlZGl0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFZGl0b3IgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnRlcm5hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkludGVybmFsIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VtYW50aWNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbmFseXplclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFsZ29yaXRobSBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZlZWRiYWNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3Rpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5zdHJ1Y3Rpb25zXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkluY29ycmVjdCBBbnN3ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkNvbXBsZXRlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm8gZXJyb3JzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZXNldFNjb3JlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoMCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvbihtb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCksIG1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVSYXRpbmdzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZsaXBSYXRpbmc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSAhbW9kZWwuZGlzcGxheS5zaG93UmF0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2hvd1JhdGluZyhuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9jYWxTZXR0aW5nc18uc2V0KFwiZGlzcGxheS5zaG93UmF0aW5nXCIsIG5ld1N0YXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmF0ZTogKHJhdGluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1SYXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGFiZWwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktcmF0aW5nXCIpLmZhZGVPdXQoNTAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZmFkZUluKDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhhc1JhdGVkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhhbmtZb3UgPSBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stdGhhbmsteW91XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGFua1lvdS5hZGRDbGFzcyhcInNob3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhbmtZb3UucmVtb3ZlQ2xhc3MoXCJzaG93XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhc1JhdGVkQ2xhc3M6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhhc1JhdGVkKCkgPyBcImZhclwiIDogXCJmYXNcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2U6IHtcbiAgICAgICAgICAgICAgICBoYXM6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkTGluZToga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSAhPT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhIHx8IHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RyYWNlRGF0YVtzdGVwLTFdLmxpbmVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbGluZToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhIHx8IHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHRyYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJlZm9yZSBydW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBsYXN0U3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRmluaXNoZWQgcnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgYXJlIHRoZXNlIG51bWJlcnMgd29ua3k/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMaW5lIFwiKyh0cmFjZURhdGFbc3RlcC0xXS5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGFzdDoga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJOb3RoaW5nIHRyYWNlZC5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdGFydGluZyBleGVjdXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbGFzdFN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXhlY3V0aW9uIGhhbHRlZCAoZXJyb3IpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkZpbmlzaGVkIGV4ZWN1dGlvblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJDdXJyZW50IHN0ZXA6IFwiICsgQVNUX0RFU0NSSVBUSU9OU1t0cmFjZURhdGFbc3RlcC0xXS5hc3RdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IE1hdGgubWF4KDAsIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBNYXRoLm1pbihtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpLCBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChuZXh0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRhdGE6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdFN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2VEYXRhID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbGFzdFN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlRGF0YVtzdGVwIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZURhdGFbc3RlcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxlczoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6IFwiY29sLW1kLTZcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGFzQ29udGVudHM6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYW5zd2VyLnB5XCI6IHJldHVybiBtb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhaW5zdHJ1Y3Rpb25zLm1kXCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9jaGFuZ2UucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/bW9ja191cmxzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9pbWFnZXMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/aW1hZ2VzLmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9wcmVmaXgucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiIWFuc3dlcl9wcmVmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9zdWZmaXgucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiIWFuc3dlcl9zdWZmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3Rvb2xib3guYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiF0YWdzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQudGFncygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnMoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/bW9ja191cmxzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3ByZWZpeC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfc3VmZml4LnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3RhZ3MuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9zZXR0aW5ncy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/aW1hZ2VzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgsIFwie31cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3Rvb2xib3guYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3JtYWxUb29sYm94ID0gc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5ibG9ja0VkaXRvci5UT09MQk9YRVNbXCJub3JtYWxcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsVG9vbGJveCA9IEpTT04uc3RyaW5naWZ5KG5vcm1hbFRvb2xib3gsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCwgbm9ybWFsVG9vbGJveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucyhbU2FtcGxlU3VibWlzc2lvbi5CbGFuaygpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZml4IGV4dHJhZmlsZXMgZm9yIGluc3RydWN0b3IgYW5kIHN0dWRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHVkZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0dWRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcInN0YXJ0aW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKHBhdGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmFtZTogKG5ld05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLnJlbmFtZUZpbGUobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpLCBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldFN0dWRlbnRDb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeFB5ID0gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIiFhbnN3ZXJfcHJlZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4UHkgPSBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiIWFuc3dlcl9zdWZmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeFB5ICYmIHByZWZpeFB5LmhhbmRsZSAmJiBwcmVmaXhQeS5oYW5kbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IHByZWZpeFB5LmhhbmRsZSgpICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VmZml4UHkgJiYgc3VmZml4UHkuaGFuZGxlICYmIHN1ZmZpeFB5LmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSArIHN1ZmZpeFB5LmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFTdHVkZW50RmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhU3RhcnRpbmdGaWxlczogb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlGaWxlbmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVVJMIERhdGFcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/aW1hZ2VzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW1hZ2VzXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiIWFuc3dlcl9wcmVmaXgucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQW5zd2VyIFByZWZpeFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFuc3dlciBTdWZmaXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlRvb2xib3hcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiJlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0b3JzOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudDoga28ucHVyZUNvbXB1dGVkKCAoKT0+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lZGl0b3JzLmdldEVkaXRvcihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3aWR0aDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC0xMlwiIDogXCJjb2wtbWQtN1wiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFZGl0b3JzKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Mub25seUludGVyYWN0aXZlKCkpKSA/IFwiTm9uZVwiIDpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID8gbW9kZWwudWkuZWRpdG9ycy5jdXJyZW50KCkgOiBcIk5vbmVcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLlJlc2V0XCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmNvZGUobW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyhtb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IGZpbGUuZmlsZW5hbWUoKS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuU2F2ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5kaXNwbGF5LmF1dG9TYXZlKCkpLFxuICAgICAgICAgICAgICAgIGNhbkRlbGV0ZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKSB8fCBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgVU5ERUxFVEFCTEVfRklMRVMuaW5kZXhPZihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpID09PSAtMSksXG4gICAgICAgICAgICAgICAgY2FuUmVuYW1lOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpIHx8IG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSAmJlxuICAgICAgICAgICAgICAgICAgICBVTlJFTkFNQUJMRV9GSUxFUy5pbmRleE9mKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSkgPT09IC0xKSxcbiAgICAgICAgICAgICAgICB1cGxvYWQ6IHVwbG9hZEZpbGUuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWRGaWxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgaW1wb3J0RGF0YXNldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuY29yZ2lzLm9wZW5EaWFsb2coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB5dGhvbjoge1xuICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZU1pcnJvciA9IHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dEVkaXRvci5jb2RlTWlycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY29kZU1pcnJvci5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTW9kZTogKG5ld01vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLVZpZXcuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsIG5ld01vZGUsIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUobmV3TW9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5vbGRQeXRob25Nb2RlID0gbmV3TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXN0b3J5QXZhaWxhYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkSGlzdG9yeVwiKSksXG4gICAgICAgICAgICAgICAgICAgIHR1cm5PZmZIaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci51cGRhdGVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iuc2V0UmVhZE9ubHkoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHR1cm5Pbkhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvYWRIaXN0b3J5KChyZXNwb25zZSkgPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubG9hZChyZXNwb25zZS5oaXN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5zZXRSZWFkT25seSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfSElTVE9SWSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVIaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT25IaXN0b3J5TW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVRvU3RhcnQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlUHJldmlvdXMoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVOZXh0KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0UmVjZW50OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlVG9Nb3N0UmVjZW50KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2U6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5LnVzZSgpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGltYWdlczoge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRGaWxlOiAoKSA9PiBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJpbWFnZVwiKS51cGxvYWRGaWxlKCksXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGU6IChmaWxlSW5mbykgPT4gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiaW1hZ2VcIikuZGVsZXRlRmlsZShmaWxlSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIHJlbmFtZUZpbGU6IChmaWxlSW5mbykgPT4gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiaW1hZ2VcIikucmVuYW1lRmlsZShmaWxlSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIHJlbG9hZEltYWdlczogKCkgPT4gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiaW1hZ2VcIikucmVsb2FkSW1hZ2VzKCksXG4gICAgICAgICAgICAgICAgICAgIGNhbkNob29zZVBsYWNlbWVudDoga28ucHVyZUNvbXB1dGVkKCgpID0+IG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSxcbiAgICAgICAgICAgICAgICAgICAgY2FuTW9kaWZ5OiAocGxhY2VtZW50KSA9PiBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCBwbGFjZW1lbnQgPT09IFwic3VibWlzc2lvblwiIHx8IHBsYWNlbWVudCA9PT0gXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICAgICAgICBzYXZlOiAoKSA9PiBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnNhdmVBc3NpZ25tZW50KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNhbXBsZVN1Ym1pc3Npb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkRWRpdG9yOiAobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRvciA9IHNlbGYuY29tcG9uZW50cy5lZGl0b3JzLmJ5TmFtZShcIlNhbXBsZSBTdWJtaXNzaW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5idWlsZEVkaXRvcihuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhlY3V0ZToge1xuICAgICAgICAgICAgICAgIGlzUnVubmluZzoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJ1bkxhYmVsOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRSA/IFwiU3RvcFwiIDogXCJSdW5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcnVuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFB5Z2FtZUxpYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQeWdhbWVMaWIucnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB5Z2FtZUxpYi5TdG9wUHlnYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJ1blF1aWV0bHlMYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRSA/IFwiU3RvcFwiIDogXCJSdW4gd2l0aG91dCBmZWVkYmFja1wiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBydW5RdWlldGx5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFB5Z2FtZUxpYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQeWdhbWVMaWIucnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB5Z2FtZUxpYi5TdG9wUHlnYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZTogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5ldmFsdWF0ZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAoZW5kcG9pbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXItc3RhdHVzLVwiICsgbW9kZWwuc3RhdHVzW2VuZHBvaW50XSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0VuZHBvaW50Q29ubmVjdGVkOiAoZW5kcG9pbnQpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzW2VuZHBvaW50XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgY2FwaXRhbGl6ZShtb2RlbC5zdGF0dXMubG9hZEFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlQXNzaWdubWVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRIaXN0b3J5TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZEZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlRmlsZU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWREYXRhc2V0TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9nRXZlbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlSW1hZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5leHRlcm5hbEFQSSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMudXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2UoKSB8fCBcIlwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZm9yY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgZmlsZUhhbmRsZXIgPSAkKFwiLmJsb2NrcHktZm9yY2UtbG9hZC1hc3NpZ25tZW50LWZpbGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlsZUhhbmRsZXIuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKS5mYWRlT3V0KDEwMCkuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB1c2VyIHRvIHVwbG9hZCBhIGZpbGUgY29udGFpbmluZyBhbiBhc3NpZ25tZW50IHN1Ym1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uWzBdLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50U3VibWlzc2lvbiA9IEpTT04ucGFyc2UoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRBc3NpZ25tZW50RGF0YV8oYXNzaWdubWVudFN1Ym1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvbi52YWwoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKHNlbGYubW9kZWwuc3VibWlzc2lvbi5zY29yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb290ZXI6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwudWkuc21hbGxMYXlvdXQoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMoc2VsZiwgbW9kZWwpO1xuICAgIH1cblxuICAgIHR1cm5PbkhhY2tzKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ET1wiKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9pbWFnZS5qc1wiXSA9IGltYWdlTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi93ZWFrcmVmLmpzXCJdID0gd2Vha3JlZk1vZHVsZS50b1N0cmluZygpO1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvbWF0cGxvdGxpYi9weXBsb3QvX19pbml0X18uanNcIl0gPSBtYXRwbG90bGliTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHlzIHRoZSBLbm9ja291dEpTIGJpbmRpbmdzIHRvIHRoZSBtb2RlbCwgaW5zdGFudGlhdGluZyB0aGUgdmFsdWVzIGludG8gdGhlXG4gICAgICogSFRNTC5cbiAgICAgKi9cbiAgICBhcHBseU1vZGVsKCkge1xuICAgICAgICBrby5hcHBseUJpbmRpbmdzKHRoaXMubW9kZWwsIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXJbMF0pO1xuICAgIH1cblxuICAgIGluaXRVdGlsaXRpZXMoKSB7XG4gICAgICAgIGxldCBtYWluID0gdGhpcztcbiAgICAgICAgdGhpcy51dGlsaXRpZXMgPSB7XG4gICAgICAgICAgICBtYXJrZG93bjogKHRleHQpID0+IHRleHQgPyBFYXN5TURFLnByb3RvdHlwZS5tYXJrZG93bih0ZXh0KSA6IFwiPHA+PC9wPlwiXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5pdENvbXBvbmVudHMoKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyO1xuICAgICAgICBsZXQgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXM7XG4gICAgICAgIC8vIEVhY2ggb2YgdGhlc2UgY29tcG9uZW50cyB3aWxsIHRha2UgdGhlIEJsb2NrUHkgaW5zdGFuY2UsIGFuZCBwb3NzaWJseSBhXG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgcmVsZXZhbnQgSFRNTCBsb2NhdGlvbiB3aGVyZSBpdCB3aWxsIGJlIGVtYmVkZGVkLlxuICAgICAgICBjb21wb25lbnRzLmRpYWxvZyA9IG5ldyBCbG9ja1B5RGlhbG9nKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZGlhbG9nXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy5mZWVkYmFjayA9IG5ldyBCbG9ja1B5RmVlZGJhY2sobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFja1wiKSk7XG4gICAgICAgIGNvbXBvbmVudHMudHJhY2UgPSBuZXcgQmxvY2tQeVRyYWNlKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmNvbnNvbGUgPSBuZXcgQmxvY2tQeUNvbnNvbGUobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1jb25zb2xlXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy5lbmdpbmUgPSBuZXcgQmxvY2tQeUVuZ2luZShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5maWxlU3lzdGVtID0gbmV3IEJsb2NrUHlGaWxlU3lzdGVtKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmVkaXRvcnMgPSBuZXcgRWRpdG9ycyhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWVkaXRvclwiKSk7XG4gICAgICAgIC8vIENvbnZlbmllbnQgc2hvcnRjdXQgZGlyZWN0bHkgdG8gUHl0aG9uRWRpdG9yXG4gICAgICAgIGNvbXBvbmVudHMucHl0aG9uRWRpdG9yID0gdGhpcy5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwicHl0aG9uXCIpO1xuICAgICAgICBjb21wb25lbnRzLnNlcnZlciA9IG5ldyBCbG9ja1B5U2VydmVyKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmNvcmdpcyA9IG5ldyBCbG9ja1B5Q29yZ2lzKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmhpc3RvcnkgPSBuZXcgQmxvY2tQeUhpc3RvcnkobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1oaXN0b3J5LXRvb2xiYXJcIikpO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuc2hvdygpO1xuICAgICAgICAvL3RoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiKS50b2dnbGUodGhpcy5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgfVxuXG4gICAgbWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1JbnN0cnVjdGlvbnMuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQsIFwiaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9jayA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUNsb2NrID0gKCkgPT4gY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1tZW51LWNsb2NrXCIpLnRleHQoZ2V0Q3VycmVudFRpbWUoKSk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnVpLm1lbnUuc2hvd0Nsb2NrKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzZXRJbnRlcnZhbCh1cGRhdGVDbG9jaywgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnVpLm1lbnUuc2hvd0Nsb2NrLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZWwudWkubWVudS5zaG93Q2xvY2soKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbG9jayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzZXRJbnRlcnZhbCh1cGRhdGVDbG9jaywgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIHJlc2V0SW50ZXJmYWNlKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIC8vIERpc2FibGUgYW55IGFsdGVybmF0aXZlIGxvZ0VudHJ5IGZ1bmN0aW9ucyB3ZSBoYXZlIGJlZW4gZ2l2ZW5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5hbHRMb2dFbnRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVxdWVzdFBhc3Njb2RlKCkge1xuICAgICAgICBsZXQgdXNlclN1cHBsaWVkUGFzc2NvZGUgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIHBhc3Njb2RlLlwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LnBhc3Njb2RlKHVzZXJTdXBwbGllZFBhc3Njb2RlKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuXG4gICAgfVxuXG59XG5cbiIsImltcG9ydCB7ZW5jb2RlSFRNTH0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5cbi8qKlxuICogRXZhbHVhdGUgYnV0dG9uIEhUTUwgdGVtcGxhdGVcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFNUQVJUX0VWQUxfSFRNTCA9IGBcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tb3V0bGluZSBmbG9hdC1yaWdodCBibG9ja3B5LWJ0bi1ldmFsXCI+XG4gICAgRXZhbHVhdGVcbjwvYnV0dG9uPmA7XG5cbi8qKlxuICogSFRNTCB0ZW1wbGF0ZSBmb3IgYSBuZXcgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IE5FV19DT05TT0xFX0xJTkVfSFRNTCA9IFwiPGRpdj48L2Rpdj5cIjtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgZW50aXJlIGNvbnNvbGUgYXJlYVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENPTlNPTEVfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LXBhbmVsIGJsb2NrcHktY29uc29sZSdcbiAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkNvbnNvbGVcIlxuICAgICAgICAgIGRhdGEtYmluZD1cImNsYXNzOiB1aS5jb25zb2xlLnNpemVcIj5cbiAgICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LXNob3ctZmVlZGJhY2snXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5zZWNvbmRSb3cuaXNDb25zb2xlU2hvd1Zpc2libGUsIGNsaWNrOiB1aS5zZWNvbmRSb3cuYWR2YW5jZVN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICBcbiAgICAgICAgPHN0cm9uZz5Db25zb2xlOjwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz0nYmxvY2tweS1wcmludGVyIGJsb2NrcHktcHJpbnRlci1kZWZhdWx0Jz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICA8L2Rpdj5gO1xuXG4vKipcbiAqIEFsbCB0aGUgcG9zc2libGUgdHlwZXMgZm9yIGEgbGluZSBpbiB0aGUgY29uc29sZS5cbiAqIEBlbnVtXG4gKi9cbmV4cG9ydCBsZXQgQ29uc29sZUxpbmVUeXBlID0ge1xuICAgIFRFWFQ6IFwidGV4dFwiLFxuICAgIEhUTUw6IFwiaHRtbFwiLFxuICAgIFBMT1Q6IFwicGxvdFwiLFxuICAgIElNQUdFOiBcImltYWdlXCIsXG4gICAgUFlHQU1FOiBcInB5Z2FtZVwiLFxuICAgIERSQUZURVI6IFwiZHJhZnRlclwiLFxuICAgIFRVUlRMRTogXCJ0dXJ0bGVcIixcbiAgICBFVkFMOiBcImV2YWxcIixcbiAgICBTVEFSVF9FVkFMOiBcInN0YXJ0X2V2YWxcIixcbiAgICBWQUxVRTogXCJ2YWx1ZVwiLFxuICAgIElOUFVUOiBcImlucHV0XCIsXG4gICAgVEVTVF9DQVNFOiBcInRlc3RfY2FzZVwiXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IHZlcnNpb24gb2YgYSBsaW5lIGluIHRoZSBjb25zb2xlLiBBbGwgb3RoZXIgY29uc29sZSBsaW5lc1xuICogc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLiBDcml0aWNhbGx5LCB0aGV5IG5lZWQgdG8gaW1wbGVtZW50IGEgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdHlwZSwgY29udGVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIGJhY2sgdG8gdGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZS5cbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqIEB0eXBlIHtCbG9ja1B5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdGVnb3JpemVzIHdoYXQga2luZCBvZiBsaW5lIHRoaXMgaXMgKHRleHQvaHRtbC9wbG90L2V0Yy4pXG4gICAgICAgICAqIEB0eXBlIHtDb25zb2xlTGluZVR5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdHVhbCBkYXRhIHN0b3JlZCBvbiB0aGlzIGxpbmUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0YWRhdGEgYWJvdXQgd2hlcmUgdGhlIGxpbmUgb3JpZ2luYXRlZCBmcm9tIGluIHRoZSBjb2RlLlxuICAgICAgICAgKiBAdHlwZSB7e2ZpbGVuYW1lOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgc3RlcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IFNrLmN1cnJGaWxlbmFtZSxcbiAgICAgICAgICAgIHN0ZXA6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAsXG4gICAgICAgICAgICBsaW5lOiBtYWluLmNvbXBvbmVudHMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSFRNTCBjb250ZW50IHN0b3JlZCBvbiB0aGlzIGxpbmUsIG1lYW50IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAqIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAdHlwZSB7KnxqUXVlcnkuZm4uaW5pdHxqUXVlcnl8SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh0bWwgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1xuICAgICAgICAgICAgXCJjbGFzc1wiOiAgXCJibG9ja3B5LXByaW50ZXItb3V0cHV0XCIsXG4gICAgICAgICAgICBcImRhdGEtY29udGFpbmVyXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnQsXG4gICAgICAgICAgICBcImRhdGEtdG9nZ2xlXCI6IFwidG9vbHRpcFwiLFxuICAgICAgICAgICAgXCJkYXRhLXBsYWNlbWVudFwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwiZGF0YS1zdGVwXCI6IHRoaXMub3JpZ2luLnN0ZXAsXG4gICAgICAgICAgICBcInRpdGxlXCI6IFwiU3RlcCBcIiArIHRoaXMub3JpZ2luLnN0ZXAgKyBcIiwgTGluZSBcIiArIHRoaXMub3JpZ2luLmxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxpbmUgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhbWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU2t1bHB0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29uc29sZSBsaW5lJ3MgY29udGVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0b1NrdWxwdCgpIHtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkodGhpcy5jb250ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhpcyBjb25zb2xlIGxpbmUgYnkgZGVsZXRpbmcgaXRzIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLmh0bWwucmVtb3ZlKCk7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVR1cnRsZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICAvLyBUT0RPOiBDYXB0dXJlIHR1cnRsZSBjb21tYW5kcyBmb3IgdHJhY2luZyBwdXJwb3Nlc1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlRVUlRMRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS10dXJ0bGUtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5wcmVwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbFswXS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAvLyQoJ2h0bWwnKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgICAgICQoXCJodG1sXCIpLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZURyYWZ0ZXIgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgc2l6ZSwgZnVsbHNjcmVlbikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuRFJBRlRFUik7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1kcmFmdGVyLW91dHB1dFwiKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuID0gZnVsbHNjcmVlbjtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgd2hlcmUucHJlcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIC8vIFN0YXJ0cyBvZmYgYXMgYSBuby1vcFxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5zZWNvbmRSb3cucmVzdG9yZVBhbmVsKCk7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVB5Z2FtZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlBZR0FNRSk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1weWdhbWUtb3V0cHV0XCIpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuO1xuICAgICAgICB0aGlzLnB5Z2FtZU9iaiA9IHB5Z2FtZU9iajtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIC8vU2subWFpbl9jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q2FudmFzXCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLmh0bWwub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICAvLyBTdGFydHMgb2ZmIGFzIGEgbm8tb3BcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7fTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNlY29uZFJvdy5yZXN0b3JlUGFuZWwoKTtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZShjbGVhbnVwRnVuY3Rpb24sIGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwID0gKCkgPT4gY2xlYW51cEZ1bmN0aW9uKHRoaXMucHlnYW1lT2JqLCBsaXN0ZW5lcnMpO1xuICAgIH1cblxufVxuXG5jbGFzcyBDb25zb2xlTGluZUltYWdlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLklNQUdFLCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLWltYWdlLW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgLy90aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZVBsb3QgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUExPVCwgY29udGVudCk7XG4gICAgICAgIHRoaXMuaHRtbC5hZGRDbGFzcyhcImJsb2NrcHktY29uc29sZS1wbG90LW91dHB1dFwiKTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVGV4dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGFkZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQgKyBjb250ZW50O1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWVuY29kZWRUZXh0IHx8IGVuY29kZWRUZXh0LnRyaW0oKS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgIGVuY29kZWRUZXh0ID0gXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8c2FtcD48L3NhbXA+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVmFsdWUgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5WQUxVRSwgY29udGVudCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGxldCBsaW5lRGF0YSA9ICQoXCI8Y29kZT48L2NvZGU+XCIsIHsgXCJodG1sXCI6IGVuY29kZWRUZXh0IH0pO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChsaW5lRGF0YSk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW5wdXQgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgcHJvbXB0TWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU5QVVQsIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSW5wdXQgYm94IGZvciByZWNlaXZpbmcgaW5wdXQoKSBmcm9tIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICovXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIC8vIFBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbmluZ1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBJbnB1dCBmb3JtXG4gICAgICAgICAgICBsZXQgaW5wdXRGb3JtID0gJChcIjxpbnB1dCB0eXBlPSd0ZXh0JyAvPlwiKTtcbiAgICAgICAgICAgIC8vIEVudGVyIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0QnRuID0gJChcIjxidXR0b24+PC9idXR0b24+XCIsIHtcImh0bWxcIjogXCJFbnRlclwifSk7XG4gICAgICAgICAgICAvLyBHcm91cCBmb3JtIGFuZCBidXR0b25cbiAgICAgICAgICAgIGxldCBpbnB1dEdyb3VwID0gJChcIjxkaXY+PC9kaXY+XCIsIHtcImNsYXNzXCI6IFwiYmxvY2tweS1jb25zb2xlLWlucHV0XCJ9KTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0Rm9ybSk7XG4gICAgICAgICAgICBpbnB1dEdyb3VwLmFwcGVuZChpbnB1dEJ0bik7XG4gICAgICAgICAgICAvLyBQcm9tcHQgYm94LCBuZXcgbGluZSwgaW5wdXQgZ3JvdXBcbiAgICAgICAgICAgIGxldCBpbnB1dEJveCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5jb2RlZFRleHQgPSBlbmNvZGVIVE1MKHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0TXNnID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgIHtcImh0bWxcIjogZW5jb2RlZFRleHR9KTtcbiAgICAgICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoaW5wdXRNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRCb3guYXBwZW5kKCQoXCI8YnI+XCIpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoaW5wdXRHcm91cCk7XG4gICAgICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQoaW5wdXRCb3gpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvLyBNYWtlIGl0IGludGVyYWN0aXZlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlSW50ZXJhY3RpdmUoaW5wdXRGb3JtLCBpbnB1dEJ0bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIG1ha2VJbnRlcmFjdGl2ZShpbnB1dCwgYnV0dG9uKSB7XG4gICAgICAgIGxldCByZXNvbHZlT25DbGljaztcbiAgICAgICAgbGV0IHN1Ym1pdHRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZU9uQ2xpY2sgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgbGV0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSBpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2godXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnV0dG9uLmNsaWNrKHN1Ym1pdEZvcm0pO1xuICAgICAgICBpbnB1dC5rZXl1cCgoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBzdWJtaXRGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dEluZGV4LCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKTtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdXNlcklucHV0dGVkVmFsdWUgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICBpbnB1dC52YWwodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KGlucHV0SW5kZXgrMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodXNlcklucHV0dGVkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlZFByb21pc2U7XG4gICAgfVxufVxuXG5jbGFzcyBDb25zb2xlTGluZUV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmVJbnB1dCB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBcIkV2YWx1YXRlOlwiKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5TVEFSVF9FVkFMKTtcbiAgICAgICAgdGhpcy5odG1sLmFwcGVuZCgkKFNUQVJUX0VWQUxfSFRNTCkpO1xuICAgICAgICB0aGlzLmh0bWwuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmV4ZWN1dGUuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5Q29uc29sZSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgZm9yIG1hbmFnaW5nIHRoZSBjb25zb2xlLCB3aXRoIGZlYXR1cmVzIGZvciB0aGluZ3MgbGlrZSBwcmludGluZywgcGxvdHRpbmcsIGV2YWxpbmcsIGlucHV0aW5nLlxuICAgICAqIFRoZSBcInByaW50ZXJcIiBpcyB0aGUgcmVnaW9uIHdoZXJlIHdlIHB1dCB0aGluZ3MsIGFzIG9wcG9zZWQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3aG9sZS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZyA9IHRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlclwiKTtcblxuICAgICAgICB0aGlzLk1JTklNVU1fV0lEVEggPSAyMDA7XG4gICAgICAgIHRoaXMuTUlOSU1VTV9IRUlHSFQgPSAyMDA7XG4gICAgICAgIHRoaXMuREVGQVVMVF9IRUlHSFQgPSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCk7IC8vIExldCBDU1MgZGVmaW5lIHRoaXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuXG4gICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQ7XG4gICAgICAgIC8vdGhpcy5pbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZSB1c2VyIG1vZGlmaWVzIGEgZmlsZSwgdGhlbiBtYWtlIHRoZSBjb25zb2xlIGxvb2sgZmFkZWQgYSBsaXR0bGVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXR1cyBvZiB0aGUgcHJpbnRlciwgaW5jbHVkaW5nIHJlbW92aW5nIGFueSB0ZXh0IGluIGl0IGFuZFxuICAgICAqIGZpeGluZyBpdHMgc2l6ZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbG90QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmVtcHR5KCk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIHJlc2V0IGl0XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KHRoaXMuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBudWxsO1xuICAgICAgICBTay5UdXJ0bGVHcmFwaGljcyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRUdXJ0bGVMaW5lLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgYXNzZXRzOiB0aGlzLmxvYWRBc3NldC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5weWdhbWVMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFmdGVyTGluZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGxvYWRBc3NldChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGdldFR1cnRsZUxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR1cnRsZUxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudHVydGxlTGluZSA9IG5ldyBDb25zb2xlTGluZVR1cnRsZSh0aGlzLm1haW4pO1xuICAgICAgICAgICAgdGhpcy50dXJ0bGVMaW5lLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgd2UnbGwgZG8gc29cbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQoKSA9PT0gdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQcmludGVyRGltZW5zaW9uID0gdGhpcy5wcmludGVyVGFnLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludGVyVGFnLmhlaWdodChjdXJyZW50UHJpbnRlckRpbWVuc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgU2suVHVydGxlR3JhcGhpY3MuaGVpZ2h0ID0gY3VycmVudFByaW50ZXJEaW1lbnNpb24tNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHVydGxlTGluZS5odG1sWzBdO1xuICAgIH1cblxuICAgIGhhbmRsZVB5Z2FtZVJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIGFuZCB0aGUgbmV3SGVpZ2h0IGlzIGJpZ2dlciB0aGFuIGRlZmF1bHQsIHdlJ2xsIGNoYW5nZSBpdFxuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KCkgPT09IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSAmJlxuICAgICAgICAgICAgbmV3SGVpZ2h0ID4gdGhpcy5ERUZBVUxUX0hFSUdIVCkge1xuICAgICAgICAgICAgdGhpcy5wcmludGVyVGFnLmhlaWdodCgzMCtuZXdIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHB5Z2FtZSB3aW5kb3cgaXMgd2lkZXIgdGhhbiB0aGUgY29uc29sZSwgd2UnbGwgZXhwYW5kIHRlbXBvcmFyaWx5LlxuICAgICAgICBpZiAobmV3V2lkdGggPiB0aGlzLnByaW50ZXJUYWcud2lkdGgoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNlY29uZFJvdy5tYWtlV2lkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmluaXNoVHVydGxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNhdmVUdXJ0bGVPdXRwdXQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHVydGxlTGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnR1cnRsZUxpbmUuaHRtbC5maW5kKFwiY2FudmFzXCIpLmxhc3QoKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVJbWFnZShcInR1cnRsZV9vdXRwdXRcIiwgZGF0YVVybCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHlnYW1lTGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnB5Z2FtZUxpbmUuY2FudmFzO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUltYWdlKFwidHVydGxlX291dHB1dFwiLCBkYXRhVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB0aGVyZSBhcmUgbm8gdHVydGxlcyB0byBzYXZlP1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdHVydGxlcyBzaG91bGQgYmUgYmFzZWQgb24gdGhlIGN1cnJlbnQgd2lkdGhcbiAgICBuZXdUdXJ0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5NSU5JTVVNX1dJRFRILCB0aGlzLnByaW50ZXJUYWcud2lkdGgoKS00MCk7XG4gICAgfVxuXG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5NSU5JTVVNX0hFSUdIVCwgdGhpcy5wcmludGVyVGFnLmhlaWdodCgpKzQwKTtcbiAgICB9XG5cbiAgICBpc011dGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGVhY2ggcHJpbnRlZCBlbGVtZW50IGluIHRoZSBwcmludGVyIGFuZCBtYWtlcyBpdCBoaWRkZW5cbiAgICAgKiBvciB2aXNpYmxlLCBkZXBlbmRpbmcgb24gd2hhdCBzdGVwIHdlJ3JlIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXAgLSBUaGUgY3VycmVudCBzdGVwIG9mIHRoZSBleGVjdXRlZCBwcm9ncmFtIHRoYXQgd2UncmUgb247IGVhY2ggZWxlbWVudCBpbiB0aGUgcHJpbnRlciBtdXN0IGJlIG1hcmtlZCB3aXRoIGEgXCJkYXRhLXN0ZXBcIiBwcm9wZXJ0eSB0byByZXNvbHZlIHRoaXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgLSBEZXByZWNhdGVkLCBub3Qgc3VyZSB3aGF0IHRoaXMgZXZlbiBkb2VzLlxuICAgICAqL1xuICAgIHN0ZXBQcmludGVyKHN0ZXAsIHBhZ2UpIHtcbiAgICAgICAgdGhpcy5wcmludGVyVGFnLmZpbmQoXCIuYmxvY2tweS1wcmludGVyLW91dHB1dFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuYXR0cihcImRhdGEtc3RlcFwiKSA8PSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQodGhpcykuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpbnQgYSBsaW5lIHRvIHRoZSBvbi1zY3JlZW4gcHJpbnRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVRleHQgLSBBIGxpbmUgb2YgdGV4dCB0byBiZSBwcmludGVkIG91dC5cbiAgICAgKi9cbiAgICBwcmludChsaW5lVGV4dCkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIG1lYW5zIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIHByaW50KFwiXCIsIGVuZD1cIlwiKVxuICAgICAgICBpZiAoIWxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChsaW5lVGV4dC5jaGFyQXQobGluZVRleHQubGVuZ3RoLTEpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBmbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwbGl0TGluZXMgPSBsaW5lVGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lVGV4dCh0aGlzLm1haW4sIENvbnNvbGVMaW5lVHlwZS5URVhULCBzcGxpdExpbmVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5hZGRDb250ZW50KHNwbGl0TGluZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MTsgaSA8IHNwbGl0TGluZXMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQucHVzaCh0aGlzLmxpbmVCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICAgICAgdGhpcy5saW5lQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lVGV4dCh0aGlzLm1haW4sIENvbnNvbGVMaW5lVHlwZS5URVhULCBzcGxpdExpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGhpcy5saW5lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBwbG90KHBsb3RzKSB7XG4gICAgICAgIHRoaXMucGxvdEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVBsb3QodGhpcy5tYWluLCBwbG90cyk7XG4gICAgICAgIHRoaXMucGxvdEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdEJ1ZmZlcjtcbiAgICB9XG5cbiAgICBweWdhbWUoc2l6ZSwgZnVsbHNjcmVlbiwgcHlnYW1lT2JqKSB7XG4gICAgICAgIGlmICh0aGlzLnB5Z2FtZUxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucHlnYW1lTGluZSA9IG5ldyBDb25zb2xlTGluZVB5Z2FtZSh0aGlzLm1haW4sIHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaik7XG4gICAgICAgICAgICB0aGlzLnB5Z2FtZUxpbmUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHlnYW1lTGluZTtcbiAgICB9XG5cbiAgICBkcmFmdGVyKHNpemUsIGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZnRlckxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZnRlckxpbmUgPSBuZXcgQ29uc29sZUxpbmVEcmFmdGVyKHRoaXMubWFpbiwgc2l6ZSwgZnVsbHNjcmVlbik7XG4gICAgICAgICAgICB0aGlzLmRyYWZ0ZXJMaW5lLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWZ0ZXJMaW5lO1xuICAgIH1cblxuICAgIHByaW50UElMSW1hZ2UoaW1hZ2VEYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVEVTVFwiLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gbmV3IENvbnNvbGVMaW5lSW1hZ2UodGhpcy5tYWluLCBpbWFnZURhdGEuaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwcmludFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBwcmludGVkVmFsdWUgPSBuZXcgQ29uc29sZUxpbmVWYWx1ZSh0aGlzLm1haW4sIHZhbHVlKTtcbiAgICAgICAgcHJpbnRlZFZhbHVlLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICByZXR1cm4gcHJpbnRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIFByb21pc2UgZnJvbSB0aGUgSW5wdXQgYm94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb21wdE1lc3NhZ2UgLSBNZXNzYWdlIHRvIGRpc3BsYXkgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbnB1dCh0aGlzLm1haW4sIHByb21wdE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dEJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9O1xuXG5cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUV2YWx1YXRlKHRoaXMubWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIGJlZ2luRXZhbCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RXZhbHVhdGlvbiA9IG5ldyBDb25zb2xlTGluZVN0YXJ0RXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RXZhbHVhdGlvbi5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmNvbmRpdGlvbmFsbHkgc2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKCkge1xuICAgICAgICB0aGlzLnRhZy5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcucHJvcChcInNjcm9sbEhlaWdodFwiKSAtIHRoaXMudGFnLnByb3AoXCJjbGllbnRIZWlnaHRcIilcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuXG59IiwiaW1wb3J0IHtzbHVnfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLy8gVE9ETzogZWRpdG9yLmJtLmJsb2NrRWRpdG9yLmV4dHJhVG9vbHNbXVxuXG5leHBvcnQgbGV0IF9JTVBPUlRFRF9EQVRBU0VUUyA9IHt9O1xuZXhwb3J0IGxldCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMgPSB7fTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgdmVyeSBzaW1wbGlzdGljIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgdHJhbnNmb3JtXG4gKiBhIGdpdmVuIGJ1dHRvbiBpbnRvIGEgXCJMb2FkZWRcIiBzdGF0ZSAoZGlzYWJsZWQsIHByZXNzZWQgc3RhdGUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ0biAtIEFuIEhUTUwgZWxlbWVudCB0byBjaGFuZ2UgdGhlIHRleHQgb2YuXG4gKi9cbmxldCBzZXRCdXR0b25Mb2FkZWQgPSBmdW5jdGlvbiAoYnRuKSB7XG4gICAgYnRuLmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpXG4gICAgICAgIC5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLnRleHQoXCJMb2FkZWRcIilcbiAgICAgICAgLmF0dHIoXCJhcmlhLXByZXNzZWRcIiwgXCJ0cnVlXCIpO1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGNvbm5lY3RzIHRvIHRoZSBDT1JHSVMgZGF0YXNldHMgYW5kIG1hbmFnZXMgaW50ZXJhY3Rpb25zXG4gKiB3aXRoIHRoZW0uIFRoaXMgaW5jbHVkZXMgbG9hZGluZyBpbiBkYXRhc2V0cyBhdCBsYXVuY2ggYW5kIG9uLXRoZS1mbHkuXG4gKiBOb3RlIHRoYXQgdGhpcyBoYXMgbm8gcHJlc2VuY2Ugb24gc2NyZWVuLCBzbyBpdCBkb2VzIG5vdCBoYXZlIGEgdGFnLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlDb3JnaXN9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlDb3JnaXMobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICB0aGlzLmxvYWRlZERhdGFzZXRzID0gW107XG4gICAgdGhpcy5sb2FkRGF0YXNldHMoKTtcbn1cblxuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUubG9hZERhdGFzZXRzID0gZnVuY3Rpb24gKHNpbGVudGx5KSB7XG4gICAgLy8gTG9hZCBpbiBlYWNoIHRoZSBkYXRhc2V0c1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbCxcbiAgICAgICAgZWRpdG9yID0gdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLFxuICAgICAgICBzZXJ2ZXIgPSB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXI7XG4gICAgbGV0IGltcG9ydHMgPSBbXTtcbiAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzKCkuc3BsaXQoXCIsXCIpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIShuYW1lIGluIEJsb2NrTWlycm9yQmxvY2tFZGl0b3IuRVhUUkFfVE9PTFMpKSB7XG4gICAgICAgICAgICBpbXBvcnRzLnB1c2guYXBwbHkoaW1wb3J0cywgdGhpcy5pbXBvcnREYXRhc2V0KHNsdWcobmFtZSksIG5hbWUsIHNpbGVudGx5KSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgYXJlIGxvYWRlZCwgdXBkYXRlIHRoZSB0b29sYm94LlxuICAgICQud2hlbi5hcHBseSgkLCBpbXBvcnRzKS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRSSUdHRVJFRFwiKTtcbiAgICAgICAgZWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgIGVkaXRvci5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlcnZlci5maW5hbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIGRlZmluaXRpb25zIGZvciBhIGRhdGFzZXQgaW50byB0aGUgZW52aXJvbm1lbnQsIGluY2x1ZGluZ1xuICogdGhlIGRhdGFzZXQgKGFzIGEgSlMgZmlsZSksIHRoZSBza3VscHQgYmluZGluZ3MsIGFuZCB0aGUgYmxvY2tseVxuICogYmluZGluZ3MuIFRoaXMgcmVxdWlyZXMgYWNjZXNzIHRvIGEgQ09SR0lTIHNlcnZlciwgYW5kIG9jY3Vyc1xuICogYXN5bmNocm9ub3VzbHkuIFRoZSByZXF1ZXN0cyBhcmUgZmlyZWQgYW5kIHRoZWlyIGRlZmVycmVkIG9iamVjdHNcbiAqIGFyZSByZXR1cm5lZCAtIGNhbGxlcnMgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIHBlcmZvcm0gYW4gYWN0aW9uXG4gKiBvbiBjb21wbGV0aW9uIG9mIHRoZSBpbXBvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNsdWcgLSBUaGUgVVJMIHNhZmUgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSB1c2VyLWZyaWVuZGx5IHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheS48RGVmZXJyZWQ+fSAtIFJldHVybnMgdGhlIGFzeW5jIHJlcXVlc3RzIGFzIGRlZmVycmVkIG9iamVjdHMuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLmltcG9ydERhdGFzZXQgPSBmdW5jdGlvbiAoc2x1ZywgbmFtZSkge1xuICAgIGxldCB1cmxfcmV0cmlldmFscyA9IFtdO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJpbXBvcnREYXRhc2V0c1wiKSkge1xuICAgICAgICBsZXQgcm9vdCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW1wb3J0RGF0YXNldHMgKyBcImJsb2NrcHkvXCIgKyBzbHVnICsgXCIvXCIgKyBzbHVnO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5sb2FkaW5nRGF0YXNldHMucHVzaChuYW1lKTtcbiAgICAgICAgLy8gQWN0dWFsbHkgZ2V0IGRhdGFcbiAgICAgICAgbGV0IGdldERhdGFzZXQgPSAkLmdldFNjcmlwdChyb290ICsgXCJfZGF0YXNldC5qc1wiKTtcbiAgICAgICAgLy8gTG9hZCBnZXRDb21wbGV0ZSBzaWxlbnRseSBpbiB0aGUgYmFja2dyb3VuZCBiZWNhdXNlIGl0cyBiaWcgOihcbiAgICAgICAgbGV0IGdldENvbXBsZXRlID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2NvbXBsZXRlLmpzXCIpO1xuICAgICAgICBsZXQgZ2V0U2t1bHB0ID0gJC5nZXQocm9vdCArIFwiX3NrdWxwdC5qc1wiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bXCJzcmMvbGliL1wiICsgc2x1ZyArIFwiL19faW5pdF9fLmpzXCJdID0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnZXRCbG9ja2x5ID0gJC5nZXRTY3JpcHQocm9vdCArIFwiX2Jsb2NrbHkuanNcIik7XG4gICAgICAgIC8vIE9uIGNvbXBsZXRpb24sIHVwZGF0ZSBtZW51cy5cbiAgICAgICAgJC53aGVuKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZERhdGFzZXRzLnB1c2goc2x1Zyk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dFRvQmxvY2tzLmhpZGRlbkltcG9ydHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5mb3JjZUJsb2NrUmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1cmxfcmV0cmlldmFscy5wdXNoKGdldERhdGFzZXQsIGdldFNrdWxwdCwgZ2V0QmxvY2tseSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxfcmV0cmlldmFscztcbn07XG5cbi8qKlxuICogT3BlbnMgYSBkaWFsb2cgYm94IHRvIHByZXNlbnQgdGhlIHVzZXIgd2l0aCB0aGUgZGF0YXNldHMgYXZhaWxhYmxlXG4gKiB0aHJvdWdoIHRoZSBDT1JHSVMgc2VydmVyLiBUaGlzIHJlcXVpcmVzIGEgY2FsbCwgc28gdGhpcyBtZXRob2RcbiAqIGNvbXBsZXRlcyBhc3luY2hyb25vdXNseS4gVGhlIGRpYWxvZyBpcyBjb21wb3NlZCBvZiBhIHRhYmxlIHdpdGhcbiAqIGJ1dHRvbnMgdG8gbG9hZCB0aGUgZGF0YXNldHMgKE1vcmUgdGhhbiBvbmUgZGF0YXNldCBjYW4gYmUgbG9hZGVkXG4gKiBmcm9tIHdpdGhpbiB0aGUgZGlhbG9nIGF0IGEgdGltZSkuXG4gKi9cbkJsb2NrUHlDb3JnaXMucHJvdG90eXBlLm9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cztcbiAgICAgICAgJC5nZXRKU09OKHJvb3QgKyBcImluZGV4Lmpzb25cIiwgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHVwIHRoZSBCb2R5XG4gICAgICAgICAgICBsZXQgZGF0YXNldHMgPSBkYXRhLmJsb2NrcHk7XG4gICAgICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHJvb3QrXCJibG9ja3B5L2luZGV4Lmh0bWxcIjtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICQoYDxwPkRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0IDxhIGhyZWY9JyR7ZG9jdW1lbnRhdGlvbn0nIHRhcmdldD1fYmxhbms+dXJsPC9hPjwvcD5gKTtcbiAgICAgICAgICAgIGxldCBib2R5ID0gJChcIjx0YWJsZT48L3RhYmxlPlwiLCB7XCJjbGFzc1wiOiBcInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWRcIn0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YXNldHMpLnNvcnQoKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2x1Z2dlZE5hbWUgPSBzbHVnKGRhdGFzZXRzW25hbWVdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGxldCBidG4gPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIiBhdXRvY29tcGxldGU9XCJvZmZcIj5Mb2FkPC9idXR0b24+Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGltZ1NyYyA9IHJvb3QrXCIuLi9pbWFnZXMvZGF0YXNldHMvXCIrbmFtZStcIi1pY29uLnBuZ1wiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZERhdGFzZXRzLmluZGV4T2Yoc2x1Z2dlZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnRuLmNsaWNrKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydERhdGFzZXQoc2x1Z2dlZE5hbWUsIFwiRGF0YSAtIFwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnV0dG9uTG9hZGVkKGJ0bik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xldCBpbWcgPSBgPGltZyBzcmM9JyR7aW1nU3JjfScgY2xhc3M9XCJjb3JnaXMtaWNvblwiPmA7XG4gICAgICAgICAgICAgICAgJChcIjx0cj48L3RyPlwiKVxuICAgICAgICAgICAgICAgICAgICAvLy5hcHBlbmQoJChcIjx0ZD5cIiArIGltZyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD5cIiArIGRhdGFzZXRzW25hbWVdLnRpdGxlICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0ub3ZlcnZpZXcgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+PC90ZD5cIikuYXBwZW5kKGJ0bikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhib2R5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRUbyhzdGFydCk7XG4gICAgICAgICAgICAvLyBTaG93IHRoZSBhY3R1YWwgZGlhbG9nXG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuc2hvdyhcIkltcG9ydCBEYXRhc2V0c1wiLCBzdGFydCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3MjcxMDQ1MDY1NzJcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvYWNiYXIvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzI3MTA0NTA2NTc2XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL2FjYmFyL1Byb2plY3RzL2Jsb2NrcHktZWR1L2Jsb2NrcHkvbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiLi4vXCIsXCJobXJcIjp0cnVlLFwibG9jYWxzXCI6ZmFsc2V9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgbW9kdWxlLmhvdC5hY2NlcHQodW5kZWZpbmVkLCBjc3NSZWxvYWQpO1xuICAgIH1cbiAgIiwiLy8gVE9ETzogRHlhbm1pY2FsbHkgcG9wdWxhdGUgYXJpYS1sYWJlbGxlZGJ5IGluIHRoaXMgYW5kIG90aGVyIHBsYWNlc1xuXG5leHBvcnQgbGV0IERJQUxPR19IVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktZGlhbG9nIG1vZGFsIGhpZGRlbidcbiAgICAgICAgIHJvbGU9XCJkaWFsb2dcIlxuICAgICAgICAgYXJpYS1sYWJlbD0nRGlhbG9nJ1xuICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgIGFyaWEtbW9kYWw9XCJ0cnVlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWRpYWxvZyBtb2RhbC1sZycgcm9sZT1cImRvY3VtZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1jb250ZW50JyByb2xlPSdyZWdpb24nIGFyaWEtbGFiZWw9J0RpYWxvZyBjb250ZW50Jz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1oZWFkZXInPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9J21vZGFsLXRpdGxlJz5EeW5hbWljIENvbnRlbnQ8L2g0PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2Nsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJyBhcmlhLWhpZGRlbj0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5JyBzdHlsZT0nbWF4LXdpZHRoOjEwMCU7IG1heC1oZWlnaHQ6NDAwcHgnPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSBtb2RhbC1jbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+Q2xvc2U8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXN1Y2Nlc3MgbW9kYWwtb2theScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+T2theTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbmA7XG5cbi8qKlxuICogQSB1dGlsaXR5IG9iamVjdCBmb3IgcXVpY2tseSBhbmQgY29udmVuaWVudGx5IGdlbmVyYXRpbmcgZGlhbG9nIGJveGVzLlxuICogVW5mb3J0dW5hdGVseSwgdGhpcyBkb2Vzbid0IGR5bmFtaWNhbGx5IGNyZWF0ZSBuZXcgYm94ZXM7IGl0IHJldXNlcyB0aGUgc2FtZSBvbmVcbiAqIG92ZXIgYW5kIG92ZXIgYWdhaW4uIEl0IHR1cm5zIG91dCBkeW5hbWljYWxseSBnZW5lcmF0aW5nIG5ldyBkaWFsb2cgYm94ZXNcbiAqIGlzIGEgcGFpbiEgU28gd2UgY2FuJ3Qgc3RhY2sgdGhlbS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5RGlhbG9nfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlEaWFsb2cobWFpbiwgdGFnKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgIHRoaXMudGl0bGVUYWcgPSB0YWcuZmluZChcIi5tb2RhbC10aXRsZVwiKTtcbiAgICB0aGlzLmJvZHlUYWcgPSB0YWcuZmluZChcIi5tb2RhbC1ib2R5XCIpO1xuICAgIHRoaXMuZm9vdGVyVGFnID0gdGFnLmZpbmQoXCIubW9kYWwtZm9vdGVyXCIpO1xuICAgIHRoaXMub2theUJ1dHRvbiA9IHRhZy5maW5kKFwiLm1vZGFsLW9rYXlcIik7XG4gICAgdGhpcy5jbG9zZUJ1dHRvbiA9IHRhZy5maW5kKFwiLm1vZGFsLWNsb3NlXCIpO1xuXG4gICAgdGhpcy55ZXMgPSAoKSA9PiB7fTtcbiAgICB0aGlzLm5vID0gKCkgPT4ge307XG4gICAgdGhpcy5va2F5QnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy55ZXMoKTtcbiAgICAgICAgdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xuICAgIH0pO1xuICAgIHRoaXMuY2xvc2VCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLm5vKCk7XG4gICAgICAgIC8vdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xuICAgIH0pO1xufVxuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhZy5tb2RhbChcImhpZGVcIik7XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGV4dGVybmFsbHkgYXZhaWxhYmxlIGZ1bmN0aW9uIGZvciBwb3BwaW5nIHVwIGEgZGlhbG9nXG4gKiBtZXNzYWdlLiBUaGlzIG1lbnUgd2lsbCBiZSBkcmFnZ2FibGUgYnkgaXRzIHRpdGxlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgbWVzc2FnZSBkaWFsb2cuIENhbiBoYXZlIEhUTUwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBtZXNzYWdlIGRpYWxvZy4gQ2FuIGhhdmUgSFRNTC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uY2xvc2UgLSBBIGZ1bmN0aW9uIHRvIGJlIHJ1biB3aGVuIHRoZSB1c2VyIGNsb3NlcyB0aGUgZGlhbG9nLlxuICovXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHRpdGxlLCBib2R5LCBvbmNsb3NlKSB7XG4gICAgdGhpcy50aXRsZVRhZy5odG1sKHRpdGxlKTtcbiAgICB0aGlzLmJvZHlUYWcuaHRtbChib2R5KTtcbiAgICB0aGlzLnRhZy5tb2RhbChcInNob3dcIik7XG4gICAgdGhpcy5va2F5QnV0dG9uLmhpZGUoKTtcbiAgICB0aGlzLnRhZy5kcmFnZ2FibGUoe1xuICAgICAgICBcImhhbmRsZVwiOiBcIi5tb2RhbC10aXRsZVwiXG4gICAgfSk7XG5cbiAgICB0aGlzLnRhZy5vbihcImhpZGRlbi5icy5tb2RhbFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAob25jbG9zZSAhPT0gdW5kZWZpbmVkICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uICh0aXRsZSwgYm9keSwgeWVzLCBubywgeWVzVGV4dCkge1xuICAgIGlmICh5ZXNUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWVzVGV4dCA9IFwiT2theVwiO1xuICAgIH1cbiAgICB0aGlzLnNob3codGl0bGUsIGJvZHksIG5vKTtcbiAgICB0aGlzLnllcyA9IHllcztcbiAgICB0aGlzLm5vID0gbm87XG4gICAgdGhpcy5va2F5QnV0dG9uLnNob3coKS5odG1sKHllc1RleHQpO1xuICAgIC8vIFRPRE86IGFkZCBva2F5IGJ1dHRvbiBhbmQgY2FuY2VsIGJ1dHRvblxufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuQVNTSUdOTUVOVF9WRVJTSU9OX0NIQU5HRUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25maXJtKFwiQXNzaWdubWVudCBDaGFuZ2VkXCIsIFwiWW91ciBpbnN0cnVjdG9yIGhhcyBtYWRlIGNoYW5nZXMgdG8gdGhpcyBhc3NpZ25tZW50LiBXb3VsZCB5b3UgbGlrZSB0byByZWxvYWQ/IEFsbCB5b3VyIHdvcmsgaGFzIGJlZW4gc2F2ZWQuXCIsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgTG9hZGluZyBBc3NpZ25tZW50XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIGFzc2lnbm1lbnQuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBMaXN0aW5nIFVwbG9hZGVkIEZpbGVzXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgdGhlIHVwbG9hZGVkIGZpbGVzLjxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1VQTE9BRElOR19GSUxFID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFVwbG9hZGVkIEZpbGVcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgdXBsb2FkaW5nIHRoZSBmaWxlLjxicj5cblBsZWFzZSB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9ET1dOTE9BRElOR19GSUxFID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIERvd25sb2FkaW5nIEZpbGVcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZG93bmxvYWRpbmcgYSBmaWxlLjxicj5cblBsZWFzZSB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9SRU5BTUlOR19GSUxFID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFJlbmFtaW5nIEZpbGVcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgcmVuYW1pbmcgYSBmaWxlLjxicj5cblBsZWFzZSB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9ERUxFVElOR19GSUxFID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIERlbGV0aW5nIEZpbGVcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVsZXRpbmcgYSBmaWxlLjxicj5cblBsZWFzZSB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgU2F2aW5nIEFzc2lnbm1lbnRcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgc2F2aW5nIHRoZSBhc3NpZ25tZW50Ljxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUiA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRoaXMuc2hvdyhcIk9yaWdpbmFsIEVycm9yXCIsIGBXaGVuIEkgcmFuIHlvdXIgY29kZSwgSSBlbmNvdW50ZXJlZCBhbiBlcnJvcjpcXG5cXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1kaWFsb2ctc3R1ZGVudC1lcnJvci1tZXNzYWdlXCI+JHtlcnJvcn08L2Rpdj5gKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwgPSBmdW5jdGlvbiAodGl0bGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLnNob3codGl0bGUsIG1lc3NhZ2UpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuU0NSRUVOU0hPVF9CTE9DS1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ET1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgVXBkYXRpbmcgU3VibWlzc2lvbiBTdGF0dXNcIiwgYEJsb2NrUHkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgdXBkYXRpbmcgeW91ciBzdWJtaXNzaW9uIHN0YXR1cy48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9MT0FESU5HX0hJU1RPUlkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgTG9hZGluZyBIaXN0b3J5XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGxvYWRpbmcgeW91ciBoaXN0b3J5Ljxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi5gKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLk9GRkVSX0ZPUksgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNldHVwVXJsID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbnN0cnVjdGlvbnNBc3NpZ25tZW50U2V0dXA7XG4gICAgc2V0dXBVcmwgPSBzZXR1cFVybCA/IGAgKDxhIGhyZWY9XCIke3NldHVwVXJsfVwiIHRhcmdldD1cIl9ibGFua1wiPkhvdyBkbyBJIGRvIHRoYXQ/PC9hPilgIDogXCJcIjtcbiAgICB0aGlzLnNob3coXCJBc3NpZ25tZW50IE5vdCBPd25lZDsgRm9yaz9cIiwgYFxuICAgIDxkaXYgY2xhc3M9XCJtYi00XCI+XG4gICAgICAgIEl0IGxvb2tzIGxpa2UgeW91IHdhbnQgdG8gZWRpdCB0aGlzIGFzc2lnbm1lbnQsIGJ1dCB5b3UgYXJlIG5vdCBhbiBpbnN0cnVjdG9yXG4gICAgb3IgZGVzaWduZXIgaW4gdGhlIGNvdXJzZSB0aGF0IG93bnMgaXQgKFwiQ291cnNlIE5hbWVcIikuIFdvdWxkIHlvdSBsaWtlIHRvIGZvcmtcbiAgICB0aGlzIGFzc2lnbm1lbnQgKG9yIGl0cyBlbnRpcmUgZ3JvdXApIHNvIHRoYXQgeW91IGNhbiBzYXZlIHlvdXIgbW9kaWZpY2F0aW9ucz9cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwibWItNFwiPlxuICAgICAgICBSZW1lbWJlciB0byB1cGRhdGUgdGhlIExhdW5jaCBVUkwgaW4gdGhlIGFzc2lnbm1lbnRzJyBzZXR0aW5ncyBvbiBDYW52YXMhJHtzZXR1cFVybH1cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSc+Rm9yayBlbnRpcmUgYXNzaWdubWVudCBncm91cDwvYnV0dG9uPjwvZGl2PlxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLXdoaXRlJz5Gb3JrIGp1c3QgdGhpcyBhc3NpZ25tZW50PC9idXR0b24+PC9kaXY+XG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tZGFuZ2VyJz5SZXNldCBteSBsb2NhbCBjaGFuZ2VzPC9idXR0b24+PC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiXG4gICAgICAgICAgICAgICAgbmFtZT1cImJsb2NrcHktdHJhbnNmZXItc3VibWlzc2lvbnNcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktdHJhbnNmZXItc3VibWlzc2lvbnNcIj5UcmFuc2ZlciBTdHVkZW50IFN1Ym1pc3Npb25zIGZvciB0aGlzIGNvdXJzZTwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLXRleHRcIiBmb3I9XCJibG9ja3B5LWNvdXJzZS1pZFwiPk5ldyBvd25pbmcgY291cnNlIGlkOiA8L2xhYmVsPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiYmxvY2tweS1jb3Vyc2UtaWRcIiB2YWx1ZT1cIiR7dGhpcy5tYWluLm1vZGVsLnVzZXIuY291cnNlSWQoKX1cIj5cbiAgICA8L2Rpdj5cbiAgICBgKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVESVRfSU5QVVRTID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBpbnB1dFRleHQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkuam9pbihcIlxcblwiKTtcbiAgICBsZXQgY2xlYXJJbnB1dHMgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cygpID8gXCJcIiA6IFwiY2hlY2tlZFwiO1xuICAgIGxldCB5ZXMgPSAoKSA9PiB7XG4gICAgICAgIGxldCBjaGVja2VkID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiKS5wcm9wKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgbGV0IGlucHV0cyA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1pbnB1dC1saXN0XCIpLnZhbCgpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cyghY2hlY2tlZCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoaW5wdXRzKTtcbiAgICB9O1xuICAgIHRoaXMuY29uZmlybShcIkVkaXQgUmVtZW1iZXJlZCBJbnB1dHNcIiwgYFxuXG48ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHMgZm9ybS1jaGVjay1pbnB1dFwiXG4gICAgICAgIG5hbWU9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiICR7Y2xlYXJJbnB1dHN9PlxuPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzXCI+UmV1c2UgaW5wdXRzIGZvciBuZXh0IGV4ZWN1dGlvbjwvbGFiZWw+XG48L2Rpdj5cblxuPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1pbnB1dC1saXN0IGZvcm0tY29udHJvbFwiIHJvd3M9XCI0XCI+JHtpbnB1dFRleHR9PC90ZXh0YXJlYT48YnI+XG5FZGl0IHRoZSBpbnB1dHMgYWJvdmUgdG8gc3RvcmUgYW5kIHJldXNlIHRoZW0gYWNyb3NzIG11bHRpcGxlIGV4ZWN1dGlvbnMuXG5FYWNoIGlucHV0IHNob3VsZCBiZSBwdXQgb24gaXRzIG93biBsaW5lLlxuWW91IGRvIG5vdCBuZWVkIHF1b3RlczsgdGhlIHRleHQgd2lsbCBiZSBlbnRlcmVkIGxpdGVyYWxseS5cbiBcbmAsIHllcywgdGhpcy5ubywgXCJTYXZlXCIpO1xuICAgIC8vIFRPRE86IEFsbG93IHVzZXIgdG8gc3BlY2lmeSB0aGUgaW5maW5pdGUgc3RyaW5nIHRvIGtlZXAgZ2l2aW5nIHdoZW4gdGhlIG90aGVycyBydW4gb3V0XG59OyIsImltcG9ydCB7RWRpdG9yc30gZnJvbSBcIi4uL2VkaXRvcnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZEZpbGUobW9kZWwsIGV2ZW50KSB7XG4gICAgbGV0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGxldCBmaWxlcyA9IGV2ZW50LnRhcmdldC5maWxlcztcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IChlID0+XG4gICAgICAgIG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpLnVwbG9hZEZpbGUoZSlcbiAgICApO1xuICAgIGZpbGVSZWFkZXIuZmlsZU5hbWUgPSBmaWxlc1swXS5uYW1lO1xuICAgIGZpbGVSZWFkZXIucmVhZEFzVGV4dChmaWxlc1swXSk7XG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gXCJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsdWdnaWZ5KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXmEtejAtOV0vZ2ksIFwiX1wiKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRGaWxlKG1vZGVsLCBldmVudCkge1xuICAgIGxldCB7bmFtZSwgZXh0ZW5zaW9uLCBjb250ZW50cywgbWltZXR5cGV9ID0gbW9kZWwudWkuZWRpdG9ycy5jdXJyZW50KCkuZG93bmxvYWRGaWxlKCk7XG4gICAgLy8gTWFrZSBzYWZlXG4gICAgbmFtZSA9IHNsdWdnaWZ5KG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lICsgZXh0ZW5zaW9uO1xuICAgIC8vIE1ha2UgdGhlIGRhdGEgZG93bmxvYWQgYXMgYSBmaWxlXG4gICAgbGV0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudHNdLCB7dHlwZTogbWltZXR5cGV9KTtcbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG4gICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iLCBuYW1lKTtcbiAgICB9IGVsc2V7XG4gICAgICAgIGxldCB0ZW1wb3JhcnlEb3dubG9hZExpbmsgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcG9yYXJ5RG93bmxvYWRMaW5rKTtcbiAgICAgICAgdGVtcG9yYXJ5RG93bmxvYWRMaW5rLmNsaWNrKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcG9yYXJ5RG93bmxvYWRMaW5rKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbSA9IG1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZWxldGVGaWxlKCkge1xuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0uZGVsZXRlRmlsZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmVkaXRvcnMuY2hhbmdlRWRpdG9yKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIG9uRmlsZURlbGV0ZWQoKSB7XG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0byB0aGUgcHJldmlvdXMgZmlsZSBpbnN0ZWFkIG9mIGEgZGVmYXVsdCBmaWxlXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcihcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICBvbkZpbGVVcGRhdGVkKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuZmlsZW5hbWUgPT09IHRoaXMuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmVkaXRvcnMuY2hhbmdlRWRpdG9yKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy90aGlzLmZpbGVTeXN0ZW0uc3RvcFdhdGNoaW5nRmlsZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vdGhpcy50cmFja0N1cnJlbnRGaWxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFja0N1cnJlbnRGaWxlKCkge1xuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0ud2F0Y2hGaWxlKHRoaXMuZmlsZW5hbWUsIHtcbiAgICAgICAgICAgIHVwZGF0ZWQ6IHRoaXMub25GaWxlVXBkYXRlZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVsZXRlZDogdGhpcy5vbkZpbGVEZWxldGVkLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbmV3RmlsZW5hbWU7XG4gICAgICAgIHRoaXMuZmlsZSA9IHRoaXMuZmlsZVN5c3RlbS5nZXRGaWxlKG5ld0ZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy50cmFja0N1cnJlbnRGaWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3RmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgdGhhdCB0aGUgb3RoZXIgZWRpdG9yIHdpbGwgYmUgc3dpdGNoaW5nIHRvXG4gICAgICogQHBhcmFtIG9sZEVkaXRvclxuICAgICAqIEBwYXJhbSBuZXdFZGl0b3JcbiAgICAgKi9cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0uc3RvcFdhdGNoaW5nRmlsZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5maWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdXBsb2FkRmlsZShldmVudCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBldmVudC50YXJnZXQuZmlsZU5hbWU7XG4gICAgICAgIGxldCBjb250ZW50cyA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIHRoaXMuZmlsZS5oYW5kbGUoY29udGVudHMpO1xuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZSgpIHtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gRWRpdG9ycy5wYXJzZUZpbGVuYW1lKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogZmlsZW5hbWUubmFtZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbjogZmlsZW5hbWUudHlwZSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmZpbGUuaGFuZGxlKCksXG4gICAgICAgICAgICBtaW1ldHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgfTtcbiAgICB9XG59IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0Rpc3BsYXlNb2Rlc30gZnJvbSBcIi4vcHl0aG9uXCI7XG5cbmNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1MgPSBbXG4gICAgW1widG9vbGJveFwiLCBcInRvb2xib3hcIiwgXCJub3JtYWxcIiwgXCJ0b29sYm94XCIsIFwiV2hpY2ggdmVyc2lvbiBvZiB0aGUgdG9vbGJveCB0byBwcmVzZW50IHRvIHRoZSB1c2VyLlwiXSxcbiAgICBbXCJ0eXBlXCIsIFwidHlwZVwiLCBcImJsb2NrcHlcIiwgXCJ0eXBlXCIsIFwiVGhlIHR5cGUgb2YgcXVlc3Rpb247IEJsb2NrUHkgcHJvZ3JhbW1pbmcgcHJvYmxlbXMgYXJlIHRoZSBkZWZhdWx0LCBidXQgd2UgYWxzbyBzdXBwb3J0IHN0YXRpYyByZWFkaW5ncywgcXVpeiBxdWVzdGlvbnMsIGFuZCBhIE1hemUgZ2FtZS5cIl0sXG4gICAgW1wicGFzc2NvZGVcIiwgXCJwYXNzY29kZVwiLCBcIlwiLCBcInN0cmluZ1wiLCBcIkEgc3RyaW5nIHRoYXQgdGhlIHVzZXIgbXVzdCBlbnRlciB0byBhY2Nlc3MgdGhlIHByb2JsZW0uIElmIGJsYW5rLCB0aGVuIG5vIHBhc3Njb2RlIGlzIHByb21wdGVkLlwiXSxcbiAgICAvL1tcInRvb2xib3hMZXZlbFwiLCBcInRvb2xib3hfbGV2ZWxcIiwgXCJub3JtYWxcIiwgXCJ0b29sYm94XCIsIFwiSU5DT01QTEVURTogV2hhdCBsZXZlbCBvZiB0b29sYm94IHRvIHByZXNlbnQgdG8gdGhlIHVzZXIgKGhpZGluZyBhbmQgc2hvd2luZyBjYXRlZ29yaWVzKS5cIl0sXG4gICAgW1wic3RhcnRWaWV3XCIsIFwic3RhcnRfdmlld1wiLCBEaXNwbGF5TW9kZXMuVEVYVCwgRGlzcGxheU1vZGVzLCBcIlRoZSBQeXRob24gZWRpdG9yIG1vZGUgdG8gc3RhcnQgaW4gd2hlbiB0aGUgc3R1ZGVudCBzdGFydHMgdGhlIHByb2JsZW0uXCJdLFxuICAgIFtcImRhdGFzZXRzXCIsIFwiZGF0YXNldHNcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJUaGUgY3VycmVudCBsaXN0IG9mIGRhdGFzZXRzIGF2YWlsYWJsZSBvbiBsb2FkIGFzIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZy5cIl0sXG4gICAgW1wiZGlzYWJsZVRpbWVvdXRcIiwgXCJkaXNhYmxlX3RpbWVvdXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgY29kZSBpcyBhbGxvd2VkIHRvIHJ1biB3aXRob3V0IHRpbWVvdXRzIChwb3RlbnRpYWxseSBhbGxvd2luZyBpbmZpbml0ZSBsb29wcykuXCJdLFxuICAgIFtcInBhcnRJZFwiLCBcInBhcnRfaWRcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJUaGUgUGFydCBJRCBvZiBhbiBBc3NpZ25tZW50IHRoYXQgdGhpcyBlZGl0b3IgaXMgcmVzcG9uc2libGUgZm9yLiBBc3NpZ25tZW50cyBjYW4gaGF2ZSByZWdpb25zIChcXFwiUGFydHNcXFwiKSB0aGF0IGJlaGF2ZSBpbmRlcGVuZGVudGx5IHRvIHRoZSB1c2VyIGJ1dCBhbGwgY29ycmVzcG9uZCB0byB0aGUgc2FtZSBhc3NpZ25tZW50IG9uIHRoZSBiYWNrZW5kLiBCbGFuayBjb3JyZXNwb25kcyB0byB0aGUgZnVsbCBkb2N1bWVudC4gTm90ZSB0aGF0IG1vc3QgYXNzaWdubWVudCBzZXR0aW5ncyB3aWxsIGFwcGx5IFVOSVZFUlNBTExZIGFjcm9zcyBhbGwgcGFydHMsIGluY2x1ZGluZyB0aGUgb25fcnVuLnB5IGFuZCB0aGUgb3RoZXIgc2V0dGluZ3Mgb24gdGhpcyBwYWdlLlwiXSxcbiAgICBbXCJpc1BhcnNvbnNcIiwgXCJpc19wYXJzb25zXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoaXMgaXMgYSBwYXJzb24ncyBzdHlsZSBxdWVzdGlvbiAoanVtYmxlZCkuXCJdLFxuICAgIFtcInNhdmVUdXJ0bGVPdXRwdXRcIiwgXCJzYXZlX3R1cnRsZV9vdXRwdXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdHVydGxlIChhbmQgcHlnYW1lKSBvdXRwdXQgaXMgc2F2ZWQgd2hlbmV2ZXIgdGhlIHByb2dyYW0gdXNlcyBpdC5cIl0sXG4gICAgW1wiZGlzYWJsZUZlZWRiYWNrXCIsIFwiZGlzYWJsZV9mZWVkYmFja1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBubyBpbnN0cnVjdG9yIHNjcmlwdHMgYXJlIHJ1biAoZS5nLiwgb25fcnVuIGFuZCBvbl9ldmFsKS5cIl0sXG4gICAgW1wiZGlzYWJsZUluc3RydWN0b3JSdW5cIiwgXCJkaXNhYmxlX2luc3RydWN0b3JfcnVuXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBpbnN0cnVjdG9yIG9uX3J1biB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHJ1biB0aGUgc3R1ZGVudHMnIGNvZGUuIFRoaXMgc3RpbGwgcnVucyB0aGUgc3R1ZGVudHMnIGNvZGUgb25jZSBiZWZvcmVoYW5kLCBidXQgdGhlIG91dHB1dC9kYXRhIHdpbGwgbm90IGJlIGF2YWlsYWJsZSB0byB0aGUgaW5zdHJ1Y3RvcidzIG9uX3J1bi5weSBzY3JpcHQuXCJdLFxuICAgIFtcImRpc2FibGVTdHVkZW50UnVuXCIsIFwiZGlzYWJsZV9zdHVkZW50X3J1blwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgcnVuIGJ1dHRvbiBubyBsb25nZXIgcnVuIHRoZSBzdHVkZW50cycgY29kZS4gVGhpcyBzdGlsbCBydW5zIHRoZSBpbnN0cnVjdG9yJ3MgZmVlZGJhY2sgb25fcnVuIHNjcmlwdC5cIl0sXG4gICAgW1wiZGlzYWJsZVRpZmFcIiwgXCJkaXNhYmxlX3RpZmFcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gZG8gbm90IGF1dG9tYXRpY2FsbHkgcnVuIFRpZmEgKHdoaWNoIGNhbiBiZSBzbG93KS5cIl0sXG4gICAgW1wiZGlzYWJsZVRyYWNlXCIsIFwiZGlzYWJsZV90cmFjZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMgY29kZSB3aWxsIG5vdCBoYXZlIGl0cyBleGVjdXRpb24gdHJhY2VkIChubyB2YXJpYWJsZXMgcmVjb3JkZWQsIG5vIGNvdmVyYWdlIHRyYWNrZWQpLlwiXSxcbiAgICBbXCJkaXNhYmxlRWRpdFwiLCBcImRpc2FibGVfZWRpdFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZWRpdGFibGUuXCJdLFxuICAgIFtcInByZWxvYWRBbGxGaWxlc1wiLCBcInByZWxvYWRfYWxsX2ZpbGVzXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50cyBjYW4gdXBsb2FkIGFuZCB1c2UgaW1hZ2VzIGFuZCBvdGhlciBmaWxlcy4gVGhpcyBwcmVsb2FkcyBhbGwgYXZhaWxhYmxlIGZpbGVzIGFuZCBpbWFnZXMuIFlvdSBjYW4gZmlsdGVyIHRoZW0gdXNpbmcgdGhlIFByZWxvYWRlZCBGaWxlcyBzZXR0aW5nLlwiXSxcbiAgICBbXCJlbmFibGVJbWFnZXNcIiwgXCJjYW5faW1hZ2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdXNlcnMgY2FuIGNvcHkvcGFzdGUgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIHRleHQgZWRpdG9yLlwiXSxcbiAgICBbXCJlbmFibGVCbG9ja3NcIiwgXCJjYW5fYmxvY2tzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnQgY2FuIGVkaXQgdGhlIGJsb2NrIGludGVyZmFjZSAoaWYgbm90LCB0aGVuIGl0IGlzIHZpc2libGUgYnV0IG5vdCBlZGl0YWJsZSkuXCJdLFxuICAgIFtcImNhbkNsb3NlXCIsIFwiY2FuX2Nsb3NlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IHNob3VsZCBtYXJrIHRoZWlyIHN1Ym1pc3Npb24gY2xvc2VkIHdoZW4gdGhleSBhcmUgZG9uZS4gVGhlcmUgaXMgbm8gd2F5IHRvIGZvcmNlIGEgc3R1ZGVudCB0byBkbyBzby4gVW5saWtlIFJldmlld2VkLCB0aGlzIHN0aWxsIHN1Ym1pdHMgdGhlIGNvcnJlY3RuZXNzLlwiXSxcbiAgICBbXCJvbmx5SW50ZXJhY3RpdmVcIiwgXCJvbmx5X2ludGVyYWN0aXZlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGUgZWRpdG9ycyBhcmUgaGlkZGVuLCB0aGUgcHJvZ3JhbSBpcyBhdXRvbWF0aWNhbGx5IHJ1biwgYW5kIHRoZW4gdGhlIGNvbnNvbGUgZW50ZXJzIEV2YWwgbW9kZSAoaW50ZXJhY3RpdmUpLlwiXSxcbiAgICBbXCJvbmx5VXBsb2Fkc1wiLCBcIm9ubHlfdXBsb2Fkc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZGlyZWN0bHkgZWRpdGFibGUgKHRoZXkgd2lsbCBoYXZlIHRvIHVwbG9hZCBzdWJtaXNzaW9ucykuXCJdLFxuICAgIC8vIFdoYXQgbWVudXMvZmVlZGJhY2sgdG8gc2hvdyBhbmQgaGlkZVxuICAgIFtcImhpZGVTdWJtaXNzaW9uXCIsIFwiaGlkZV9zdWJtaXNzaW9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIHN1Ym1pc3Npb24ncyBjb2RlIG9yIGhpc3Rvcnkgb24gQ2FudmFzLlwiXSxcbiAgICBbXCJoaWRlRmlsZXNcIiwgXCJoaWRlX2ZpbGVzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgd2lsbCBub3Qgc2VlIHRoZSBWaWV3IEZpbGVzIHRvb2xiYXIuXCJdLFxuICAgIFtcImhpZGVRdWV1ZWRJbnB1dHNcIiwgXCJoaWRlX3F1ZXVlZF9pbnB1dHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNhbm5vdCBhY2Nlc3MgdGhlIHF1ZXVlZCBpbnB1dHMgYm94IChtYWtlcyByZXBlYXRlZCBkZWJ1Z2dpbmcgZWFzaWVyIGZvciB0aGUgaW5wdXQgZnVuY3Rpb24pLlwiXSxcbiAgICBbXCJoaWRlRWRpdG9yc1wiLCBcImhpZGVfZWRpdG9yc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhbGwgb2YgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZU1pZGRsZVBhbmVsXCIsIFwiaGlkZV9taWRkbGVfcGFuZWxcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGNvbnNvbGUgYW5kIGZlZWRiYWNrIGFyZWFzIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUFsbFwiLCBcImhpZGVfYWxsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCB0aGVuIHRoZSBlbnRpcmUgaW50ZXJmYWNlIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUV2YWx1YXRlXCIsIFwiaGlkZV9ldmFsdWF0ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgRXZhbHVhdGUgYnV0dG9uIGlzIG5vdCBzaG93biBvbiB0aGUgY29uc29sZS5cIl0sXG4gICAgW1wiaGlkZUltcG9ydERhdGFzZXRzQnV0dG9uXCIsIFwiaGlkZV9pbXBvcnRfZGF0YXNldHNfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNhbm5vdCBzZWUgdGhlIGltcG9ydCBkYXRhc2V0cyBidXR0b24uXCJdLFxuICAgIC8vIFRPRE86IEZpeCB0aGlzIG9uZSB0byBiZSBzZXR0YWJsZVxuICAgIFtcImhpZGVJbXBvcnRTdGF0ZW1lbnRzXCIsIFwiaGlkZV9pbXBvcnRfc3RhdGVtZW50c1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgY2VydGFpbiBraW5kcyBvZiBpbXBvcnQgc3RhdGVtZW50cyAobWF0cGxvdGxpYiwgdHVydGxlLCBkYXRhc2V0cykgYXJlIG5vdCBzaG93biBpbiB0aGUgYmxvY2sgaW50ZXJmYWNlLlwiXSxcbiAgICBbXCJoaWRlQ292ZXJhZ2VCdXR0b25cIiwgXCJoaWRlX2NvdmVyYWdlX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlIGNvdmVyYWdlIGJ1dHRvbiBpcyBub3Qgc2hvd24uXCJdLFxuICAgIFtcImhpZGVUcmFjZUJ1dHRvblwiLCBcImhpZGVfdHJhY2VfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBUcmFjZSBidXR0b24gaXMgbm90IHNob3duLlwiXSxcbiAgICBbXCJzbWFsbExheW91dFwiLCBcInNtYWxsX2xheW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW50ZXJmYWNlIGZpdHMgaW50byBhIHNtYWxsZXIgcmVnaW9uLlwiXSxcbiAgICBbXCJoYXNDbG9ja1wiLCBcImhhc19jbG9ja1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhIGNsb2NrIGlzIHNob3duIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyLlwiXSxcbiAgICBbXCJwcmVsb2FkRmlsZXNcIiwgXCJwcmVsb2FkX2ZpbGVzXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiQSBKU09OIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgdGhlIGZpbGVzIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBvbiBzdGFydCBmcm9tIHRoZSByZW1vdGUsIGFzIGlmIHRoZXkgd2VyZSBsb2NhbC5cIl1cbl07XG5cbmV4cG9ydCBsZXQgQXNzaWdtZW50VHlwZSA9IHtcbiAgICBCTE9DS1BZOiBcImJsb2NrcHlcIixcbiAgICBNQVpFOiBcIm1hemVcIixcbiAgICBRVUlaOiBcInF1aXpcIixcbiAgICBSRUFESU5HOiBcInJlYWRpbmdcIlxufTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRhdGlvbihuYW1lKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgQVNTSUdOTUVOVF9TRVRUSU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQVNTSUdOTUVOVF9TRVRUSU5HU1tpXVswXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiRG9jdW1lbnRhdGlvbiBub3QgZm91bmQgZm9yIGZpZWxkXCI7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdGFydFZpZXdUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0VmlldygpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGFzc2lnbm1lbnQuc2V0dGluZ3Muc3RhcnRWaWV3LmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktc3RhcnQtdmlldy1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwgPSBBU1NJR05NRU5UX1NFVFRJTkdTXG4gICAgLy8gT25seSBoYW5kbGUgdGhlIHNpbXBsZSBib29sZWFucyB0aGlzIHdheVxuICAgIC5maWx0ZXIoKHNldHRpbmcpID0+IHNldHRpbmdbM10gPT09IFwiYm9vbFwiKVxuICAgIC5tYXAoKHNldHRpbmcpID0+IHtcbiAgICAgICAgbGV0IHByZXR0eU5hbWUgPSBzZXR0aW5nWzFdLnNwbGl0KFwiX1wiKS5tYXAod29yZD0+KHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrd29yZC5zbGljZSgxKSkpLmpvaW4oXCIgXCIpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtJHtzZXR0aW5nWzBdfVwiPiR7cHJldHR5TmFtZX08L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnNldHRpbmdzLiR7c2V0dGluZ1swXX1cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke3NldHRpbmdbNF19XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9KS5qb2luKFwiXFxuXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS12aWV3LXNldHRpbmdzXCI+XG4gICAgXG4gICAgPGZvcm0+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEyIG14LWF1dG9cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc3VjY2Vzc1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnNldHRpbmdzLnNhdmVcIj5TYXZlIGNoYW5nZXM8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+TmFtZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLW5hbWVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50Lm5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgc3R1ZGVudC1mYWNpbmcgbmFtZSBvZiB0aGUgYXNzaWdubWVudC4gQXNzaWdubWVudHMgd2l0aGluIGEgZ3JvdXAgYXJlIG9yZGVyZWQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgYnkgdGhlaXIgbmFtZSwgc28geW91IG1heSB3YW50IHRvIHVzZSBhIG5hbWluZyBzY2hlbWUgbGlrZSBcIiM0My41KSBXaGF0ZXZlclwiLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlVSTDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudXJsXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIGNvdXJzZS11bmlxdWUgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uc2lzdGVudGx5IHJlZmVyIHRvIHRoaXMgYXNzaWdubWVudC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIj5QdWJsaWM6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnB1YmxpY1wiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIG5vdCBwdWJsaWMsIHVzZXJzIG91dHNpZGUgb2YgdGhlIGNvdXJzZSB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGUgYXNzaWdubWVudCBpbiBjb3Vyc2UgbGlzdGluZ3MuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIj5IaWRkZW46PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LmhpZGRlblwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIGhpZGRlbiwgc3R1ZGVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlaXIgZ3JhZGUgd2hpbGUgd29ya2luZyBvbiB0aGUgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXJldmlld2VkXCI+UmV2aWV3ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGFzc2lnbm1lbnQucmV2aWV3ZWRcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiByZXZpZXdlZCwgdGhlIGFzc2lnbm1lbnQgbmVlZCB0byBiZSBjb21tZW50ZWQgdXBvbiBhbmQgcmVncmFkZWQgYnkgdGhlIHN0YWZmIGFmdGVyIHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UG9pbnRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wb2ludHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnBvaW50c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoaXMgYXNzaWdubWVudCBpcyB3b3J0aDsgZGVmYXVsdHMgdG8gMSBwb2ludC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlN0YXJ0aW5nIFZpZXc6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiQmxvY2tzXCIsIFwidGgtbGFyZ2VcIiwgRGlzcGxheU1vZGVzLkJMT0NLKX1cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tN1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInN0YXJ0Vmlld1wiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5JUCBSYW5nZXM6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LmlwUmFuZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIElQIEFkZHJlc3NlcyB0aGF0IHdpbGwgYmUgZXhwbGljaXRseSBhbGxvd2VkLiBJZiBibGFuayxcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgYWRkcmVzc2VzIGFyZSBhbGxvd2VkLiBJZiBhbiBhZGRyZXNzIHN0YXJ0cyB3aXRoIDxjb2RlPl48L2NvZGU+IHRoZW4gaXQgaXQgaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3RlZCwgYnV0IHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdHVybiB3aXRoIGEgPGNvZGU+ITwvY29kZT4uIEFkZHJlc3NlcyBjYW4gYWxzb1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIGEgYml0IG1hc2sgdG8gYWxsb3cgYSByYW5nZSBvZiBhZGRyZXNzZXMuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcGFzc2NvZGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5QYXNzY29kZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5wYXNzY29kZVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInBhc3Njb2RlXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJlbG9hZGVkIERhdGFzZXRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtZGF0YXNldHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwiZGF0YXNldHNcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcHJlbG9hZC1maWxlc1wiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlByZWxvYWRlZCBGaWxlczo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXByZWxvYWQtZmlsZXNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLnByZWxvYWRGaWxlc1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInByZWxvYWRGaWxlc1wiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy10b29sYm94XCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+QmxvY2sgVG9vbGJveDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtdG9vbGJveFwiXG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3hcIj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibm9ybWFsXCI+Tm9ybWFsIFRvb2xib3g8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3RcIj5DVEBWVCBUb29sYm94PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN0MlwiPkNUQFZUIFRvb2xib3ggVjI8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibWluaW1hbFwiPk1pbmltYWwgU2V0PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImZ1bGxcIj5BbGwgQmxvY2tzPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN1c3RvbVwiPkN1c3RvbTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInRvb2xib3hcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtdHlwZVwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlByb2JsZW0gVHlwZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtdHlwZVwiXG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnR5cGVcIj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiYmxvY2tweVwiPkJsb2NrUHk8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibWF6ZVwiPk1hemU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicXVpelwiPlF1aXogUXVlc3Rpb248L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmVhZGluZ1wiPlJlYWRpbmc8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJ0eXBlXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXBhcnQtaWRcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5QYXJ0IElEOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtcGFydC1pZFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGNvbmZpZ3VyYXRpb24ucGFydElkXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwicGFydElkXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICAke0FTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUx9XG4gICAgPC9mb3JtPlxuICAgIFxuICAgIDwvZGl2PlxuYDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVBc3NpZ25tZW50U2V0dGluZ3MobW9kZWwpIHtcbiAgICBsZXQgc2V0dGluZ3MgPSB7fTtcbiAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgIGxldCBjbGllbnROYW1lID0gc2V0dGluZ1swXSwgc2VydmVyTmFtZSA9IHNldHRpbmdbMV0sIGRlZmF1bHRWYWx1ZSA9IHNldHRpbmdbMl07XG4gICAgICAgIGxldCB2YWx1ZSA9IG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3NbY2xpZW50TmFtZV0oKTtcbiAgICAgICAgLy8gT25seSBzdG9yZSB0aGlzIHNldHRpbmcgaWYgaXRzIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1tzZXJ2ZXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRBc3NpZ25tZW50U2V0dGluZ3MobW9kZWwsIHNldHRpbmdzKSB7XG4gICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gSlNPTi5wYXJzZShzZXR0aW5ncyk7XG4gICAgICAgIEFTU0lHTk1FTlRfU0VUVElOR1MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgICAgIGxldCBjbGllbnROYW1lID0gc2V0dGluZ1swXSwgc2VydmVyTmFtZSA9IHNldHRpbmdbMV07XG4gICAgICAgICAgICBpZiAoc2VydmVyTmFtZSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3NbY2xpZW50TmFtZV0oc2V0dGluZ3Nbc2VydmVyTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKHNldHRpbmdbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2V0dGluZ3Muc3RhcnRfdmlldykge1xuICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5weXRob25Nb2RlKHNldHRpbmdzLnN0YXJ0X3ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBsZXQgc2V0dGluZ3MgPSB7fTtcbiAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgIGxldCBjbGllbnROYW1lID0gc2V0dGluZ1swXSwgc2VydmVyTmFtZSA9IHNldHRpbmdbMV0sIGRlZmF1bHRWYWx1ZSA9IHNldHRpbmdbMl0sXG4gICAgICAgICAgICBmaWVsZFR5cGUgPSBzZXR0aW5nWzNdO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc2V0dGluZ3MuXCIrc2VydmVyTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2V0dGluZ3NbY2xpZW50TmFtZV0gPSBrby5vYnNlcnZhYmxlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29uZmlnVmFsdWUgPSBjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zZXR0aW5ncy5cIitzZXJ2ZXJOYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnVmFsdWUgPSBjb25maWdWYWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzW2NsaWVudE5hbWVdID0ga28ub2JzZXJ2YWJsZShjb25maWdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzZXR0aW5ncztcbn1cblxuY2xhc3MgQXNzaWdubWVudFNldHRpbmdzVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgLy9UT0RPOiB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vVE9ETzogdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB1cGRhdGVcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy90aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci52YWx1ZSgpKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgLy90aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAvLyBUT0RPOiB1cGRhdGVcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBBc3NpZ25tZW50U2V0dGluZ3MgPSB7XG4gICAgbmFtZTogXCJBc3NpZ25tZW50IFNldHRpbmdzXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogQXNzaWdubWVudFNldHRpbmdzVmlldyxcbiAgICB0ZW1wbGF0ZTogQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTFxufTsiLCJcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0X2hlYWRlciA9IGBcclxuPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLXRvb2xiYXIgY29sLW1kLTEyIGJ0bi10b29sYmFyXCJcclxuICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJQeXRob24gVG9vbGJhclwiPlxyXG4gICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiPlxyXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS11cGxvYWRcIj48L3NwYW4+IFVwbG9hZFxyXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJibG9ja3B5LXRvb2xiYXItdXBsb2FkXCIgdHlwZT1cImZpbGVcIlxyXG4gICAgICAgICAgICAgICAgaGlkZGVuXHJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuZWRpdG9ycy51cGxvYWR9XCI+XHJcbiAgICAgICAgIDwvbGFiZWw+XHJcblxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBkcm9wZG93bi10b2dnbGUgZHJvcGRvd24tdG9nZ2xlLXNwbGl0XCJcclxuICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiPlRvZ2dsZSBEcm9wZG93bjwvc3Bhbj5cclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgIDxhIGNsYXNzPSdkcm9wZG93bi1pdGVtIGJsb2NrcHktdG9vbGJhci1kb3dubG9hZCdcclxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmRvd25sb2FkXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZG93bmxvYWQnPjwvc3Bhbj4gRG93bmxvYWRcclxuICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICBcclxuICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJEZWxldGUgR3JvdXBcIlxyXG4gICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuRGVsZXRlXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXHJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5kZWxldGVcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L3NwYW4+IERlbGV0ZVxyXG4gICAgICAgICA8L2J1dHRvbj5cclxuICAgICA8L2Rpdj5cclxuIDwvZGl2PlxyXG5gO1xyXG4iLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuaW1wb3J0ICogYXMgRmlsZVBvbmQgZnJvbSBcImZpbGVwb25kXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSU1BR0VfRURJVE9SX0hUTUwgPSBgXHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8c3Ryb25nPkltYWdlcyBhbmQgRmlsZXM8L3N0cm9uZz5cclxuICAgICAgICA8IS0tPGRpdiBjbGFzcz1cImJsb2NrcHktZWRpdG9yLWltYWdlcy1maWxlcG9uZFwiPjwvZGl2Pi0tPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbFwiIGZvcj1cImJsb2NrcHktZWRpdG9yLWltYWdlcy11cGxvYWQtZmlsZVwiPkZpbGU6PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktZWRpdG9yLWltYWdlcy11cGxvYWQtZmlsZVwiIGlkPVwiYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1maWxlXCJcclxuICAgICAgICAgICAgbmFtZT1cImJsb2NrcHktZWRpdG9yLWltYWdlcy11cGxvYWQtZmlsZVwiPlxyXG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICBUaGUgZmlsZSB0byBtYWtlIGF2YWlsYWJsZSBpbiB5b3VyIGNvZGVcclxuICAgICAgICAgICAgICAgIDwvc21hbGw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuaW1hZ2VzLmNhbkNob29zZVBsYWNlbWVudCgpXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1wbGFjZW1lbnRcIj5QbGFjZW1lbnQ6PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJibG9ja3B5LWVkaXRvci1pbWFnZXMtdXBsb2FkLXBsYWNlbWVudFwiIG5hbWU9XCJibG9ja3B5LWVkaXRvci1pbWFnZXMtdXBsb2FkLXBsYWNlbWVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1wbGFjZW1lbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic3VibWlzc2lvblwiIHNlbGVjdGVkPk9ubHkgeW91ciBzdWJtaXNzaW9uPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImFzc2lnbm1lbnRcIj5Gb3IgYWxsIHN1Ym1pc3Npb25zIG9mIHRoaXMgYXNzaWdubWVudDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjb3Vyc2VcIj5BY3Jvc3MgdGhlIGVudGlyZSBjb3Vyc2U8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwidXNlclwiPkZvciBqdXN0IHlvdXIgdXNlciBhY2NvdW50PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgVGhlIHBsYWNlbWVudCBvZiB0aGUgZmlsZSBpbiB0aGUgc3lzdGVtLiBUaGlzIGNvbnRyb2xzIHdoZXRoZXIgb3RoZXIgdXNlcnMgY2FuIHNlZSB0aGUgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgICBJZiB5b3Ugd2FudCB0byBwcm92aWRlIGEgZmlsZSB0byBhbGwgc3R1ZGVudHMgZm9yIGp1c3QgdGhpcyBzcGVjaWZpYyBwcm9ibGVtLCB0aGVuIHlvdSBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICB1c2UgPGNvZGU+Rm9yIGFsbCBzdWJtaXNzaW9ucyBvZiB0aGlzIGFzc2lnbm1lbnQ8L2NvZGU+LiBJZiB5b3Ugd2FudCB0byB1c2UgdGhpcyBzYW1lIGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgYWNyb3NzIG90aGVyIGFzc2lnbm1lbnRzIChpbmNsdWRpbmcgYXNzaWdubWVudHMgd2l0aGluIHRoaXMgYXNzaWdubWVudCBncm91cCksIHRoZW4geW91IHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZSA8Y29kZT5BY3Jvc3MgdGhlIGVudGlyZSBjb3Vyc2U8L2NvZGU+LlxyXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1maWxlbmFtZVwiPkZpbGVuYW1lOjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWVkaXRvci1pbWFnZXMtdXBsb2FkLWZpbGVuYW1lXCIgaWQ9XCJibG9ja3B5LWVkaXRvci1pbWFnZXMtdXBsb2FkLWZpbGVuYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1maWxlbmFtZVwiPlxyXG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICBUaGUgZmlsZW5hbWUgdGhhdCB3aWxsIGJlIG1hZGUgYXZhaWxhYmxlIGluIHRoZSBjb2RlLiBUaGlzIHNob3VsZCBiZSBhIHZhbGlkIGZpbGVuYW1lIGZvciB0aGVcclxuICAgICAgICAgICAgICAgICAgICBzeXN0ZW0sIGFuZCBzaG91bGQgbm90IGNvbnRhaW4gc3BhY2VzIG9yIHNwZWNpYWwgY2hhcmFjdGVycy4gSXQgc2hvdWxkIGFsc28gaGF2ZSBhIHZhbGlkIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gKGUuZy4sIDxjb2RlPi5wbmc8L2NvZGU+LCA8Y29kZT4uanBnPC9jb2RlPiwgPGNvZGU+LnR4dDwvY29kZT4pLlxyXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPiAgICBcclxuICAgICAgICAgICAgPGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbWFnZXMudXBsb2FkRmlsZVwiIGNsYXNzPVwiYnRuIGJ0bi1zdWNjZXNzXCI+VXBsb2FkPC9idXR0b24+XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICA8YnV0dG9uIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmltYWdlcy5yZWxvYWRJbWFnZXNcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0XCJcclxuICAgICAgICAgICAgPlJlbG9hZCBBdmFpbGFibGUgSW1hZ2VzPC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPHN0cm9uZz5BdmFpbGFibGUgRmlsZXM8L3N0cm9uZz5cclxuICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5LnVwbG9hZGVkRmlsZXMoKSAhPT0gbnVsbCAtLT5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6IE9iamVjdC5rZXlzKGRpc3BsYXkudXBsb2FkZWRGaWxlcygpKSwgYXM6ICdwbGFjZW1lbnQnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZyBkYXRhLWJpbmQ9XCJ0ZXh0OiAkZGF0YVswXS50b1VwcGVyQ2FzZSgpICsgJGRhdGEuc2xpY2UoMSlcIj48L3N0cm9uZz46XHJcbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1ob3ZlciB0YWJsZS1zbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkZpbGVuYW1lPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+UHJldmlldzwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkFjdGlvbnM8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0ga28gZm9yZWFjaDogeyBkYXRhOiAkcm9vdC5kaXNwbGF5LnVwbG9hZGVkRmlsZXMoKVtwbGFjZW1lbnRdLCBhczogJ2ZpbGVuYW1lJyB9IC0tPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGUgZGF0YS1iaW5kPVwidGV4dDogZmlsZW5hbWVbMF1cIj48L2NvZGU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZXRhaWxzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3VtbWFyeT48aW1nIGRhdGEtYmluZD1cImF0dHI6IHsgc3JjOiBmaWxlbmFtZVsxXSwgYWx0OiBmaWxlbmFtZVsxXSB9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMzBweFwiIGhlaWdodD1cIjMwcHhcIiBvbmVycm9yPVwidGhpcy5zdHlsZS5kaXNwbGF5PSdub25lJ1wiLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGRhdGEtYmluZD1cImF0dHI6IHsgc3JjOiBmaWxlbmFtZVsxXSwgYWx0OiBmaWxlbmFtZVsxXSB9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3I9XCJ0aGlzLnN0eWxlLmRpc3BsYXk9J25vbmUnXCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGV0YWlscz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGFuZ2VyXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC51aS5lZGl0b3JzLmltYWdlcy5kZWxldGVGaWxlLmJpbmQoZmlsZW5hbWVbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6ICRyb290LnVpLmVkaXRvcnMuaW1hZ2VzLmNhbk1vZGlmeShwbGFjZW1lbnQpXCI+RGVsZXRlPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGFuZ2VyXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiAkcm9vdC51aS5lZGl0b3JzLmltYWdlcy5yZW5hbWVGaWxlLmJpbmQoZmlsZW5hbWVbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6ICRyb290LnVpLmVkaXRvcnMuaW1hZ2VzLmNhbk1vZGlmeShwbGFjZW1lbnQpXCI+UmVuYW1lPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEltYWdlRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcblxyXG4gICAgICAgIHRoaXMudGFnVXBsb2FkRmlsZUJ1dHRvbiA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1maWxlXCIpO1xyXG4gICAgICAgIHRoaXMudGFnVXBsb2FkRmlsZVBsYWNlbWVudCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1wbGFjZW1lbnRcIik7XHJcbiAgICAgICAgdGhpcy50YWdVcGxvYWRGaWxlTmFtZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItaW1hZ2VzLXVwbG9hZC1maWxlbmFtZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy50YWdVcGxvYWRGaWxlQnV0dG9uLm9uKFwiY2hhbmdlXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRhZ1VwbG9hZEZpbGVOYW1lLnZhbChldmVudC50YXJnZXQuZmlsZXNbMF0ubmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG5cclxuICAgICAgICBsZXQgdXBsb2FkZWRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnVwbG9hZGVkRmlsZXMoKTtcclxuICAgICAgICBpZiAodXBsb2FkZWRGaWxlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbG9hZEltYWdlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8vIGNvbnN0IHRhcmdldCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItaW1hZ2VzLWZpbGVwb25kXCIpWzBdO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2codGFyZ2V0KTtcclxuICAgICAgICAvKmNvbnN0IHVwbG9hZFVybCA9IG5ldyBVUkwodGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tcInVwbG9hZEZpbGVcIl0pO1xyXG4gICAgICAgIHVwbG9hZFVybC5zZWFyY2hQYXJhbXMuc2V0KFwiZGlyZWN0b3J5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmlkKCkpO1xyXG4gICAgICAgIHVwbG9hZFVybC5zZWFyY2hQYXJhbXMuc2V0KFwicGxhY2VtZW50XCIsIFwic3VibWlzc2lvblwiKTsqL1xyXG4gICAgICAgIC8vIHRoaXMuZmlsZXBvbmQgPSBGaWxlUG9uZC5jcmVhdGUodGFyZ2V0LCB7XHJcbiAgICAgICAgLy8gICAgIC8vZmlsZXM6IFtdLFxyXG4gICAgICAgIC8vICAgICBhbGxvd011bHRpcGxlOiB0cnVlLFxyXG4gICAgICAgIC8vICAgICBzZXJ2ZXI6IHtcclxuICAgICAgICAvLyAgICAgICAgIHVybDogdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tcImRvd25sb2FkRmlsZVwiXSxcclxuICAgICAgICAvLyAgICAgICAgIGxvYWQ6IChzb3VyY2UsIGxvYWQpID0+IHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMKHNvdXJjZSwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikuc2VhcmNoUGFyYW1zO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5kb3dubG9hZEZpbGUoXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHBhcmFtcy5nZXQoXCJwbGFjZW1lbnRcIiksXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHBhcmFtcy5nZXQoXCJkaXJlY3RvcnlcIiksXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHBhcmFtcy5nZXQoXCJmaWxlbmFtZVwiKSxcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBsb2FkKG5ldyBGaWxlKFtyZXNwb25zZV0sIHBhcmFtcy5nZXQoXCJmaWxlbmFtZVwiKSkpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhzb3VyY2UsIGxvYWQpO1xyXG4gICAgICAgIC8vICAgICAgICAgfSxcclxuICAgICAgICAvLyAgICAgICAgIHByb2Nlc3M6IHtcclxuICAgICAgICAvLyAgICAgICAgICAgICB1cmw6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHNbXCJ1cGxvYWRGaWxlXCJdLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIHVybDogXCJibG9ja3B5L3VwbG9hZF9maWxlP3BsYWNlbWVudD1hc3NpZ25tZW50JmRpcmVjdG9yeT1cIit0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpLFxyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5maWxlcG9uZCk7XHJcbiAgICAgICAgLypcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG5cclxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7Ki9cclxuICAgIH1cclxuXHJcbiAgICByZWxvYWRJbWFnZXMoKSB7XHJcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxpc3RVcGxvYWRlZEZpbGVzKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudXBsb2FkZWRGaWxlcyhyZXNwb25zZS5maWxlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLmxvYWRSZW1vdGVGaWxlcyhyZXNwb25zZS5maWxlcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBhbGxGaWxlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0LmVudHJpZXMocmVzcG9uc2UuZmlsZXMpLmZvckVhY2goKFtncm91cCwgZmlsZXNdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgZmlsZXMuZm9yRWFjaCgoW2ZpbGVuYW1lLCB1cmxdKSA9PiBhbGxGaWxlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgc291cmNlOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHR5cGU6IFwibG9jYWxcIlxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmZpbGVwb25kLmFkZEZpbGVzKGFsbEZpbGVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZ3MuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyhyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICAvKnRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICBnZXRQbGFjZW1lbnREaXJlY3RvcnkocGxhY2VtZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBcInN1Ym1pc3Npb25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5pZCgpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYXNzaWdubWVudFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmlkKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjb3Vyc2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuY291cnNlLmlkKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1c2VyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLnVzZXIuaWQoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwbG9hZEZpbGUoXHJcbiAgICAgICAgICAgIHRoaXMudGFnVXBsb2FkRmlsZVBsYWNlbWVudC52YWwoKSxcclxuICAgICAgICAgICAgdGhpcy5nZXRQbGFjZW1lbnREaXJlY3RvcnkodGhpcy50YWdVcGxvYWRGaWxlUGxhY2VtZW50LnZhbCgpKSxcclxuICAgICAgICAgICAgdGhpcy50YWdVcGxvYWRGaWxlTmFtZS52YWwoKSxcclxuICAgICAgICAgICAgdGhpcy50YWdVcGxvYWRGaWxlQnV0dG9uWzBdLmZpbGVzWzBdLFxyXG4gICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRJbWFnZXMoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9ncy5FUlJPUl9VUExPQURJTkdfRklMRShyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlRmlsZShmaWxlSW5mbykge1xyXG4gICAgICAgIGNvbnN0IFtmaWxlbmFtZSwgdXJsXSA9IGZpbGVJbmZvO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTCh1cmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLnNlYXJjaFBhcmFtcztcclxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIudXBsb2FkRmlsZShcclxuICAgICAgICAgICAgcXVlcnlQYXJhbXMuZ2V0KFwicGxhY2VtZW50XCIpLFxyXG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5nZXQoXCJkaXJlY3RvcnlcIiksXHJcbiAgICAgICAgICAgIGZpbGVuYW1lLFxyXG4gICAgICAgICAgICBcIlwiLFxyXG4gICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRJbWFnZXMoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9ncy5FUlJPUl9ERUxFVElOR19GSUxFKHJlc3BvbnNlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHJlbmFtZUZpbGUoZmlsZUluZm8pIHtcclxuICAgICAgICBjb25zdCBbZmlsZW5hbWUsIHVybF0gPSBmaWxlSW5mbztcclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkwodXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKS5zZWFyY2hQYXJhbXM7XHJcbiAgICAgICAgY29uc3QgbmV3RmlsZW5hbWUgPSBwcm9tcHQoXCJFbnRlciB0aGUgbmV3IGZpbGVuYW1lIGZvciB0aGlzIGZpbGU6XCIsIGZpbGVuYW1lKTtcclxuICAgICAgICBpZiAobmV3RmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnJlbmFtZUZpbGUoXHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5nZXQoXCJwbGFjZW1lbnRcIiksXHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5nZXQoXCJkaXJlY3RvcnlcIiksXHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcclxuICAgICAgICAgICAgICAgIG5ld0ZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRJbWFnZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2dzLkVSUk9SX1JFTkFNSU5HX0ZJTEUocmVzcG9uc2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIC8vIGlmICh0aGlzLmZpbGVwb25kKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuZmlsZXBvbmQuZGVzdHJveSgpO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEltYWdlRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJJbWFnZVwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiP2ltYWdlcy5ibG9ja3B5XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IEltYWdlRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBJTUFHRV9FRElUT1JfSFRNTFxyXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEpTT05fRURJVE9SX0hUTUwgPSBgXHJcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxyXG4gICAgIDxkaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItanNvblwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIEpzb25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1qc29uXCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBKc29uRWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJKU09OXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCIuanNvblwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBKc29uRWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBKU09OX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgTUFSS0RPV05fRURJVE9SX0hUTUwgPSBgXG4gICAgJHtkZWZhdWx0X2hlYWRlcn1cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1tYXJrZG93blwiPjwvdGV4dGFyZWE+ICAgIFxuYDtcblxuXG5jbGFzcyBNYXJrZG93bkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMubWRlID0gbmV3IEVhc3lNREUoe1xuICAgICAgICAgICAgZWxlbWVudDogdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItbWFya2Rvd25cIilbMF0sXG4gICAgICAgICAgICBhdXRvRG93bmxvYWRGb250QXdlc29tZTogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZVN5bmM6IHRydWUsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IFwiMzAwcHhcIixcbiAgICAgICAgICAgIC8vc2Nyb2xsYmFyU3R5bGU6IFwibmF0aXZlXCIsXG4gICAgICAgICAgICAvLyBUT0RPOiBpbWFnZVVwbG9hZEZ1bmN0aW9uXG4gICAgICAgICAgICByZW5kZXJpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICBjb2RlU3ludGF4SGlnaGxpZ2h0aW5nOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1kZS5jb2RlbWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMubWRlLmNvZGVtaXJyb3IpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWRlLnZhbHVlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLm1kZS52YWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bkVkaXRvciA9IHtcbiAgICBuYW1lOiBcIk1hcmtkb3duXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLm1kXCJdLFxuICAgIGNvbnN0cnVjdG9yOiBNYXJrZG93bkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IE1BUktET1dOX0VESVRPUl9IVE1MXG59OyIsIi8qKlxuICogVE9ETzogcmVuYW1lIGZpbGVzLCBtYW51YWwgc2F2ZSwgdGFncywgc2FtcGxlX3N1Ym1pc3Npb25zLCBvbl9ldmFsLCBub24tYnVpbHRpbiBmaWxlc1xuICogVE9ETzogaW1wb3J0IGRhdGEsIGhpc3RvcnksIHJ1biwgdXJsX2RhdGEsIGFzc2lnbm1lbnRfc2V0dGluZ3MsIHBhcnNvbnNfbW9kZVxuICogVE9ETzogZGVsZXRlIGJlY29tZXMgXCJjbGVhclwiIGZvciBpbnN0cnVjdG9yIGZpbGVzXG4gKi9cblxuLyoqXG4gKlxuICogQGVudW0ge3N0cn1cbiAqL1xuaW1wb3J0IHtBYnN0cmFjdEVkaXRvciwgc2x1Z2dpZnl9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtISVNUT1JZX1RPT0xCQVJfSFRNTH0gZnJvbSBcIi4uL2hpc3RvcnlcIjtcbmltcG9ydCB7U2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfSBmcm9tIFwiLi4vaW50ZXJmYWNlXCI7XG5cbmV4cG9ydCBsZXQgRGlzcGxheU1vZGVzID0ge1xuICAgIEJMT0NLOiBcImJsb2NrXCIsXG4gICAgU1BMSVQ6IFwic3BsaXRcIixcbiAgICBURVhUOiBcInRleHRcIlxufTtcblxuZnVuY3Rpb24gbWFrZVRhYihuYW1lLCBpY29uLCBtb2RlKSB7XG4gICAgcmV0dXJuIGA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJsb2NrcHktbW9kZS1zZXQtYmxvY2tzXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGRpc3BsYXkucHl0aG9uTW9kZSgpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLnVwZGF0ZU1vZGUuYmluZCgkZGF0YSwgJyR7bW9kZX0nKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtJHtpY29ufSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiYmxvY2tweS1tb2RlLXNldFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIGNoZWNrZWQ+ICR7bmFtZX1cbiAgICAgICAgICAgIDwvbGFiZWw+YDtcbn1cblxuZXhwb3J0IGNvbnN0IFBZVEhPTl9FRElUT1JfSFRNTCA9IGBcblxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi10b29sYmFyIGNvbC1tZC0xMiBidG4tdG9vbGJhclwiXG4gICAgICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJQeXRob24gVG9vbGJhclwiPlxuXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUnVuIEdyb3VwXCI+ICAgICAgICAgXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBibG9ja3B5LXJ1biBub3RyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5leGVjdXRlLnJ1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3M6IHsnYmxvY2tweS1ydW4tcnVubmluZyc6IHVpLmV4ZWN1dGUuaXNSdW5uaW5nfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXBsYXlcIj48L3NwYW4+IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLmV4ZWN1dGUucnVuTGFiZWxcIj48L3NwYW4+XG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgIDwhLS0ga28gaWY6ICRyb290LmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlQmxvY2tzKCkgLS0+XG4gICAgICAgICAgICAke21ha2VUYWIoXCJCbG9ja3NcIiwgXCJ0aC1sYXJnZVwiLCBEaXNwbGF5TW9kZXMuQkxPQ0spfVxuICAgICAgICAgICAgJHttYWtlVGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJUZXh0XCIsIFwiYWxpZ24tbGVmdFwiLCBEaXNwbGF5TW9kZXMuVEVYVCl9XG4gICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVzZXQgR3JvdXBcIj5cbiAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5yZXNldFwiPlxuICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zeW5jXCI+PC9zcGFuPiBSZXNldFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIGtvIGlmOiAhYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlSW1wb3J0RGF0YXNldHNCdXR0b24oKSAmJiAhdWkuc21hbGxMYXlvdXQoKS0tPlxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkltcG9ydCBHcm91cFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbXBvcnREYXRhc2V0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtY2xvdWQtZG93bmxvYWQtYWx0XCI+PC9zcGFuPiBJbXBvcnQgZGF0YXNldHNcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxuICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGRyb3Bkb3duLXRvZ2dsZSBkcm9wZG93bi10b2dnbGUtc3BsaXRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+VG9nZ2xlIERyb3Bkb3duPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9J2Ryb3Bkb3duLWl0ZW0gYmxvY2tweS10b29sYmFyLWRvd25sb2FkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMuZG93bmxvYWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1kb3dubG9hZCc+PC9zcGFuPiBEb3dubG9hZFxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkhpc3RvcnkgR3JvdXBcIiBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNtYWxsTGF5b3V0XCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24udG9nZ2xlSGlzdG9yeU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGU6IHVpLmVkaXRvcnMucHl0aG9uLmlzSGlzdG9yeUF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeyBhY3RpdmU6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IHsgJ2FyaWEtcHJlc3NlZCc6IGRpc3BsYXkuaGlzdG9yeU1vZGUgfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWhpc3RvcnlcIj48L3NwYW4+IEhpc3RvcnlcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIEZ1bGx5IGZ1bmN0aW9uYWwsIGJ1dCBhIGxpdHRsZSB0b28uLiBJbnZhc2l2ZSBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJGdWxsc2NyZWVuIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IGRpc3BsYXkucHl0aG9uTW9kZSgpID09PSAndGV4dCdcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmZ1bGxzY3JlZW5cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1leHBhbmQtYXJyb3dzLWFsdFwiPjwvc3Bhbj4gRnVsbHNjcmVlblxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlNhdmUgR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5TYXZlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkRlbGV0ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmRlbGV0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1lbGxpcHNpcy12XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRXh0cmEgRmVhdHVyZXM8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItcnVuLXF1aWV0bHkgbm90cmFuc2l0aW9uJyByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmV4ZWN1dGUucnVuUXVpZXRseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeydibG9ja3B5LXJ1bi1ydW5uaW5nJzogdWkuZXhlY3V0ZS5pc1J1bm5pbmd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1jb21tZW50LXNsYXNoXCI+PC9zcGFuPiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5leGVjdXRlLnJ1blF1aWV0bHlMYWJlbFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS08ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVuYW1lIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuUmVuYW1lXCI+XG4gICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS1zaWduYXR1cmVcIj48L3NwYW4+IFJlbmFtZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+LS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICAke0hJU1RPUllfVE9PTEJBUl9IVE1MfVxuXG5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIlxuICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLm1lbnUuaXNTdWJtaXR0ZWRcIj5cbiAgICA8L2Rpdj5cbmA7XG5cblxuXG5mdW5jdGlvbiBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKSB7XG4gICAgbGV0IGlweW5iID0gSlNPTi5wYXJzZShjb2RlKTtcbiAgICBsZXQgaXNVc2FibGUgPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIWNlbGwuc291cmNlWzBdLnN0YXJ0c1dpdGgoXCIlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG1ha2VQeXRob24gPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgIGNlbGwuY2VsbF90eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInJydcIitjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpK1wiJycnXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpcHluYi5jZWxscy5maWx0ZXIoaXNVc2FibGUpLm1hcChtYWtlUHl0aG9uKS5qb2luKFwiXFxuXCIpO1xufVxuXG5jbGFzcyBQeXRob25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcuZmluZChcIi5ibG9ja3B5LXB5dGhvbi1ibG9ja21pcnJvclwiKSk7XG4gICAgICAgIEJsb2NrbHkuc2V0UGFyZW50Q29udGFpbmVyKG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXJbMF0pO1xuICAgICAgICB0aGlzLmJtID0gbmV3IEJsb2NrTWlycm9yKHtcbiAgICAgICAgICAgIFwiY29udGFpbmVyXCI6IHRoaXMudGFnWzBdLFxuICAgICAgICAgICAgXCJydW5cIjogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5ydW4uYmluZChtYWluLmNvbXBvbmVudHMuZW5naW5lKSxcbiAgICAgICAgICAgIFwic2tpcFNrdWxwdFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJibG9ja2x5TWVkaWFQYXRoXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5ibG9ja2x5UGF0aCxcbiAgICAgICAgICAgIFwidG9vbGJveFwiOiBtYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveCgpLFxuICAgICAgICAgICAgXCJpbWFnZU1vZGVcIjogdHJ1ZSxcbiAgICAgICAgICAgIGltYWdlRG93bmxvYWRIb29rOiAob2xkVXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFVybDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZVVwbG9hZEhvb2s6IChibG9iKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zdCB1dWlkID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW10pKS5zdWJzdHJpbmcoMzEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1pc3Npb25JZCA9IG1haW4ubW9kZWwuc3VibWlzc2lvbi5pZCgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluLmNvbXBvbmVudHMuc2VydmVyLnVwbG9hZEZpbGUoXCJzdWJtaXNzaW9uXCIsIHN1Ym1pc3Npb25JZCwgYmxvYi5uYW1lLCBibG9iLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZW5kcG9pbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzb2x2ZShKU09OLnN0cmluZ2lmeShtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tcImRvd25sb2FkRmlsZVwiXSArIGA/cGxhY2VtZW50PXN1Ym1pc3Npb24mZGlyZWN0b3J5PSR7c3VibWlzc2lvbklkfSZmaWxlbmFtZT0ke2Jsb2IubmFtZX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBQcm9taXNlLnJlc29sdmUoXCJJbWFnZShcIitKU09OLnN0cmluZ2lmeShVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKStcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnN0cmluZ2lmeShVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VMaXRlcmFsSG9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIGBJbWFnZShcIiR7b2xkVXJsfVwiKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7b2xkVXJsfVwiYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLydoZWlnaHQnOiAnMjAwMHB4J1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogUHJldmVudCBJTlMgYW5kIE9WUiBtb2RlICguLi4gdGhpcy5ibS50ZXh0RWRpdG9yLmNvZGVNaXJyb3IuXG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFrZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkUHl0aG9uTW9kZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKTtcblxuICAgICAgICB0aGlzLm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucygpO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZUV4dHJhQmxvY2tseSgpIHtcbiAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci53b3Jrc3BhY2UuY29uZmlndXJlQ29udGV4dE1lbnUgPSAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiU2NyZWVuc2hvdFwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuU0NSRUVOU0hPVF9CTE9DS1NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgbGV0IG9sZEZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAobmV3RmlsZW5hbWUgIT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGlmIChvbGRGaWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkUHl0aG9uTW9kZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSh0aGlzLm9sZFB5dGhvbk1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRCTUxpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ibS5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRCTUxpc3RlbmVyKTtcblxuICAgICAgICBpZiAobmV3RmlsZW5hbWUgIT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMuYm0uaXNQYXJzb25zID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJtLmlzUGFyc29ucyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmlzUGFyc29ucztcblxuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxpbmVzRXJyb3Iuc3Vic2NyaWJlKChsaW5lcykgPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm0uc2V0SGlnaGxpZ2h0ZWRMaW5lcyhsaW5lcywgXCJlZGl0b3ItZXJyb3ItbGluZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5saW5lc1VuY292ZXJlZC5zdWJzY3JpYmUoKGxpbmVzKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuYm0uc2V0SGlnaGxpZ2h0ZWRMaW5lcyhsaW5lcywgXCJlZGl0b3ItdW5jb3ZlcmVkLWxpbmVcIilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLnVpLnRyYWNlLmhpZ2hsaWdodGVkTGluZS5zdWJzY3JpYmUoKGxpbmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoXCJlZGl0b3ItdHJhY2VkLWxpbmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci10cmFjZWQtbGluZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL3RoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLnJlbmRlcigpO1xuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSB0aGlzIGRvZXNuJ3QgZW5kIHVwIGxvb2tpbmcgcmlnaHQgKGdvIHRvIGEgZGlmZmVyZW50IGVkaXRvciwgY29tZSBiYWNrLCBhbmQgaXQnbGwgYmUgc3F1aXNoZWQpXG4gICAgICAgIC8vdGhpcy5ibS5yZWZyZXNoKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ibS5yZWZyZXNoKCksIDApO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICBpZiAobmV3Q29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gdGhpcy5maWxlLmhhbmRsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciwgZmlsZSB3YXMgYWxyZWFkeSBzaHV0IGRvd24uXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudHMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NvbnRlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBjbG9zaW5nIHRoaXMgZmlsZVxuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlTG9jYWxseV8odGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJtLnNldENvZGUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5ibS5nZXRDb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJtLnJlbW92ZUNoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5PZmZIaXN0b3J5TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJMaW5lU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIGNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYm0uc2V0TW9kZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlLnN1YnNjcmliZShtb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZShtb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUJsb2Nrcy5zdWJzY3JpYmUoZW5hYmxlZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUoRGlzcGxheU1vZGVzLlRFWFQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3guc3Vic2NyaWJlKHRoaXMucmVsb2FkVG9vbGJveC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlSW1hZ2VzLnN1YnNjcmliZShpbWFnZU1vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRJbWFnZU1vZGUoaW1hZ2VNb2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU21hbGwgTGF5b3V0IFN0dWZmXG4gICAgICAgIHRoaXMub2xkSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zbWFsbExheW91dCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVzZVNtYWxsTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnVpLnNtYWxsTGF5b3V0LnN1YnNjcmliZSh1c2VTbWFsbExheW91dCA9PiB7XG4gICAgICAgICAgICBpZiAodXNlU21hbGxMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVNtYWxsTGF5b3V0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub2xkSGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLmhlaWdodCA9IHRoaXMub2xkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuYm0udGV4dEVkaXRvci5yZXNpemVSZXNwb25zaXZlbHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZEhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVzZVNtYWxsTGF5b3V0KCkge1xuICAgICAgICB0aGlzLmJtLnRleHRFZGl0b3IudXBkYXRlR3V0dGVyKHtpbmRlbnRTaWRlYmFyOiBmYWxzZX0pO1xuICAgICAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuYm0uY29uZmlndXJhdGlvbi5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi5oZWlnaHQgPSAzMDA7IC8vIFRPRE86IFBhcmFtZXRlcml6ZSB0aGlzXG4gICAgICAgIHRoaXMuYm0udGV4dEVkaXRvci5yZXNpemVSZXNwb25zaXZlbHkoKTtcbiAgICB9XG5cbiAgICByZWxvYWRUb29sYm94KHRvb2xib3gpIHtcbiAgICAgICAgaWYgKHRvb2xib3ggPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXN0b21Ub29sYm94ID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiP3Rvb2xib3guYmxvY2tweVwiKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21Ub29sYm94ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b29sYm94ID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0b29sYm94ID0gSlNPTi5wYXJzZShjdXN0b21Ub29sYm94LmhhbmRsZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIFRPRE86IEltcHJvdmUgZXJyb3IgbWVzc2FnZSBmb3IgaW5zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICB0b29sYm94ID0gXCJtaW5pbWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi50b29sYm94ID0gdG9vbGJveDtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGludmFsaWQgdG9vbGJveCBiZXR0ZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLnRvb2xib3ggPSBcImVtcHR5XCI7XG4gICAgICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3Rvci5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhZE9ubHkodGhpcy5kZWNpZGVJZk5vdEVkaXRhYmxlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Mub25seVVwbG9hZHMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWRPbmx5KHRoaXMuZGVjaWRlSWZOb3RFZGl0YWJsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnBhcnRJZC5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBwYXJ0IGlkIGNoYW5naW5nIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgbG9hZGVkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlY2lkZUlmTm90RWRpdGFibGUoKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoKSB8fCAoXG4gICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzKCkgJiYgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0UmVhZE9ubHkoaXNSZWFkT25seSkge1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gaXNSZWFkT25seTtcbiAgICAgICAgdGhpcy5ibS5zZXRSZWFkT25seShpc1JlYWRPbmx5KTtcbiAgICB9XG5cbiAgICB1cGxvYWRGaWxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGV2ZW50LnRhcmdldC5maWxlTmFtZTtcbiAgICAgICAgbGV0IGNvZGUgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIuaXB5bmJcIikpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuVXBsb2FkXCIsIFwiXCIsIFwiXCIsIGNvZGUsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvZGUpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lbmdpbmUucnVuKCk7XG4gICAgICAgIC8vIFRPRE86IFJ1biBjb2RlXG4gICAgfVxuXG4gICAgZG93bmxvYWRGaWxlKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZG93bmxvYWRGaWxlKCk7XG4gICAgICAgIGlmIChyZXN1bHQubmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiByZXN1bHQuZXh0ZW5zaW9uID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IHNsdWdnaWZ5KHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm5hbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1pbWV0eXBlID0gXCJ0ZXh0L3gtcHl0aG9uXCI7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5Eb3dubG9hZFwiLCBcIlwiLCBcIlwiLCBcIlwiLCByZXN1bHQubmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQeXRob25FZGl0b3IgPSB7XG4gICAgbmFtZTogXCJQeXRob25cIixcbiAgICBleHRlbnNpb25zOiBbXCIucHlcIiwgXCIucmVhZGluZ1wiXSxcbiAgICBjb25zdHJ1Y3RvcjogUHl0aG9uRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogUFlUSE9OX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFFVSVpfRURJVE9SX0hUTUwgPSBgXHJcbiAgICA8ZGl2PlxyXG4gICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItcXVpelwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIFF1aXpFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1xdWl6XCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgUXVpekVkaXRvciA9IHtcclxuICAgIG5hbWU6IFwiUXVpelwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiLnF1aXpcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogUXVpekVkaXRvclZpZXcsXHJcbiAgICB0ZW1wbGF0ZTogUVVJWl9FRElUT1JfSFRNTFxyXG59OyIsIi8qKlxuICogUGFuZWwgZm9yIGVkaXRpbmcgdGhlIHNldCBvZiBTYW1wbGUgU3VibWlzc2lvbnMuXG4gKiBUaGVzZSBhcmUgbm90IHByb3ZpZGVkIGF0IGFsbCB0byBzdHVkZW50cyB3aXRob3V0IHRoZSBHcmFkZXIgcm9sZS5cbiAqL1xuXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcblxuZXhwb3J0IGNvbnN0IFN1Ym1pc3Npb25TdGF0dXNlcyA9IHtcbiAgICBVTktOT1dOOiBcInVua25vd25cIixcbiAgICBQQVNTRUQ6IFwicGFzc2VkXCIsXG4gICAgRkFJTEVEOiBcImZhaWxlZFwiLFxuICAgIEVSUk9SOiBcImVycm9yXCIsXG4gICAgU0tJUFBFRDogXCJza2lwcGVkXCJcbn07XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVTdWJtaXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgc3RhdGljIEJsYW5rKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FtcGxlU3VibWlzc2lvbihcIlVudGl0bGVkXCIrKGNvdW50IHx8IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VibWlzc2lvblN0YXR1c2VzLlVOS05PV04sIFwiYT0wXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FtcGxlU3VibWlzc2lvbihkYXRhLm5hbWUsIGRhdGEuc3RhdHVzLCBkYXRhLmNvZGUpO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTCA9IGBcbjxkaXY+XG4gICAgPGRpdiBkYXRhLWJpbmQ9XCJmb3JlYWNoOiB7ZGF0YTogYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9uc31cIlxuICAgICAgICBjbGFzcz1cInJvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IG5hbWVcIj48L3NwYW4+XG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1zYW1wbGUtc3VibWlzc2lvbnMtY29kZVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY29kZU1pcnJvckluc3RhbmNlOiBjb2RlXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3RhdHVzXCI+PC9zcGFuPiAgICAgICAgXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gO1xuXG5rby5iaW5kaW5nSGFuZGxlcnMuY29kZU1pcnJvckluc3RhbmNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYmluZGluZyBpcyBmaXJzdCBhcHBsaWVkIHRvIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gU2V0IHVwIGFueSBpbml0aWFsIHN0YXRlLCBldmVudCBoYW5kbGVycywgZXRjLiBoZXJlXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSU5JVFwiKTtcbiAgICAgICAgbGV0IGNtID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEoZWxlbWVudCwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY20uc2V0U2l6ZShcIjEwMCVcIiwgXCIxMDBweFwiKTtcbiAgICAgICAgcmV0dXJuIGNtO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgYmluZGluZyBpcyBmaXJzdCBhcHBsaWVkIHRvIGFuIGVsZW1lbnQsXG4gICAgICAgIC8vIGFuZCBhZ2FpbiB3aGVuZXZlciBhbnkgb2JzZXJ2YWJsZXMvY29tcHV0ZWRzIHRoYXQgYXJlIGFjY2Vzc2VkIGNoYW5nZVxuICAgICAgICAvLyBVcGRhdGUgdGhlIERPTSBlbGVtZW50IGJhc2VkIG9uIHRoZSBzdXBwbGllZCB2YWx1ZXMgaGVyZS5cbiAgICAgICAgY29uc29sZS5sb2coXCJVUERBVEVcIik7XG4gICAgfVxufTtcblxuY2xhc3MgU2FtcGxlU3VibWlzc2lvbnNWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jb2RlTWlycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYnVpbGRFZGl0b3IobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCkge1xuXG4gICAgfVxuXG4gICAgcmVidWlsZEVkaXRvcnMoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVidWlsZGluZyBlZGl0b3JzXCIpO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgLy90aGlzLnJlYnVpbGRFZGl0b3JzKCk7XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksY20pID0+IGNvbnNvbGUubG9nKFwiKysrXCIsIGNtLkNvZGVNaXJyb3IpKSk7XG4gICAgICAgICAgICB0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLCBjbSkgPT4gY20uQ29kZU1pcnJvci5yZWZyZXNoKCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSRUZSRVNIXCIpO1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksIGNtKSA9PiBjbS5Db2RlTWlycm9yLnJlZnJlc2goKSksIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29kZU1pcnJvcnMpO1xuICAgICAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLmVhY2goIChpLCBjbSkgPT4gY20uc2V0VmFsdWUobmV3Q29udGVudHMuam9pbihcIlxcblwiKSkpO1xuICAgICAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLmVhY2goIChpLCBjbSkgPT4gY20ucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9ycy5tYXAoY20gPT4gY20uZ2V0VmFsdWUoKSkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9ycyA9IFtdO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNhbXBsZVN1Ym1pc3Npb25zID0ge1xuICAgIG5hbWU6IFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBTYW1wbGVTdWJtaXNzaW9uc1ZpZXcsXG4gICAgdGVtcGxhdGU6IFNBTVBMRV9TVUJNSVNTSU9OU19IVE1MXG59O1xuIiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBUQUdTX0VESVRPUl9IVE1MID0gYFxuQ3JlYXRlIG5ld1xuSW1wb3J0IGJ5IG5hbWVcbkZpbmQgYnkgb3duZXIvY291cnNlL2tpbmRcblxuVGFnczpcbiAgICBEYXRhOlxuICAgICAgICBOYW1lXG4gICAgICAgIEtpbmRcbiAgICAgICAgTGV2ZWxcbiAgICAgICAgVmVyc2lvblxuICAgICAgICBEZXNjcmlwdGlvblxuICAgIENvbnRyb2xzOlxuICAgICAgICBFZGl0XG4gICAgICAgIFJlbW92ZVxuICAgICAgICBEZWxldGUgXG5gO1xuXG5jbGFzcyBUYWdzRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGFnc1wiKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVGFnc0VkaXRvciA9IHtcbiAgICBuYW1lOiBcIlRhZ3NcIixcbiAgICBleHRlbnNpb25zOiBbXCIhdGFncy5ibG9ja3B5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBUYWdzRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogVEFHU19FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0VESVRPUl9IVE1MID0gYFxuICAgICR7ZGVmYXVsdF9oZWFkZXJ9XG4gICAgPGRpdj5cbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci10ZXh0XCI+PC90ZXh0YXJlYT5cbiAgICA8L2Rpdj5cbmA7XG5cbmNsYXNzIFRleHRFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10ZXh0XCIpWzBdLCB7XG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRleHRFZGl0b3IgPSB7XG4gICAgbmFtZTogXCJUZXh0XCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnR4dFwiXSxcbiAgICBjb25zdHJ1Y3RvcjogVGV4dEVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFRFWFRfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgVE9PTEJPWF9FRElUT1JfSFRNTCA9IGBcclxuICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMlwiXHJcbiAgICAgICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlRvb2xib3ggVG9vbGJhclwiPlxyXG4gICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIlNhdmUgR3JvdXBcIj4gICAgICAgICBcclxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tZWRpdG9yLWpzb24tc2F2ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXNhdmVcIj48L3NwYW4+IFNhdmVcclxuICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci10b29sYm94XCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgVG9vbGJveEVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRvb2xib3hcIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJ0bi1lZGl0b3ItanNvbi1zYXZlXCIpLm9uKFwiY2xpY2tcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnRvb2xib3goKSA9PT0gXCJjdXN0b21cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnJlbG9hZFRvb2xib3goXCJjdXN0b21cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJ0bi1lZGl0b3ItdG9vbGJveC1zYXZlXCIpLm9mZihcImNsaWNrXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFRvb2xib3hFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIlRvb2xib3hcIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIj90b29sYm94LmJsb2NrcHlcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogVG9vbGJveEVkaXRvclZpZXcsXHJcbiAgICB0ZW1wbGF0ZTogVE9PTEJPWF9FRElUT1JfSFRNTFxyXG59OyIsIi8qKlxuICogRWRpdG9ycyBhcmUgaW5mZXJyZWQgZnJvbSBGaWxlbmFtZXMuXG4gKlxuICogVGhlIGVkaXRvciBpcyBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uOlxuICogIC5ibG9ja3B5OiBTcGVjaWFsIGVkaXRvciAod2lsbCBiZSBjaG9zZW4gYnkgZmlsZW5hbWUpXG4gKiAgLnB5OiBQeXRob24gRWRpdG9yXG4gKiAgLm1kOiBNYXJrZG93biBFZGl0b3JcbiAqICAudHh0OiBUZXh0IEVkaXRvciAoYWxzbyB1c2VkIGZvciBvdGhlciB0eXBlcylcbiAqICAucGVtbDogUEVNTCBFZGl0b3JcbiAqICAucG5nLCAuZ2lmLCAuanBlZywgLmpwZywgLmJtcDogSW1hZ2UgRWRpdG9yXG4gKiAgLmpzb246IEpTT04gRWRpdG9yXG4gKiAgLnlhbWw6IFlBTUwgRWRpdG9yXG4gKi9cblxuaW1wb3J0IHtQeXRob25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9weXRob25cIjtcbmltcG9ydCB7VGV4dEVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3RleHRcIjtcbmltcG9ydCB7QXNzaWdtZW50VHlwZSBhcyBBc3NpZ25tZW50VHlwZSwgQXNzaWdubWVudFNldHRpbmdzfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuaW1wb3J0IHtUYWdzRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdGFnc1wiO1xuaW1wb3J0IHtNYXJrZG93bkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL21hcmtkb3duXCI7XG5pbXBvcnQge1NhbXBsZVN1Ym1pc3Npb25zfSBmcm9tIFwiLi9lZGl0b3Ivc2FtcGxlX3N1Ym1pc3Npb25zXCI7XG5pbXBvcnQge0pzb25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9qc29uXCI7XG5pbXBvcnQge1Rvb2xib3hFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90b29sYm94XCI7XG5pbXBvcnQge1F1aXpFZGl0b3J9IGZyb20gXCIuL2VkaXRvci9xdWl6XCI7XG5pbXBvcnQge0ltYWdlRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvaW1hZ2VzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBwb3NzaWJsZSBlZGl0b3JzIGF2YWlsYWJsZVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBFZGl0b3JzRW51bSA9IHtcbiAgICBTVUJNSVNTSU9OOiBcInN1Ym1pc3Npb25cIixcbiAgICBBU1NJR05NRU5UOiBcImFzc2lnbm1lbnRcIixcbiAgICBJTlNUUlVDVElPTlM6IFwiaW5zdHJ1Y3Rpb25zXCIsXG4gICAgT05fUlVOOiBcIm9uX3J1blwiLFxuICAgIE9OX0NIQU5HRTogXCJvbl9jaGFuZ2VcIixcbiAgICBPTl9FVkFMOiBcIm9uX2V2YWxcIixcbiAgICBTVEFSVElOR19DT0RFOiBcInN0YXJ0aW5nX2NvZGVcIixcbiAgICBTQU1QTEVfU1VCTUlTU0lPTlM6IFwic2FtcGxlX3N1Ym1pc3Npb25zXCIsXG4gICAgSU5TVFJVQ1RPUl9GSUxFOiBcImluc3RydWN0b3JfZmlsZVwiXG59O1xuXG5jb25zdCBTUEVDSUFMX05BTUVTUEFDRVMgPSBbXCIhXCIsIFwiXlwiLCBcIj9cIiwgXCIkXCJdO1xuXG5jb25zdCBBVkFJTEFCTEVfRURJVE9SUyA9IFtcbiAgICBUZXh0RWRpdG9yLCBQeXRob25FZGl0b3IsIEFzc2lnbm1lbnRTZXR0aW5ncywgVGFnc0VkaXRvciwgTWFya2Rvd25FZGl0b3IsXG4gICAgU2FtcGxlU3VibWlzc2lvbnMsIEpzb25FZGl0b3IsIFRvb2xib3hFZGl0b3IsIFF1aXpFZGl0b3IsIEltYWdlRWRpdG9yXG5dO1xuXG5leHBvcnQgY29uc3QgRURJVE9SU19IVE1MID0gQVZBSUxBQkxFX0VESVRPUlMubWFwKGVkaXRvciA9PiBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1wYW5lbCBibG9ja3B5LWVkaXRvclwiIFxuICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLnZpZXcoKS5uYW1lID09PSAnJHtlZGl0b3IubmFtZX0nLCBjbGFzczogdWkuZWRpdG9ycy53aWR0aFwiPlxuICAgIDxkaXY+XG4gICAgJHtlZGl0b3IudGVtcGxhdGV9XG4gICAgPC9kaXY+XG48L2Rpdj5cbmBcbiAgICAvKlxuICAgIGBcbjwhLS0ga28gaWY6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfScgLS0+XG4ke2VkaXRvci50ZW1wbGF0ZX1cbjwhLS0gL2tvIC0tPmAqL1xuKS5qb2luKFwiXFxuXCIpO1xuXG5leHBvcnQgY2xhc3MgRWRpdG9ycyB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfID0gW107XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc18gPSB7fTtcbiAgICAgICAgdGhpcy5ieU5hbWVfID0ge307XG4gICAgICAgIEFWQUlMQUJMRV9FRElUT1JTLmZvckVhY2goZWRpdG9yID0+IHRoaXMucmVnaXN0ZXJFZGl0b3IoZWRpdG9yKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lLnN1YnNjcmliZSh0aGlzLmNoYW5nZUVkaXRvciwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJFZGl0b3IoZGF0YSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9IGRhdGEuZXh0ZW5zaW9ucztcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IGRhdGEuY29uc3RydWN0b3IodGhpcy5tYWluLCB0aGlzLnRhZyk7XG4gICAgICAgIGluc3RhbmNlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZF8ucHVzaChpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYnlOYW1lX1tkYXRhLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBpbnN0YW5jZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zX1tleHRlbnNpb25zW2ldXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnlOYW1lX1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cblxuICAgIGNoYW5nZUVkaXRvcihuZXdGaWxlbmFtZSkge1xuICAgICAgICBsZXQgb2xkRWRpdG9yID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBsZXQgbmV3RWRpdG9yID0gdGhpcy5nZXRFZGl0b3IobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVkaXRvci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3RWRpdG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnQuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlRmlsZW5hbWUocGF0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSBwYXRoLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKFNQRUNJQUxfTkFNRVNQQUNFUy5pbmRleE9mKHNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwYWNlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwYXRoLnN1YnN0cihwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB7XCJzcGFjZVwiOiBzcGFjZSwgXCJuYW1lXCI6IG5hbWUsIFwidHlwZVwiOiB0eXBlfTtcbiAgICB9XG5cbiAgICBnZXRFZGl0b3IocGF0aCkge1xuICAgICAgICBsZXQge3NwYWNlLCBuYW1lLCB0eXBlfSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiLmJsb2NrcHlcIiAmJiBwYXRoIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW3BhdGhdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc3NpZ25tZW50VHlwZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnR5cGUoKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnRUeXBlICE9PSBBc3NpZ25tZW50VHlwZS5CTE9DS1BZKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJhbnN3ZXJcIiAmJiB0eXBlID09PSBcIi5weVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiLlwiK2Fzc2lnbm1lbnRUeXBlIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bXCIuXCIrYXNzaWdubWVudFR5cGVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBlZGl0b3IgcmVnaXN0ZXJlZCBmb3IgYXNzaWdubWVudCB0eXBlOlwiLCBhc3NpZ25tZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRfWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudHlwZSgpLCBzcGFjZSwgbmFtZSwgdHlwZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4vc2VydmVyXCI7XG5pbXBvcnQge09uUnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX3J1blwiO1xuaW1wb3J0IHtSdW5Db25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvcnVuXCI7XG5pbXBvcnQge0V2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvZXZhbFwiO1xuaW1wb3J0IHtTYW1wbGVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvc2FtcGxlXCI7XG5pbXBvcnQge09uQ2hhbmdlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX2NoYW5nZVwiO1xuaW1wb3J0IHtPbkV2YWxDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fZXZhbFwiO1xuaW1wb3J0IHtPblNhbXBsZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9zYW1wbGVcIjtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGV4ZWN1dGluZyBQeXRob24gY29kZSBhbmQgcGFzc2luZyB0aGUgcmVzdWx0cyBhbG9uZyB0byBpbnRlcmVzdGVkIGNvbXBvbmVudHMuXG4gKlxuICogSW50ZXJlc3RpbmcgY29tcG9uZW50czpcbiAqICBFeGVjdXRpb24gQnVmZmVyOiBSZXNwb25zaWJsZSBmb3IgY29sbGVjdGluZyB0aGUgdHJhY2UgZHVyaW5nIHByb2dyYW0gZXhlY3V0aW9uLlxuICogICAgICAgICAgICAgICAgICAgIFRoaXMgcHJldmVudHMgS25vY2tvdXRqcyBmcm9tIHVwZGF0aW5nIHRoZSBlZGl0b3IgZHVyaW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5RWRpdG9yfVxuICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlFbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5leGVjdXRpb25Nb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb247XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IHtcbiAgICAgICAgICAgIHJ1bjogbmV3IFJ1bkNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBldmFsOiBuZXcgRXZhbENvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvblJ1bjogbmV3IE9uUnVuQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBuZXcgT25DaGFuZ2VDb25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25FdmFsOiBuZXcgT25FdmFsQ29uZmlndXJhdGlvbihtYWluKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByZWNvbmZpZ3VyZSBza3VscHQgc28gd2UgY2FuIHBhcnNlXG4gICAgICAgIFNrLmNvbmZpZ3VyZSh0aGlzLmNvbmZpZ3VyYXRpb25zLnJ1bi5nZXRTa3VscHRPcHRpb25zKCkpO1xuXG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB0cmFjaW5nIHdoaWxlIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGluZ1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmFibGUgZnVuY3Rpb24gdG8gYmUgcnVuIHdoZW4gZXhlY3V0aW9uIGhhcyBmdWxseSBlbmRlZCxcbiAgICAgICAgICogd2hldGhlciBpdCBzdWNjZWVkcyBvciBmYWlscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25FeGVjdXRpb25CZWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25FeGVjdXRpb25FbmQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHJlcG9ydHNcbiAgICAgKi9cbiAgICByZXNldFJlcG9ydHMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLmV4ZWN1dGlvbk1vZGVsLnJlcG9ydHM7XG4gICAgICAgIHJlcG9ydFtcInZlcmlmaWVyXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wibW9kZWxcIl0gPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgfTtcblxuICAgIHJlc2V0U3R1ZGVudE1vZGVsKCkge1xuICAgICAgICBsZXQgc3R1ZGVudCA9IHRoaXMuZXhlY3V0aW9uTW9kZWwuc3R1ZGVudDtcbiAgICAgICAgc3R1ZGVudC5jYWxscyA9IHt9O1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRTdGVwKG51bGwpO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQubGFzdFN0ZXAoMCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudExpbmUobnVsbCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFRyYWNlRGF0YS5yZW1vdmVBbGwoKTtcbiAgICAgICAgc3R1ZGVudC5yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgc3R1ZGVudC50cmFjaW5nID0gW107XG4gICAgfVxuXG4gICAgcmVzZXRFeGVjdXRpb25CdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uQnVmZmVyID0ge1xuICAgICAgICAgICAgXCJ0cmFjZVwiOiBbXSxcbiAgICAgICAgICAgIFwic3RlcFwiOiAwLFxuICAgICAgICAgICAgXCJsaW5lXCI6IDAsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgaW50ZXJmYWNlIGFzcGVjdHMgb2YgdGhlIHByZXZpb3VzIFJ1bi5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy8gVE9ETzogQ2xlYXIgb3V0IGFueSBjb3ZlcmFnZS90cmFjZS9lcnJvciBoaWdobGlnaHRzIGluIGVkaXRvcnNcbiAgICAgICAgLy8gUmVzZXQgZXhlY3V0aW9uIGluIG1vZGVsXG4gICAgICAgIHRoaXMucmVzZXRTdHVkZW50TW9kZWwoKTtcbiAgICAgICAgLy8gR2V0IHJlcG9ydHMgcmVhZHlcbiAgICAgICAgdGhpcy5yZXNldFJlcG9ydHMoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBleGVjdXRpb24gYnVmZmVyXG4gICAgICAgIHRoaXMucmVzZXRFeGVjdXRpb25CdWZmZXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBjb25zb2xlIG9mIHByaW50ZWQgc3R1ZmZcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5jbGVhcigpO1xuICAgICAgICAvLyBDbGVhciBvdXQgYW55IG9sZCBmZWVkYmFja1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5jbGVhcigpO1xuICAgIH1cblxuICAgIGRlbGF5ZWRSdW4oZGlzYWJsZUZlZWRiYWNrPWZhbHNlKSB7XG4gICAgICAgIC8vdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyQoXCIuYmxvY2tweS1ydW5cIikuYWRkQ2xhc3MoXCJibG9ja3B5LXJ1bi1ydW5uaW5nXCIpO1xuICAgICAgICB0aGlzLnJ1bihkaXNhYmxlRmVlZGJhY2spO1xuICAgICAgICAvL3NldFRpbWVvdXQodGhpcy5ydW4uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcblxuICAgIH1cblxuICAgIHJ1bihkaXNhYmxlRmVlZGJhY2s9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ydW4udXNlKHRoaXMpO1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpICYmICFkaXNhYmxlRmVlZGJhY2spIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZVNlY3JldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25SdW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgIH1cblxuICAgIG9uUnVuKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uUnVuLnVzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgICAudGhlbih0aGlzLmV4ZWN1dGlvbkVuZF8uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgbGV0IGV2YWx1YXRpb25JbnB1dCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuZXZhbHVhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coZXZhbHVhdGlvbklucHV0KTtcbiAgICAgICAgZXZhbHVhdGlvbklucHV0LnRoZW4oKHVzZXJJbnB1dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ldmFsLnVzZSh0aGlzLCB1c2VySW5wdXQpO1xuICAgICAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUZlZWRiYWNrKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlU2VjcmV0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLm9uRXZhbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLmV2YWx1YXRlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25FdmFsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uRXZhbC51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vbkNoYW5nZS51c2UodGhpcyk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UoKCkgPT5cbiAgICAgICAgICAgIFNrLmltcG9ydE1haW5XaXRoQm9keSh0aGlzLmNvbmZpZ3VyYXRpb24uZmlsZW5hbWUsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5jb2RlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zeXNtb2R1bGVzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlZCB3aGVuZXZlciB0aGUgUHl0aG9uIGNvZGUgY2hhbmdlc1xuICAgICAqL1xuICAgIG9uX2NoYW5nZSgpIHtcbiAgICAgICAgbGV0IEZJTEVOQU1FID0gXCJvbl9jaGFuZ2VcIjtcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgaW5zdHJ1Y3RvciBoYXMgbm90IGRlZmluZWQgYW55dGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwucHJvZ3JhbXNbRklMRU5BTUVdKCkudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdGF0dXMoXCJjaGFuZ2luZ1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVDb2RlKCk7XG4gICAgICAgIC8vIE9uIHN0ZXAgZG9lcyBub3QgcGVyZm9ybSBwYXJzZSBhbmFseXNpcyBieSBkZWZhdWx0IG9yIHJ1biBzdHVkZW50IGNvZGVcbiAgICAgICAgbGV0IGVuZ2luZSA9IHRoaXM7XG4gICAgICAgIGxldCBmZWVkYmFjayA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrO1xuICAgICAgICBlbmdpbmUucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIGVuZ2luZS52ZXJpZnlDb2RlKCk7XG4gICAgICAgIGVuZ2luZS51cGRhdGVQYXJzZSgpO1xuICAgICAgICBlbmdpbmUucnVuSW5zdHJ1Y3RvckNvZGUoRklMRU5BTUUsIHRydWUsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0pIHtcbiAgICAgICAgICAgICAgICAvLyBTVUNDRVNTLCBTQ09SRSwgQ0FURUdPUlksIExBQkVMLCBNRVNTQUdFLCBEQVRBLCBISURFXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogb25seSBzaG93IHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZ2luZS5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKG1vZHVsZS4kZCk7XG4gICAgICAgICAgICAgICAgZW5naW5lLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0YXR1cyhcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZW5naW5lLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJlbmdpbmVcIiwgXCJvbl9jaGFuZ2VcIik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBhdHRlbXB0IHRvIGNhbGwgdGhlIGRlZmluZWQgb25FeGVjdXRpb25FbmQsXG4gICAgICogYnV0IHdpbGwgZG8gbm90aGluZyBpZiB0aGVyZSBpcyBubyBmdW5jdGlvbiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkVuZF8oKSB7XG4gICAgICAgIGlmICh0aGlzLm9uRXhlY3V0aW9uRW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0aW9uRW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkJlZ2luXygpIHtcbiAgICAgICAgaWYgKHRoaXMub25FeGVjdXRpb25CZWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX01PRFVMRSA9IFwibGV0ICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obW9kKXsgcmV0dXJuIG1vZDsgfVwiO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBob2xkaW5nIHNldHRpbmdzIG9mIGEgcGFydGljdWxhciBydW4gY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgaXMgdGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBvdGhlciBjb25maWd1cmF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeXNtb2R1bGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgLy8gQWNjZXNzIHBvaW50IGZvciBpbnN0cnVjdG9yIGRhdGFcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIFNrLmNvbnNvbGUgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlO1xuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICBTay5jb25maWd1cmUodGhpcy5nZXRTa3VscHRPcHRpb25zKCkpO1xuICAgICAgICAvLyBTZXQgb3BlbkZpbGUgYXMgbWVjaGFuaXNtIHRvIHJlYWQgZmlsZXNcbiAgICAgICAgU2suaW5Ccm93c2VyID0gdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBGdW5jdGlvbiB0byBjb252ZXJ0IGZpbGVuYW1lcyB0byBVUkxzXG4gICAgICAgIFNrLmZpbGVUb1VSTCA9IHRoaXMuZ2V0VXJsRnJvbUZpbGVuYW1lLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IHJlcXVlc3RzXG4gICAgICAgIFNrLnJlcXVlc3RzR2V0ID0gKHVybCwgZGF0YSwgdGltZW91dCkgPT4gdGhpcy5vcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCk7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFwiZG8geW91IHdhbnQgdG8gd2FpdD8gcHJvbXB0XCJcbiAgICAgICAgU2sudGltZW91dEhhbmRsZXIgPSAodGltZVBhc3NlZCwgZXhlY0xpbWl0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByb21wdE1lc3NhZ2UgPSB0aGlzLmdldFRpbWVvdXRQcm9tcHQodGltZVBhc3NlZC8xMDAwID4gMzApO1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gcHJvbXB0KHByb21wdE1lc3NhZ2UsIFNrLmV4ZWNMaW1pdC8xMDAwKTtcbiAgICAgICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCB8fCBkZWxheT09MCkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gU2suZXhlY0xpbWl0ICsgcGFyc2VJbnQoZGVsYXksIDEwKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiBkZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWxheTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0YWNoIGJlZm9yZUNhbGxcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IHRoaXMuYmVmb3JlQ2FsbC5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRUaW1lb3V0UHJvbXB0KGxvbmdUaW1lb3V0KSB7XG4gICAgICAgIGlmIChsb25nVGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIHByb2dyYW0gaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBydW4gKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBpcyB0YWtpbmcgYSB3aGlsZSB0byBydW4uIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2t1bHB0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fZnV0dXJlX186IFNrLnB5dGhvbjMsXG4gICAgICAgICAgICAvLyBpbXBvcnRcbiAgICAgICAgICAgIHJlYWQ6IHRoaXMuaW1wb3J0RmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gb3BlblxuICAgICAgICAgICAgLy9maWxlb3BlbjogdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gZmlsZS53cml0ZVxuICAgICAgICAgICAgZmlsZXdyaXRlOiB0aGlzLndyaXRlRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gcHJpbnRcbiAgICAgICAgICAgIG91dHB1dDogdGhpcy5wcmludC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gaW5wdXRcbiAgICAgICAgICAgIGlucHV0ZnVuOiB0aGlzLmlucHV0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBpbnB1dGZ1blRha2VzUHJvbXB0OiB0cnVlLFxuICAgICAgICAgICAgLy8gTWVkaWEgSW1hZ2UgUHJveHkgVVJMXG4gICAgICAgICAgICBpbWFnZVByb3h5OiB0aGlzLmdldEltYWdlUHJveHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzZXQgYnkgdGhlIHN5c3RlbSBzbyB3ZSBjYW4gdXNlIG91ciBvd24gc2VydmVycyBpbiBwcmFjdGljZVxuICAgICAgICAgICAgZW1vamlQcm94eTogKHBhcnQpID0+IGBodHRwczovL3R3ZW1vamkubWF4Y2RuLmNvbS92LzEzLjEuMC9zdmcvJHtwYXJ0LnRvTG93ZXJDYXNlKCl9LnN2Z2AsXG4gICAgICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBrZWVwIHRoZSBnbG9iYWxzXG4gICAgICAgICAgICByZXRhaW5HbG9iYWxzOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0VXJsRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5maWxlc1RvVXJsc1tmaWxlbmFtZV07XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiICsgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFjY2VzcyBTa3VscHQgYnVpbHQtaW5zLiBUaGlzIGlzIHByZXR0eSBnZW5lcmljLCB0YWtlblxuICAgICAqIGFsbW9zdCBkaXJlY3RseSBmcm9tIHRoZSBTa3VscHQgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBweXRob24gZmlsZW5hbWUgKGUuZy4sIFwib3NcIiBvciBcInBwcmludFwiKSB0aGF0IHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIG9mIHRoZSBmaWxlICh3ZWlyZCwgcmlnaHQ/KVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpc24ndCBmb3VuZC5cbiAgICAgKi9cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG5cbiAgICBvcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCkge1xuICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBtb2NrVXJsRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgaWYgKG1vY2tVcmxEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFVSTCBEYXRhIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9ja1VybERhdGEgPSBKU09OLnBhcnNlKG1vY2tVcmxEYXRhLmhhbmRsZSgpKTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gbW9ja1VybERhdGEpIHtcbiAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YS5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2NrVXJsRGF0YVtmaWxlbmFtZV0ubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ja1VybERhdGFbZmlsZW5hbWVdW2ldID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ucmVhZEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWplY3QobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogXCIrdXJsK1wiIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIC8vfSk7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIHdyaXRlRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaW5wdXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIGNsZWFySW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cygpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlucHV0TW9ja0Z1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2sucXVldWVkSW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gU2sucXVldWVkSW5wdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXRJbWFnZVByb3h5KHVybCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgc3RlcCgpIHtcblxuICAgIH1cblxuICAgIGxhc3RTdGVwKCkge1xuXG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0IHN1Y2Nlc3MgZXhlY3V0aW9uXCIpO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3QgZmFpbHVyZSBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmluYWxseShyZXN1bHQpIHtcbiAgICAgICAgLy8gRm9yY2UgUHlnYW1lIHRvIHN0b3AgdHJhcHBpbmcga2V5Ym9hcmQgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHVtbXlPdXRTYW5kYm94KCkge1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC9zYW5kYm94LnB5XCJdID0gXCJjbGFzcyBTYW5kYm94OiBwYXNzXFxuZGVmIHJ1bigpOiBwYXNzXFxuZGVmIHJlc2V0KCk6IHBhc3NcXG5cIjtcbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUUkFDS0lORyBDQUxMXCIsIGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGZhc3RjYWxsIHRvbz8gQ2hlY2sgaG93IHRoYXQgd29ya3MgaW4gU2t1bHB0IHNpZGVcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICBpZiAoIShcImNhbGxzXCIgaW4gc3R1ZGVudE1vZGVsKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZnVuY3Rpb25OYW1lIGluIHN0dWRlbnRNb2RlbC5jYWxscykpIHtcbiAgICAgICAgICAgIHN0dWRlbnRNb2RlbC5jYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgLy8gR2V0IGFjdHVhbCBwYXJhbWV0ZXIgbmFtZXMhIVxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBwb3NhcmdzLmxlbmd0aDsgaSs9IDEpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1wiK2ldID0gcG9zYXJnc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa3dhcmdzICYmIGt3YXJnc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19BUkdTXCJdID0ga3dhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0tXQVJHU1wiXSA9IGt3YXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXS5wdXNoKGFyZ3MpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuLi90cmFjZVwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSwgY29kZSkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdG8gYmUgY3VycmVudGx5IGFkZGVkIGxpbmVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiXyA9IFwiICsgY29kZTtcbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gdHJ1ZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLkFkZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIHRoaXMuY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1FdmFsdWF0ZS5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludFZhbHVlKFNrLmZmaS5yZW1hcFRvSnMobW9kdWxlLiRkLl8uJHIoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnMuanNcIjtcbmltcG9ydCB7JHNrX21vZF9pbnN0cnVjdG9yfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3JcIjtcbmltcG9ydCB7JHNrX21vZF9jb3ZlcmFnZX0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL2NvdmVyYWdlXCI7XG5pbXBvcnQgeyRwZWRhbF90cmFjZXJ9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9wZWRhbF90cmFjZXJcIjtcbmltcG9ydCB7Y2hvbXBTcGVjaWFsRmlsZX0gZnJvbSBcIi4uL2ZpbGVzXCI7XG5cbmNvbnN0IFVUSUxJVFlfTU9EVUxFX0NPREUgPSBcInZhciAkYnVpbHRpbm1vZHVsZSA9IFwiICsgJHNrX21vZF9pbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG5jb25zdCBDT1ZFUkFHRV9NT0RVTEVfQ09ERSA9ICRza19tb2RfY292ZXJhZ2U7XG5cbmV4cG9ydCBjbGFzcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIEluc3RydWN0b3JzIGdldCA0IHNlY29uZHNcbiAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogNzAwMDtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgLy8gU3RlcHBlciEgRXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc3RhdGVtZW50LlxuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IG51bGw7IC8vIDEwICoxMDAwXG4gICAgICAgIC8vIE11dGUgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcih0cnVlKTtcbiAgICAgICAgLy8gRGlzYWJsZSBpbnB1dCBib3hcbiAgICAgICAgU2sucXVldWVkSW5wdXQgPSBbXTtcbiAgICAgICAgLy8gVE9ETyBTay5pbnB1dGZ1biA9IEJsb2NrUHlFbmdpbmUuaW5wdXRNb2NrRnVuY3Rpb247XG4gICAgICAgIC8vIFRPRE86IEFsbG93IGlucHV0IGZ1bmN0aW9uIHRvIGRpc2FibGUgdGhlIHRpbWVyLCBzb21laG93XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJlZm9yZUNhbGwgY2hlY2tlciB1bmxlc3Mgc3BlY2lmaWNhbGx5IHJlcXVlc3RlZFxuICAgICAgICBTay5iZWZvcmVDYWxsQmFja3VwID0gU2suYmVmb3JlQ2FsbDtcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIC8vIEVuYWJsZSB1dGlsaXR5IG1vZGVcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gVVRJTElUWV9NT0RVTEVfQ09ERTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9jb3ZlcmFnZS5weVwiXSA9IENPVkVSQUdFX01PRFVMRV9DT0RFO1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIG5lZWRzIHRvIGJlIG9wdGltaXplZFxuICAgICAgICAvL2NvbnN0IFBFREFMX1RSQUNFUl9NT0RVTEVfQ09ERSA9IFNrLmNvbXBpbGUoJHBlZGFsX3RyYWNlciwgXCJ0cmFjZXIucHlcIiwgXCJleGVjXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3RyYWNlci5weVwiXSA9ICRwZWRhbF90cmFjZXI7XG4gICAgICAgIGRlbGV0ZSBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLmpzXCJdO1xuICAgICAgICAvLyBUT0RPOiBNb2NrIFBlZGFsJ3MgdHJhY2VyIG1vZHVsZSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2ZXJzaW9uXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcIi4vX2luc3RydWN0b3IvX19pbml0X18uanNcIl0gPSBFTVBUWV9NT0RVTEU7XG4gICAgICAgIC8vIFJldXNlIGFueSBleGlzdGluZyBzeXNtb2R1bGVzIHRoYXQgd2UgcHJldmlvdXNseSBmb3VuZCwgYnV0IG5vdCBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIHRoaXMuc3lzbW9kdWxlcyA9IHRoaXMuY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCk7XG4gICAgICAgIC8vIEhvcnJpZmljIGhhY2ssIHRvIHByZXZlbnQgVGlmYSBmcm9tIGNhY2hpbmcgYSBiYWQgdmVyc2lvbiBvZiB0aGUgc3R1ZGVudHMnIGltcG9ydFxuICAgICAgICBTay5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMgPSB0aGlzLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgc3VwZXIucHJpbnQodmFsdWUpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJQcmludGVkOlwiLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCkge1xuICAgICAgICBsZXQgc3lzbW9kdWxlcyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIF9fbWFpbl9fIG1vZHVsZXNcbiAgICAgICAgaWYgKHN5c21vZHVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgb2YgdGhpcy5nZXRBbGxGaWxlbmFtZXMoKSkge1xuICAgICAgICAgICAgICAgIGxldCBza0ZpbGVuYW1lID0gbmV3IFNrLmJ1aWx0aW4uc3RyKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAvKmlmIChzeXNtb2R1bGVzLnF1aWNrJGxvb2t1cChza0ZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzLnBvcCRpdGVtKHNrRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICAgIHN5c21vZHVsZXMucG9wJGl0ZW0oc2tGaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5c21vZHVsZXM7XG4gICAgfVxuXG4gICAgZ2V0QWxsU3R1ZGVudEZpbGVzKCkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHtcbiAgICAgICAgICAgIFwiYW5zd2VyLnB5XCI6IHRoaXMubWFpbi5tb2RlbC51aS5maWxlcy5nZXRTdHVkZW50Q29kZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNraXAgc3BlY2lhbCBpbnN0cnVjdG9yIGZpbGVzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGlmICghKFwiIV4kI1wiLmluY2x1ZGVzKGZpbGUuZmlsZW5hbWUoKVswXSkpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXNbY2hvbXBTcGVjaWFsRmlsZShmaWxlLmZpbGVuYW1lKCkpXSA9IGZpbGUuY29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluY2x1ZGUgbm9ybWFsIHN0dWRlbnQgZXh0cmEgZmlsZXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlLmZpbGVuYW1lKCldID0gZmlsZS5jb250ZW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH1cblxuICAgIGdldEFsbEZpbGVuYW1lcygpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW4oZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gY2hvbXBTcGVjaWFsRmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIucHlcIikpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJfX21haW5fX1wiLFxuICAgICAgICAgICAgXCJfaW5zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgLi4udGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5tYXAoZmlsZSA9PiBcIl9pbnN0cnVjdG9yLlwiICsgY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgICAgICAuLi50aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKCkubWFwKGZpbGUgPT4gY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBjaGVjayB5b3VyIGNvZGUgKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlIChvciBnZXQgaGVscCBmcm9tIGFuIGluc3RydWN0b3IpLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGlzIHRha2luZyBhIGxpdHRsZSB3aGlsZSB0byBjaGVjayB5b3VyIGNvZGU7IGl0IG1pZ2h0IGp1c3QgbmVlZCBhIGxpdHRsZSBtb3JlIHRpbWUuIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiK2ZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlblVSTCh1cmwsIGRhdGEsIHRpbWVvdXQpIHtcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgcGFyYW1ldGVycyBhcmUgbWlzYWxpZ25lZC4uP1xuICAgICAgICBpZiAoZGF0YS52ID09PSBcIk9QRU5BSVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLm9wZW5haVByb3h5KHRpbWVvdXQudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIub3BlblVSTCh1cmwsIGRhdGEsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfTU9EVUxFO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgLy9yZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+PlwiLCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCksIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpIDwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBuZXh0SW5wdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8qcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKFNrLnF1ZXVlZElucHV0LnBvcCgpKTtcbiAgICAgICAgfSk7Ki9cbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIGxldCBzdHVkZW50TW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkhFWSBJTlNUUlVDVE9SIENBTExcIiwgZnVuY3Rpb25OYW1lLCBzdHVkZW50TW9kZWwudHJhY2luZyk7XG4gICAgICAgIGlmIChzdHVkZW50TW9kZWwudHJhY2luZyAmJiBzdHVkZW50TW9kZWwudHJhY2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1cGVyLmJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuXG5leHBvcnQgY2xhc3MgT25DaGFuZ2VDb25maWd1cmF0aW9uIGV4dGVuZHMgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIm9uX2NoYW5nZS5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS50cmlnZ2VyT25DaGFuZ2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge2ZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0LCBJTlNUUlVDVE9SX01BUktFUiwgTkVXX0xJTkVfUkVHRVh9IGZyb20gXCIuL29uX3J1blwiO1xuaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50Q29kZSwgaW5zdHJ1Y3RvckNvZGUsIHF1aWNrLCBpc1NhZmUpIHtcbiAgICBsZXQgc2FmZUNvZGUgPSBKU09OLnN0cmluZ2lmeShzdHVkZW50Q29kZSk7XG5cbiAgICByZXR1cm4gYFxuZnJvbSB1dGlsaXR5IGltcG9ydCAqXG5cbiMgTG9hZCBpbiBzb21lIGNvbW1vbmx5IHVzZWQgdG9vbHNcbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuZnJvbSBwZWRhbC5zYW5kYm94LmNvbW1hbmRzIGltcG9ydCAqXG5mcm9tIHBlZGFsLmNvcmUuY29tbWFuZHMgaW1wb3J0ICpcblxuIyBCYWNrdXAgdGhlIGZlZWRiYWNrXG5vbl9ydW5fZmVlZGJhY2sgPSBbXVxuZm9yIGZlZWRiYWNrIGluIE1BSU5fUkVQT1JULmZlZWRiYWNrOlxuICAgIG9uX3J1bl9mZWVkYmFjay5hcHBlbmQoZmVlZGJhY2spXG5NQUlOX1JFUE9SVC5mZWVkYmFjay5jbGVhcigpXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIEFkZCBpbiBldmFsdWF0ZWQgc3R1ZmYgZnJvbSBsYXN0IHRpbWVcbnN0dWRlbnQgPSBnZXRfc2FuZGJveCgpXG4jIFRPRE86IFdoYXQgYWJvdXQgbmV3IGlucHV0cyBzaW5jZSB3ZSBsYXN0IHJhbi9ldmFsZWQ/XG4jIE1BSU5fUkVQT1JULnN1Ym1pc3Npb24uZmlsZXNbJ2V2YWx1YXRpb24nXSA9ICR7c2FmZUNvZGV9XG5ldmFsdWF0ZSgke3NhZmVDb2RlfVsnZXZhbHVhdGlvbiddKVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiX2luc3RydWN0b3Iub25fZXZhbFwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSB8fCBcIlwiO1xuXG4gICAgICAgIGxldCBkaXNhYmxlVGlmYSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaWZhKCk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQuZXZhbHVhdGlvbiB8fCBcIk5vbmVcIjtcbiAgICAgICAgbGV0IHN0dWRlbnRGaWxlcyA9IHRoaXMuZ2V0QWxsU3R1ZGVudEZpbGVzKCk7XG4gICAgICAgIHN0dWRlbnRGaWxlc1tcImV2YWx1YXRpb25cIl0gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudC5ldmFsdWF0aW9uIHx8IFwiTm9uZVwiO1xuICAgICAgICB0aGlzLmR1bW15T3V0U2FuZGJveCgpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3RvckNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudEZpbGVzLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4+XCIsIGluc3RydWN0b3JDb2RlKTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldChpbnN0cnVjdG9yQ29kZSk7IC8vaW5zdHJ1Y3RvckNvZGUuc3BsaXQoTkVXX0xJTkVfUkVHRVgpLmxlbmd0aDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICBcImNvZGVcIjogaW5zdHJ1Y3RvckNvZGUsXG4gICAgICAgICAgICBcImxpbmVPZmZzZXRcIjogbGluZU9mZnNldFxuICAgICAgICAgICAgLy8nY29tcGxldGUnOiBmYWxzZSAvLyBBY3R1YWxseSwgbGV0J3MgdXNlIHVuZGVmaW5lZCBmb3Igbm93LlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICAvL1NrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZSk7XG4gICAgICAgIGxldCByZXN1bHRzID0gbW9kdWxlLiRkLm9uX2V2YWwuJGQ7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZS4kZCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKE1hdGgubWF4KG9sZFNjb3JlLCBzY29yZSkpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPbkV2YWwgZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIkdyYWNlZnVsRXhpdFwiKSB7XG4gICAgICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImNvZGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiZXJyb3JcIl0gPSBlcnJvcjtcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImxpbmVfb2Zmc2V0XCJdID0gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGFmdGVyKGVycm9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdG9yQ29kZS5pbmRleE9mKElOU1RSVUNUT1JfTUFSS0VSKTtcbiAgICBjb25zdCBiZWZvcmUgPSBpbnN0cnVjdG9yQ29kZS5zbGljZSgwLCBpbmRleCk7XG4gICAgY29uc3QgbWF0Y2ggPSBiZWZvcmUubWF0Y2goTkVXX0xJTkVfUkVHRVgpO1xuICAgIHJldHVybiBtYXRjaCA/ICgxK21hdGNoLmxlbmd0aCkgOiAwO1xufVxuXG5leHBvcnQgY29uc3QgSU5TVFJVQ1RPUl9NQVJLRVIgPSBcIiMjI1J1biB0aGUgYWN0dWFsIGluc3RydWN0b3IgY29kZSMjI1wiO1xuZXhwb3J0IGNvbnN0IE5FV19MSU5FX1JFR0VYID0gL1xcbi9nO1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50RmlsZXMsIGluc3RydWN0b3JDb2RlLCBxdWljaywgaXNTYWZlKSB7XG4gICAgbGV0IHNhZmVDb2RlID0gSlNPTi5zdHJpbmdpZnkoc3R1ZGVudEZpbGVzKTtcbiAgICBsZXQgc2tpcF90aWZhID0gcXVpY2sgPyBcIlRydWVcIjogXCJGYWxzZVwiO1xuXG4gICAgLy8gVE9ETzogQWRkIGluIFNrLnF1ZXVlZElucHV0IHRvIGJlIHBhc3NlZCBpblxuXG4gICAgcmV0dXJuIGBcbiMgU3VwcG9ydCBvdXIgc3lzbW9kdWxlcyBoYWNrIGJ5IGNsZWFyaW5nIG91dCBhbnkgbGluZ2VyaW5nIG9sZCBkYXRhXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuTUFJTl9SRVBPUlQuY2xlYXIoKVxuXG5mcm9tIGJha2VyeSBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBTZXQgdGhlIHNlZWQgdG8gdGhlIHN1Ym1pc3Npb24gSUQgYnkgZGVmYXVsdD9cbmZyb20gcGVkYWwucXVlc3Rpb25zIGltcG9ydCBzZXRfc2VlZFxuc2V0X3NlZWQoc3RyKGdldF9tb2RlbF9pbmZvKFwic3VibWlzc2lvbi5pZFwiKSkpXG5cbiMgSW5pdGlhbGl6ZSB0aGUgQmxvY2tQeSBlbnZpcm9ubWVudFxucGVkYWwgPSBzZXR1cF9lbnZpcm9ubWVudChza2lwX3RpZmE9JHtza2lwX3RpZmF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3J1bj1za2lwX3J1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzPWlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9maWxlPSdhbnN3ZXIucHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcz0ke3NhZmVDb2RlfSlcbnN0dWRlbnQgPSBwZWRhbC5maWVsZHNbJ3N0dWRlbnQnXVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ydW5cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuICAgICAgICAvLyBQdXQgdGhlIGlucHV0IGluZGV4IGJhY2sgdG8gdGhlIGZyb250LCBzbyB3ZSBjYW4gcmVwbGF5IGlucHV0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMSk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICBsZXQgc3R1ZGVudEZpbGVzID0gdGhpcy5nZXRBbGxTdHVkZW50RmlsZXMoKTtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKTsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICAvL2xpbmVPZmZzZXQgPSAwOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGggLSBsaW5lT2Zmc2V0IC0gNDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IEludGVyZXN0aW5nIHNpdHVhdGlvbi4gSWYgeW91IGhhdmUgYW4gaW5zdHJ1Y3Rvci1maWxlIChub3QgYSBzdHVkZW50LWZpbGUpLFxuICAgICAgICB0aGVuIGl0IGdldHMgaW1wb3J0ZWQgaW50byBzeXNtb2R1bGVzIGFzIGBfaW5zdHJ1Y3Rvci5NT0RVTEVfTkFNRWAuIEJ1dCB0aGUgaW5zdHJ1Y3RvclxuICAgICAgICBzY3JpcHQgd2lsbCBhdHRlbXB0IHRvIGltcG9ydCBpdCBhcyBgTU9EVUxFX05BTUVgLCBhbmQgZmFpbC4gVU5MRVNTIHRoZSAqc3R1ZGVudCogaGFzXG4gICAgICAgIHByZXZpb3VzbHkgaW1wb3J0ZWQgdGhhdCBtb2R1bGUgc3VjY2Vzc2Z1bGx5LiBTbyB0aGVyZSdzIGEgY29tbW9uIGNhc2UgaGVyZSB3aGVyZSB0aGVcbiAgICAgICAgc3R1ZGVudHMnIGNvZGUgZmFpbHMgdG8gaW1wb3J0IHRoZSBtb2R1bGUgVEhFUkVCWSBicmVha2luZyB0aGUgaW5zdHJ1Y3RvciBjb2RlLlxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgLy8gVE9ETyBMb2dnaW5nISEhIVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiT25SdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgLy8gVE9ETzogQWN0dWFsbHkgcGFyc2UgcmVzdWx0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3IuZ2xvYmFscyA9IFNrLmdsb2JhbHM7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzID0gU2suc3lzbW9kdWxlcztcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVzdWx0cyA9IG1vZHVsZS4kZC5vbl9ydW4uJGQ7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc2NvcmUpKTtcbiAgICAgICAgbGV0IG9sZFNjb3JlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoKTtcbiAgICAgICAgc2NvcmUgPSBNYXRoLm1heChvbGRTY29yZSwgc2NvcmUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zY29yZShzY29yZSk7XG4gICAgICAgIC8vIEhpZGUgc3RhdHVzXG4gICAgICAgIGxldCBoaWRlID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLkhJREUpO1xuICAgICAgICAvLyBBbmQgZmlyZSB0aGUgcmVzdWx0IVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvbihzY29yZSwgc3VjY2VzcywgaGlkZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgLy9hZnRlcihtb2R1bGUpO1xuXG4gICAgICAgIC8qaWYgKHN1Y2Nlc3MgJiYgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmlkKCkpO1xuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoIVNrLmV4ZWN1dGlvblJlcG9ydHMuaW5zdHJ1Y3Rvci5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiT25SdW4gZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIkdyYWNlZnVsRXhpdFwiKSB7XG4gICAgICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImNvZGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiZXJyb3JcIl0gPSBlcnJvcjtcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImxpbmVfb2Zmc2V0XCJdID0gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGFmdGVyKGVycm9yKTtcbiAgICB9XG59XG5cblxuLypcbiMgVGhlIGZvbGxvd2luZyBpcyB0aGUgb2xkIGluc3RydWN0b3IgY29kZSwgbGVhdmluZyBpdCBoZXJlIGZvciBub3cuXG5cbmZyb20gcGVkYWwuY29yZS5yZXBvcnQgaW1wb3J0IE1BSU5fUkVQT1JUXG4jIFN1cHBvcnQgb3VyIHN5c21vZHVsZXMgaGFjayBieSBjbGVhcmluZyBvdXQgYW55IGxpbmdlcmluZyBvbGQgZGF0YVxuTUFJTl9SRVBPUlQuY2xlYXIoKVxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCBjb250ZXh0dWFsaXplX3JlcG9ydFxuY29udGV4dHVhbGl6ZV9yZXBvcnQoJHtzYWZlQ29kZX0sIFwiYW5zd2VyLnB5XCIpXG4ke3RpZmFBbmFseXNpc31cbmZyb20gcGVkYWwuc2FuZGJveC5zYW5kYm94IGltcG9ydCBTYW5kYm94XG5mcm9tIHBlZGFsLnNhbmRib3ggaW1wb3J0IGNvbXBhdGliaWxpdHlcbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuc3R1ZGVudCA9IE1BSU5fUkVQT1JUWydzYW5kYm94J11bJ3J1biddID0gU2FuZGJveCgpXG5zdHVkZW50LnJlcG9ydF9leGNlcHRpb25zX21vZGUgPSBUcnVlXG5sb2coZ2V0X21vZGVsX2luZm8oJ2V4ZWN1dGlvbi5pbnB1dCcpKVxuc3R1ZGVudC5zZXRfaW5wdXQoZ2V0X21vZGVsX2luZm8oJ2V4ZWN1dGlvbi5pbnB1dCcpKVxuaWYgbm90IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJyk6XG4gICAgY29tcGF0aWJpbGl0eS5ydW5fc3R1ZGVudChyYWlzZV9leGNlcHRpb25zPUZhbHNlKVxuI2xvZyhzdHVkZW50LmRhdGEpXG4jc3R1ZGVudCA9IGdldF9zdHVkZW50X2RhdGEoKVxuI2Vycm9yLCBwb3NpdGlvbiA9IGdldF9zdHVkZW50X2Vycm9yKClcbiNjb21wYXRpYmlsaXR5LnJhaXNlX2V4Y2VwdGlvbihlcnJvciwgcG9zaXRpb24pXG5ydW5fc3R1ZGVudCA9IGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnRcbnJlc2V0X291dHB1dCA9IGNvbXBhdGliaWxpdHkucmVzZXRfb3V0cHV0XG5xdWV1ZV9pbnB1dCA9IGNvbXBhdGliaWxpdHkucXVldWVfaW5wdXRcbmdldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LmdldF9vdXRwdXRcbmdldF9wbG90cyA9IGNvbXBhdGliaWxpdHkuZ2V0X3Bsb3RzXG5jb21wYXRpYmlsaXR5LnRyYWNlX2xpbmVzID0gdHJhY2VfbGluZXNcbmZyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xucXVlc3Rpb25zLnNob3dfcXVlc3Rpb24gPSBzZXRfaW5zdHJ1Y3Rpb25zXG4jIFRPRE86IFJlbW92ZSB0aGUgbmVlZCBmb3IgdGhpcyBoYWNrIVxuZGVmIGNhcHR1cmVfb3V0cHV0KGZ1bmMsICphcmdzKTpcbiAgIHJlc2V0X291dHB1dCgpXG4gICBzdHVkZW50LmNhbGwoZnVuYy5fX25hbWVfXywgKmFyZ3MpXG4gICByZXR1cm4gZ2V0X291dHB1dCgpXG5jb21wYXRpYmlsaXR5LmNhcHR1cmVfb3V0cHV0ID0gY2FwdHVyZV9vdXRwdXRcblxuZnJvbSBwZWRhbC5jYWl0LmNhaXRfYXBpIGltcG9ydCBwYXJzZV9wcm9ncmFtXG4ke2luc3RydWN0b3JDb2RlfVxuZnJvbSBwZWRhbC5yZXNvbHZlcnMgaW1wb3J0IHNpbXBsZVxuZmluYWwgPSBzaW1wbGUucmVzb2x2ZSgpXG5TVUNDRVNTID0gZmluYWwuc3VjY2Vzc1xuU0NPUkUgPSBmaW5hbC5zY29yZVxuQ0FURUdPUlkgPSBmaW5hbC5jYXRlZ29yeVxuTEFCRUwgPSBmaW5hbC50aXRsZVxuTUVTU0FHRSA9IGZpbmFsLm1lc3NhZ2VcbkRBVEEgPSBmaW5hbC5kYXRhXG5ISURFID0gZmluYWwuaGlkZV9jb3JyZWN0bmVzc1xuXG4gKi8iLCJpbXBvcnQge09uUnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vb25fcnVuXCI7XG5cbmV4cG9ydCBjbGFzcyBPblNhbXBsZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBPblJ1bkNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIm9uX3J1bi5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge1N0dWRlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zdHVkZW50XCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5cbmV4cG9ydCBjbGFzcyBSdW5Db25maWd1cmF0aW9uIGV4dGVuZHMgU3R1ZGVudENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC51aS5maWxlcy5nZXRTdHVkZW50Q29kZSgpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVN0dWRlbnRSdW4oKSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVGaWxlKFwiYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGVcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5jb2RlKTtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG5cbiAgICAgICAgZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyc2UoKTtcblxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHNbXCJ2ZXJpZmllclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBCb29sZWFuKHRoaXMuY29kZS50cmltKCkpLFxuICAgICAgICAgICAgXCJjb2RlXCI6IHRoaXMuY29kZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgU2suZW52aXJvbiA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBTay5lbnZpcm9uID0gbmV3IFNrLmJ1aWx0aW4uZGljdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW50ZXJUYWcgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnByaW50ZXJUYWcsXG4gICAgICAgICAgICB3aWR0aCA9IHByaW50ZXJUYWcud2lkdGgoKS01MCxcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDMwMCwgcHJpbnRlclRhZy5oZWlnaHQoKS01MCk7XG4gICAgICAgIFNrLmVudmlyb24uc2V0JGl0ZW0obmV3IFNrLmJ1aWx0aW4uc3RyKFwiREVTSUdORVJfV0lORE9XX1dJRFRIXCIpLCBuZXcgU2suYnVpbHRpbi5pbnRfKE1hdGgucm91bmQod2lkdGgpKSk7XG4gICAgICAgIFNrLmVudmlyb24uc2V0JGl0ZW0obmV3IFNrLmJ1aWx0aW4uc3RyKFwiREVTSUdORVJfV0lORE9XX0hFSUdIVFwiKSwgbmV3IFNrLmJ1aWx0aW4uaW50XyhNYXRoLnJvdW5kKGhlaWdodCkpKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBcImlucHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICAgIFwib3V0cHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCgpLm1hcChsaW5lID0+IGxpbmUuY29udGVudCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJcIiwgXCJcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmZpbmlzaFR1cnRsZXMoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKFNrLmdsb2JhbHMpO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5yZXN1bHRzID0gbW9kdWxlO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmJlZ2luRXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnQucGFyc2VyLnN1Y2Nlc3MgJiYgcmVwb3J0LnZlcmlmaWVyLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJSdW4uUHJvZ3JhbVwiLCBcIlByb2dyYW1FcnJvck91dHB1dFwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGVycm9yLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge1N0dWRlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zdHVkZW50XCI7XG5cbmV4cG9ydCBjbGFzcyBTYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgU3R1ZGVudENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIFRPRE86IEZpeCB0byBiZSB0aGUgY3VycmVudCBzYW1wbGUgc3VibWlzc2lvblxuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJhbnN3ZXIucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJwcmludCgnTm90IHJlYWR5IHlldCEnKVwiO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnNcIjtcblxuZXhwb3J0IGNsYXNzIFN0dWRlbnRDb25maWd1cmF0aW9uIGV4dGVuZHMgQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gTGltaXQgZXhlY3V0aW9uIHRvIDQgc2Vjb25kc1xuICAgICAgICBsZXQgc2V0dGluZ3MgPSB0aGlzLm1haW4ubW9kZWwuc2V0dGluZ3M7XG4gICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IDUwMDA7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKCk7XG4gICAgICAgIC8vIFN0ZXBwZXIhIEV4ZWN1dGVkIGFmdGVyIGV2ZXJ5IHN0YXRlbWVudC5cbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSB0aGlzLnN0ZXAuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBVbm11dGUgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcihmYWxzZSk7XG5cbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCBhZnRlciBlYWNoIHN0ZXBcbiAgICAgICAgLy8gYWZ0ZXJTaW5nbGVFeGVjdXRpb25cblxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3V0aWxpdHkvX19pbml0X18uanNcIl0gPSBFTVBUWV9NT0RVTEU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhmaWxlbmFtZSwgZm91bmQpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKFNrLmJ1aWx0aW5GaWxlcyAmJiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogXCIgKyBmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGltcG9ydEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb3JiaWRkZW4oZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkZpbGUgbm90IGFjY2Vzc2libGU6ICdcIiArIGZpbGVuYW1lICsgXCInXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkJ1aWx0LWluIG1vZHVsZXMgbm90IGFjY2Vzc2libGUuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5wdXQocHJvbXB0TWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5pbnB1dChwcm9tcHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpc0ZvcmJpZGRlbihmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChcInNyYy9saWIvdXRpbGl0eS9cIikgfHxcbiAgICAgICAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJzcmMvbGliL3BlZGFsL1wiKSB8fFxuICAgICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcIi4vX2luc3RydWN0b3IvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFwiU3RlcHNcIiB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjb2RlLCBtZWFudCB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgdG8gdGhlIFNrdWxwdFxuICAgICAqIGVudmlyb25tZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdsb2JhbHMgLSBIYXNoIHRoYXQgbWFwcyB0aGUgbmFtZXMgb2YgZ2xvYmFsIHZhcmlhYmxlcyAoU3RyaW5ncykgdG8gdGhlaXIgU2t1bHB0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhbHMgLSBIYXNoIHRoYXQgbWFwcyB0aGUgbmFtZXMgb2YgbG9jYWwgdmFyaWFibGVzIChTdHJpbmdzKSB0byB0aGVpciBTa3VscHQgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVOdW1iZXIgLSBUaGUgY29ycmVzcG9uZGluZyBsaW5lIG51bWJlciBpbiB0aGUgc291cmNlIGNvZGUgdGhhdCBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uTnVtYmVyIC0gVGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIG51bWJlciBpbiB0aGUgc291cmNlIGNvZGUgdGhhdCBpcyBiZWluZyBleGVjdXRlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpbmsgb2YgaXQgYXMgdGhlIFwiWFwiIHBvc2l0aW9uIHRvIHRoZSBsaW5lTnVtYmVyJ3MgXCJZXCIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHB5dGhvbiBmaWxlIGJlaW5nIGV4ZWN1dGVkIChlLmcuLCBcIl9fbWFpbl9fLnB5XCIpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEb2NzdHJpbmcgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGFuIGFjdHVhbCBsaW5lIG9yIGEgZG9jc3RyaW5nLlxuICAgICAqL1xuICAgIHN0ZXAoZ2xvYmFscywgbG9jYWxzLCBsaW5lTnVtYmVyLCBjb2x1bW5OdW1iZXIsIGZpbGVuYW1lLCBpc0RvY3N0cmluZywgYXN0TmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIC8qaWYgKGV4ZWNTdGFjaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4ZWNTdGFjay5tYXAoKFtuLCBvXSkgPT4gW24sIHsuLi5vfV0pKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGVwID0gdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXA7XG4gICAgICAgICAgICBnbG9iYWxzID0gdGhpcy5tYWluLmNvbXBvbmVudHMudHJhY2UucGFyc2VHbG9iYWxzKHsuLi5nbG9iYWxzLCAuLi5sb2NhbHN9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRyYWNlIGxvY2FsIHZhcmlhYmxlcyBwcm9wZXJseVxuICAgICAgICAgICAgLy9sZXQgbG9jYWxzID0gdGhpcy5tYWluLmNvbXBvbmVudHMudHJhY2UucGFyc2VHbG9iYWxzKGxvY2Fscyk7XG4gICAgICAgICAgICAvL09iamVjdC5hc3NpZ24oZ2xvYmFscywgbG9jYWxzKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBcInN0ZXBcIjogY3VycmVudFN0ZXAsXG4gICAgICAgICAgICAgICAgXCJmaWxlbmFtZVwiOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAvLydibG9jayc6IGhpZ2hsaWdodE1hcFtsaW5lTnVtYmVyLTFdLFxuICAgICAgICAgICAgICAgIFwibGluZVwiOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIFwiY29sdW1uXCI6IGNvbHVtbk51bWJlcixcbiAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjogZ2xvYmFscy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIFwibW9kdWxlc1wiOiBnbG9iYWxzLm1vZHVsZXMsXG4gICAgICAgICAgICAgICAgXCJpc0RvY3N0cmluZ1wiOiBpc0RvY3N0cmluZyxcbiAgICAgICAgICAgICAgICBcImFzdFwiOiBhc3ROYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwID0gY3VycmVudFN0ZXAgKyAxO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgU2t1bHB0IGV4ZWN1dGlvbiB0byB0ZXJtaW5hdGUgdGhlIGV4ZWN1dGlvbkJ1ZmZlclxuICAgICAqIGFuZCBoYW5kIGl0IG9mZiB0byB0aGUgZXhlY3V0aW9uIHRyYWNlIGluIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBsYXN0U3RlcCgpIHtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb247XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRMaW5lKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQubGFzdExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICB9O1xuXG4gICAgZ2V0TGluZXMoYXN0KSB7XG4gICAgICAgIGxldCB2aXNpdGVkTGluZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB2aXNpdEJvZHkgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubGluZW5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkTGluZXMuYWRkKG5vZGUubGluZW5vKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vcmVsc2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9yZWxzZS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmZpbmFsYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZmluYWxib2R5LmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2aXNpdEJvZHkoYXN0KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmlzaXRlZExpbmVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGUgcGFyc2UgaW5mb3JtYXRpb24gaXMgdXAtdG8tZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVBhcnNlKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICAvLyBIb2xkIGFsbCB0aGUgYWN0dWFsbHkgZGlzY292ZXJlZCBsaW5lcyBmcm9tIHRoZSBwYXJzZVxuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgLy8gQXR0ZW1wdCBhIHBhcnNlXG4gICAgICAgIGxldCBhc3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcGFyc2UgPSBTay5wYXJzZSh0aGlzLmZpbGVuYW1lLCB0aGlzLmNvZGUpO1xuICAgICAgICAgICAgYXN0ID0gU2suYXN0RnJvbVBhcnNlKHBhcnNlLmNzdCwgdGhpcy5maWxlbmFtZSwgcGFyc2UuZmxhZ3MpO1xuICAgICAgICAgICAgbGluZXMgPSB0aGlzLmdldExpbmVzKGFzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXBvcnQgdGhlIGVycm9yXG4gICAgICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJlbXB0eVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogbGluZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3VjY2Vzc2Z1bCBwYXJzZVxuICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiYXN0XCI6IGFzdCxcbiAgICAgICAgICAgIFwiZW1wdHlcIjogYXN0LmJvZHkubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzaG93RXJyb3JzKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAocmVwb3J0W1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5jbGVhcihcIkV4ZWN1dGlvbiBmaW5pc2hlZC4gTm8gZXJyb3JzIHRvIHJlcG9ydC5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZVNlY3JldEVycm9yKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgaWYgKCFyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBlcnJvckJ1dHRvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZmVlZGJhY2sucHJlc2VudFJ1bkVycm9yKHJlcG9ydC5zdHVkZW50LmVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLmF0dHIoXCJ0aXRsZVwiLCBcIkNsaWNrIHRvIHNlZSBPcmlnaW5hbCBFcnJvclwiKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnRvb2x0aXAoe1widHJpZ2dlclwiOiBcImhvdmVyXCIsIFwiY29udGFpbmVyXCI6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludH0pO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uY2xpY2soKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUihtZXNzYWdlKSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHthcnJheU1vdmUsIGNhcGl0YWxpemUsIHB5U3RyfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuZXhwb3J0IGxldCBGRUVEQkFDS19IVE1MID0gYFxuXG48c3BhbiBjbGFzcz0nYmxvY2tweS1mbG9hdGluZy1mZWVkYmFjayB0ZXh0LW11dGVkLWxlc3MgcHVsbC1yaWdodCBwb3NpdGlvbi1zdGlja3kgc3RpY2t5LXRvcCdcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIiByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1sYWJlbD1cIk5ldyBGZWVkYmFjayBBbGVydFwiPlxuICAgIE5ldyBmZWVkYmFjayAmdWFycjtcbjwvc3Bhbj5cblxuPGRpdiBjbGFzcz0nYmxvY2tweS1mZWVkYmFjayBibG9ja3B5LXBhbmVsJ1xuICAgICAgICAgICAgcm9sZT1cInJlZ2lvblwiIGFyaWEtbGFiZWw9XCJGZWVkYmFja1wiXG4gICAgICAgICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLmNvbnNvbGUuc2l6ZVwiPlxuXG4gICAgPGRpdj5cbiAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICA8IS0tIGtvIGlmbm90OiB1aS5zZWNvbmRSb3cuaGlkZVRyYWNlQnV0dG9uIC0tPlxuICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0J1xuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuc2Vjb25kUm93LnN3aXRjaExhYmVsXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDwhLS0gUG9zaXRpdmUgRmVlZGJhY2sgUmVnaW9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlIGZsb2F0LXJpZ2h0XCI+XG4gICAgICAgIFxuICAgIFxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBBY3R1YWwgRmVlZGJhY2sgUmVnaW9uIC0tPiAgICBcbiAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nPkZlZWRiYWNrOiA8L3N0cm9uZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2JhZGdlIGJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnkgZmVlZGJhY2stYmFkZ2UnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHVpLmZlZWRiYWNrLmJhZGdlLFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5mZWVkYmFjay5jYXRlZ29yeVwiPkZlZWRiYWNrIEtpbmQ8L3NwYW4+XG4gICAgICAgIDxzbWFsbCBkYXRhLWJpbmQ9XCJ0ZXh0OiAoMTAwKnN1Ym1pc3Npb24uc2NvcmUoKSkrJyUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBkaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKVwiXG4gICAgICAgICAgICBjbGFzcz1cInRleHQtbXV0ZWRcIj48L3NtYWxsPlxuICAgICAgICA8c21hbGwgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZlZWRiYWNrLnJlc2V0U2NvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbCgpICYmIHN1Ym1pc3Npb24uc2NvcmUoKSA+IDBcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0ZXh0LW11dGVkXCIgc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXJcIj48dT4ocmVzZXQpPC91Pjwvc21hbGw+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZyBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stbGFiZWxcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidGV4dDogZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsXCI+PC9zdHJvbmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLW1lc3NhZ2VcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiPlxuICAgICAgICA8IS0tIFRoZSB0aGFuayB5b3UgbWVzc2FnZSB3aWxsIGFwcGVhciBhYm92ZSB0aGUgc3BhbiAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLXRoYW5rLXlvdVwiPlRoYW5rIHlvdSE8L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPHNtYWxsIGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1yZXNwb25zZS1mdWxsXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiByaWdodFwiXG4gICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmZlZWRiYWNrLnByb3ZpZGVSYXRpbmdzKCkgJiYgZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKCkgJiYgZGlzcGxheS5zaG93UmF0aW5nKClcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7XCIgY2xhc3M9XCJmYXIgZmEtbWludXMtc3F1YXJlXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5mZWVkYmFjay5mbGlwUmF0aW5nXCI+PC9zcGFuPlxuICAgICAgICBSYXRlIHRoaXMgRmVlZGJhY2s6XG4gICAgICAgIDxzcGFuIHN0eWxlPVwiY3Vyc29yOiBwb2ludGVyOyBmb250LXNpemU6IDIwcHhcIiBjbGFzcz1cImJsb2NrcHktcmF0aW5nIGZhLXRodW1icy11cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogKCk9PnVpLmZlZWRiYWNrLnJhdGUoJ3RodW1icy11cCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB1aS5mZWVkYmFjay5oYXNSYXRlZENsYXNzXCI+PC9zcGFuPlxuPCEtLSAgICAgICAgPHNwYW4gc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7IGZvbnQtc2l6ZTogMjBweFwiIGNsYXNzPVwiYmxvY2tweS1yYXRpbmcgZmEtbWVoXCItLT5cbjwhLS0gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogKCk9PnVpLmZlZWRiYWNrLnJhdGUoJ21laCcpLC0tPlxuPCEtLSAgICAgICAgICAgICAgICAgICAgICAgIGNzczogdWkuZmVlZGJhY2suaGFzUmF0ZWRDbGFzc1wiPjwvc3Bhbj4tLT5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7IGZvbnQtc2l6ZTogMjBweFwiIGNsYXNzPVwiYmxvY2tweS1yYXRpbmcgZmEtdGh1bWJzLWRvd25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6ICgpPT51aS5mZWVkYmFjay5yYXRlKCd0aHVtYnMtZG93bicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB1aS5mZWVkYmFjay5oYXNSYXRlZENsYXNzXCI+PC9zcGFuPlxuICAgIDwvc21hbGw+XG4gICAgPHNtYWxsIGNsYXNzPVwiYmxvY2tweS1mZWVkYmFjay1yZXNwb25zZS1jb2xsYXBzZWRcIiBcbiAgICAgICAgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiAwOyBib3R0b206IDBcIlxuICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKSAmJiAhZGlzcGxheS5zaG93UmF0aW5nKClcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7IHZlcnRpY2FsLWFsaWduOiBtaWRkbGVcIiBjbGFzcz1cImZhciBmYS1wbHVzLXNxdWFyZVwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmVlZGJhY2suZmxpcFJhdGluZ1wiPjwvc3Bhbj4gUmF0ZVxuICAgIDwvc21hbGw+XG48L2Rpdj4gICAgICAgICAgICBcbmA7XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmVlZGJhY2sge1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyB0aGUgZmVlZGJhY2sgYXJlYSwgd2hlcmUgdXNlcnMgYXJlIHRvbGQgdGhlIHN0YXRlIG9mIHRoZWlyXG4gICAgICogcHJvZ3JhbSdzIGV4ZWN1dGlvbiBhbmQgZ2l2ZW4gZ3VpZGFuY2UuIEFsc28gbWFuYWdlcyB0aGUgY3JlYXRpb24gb2YgdGhlIFRyYWNlIFRhYmxlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHRoaXMge0Jsb2NrUHlGZWVkYmFja31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBUaGUgSFRNTCBvYmplY3QgdGhpcyBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjaztcblxuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWNhdGVnb3J5XCIpO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLWxhYmVsXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbWVzc2FnZVwiKTtcbiAgICAgICAgdGhpcy5wb3NpdGl2ZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZVwiKTtcblxuICAgICAgICAvLyBUT0RPOiBJZiB0aGV5IGNoYW5nZSB0aGUgc3R1ZGVudCBleHRyYSBmaWxlcywgYWxzbyB1cGRhdGUgdGhlIGRpcnR5IGZsYWdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNjcmVlbiAodGFrZXMgMSBzZWNvbmQpIHRvIG1ha2UgdGhlIEZlZWRiYWNrIGFyZWEgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgJChcImh0bWwsIGJvZHlcIikuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMudGFnLm9mZnNldCgpLnRvcFxuICAgICAgICB9LCA3MDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmZWVkYmFjayBhcmVhIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGZWVkYmFja1Zpc2libGUoKSB7XG4gICAgICAgIGxldCB2aXNpYmlsaXR5QnVmZmVyID0gMTAwO1xuICAgICAgICBsZXQgdG9wT2ZFbGVtZW50ID0gdGhpcy50YWcub2Zmc2V0KCkudG9wO1xuICAgICAgICAvL2xldCBib3R0b21PZkVsZW1lbnQgPSB0aGlzLnRhZy5vZmZzZXQoKS50b3AgKyB0aGlzLnRhZy5vdXRlckhlaWdodCgpO1xuICAgICAgICBsZXQgYm90dG9tT2ZFbGVtZW50ID0gdG9wT2ZFbGVtZW50ICsgdmlzaWJpbGl0eUJ1ZmZlcjtcbiAgICAgICAgbGV0IGJvdHRvbU9mU2NyZWVuID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICAgICBsZXQgdG9wT2ZTY3JlZW4gPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgIC8vYm90dG9tX29mX2VsZW1lbnQgLT0gNDA7IC8vIFVzZXIgZnJpZW5kbHkgcGFkZGluZ1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHRvcE9mRWxlbWVudCA8IGJvdHRvbU9mU2NyZWVuKSAmJlxuICAgICAgICAgICAgKHRvcE9mU2NyZWVuIDwgYm90dG9tT2ZFbGVtZW50KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgb3V0cHV0IGN1cnJlbnRseSBpbiB0aGUgZmVlZGJhY2sgYXJlYS4gQWxzbyByZXNldHMgdGhlIHByaW50ZXIgYW5kXG4gICAgICogYW55IGhpZ2hsaWdodGVkIGxpbmVzIGluIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgY2xlYXIobWVzc2FnZT1cIlJlYWR5XCIpIHtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5jYXRlZ29yeShudWxsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuaGlkZGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZC5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5jbGVhclBvc2l0aXZlRmVlZGJhY2soKTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeS5vZmYoXCJjbGlja1wiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaGFzUmF0ZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZmluZEZpcnN0RXJyb3JMaW5lKGZlZWRiYWNrRGF0YSkge1xuICAgICAgICBpZiAoZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cCkge1xuICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJsb2NhdGlvblwiKSk7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGxvY2F0aW9uLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGluZVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKmZvciAobGV0IGkgPSBmZWVkYmFja0RhdGEubGVuZ3RoLTE7IGkgPj0gMDsgaS09IDEpIHtcbiAgICAgICAgICAgIGlmIChcInBvc2l0aW9uXCIgaW4gZmVlZGJhY2tEYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlZWRiYWNrRGF0YVtpXS5wb3NpdGlvbi5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsOyovXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3VsYXJGZWVkYmFjaygpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG1vZGVsIHdpdGggdGhlc2UgbmV3IGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICogQHBhcmFtIGV4ZWN1dGlvblJlc3VsdHNcbiAgICAgKi9cbiAgICB1cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIC8vIFBhcnNlIG91dCBkYXRhXG4gICAgICAgIGxldCBtZXNzYWdlID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLk1FU1NBR0UpO1xuICAgICAgICBsZXQgY2F0ZWdvcnkgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuQ0FURUdPUlkpO1xuICAgICAgICBsZXQgbGFiZWwgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuTEFCRUwpO1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5ISURFKTtcbiAgICAgICAgbGV0IGRhdGEgPSBleGVjdXRpb25SZXN1bHRzLkRBVEE7XG4gICAgICAgIGxldCBwb3NpdGl2ZXMgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuUE9TSVRJVkUpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIGJhc2VkIG9uIGFzc2lnbm1lbnRzJyBzZXR0aW5nc1xuICAgICAgICBsZXQgaGlkZVNjb3JlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCk7XG4gICAgICAgIGlmIChoaWRlU2NvcmUgJiYgY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBjYXRlZ29yeSA9IFwibm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBsYWJlbCA9IFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJObyBlcnJvcnMgcmVwb3J0ZWQuXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1hcCB0byBleHBlY3RlZCBCbG9ja1B5IGxhYmVsc1xuICAgICAgICBpZiAoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnN0cnVjdG9yXCIgJiYgbGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gXCJleHBsYWluXCIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCJJbnN0cnVjdG9yIEZlZWRiYWNrXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBwcmVzZW50IGEgbGFjayBvZiBlcnJvciBhcyBiZWluZyBpbmNvcnJlY3RcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGFjY29yZGluZ2x5XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1haW4udXRpbGl0aWVzLm1hcmtkb3duKG1lc3NhZ2UpLnJlcGxhY2UoLzxwcmU+XFxuL2csIFwiPHByZT5cXG5cXG5cIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICAvL2xldCBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5maW5kKFwicHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vfSwgNDAwKTtcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0cmFja2luZyBzdHVkZW50IGZpbGUsIGxldCdzIHRyYWNrIHRoZSBpbnN0cnVjdG9yIGZpbGVcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiSW50ZXJ2ZW50aW9uXCIsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgXCJhbnN3ZXIucHlcIik7XG5cbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBwcmV2aW91c2x5IGhpZ2hsaWdodGVkIGxpbmVzXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciBvbiBhIGxpbmUgYW5kIHJlcG9ydCB0aGF0XG4gICAgICAgIGxldCBsaW5lID0gQmxvY2tQeUZlZWRiYWNrLmZpbmRGaXJzdEVycm9yTGluZShkYXRhKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lICE9PSBudWxsICYmIGxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmVydCB0aGUgc2V0IG9mIHRyYWNlZCBsaW5lc1xuICAgICAgICBsZXQgc3R1ZGVudFJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChzdHVkZW50UmVwb3J0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCB1bmNvdmVyZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnBhcnNlci5saW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWRlbnRSZXBvcnQubGluZXMuaW5kZXhPZihsaW5lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jb3ZlcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZCh1bmNvdmVyZWRMaW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9zaXRpdmVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aXZlRGF0YSA9IHBvc2l0aXZlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zaXRpdmVGZWVkYmFjayhwb3NpdGl2ZURhdGEubWVzc2FnZSwgXCJzdGFyXCIsIFwiZ3JlZW5cIiwgKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwocG9zaXRpdmVEYXRhLnRpdGxlLCBwb3NpdGl2ZURhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJQb3NpdGl2ZUZlZWRiYWNrKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgYWRkUG9zaXRpdmVGZWVkYmFjayh0ZXh0LCBpY29uLCBjb2xvciwgb25jbGljaywgdG9FbmQpIHtcbiAgICAgICAgbGV0IHBvc2l0aXZlID0gJChcIjxzcGFuPjwvc3Bhbj5cIik7XG4gICAgICAgIHBvc2l0aXZlLmFkZENsYXNzKFwiYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZS1pY29uIGZhcyBmYS1cIitpY29uKTtcbiAgICAgICAgcG9zaXRpdmUuY3NzKFwiY29sb3JcIiwgY29sb3IpO1xuICAgICAgICBwb3NpdGl2ZS5hdHRyKFwidGl0bGVcIiwgdGV4dCk7XG4gICAgICAgIGlmICh0b0VuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5hcHBlbmQocG9zaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5wcmVwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGl2ZS50b29sdGlwKHtcInRyaWdnZXJcIjogXCJob3ZlclwiLCBcImNvbnRhaW5lclwiOiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnR9KTtcbiAgICAgICAgaWYgKG9uY2xpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpdmUuY2xpY2sob25jbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUuaG92ZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GZWVkYmFja1wiLCBcInBvc2l0aXZlXCIsIFwiaG92ZXJcIiwgdGV4dCwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgYW55IGFjY3VtdWxhdGVkIGZlZWRiYWNrXG4gICAgICovXG4gICAgcHJlc2VudEZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKTtcblxuICAgICAgICB0aGlzLmNhdGVnb3J5Lm9mZihcImNsaWNrXCIpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGxGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IExvZ2dpbmdcbiAgICAgICAgLy90aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJmZWVkYmFja1wiLCBjYXRlZ29yeStcInxcIitsYWJlbCwgbWVzc2FnZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlGZWVkYmFja1VwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBwcm9jZXNzU2luZ2xlRmVlZGJhY2soZWxlbWVudCkge1xuICAgICAgICBjb25zdCB0aXRsZSA9IGVsZW1lbnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJ0aXRsZVwiKSkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBjYXBpdGFsaXplKGVsZW1lbnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJjYXRlZ29yeVwiKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBlbGVtZW50LnRwJGdldGF0dHIobmV3IHB5U3RyKFwia2luZFwiKSkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gU2subWlzY2V2YWwuaXNUcnVlKGVsZW1lbnQpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGVsZW1lbnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJtZXNzYWdlXCIpKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCB1bnVzZWRfbWVzc2FnZSA9IGVsZW1lbnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJ1bnVzZWRfbWVzc2FnZVwiKSkudG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgPT09IFwiTm9uZVwiID8gdW51c2VkX21lc3NhZ2UgOiBtZXNzYWdlO1xuICAgICAgICBjb25zdCBqdXN0aWZpY2F0aW9uID0gZWxlbWVudC50cCRnZXRhdHRyKG5ldyBweVN0cihcImp1c3RpZmljYXRpb25cIikpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJwYXJlbnRcIikpO1xuICAgICAgICBjb25zdCBoYXNQYXJlbnQgPSAhU2suYnVpbHRpbi5jaGVja05vbmUocGFyZW50KTtcbiAgICAgICAgbGV0IHNjb3JlID0gZWxlbWVudC50cCRnZXRhdHRyKG5ldyBweVN0cihcInJlc29sdmVkX3Njb3JlXCIpKTtcbiAgICAgICAgc2NvcmUgPSBzY29yZSA9PT0gU2suYnVpbHRpbi5ub25lLm5vbmUkID8gXCJcIlxuICAgICAgICAgICAgOiBzY29yZS50cCRuYW1lID09PSBcImZsb2F0XCJcbiAgICAgICAgICAgICAgICA/IFwiK1wiICsgTWF0aC5yb3VuZChzY29yZS52KjEwMCkudG9TdHJpbmcoKSArIFwiJVwiXG4gICAgICAgICAgICAgICAgOiBzY29yZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW2VsZW1lbnQsIHBhcmVudCwgYFxuICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdC1ncm91cC1pdGVtIGZsZXgtY29sdW1uIGFsaWduLWl0ZW1zLXN0YXJ0XCIgJHtoYXNQYXJlbnQgPyBcInN0eWxlPSdtYXJnaW4tbGVmdDogNTBweDsnXCIgOiBcIlwifT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggdy0xMDAganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+PHN0cm9uZyBjbGFzcz1cIm1iLTFcIiBzdHlsZT1cIiR7YWN0aXZlID8gXCJcIiA6IFwidGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XCJ9XCI+JHt0aXRsZX08L3N0cm9uZz4gKCR7Y2F0ZWdvcnl9IC0gJHtraW5kfSk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZSBiYWRnZS1pbmZvIGJhZGdlLXBpbGxcIj4ke3Njb3JlfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHthY3RpdmUgPyBcIlwiIDogXCI8ZGl2PihNdXRlZCAtIE5vdCBzaG93biB0byBzdHVkZW50KTwvZGl2PlwifVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1iLTEgcC0xIGZlZWRiYWNrLWV4cGFuZC1vbi1jbGljayBmZWVkYmFjay1zaHJ1bmtcIj5cbiAgICAgICAgICAgICAgICAke21lc3NhZ2V9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxzbWFsbCBzdHlsZT1cIndoaXRlLXNwYWNlOiBwcmVcIj4ke2p1c3RpZmljYXRpb259PC9zbWFsbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGBdO1xuICAgIH1cblxuICAgIHVwZGF0ZUZ1bGxGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV4ZWN1dGlvblJlc3VsdHMpO1xuICAgICAgICBpZiAoIShcIk1BSU5fUkVQT1JUXCIgaW4gZXhlY3V0aW9uUmVzdWx0cykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFpblJlcG9ydCA9IGV4ZWN1dGlvblJlc3VsdHMuTUFJTl9SRVBPUlQ7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrID0gbWFpblJlcG9ydC50cCRnZXRhdHRyKG5ldyBweVN0cihcImZlZWRiYWNrXCIpKTtcbiAgICAgICAgaWYgKCFmZWVkYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmZWVkYmFja3MgPSBbXTtcbiAgICAgICAgU2subWlzY2V2YWwuaXRlckZvcihmZWVkYmFjay50cCRpdGVyKCksIChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBmZWVkYmFja3MucHVzaCh0aGlzLnByb2Nlc3NTaW5nbGVGZWVkYmFjayhlbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBTay5taXNjZXZhbC5pdGVyRm9yKG1haW5SZXBvcnQudHAkZ2V0YXR0cihuZXcgcHlTdHIoXCJpZ25vcmVkX2ZlZWRiYWNrXCIpKS50cCRpdGVyKCksIChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBmZWVkYmFja3MucHVzaCh0aGlzLnByb2Nlc3NTaW5nbGVGZWVkYmFjayhlbGVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlZWRiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgW2VsZW1lbnQsIHBhcmVudCwgdGV4dF0gPSBmZWVkYmFja3NbaV07XG4gICAgICAgICAgICBjb25zdCBoYXNQYXJlbnQgPSAhU2suYnVpbHRpbi5jaGVja05vbmUocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5zZXQocGFyZW50LCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KHBhcmVudCkucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnNldChlbGVtZW50LCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGVsZW1lbnQpLnVuc2hpZnQodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmVlZGJhY2tzID0gWy4uLnBhcmVudHMudmFsdWVzKCldLmZsYXQoKTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeS5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5zaG93KFwiRnVsbCBGZWVkYmFjayBJbmZvcm1hdGlvblwiLCAnPGRpdiBjbGFzcz1cImxpc3QtZ3JvdXBcIj4nK1xuICAgICAgICAgICAgICAgIGZlZWRiYWNrcy5qb2luKFwiXFxuXCIpICsgXCI8L2Rpdj5cIik7XG4gICAgICAgICAgICAkKFwiLmZlZWRiYWNrLWV4cGFuZC1vbi1jbGlja1wiKS5vbihcImNsaWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS50b2dnbGVDbGFzcyhcImZlZWRiYWNrLXNocnVua1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBub3RpZnlGZWVkYmFja1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmVlZGJhY2tWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mbG9hdGluZy1mZWVkYmFja1wiKS5zaG93KCkuZmFkZU91dCg3MDAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFNjcm9sbEludG9WaWV3KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2hvdWxkU2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5tYWluLm1vZGVsLnVpLnNtYWxsTGF5b3V0KCk7XG4gICAgfVxuXG4gICAgcHJlc2VudFJ1bkVycm9yKGVycm9yLCBqdXN0X3JldHVybikge1xuICAgICAgICBpZiAoanVzdF9yZXR1cm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganVzdF9yZXR1cm4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWVzc2FnZSwgbGFiZWwsIGNhdGVnb3J5LCBsaW5lbm87XG4gICAgICAgIGxhYmVsID0gZXJyb3IudHAkbmFtZTtcbiAgICAgICAgY2F0ZWdvcnkgPSBcInJ1bnRpbWVcIjtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMuY29udmVydFNrdWxwdEVycm9yKGVycm9yKTtcblxuICAgICAgICBpZiAoanVzdF9yZXR1cm4pIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgaWYgKGxpbmVubyAhPT0gdW5kZWZpbmVkICYmIGxpbmVubyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lbm8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnVpbGRUcmFjZWJhY2soZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnRyYWNlYmFjay5tYXAoZnJhbWUgPT4ge1xuICAgICAgICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIj8/XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZW5vID0gZnJhbWUubGluZW5vO1xuICAgICAgICAgICAgaWYgKGZyYW1lLmZpbGVuYW1lLnNsaWNlKDAsIC0zKSA9PT0gZmlsZW5hbWVFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGxpbmVubyAtPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuaW5zdHJ1Y3Rvci5saW5lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpbGUgPSBgRmlsZSA8Y29kZSBjbGFzcz1cImZpbGVuYW1lXCI+XCIke2ZyYW1lLmZpbGVuYW1lfVwiPC9jb2RlPiwgYDtcbiAgICAgICAgICAgIGxldCBsaW5lID0gYG9uIGxpbmUgPGNvZGUgY2xhc3M9XCJsaW5lbm9cIj4ke2xpbmVub308L2NvZGU+LCBgO1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gKGZyYW1lLnNjb3BlICE9PSBcIjxtb2R1bGU+XCIgJiZcbiAgICAgICAgICAgIGZyYW1lLnNjb3BlICE9PSB1bmRlZmluZWQpID8gYGluIHNjb3BlICR7ZnJhbWUuc2NvcGV9YCA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChmcmFtZS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGBcXG48cHJlPjxjb2RlPiR7ZnJhbWUuc291cmNlfTwvY29kZT48L3ByZT5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGUgKyBsaW5lICsgc2NvcGUgKyBzb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCwgaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgIGxldCBuYW1lID0gZXJyb3IudHAkbmFtZTtcbiAgICAgICAgbGV0IGFyZ3MgPSBTay5mZmkucmVtYXBUb0pzKGVycm9yLmFyZ3MpO1xuICAgICAgICBsZXQgdG9wID0gYCR7bmFtZX06ICR7YXJnc1swXX1cXG48YnI+XFxuPGJyPmA7XG4gICAgICAgIGxldCB0cmFjZWJhY2sgPSBcIlwiO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmVyciAmJiBlcnJvci5lcnIudHJhY2ViYWNrICYmIGVycm9yLmVyci50cmFjZWJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRnJhbWVzID0gdGhpcy5idWlsZFRyYWNlYmFjayhlcnJvci5lcnIsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtcIlRyYWNlYmFjazpcIl07XG4gICAgICAgICAgICAgICAgaWYgKGFsbEZyYW1lcy5sZW5ndGggPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmFsbEZyYW1lcy5zbGljZSgwLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYC4uLiBIaWRpbmcgJHthbGxGcmFtZXMubGVuZ3RoIC0gM30gb3RoZXIgc3RhY2sgZnJhbWVzIC4uLixgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hbGxGcmFtZXMuc2xpY2UoLTMsIC0yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsRnJhbWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrID0gcmVzdWx0LmpvaW4oXCJcXG48YnI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSW5zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHRvcCA9IFwiRXJyb3IgaW4gaW5zdHJ1Y3RvciBmZWVkYmFjay4gUGxlYXNlIHNob3cgdGhlIGZvbGxvd2luZyB0byBhbiBpbnN0cnVjdG9yOjxicj5cXG5cIit0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IudHJhY2ViYWNrICYmIGVycm9yLnRyYWNlYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cmFjZWJhY2sgPSBcIlRyYWNlYmFjazo8YnI+XFxuXCIgKyB0aGlzLmJ1aWxkVHJhY2ViYWNrKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKS5qb2luKFwiXFxuPGJyPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wK1wiXFxuXCIrdHJhY2ViYWNrO1xuICAgIH1cblxuICAgIHByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KFwicnVudGltZVwiKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGFiZWwoXCJUaW1lb3V0IEVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeShcImludGVybmFsXCIpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbChcIkludGVybmFsIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5jb252ZXJ0U2t1bHB0RXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQsIHRydWUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlGZWVkYmFja1VwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtU3lzdGVtLkVycm9yXCIsIFwiaW50ZXJuYWxcIiwgXCJJbnRlcm5hbCBFcnJvclwiLCBtZXNzYWdlLCBmaWxlbmFtZUV4ZWN1dGVkKTtcbiAgICB9XG5cblxuXG59IiwiaW1wb3J0IHtmaXJzdERlZmluZWRWYWx1ZX0gZnJvbSBcInV0aWxpdGllcy5qc1wiO1xuXG4vLyAke21ha2VUYWIoXCI/bW9ja191cmxzLmJsb2NrcHlcIiwgXCJVUkwgRGF0YVwiLCB0cnVlKX1cblxuY29uc3QgbWFrZVRhYiA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBmcmllbmRseU5hbWUsIGhpZGVJZkVtcHR5LCBub3RJbnN0cnVjdG9yKSB7XG4gICAgaWYgKGZyaWVuZGx5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyaWVuZGx5TmFtZSA9IGZpbGVuYW1lO1xuICAgIH1cbiAgICBsZXQgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiXCI7XG4gICAgbGV0IGhpZGVJZk5vdEluc3RydWN0b3IgPSBcInRydWVcIjtcbiAgICBpZiAoIW5vdEluc3RydWN0b3IpIHtcbiAgICAgICAgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiYmxvY2tweS1maWxlLWluc3RydWN0b3JcIjtcbiAgICAgICAgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwiZGlzcGxheS5pbnN0cnVjdG9yKClcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSAke2luc3RydWN0b3JGaWxlQ2xhc3N9XCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gJyR7ZmlsZW5hbWV9J30sXG4gICAgICAgICAgICAgICAgY2xpY2s6IGRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgJyR7ZmlsZW5hbWV9JyksXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogKCEke2hpZGVJZkVtcHR5fSB8fCB1aS5maWxlcy5oYXNDb250ZW50cygnJHtmaWxlbmFtZX0nKSkgJiYgJHtoaWRlSWZOb3RJbnN0cnVjdG9yfVwiPlxuICAgICAgICAgICAgJHtmcmllbmRseU5hbWV9PC9hPlxuICAgIDwvbGk+YDtcbn07XG5cbmV4cG9ydCBsZXQgRklMRVNfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXBhbmVsIGJsb2NrcHktZmlsZXNcIlxuICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmZpbGVzLnZpc2libGUsIGNsYXNzOiB1aS5maWxlcy53aWR0aFwiPlxuPHVsIGNsYXNzPVwibmF2IG5hdi10YWJzXCIgcm9sZT1cInRhYmxpc3RcIj5cblxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgIDxzdHJvbmc+VmlldzogPC9zdHJvbmc+XG4gICAgPC9saT5cblxuICAgICR7bWFrZVRhYihcImFuc3dlci5weVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIkluc3RydWN0aW9uc1wiKX1cbiAgICAke21ha2VUYWIoXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIsIFwiU2V0dGluZ3NcIil9XG4gICAgJHttYWtlVGFiKFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCJTdGFydGluZyBDb2RlXCIpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ydW4ucHlcIiwgXCJPbiBSdW5cIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX2NoYW5nZS5weVwiLCBcIk9uIENoYW5nZVwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhb25fZXZhbC5weVwiLCBcIk9uIEV2YWxcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsIFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiF0YWdzLmJsb2NrcHlcIiwgXCJUYWdzXCIsIHRydWUpfVxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7J2Jsb2NrcHktZmlsZS1pbnN0cnVjdG9yJzogIWZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJykgfHwgJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKCkgXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZWRpdGFibGU6IGZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAkcm9vdC51aS5maWxlcy5kaXNwbGF5RmlsZW5hbWUoZmlsZW5hbWUoKSlcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6ICRyb290LmRpc3BsYXkuaW5zdHJ1Y3RvcigpXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmlsZW5hbWVcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogc3VibWlzc2lvbi5leHRyYUZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKCl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gIFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGRyb3Bkb3duXCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCIgaHJlZj1cIiNcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgIHJvbGU9XCJidXR0b25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPkFkZCBOZXc8L2E+XG4gICAgICAgIDwhLS0ga28gaWY6ICRyb290LmRpc3BsYXkuaW5zdHJ1Y3RvcigpIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnP21vY2tfdXJscy5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/bW9ja191cmxzLmJsb2NrcHknKVwiPlVSTCBEYXRhPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz9pbWFnZXMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnP2ltYWdlcy5ibG9ja3B5JylcIj5JbWFnZXM8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnP3Rvb2xib3guYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnP3Rvb2xib3guYmxvY2tweScpXCI+VG9vbGJveDwvYT5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyF0YWdzLmJsb2NrcHknKVwiPlRhZ3M8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHknKVwiPlNhbXBsZSBTdWJtaXNzaW9uczwvYT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1kaXZpZGVyXCI+PC9kaXY+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiBhc3NpZ25tZW50Lm9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIW9uX2NoYW5nZS5weScpXCI+T24gQ2hhbmdlPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogYXNzaWdubWVudC5vbkV2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchb25fZXZhbC5weScpXCI+T24gRXZhbDwvYT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1kaXZpZGVyXCI+PC9kaXY+XG4gICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchYW5zd2VyX3ByZWZpeC5weScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIWFuc3dlcl9wcmVmaXgucHknKVwiPkFuc3dlciBQcmVmaXg8L2E+XG4gICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchYW5zd2VyX3N1ZmZpeC5weScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIWFuc3dlcl9zdWZmaXgucHknKVwiPkFuc3dlciBTdWZmaXg8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJ3N0YXJ0aW5nJylcIj5TdGFydGluZyBGaWxlPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJ2luc3RydWN0b3InKVwiPkluc3RydWN0b3IgRmlsZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdzdHVkZW50JylcIj5TdHVkZW50IEZpbGU8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgPCEtLSBrbyBpZm5vdDogJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKCkgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJ3N0dWRlbnQnKVwiPlN0dWRlbnQgRmlsZTwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDwhLS0gL2tvIC0tPlxuICAgIDwvbGk+XG4gIFxuPC91bD5cbjwvZGl2PlxuYDtcblxuY29uc3QgTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCA9IGBcbjxmb3JtPlxuPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgPCEtLSBGaWxlbmFtZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCI+RmlsZW5hbWU6PC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiXG4gICAgICAgICAgICBpZD1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiPiAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIEZpbGV0eXBlIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0IG10LTJcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiPkZpbGV0eXBlOiA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIj48L3NwYW4+ICAgIFxuICAgIDwvZGl2PlxuICAgIDwhLS0gSW5hY2Nlc3NpYmxlIHRvIHN0dWRlbnQ/IC0tPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0IG10LTJcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIj5OYW1lc3BhY2U6IDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS00XCI+XG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiXG4gICAgICAgICAgICBpZD1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIhXCI+Q29tcGxldGVseSBpbmFjY2Vzc2libGU8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI/XCI+SGlkZGVuIGZyb20gc3R1ZGVudCwgYWNjZXNzaWJsZSBwcm9ncmFtYXRpY2FsbHk8L29wdGlvbj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCImXCI+VmlzaWJsZSB0byBzdHVkZW50LCBidXQgbm90IGVkaXRhYmxlPC9vcHRpb24+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuPC9kaXY+XG48L2Zvcm0+XG5gO1xuXG4vKipcbiAqIEZpbGVuYW1lcyBsaXZlIGluIG9uZSBvZiBmaXZlIHBvc3NpYmxlIG5hbWVzcGFjZXM6XG4gKiAgSW5zdHJ1Y3RvciAoISk6IEludmlzaWJsZSB0byB0aGUgc3R1ZGVudCB1bmRlciBhbGwgY2lyY3Vtc3RhbmNlc1xuICogIFN0YXJ0IFNwYWNlICheKTogVXNlZCB0byByZXNldCB0aGUgc3R1ZGVudCBuYW1lc3BhY2VcbiAqICBTdHVkZW50IFNwYWNlICgpOiBWaXNpYmxlIHRvIHRoZSBzdHVkZW50IHdoZW4gZGlzcGxheS5oaWRlRmlsZXMgaXMgbm90IHRydWUsIGFibGUgdG8gYmUgZWRpdGVkXG4gKiAgSGlkZGVuIFNwYWNlICg/KTogTm90IGRpcmVjdGx5IHZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBhY2Nlc3NpYmxlIHByb2dyYW1tYXRpY2FsbHlcbiAqICBSZWFkLW9ubHkgU3BhY2UgKCYpOiBBbiBpbnN0cnVjdG9yIGZpbGUgdHlwZSB2aXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgaXMgdW5lZGl0YWJsZSBieSB0aGVtXG4gKiAgU2VjcmV0IFNwYWNlICgkKTogTm90IHZpc2libGUgZnJvbSB0aGUgbWVudSBhdCBhbGwsIHNvbWUgb3RoZXIgbWVjaGFuaXNtIGNvbnRyb2xzIGl0XG4gKiAgR2VuZXJhdGVkIFNwYWNlICgqKTogVmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGRlc3Ryb3llZCBhZnRlciBFbmdpbmUuQ2xlYXIuIENhbiBzaGFkb3cgYW4gYWN0dWFsIGZpbGUuXG4gKiAgQ29uY2F0ZW5hdGVkIFNwYWNlICgjKTogVXNlZCB3aGVuIGJ1bmRsaW5nIGEgc3BhY2UgZm9yIHRoZSBzZXJ2ZXIuXG4gKi9cblxuZXhwb3J0IGxldCBTVEFSVElOR19GSUxFUyA9IFtcbiAgICAvLyBTdWJtaXNzaW9uXG4gICAgXCJhbnN3ZXIucHlcIixcbiAgICAvLyBJbnN0cnVjdG9yIGZpbGVzXG4gICAgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsXG4gICAgXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIsXG4gICAgXCJec3RhcnRpbmdfY29kZS5weVwiLFxuICAgIFwiIW9uX3J1bi5weVwiLFxuICAgIFwiJHNldHRpbmdzLmJsb2NrcHlcIixcbl07XG5cbmV4cG9ydCBjb25zdCBCQVNJQ19ORVdfRklMRVMgPSBbXG4gICAgXCIhb25fY2hhbmdlLnB5XCIsXG4gICAgXCIhb25fZXZhbC5weVwiLFxuICAgIFwiP21vY2tfdXJscy5ibG9ja3B5XCIsXG4gICAgXCI/dG9vbGJveC5ibG9ja3B5XCIsXG4gICAgXCIhdGFncy5ibG9ja3B5XCIsXG4gICAgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIixcbiAgICBcIiFhbnN3ZXJfcHJlZml4LnB5XCIsXG4gICAgXCIhYW5zd2VyX3N1ZmZpeC5weVwiXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hvbXBTcGVjaWFsRmlsZShmaWxlbmFtZSkge1xuICAgIGlmIChcIiFePyYkKiNcIi5pbmNsdWRlcyhmaWxlbmFtZVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG59XG5cbmNvbnN0IElOU1RSVUNUT1JfRElSRUNUT1JZID0gXCJfaW5zdHJ1Y3Rvci9cIjtcbmNvbnN0IFNUVURFTlRfRElSRUNUT1JZID0gXCJfc3R1ZGVudC9cIjtcblxuY29uc3QgU2VhcmNoTW9kZXMgPSB7XG4gICAgRVZFUllXSEVSRTogXCJFVkVSWVdIRVJFXCIsXG4gICAgU1RBUlRfV0lUSF9JTlNUUlVDVE9SOiBcIlNUQVJUX1dJVEhfSU5TVFJVQ1RPUlwiLFxuICAgIE9OTFlfU1RVREVOVF9GSUxFUzogXCJPTkxZX1NUVURFTlRfRklMRVNcIlxufTtcblxuY29uc3QgREVMRVRBQkxFX1NJTVBMRV9GSUxFUyA9IFtcIiFvbl9jaGFuZ2UucHlcIiwgXCIhb25fZXZhbC5weVwiXTtcblxuZXhwb3J0IGNvbnN0IFVOREVMRVRBQkxFX0ZJTEVTID0gW1wiYW5zd2VyLnB5XCIsIFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIiFhc3NpZ25tZW50X3NldHRpbmdzLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIiFvbl9ydW4ucHlcIiwgXCIkc2V0dGluZ3MuYmxvY2tweVwiXTtcblxuZXhwb3J0IGNvbnN0IFVOUkVOQU1BQkxFX0ZJTEVTID0gW1wiYW5zd2VyLnB5XCIsIFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIiFhc3NpZ25tZW50X3NldHRpbmdzLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIiFvbl9ydW4ucHlcIiwgXCIkc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIW9uX2NoYW5nZS5weVwiLCBcIiFvbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI/bW9ja191cmxzLmJsb2NrcHlcIiwgXCI/dG9vbGJveC5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhdGFncy5ibG9ja3B5XCIsIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhYW5zd2VyX3ByZWZpeC5weVwiLCBcIiFhbnN3ZXJfc3VmZml4LnB5XCJdO1xuXG5jbGFzcyBCbG9ja1B5RmlsZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICByZXR1cm4ge1wiZmlsZW5hbWVcIjoga28ub2JzZXJ2YWJsZShmaWxlbmFtZSksIGNvbnRlbnRzOiBrby5vYnNlcnZhYmxlKGNvbnRlbnRzIHx8IFwiXCIpfTtcbn1cblxuZnVuY3Rpb24gbWFrZU1vY2tNb2RlbEZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIHsgZmlsZW5hbWU6ICgpID0+IGZpbGVuYW1lLCBjb250ZW50czogKCkgPT4gY29udGVudHMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGNvbmNhdGVuYXRlZEZpbGUsIG1vZGVsRmlsZUxpc3QpIHtcbiAgICBpZiAoY29uY2F0ZW5hdGVkRmlsZSkge1xuICAgICAgICBsZXQgZmlsZXMgPSBKU09OLnBhcnNlKGNvbmNhdGVuYXRlZEZpbGUpO1xuICAgICAgICBsZXQgbW9kZWxGaWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBpbiBmaWxlcykge1xuICAgICAgICAgICAgaWYgKGZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsRmlsZXMucHVzaChtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBmaWxlc1tmaWxlbmFtZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL2ZpbGVzID0gZmlsZXMubWFwKGZpbGUgPT4gbWFrZU1vZGVsRmlsZShmaWxlLmZpbGVuYW1lLCBmaWxlLmNvbnRlbnRzKSk7XG4gICAgICAgIGlmIChtb2RlbEZpbGVMaXN0KSB7XG4gICAgICAgICAgICBtb2RlbEZpbGVMaXN0KG1vZGVsRmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsRmlsZXM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobW9kZWxGaWxlTGlzdCkge1xuICAgICAgICAgICAgbW9kZWxGaWxlTGlzdChbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsRmlsZUxpc3QpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobW9kZWxGaWxlTGlzdCgpLm1hcChmaWxlID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLmZpbGVuYW1lKCksXG4gICAgICAgICAgICBjb250ZW50czogZmlsZS5jb250ZW50cygpXG4gICAgICAgIH07XG4gICAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWxGaWxlTGlzdCkge1xuICAgIHJldHVybiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIG1vZGVsRmlsZUxpc3QoKS5mb3JFYWNoKGZpbGUgPT5cbiAgICAgICAgICAgIHJlc3VsdFtmaWxlLmZpbGVuYW1lKCldID0gZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgZGF0YWJhc2UgbG9naWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlGaWxlU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZmlsZXNfID0ge307XG4gICAgICAgIHRoaXMubW91bnRGaWxlcygpO1xuXG4gICAgICAgIHRoaXMud2F0Y2hNb2RlbCgpO1xuICAgICAgICB0aGlzLndhdGNoZXNfID0ge307XG5cbiAgICAgICAgdGhpcy5yZW1vdGVGaWxlc18gPSB7fTtcbiAgICAgICAgdGhpcy5maWxlc1RvVXJscyA9IHt9O1xuXG4gICAgICAgIC8qbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIpLnRvZ2dsZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yLnN1YnNjcmliZSgodmlzaWJsaXR5KT0+IHtcbiAgICAgICAgICAgIG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiKS50b2dnbGUodmlzaWJsaXR5KTtcbiAgICAgICAgfSk7Ki9cbiAgICB9XG5cbiAgICB3YXRjaEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKGZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHN0b3BXYXRjaGluZ0ZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIHdhdGNoTW9kZWwoKSB7XG4gICAgICAgIGxldCBmaWxlc3lzdGVtID0gdGhpcztcbiAgICAgICAgW3RoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlc10uZm9yRWFjaChmaWxlQXJyYXkgPT5cbiAgICAgICAgICAgIGZpbGVBcnJheS5zdWJzY3JpYmUoZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4gc2Vjb25kLnN0YXR1cy5sb2NhbGVDb21wYXJlKGZpcnN0LnN0YXR1cykpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RlbEZpbGUgPSBjaGFuZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgbmV3IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzeXN0ZW0ubmV3RmlsZShtb2RlbEZpbGUuZmlsZW5hbWUoKSwgbW9kZWxGaWxlLmNvbnRlbnRzKCksIG1vZGVsRmlsZS5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5ub3RpZnlXYXRjaGVzKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2Uuc3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBmaWxlc3lzdGVtLmRlbGV0ZUZpbGVMb2NhbGx5Xyhtb2RlbEZpbGUuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzeXN0ZW0ubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IG1vZGVsRmlsZS5maWxlbmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzeXN0ZW0ubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLCBcImFycmF5Q2hhbmdlXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gYW5zd2VyLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZmlyc3QgZWxlbWVudCBvZiBzdWJtaXNzaW9uLmNvZGUpXG4gICAgLy8gIW9uX3J1bi5weSwgIW9uX2NoYW5nZS5weSwgIW9uX2V2YWwucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZWxldmFudCBhc3NpZ25tZW50Ljx3aGF0ZXZlcj5cbiAgICAvLyBec3RhcnRpbmdfY29kZS5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGZpcnN0IGVsZW1lbnQgb2YgYXNzaWdubWVudC5zdGFydGluZ0NvZGVcbiAgICAvLyBed2hhdGV2ZXJcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZXN0IG9mIHRoZSBlbGVtZW50cyBvZiBhc3NpZ25tZW50LnN0YXJ0aW5nQ29kZVxuICAgIC8vICF3aGF0ZXZlciBvciA/d2hhdGV2ZXJcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBlbGVtZW50cyBvZiBhc3NpZ25tZW50LmV4dHJhRmlsZXNcbiAgICAvLyBPdGhlcndpc2U6XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVzdCBvZiB0aGUgZWxlbWVudHMgb2Ygc3VibWlzc2lvbi5jb2RlXG4gICAgLyoqXG4gICAgICogTmV3IHNwZWNpYWwgZmlsZXMgbmVlZCB0byBiZSByZWdpc3RlcmVkIGhlcmVcbiAgICAgKiBAcGFyYW0gZmlsZSB7QmxvY2tQeUZpbGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvYnNlcnZlRmlsZV8oZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX2NoYW5nZS5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiXnN0YXJ0aW5nX2NvZGUucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhdGFncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudGFncztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiJHNldHRpbmdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJeXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIiFcIikgfHxcbiAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCI/XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZlSW5BcnJheV8oZmlsZSwgYXJyYXkpIHtcbiAgICAgICAgZmlsZS5vd25lciA9IGFycmF5O1xuICAgICAgICBsZXQgY29kZUJ1bmRsZSA9IGZpbGUub3duZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY29kZUJ1bmRsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVCdW5kbGVbaV0uZmlsZW5hbWUoKSA9PT0gZmlsZS5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gY29kZUJ1bmRsZVtpXS5jb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZS5oYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBuZXdGaWxlID0gbWFrZU1vZGVsRmlsZShmaWxlLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gbmV3RmlsZS5jb250ZW50cztcbiAgICAgICAgICAgIGFycmF5LnB1c2gobmV3RmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudEZpbGVzKCkge1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIl5zdGFydGluZ19jb2RlLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhb25fcnVuLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIpO1xuICAgIH1cblxuICAgIGRpc21vdW50RXh0cmFGaWxlcygpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmZpbGVzXykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFVOREVMRVRBQkxFX0ZJTEVTLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2F0Y2hlc19bbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN1Ym1pc3Npb24uY29kZVRPRE86IFNob3VsZG4ndCB3ZSBub3RpZnkgdGhlIFVJIHRoYXQgdGhlIGZpbGUgd2FzIGRlbGV0ZWQ/XG4gICAgfVxuXG4gICAgbmV3RmlsZShmaWxlbmFtZSwgY29udGVudHMsIG1vZGVsRmlsZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gdGhpcy5maWxlc18pIHtcbiAgICAgICAgICAgIC8vIEZpbGUgYWxyZWFkeSBleGlzdHMhIEp1c3QgdXBkYXRlIGl0cyBoYW5kbGVcbiAgICAgICAgICAgIGxldCBleGlzdGluZ0ZpbGUgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgICAgICBpZiAobW9kZWxGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVGaWxlXyhleGlzdGluZ0ZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0ZpbGUuaGFuZGxlID0gbW9kZWxGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpc3RpbmdGaWxlLmhhbmRsZShjb250ZW50cyB8fCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaWxlIGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICBsZXQgbmV3RmlsZSA9IG5ldyBCbG9ja1B5RmlsZSh0aGlzLm1haW4sIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXSA9IG5ld0ZpbGU7XG4gICAgICAgICAgICBpZiAobW9kZWxGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVGaWxlXyhuZXdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZS5oYW5kbGUgPSBtb2RlbEZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdGaWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5oYW5kbGUoY29udGVudHMpO1xuICAgIH1cblxuICAgIHJlYWRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzX1tmaWxlbmFtZV0uaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgZ2V0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58b2JqZWN0fSBUaGUgaW5mbyBhYm91dCB0aGUgZmlsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGRlbGV0ZWRcbiAgICAgKi9cbiAgICBkZWxldGVGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmIChERUxFVEFCTEVfU0lNUExFX0ZJTEVTLmluZGV4T2YoZmlsZW5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmRlbGV0ZUZpbGVMb2NhbGx5XyhmaWxlbmFtZSk7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjayB0byBldmVudHVhbGx5IGNhbGwgZGVsZXRlRmlsZUxvY2FsbHlfXG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIucmVtb3ZlKG1vZGVsRmlsZSA9PiBtb2RlbEZpbGUuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZUxvY2FsbHlfKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay5kZWxldGVkKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cblxuICAgIHJlbmFtZUZpbGUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgICBpZiAoVU5SRU5BTUFCTEVfRklMRVMuaW5kZXhPZihzb3VyY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjayB0byBldmVudHVhbGx5IGNhbGwgZGVsZXRlRmlsZUxvY2FsbHlfXG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIucmVtb3ZlKG1vZGVsRmlsZSA9PiBtb2RlbEZpbGUuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm90aWZ5V2F0Y2hlcyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZS5maWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay51cGRhdGVkKGZpbGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGUobmFtZSwgc3R1ZGVudFNlYXJjaCkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiBUaGlzIGlzIGNhbGxlZCBxdWl0ZSBhIGJpdCBieSB0aGUgSW1wb3J0IG1lY2hhbmlzbSwgbWlnaHQgbmVlZFxuICAgICAgICAgICAgICB0byBvcHRpbWl6ZSBpdCBzb21lIG1vcmUuIERvIHRpbWluZyB0ZXN0cy5cblxuICAgICAgICBmaWxlcy4qXG4gICAgICAgIF9pbnN0cnVjdG9yL2ZpbGVzLipcbiAgICAgICAgX3N0dWRlbnQvZmlsZXMuKlxuXG4gICAgICAgIElmIGEgc3R1ZGVudCBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgdGhlIFwiP1wiLCBcIiZcIiwgXCIqXCIsIFwiXCIgbmFtZXNwYWNlc1xuICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgIElmIGFuIGluc3RydWN0b3Igc2VhcmNoZXMgZm9yIGEgZmlsZSwgaXQgY2hlY2tzIFwiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBUbyBleHBsaWNpdGx5IHNlYXJjaCBpbnN0cnVjdG9yIG5hbWVzcGFjZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBpbXBvcnQgX2luc3RydWN0b3IuaGVscGVyID0+IFwiLi9pbnN0cnVjdG9yL2hlbHBlci5weVwiXG4gICAgICAgICAgICAgICAgb3BlbihcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIikgPT4gXCJfaW5zdHJ1Y3Rvci9leHRlcm5hbC5qc29uXCJcbiAgICAgICAgICAgIHRvIGFsbG93IHN0dWRlbnQgZmlsZXMgdG8gb3ZlcnJpZGU6XG4gICAgICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiZXh0ZXJuYWwuanNvblwiKSA9PiBcImV4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gb25seSBjaGVjayBzdHVkZW50IGZpbGVzLCBwcmVwZW5kIHdpdGggX3N0dWRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIENob3Agb2ZmIHN0YXJ0aW5nIFwiLi9cIlxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRTtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBzZWFyY2ggYmUgc3RhcnQgd2l0aCBpbnN0cnVjdG9yIHNpZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoSU5TVFJVQ1RPUl9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShJTlNUUlVDVE9SX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBsaW1pdGVkIHRvIHRoZSBzdHVkZW50IG1vZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoU1RVREVOVF9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShTVFVERU5UX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUztcbiAgICAgICAgfSBlbHNlIGlmIChzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBpbnN0cnVjdG9yIHZlcnNpb25zXG4gICAgICAgIGxldCBleHRyYVN0dWRlbnRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhSW5zdHJ1Y3RvckZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhU3RhcnRpbmdGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpO1xuICAgICAgICAvLyBDaGVjayBzcGVjaWFsIGZpbGVzIChUT0RPOiBob3cgd291bGQgYW4gaW5zdHJ1Y3RvciBhY2Nlc3MgXCIuL19pbnN0cnVjdG9yL2Fuc3dlci5weVwiP1xuICAgICAgICBsZXQgc3BlY2lhbEZpbGUgPSB0aGlzLnNlYXJjaEZvclNwZWNpYWxGaWxlc18obmFtZSwgc2VhcmNoTW9kZSk7XG4gICAgICAgIGlmIChzcGVjaWFsRmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lhbEZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgbG9va2luZyB0aHJvdWdoIHBvc3NpYmxlIGZpbGVzXG4gICAgICAgIGxldCBzdHVkZW50VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIG5hbWUpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIFwiKlwiK25hbWUpO1xuICAgICAgICBsZXQgZGVmYXVsdFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiZcIituYW1lKTtcbiAgICAgICAgbGV0IGhpZGRlblZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIj9cIituYW1lKTtcbiAgICAgICAgbGV0IHJlbW90ZVZlcnNpb24gPSB0aGlzLnJlbW90ZUZpbGVzX1tuYW1lXTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGhpZGRlblZlcnNpb24sIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbiwgcmVtb3RlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc3RydWN0b3JWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCIhXCIrbmFtZSk7XG4gICAgICAgIGxldCBzdGFydGluZ1ZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3RhcnRpbmdGaWxlcywgXCJeXCIrbmFtZSk7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5TVEFSVF9XSVRIX0lOU1RSVUNUT1IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbiwgcmVtb3RlVmVyc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uLCByZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGVJbkxpc3RfKG1vZGVsTGlzdCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9kZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0W2ldLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNlYXJjaEZvclNwZWNpYWxGaWxlc18oZmlsZW5hbWUsIHNlYXJjaE1vZGUpIHtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9ydW4ucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fY2hhbmdlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ldmFsLm1kXCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnMubWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9pbnN0cnVjdGlvbnMubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpO1xuICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nX2NvZGUucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9zdGFydGluZ19jb2RlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5ld0ZpbGVEaWFsb2coa2luZCkge1xuICAgICAgICBsZXQgYm9keSA9ICQoTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCk7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIik7XG4gICAgICAgIGxldCBmaWxldHlwZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIik7XG4gICAgICAgIGxldCBuYW1lc3BhY2UgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiKTtcbiAgICAgICAgbGV0IGV4dGVuc2lvblJlZ2V4ID0gLyg/OlxcLihbXi5dKykpPyQvO1xuICAgICAgICBmaWxlbmFtZS5vbihcImlucHV0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbnNpb25SZWdleC5leGVjKGZpbGVuYW1lLnZhbCgpKVsxXTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJObyBleHRlbnNpb25cIiA6IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3JGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgICAgICAgICBmaWxldHlwZS50ZXh0KGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJpbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBuYW1lc3BhY2UudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwic3RhcnRpbmdcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUudmFsKCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHByZWZpeCtmaWxlbmFtZS52YWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0ZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBib2R5LnN1Ym1pdCgoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgeWVzKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jb25maXJtKFwiTWFrZSBOZXcgRmlsZVwiLCBib2R5LCB5ZXMsICgpPT57fSwgXCJBZGRcIik7XG4gICAgfVxuXG4gICAgbG9hZFJlbW90ZUZpbGVzKGZpbGVzPW51bGwpIHtcbiAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgcmVtb3RlIGZpbGVzICg/KVxuICAgICAgICAvKlxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnJlbW90ZUZpbGVzXykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVtb3RlRmlsZXNfW3Byb3BdO1xuICAgICAgICB9KTsqL1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG5cbiAgICAgICAgY29uc3QgcHJlbG9hZEZpbGVzID0gbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5wcmVsb2FkRmlsZXMoKSB8fCBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnByZWxvYWRBbGxGaWxlcygpO1xuICAgICAgICBpZiAoIXByZWxvYWRGaWxlcyAmJiAhZmlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnByZWxvYWRGaWxlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbGVzID0gSlNPTi5wYXJzZShwcmVsb2FkRmlsZXMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcHJlbG9hZCBmaWxlcywgaW52YWxpZCBzdHJ1Y3R1cmU6IFwiLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRSZW1vdGVGaWxlcyhmaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRSZW1vdGVGaWxlcyh0aGlzLnJlb3JnYW5pemVGaWxlcyhmaWxlcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxpc3RVcGxvYWRlZEZpbGVzKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZFJlbW90ZUZpbGVzKHRoaXMucmVvcmdhbml6ZUZpbGVzKGRhdGEuZmlsZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVvcmdhbml6ZUZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGNvbnN0IG9yZ2FuaXplZCA9IHt9O1xuICAgICAgICBPYmplY3QuZW50cmllcyhmaWxlcykuZm9yRWFjaCgoW3BsYWNlbWVudCwgcGxhY2VkRmlsZXNdKSA9PiB7XG4gICAgICAgICAgICBwbGFjZWRGaWxlcy5mb3JFYWNoKChbZmlsZW5hbWUsIHVybF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMKHVybCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IHNlYXJjaFBhcmFtcy5nZXQoXCJkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gc2VhcmNoUGFyYW1zLmdldChcInBsYWNlbWVudFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIShwbGFjZW1lbnQgaW4gb3JnYW5pemVkKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmdhbml6ZWRbcGxhY2VtZW50XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShkaXJlY3RvcnkgaW4gb3JnYW5pemVkW3BsYWNlbWVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZ2FuaXplZFtwbGFjZW1lbnRdW2RpcmVjdG9yeV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JnYW5pemVkW3BsYWNlbWVudF1bZGlyZWN0b3J5XVtmaWxlbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXNUb1VybHNbZmlsZW5hbWVdID0gdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3JnYW5pemVkO1xuICAgIH1cblxuICAgIGRvd25sb2FkUmVtb3RlRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgY29uc3Qgb2xkUmVtYWluaW5nRmlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJlbW90ZUZpbGVzXyk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpbGVzKS5mb3JFYWNoKChbcGxhY2VtZW50LCBwbGFjZW1lbnREYXRhXSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGxhY2VtZW50RGF0YSkuZm9yRWFjaCgoW2RpcmVjdG9yeSwgZGlyZWN0b3J5RGF0YV0pID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhkaXJlY3RvcnlEYXRhKS5mb3JFYWNoKChbZmlsZW5hbWUsIHJlbmFtZWRGaWxlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuYW1lZEZpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmFtZWRGaWxlID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVuYW1lZEZpbGUgaW4gdGhpcy5yZW1vdGVGaWxlc18pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuZG93bmxvYWRGaWxlKHBsYWNlbWVudCwgZGlyZWN0b3J5LCBmaWxlbmFtZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUZpbGVzX1tyZW5hbWVkRmlsZV0gPSBtYWtlTW9ja01vZGVsRmlsZShyZW5hbWVkRmlsZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9sZFJlbWFpbmluZ0ZpbGVzW3JlbmFtZWRGaWxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IENsZWFuIHVwIHRoZSBvbGQgZmlsZXMgYWZ0ZXIgYWxsIHRoZSBuZXcgb25lcyBhcmUgbG9hZGVkXG4gICAgfVxufSIsIi8vVE9ETzogTW92ZSBnZXQgbGluayBkb3duIHRvIGZvb3RlciwgcmVtb3ZlIHZlcnRpY2FsIGJhciBmcm9tIHF1aWNrLW1lbnVcbmV4cG9ydCBsZXQgRk9PVEVSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1zdGF0dXNcIj5cbiAgICA8ZGl2PlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkQXNzaWdubWVudCcpXCI+TG9hZCBBc3NpZ25tZW50XG4gICAgICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5Lmluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LWZvcmNlLWxvYWQtYXNzaWdubWVudC1maWxlIGJsb2NrcHktaGlkZGVuLWZpbGVcIlxuICAgICAgICAgICAgYWNjZXB0PVwiYXBwbGljYXRpb24vSlNPTlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuc2VydmVyLmZvcmNlLmxvYWRBc3NpZ25tZW50fVwiPlxuICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwvbGFiZWw+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdzYXZlQXNzaWdubWVudCcpXCI+U2F2ZSBBc3NpZ25tZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZEZpbGUnKVwiPkxvYWQgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVGaWxlJylcIj5TYXZlIEZpbGU8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRGF0YXNldCcpXCI+TG9hZCBEYXRhc2V0PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9nRXZlbnQnKVwiPkxvZyBFdmVudDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3VwZGF0ZVN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuc2VydmVyLmZvcmNlLnVwZGF0ZVN1Ym1pc3Npb25cIj5VcGRhdGUgU3VibWlzc2lvbjwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ29uRXhlY3V0aW9uJylcIj5FeGVjdXRpb248L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZXJ2ZXIubWVzc2FnZXNcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHNwYW4+VXNlcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5pZFwiPjwvc3Bhbj4gKDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIubmFtZVwiPjwvc3Bhbj4sIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIucm9sZVwiPjwvc3Bhbj4pPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuPkNvdXJzZTogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5jb3Vyc2VJZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Hcm91cDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5ncm91cElkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkFzc2lnbm1lbnQ6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQuaWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudCBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBhc3NpZ25tZW50LnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbjogXG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLmlkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIChPd25lciBJRDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkKClcIj48L3NwYW4+KVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbiBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+RWRpdG9yIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGRpc3BsYXkuZWRpdG9yVmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7IiwiLy8gVE9ETzogU2hvdWxkIGRpc2FibGUgYnV0dG9ucyBpZiB3ZSBjYW4ndCBhY3RpdmF0ZSB0aGVtLlxuXG5leHBvcnQgY29uc3QgSElTVE9SWV9UT09MQkFSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXRvb2xiYXIgY29sLW1kLTEyXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5oaXN0b3J5TW9kZVwiPlxuXG4gICAgPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXN0YXJ0IGJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3Rvcnkuc3RhcnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPiBTdGFydFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkucHJldmlvdXNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj4gUHJldmlvdXNcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3IgZm9ybS1jb250cm9sIGN1c3RvbS1zZWxlY3QgbXItMlwiIGFyaWEtdGl0bGU9XCJIaXN0b3J5IFNlbGVjdG9yXCI+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS51c2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZmlsZS1pbXBvcnQnPjwvc3Bhbj4gVXNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5uZXh0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj4gTmV4dFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm1vc3RSZWNlbnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+IE1vc3QgUmVjZW50XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuYDtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGRpc3BsYXlpbmcgdGhlIHVzZXIncyBjb2RpbmcgbG9ncyAodGhlaXIgaGlzdG9yeSkuXG4gKiBBIGxpZ2h0d2VpZ2h0IGNvbXBvbmVudCwgaXRzIG9ubHkgam9iIGlzIHRvIG9wZW4gYSBkaWFsb2cuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUhpc3Rvcnl9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGxvYWQoaGlzdG9yeSkge1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICB0aGlzLmVkaXRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICQoXCIuYmxvY2tweS1oaXN0b3J5LXNlbGVjdG9yXCIpLmVtcHR5KCk7XG4gICAgICAgIGxldCBlZGl0SWQgPSAwO1xuICAgICAgICBoaXN0b3J5XG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gKFxuICAgICAgICAgICAgICAgICFlbnRyeS5maWxlX3BhdGguc3RhcnRzV2l0aChcIl9pbnN0cnVjdG9yLlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkNvbXBpbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkludGVydmVudGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJYLVN1Ym1pc3Npb24uTE1TXCIpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldmVudF90eXBlID0gUkVNQVBfRVZFTlRfVFlQRVNbZW50cnkuZXZlbnRfdHlwZV0gfHwgZW50cnkuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzcGxheWVkID0gcHJldHR5UHJpbnREYXRlVGltZShlbnRyeS5jbGllbnRfdGltZXN0YW1wKSArXCIgLSBcIitldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlID0gKGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiRmlsZS5FZGl0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSAkKFwiPG9wdGlvbj48L29wdGlvbj5cIiwge3RleHQ6IGRpc3BsYXllZCwgZGlzYWJsZWQ6IGRpc2FibGV9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VkaXRFdmVudChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmF0dHIoXCJ2YWx1ZVwiLCBlZGl0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRFdmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRJZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGVkaXRJZC0xKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuY2hhbmdlKChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vdmVUb1N0YXJ0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCgwKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlUHJldmlvdXMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGN1cnJlbnRJZC0xKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWluKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSwgY3VycmVudElkKzEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlVG9Nb3N0UmVjZW50KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCh0aGlzLmVkaXRFdmVudHMubGVuZ3RoLTEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uc2V0Q29kZSh0aGlzLmVkaXRFdmVudHNbY3VycmVudElkXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuZmlsZS5oYW5kbGUoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VkaXRFdmVudChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKChlbnRyeS5ldmVudF90eXBlID09PSBcIkZpbGUuRWRpdFwiIHx8XG4gICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5DcmVhdGVcIikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBlbnRyeS5maWxlX3BhdGgpO1xuICAgIH1cblxufVxuXG5jb25zdCBSRU1BUF9FVkVOVF9UWVBFUyA9IHtcbiAgICBcIlNlc3Npb24uU3RhcnRcIjogXCJCZWdhbiBzZXNzaW9uXCIsXG4gICAgXCJYLUlQLkNoYW5nZVwiOiBcIkNoYW5nZWQgSVAgYWRkcmVzc1wiLFxuICAgIFwiRmlsZS5FZGl0XCI6IFwiRWRpdGVkIGNvZGVcIixcbiAgICBcIkZpbGUuQ3JlYXRlXCI6IFwiU3RhcnRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJSdW4uUHJvZ3JhbVwiOiBcIlJhbiBwcm9ncmFtXCIsXG4gICAgXCJDb21waWxlLkVycm9yXCI6IFwiU3ludGF4IGVycm9yXCIsXG4gICAgXCJYLVN1Ym1pc3Npb24uTE1TXCI6IFwiVXBkYXRlZCBncmFkZVwiXG59O1xuXG5jb25zdCBtb250aE5hbWVzID0gW1xuICAgIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsXG4gICAgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLFxuICAgIFwiQXVnXCIsIFwiU2VwdFwiLCBcIk9jdFwiLFxuICAgIFwiTm92XCIsIFwiRGVjXCJcbl07XG5jb25zdCB3ZWVrRGF5cyA9IFtcbiAgICBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLFxuICAgIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsXG4gICAgXCJTYXRcIlxuXTtcblxuZnVuY3Rpb24gaXNTYW1lRGF5KGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QuZ2V0RGF0ZSgpID09PSBzZWNvbmQuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGZpcnN0LmdldE1vbnRoKCkgPT09IHNlY29uZC5nZXRNb250aCgpICYmXG4gICAgICAgIGZpcnN0LmdldEZ1bGxZZWFyKCkgPT09IHNlY29uZC5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBhIGRhdGUvdGltZSBzdHJpbmcgYW5kIHJld3JpdGUgaXQgYXMgc29tZXRoaW5nXG4gKiBtb3JlIGh1bWFuIHJlYWRhYmxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHRpbWVTdHJpbmcgLSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgKFwiWVlZWU1NREQgSEhNTVNTXCIpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgaHVtYW4tcmVhZGFibGUgdGltZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByZXR0eVByaW50RGF0ZVRpbWUodGltZVN0cmluZykge1xuICAgIC8qbGV0IHllYXIgPSB0aW1lU3RyaW5nLnNsaWNlKDAsIDQpLFxuICAgICAgICBtb250aCA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoNCwgNiksIDEwKS0xLFxuICAgICAgICBkYXkgPSB0aW1lU3RyaW5nLnNsaWNlKDYsIDgpLFxuICAgICAgICBob3VyID0gdGltZVN0cmluZy5zbGljZSg5LCAxMSksXG4gICAgICAgIG1pbnV0ZXMgPSB0aW1lU3RyaW5nLnNsaWNlKDExLCAxMyksXG4gICAgICAgIHNlY29uZHMgPSB0aW1lU3RyaW5nLnNsaWNlKDEzLCAxNSk7Ki9cbiAgICAvLyBUT0RPOiBIYW5kbGUgdGltZXpvbmVzIGNvcnJlY3RseVxuICAgIGlmICh0aW1lU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5kZWZpbmVkIFRpbWVcIjtcbiAgICB9XG4gICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHBhc3QgPSBuZXcgRGF0ZShwYXJzZUludCh0aW1lU3RyaW5nLCAxMCkpO1xuICAgIGlmIChpc1NhbWVEYXkobm93LCBwYXN0KSkge1xuICAgICAgICByZXR1cm4gXCJUb2RheSBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXlTdHIgPSB3ZWVrRGF5c1twYXN0LmdldERheSgpXTtcbiAgICAgICAgbGV0IG1vbnRoU3RyID0gbW9udGhOYW1lc1twYXN0LmdldE1vbnRoKCldO1xuICAgICAgICBsZXQgZGF0ZSA9IGRheVN0ciArIFwiLCBcIiArIG1vbnRoU3RyICsgXCIgXCIgKyBwYXN0LmdldERhdGUoKTtcbiAgICAgICAgaWYgKG5vdy5nZXRGdWxsWWVhcigpID09PSBwYXN0LmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIsIFwiK3Bhc3QuZ2V0RnVsbFllYXIoKSArIFwiIGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBPcGVucyB0aGUgaGlzdG9yeSBkaWFsb2cgYm94LiBUaGlzIHJlcXVpcmVzIGEgdHJpcCB0byB0aGUgc2VydmVyIGFuZFxuICogb2NjdXJzIGFzeW5jaHJvbm91c2x5LiBUaGUgdXNlcnMnIGNvZGUgaXMgc2hvd24gaW4gcHJlZm9ybWF0dGVkIHRleHRcbiAqIHRhZ3MgKG5vIGNvZGUgaGlnaGxpZ2h0aW5nIGN1cnJlbnRseSkgYWxvbmcgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovXG5CbG9ja1B5SGlzdG9yeS5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFsb2cgPSB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2c7XG4gICAgdmFyIGJvZHkgPSBcIjxwcmU+YSA9IDA8L3ByZT5cIjtcbiAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuZ2V0SGlzdG9yeShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBib2R5ID0gZGF0YS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChjb21wbGV0ZSwgZWxlbSkgeyBcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZV9zdHIgPSBwcmV0dHlQcmludERhdGVUaW1lKGVsZW0udGltZSk7XG4gICAgICAgICAgICB2YXIgbmV3X2xpbmUgPSBcIjxiPlwiK2NvbXBsZXRlX3N0citcIjwvYj48YnI+PHByZT5cIitlbGVtLmNvZGUrXCI8L3ByZT5cIjtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZStcIlxcblwiK25ld19saW5lO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgZGlhbG9nLnNob3coXCJXb3JrIEhpc3RvcnlcIiwgYm9keSwgZnVuY3Rpb24oKSB7fSk7XG4gICAgfSk7XG59OyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBtYWluIEhUTUwgb2YgQmxvY2tQeSBpbnRlcmZhY2UsIGFuZCBoZWxwZXIgZnVuY3Rpb25zLlxuICogQ29tYmluZXMgYSBsb3Qgb2YgSFRNTCBmcm9tIGNvbXBvbmVudHMuXG4gKlxuICogSGVyZSdzIHRoZSBsYXlvdXQ6XG4gKiAgUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudVxuICogIFJvdyAyOiBDb25zb2xlIGFuZCBGZWVkYmFja1xuICogIFJvdyAzOiBGaWxlIE5hdmlnYXRpb25cbiAqICBSb3cgNDogVmlldyBSb3dcbiAqICBSb3cgNTogRm9vdGVyIFJvd1xuICovXG5cbmltcG9ydCB7VFJBQ0VfSFRNTH0gZnJvbSBcInRyYWNlLmpzXCI7XG5pbXBvcnQge0RJQUxPR19IVE1MfSBmcm9tIFwiZGlhbG9nLmpzXCI7XG5pbXBvcnQge0ZFRURCQUNLX0hUTUx9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtGSUxFU19IVE1MfSBmcm9tIFwiZmlsZXMuanNcIjtcbmltcG9ydCB7Rk9PVEVSX0hUTUx9IGZyb20gXCJmb290ZXIuanNcIjtcbmltcG9ydCB7RURJVE9SU19IVE1MfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtDT05TT0xFX0hUTUx9IGZyb20gXCJjb25zb2xlLmpzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBsYXlvdXQgb3B0aW9ucyBvZiB0aGUgcGFuZXMgaW4gdGhlIHNlY29uZCByb3cgb2YgdGhlIGxheW91dC5cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zID0ge1xuICAgIEZFRURCQUNLOiBcImZlZWRiYWNrXCIsXG4gICAgVFJBQ0U6IFwidHJhY2VcIixcbiAgICBOT05FOiBcIm5vbmVcIlxufTtcblxuLyoqXG4gKiBTZXR1cCBhbnkgYWRkaXRpb25hbCBLbm9ja291dCBzdWJzY3JpcHRpb25zIHRvIGZpcmUgb24gaW50ZXJmYWNlIGNoYW5nZXMuXG4gKiBAcGFyYW0gc2VsZlxuICogQHBhcmFtIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zKHNlbGYsIG1vZGVsKSB7XG4gICAgLy8gSGlnaGxpZ2h0IE1hcmtkb3duIHdoZW4gaW5zdHJ1Y3Rpb25zIHVwZGF0ZVxuICAgIGxldCBoaWdobGlnaHRUaW1lb3V0ID0gbnVsbDtcbiAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuY3VycmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdGlvbnMgcHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICB9KTtcbiAgICAvLyBQcm92aWRlIEZ1bGxzY3JlZW4gc3VwcG9ydFxuICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbi5zdWJzY3JpYmUoKGlzRnVsbHNjcmVlbikgPT4ge1xuICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uUmVxdWVzdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLy8gTk9URTogbmF2aWdhdGlvblVJIGNvdWxkIGFsbG93IHVzIHRvIGZvcmNlIGNvbnRyb2xzIHRvIHNob3dcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLnBhcmVudCgpWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXJyb3JcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsICBcIlwiKTtcbiAgICAgICAgICAgICAgICBhbGVydChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5TdWNjZXNzXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuY3NzKFwib3ZlcmZsb3cteVwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLkV4aXRcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8gVE9ETzogR2V0IHNoYXJlYWJsZSBsaW5rIGJ1dHRvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludGVyZmFjZShtYWluKSB7XG4gICAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9J2Jsb2NrcHktY29udGVudCBjb250YWluZXItZmx1aWQnPlxuXG4gICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgJHtESUFMT0dfSFRNTH1cbiAgICBcbiAgICA8IS0tIEhpZGRlbiBDYXB0dXJlIENhbnZhcyAtLT5cbiAgICA8Y2FudmFzIGlkPSdjYXB0dXJlLWNhbnZhcycgY2xhc3M9J2Qtbm9uZScgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2FudmFzPlxuICAgIFxuICAgIDwhLS0gUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXQoKVwiPlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIERlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTkgYmxvY2tweS1wYW5lbCBibG9ja3B5LWhlYWRlcidcbiAgICAgICAgICAgICAgIHJvbGU9J2hlYWRpbmcnIGFyaWEtbGFiZWw9J0Fzc2lnbm1lbnQgRGVzY3JpcHRpb24nPlxuICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIEFzc2lnbm1lbnQgTmFtZSAtLT5cbiAgICAgICAgICAgIDxzcGFuIHJvbGU9J2hlYWRpbmcnIGFyaWEtbGV2ZWw9JzEnXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrcHktbmFtZVwiPlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+QmxvY2tQeTogPC9zdHJvbmc+IFxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogYXNzaWdubWVudC5uYW1lJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gUmVzZXQgSW5zdHJ1Y3Rpb25zIEJ1dHRvbiAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWluc3RydWN0aW9ucy1yZXNldFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuaW5zdHJ1Y3Rpb25zLmlzQ2hhbmdlZFwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwiZmxvYXQtcmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuaW5zdHJ1Y3Rpb25zLnJlc2V0XCJcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgICAgICBSZXNldCBpbnN0cnVjdGlvbnM8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBJbnN0cnVjdGlvbnMgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LWluc3RydWN0aW9ucydcbiAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogdWkuaW5zdHJ1Y3Rpb25zLmN1cnJlbnRcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9J2NvbC1tZC0zIGJsb2NrcHktcGFuZWwgYmxvY2tweS1xdWljay1tZW51J1xuICAgICAgICAgICAgIHJvbGU9J21lbnViYXInIGFyaWEtbGFiZWw9J1F1aWNrIE1lbnUnIHRpdGxlPVwiUXVpY2sgTWVudVwiPlxuICAgICAgICAgICAgPCEtLSBHZXQgU2hhcmVhYmxlIExpbmsgLS0+XG4gICAgICAgICAgICA8IS0tPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCI+XG4gICAgICAgICAgICAgICAgR2V0IHNoYXJlYWJsZSBsaW5rPC9idXR0b24+LS0+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5tZW51LmlzU3VibWl0dGVkXCI+XG4gICAgICAgICAgICAgICAgWW91ciBzdWJtaXNzaW9uIGlzIHJlYWR5IHRvIGJlIHJldmlld2VkITwvc3Bhbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkubWVudS5jYW5NYXJrU3VibWl0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdWkubWVudS50ZXh0TWFya1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5tZW51LmNsaWNrTWFya1N1Ym1pdHRlZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBWaWV3IGFzIGluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLnJvbGUuaXNHcmFkZXJcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJcIiBpZD1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkuaW5zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LWFzLWluc3RydWN0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAgVmlldyBhcyBpbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBSZWFkb25seSBtb2RlIGZvciBzcHlpbmcgLS0+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtYmluZD1cImlmOiBzdWJtaXNzaW9uLm93bmVySWQoKSAhPSB1c2VyLmlkKClcIj5cbiAgICAgICAgICAgICAgICBPd25lcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cImJsb2NrcHktcmVhZC1vbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkucmVhZE9ubHlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktcmVhZC1vbmx5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkb25seT9cbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gRnVsbHNjcmVlbiBidXR0b24gLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LmNsaWNrRnVsbHNjcmVlblwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsIFNjcmVlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMnIGRhdGEtYmluZD1cImNsYXNzOiB1aS5tZW51LnRleHRGdWxsc2NyZWVuXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIEVkaXQgUXVldWVkIElucHV0cyAtLT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUuZWRpdElucHV0cywgdmlzaWJsZTogdWkubWVudS5zaG93UXVldWVkSW5wdXRzXCIgdGl0bGU9XCJFZGl0IElucHV0c1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtbGlzdC1hbHQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBUb2dnbGUgSW1hZ2UgUmVuZGVyaW5nIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUudG9nZ2xlSW1hZ2VzXCIgdGl0bGU9XCJUb2dnbGUgSW1hZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtaW1hZ2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFBpbmsgQnVnIGZvciBhY3R1YWwgZXJyb3JzIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9ja3B5LXN0dWRlbnQtZXJyb3IgZmFzIGZhLWJ1Z1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cImhpZGRlbjogdWkubWVudS5zaG93Q2xvY2tcIiBjbGFzcz1cImJsb2NrcHktbWVudS1jbG9ja1wiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8IS0tIGtvIGlmOiB1aS5zbWFsbExheW91dCgpIC0tPlxuICAgIDwhLS0gU21hbGwgbGF5b3V0IFZpZXcgYXMgaW5zdHJ1Y3RvciAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiXG4gICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5yb2xlLmlzR3JhZGVyXCI+XG4gICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIlwiIGlkPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkuaW5zdHJ1Y3RvclwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICBWaWV3IGFzIGluc3RydWN0b3JcbiAgICAgICAgPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIGtvIGlmOiB1aS5maWxlcy52aXNpYmxlKCkgLS0+XG4gICAgJHtGSUxFU19IVE1MfVxuICAgIDwhLS0gL2tvIC0tPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDxkaXYgY2xhc3M9J3Jvdyc+XG4gICAgPCEtLSBSb3cgMjogQ29uc29sZSBhbmQgRmVlZGJhY2sgLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuc2Vjb25kUm93LmlzQWxsVmlzaWJsZSAtLT5cbiAgICA8ZGl2IGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZWNvbmRSb3cud2lkdGhcIj5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICA8IS0tIENvbnNvbGUgLS0+XG4gICAgICAgICR7Q09OU09MRV9IVE1MfVxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwhLS0gVHJhY2UgLS0+XG4gICAgICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSAtLT5cbiAgICAgICAgJHtUUkFDRV9IVE1MfVxuICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSgpICYmICF1aS5zbWFsbExheW91dCgpIC0tPlxuICAgICR7RklMRVNfSFRNTH1cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyA0OiBWaWV3IFJvdyAtLT5cbiAgICAke0VESVRPUlNfSFRNTH1cbiAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICBcbiAgICA8IS0tIFJvdyA1OiBGb290ZXIgUm93IC0tPiAgICBcbiAgICA8IS0tIGtvIGlmOiB1aS5mb290ZXIudmlzaWJsZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICR7Rk9PVEVSX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG48L2Rpdj5cbiAgICBgO1xufSIsImltcG9ydCB7TG9jYWxTdG9yYWdlV3JhcHBlcn0gZnJvbSBcIi4vc3RvcmFnZVwiO1xuaW1wb3J0IHtsb2FkQXNzaWdubWVudFNldHRpbmdzLCBzYXZlQXNzaWdubWVudFNldHRpbmdzfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgbGV0IFN0YXR1c1N0YXRlID0ge1xuICAgIFJFQURZOiBcInJlYWR5XCIsXG4gICAgQUNUSVZFOiBcImFjdGl2ZVwiLFxuICAgIFJFVFJZSU5HOiBcInJldHJ5aW5nXCIsXG4gICAgRkFJTEVEOiBcImZhaWxlZFwiLFxuICAgIE9GRkxJTkU6IFwib2ZmbGluZVwiXG59O1xuXG4vKipcbiAqIE9iamVjdCBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBleHRlcm5hbCBzZXJ2ZXJzLiBUaGlzIGluY2x1ZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG4gKiBzYXZpbmcgYW5kIGxvYWRpbmcgZmlsZXMsIGxvZ2dpbmcgZXZlbnRzLCBzYXZpbmcgY29tcGxldGlvbnMsIGFuZCByZXRyaWV2aW5nIGhpc3RvcnkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeVNlcnZlcn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeVNlcnZlcihtYWluKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcblxuICAgIC8vIFNhdmUgVVJMcyBsb2NhbGx5IGZvciBxdWlja2VyIGFjY2Vzc1xuICAgIHRoaXMudXJscyA9IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzO1xuXG4gICAgLy8gQWRkIHRoZSBMb2NhbFN0b3JhZ2UgY29ubmVjdGlvblxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKFwiQkxPQ0tQWVwiKTtcblxuICAgIC8vIEZhdWx0UmVzaXN0YW50Q2FjaGVcbiAgICB0aGlzLnF1ZXVlID0ge1xuICAgICAgICBcImxvZ0V2ZW50XCI6IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldERlZmF1bHQoXCJsb2dFdmVudFwiLCBcIltdXCIpKSxcbiAgICAgICAgXCJ1cGRhdGVTdWJtaXNzaW9uXCI6IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldERlZmF1bHQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFwiW11cIikpXG4gICAgfTtcbiAgICB0aGlzLk1BWF9RVUVVRV9TSVpFID0ge1xuICAgICAgICBcImxvZ0V2ZW50XCI6IDIwMCxcbiAgICAgICAgXCJ1cGRhdGVTdWJtaXNzaW9uXCI6IDUwXG4gICAgfTtcblxuICAgIHRoaXMuVElNRVJfREVMQVkgPSAxMDAwO1xuICAgIHRoaXMuRkFJTF9ERUxBWSA9IDIwMDA7XG5cbiAgICB0aGlzLnRpbWVycyA9IHt9O1xuXG4gICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgPSAwO1xuXG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMgPSBbXTtcbiAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB0aGlzLmNoZWNrQ2FjaGVzKCk7XG5cbiAgICB0aGlzLmFsdExvZ0VudHJ5ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgSVAgYWRkcmVzcyBoYXMgY2hhbmdlZCwgbG9nZ2luZyBhbiBldmVudCBpZiB0aGF0IG9jY3Vycy5cbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jaGVja0lQID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJJUFwiKSkge1xuICAgICAgICAgICAgbGV0IG9sZElQID0gdGhpcy5zdG9yYWdlLmdldChcIklQXCIpO1xuICAgICAgICAgICAgaWYgKG9sZElQICE9PSByZXNwb25zZS5pcCkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBcIm9sZFwiOiBvbGRJUCxcbiAgICAgICAgICAgICAgICAgICAgXCJuZXdcIjogcmVzcG9uc2UuaXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbHRMb2dFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsdExvZ0VudHJ5KFwiWC1JUC5DaGFuZ2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nRXZlbnQoXCJYLUlQLkNoYW5nZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXCJJUFwiLCByZXNwb25zZS5pcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFwiSVBcIiwgcmVzcG9uc2UuaXApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZXJlIGhhdmUgYmVlbiBwcmV2aW91cyBmYWlsdXJlcyBjYWNoZWQsIGFuZCBpZiBzbyByZXRyaWVzIHRoZW0uXG4gKiBUT0RPOiB1cGRhdGVcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY2hlY2tDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVBc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIFwiYXNzaWdubWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzYXZlQXNzaWdubWVudFwiLCB0aGlzLlRJTUVSX0RFTEFZKTtcbiAgICB9XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMuZm9yRWFjaCgoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlRmlsZVwiICsgZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVGaWxlXCIgKyBmaWxlbmFtZSkpO1xuICAgICAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIHRoaXMuVElNRVJfREVMQVkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHNlcnZlciA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5xdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uIHB1c2hBbnlRdWV1ZWQocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlci5xdWV1ZVtlbmRwb2ludF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShzZXJ2ZXIucXVldWVbZW5kcG9pbnRdLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHNlcnZlci51cmxzW2VuZHBvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIDEwMDAsIHB1c2hBbnlRdWV1ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoe1wic3VjY2Vzc1wiOiB0cnVlfSk7XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG1vZGVsLCBmaWxlbmFtZSkge1xuICAgIG1vZGVsLnN1YnNjcmliZSgoY29udGVudHMpID0+XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmF1dG9TYXZlKCkgPyB0aGlzLnNhdmVGaWxlKGZpbGVuYW1lLCBjb250ZW50cykgOiBmYWxzZSwgdGhpcyk7XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMucHVzaChmaWxlbmFtZSk7XG59O1xuXG4vKipcbiAqIFRPRE86IGZpeFxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuc3VibWlzc2lvbi5jb2RlLCBcImFuc3dlci5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vblJ1biwgXCIhb25fcnVuLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCwgXCIhb25fZXZhbC5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSwgXCIhb25fY2hhbmdlLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucywgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSwgXCJec3RhcnRpbmdfY29kZS5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdHVkZW50RmlsZXMsIFwiI2V4dHJhX3N0dWRlbnRfZmlsZXMuYmxvY2tweVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdGFydGluZ0ZpbGVzLCBcIiNleHRyYV9zdGFydGluZ19maWxlcy5ibG9ja3B5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYUluc3RydWN0b3JGaWxlcywgXCIjZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcy5ibG9ja3B5XCIpO1xufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRMb2dzID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lm9uYmx1ciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2dFdmVudChcIlNlc3Npb24uRW5kXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgd2luZG93Lm9uZm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJTZXNzaW9uLlN0YXJ0XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gYmVhY29uP1xufTtcblxuLyoqXG4gKlxuICogU29tZSBzdWJzY3JpcHRpb25zIGhhdmUgdG8gaGFwcGVuIGFmdGVyIG90aGVyIHRoaW5ncyBoYXZlIGJlZW4gbG9hZGVkLlxuICogUmlnaHQgbm93IHRoaXMgaXMganVzdCBhZnRlciBDT1JHSVMgbGlicmFyaWVzIGhhdmUgYmVlbiBsb2FkZWQsIGJ1dCBtYXliZVxuICogd2UnbGwgYWRkIG1vcmUgbGF0ZXIgYW5kIHRoaXMgd2lsbCBuZWVkIHRvIGJlIHJlZmFjdG9yZWQuXG4gKlxuICogVE9ETzogZml4XG4gKlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5maW5hbGl6ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy90aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0cy5zdWJzY3JpYmUodGhpcy5zYXZlQXNzaWdubWVudC5iaW5kKHRoaXMpKTtcbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmF1dGhvcml6ZUhlYWRlciA9IGZ1bmN0aW9uKGN1cnJlbnRTZXR0aW5ncykge1xuICAgIGlmICghY3VycmVudFNldHRpbmdzKSB7XG4gICAgICAgIGN1cnJlbnRTZXR0aW5ncyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKCk7XG4gICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGlmICghY3VycmVudFNldHRpbmdzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncy5oZWFkZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFNldHRpbmdzLmhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBhY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRTZXR0aW5ncztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBwYXlsb2FkIGZvciBhbnkgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgQVBJXG4gKiBAcmV0dXJucyB7e2Fzc2lnbm1lbnRfaWQ6ICosIGNvdXJzZV9pZDogKiwgZ3JvdXBfaWQ6ICosIHVzZXJfaWQ6ICosIHRpbWV6b25lOiAqLCB2ZXJzaW9uOiAqLCB0aW1lc3RhbXA6ICp9fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTZXJ2ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBhc3NpZ25tZW50ID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQ7XG4gICAgbGV0IHVzZXIgPSB0aGlzLm1haW4ubW9kZWwudXNlcjtcbiAgICBsZXQgc3VibWlzc2lvbiA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uO1xuICAgIGxldCBkaXNwbGF5ID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXk7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uO1xuICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBub3cuZ2V0VGltZSgpO1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIFwiYXNzaWdubWVudF9pZFwiOiBhc3NpZ25tZW50LmlkKCksXG4gICAgICAgIFwiYXNzaWdubWVudF9ncm91cF9pZFwiOiB1c2VyLmdyb3VwSWQoKSxcbiAgICAgICAgXCJjb3Vyc2VfaWRcIjogdXNlci5jb3Vyc2VJZCgpLFxuICAgICAgICBcInN1Ym1pc3Npb25faWRcIjogc3VibWlzc2lvbi5pZCgpLFxuICAgICAgICBcInVzZXJfaWRcIjogdXNlci5pZCgpLFxuICAgICAgICBcInZlcnNpb25cIjogYXNzaWdubWVudC52ZXJzaW9uKCksXG4gICAgICAgIFwidGltZXN0YW1wXCI6IG1pY3Jvc2Vjb25kcyxcbiAgICAgICAgXCJ0aW1lem9uZVwiOiBub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgXCJwYXNzY29kZVwiOiBkaXNwbGF5LnBhc3Njb2RlKCksXG4gICAgICAgIFwicGFydF9pZFwiOiBjb25maWd1cmF0aW9uLnBhcnRJZCgpXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0dXMgYW5kIG1lc3NhZ2UgZm9yIHRoZSByZWxldmFudCBlbmRwb2ludC5cbiAqIEBwYXJhbSBlbmRwb2ludCB7c3RyaW5nfSBvbmUgb2YgdGhlIFVSTCBlbmRwb2ludHNcbiAqIEBwYXJhbSBzdGF0dXMge1N0YXR1c1N0YXRlfVxuICogQHBhcmFtIG1lc3NhZ2Uge3N0cmluZz99XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uIChlbmRwb2ludCwgc3RhdHVzLCBtZXNzYWdlKSB7XG4gICAgaWYgKGVuZHBvaW50IGluIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludF0oc3RhdHVzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludCArIFwiTWVzc2FnZVwiXShtZXNzYWdlIHx8IFwiXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVuZGVycyBhbiBvdmVybGF5IG9uIHRoZSBzY3JlZW4gdGhhdCBibG9ja3Mgb3BlcmF0aW9uIHVudGlsIHRoZSBzeXN0ZW0gaXMgcmVhZHkuXG4gKiBUaGUgb3ZlcmxheSBnZXRzIHByb2dyZXNzaXZlbHkgZGFya2VyIHRvIGluZGljYXRlIHJlcGVhdGVkIGZhaWx1cmVzLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zaG93T3ZlcmxheSA9IGZ1bmN0aW9uIChhdHRlbXB0KSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzICs9IDE7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYmxvY2tweS1vdmVybGF5XCIpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSAkKCc8ZGl2IGNsYXNzPVwiYmxvY2tweS1vdmVybGF5XCI+IDwvZGl2PicpO1xuICAgICAgICB0aGlzLm92ZXJsYXkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXR0ZW1wdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM5ODhcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjNjU1XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzMzM1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJibGFja1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5kbyBhIGxldmVsIG9mIG92ZXJsYXk7IGlmIHRoaXMgd2FzIHRoZSBsYXN0IGxldmVsLCByZW1vdmVzIGl0IGZyb20gdGhlIHNjcmVlbi5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuaGlkZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzIC09IDE7XG4gICAgaWYgKHRoaXMuYmxvY2tpbmdBdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZW5xdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBub3Qgb3ZlcmZpbGxlZCB0aGUgcXVldWVcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5xdWV1ZVtjYWNoZV0ubGVuZ3RoO1xuICAgIGxldCBtYXggPSB0aGlzLk1BWF9RVUVVRV9TSVpFW2NhY2hlXTtcbiAgICBpZiAobGVuZ3RoID4gbWF4KSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdID0gdGhpcy5xdWV1ZVtjYWNoZV0uc2xpY2UobGVuZ3RoIC0gbWF4LCBtYXgpO1xuICAgIH1cbiAgICAvLyBPbmx5IGFkZCB0aGUgZWxlbWVudCBpZiBpdCdzIG5ld1xuICAgIGxldCBrZXkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnF1ZXVlW2NhY2hlXS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5wdXNoKGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX2RlcXVldWVEYXRhID0gZnVuY3Rpb24gKGNhY2hlLCBkYXRhKSB7XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXS5zcGxpY2UoaW5kZXgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGNhY2hlLCBKU09OLnN0cmluZ2lmeSh0aGlzLnF1ZXVlW2NhY2hlXSkpO1xuICAgIH1cbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX3Bvc3RSZXRyeSA9IGZ1bmN0aW9uIChkYXRhLCBlbmRwb2ludCwgZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgbGV0IHBvc3RSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIGEgYmFja3VwIG9mIHRoZSBjdXJyZW50IHBvc3RcbiAgICAgICAgdGhpcy5fZW5xdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAkLmFqYXgoe3VybDogdGhpcy51cmxzW2VuZHBvaW50XSwgdHlwZTogXCJwb3N0XCIsIGRhdGE6IGRhdGEsIC4uLnRoaXMuYXV0aG9yaXplSGVhZGVyKCl9KVxuICAgICAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICBwb3N0UmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocG9zdFJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBBSkFYIHJlcXVlc3QgdGhhdCwgdXBvbiBmYWlsdXJlLCB3aWxsIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHdhcyB0aGVcbiAqIGxhdGVzdCBhdHRlbXB0IGZvciB0aGlzIGBjYWNoZWAgbWFya2VyLiBJZiBzbywgaXQgd2lsbCBhdHRlbXB0IGFnYWluIHVudGlsXG4gKiBzdWNjZXNzZnVsOyBvdGhlcndpc2UsIGl0IGdpdmVzIHVwIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIEFKQVgtcmVhZHkgZGF0YSB0byBiZSBwb3N0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgdGltZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludCAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgY2FjaGUgZW50cnlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXkgLSBUaGUgY3VycmVudCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gdHJ5aW5nIHRoZSByZXF1ZXN0IGFnYWluLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdExhdGVzdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXksIGZhaWx1cmVGdW5jdGlvbiwgZG9uZUZ1bmN0aW9uKSB7XG4gICAgbGV0IGNhY2hlID0gZW5kcG9pbnQgKyBmaWxlbmFtZTtcbiAgICBsZXQgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgJC5hamF4KHt1cmw6IHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGE6IGRhdGEsIHR5cGU6IFwicG9zdFwiLCAuLi50aGlzLmF1dGhvcml6ZUhlYWRlcigpfSlcbiAgICAgICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tJUChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlcnZlciByZXF1ZXN0IGlzIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbm5lY3RlZCBidXQgZmFpbGVkLCBkb24ndCB0cnkgYWdhaW4gYnV0IGxldCB0aGUgdXNlciBrbm93IHdoeS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdGhlIGxhdGVzdCBvbmUsIGNsZWFyIGl0IGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlRnVuY3Rpb24ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBmaWxlbmFtZSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZG9uZUZ1bmN0aW9uKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1tjYWNoZV0pO1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXJzW2NhY2hlXSA9IHNldFRpbWVvdXQocmVxdWVzdCwgZGVsYXkpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9wb3N0QmxvY2tpbmcgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIGRhdGEsIGF0dGVtcHRzLCBzdWNjZXNzLCBmYWlsdXJlLCBleHRyYVNldHRpbmdzPXt9KSB7XG4gICAgdGhpcy5zaG93T3ZlcmxheShhdHRlbXB0cyk7XG4gICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICB1cmw6IHRoaXMudXJsc1tlbmRwb2ludF0sXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIC4uLnRoaXMuYXV0aG9yaXplSGVhZGVyKGV4dHJhU2V0dGluZ3MpXG4gICAgfSlcbiAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAuZmFpbCgoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZShlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhlbmRwb2ludCwgZGF0YSwgYXR0ZW1wdHMgLSAxLCBzdWNjZXNzLCBmYWlsdXJlLCBleHRyYVNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoYXNzaWdubWVudF9pZCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiYXNzaWdubWVudF9pZFwiXSA9IGFzc2lnbm1lbnRfaWQ7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxvYWRBc3NpZ25tZW50XCIsIGRhdGEsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubG9hZEFzc2lnbm1lbnREYXRhXyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVChyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVBc3NpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiaGlkZGVuXCJdID0gbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKTtcbiAgICAgICAgZGF0YVtcInJldmlld2VkXCJdID0gbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpO1xuICAgICAgICBkYXRhW1wicHVibGljXCJdID0gbW9kZWwuYXNzaWdubWVudC5wdWJsaWMoKTtcbiAgICAgICAgZGF0YVtcInVybFwiXSA9IG1vZGVsLmFzc2lnbm1lbnQudXJsKCk7XG4gICAgICAgIGRhdGFbXCJwb2ludHNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnBvaW50cygpO1xuICAgICAgICBkYXRhW1wiaXBfcmFuZ2VzXCJdID0gbW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcygpO1xuICAgICAgICBkYXRhW1wibmFtZVwiXSA9IG1vZGVsLmFzc2lnbm1lbnQubmFtZSgpO1xuICAgICAgICBkYXRhW1wic2V0dGluZ3NcIl0gPSBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKTtcblxuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJzYXZlQXNzaWdubWVudFwiLCBkYXRhLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc3NpYmxlRm9yay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFNhdmUgQXNzaWdubWVudClcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEhpc3RvcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkSGlzdG9yeVwiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxpc3RVcGxvYWRlZEZpbGVzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxpc3RVcGxvYWRlZEZpbGVzXCIpKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibGlzdFVwbG9hZGVkRmlsZXNcIiwgZGF0YSwgMiwgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnVwbG9hZEZpbGUgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBkaXJlY3RvcnksIGZpbGVuYW1lLCBjb250ZW50cywgY2FsbGJhY2ssIGRlbGV0ZUluc3RlYWQ9ZmFsc2UpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBsb2FkRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wicGxhY2VtZW50XCJdID0gcGxhY2VtZW50O1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvbnRlbnRzXCJdID0gY29udGVudHM7XG4gICAgICAgIGlmIChkZWxldGVJbnN0ZWFkKSB7XG4gICAgICAgICAgICBkYXRhW1wiZGVsZXRlXCJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmQgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGQsZSkgPT4gKGQuYXBwZW5kKC4uLmUpLCBkKSwgbmV3IEZvcm1EYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdEJsb2NraW5nKFwidXBsb2FkRmlsZVwiLCBmZCwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUluc3RlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9ERUxFVElOR19GSUxFKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1VQTE9BRElOR19GSUxFKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtwcm9jZXNzRGF0YTogZmFsc2UsIGNvbnRlbnRUeXBlOiBmYWxzZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoVXBsb2FkIEZpbGUpXCIpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmRvd25sb2FkRmlsZSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIGRpcmVjdG9yeSwgZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImRvd25sb2FkRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wicGxhY2VtZW50XCJdID0gcGxhY2VtZW50O1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgbGV0IGZkID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChkLGUpID0+IChkLmFwcGVuZCguLi5lKSwgZCksIG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RCbG9ja2luZyhcImRvd25sb2FkRmlsZVwiLCBmZCwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0RPV05MT0FESU5HX0ZJTEUodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtwcm9jZXNzRGF0YTogZmFsc2UsIGNvbnRlbnRUeXBlOiBmYWxzZSwgZGF0YVR5cGU6IFwidGV4dFwifSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGxvYWRGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUsIFwiU2VydmVyIGlzIG5vdCBjb25uZWN0ZWQhIChVcGxvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUucmVuYW1lRmlsZSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIGRpcmVjdG9yeSwgb2xkX2ZpbGVuYW1lLCBuZXdfZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInJlbmFtZUZpbGVcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcInBsYWNlbWVudFwiXSA9IHBsYWNlbWVudDtcbiAgICAgICAgZGF0YVtcImRpcmVjdG9yeVwiXSA9IGRpcmVjdG9yeTtcbiAgICAgICAgZGF0YVtcIm9sZF9maWxlbmFtZVwiXSA9IG9sZF9maWxlbmFtZTtcbiAgICAgICAgZGF0YVtcIm5ld19maWxlbmFtZVwiXSA9IG5ld19maWxlbmFtZTtcbiAgICAgICAgbGV0IGZkID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChkLGUpID0+IChkLmFwcGVuZCguLi5lKSwgZCksIG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RCbG9ja2luZyhcInJlbmFtZUZpbGVcIiwgZmQsIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9VUExPQURJTkdfRklMRSh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge3Byb2Nlc3NEYXRhOiBmYWxzZSwgY29udGVudFR5cGU6IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJyZW5hbWVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUsIFwiU2VydmVyIGlzIG5vdCBjb25uZWN0ZWQhIChSZW5hbWUgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRfdHlwZSwgY2F0ZWdvcnksIGxhYmVsLCBtZXNzYWdlLCBmaWxlX3BhdGgpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2dFdmVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZXZlbnRfdHlwZVwiXSA9IGV2ZW50X3R5cGU7XG4gICAgICAgIGRhdGFbXCJjYXRlZ29yeVwiXSA9IGNhdGVnb3J5O1xuICAgICAgICBkYXRhW1wibGFiZWxcIl0gPSBsYWJlbDtcbiAgICAgICAgZGF0YVtcIm1lc3NhZ2VcIl0gPSBtZXNzYWdlO1xuICAgICAgICBkYXRhW1wiZmlsZV9wYXRoXCJdID0gZmlsZV9wYXRoO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIC8vIFRyaWdnZXIgcmVxdWVzdFxuICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJsb2dFdmVudFwiLCAwLCAoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9nRXZlbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUltYWdlID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgaW1hZ2UpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwic2F2ZUltYWdlXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJkaXJlY3RvcnlcIl0gPSBkaXJlY3Rvcnk7XG4gICAgICAgIGRhdGFbXCJpbWFnZVwiXSA9IGltYWdlO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIFwidHVydGxlX291dHB1dFwiLCBcInNhdmVJbWFnZVwiLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS51cGRhdGVTdWJtaXNzaW9uU3RhdHVzID0gZnVuY3Rpb24obmV3U3RhdHVzKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzdGF0dXNcIl0gPSBuZXdTdGF0dXM7XG4gICAgICAgIGxldCBwb3N0U3RhdHVzQ2hhbmdlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKG5ld1N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNcIiwgZGF0YSwgMiwgcG9zdFN0YXR1c0NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGxvYWQgZmlsZXMgYW5kIHdlYiByZXNvdXJjZXMuXG4gKlxuICogREVQUkVDQVRFRFxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgdHlwZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgdmFyIHNlcnZlciA9IHRoaXM7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZF9maWxlXCIpKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJmaWxlbmFtZVwiXSA9IGZpbGVuYW1lO1xuICAgICAgICBkYXRhW1widHlwZVwiXSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyh0aGlzLnVybHMubG9hZF9maWxlLCBkYXRhLCA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnNldFN0YXR1cyhcImxvYWRGaWxlXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soXCJTZXJ2ZXIgZmFpbHVyZSEgUmVwb3J0IHRvIGluc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckNhbGxiYWNrKFwiTm8gZmlsZSBzZXJ2ZXIgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoTG9hZCBGaWxlKVwiKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zYXZlRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY29udGVudHMsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsYXkgPSB0aGlzLlRJTUVSX0RFTEFZO1xuICAgIH1cbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVGaWxlXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJmaWxlbmFtZVwiXSA9IGZpbGVuYW1lO1xuICAgICAgICBkYXRhW1wiY29kZVwiXSA9IGNvbnRlbnRzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIFwic2F2ZUZpbGVcIiwgZGVsYXksIHRoaXMuc3RhcnRQb3NzaWJsZUZvcmsuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc3RhcnRQb3NzaWJsZUZvcmsgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZm9ya2FibGUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLk9GRkVSX0ZPUksoKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS51cGRhdGVTdWJtaXNzaW9uID0gZnVuY3Rpb24gKHNjb3JlLCBjb3JyZWN0LCBoaWRkZW5PdmVycmlkZSwgZm9yY2VVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3M7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInVwZGF0ZVN1Ym1pc3Npb25cIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIGRhdGFbXCJjb3JyZWN0XCJdID0gY29ycmVjdDtcbiAgICAgICAgZGF0YVtcImhpZGRlbl9vdmVycmlkZVwiXSA9IGhpZGRlbk92ZXJyaWRlO1xuICAgICAgICBkYXRhW1wiZm9yY2VfdXBkYXRlXCJdID0gZm9yY2VVcGRhdGU7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5ibG9ja0VkaXRvci5nZXRQbmdGcm9tQmxvY2tzKChwbmdEYXRhLCBpbWcpID0+IHtcbiAgICAgICAgICAgIGRhdGFbXCJpbWFnZVwiXSA9IHBuZ0RhdGE7XG4gICAgICAgICAgICBpZiAoaW1nLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGltZy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Bvc3RSZXRyeShkYXRhLCBcInVwZGF0ZVN1Ym1pc3Npb25cIiwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblwiLCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhpZGRlbk92ZXJyaWRlICYmIGNvcnJlY3QgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFbXCJhc3NpZ25tZW50X2lkXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5vcGVuYWlQcm94eSA9IGZ1bmN0aW9uIChvcGVuYWlfZGF0YSkge1xuICAgIHZhciBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB2YXIgc2VydmVyID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgIGRhdGFbXCJvcGVuYWlfZGF0YVwiXSA9IG9wZW5haV9kYXRhO1xuICAgIHJldHVybiB0aGlzLl9wb3N0QmxvY2tpbmcodGhpcy51cmxzLm9wZW5haV9wcm94eSwgZGF0YSk7XG59OyIsImV4cG9ydCBjb25zdCAkc2tfbW9kX2NvdmVyYWdlID0gYFxuXCJcIlwiXG5IaWRlb3VzIGZpbGwtaW4gcmVwbGFjZW1lbnQgZm9yIENvdmVyYWdlLCBsZXZlcmFnaW5nIHNvbWUgbWFnaWMgZnJvbSB0aGVcblV0aWxpdHkgZnVuY3Rpb24uIFRoZSBkYXRhIHRoaXMgcmV0dXJucyBpcyBmYWxzZSAtIGl0IGRvZXNuJ3QgYWN0dWFsbHlcbmRlc2NyaWJlIHRoZSBtaXNzaW5nIGxpbmVzIGFuZCBhbGwgbGluZXM7IGl0IGp1c3QgZGVzY3JpYmVzIHRoZSB0cmFjZWQgbGluZXMuXG5CdXQgc2luY2UgUGVkYWwgZG9lc24ndCBuZWVkIHRoZSBvdGhlciB0d28sIGl0IHdvcmtzIG91dCBmaW5lIHdoZW4geW91IGRvOlxuXG5zdGF0ZW1lbnRzIC0gbWlzc2luZ1xuXCJcIlwiXG5cbmltcG9ydCB1dGlsaXR5XG5cbmNsYXNzIENvdmVyYWdlOlxuICAgIGRlZiBzdGFydChzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIHN0b3Aoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzYXZlKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgX2FuYWx5emUoc2VsZiwgZmlsZW5hbWU6IHN0cik6XG4gICAgICAgIGxpbmVzID0gc2V0KHV0aWxpdHkudHJhY2VfbGluZXMoKSlcbiAgICAgICAgIyBsaW5lcyB3aWxsIGJlIHRoZSBsaW5lcyB0aGF0IHdlcmUgYWN0dWFsbHkgZXhlY3V0ZWRcbiAgICAgICAgcmV0dXJuIEFuYWx5c2lzKE5vbmUsIGxlbihsaW5lcyksIE5vbmUsIHNldCgpLCBsaW5lcylcblxuXG5jbGFzcyBOdW1iZXJzOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBuX21pc3NpbmcsIG5fc3RhdGVtZW50cywgcGNfY292ZXJlZCk6XG4gICAgICAgIHNlbGYubl9taXNzaW5nID0gbl9taXNzaW5nXG4gICAgICAgIHNlbGYubl9zdGF0ZW1lbnRzID0gbl9zdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYucGNfY292ZXJlZCA9IHBjX2NvdmVyZWRcblxuXG5jbGFzcyBBbmFseXNpczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQsIG1pc3NpbmcsIHN0YXRlbWVudHMpOlxuICAgICAgICBzZWxmLm1pc3NpbmcgPSBtaXNzaW5nXG4gICAgICAgIHNlbGYuc3RhdGVtZW50cyA9IHN0YXRlbWVudHNcbiAgICAgICAgc2VsZi5udW1iZXJzID0gTnVtYmVycyhuX21pc3NpbmcsIG5fc3RhdGVtZW50cywgcGNfY292ZXJlZClcblxuXG5jbGFzcyBweXRob246XG4gICAgZGVmIGdldF9weXRob25fc291cmNlKHNlbGYpOlxuICAgICAgICByZXR1cm4gTm9uZVxuYDsiLCJleHBvcnQgdmFyICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtb2QsIHNhbXBsZVdyYXBwZXI7XG4gICAgbW9kID0ge19fbmFtZV9fOiBcImltYWdlXCJ9O1xuXG4gICAgaWYgKCFTay5QSUwpIHtcbiAgICAgICAgU2suUElMID0ge2Fzc2V0czoge319O1xuICAgIH1cblxuICAgIC8vIEluc3RhbnRQcm9taXNlIGlzIGEgd29ya2Fyb3VuZCB0byBhbGxvdyB1c2FnZSBvZiB0aGUgY2xlYW4gcHJvbWlzZS1zdHlsZVxuICAgIC8vIHRoZW4vY2F0Y2ggc3ludGF4IGJ1dCB0byBpbnN0YW50bHkgY2FsbCByZXNvbHZlIHRoZSB0aGVuL2NhdGNoIGNoYWluIHNvIHdlXG4gICAgLy8gY2FuIGF2b2lkIGNyZWF0aW5nIFN1c3BlbnNpb25zIGluIHVubmVjZXNzYXJ5IGNhc2VzLiAgVGhpcyBpcyBkZXNpcmFibGVcbiAgICAvLyBiZWNhdXNlIFN1c3BlbnNpb25zIGhhdmUgYSBmYWlybHkgbGFyZ2UgbmVnYXRpdmUgaW1wYWN0IG9uIG92ZXJhbGxcbiAgICAvLyBwZXJmb3JtYW5jZS4gIFRoZXNlICdpbnN0YW50IHByb21pc2VzJyBjb21lIGludG8gcGxheSB3aGVuIGEgdHJhY2VyKClcbiAgICAvLyBjYWxsIGlzIG1hZGUgd2l0aCBhIHZhbHVlIG90aGVyIHRoYW4gMS4gIFdoZW4gdHJhY2VyIGlzIDAgb3IgZ3JlYXRlciB0aGFuIDFcbiAgICAvLyAsIHdlIGNhbiBieXBhc3MgdGhlIGNyZWF0aW9uIG9mIGEgU3VzcGVuc2lvbiBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBsaW5lIG9mXG4gICAgLy8gY29kZSBpbW1lZGlhdGVseSBpZiB0aGUgY3VycmVudCBsaW5lIGlzIG5vdCBnb2luZyB0byBpbnZvbHZlIGEgc2NyZWVuXG4gICAgLy8gdXBkYXRlLiBXZSBkZXRlcm1pbmUgaWYgYSByZWFsIHByb21pc2Ugb3IgSW5zdGFudFByb21pc2UgaXMgbmVjZXNzYXJ5IGJ5XG4gICAgLy8gY2hlY2tpbmcgRnJhbWVNYW5hZ2VyLndpbGxSZW5kZXJOZXh0KClcbiAgICBmdW5jdGlvbiBJbnN0YW50UHJvbWlzZShlcnIsIHJlc3VsdCkge1xuICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMubGFzdEVycm9yICA9IGVycjtcbiAgICB9XG5cbiAgICBJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gY2IodGhpcy5sYXN0UmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICBJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gY2IodGhpcy5sYXN0RXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yICA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSA/IHRoaXMubGFzdFJlc3VsdCA6IHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBidWlsZEltYWdlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoU2suUElMLmFzc2V0c1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gU2suUElMLmFzc2V0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFNrLlBJTC5hc3NldHNbbmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBTay5QSUwuYXNzZXRzW25hbWVdID0gaW1nO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBhc3NldDogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IGZ1bmN0aW9uKCRnYmwsICRsb2MpIHtcbiAgICAgICAgLy8gb3BlbihmaWxlbmFtZSkgb3Igb3Blbih1cmwpXG4gICAgICAgIC8vIHNob3coKVxuXG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBmaWxlX29yX3VybCkge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9faW5pdF9fXCIsIGFyZ3VtZW50cywgMiwgMik7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZmlsZV9vcl91cmxcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgc2VsZi5maWxlX29yX3VybCA9IGZpbGVfb3JfdXJsO1xuICAgICAgICAgICAgLy8gVE9ETzogQ2hhbmdlIHRvIHN1c3BlbnNpb25cbiAgICAgICAgICAgIHZhciBpbWFnZVByb21pc2UgPSBnZXRBc3NldChTay5mZmkucmVtYXBUb0pzKGZpbGVfb3JfdXJsKSk7XG4gICAgICAgICAgICB2YXIgc3VzcCA9IG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKCk7XG4gICAgICAgICAgICBzZWxmLmltYWdlID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgICAgICAgICAgc3VzcC5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcC5kYXRhW1wiZXJyb3JcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgU2suYnVpbHRpbi5JT0Vycm9yKHN1c3AuZGF0YVtcImVycm9yXCJdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzdXNwLmRhdGFbXCJlcnJvclwiXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBzZWxmLmltYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdXNwLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTay5wcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgcHJvbWlzZTogaW1hZ2VQcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLndpZHRoID0gc2VsZi5pbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuaGVpZ2h0ID0gc2VsZi5pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2Uoc2VsZi5pbWFnZSwgMCwgMCwgc2VsZi5pbWFnZS53aWR0aCwgc2VsZi5pbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBpeGVscyA9IHNlbGYuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgc2VsZi5pbWFnZS53aWR0aCwgc2VsZi5pbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzdXNwO1xuICAgICAgICB9KTtcblxuICAgICAgICAkbG9jLnNob3cgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb25zb2xlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogc2VsZi5pbWFnZSxcbiAgICAgICAgICAgICAgICBmaWxlX29yX3VybDogc2VsZi5maWxlX29yX3VybFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2suY29uc29sZS5wcmludFBJTEltYWdlKGNvbnNvbGVEYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5mbGlwID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBzZWxmLmltYWdlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKC0xKVwiO1xuICAgICAgICAgICAgaWYgKFNrLmNvbnNvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk5hbWVFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBkcmF3aW5nIGFyZWEuIFNrLmNvbnNvbGUgaXMgdW5kZWZpbmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIG1vZC5JbWFnZSA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBpbWFnZSwgXCJJbWFnZVwiLCBbXSk7XG5cbiAgICByZXR1cm4gbW9kO1xufTsiLCJleHBvcnQgY29uc3QgJHBlZGFsX3RyYWNlciA9IGBcclxuXHJcblwiXCJcIlxyXG5XcmFwcyB0aGUgdHJhY2VyIG1vZHVsZSBpbiBQZWRhbFxyXG5cIlwiXCJcclxuXHJcbmltcG9ydCBvc1xyXG5pbXBvcnQgdXRpbGl0eVxyXG4gICAgICAgIFxyXG5jbGFzcyBTYW5kYm94QmFzaWNUcmFjZXI6XHJcbiAgICBcIlwiXCJcclxuXHJcbiAgICBcIlwiXCJcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICBzdXBlcigpLl9faW5pdF9fKClcclxuICAgICAgICBzZWxmLmZpbGVuYW1lID0gXCJzdHVkZW50LnB5XCJcclxuICAgICAgICBzZWxmLmNvZGUgPSBOb25lXHJcblxyXG4gICAgZGVmIGFzX2ZpbGVuYW1lKHNlbGYsIGZpbGVuYW1lLCBjb2RlKTpcclxuICAgICAgICBpZiBvcy5wYXRoLmlzYWJzKGZpbGVuYW1lKTpcclxuICAgICAgICAgICAgc2VsZi5maWxlbmFtZSA9IGZpbGVuYW1lXHJcbiAgICAgICAgZWxzZTpcclxuICAgICAgICAgICAgc2VsZi5maWxlbmFtZSA9IG9zLnBhdGguYWJzcGF0aChmaWxlbmFtZSlcclxuICAgICAgICBzZWxmLmNvZGUgPSBjb2RlXHJcbiAgICAgICAgcmV0dXJuIHNlbGZcclxuXHJcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbiAgICBkZWYgX19leGl0X18oc2VsZiwgZXhjX3R5cGUsIGV4Y192YWwsIHRyYWNlYmFjayk6XHJcbiAgICAgICAgcGFzc1xyXG5cclxuY2xhc3MgU2FuZGJveE5hdGl2ZVRyYWNlcihTYW5kYm94QmFzaWNUcmFjZXIpOlxyXG4gICAgXCJcIlwiXHJcbiAgICBUcmFja3MgbGluZXMgY292ZXJlZCBhbmQgZnVuY3Rpb24gY2FsbHMuIFBvc3NpYmx5IG90aGVyIHRoaW5ncz8gV2UgY291bGQgdHJhY2sgdmFyaWFibGVzLCBpZiB0aGF0XHJcbiAgICB3YXMgc29tZXRoaW5nIHBlb3BsZSB3YW50ZWQuXHJcblxyXG4gICAgVE9ETzogSGFuZGxlIG11bHRpcGxlIHN1Ym1pc3Npb24gZmlsZXM/XHJcbiAgICBcIlwiXCJcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICBzdXBlcigpLl9faW5pdF9fKClcclxuICAgICAgICAjc2VsZi5jYWxscyA9IHV0aWxpdHkudHJhY2VfY2FsbHMoKVxyXG4gICAgICAgIHNlbGYubGluZXMgPSB1dGlsaXR5LnRyYWNlX2xpbmVzKClcclxuICAgICAgICBzZWxmLnN0ZXBfaW5kZXggPSBsZW4odXRpbGl0eS50cmFjZV9saW5lcygpKVxyXG4gICAgXHJcbiAgICBkZWYgZ2V0X2NhbGxzKHNlbGYpOlxyXG4gICAgICAgIHJldHVybiB1dGlsaXR5LnRyYWNlX2NhbGxzKClcclxuICAgIFxyXG4gICAgY2FsbHMgPSBwcm9wZXJ0eShnZXRfY2FsbHMpXHJcbiAgICBcclxuICAgIGRlZiBfX2VudGVyX18oc2VsZik6XHJcbiAgICAgICAgdXRpbGl0eS5zdGFydF90cmFjZShzZWxmKVxyXG5cclxuICAgIGRlZiBfX2V4aXRfXyhzZWxmLCBleGNfdHlwZSwgZXhjX3ZhbCwgdHJhY2ViYWNrKTpcclxuICAgICAgICB1dGlsaXR5LnN0b3BfdHJhY2Uoc2VsZilcclxuXHJcblRSQUNFUl9TVFlMRVMgPSB7XHJcbiAgICAnbm9uZSc6IFNhbmRib3hCYXNpY1RyYWNlcixcclxuICAgICduYXRpdmUnOiBTYW5kYm94TmF0aXZlVHJhY2VyXHJcbn1cclxuXHJcbmA7IiwiLyoqXG4gKiBTa3VscHQgTW9kdWxlIGZvciBob2xkaW5nIHRoZSBJbnN0cnVjdG9yIEFQSS5cbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyBsb2FkZWQgaW4gYnkgZ2V0dGluZyB0aGUgZnVuY3Rpb25zJyBzb3VyY2UgY29kZSBmcm9tIHRvU3RyaW5nLlxuICogSXNuJ3QgdGhhdCBjcmF6eT9cbiAqXG4gKlxuICovXG5leHBvcnQgbGV0ICRza19tb2RfaW5zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE1haW4gbW9kdWxlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgYXQgdGhlIGVuZC5cbiAgICBsZXQgbW9kID0ge307XG4gICAgbGV0IG5vbmUgPSBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgXG4gICAgbGV0IHByaW9yID0gbnVsbDtcbiAgICBtb2QudGltZWl0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ0aW1laXRcIiwgYXJndW1lbnRzLCAxLCAxKTtcbiAgICAgICAgbGV0IGRpZmZlcmVuY2U7XG4gICAgICAgIGlmIChwcmlvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gRGF0ZS5ub3coKSAtIHByaW9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFNrLmZmaS5yZW1hcFRvSnMobmFtZSksIGRpZmZlcmVuY2UvMTAwMCk7XG4gICAgICAgIHByaW9yID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBMb2dzIGZlZWRiYWNrIHRvIGphdmFzY3JpcHQgY29uc29sZVxuICAgICAqL1xuICAgIG1vZC5jb25zb2xlX2xvZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKChbLi4uYXJndW1lbnRzXSkubWFwKFNrLmZmaS5yZW1hcFRvSnMpKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBMb2dzIGRlYnVnIHRvIGphdmFzY3JpcHQgY29uc29sZVxuICAgICAqL1xuICAgIG1vZC5jb25zb2xlX2RlYnVnID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY292ZXJ0cyB0aGUgb3V0cHV0IGluIHRoZSBzdHVkZW50IHJlcG9ydCB0byBhIHB5dGhvbiBcbiAgICAgKiBsaXN0IGFuZCByZXR1cm5zIGl0LlxuICAgICoqL1xuICAgIG1vZC5nZXRfb3V0cHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9vdXRwdXRcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXVtcIm91dHB1dFwiXSgpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0Lm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnRvU2t1bHB0KCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVzZXRzIHRoZSBvdXRwdXQsIHBhcnRpY3VsYXJseSB1c2VmdWwgaWYgdGhlIHN0dWRlbnRcbiAgICAgKiBjb2RlIGlzIGdvaW5nIHRvIGJlIHJlcnVuLlxuICAgICAqL1xuICAgIG1vZC5yZXNldF9vdXRwdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicmVzZXRfb3V0cHV0XCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5vdXRwdXQucmVtb3ZlQWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICB9KTtcbiAgICBcbiAgICAvKm1vZC5xdWV1ZV9pbnB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJxdWV1ZV9pbnB1dFwiLCBhcmd1bWVudHMsIDEsIEluZmluaXR5KTtcbiAgICAgICAgbGV0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGZvciAobGV0IGkgPSBhcmdzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0ID0gYXJnc1tpXTtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJpbnB1dFwiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKGlucHV0KSk7XG4gICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKFNrLmZmaS5yZW1hcFRvSnMoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgIH0pOyovXG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgaW5zdHJ1Y3RvcnMgdG8gZ2V0IHRoZSBzdHVkZW50cycgY29kZSBhcyBhIHN0cmluZy5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X3Byb2dyYW0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3Byb2dyYW1cIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoU2suZXhlY3V0aW9uUmVwb3J0c1tcInZlcmlmaWVyXCJdLmNvZGUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgaW5zdHJ1Y3RvcnMgdG8gZ2V0IHRoZSBzdHVkZW50cycgY29kZSBhcyBhIHN0cmluZy5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X2V2YWx1YXRpb24gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X2V2YWx1YXRpb25cIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXZhbHVhdGlvbiB8fCBcIlwiKTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2QudHJhY2VfbGluZXMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ucmVhbExpbmVzO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkobGluZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2QudHJhY2VfY2FsbHMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiLS1cIiwgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ0hFQ0tJTkcgQ0FMTFNcIiwgU2suZXhlY3V0aW9uUmVwb3J0c1snc3R1ZGVudCddLnN1Y2Nlc3MpO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGNhbGxzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uY2FsbHM7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShjYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3QoW10pO1xuICAgIH0pO1xuXG4gICAgbW9kLnN0YXJ0X3RyYWNlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUL0JFR0lOXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICAgICAgaWYgKFNrLmJlZm9yZUNhbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFNrLmJlZm9yZUNhbGwgPSBTay5iZWZvcmVDYWxsQmFja3VwO1xuICAgICAgICB9XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcucHVzaCh0cnVlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUL0VORFwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgfSk7XG5cbiAgICBtb2Quc3RvcF90cmFjZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVE9QL0JFR0lOXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0udHJhY2luZy5wb3AoKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RPUC9FTkRcIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbW9kLmdldF9zdHVkZW50X2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25vbmUsIG5vbmVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IudHJhY2ViYWNrICYmIGVycm9yLnRyYWNlYmFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25bXCJsaW5lXCJdID0gZXJyb3IudHJhY2ViYWNrWzBdLmxpbmVubztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb24gPSBTay5mZmkucmVtYXBUb1B5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbZXJyb3IsIHBvc2l0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIG1vZC5oYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3IgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiAhU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2VzcyAmJiBcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvciAmJlxuICAgICAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLnRwJG5hbWUgPT09IFwiVGltZUxpbWl0RXJyb3JcIjtcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgYmFja3VwVGltZSA9IHVuZGVmaW5lZDtcbiAgICBtb2QubGltaXRfZXhlY3V0aW9uX3RpbWUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwibGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgYmFja3VwVGltZSA9IFNrLmV4ZWNMaW1pdDtcbiAgICAgICAgaWYgKFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1vZC51bmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInVubGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gYmFja3VwVGltZTtcbiAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2Quc3VwcHJlc3Nfc2Nyb2xsaW5nID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInN1cHByZXNzX3Njcm9sbGluZ1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFxuICAgIC8qXG4gICAgZGVmIGhpc3Qoc2VsZiwgZGF0YSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnSGlzdG9ncmFtJywgJ3ZhbHVlcyc6IGRhdGEsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgcGxvdChzZWxmLCB4cywgeXM9Tm9uZSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgaWYgeXMgPT0gTm9uZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3gnOiByYW5nZShsZW4oeHMpKSwgJ3knOiB4cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnTGluZScsICd4JzogeHMsICd5JzogeXMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgc2NhdHRlcihzZWxmLCB4cywgeXMsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ1NjYXR0ZXInLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgKi9cbiAgICBtb2QuZ2V0X3Bsb3RzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wbG90c1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXVtcIm91dHB1dFwiXSgpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IG91dHB1dHMuZmlsdGVyKGZ1bmN0aW9uKG91dHB1dCkgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0LnR5cGUgPT09IFwicGxvdFwiO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcImRhdGFcIjogZ3JhcGguY29udGVudC5tYXAoZnVuY3Rpb24ocGxvdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGxvdCA9IHsgXCJ0eXBlXCI6IHBsb3QudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIjogXCJcIiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxvdC50eXBlID09PSBcImxpbmVcIiB8fCBwbG90LnR5cGUgPT09IFwic2NhdHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieFwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi54OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ5XCJdID0gcGxvdC5kYXRhLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Lnk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsb3QudHlwZSA9PT0gXCJoaXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ2YWx1ZXNcIl0gPSBwbG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Bsb3Q7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIFwieGxhYmVsXCI6IFwiXCIsIFwieWxhYmVsXCI6IFwiXCIsIFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJcIiwgXCJsZWdlbmRcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShvdXRwdXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG4gICAgLy8gUHJvdmlkZXMgYHN0dWRlbnRgIGFzIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSB0aGF0IHRoZSBzdHVkZW50IGRlY2xhcmVkLlxuICAgIG1vZC5TdHVkZW50RGF0YSA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIC8vc2VsZi5kYXRhID0gU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBsZXQgbmV3RGljdCA9IG5ldyBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgICAgIFNrLmFic3RyLnNhdHRyKHNlbGYsIG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIiksIG5ld0RpY3QsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5yZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHNlbGYubW9kdWxlLiRkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2suYWJzdHIub2JqZWN0U2V0SXRlbShuZXdEaWN0LCBTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQoa2V5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxsX2YgPSBmdW5jdGlvbihrd2EpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJjYWxsXCIsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIEluZmluaXR5LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBrd2FyZ3MgPSBuZXcgU2suYnVpbHRpbnMuZGljdChrd2EpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDIpO1xuXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0ga3dhcmdzLm1wJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJpbnB1dHNcIikpO1xuICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gU2suZmZpLnJlbWFwVG9KcyhpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwiZGF0YVwiKSk7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25PYmplY3QgPSBkYXRhLm1wJGxvb2t1cChmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uT2JqZWN0LnRwJGNhbGwoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBjYWxsX2YuY29fa3dhcmdzID0gdHJ1ZTtcbiAgICAgICAgLy9jYWxsX2YuY29fdmFybmFtZXMgPSBbXCJzZWxmXCIsIFwiZnVuY3Rpb25cIl07XG4gICAgICAgIGNhbGxfZi5jb19uYW1lPSBuZXcgU2suYnVpbHRpbi5zdHIoXCJjYWxsXCIpO1xuICAgICAgICAkbG9jW1wiY2FsbF8kcm4kXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhjYWxsX2YpO1xuXG4gICAgICAgICRsb2NbXCJfX3JlcHJfX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5nZXRfbmFtZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9uYW1lc19ieV90eXBlXCIsIGFyZ3VtZW50cywgMiwgMyk7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJleGNsdWRlX2J1aWx0aW5zXCIsIFwiYm9vbGVhblwiLCBTay5idWlsdGluLmNoZWNrQm9vbChleGNsdWRlX2J1aWx0aW5zKSk7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IFNrLmZmaS5yZW1hcFRvSnMoZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlW3Byb3BlcnR5XS50cCRuYW1lID09PSB0eXBlLnRwJG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNrLmZmaS5yZW1hcFRvUHkoU2sudW5maXhSZXNlcnZlZChwcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAkbG9jLmdldF92YWx1ZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF92YWx1ZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYubW9kdWxlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9LCBcIlN0dWRlbnREYXRhXCIpO1xuICAgIG1vZC5zdHVkZW50ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChtb2QuU3R1ZGVudERhdGEpO1xuICAgIFxuICAgIG1vZC5nZXRfc3R1ZGVudF9kYXRhID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2RhdGFcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdHVkZW50O1xuICAgIH0pO1xuXG4gICAgbW9kLnNldF9pbnN0cnVjdGlvbnMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKG5ld0luc3RydWN0aW9ucykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic2V0X2luc3RydWN0aW9uc1wiLCBhcmd1bWVudHMsIDEsIDIpO1xuICAgICAgICBuZXdJbnN0cnVjdGlvbnMgPSBTay5mZmkucmVtYXBUb0pzKG5ld0luc3RydWN0aW9ucyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXS5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobmV3SW5zdHJ1Y3Rpb25zKTtcbiAgICB9KTtcblxuICAgIG1vZC5nZXRfbW9kZWxfaW5mbyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oa2V5cykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X21vZGVsX2luZm9cIiwgYXJndW1lbnRzLCAxLCAxKTtcbiAgICAgICAgbGV0IG1vZGVsID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcIm1vZGVsXCJdO1xuICAgICAgICBrZXlzID0gU2suZmZpLnJlbWFwVG9KcyhrZXlzKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWxba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkobW9kZWwoKSk7XG4gICAgfSk7XG5cbiAgICBtb2QuY2xlYXJfZXhpc3Rpbmdfc3R1ZGVudF9pbXBvcnRzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImNsZWFyX2V4aXN0aW5nX3N0dWRlbnRfaW1wb3J0c1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMoKTtcbiAgICB9KTtcblxuICAgIG1vZC5kb3dubG9hZF9maWxlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihwbGFjZW1lbnQsIGRpcmVjdG9yeSwgZmlsZW5hbWUpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImRvd25sb2FkX2ZpbGVcIiwgYXJndW1lbnRzLCAzLCAzKTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRGaWxlVXJsID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcIm1vZGVsXCJdLmNvbmZpZ3VyYXRpb24udXJsc1tcImRvd25sb2FkRmlsZVwiXTtcbiAgICAgICAgY29uc3QgY29tYmluZXIgPSBkb3dubG9hZEZpbGVVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7ZG93bmxvYWRGaWxlVXJsfSR7Y29tYmluZXJ9cGxhY2VtZW50PSR7cGxhY2VtZW50fSZkaXJlY3Rvcnk9JHtkaXJlY3Rvcnl9JmZpbGVuYW1lPSR7ZmlsZW5hbWV9YDtcbiAgICAgICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgaWYgdGhpcyBuZWVkcyBoZWFkZXJzXG5cbiAgICAgICAgICAgIHhtbGh0dHAuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFNrLmZmaS5yZW1hcFRvUHkoeG1saHR0cC5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgdXJsKTtcbiAgICAgICAgICAgIHhtbGh0dHAuc2VuZChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpO1xuICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgIHN1c3AucmVzdW1lID0gKCk9PnJlc29sdXRpb247XG4gICAgICAgIHN1c3AuZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgcHJvbWlzZTogcHJvbS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbiA9XCJcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN1c3A7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG1vZDtcbn07XG4iLCJleHBvcnQgdmFyICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1vZCwgc2FtcGxlV3JhcHBlcjtcclxuICAgIG1vZCA9IHtfX25hbWVfXzogXCJ3ZWFrcmVmXCJ9O1xyXG5cclxuICAgIC8qbW9kLldlYWtTZXQgPSBTay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwid2Vha3JlZi5XZWFrU2V0XCIsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gV2Vha1NldCgpXHJcbiAgICB9KTsqL1xyXG5cclxuICAgIHZhciBXZWFrU2V0ID0gZnVuY3Rpb24oJGdibCwgJGxvYykge1xyXG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xyXG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZGF0YVwiLCBcIml0ZXJhYmxlXCIsIFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShkYXRhKSk7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaXRlciA9IFNrLmFic3RyLml0ZXIoZGF0YSk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gU2suYWJzdHIuaXRlcm5leHQoaXRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhLnB1c2gobmV3IFdlYWtSZWYobmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkbG9jLl9faXRlcl9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZkRhdGEgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgc2VsZi5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2VsZi5kYXRhW2ldLmRlcmVmKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld09mRGF0YS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHZpZXdPZkRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBTay5hYnN0ci5pdGVyKG5ldyBTay5idWlsdGluLmxpc3Qodmlld09mRGF0YSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKiRsb2MubmV4dCQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnRwJGl0ZXIoKTtcclxuICAgICAgICB9KTsqL1xyXG5cclxuICAgICAgICAkbG9jLmFkZCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgaXRlbSkge1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEucHVzaChuZXcgV2Vha1JlZihpdGVtKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgbW9kLldlYWtTZXQgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgV2Vha1NldCwgXCJXZWFrU2V0XCIsIFtdKTtcclxuXHJcbiAgICByZXR1cm4gbW9kO1xyXG59OyIsImxldCBMT0NBTF9TVE9SQUdFX1JFRjtcbnRyeSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYgPSBsb2NhbFN0b3JhZ2U7XG4gICAgbGV0IG1vZCA9IFwiQkxPQ0tQWV9MT0NBTFNUT1JBR0VfVEVTVFwiO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0obW9kKTtcbn0gY2F0Y2goZSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGID0ge1xuICAgICAgICBfZGF0YSAgICAgICA6IHt9LFxuICAgICAgICBzZXRJdGVtICAgICA6IGZ1bmN0aW9uKGlkLCB2YWwpIHsgcmV0dXJuIHRoaXMuX2RhdGFbaWRdID0gU3RyaW5nKHZhbCk7IH0sXG4gICAgICAgIGdldEl0ZW0gICAgIDogZnVuY3Rpb24oaWQpIHsgcmV0dXJuIHRoaXMuX2RhdGEuaGFzT3duUHJvcGVydHkoaWQpID8gdGhpcy5fZGF0YVtpZF0gOiBudWxsOyB9LFxuICAgICAgICByZW1vdmVJdGVtICA6IGZ1bmN0aW9uKGlkKSB7IHJldHVybiBkZWxldGUgdGhpcy5fZGF0YVtpZF07IH0sXG4gICAgICAgIGNsZWFyICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhID0ge307IH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBvYmplY3QgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIExvY2FsU3RvcmFnZS4gVGhlIExvY2FsU3RvcmFnZVxuICogYnJvd3NlciBBUEkgYWxsb3dzIGZvciBvZmZsaW5lIHN0b3JhZ2UuIFRoYXQgQVBJIGlzIHZlcnkgdW5zb3BoaXN0aWNhdGVkLFxuICogYW5kIGlzIGVzc2VudGlhbGx5IGEgbGFtZSBrZXktdmFsdWUgc3RvcmUuIFRoaXMgb2JqZWN0IHNpdHMgb24gdG9wXG4gKiBhbmQgcHJvdmlkZXMgYSBudW1iZXIgb2YgdXNlZnVsIHV0aWxpdGllcywgaW5jbHVkaW5nIHJ1ZGltZW50YXJ5Y2FjaGVcbiAqIGNhY2hlIGV4cGlyYXRpb24uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7TG9jYWxTdG9yYWdlV3JhcHBlcn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBBIG5hbWVzcGFjZSB0byB1c2UgaW4gZ3JvdXBpbmcgYWNjZXNzIHRvIGxvY2Fsc3RvcmFnZS4gVGhpcyBrZWVwcyBhY2Nlc3MgY2xlYW4gYW5kIG9yZ2FuaXplZCwgd2hpbGUgYWxzbyBtYWtpbmcgaXQgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBMb2NhbFN0b3JhZ2UgY29ubmVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBMb2NhbFN0b3JhZ2VXcmFwcGVyKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xufVxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgYWRkaW5nIGEga2V5L3ZhbHVlIHBhaXIgdG8gTG9jYWxTdG9yYWdlLlxuICogTm90ZSB0aGF0IGJvdGggcGFyYW1ldGVycyBtdXN0IGJlIHN0cmluZ3MgKEpTT04uc3RyaW5naWZ5IGlzIHlvdXIgZnJpZW5kKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZS5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiLCB2YWx1ZSk7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIsICQubm93KCkpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmVtb3ZpbmcgYSBrZXkgZnJvbSBMb2NhbFN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmVtb3ZlLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIik7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIik7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB0aW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB0aW1lIGZvci5cbiAqIEByZXR1cm5zIHtJbnRlZ2VyfSAtIFRoZSB0aW1lc3RhbXAgKGxvY2FsIGVwb2NoKSB3aGVuIHRoZSBrZXkgd2FzIGxhc3Qgc2V0LlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKSk7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqIElmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIHRoZW4gdGhlIGRlZmF1bHQgdmFsdWUgaXMgdXNlZCBpbnN0ZWFkLlxuICogVGhpcyBkZWZhdWx0IHdpbGwgYmUgc2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlLiBNdXN0IGJlIGEgc3RyaW5nLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHRlc3QgZm9yIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBpbiBMb2NhbFN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdGVzdCBleGlzdGVuY2UgZm9yLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIikgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIEEgdGVzdCBmb3Igd2hldGhlciB0aGUgc2VydmVyIGhhcyB0aGUgbmV3ZXIgdmVyc2lvbi4gVGhpcyBmdW5jdGlvblxuICogYXNzdW1lcyB0aGF0IHRoZSBzZXJ2ZXIgdHJpcCB0YWtlcyBhYm91dCA1IHNlY29uZHMuIFRoaXMgbWV0aG9kXG4gKiBpcyBsYXJnZWx5IGRlcHJlY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHNlcnZlcl90aW1lIC0gVGhlIHNlcnZlcidzIHRpbWUgYXMgYW4gZXBvY2ggKGluIG1pbGxpc2Vjb25kcylcbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaXNfbmV3ID0gZnVuY3Rpb24oa2V5LCBzZXJ2ZXJfdGltZSkge1xuICAgIHZhciBzdG9yZWRfdGltZSA9IExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKTtcbiAgICByZXR1cm4gKHNlcnZlcl90aW1lID49IHN0b3JlZF90aW1lKzUwMDApO1xufTtcbiIsImV4cG9ydCBjb25zdCBUUkFDRV9IVE1MID0gYFxuXG48ZGl2IGNsYXNzPVwiYmxvY2tweS10cmFjZSBjb2wtbWQtNiBibG9ja3B5LXBhbmVsXCJcbiAgICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiVHJhY2VcIj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiY2xlYXJmaXhcIj5cbiAgICAgICAgPHN0cm9uZz5UcmFjZTogPC9zdHJvbmc+XG4gICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0IGJsb2NrcHktaGlkZS10cmFjZSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuc2Vjb25kUm93LmFkdmFuY2VTdGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj4gSGlkZSBUcmFjZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zIGJsb2NrcHktdHJhY2UtY29udHJvbHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXByZXBlbmRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuZmlyc3RcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtYmFja3dhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5iYWNrd2FyZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+U3RlcDo8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAvIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuZm9yd2FyZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZm9yd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmxhc3RcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtZm9yd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IHVpLnRyYWNlLmxpbmUnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPHAgZGF0YS1iaW5kPVwidGV4dDogdWkudHJhY2UuYXN0XCI+PC9wPlxuICAgIDxwPlZhcmlhYmxlcyBhZnRlciB0aGlzIHN0ZXA6PC9wPlxuICAgIDx0YWJsZSBjbGFzcz0ndGFibGUgdGFibGUtc20gdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1ob3Zlcic+XG4gICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgIDx0cj48dGg+TmFtZTwvdGg+PHRoPlR5cGU8L3RoPjx0aD5WYWx1ZTwvdGg+PC90cj5cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5IGRhdGEtYmluZD1cImZvcmVhY2g6IHVpLnRyYWNlLmRhdGEoKS5wcm9wZXJ0aWVzXCI+XG4gICAgICAgICAgICA8dHIgZGF0YS1iaW5kPVwidmlzaWJsZTogbmFtZSAhPSAnX19maWxlX18nICYmIG5hbWUgIT0gJ19fcGF0aF9fJ1wiPlxuICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lXCI+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgZGF0YS1iaW5kPVwidGV4dDogdHlwZVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICA8Y29kZSBkYXRhLWJpbmQ9XCJ0ZXh0OiB2YWx1ZVwiPjwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBrbyBpZjogdHlwZSA9PSBcIkxpc3RcIiAtLT5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJcIiBkYXRhLWJpbmQ9XCJjbGljazogLy8kcm9vdC52aWV3RXhhY3RWYWx1ZSh0eXBlLCBleGFjdF92YWx1ZSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2dseXBoaWNvbiBnbHlwaGljb24tbmV3LXdpbmRvdyc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICAgXG48L2Rpdj5cbmA7XG5cbmV4cG9ydCBjb25zdCBBU1RfREVTQ1JJUFRJT05TID0ge1xuICAgIFwiQWRkXCI6IFwiQW4gYWRkaXRpb24gb3BlcmF0b3JcIixcbiAgICBcIkFuZFwiOiBcIkEgYm9vbGVhbiBBTkQgb3BlcmF0b3JcIixcbiAgICBcIkFubkFzc2lnblwiOiBcIkFuIGFubm90YXRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJBc3NlcnRcIjogXCJBbiBhc3NlcnQgc3RhdGVtZW50XCIsXG4gICAgXCJBc3NpZ25cIjogXCJBbiBhc3NpZ25tZW50IHN0YXRlbWVudFwiLFxuICAgIFwiQXN5bmNGb3JcIjogXCJBbiBhc3ljaHJvbm91cyBmb3IgbG9vcFwiLFxuICAgIFwiQXN5bmNGdW5jdGlvbkRlZlwiOiBcIkFuIGFzeWNocm9ub3VzIGZ1bmN0aW9uIGRlZmluaXRpb25cIixcbiAgICBcIkFzeW5jV2l0aFwiOiBcIkFuIGFzeWNocm9ub3VzIHdpdGggc3RhdGVtZW50XCIsXG4gICAgXCJBdHRyaWJ1dGVcIjogXCJBbiBhdHRyaWJ1dGUgbG9va3VwIChhY2Nlc3MgYSBmaWVsZClcIixcbiAgICBcIkF1Z0Fzc2lnblwiOiBcIkFuIGF1Z21lbnRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJBdWdMb2FkXCI6IFwiQW4gYXVnbWVudGVkIGxvYWRcIixcbiAgICBcIkF1Z1N0b3JlXCI6IFwiQW4gYXVnbWVudGVkIHN0b3JlXCIsXG4gICAgXCJBd2FpdFwiOiBcIkFuIGF3YWl0IHN0YXRlbWVudFwiLFxuICAgIFwiQmluT3BcIjogXCJBIGJpbmFyeSBvcGVyYXRvclwiLFxuICAgIFwiQml0QW5kXCI6IFwiQSBiaXR3aXNlIEFORCBvcGVyYXRvclwiLFxuICAgIFwiQml0T3JcIjogXCJBIGJpdHdpc2UgT1Igb3BlcmF0b3JcIixcbiAgICBcIkJpdFhvclwiOiBcIkEgYml0d2lzZSBYT1Igb3BlcmF0b3JcIixcbiAgICBcIkJvb2xPcFwiOiBcIkEgYm9vbGVhbiBvcGVyYXRvclwiLFxuICAgIFwiQnJlYWtcIjogXCJBIGJyZWFrIHN0YXRlbWVudFwiLFxuICAgIFwiQnl0ZXNcIjogXCJBIGxpdGVyYWwgYnl0ZXMgc3RyaW5nXCIsXG4gICAgXCJDYWxsXCI6IFwiQSBmdW5jdGlvbiBjYWxsXCIsXG4gICAgXCJDbGFzc0RlZlwiOiBcIkEgY2xhc3MgZGVmaW5pdGlvblwiLFxuICAgIFwiQ29tcGFyZVwiOiBcIkEgYm9vbGVhbiBjb21wYXJpc29uXCIsXG4gICAgXCJDb25zdGFudFwiOiBcIkEgbGl0ZXJhbCB2YWx1ZVwiLFxuICAgIFwiQ29udGludWVcIjogXCJBIGNvbnRpbnVlIHN0YXRlbWVudFwiLFxuICAgIFwiRGVsXCI6IFwiQSBkZWxldGUgc3RhdGVtZW50XCIsXG4gICAgXCJEZWxldGVcIjogXCJBIGRlbGV0aW9uXCIsXG4gICAgXCJEaWN0XCI6IFwiQSBkaWN0aW9uYXJ5IGxpdGVyYWxcIixcbiAgICBcIkRpY3RDb21wXCI6IFwiQSBkaWN0aW9uYXJ5IGNvbXByZWhlbnNpb25cIixcbiAgICBcIkRpdlwiOiBcIkEgZGl2aXNpb24gb3BlcmF0b3JcIixcbiAgICBcIkVsbGlwc2lzXCI6IFwiQW4gZWxsaXBzaXNcIixcbiAgICBcIkVxXCI6IFwiQW4gZXF1YWxpdHkgY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiRXhjZXB0SGFuZGxlclwiOiBcIkFuIGV4Y2VwdCBoYW5kbGVyXCIsXG4gICAgXCJFeHByXCI6IFwiQW4gZXhwcmVzc2lvbiB1c2VkIGFzIGEgc3RhdGVtZW50XCIsXG4gICAgXCJFeHByZXNzaW9uXCI6IFwiQW4gZXZhbHVhdGVkIGV4cHJlc3Npb25cIixcbiAgICBcIkV4dFNsaWNlXCI6IFwiQSBtdWx0aS1kaW1lbnNpb25hbCBzbGljZVwiLFxuICAgIFwiRmxvb3JEaXZcIjogXCJBbiBpbnRlZ2VyIGRpdmlzaW9uIG9wZXJhdG9yXCIsXG4gICAgXCJGb3JcIjogXCJBIEZPUiBsb29wXCIsXG4gICAgXCJGb3JtYXR0ZWRWYWx1ZVwiOiBcIkEgZm9ybWF0dGVkIHZhbHVlIGluIGFuIGYtc3RyaW5nXCIsXG4gICAgXCJGdW5jdGlvbkRlZlwiOiBcIkEgZnVuY3Rpb24gZGVmaW5pdGlvblwiLFxuICAgIFwiR2VuZXJhdG9yRXhwXCI6IFwiQSBnZW5lcmF0b3IgZXhwcmVzc2lvblwiLFxuICAgIFwiR2xvYmFsXCI6IFwiQSBnbG9iYWwgc3RhdGVtZW50XCIsXG4gICAgXCJHdFwiOiBcIkEgZ3JlYXRlciB0aGFuIGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIkd0RVwiOiBcIkEgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIklmXCI6IFwiQW4gSUYgc3RhdGVtZW50XCIsXG4gICAgXCJJZkV4cFwiOiBcIkFuIElGIGV4cHJlc3Npb25cIixcbiAgICBcIkltcG9ydFwiOiBcIkFuIGltcG9ydCBzdGF0ZW1lbnRcIixcbiAgICBcIkltcG9ydEZyb21cIjogXCJBbiBpbXBvcnQvZnJvbSBzdGF0ZW1lbnRcIixcbiAgICBcIkluXCI6IFwiQW4gSU4gb3BlcmF0b3JcIixcbiAgICBcIkluZGV4XCI6IFwiQW4gaW5kZXhcIixcbiAgICBcIkludGVyYWN0aXZlXCI6IFwiQW4gaW50ZXJhY3RpdmUgZXhwcmVzc2lvblwiLFxuICAgIFwiSW52ZXJ0XCI6IFwiQW4gaW52ZXJ0IG9wZXJhdG9yXCIsXG4gICAgXCJJc1wiOiBcIkFuIElTIG9wZXJhdG9yXCIsXG4gICAgXCJJc05vdFwiOiBcIkFuIElTIE5PVCBvcGVyYXRvclwiLFxuICAgIFwiSm9pbmVkU3RyXCI6IFwiQW4gZi1zdHJpbmdcIixcbiAgICBcIkxTaGlmdFwiOiBcIkEgbGVmdCBzaGlmdCBvcGVyYXRvclwiLFxuICAgIFwiTGFtYmRhXCI6IFwiQSBsYW1iZGEgZXhwcmVzc2lvblwiLFxuICAgIFwiTGlzdFwiOiBcIkEgbGlzdCBsaXRlcmFsXCIsXG4gICAgXCJMaXN0Q29tcFwiOiBcIkEgbGlzdCBjb21wcmVoZW5zaW9uXCIsXG4gICAgXCJMb2FkXCI6IFwiQSBsb2FkXCIsXG4gICAgXCJMdFwiOiBcIkEgbGVzcyB0aGFuIGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIkx0RVwiOiBcIkEgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIk1hdE11bHRcIjogXCJBIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiTW9kXCI6IFwiQSBtb2R1bG8gb3BlcmF0b3JcIixcbiAgICBcIk1vZHVsZVwiOiBcIkEgbW9kdWxlXCIsXG4gICAgXCJNdWx0XCI6IFwiQSBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiTmFtZVwiOiBcIkEgbmFtZVwiLFxuICAgIFwiTmFtZUNvbnN0YW50XCI6IFwiQSBuYW1lIGNvbnN0YW50XCIsXG4gICAgXCJOb25sb2NhbFwiOiBcIkEgbm9ubG9jYWwgc3RhdGVtZW50XCIsXG4gICAgXCJOb3RcIjogXCJBIG5vdCBvcGVyYXRvclwiLFxuICAgIFwiTm90RXFcIjogXCJBIG5vdCBlcXVhbCB0byBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJOb3RJblwiOiBcIkEgTk9UIElOIG9wZXJhdG9yXCIsXG4gICAgXCJOdW1cIjogXCJBIG51bWVyaWMgbGl0ZXJhbFwiLFxuICAgIFwiT3JcIjogXCJBIGJvb2xlYW4gT1Igb3BlcmF0b3JcIixcbiAgICBcIlBhcmFtXCI6IFwiQSBwYXJhbWV0ZXJcIixcbiAgICBcIlBhc3NcIjogXCJBIHBhc3Mgc3RhdGVtZW50XCIsXG4gICAgXCJQb3dcIjogXCJBIHBvd2VyIG9wZXJhdG9yXCIsXG4gICAgXCJSU2hpZnRcIjogXCJBIHJpZ2h0IHNoaWZ0IG9wZXJhdG9yXCIsXG4gICAgXCJSYWlzZVwiOiBcIkEgcmFpc2Ugc3RhdGVtZW50XCIsXG4gICAgXCJSZXR1cm5cIjogXCJBIHJldHVybiBzdGF0ZW1lbnRcIixcbiAgICBcIlNldFwiOiBcIkEgc2V0IGxpdGVyYWxcIixcbiAgICBcIlNldENvbXBcIjogXCJBIHNldCBjb21wcmVoZW5zaW9uXCIsXG4gICAgXCJTbGljZVwiOiBcIkEgc2xpY2VcIixcbiAgICBcIlN0YXJyZWRcIjogXCJBIHN0YXJyZWQgYXJndW1lbnRcIixcbiAgICBcIlN0b3JlXCI6IFwiQSBzdG9yZVwiLFxuICAgIFwiU3RyXCI6IFwiQSBzdHJpbmcgbGl0ZXJhbFwiLFxuICAgIFwiU3ViXCI6IFwiQSBzdWJ0cmFjdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiU3Vic2NyaXB0XCI6IFwiQSBzdWJzY3JpcHRcIixcbiAgICBcIlN1aXRlXCI6IFwiQSBzdWl0ZVwiLFxuICAgIFwiVHJ5XCI6IFwiQSB0cnkgc3RhdGVtZW50XCIsXG4gICAgXCJUdXBsZVwiOiBcIkEgdHVwbGUgbGl0ZXJhbFwiLFxuICAgIFwiVHlwZUlnbm9yZVwiOiBcIiBhIHR5cGUgaWdub3JlXCIsXG4gICAgXCJVQWRkXCI6IFwiQSB1bmFyeSBhZGRpdGlvbiBvcGVyYXRvclwiLFxuICAgIFwiVVN1YlwiOiBcIkEgdW5hcnkgc3VidHJhY3Rpb24gb3BlcmF0b3JcIixcbiAgICBcIlVuYXJ5T3BcIjogXCJBIHVuYXJ5IG9wZXJhdG9yXCIsXG4gICAgXCJXaGlsZVwiOiBcIkEgd2hpbGUgbG9vcFwiLFxuICAgIFwiV2l0aFwiOiBcIkEgd2l0aCBzdGF0ZW1lbnRcIixcbiAgICBcIllpZWxkXCI6IFwiQSB5aWVsZCBzdGF0ZW1lbnRcIixcbiAgICBcIllpZWxkRnJvbVwiOiBcIkEgeWllbGQvZnJvbSBzdGF0ZW1lbnRcIlxufTtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlUcmFjZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICAgICAgdGhpcy5JR05PUkVEX0dMT0JBTFMgPSBbXCJfX25hbWVfX1wiLCBcIl9fZG9jX19cIiwgXCJfX3BhY2thZ2VfX1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzbWV0aG9kXCIsIFwicHJvcGVydHlcIiwgXCJzdGF0aWNtZXRob2RcIiwgXCIkZnJlZVwiLCBcIiRjZWxsXCJdO1xuXG4gICAgICAgIC8vIHRoaXMudHJhY2UuY2xpY2sodGhpcy5idWlsZFRyYWNlVGFibGUuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3VtZSBhIHNldCBvZiB2YXJpYWJsZXMgdHJhY2VkIGZyb20gdGhlIGV4ZWN1dGlvbiBhbmQgcGFyc2Ugb3V0IGFueVxuICAgICAqIGdsb2JhbCB2YXJpYWJsZXMgYW5kIG1vZHVsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFyaWFibGVzIC0gYSBtYXBwaW5nIG9mIHZhcmlhYmxlIG5hbWVzIHRvIHRoZWlyIFNrdXB0IHZhbHVlLlxuICAgICAqL1xuICAgIHBhcnNlR2xvYmFscyh2YXJpYWJsZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbW9kdWxlcyA9IFtdO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHZhcmlhYmxlcyk7XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJhY2VFeGVjdXRpb24oKSkge1xuICAgICAgICAgICAgLyppZiAoXCIkY2VsbFwiIGluIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHsuLi52YXJpYWJsZXMsIC4uLnZhcmlhYmxlcy4kY2VsbH07XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIC8qaWYgKFwiJGZyZWVcIiBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB7Li4udmFyaWFibGVzLCAuLi52YXJpYWJsZXMuJGZyZWV9O1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YXJpYWJsZXNbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLklHTk9SRURfR0xPQkFMUy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoXCJfJHJ3JFwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJfJHJuJFwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEJsb2NrUHlUcmFjZS5wYXJzZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0ge1wibmFtZVwiOiBwcm9wZXJ0eSwgXCJ0eXBlXCI6IFwiVW5rbm93blwiLCBcInZhbHVlXCI6IHZhbHVlLnRvU3RyaW5nKCl9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4ubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLnB1c2godmFsdWUuJGQuX19uYW1lX18udik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcInByb3BlcnRpZXNcIjogcmVzdWx0LCBcIm1vZHVsZXNcIjogbW9kdWxlc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBTa3VscHQgdmFsdWUgaW50byBhIG1vcmUgZWFzaWx5IHByaW50YWJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgc2t1bHB0IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlLCBmdWxsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJVbmtub3duXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlVuZGVmaW5lZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJEZWNvcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiPGRhdGFjbGFzcyBkZWNvcmF0b3I+XCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5mdW5jOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFBhcmFtZXRlcnM6IFwiK3ZhbHVlLmZ1bmNfY29kZS5jb192YXJuYW1lcy5qb2luKFwiLCBcIikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIE5vIHBhcmFtZXRlcnNcIilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm1vZHVsZTogcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uc3RyOlxuICAgICAgICAgICAgICAgIGlmIChmdWxsTGVuZ3RoIHx8IHZhbHVlLnYubGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IFwiW1wiK3ZhbHVlLnNxJGxlbmd0aCgpK1wiIGNoYXJhY3RlcnMgbm90IHNob3duXVwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5vbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIk5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIk5vbmVcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uYm9vbDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubm1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludFwiID09PSB2YWx1ZS5za1R5cGUgPyBcIkludGVnZXJcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uaW50XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZmxvYXRfOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4udHVwbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5saXN0OlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52Lmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlsuLi4gXCIrdmFsdWUudi5sZW5ndGgrXCIgZWxlbWVudHMgLi4uXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleGFjdF92YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5kaWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJEaWN0aW9uYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUgJSAxID09PSAwID8gXCJJbnRlZ2VyXCIgOiBcIkZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6ICh2YWx1ZSA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiB2YWx1ZS50cCRuYW1lID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLnRwJG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUuJHIgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdmFsdWUuJHIoKS52XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cblxufVxuXG4vLyBUT0RPOiB2aWV3RXhhY3RWYWx1ZSIsIi8qKlxuICogTW92ZSBhbiBlbGVtZW50IGZyb20gaW5kZXggaW4gYW4gYXJyYXkgdG8gYSBuZXcgaW5kZXguXG4gKiBPKG4pXG4gKiBDb3VydGVzeTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83Mzg3NzY4MC8xNzE4MTU1XG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gb2xkSW5kZXhcbiAqIEBwYXJhbSBuZXdJbmRleFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU1vdmUoYXJyLCBvbGRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1Ub01vdmUgPSBhcnJbb2xkSW5kZXhdO1xuXG4gICAgaWYgKG9sZEluZGV4ID09PSBuZXdJbmRleCB8fCBvbGRJbmRleCA+IGxlbmd0aCB8fCBuZXdJbmRleCA+IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIucmVkdWNlKChhY2MsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gb2xkSW5kZXgpIHtyZXR1cm4gYWNjO31cbiAgICAgICAgaWYgKGluZGV4ID09PSBuZXdJbmRleCkge3JldHVybiBvbGRJbmRleCA8IG5ld0luZGV4ID8gWy4uLmFjYywgaXRlbSwgaXRlbVRvTW92ZV0gOiBbLi4uYWNjLCBpdGVtVG9Nb3ZlLCBpdGVtXTt9XG4gICAgICAgIHJldHVybiBbLi4uYWNjLCBpdGVtXTtcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7YW55dGhpbmd9IG5lZWRsZSAtIFRoZSBlbGVtZW50IHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtBcnJheX0gaGF5c3RhY2sgLSBUaGUgbGlzdCB0byBzZWFyY2guXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IGV4aXN0c1xuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID4gLTE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheSwgcHJlc2VydmluZyBvcmRlci5cbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXksIHNvIGlzIG5vbi1kZXN0cnVjdGl2ZS5cbiAqIENvdXJ0ZXN5OlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU4NDM3MC9ob3ctdG8tbWVyZ2UtdHdvLWFycmF5cy1pbi1qYXZhc2NyaXB0LWFuZC1kZS1kdXBsaWNhdGUtaXRlbXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB1bmlxdWlmeS4gRWxlbWVudHMgY29tcGFyZWQgd2l0aCA9PT0uXG4gKi9cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgdmFyIGEgPSBhcnJheS5jb25jYXQoKTtcbiAgICBmb3IodmFyIGk9MDsgaTxhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYoYVtpXSA9PT0gYVtqXSkge2Euc3BsaWNlKGotLSwgMSk7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4dGVuZGluZyBhbiBhcnJheSBiYXNlZFxuICogb24gYW4gXCJhZGRBcnJheVwiIGFuZCBcInJlbW92ZUFycmF5XCIuIEFueSBlbGVtZW50XG4gKiBmb3VuZCBpbiByZW1vdmVBcnJheSBpcyByZW1vdmVkIGZyb20gdGhlIGZpcnN0IGFycmF5XG4gKiBhbmQgYWxsIHRoZSBlbGVtZW50cyBvZiBhZGRBcnJheSBhcmUgYWRkZWQuXG4gKiBBbnkgZHVwbGljYXRlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIG1hbmlwdWxhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFkZEFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZUFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBtb2RpZmllZCBhcnJheVxuICovXG5mdW5jdGlvbiBleHBhbmRBcnJheShhcnJheSwgYWRkQXJyYXksIHJlbW92ZUFycmF5KSB7XG4gICAgdmFyIGNvcHlBcnJheSA9IGFycmF5LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVBcnJheS5pbmRleE9mKGl0ZW0pID09PSAtMTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29weUFycmF5LmNvbmNhdChhZGRBcnJheSkpO1xufVxuXG4vKipcbiAqIERlZXBseSBjbG9uZXMgYSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQSBub2RlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHtOb2RlfSBBIGNsb25lIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbGwgaXRzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUsIHRoZW4gcmUtY3JlYXRlIGl0IHJhdGhlciB0aGFuIGNsb25lIGl0XG4gICAgdmFyIGNsb25lID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuIFxuICAgIC8vIFJlY3Vyc2UgICAgIFxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjaGlsZCkge1xuICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChjbG9uZU5vZGUoY2hpbGQpKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gICAgIFxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBJbmRlbnRzIHRoZSBnaXZlbiBzdHJpbmcgYnkgNCBzcGFjZXMuIFRoaXMgY29ycmVjdGx5IGhhbmRsZXMgbXVsdGktbGluZSBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyB3aXRoIGZvdXIgc3BhY2VzIGFkZGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuZXcgbGluZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oPz0uKS9nbSwgXCIgICAgXCIpO1xufVxuXG4vKipcbiAqIFR1cm5zIHNwYWNlcyBpbnRvIHVuZGVyc2NvcmVzIGluIHRoZSBzdHJpbmcsIG1ha2VzIGl0IGxvd2VyY2FzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSB0aGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2x1ZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccy9nLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gYmUgY2FwaXRhbGl6ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbYG1pbmAsIGBtYXhgXS5cbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBsb3dlc3QgcG9zc2libGUgaW50ZWdlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgaGlnaGVzdCBwb3NzaWJsZSBpbnRlZ2VyIChpbmNsdXNpdmUpLlxuICogQHJldHVybnMge251bWJlcn0gQSByYW5kb20gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50ZWdlcihtaW4sbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWF4LW1pbisxKSttaW4pO1xufVxuXG4vKipcbiAqIEVuY29kZXMgc29tZSB0ZXh0IHNvIHRoYXQgaXQgY2FuIGJlIHNhZmVseSB3cml0dGVuIGludG8gYW4gSFRNTCBib3guXG4gKiBUaGlzIGluY2x1ZGVzIHJlcGxhY2luZyBzcGVjaWFsIEhUTUwgY2hhcmFjdGVycyAoJiwgPCwgPiwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0ZXh0IHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEhUTUwtc2FmZSB0ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSFRNTChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKTtcbn1cblxuLyoqXG4gKiBTaHVmZmxlIHRoZSBibG9ja3MgaW4gdGhlIHdvcmtzcGFjZVxuICovXG5pZiAodHlwZW9mIEJsb2NrbHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBCbG9ja2x5LldvcmtzcGFjZVN2Zy5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMuZ2V0TWV0cmljcygpO1xuICAgICAgICB2YXIgd2lkdGggPSBtZXRyaWNzLnZpZXdXaWR0aCAvIDIsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZXRyaWNzLnZpZXdIZWlnaHQ7XG4gICAgICAgIHZhciBibG9ja3MgPSB0aGlzLmdldFRvcEJsb2NrcyhmYWxzZSk7XG4gICAgICAgIHZhciB5ID0gNSwgeCA9IDAsXG4gICAgICAgICAgICBtYXhpbWFsX2luY3JlYXNlID0gaGVpZ2h0L2Jsb2Nrcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCBhIGJsb2NrXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IGJsb2NrLmdldFJlbGF0aXZlVG9TdXJmYWNlWFkoKTtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC1wcm9wZXJ0aWVzLngrcmFuZG9tSW50ZWdlcigxMCwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2subW92ZUJ5KHgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIC1wcm9wZXJ0aWVzLnkreSk7XG4gICAgICAgICAgICB5ID0geSArIHJhbmRvbUludGVnZXIoNSwgbWF4aW1hbF9pbmNyZWFzZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE1vdmUgZWxlbWVudHMgZnJvbSBvbmUgYXJyYXkgdG8gYW5vdGhlciBiYXNlZCBvbiBhIGNvbmRpdGlvbmFsIGNoZWNrLlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzE4ODc5NjcvamF2YXNjcmlwdC1tb3ZlLW9iamVjdHMtZnJvbS1vbmUtYXJyYXktdG8tYW5vdGhlci1iZXN0LWFwcHJvYWNoXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50cyhzb3VyY2UsIHRhcmdldCwgbW92ZUNoZWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChtb3ZlQ2hlY2soZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH0gXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIG9iamVjdHNcbiAqIFRPRE86IG1ha2UgdGhpcyBzbyB3ZSBkb24ndCBoYXZlIHRvIGV4cGxpY2l0bHkgcHV0IG91dCBldmVyeSBvcHRpb25cbiAqICAgICAgICAgIG9uZSBwb3NzaWJsZSB0aGluZyB3ZSBjb3VsZCBkbyBpcyBnZXQgYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgXG4gKiAgICAgICAgICBvZiB0aGUgY29uc3RydWN0b3IgYW5kIGxvb2sgZm9yIHRoZSBzdWJzdHJpbmcgXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIlxuICogICAgICAgICAgQnV0IEkgZG9uJ3Qga25vdyBob3cgcmVsaWFibGUgdGhhdCBpcy4gIFJhdGhlciwgaXQncyBraW5kIG9mIGhhY2tpc2guXG4gKiAgICAgICAgICBTaG91bGQgdGVob3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBleGFtaW5lZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG9uZSBvZiB0aGUgU2suYnVpbHRpbiB0eXBlc1xuKiovXG5mdW5jdGlvbiBpc1NrQnVpbHRpbihvYmope1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbCkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyk7XG4gICAgLy92YXIgY29uc19zdHIgPSBvYmouY29uc3RydWN0b3IgKyBcIlwiO1xuICAgIC8vcmV0dXJuIGNvbnNfc3RyLmluZGV4T2YoXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0FzdE5vZGUob2JqKXtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmIFwiX2FzdG5hbWVcIiBpbiBvYmo7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VDVElPTl9QQVRURVJOID0gL14oIyMjIyMgUGFydCAoLispKSQvZ207XG5cbi8qKlxuICogRmluZHMgdGhlIGdpdmVuIFBhcnQgSUQgdXNpbmcgdGhlIHBhdHRlcm4gYCMjIyMgUGFydCB3aGF0ZXZlcmAgKG9uIGl0cyBvd24gc2VwYXJhdGUgbGluZSkuIElmIHRoZSBwYXR0ZXJuXG4gKiBpcyBub3QgZm91bmQsIHRoZW4gbnVsbCBpcyByZXR1cm5lZC4gSWYgbm8gcGF0dGVybiBpcyBnaXZlbiAoZW1wdHkgc3RyaW5nIG9yIG51bGwpLCB0aGVuIHRoZSBvcmlnaW5hbCB0ZXh0XG4gKiBpcyByZXR1cm5lZCB3aXRob3V0IG1vZGlmaWNhdGlvbnMuXG4gKiBAcGFyYW0gdGV4dFxuICogQHBhcmFtIHBhcnRJZFxuICogQHJldHVybnMge251bGx8Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQYXJ0KHRleHQsIHBhcnRJZCkge1xuICAgIGlmIChwYXJ0SWQgPT09IFwiXCIgfHwgcGFydElkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdGV4dC5zcGxpdChERUZBVUxUX1NFQ1RJT05fUEFUVEVSTik7XG4gICAgZm9yIChsZXQgaT0yOyBpIDwgcGFydHMubGVuZ3RoOyBpKz0zKSB7XG4gICAgICAgIC8qIC8vIFVubmVjZXNzYXJ5IGFzc2VydGlvbiwgYnV0IG5vdCBiYWQgdG8gdGhpbmsgYWJvdXRcbiAgICAgICAgaWYgKCFwYXJ0c1tpLTFdLnN0YXJ0c1dpdGgoXCIjIyMjIFBhcnQgXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkVycm9yOiBwYXJ0IGZvcm1hdCBpcyBicm9rZW4hXCI7XG4gICAgICAgIH0qL1xuICAgICAgICBpZiAocGFydHNbaV0gPT09IHBhcnRJZCkge1xuICAgICAgICAgICAgbGV0IGJvZHkgPSBwYXJ0c1tpKzFdO1xuICAgICAgICAgICAgaWYgKGJvZHkgJiYgYm9keVswXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IHBhcnRzLmxlbmd0aCAtIDMgJiYgYm9keSAmJiBib2R5LnNsaWNlKC0xKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFNob3VsZCB0aGVvcmV0aWNhbGx5IGJlbG9uZyBpbiBTay5mZmksIGJ1dCBJIHB1dCBpdCBoZXJlIGluc3RlYWQgdG8gbm90IG1lc3MgdXAgdGhlIHNrdWxwdCBmaWxlc1xuICogbGlrZSB0aGUgbm9ybWFsIFNrLmZmaS5yZW1hcFRvUHksIGl0IGRvZXNuJ3Qgd29yayBmb3IgZnVuY3Rpb25zIG9yIG1vcmUgY29tcGxleCBvYmplY3RzLCBidXQgaXQgaGFuZGxlc1xuICogY2FzZXMgd2hlcmUgdGhlIHR5cGVzIGluIG9iaiBhcmUgYSBtaXggb2YgcHl0aG9uIFNJTVBMRSBvYmplY3RzIGFuZCBTSU1QTEUgbm9ybWFsIGphdmFzY3JpcHQgb2JqZWN0c1xuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtTay5idWlsdGluLj8/P30gLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHB5dGhvbiBvYmplY3QsIGRyb3BwaW5nIGFsbCBmdW5jdGlvbnMgYW5kIHRoaW5ncyBpdCBjYW4ndCBjb252ZXJ0XG4qKi9cbmZ1bmN0aW9uIG1peGVkUmVtYXBUb1B5KG9iail7XG4gICAgdmFyIGs7XG4gICAgdmFyIGt2cztcbiAgICB2YXIgaTtcbiAgICB2YXIgYXJyO1xuICAgIC8vQFRPRE86IHNob3VsZCB0aGVvcmV0aWNhbGx5IGNoZWNrIGlmIHRoZSBvYmplY3QgaXMgYSBweWhvbiBkaWN0IG9yIGFycmF5IHdpdGgganMgb2JqZWN0c1xuICAgIGlmIChpc1NrQnVpbHRpbihvYmopKXtcbiAgICAgICAgLy9vYmplY3QgaXMgYWxyZWFkeSBweXRob24gcmVhZHlcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgLy9vYmplY3QgaXMgYWN0dWFsbHkgYSBqYXZhc2NyaXB0IGFycmF5XG4gICAgICAgIGFyciA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvL2ZvciBlYWNoIG9iamVjdCwgY29udmVydCBpdCB0byBhIHB5dGhvbiBvYmplY3QgaWYgaXQgaXNuJ3Qgb25lIGFscmVhZHlcbiAgICAgICAgICAgIHZhciBzdWJ2YWwgPSBvYmpbaV07XG4gICAgICAgICAgICBpZighaXNTa0J1aWx0aW4oc3VidmFsKSl7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobWl4ZWRSZW1hcFRvUHkoc3VidmFsKSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChzdWJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGFycik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHsvL251bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmKCFpc1NrQnVpbHRpbihvYmopKXtcbiAgICAgICAgICAgIC8vYXNzdW1pbmcgaXQncyBhIHN0YW5kYXJkIGRpY3Rpb25hcnlcbiAgICAgICAgICAgIGt2cyA9IFtdOy8vU2suYnVpbHRpbi5kaWN0IHVzZXMgYW4gYXJyYXkgb2Yga2V5LXZhbHVlLGtleS12YWx1ZS4uLlxuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCB0aGUga2V5IGlmIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuICAgICAgICAgICAgICAgIGt2cy5wdXNoKG1peGVkUmVtYXBUb1B5KGspKTtcbiAgICAgICAgICAgICAgICAvL2NvdmVydCBjb3JyZXNwb25kaW5nIHZhbHVlIGlmIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuICAgICAgICAgICAgICAgIGt2cy5wdXNoKG1peGVkUmVtYXBUb1B5KG9ialtrXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jcmVhdGUgdGhlIG5ldyBkaWN0aW9uYXJ5XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChrdnMpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihvYmopO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5hc3NrJChvYmopO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2wob2JqKTtcbiAgICB9IGVsc2UgaWYodHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIob2JqLm5hbWUpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBoID0gTWF0aC5mbG9vcih0b2RheS5nZXRIb3VycygpJTEyKTtcbiAgICBsZXQgbSA9IHRvZGF5LmdldE1pbnV0ZXMoKTtcbiAgICAvL2xldCBzID0gdG9kYXkuZ2V0U2Vjb25kcygpO1xuICAgIGlmIChtIDwgMTApIHttID0gXCIwXCIgKyBtO31cbiAgICAvL2lmIChzIDwgMTApIHtzID0gXCIwXCIgKyBzO31cbiAgICBsZXQgcCA9IFwiYW1cIjtcbiAgICBpZiAodG9kYXkuZ2V0SG91cnMoKT49MTIpIHtcbiAgICAgICAgcCA9IFwicG1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke2h9OiR7bX0ke3B9YDtcbn1cblxuZXhwb3J0IGNvbnN0IHB5SW50ID0gU2suYnVpbHRpbi5pbnRfO1xuZXhwb3J0IGNvbnN0IHB5Tm9uZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbmV4cG9ydCBjb25zdCBweVN0ciA9IFNrLmJ1aWx0aW4uc3RyO1xuZXhwb3J0IGNvbnN0IHB5VHVwbGUgPSBTay5idWlsdGluLnR1cGxlO1xuZXhwb3J0IGNvbnN0IHB5Q2FsbE9yU3VzcGVuZCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheTtcblxuZXhwb3J0IGNvbnN0IHsgaXNUcnVlLCByaWNoQ29tcGFyZUJvb2wsIGNoYWluIH0gPSBTay5taXNjZXZhbDtcbmV4cG9ydCBjb25zdCB7IHR5cGVOYW1lLCBzZXRVcE1vZHVsZU1ldGhvZHMsIGJ1aWxkTmF0aXZlQ2xhc3MgfSA9IFNrLmFic3RyO1xuZXhwb3J0IGNvbnN0IHsgVHlwZUVycm9yLCBWYWx1ZUVycm9yLCBLZXlFcnJvciwgSW5kZXhFcnJvciwgY2hlY2tTdHJpbmcsIGFzbnVtJCB9ID0gU2suYnVpbHRpbjtcbmV4cG9ydCBjb25zdCB7IHJlbWFwVG9QeSwgcmVtYXBUb0pzIH0gPSBTay5mZmk7XG5leHBvcnQgY29uc3QgeyBnZXRBdHRyLCBzZXRBdHRyIH0gPSBTay5nZW5lcmljO1xuZXhwb3J0IGNvbnN0IGNoYWluT3JTdXNwZW5kID0gY2hhaW47IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2ZpbGVwb25kX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fOyJdLCJzb3VyY2VSb290IjoiIn0=