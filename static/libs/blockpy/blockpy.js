(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var skulpt_modules_weakref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! skulpt_modules/weakref */ "./src/skulpt_modules/weakref.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */




 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_5__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration; //console.log(configuration, configuration["submission.code"], configuration["partId"], extractPart(configuration["submission.code"] || "", configuration["partId"]));

      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray(Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(configuration["assignment.extra_instructor_files"]) || []),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(configuration["submission.code"] || "", configuration["partId"]) || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_7__["DisplayModes"].TEXT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK),
          previousSecondRowSecondPanel: ko.observable(null),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),

          /**
           * Whether or not images should be rendered (true), or just stay as text code (false).
           */
          renderImages: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true"),

          /**
           * Uploaded files are ones that have been listed by the remote
           */
          uploadedFiles: ko.observable(null),

          /**
           * Backup copy of the latest known full code for the Submission. This is relevant if there was a
           * PartID specified, in which case the submission.code in the model is only showing what we know
           * locally.
           */
          backupSubmissionCode: ko.observable(configuration["submission.code"] || "")
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          listUploadedFiles: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          listUploadedFilesMessage: ko.observable(""),
          // @type {ServerStatus}
          downloadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          downloadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          uploadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          uploadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {},

          /**
           * Unique Part ID that can distinguish this editor instance's region of the assignment.
           * It's possible that other editors may be attached to a different Part of the same assignmnet, on the
           * same page.
           * **/
          partId: ko.observable(configuration["partId"] || "")
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.display.backupSubmissionCode(submission.code);
      this.model.submission.code(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["extractPart"])(submission.code, this.model.configuration.partId()) || "");
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.submissionStatus(submission.submission_status || _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SubmissionStatuses"].UNKNOWN);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.debug(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        smallLayout: ko.pureComputed(function () {
          return !model.display.instructor() && model.assignment.settings.smallLayout();
        }),
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.onlyInteractive();
          }),
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          toggleImages: function toggleImages() {
            if (model.display.renderImages()) {
              self.components.pythonEditor.bm.textEditor.disableImages();
            } else {
              self.components.pythonEditor.bm.textEditor.enableImages();
            }

            model.display.renderImages(!model.display.renderImages());
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          }),
          showClock: ko.pureComputed(function () {
            return !model.assignment.settings.hasClock();
          })
        },
        secondRow: {
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-5";
          }),
          hideTraceButton: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideTraceButton();
          }),
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            }
          },
          makeWide: function makeWide() {
            var currentPanel = model.display.secondRowSecondPanel;
            model.display.previousSecondRowSecondPanel(currentPanel());
            currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
          },
          restorePanel: function restorePanel() {
            var oldPanel = model.display.previousSecondRowSecondPanel;

            if (oldPanel() !== null) {
              model.display.secondRowSecondPanel(oldPanel());
              oldPanel(null);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.smallLayout() || model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          }),
          resetScore: function resetScore() {
            model.submission.score(0);
            model.submission.correct(false);
            self.components.server.updateSubmission(model.submission.score(), model.submission.correct(), true, true);
          }
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          highlightedLine: ko.pureComputed(function () {
            if (model.display.secondRowSecondPanel() !== interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              return [];
            }

            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return [];
            } else if (step === 0) {
              return [];
            } else {
              return [traceData[step - 1].line];
            }
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + traceData[step - 1].line;
            }
          }),
          ast: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return "Starting execution";

              case lastStep:
                return "Finished execution";

              default:
                return "Current step: " + _trace__WEBPACK_IMPORTED_MODULE_13__["AST_DESCRIPTIONS"][traceData[step - 1].ast];
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-6";
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?images.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?images.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?images.blockpy":
                self.components.fileSystem.newFile(path, "{}");
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          rename: function rename(newName) {
            return self.components.fileSystem.renameFile(model.display.filename(), newName);
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?images.blockpy") {
              return "Images";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-7";
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && (model.assignment.settings.hideEditors() || model.assignment.settings.onlyInteractive()) ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_10__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          images: {
            reloadImages: function reloadImages() {
              return self.components.editors.byName("image").reloadImages();
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          }),
          runLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run";
          }),
          run: function run() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun();
            }
          },
          runQuietlyLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run without feedback";
          }),
          runQuietly: function runQuietly() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun(true);
            }
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        },
        footer: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.ui.smallLayout();
          })
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/weakref.js"] = weakrefModule.toString();
      //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_16__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_15__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_13__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_14__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_12__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_10__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_6__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_8__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_18__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_19__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
      this.clock = null;
      var container = this.model.configuration.container;

      var updateClock = function updateClock() {
        return container.find(".blockpy-menu-clock").text(Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["getCurrentTime"])());
      };

      if (this.model.ui.menu.showClock()) {
        this.clock = setInterval(updateClock, 1000);
      }

      this.model.ui.menu.showClock.subscribe(function (changed) {
        if (_this2.model.ui.menu.showClock()) {
          if (_this2.clock) {
            clearInterval(_this2.clock);
            _this2.clock = null;
          }
        } else {
          if (!_this2.clock) {
            _this2.clock = setInterval(updateClock, 1000);
          }
        }
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.offset().top; //$('html').scrollTop(top);

        $("html").scrollTop(top); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.offset().top;
        $("html").scrollTop(top);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};

      this.main.model.ui.secondRow.restorePanel();
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();
      console.log(inputIndex, this.main.model.execution.input().length);

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "handlePygameResize",
    value: function handlePygameResize(newWidth, newHeight) {
      // If the user hasn't changed the console size, and the newHeight is bigger than default, we'll change it
      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height() && newHeight > this.DEFAULT_HEIGHT) {
        this.printerTag.height(30 + newHeight);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      } // If the pygame window is wider than the console, we'll expand temporarily.


      if (newWidth > this.printerTag.width()) {
        this.main.model.ui.secondRow.makeWide();
      }
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else if (this.pygameLine) {
          var _canvas = this.pygameLine.canvas;

          var _dataUrl = _canvas.toDataURL("image/png");

          this.main.components.server.saveImage("turtle_output", _dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_LISTING_UPLOADED_FILES = function (reason) {
  this.show("Error Listing Uploaded Files", "BlockPy encountered an error while listing the uploaded files.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_UPLOADING_FILE = function (reason) {
  this.show("Error Uploaded File", "BlockPy encountered an error while uploading the file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["partId", "part_id", "", "string", "The Part ID of an Assignment that this editor is responsible for. Assignments can have regions (\"Parts\") that behave independently to the user but all correspond to the same assignment on the backend. Blank corresponds to the full document. Note that most assignment settings will apply UNIVERSALLY across all parts, including the on_run.py and the other settings on this page."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle (and pygame) output is saved whenever the program uses it."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["hideTraceButton", "hide_trace_button", false, "bool", "If checked, then the Trace button is not shown."], ["smallLayout", "small_layout", false, "bool", "If checked, then the interface fits into a smaller region."], ["hasClock", "has_clock", false, "bool", "If checked, then a clock is shown in the top right corner."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-part-id\" class=\"col-sm-2 col-form-label text-right\">Part ID:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-part-id\"\n                data-bind=\"value: configuration.partId\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("partId"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/images.js":
/*!******************************!*\
  !*** ./src/editor/images.js ***!
  \******************************/
/*! exports provided: IMAGE_EDITOR_HTML, ImageEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_EDITOR_HTML", function() { return IMAGE_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageEditor", function() { return ImageEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var IMAGE_EDITOR_HTML = "\n     <div>\n        <h3>Available Images</h3>\n        \n        <button data-bind=\"click: ui.editors.images.reloadImages\">Reload Available Images</button>\n        <!-- ko if: display.uploadedFiles() !== null -->\n            <ul>\n                <!-- ko foreach: { data: Object.keys(display.uploadedFiles()), as: 'placement' } -->\n                <li>\n                    <strong data-bind=\"text: $data\"></strong>:\n                    <ul>\n                    <!-- ko foreach: { data: $root.display.uploadedFiles()[placement], as: 'filename' } -->\n                        <li>\n                            <span data-bind=\"text: filename[0]\"></span>:\n                            <img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                width=\"30px\" height=\"30px\"/>\n                        </li>\n                    <!-- /ko -->\n                    </ul>\n                </li>\n                <!-- /ko -->\n            </ul>\n        <!-- /ko -->\n    </div>\n";

var ImageEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ImageEditorView, _AbstractEditor);

  var _super = _createSuper(ImageEditorView);

  function ImageEditorView(main, tag) {
    _classCallCheck(this, ImageEditorView);

    return _super.call(this, main, tag);
  }

  _createClass(ImageEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ImageEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      var uploadedFiles = this.main.model.display.uploadedFiles();

      if (uploadedFiles === null) {
        this.reloadImages();
      }

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      /*
      this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
        // Notify relevant file of changes to BM
      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);*/
    }
  }, {
    key: "reloadImages",
    value: function reloadImages() {
      var _this = this;

      this.main.components.server.listUploadedFiles(function (response) {
        if (response.success) {
          _this.main.model.display.uploadedFiles(response.files);
        } else {
          _this.main.components.dialogs.ERROR_LISTING_UPLOADED_FILES(response.message);
        }
      });
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {}
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      /*this.dirty = !this.dirty;
      if (this.dirty) {
          this.dirty = true;
          this.file.handle(this.codeMirror.getValue());
          this.dirty = false;
      }*/
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();

      _get(_getPrototypeOf(ImageEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ImageEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ImageEditor = {
  name: "Image",
  extensions: ["?images.blockpy"],
  constructor: ImageEditorView,
  template: IMAGE_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface */ "./src/interface.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */



var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> <span data-bind=\"text: ui.execute.runLabel\"></span>\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() && !ui.smallLayout()-->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\" data-bind=\"hidden: ui.smallLayout\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\" data-bind=\"hidden: ui.smallLayout\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\">\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"fas fa-ellipsis-v\"></span>\n                    <span class=\"sr-only\">Toggle Extra Features</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-run-quietly notransition' role=\"button\"\n                        href=\"\"\n                        data-bind=\"click: ui.execute.runQuietly,\n                                    css: {'blockpy-run-running': ui.execute.isRunning}\">\n                        <span class=\"fas fa-comment-slash\"></span> <span data-bind=\"text: ui.execute.runQuietlyLabel\"></span>\n                    </a>\n                </div>\n            </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHook: function imageDownloadHook(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        //const uuid = window.URL.createObjectURL(new Blob([])).substring(31);
        return new Promise(function (resolve, reject) {
          var submissionId = main.model.submission.id();
          main.components.server.uploadFile("submission", submissionId, blob.name, blob, function (response) {
            resolve(JSON.stringify(response.endpoint)); //resolve(JSON.stringify(main.model.configuration.urls["downloadFile"] + `?placement=submission&directory=${submissionId}&filename=${blob.name}`));
          }); //return Promise.resolve("Image("+JSON.stringify(URL.createObjectURL(blob))+")");
          //return Promise.resolve(JSON.stringify(URL.createObjectURL(blob)));
        });
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        //return `Image("${oldUrl}")`;
        return "\"".concat(oldUrl, "\"");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.lineTraceSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
        this.lineTraceSubscription = this.main.model.ui.trace.highlightedLine.subscribe(function (lines) {
          _this3.bm.clearHighlightedLines("editor-traced-line");

          _this3.bm.setHighlightedLines(lines, "editor-traced-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }

      if (this.lineTraceSubscription) {
        this.lineTraceSubscription.dispose();
        this.lineTraceSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      }); // Small Layout Stuff

      this.oldHeight = null;

      if (this.main.model.ui.smallLayout()) {
        this.useSmallLayout();
      }

      this.main.model.ui.smallLayout.subscribe(function (useSmallLayout) {
        if (useSmallLayout) {
          _this4.useSmallLayout();
        } else if (_this4.oldHeight !== null) {
          _this4.bm.configuration.height = _this4.oldHeight;

          _this4.bm.textEditor.resizeResponsively();

          _this4.oldHeight = null;
        }
      });
    }
  }, {
    key: "useSmallLayout",
    value: function useSmallLayout() {
      this.bm.textEditor.updateGutter({
        indentSidebar: false
      });
      this.oldHeight = this.bm.configuration.height;
      this.bm.configuration.height = 300; // TODO: Parameterize this

      this.bm.textEditor.resizeResponsively();
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.configuration.partId.subscribe(function (changed) {// TODO: Handle part id changing after everything is loaded
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py", ".reading"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
/* harmony import */ var _editor_images__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./editor/images */ "./src/editor/images.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */










/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"], _editor_images__WEBPACK_IMPORTED_MODULE_9__["ImageEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "', class: ui.editors.width\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      var disableFeedback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(disableFeedback); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var disableFeedback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback() && !disableFeedback) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          _this2.configuration.provideSecretError();

          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // TODO: Make this set by the system so we can use our own servers in practice
        emojiProxy: function emojiProxy(part) {
          return "https://twemoji.maxcdn.com/v/13.1.0/svg/".concat(part.toLowerCase(), ".svg");
        },
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../files */ "./src/files.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found, but not __main__ modules

      this.sysmodules = this.clearExistingStudentImports(); // Horrific hack, to prevent Tifa from caching a bad version of the students' import

      Sk.clearExistingStudentImports = this.clearExistingStudentImports;
      return this;
    }
  }, {
    key: "print",
    value: function print(value) {
      _get(_getPrototypeOf(InstructorConfiguration.prototype), "print", this).call(this, value);

      console.info("Printed:", value);
    }
  }, {
    key: "clearExistingStudentImports",
    value: function clearExistingStudentImports() {
      var sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      if (sysmodules !== undefined) {
        var _iterator = _createForOfIteratorHelper(this.getAllFilenames()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var filename = _step.value;
            var skFilename = new Sk.builtin.str(filename);
            /*if (sysmodules.quick$lookup(skFilename)) {
                sysmodules.pop$item(skFilename);
            }*/

            sysmodules.pop$item(skFilename);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return sysmodules;
    }
  }, {
    key: "getAllStudentFiles",
    value: function getAllStudentFiles() {
      var files = {
        "answer.py": this.main.model.ui.files.getStudentCode()
      }; // Skip special instructor files

      this.main.model.assignment.extraInstructorFiles().forEach(function (file) {
        if (!"!^$#".includes(file.filename()[0])) {
          files[file.filename()] = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(file.contents());
        }
      }); // Include normal student extra files

      this.main.model.submission.extraFiles().forEach(function (file) {
        files[file.filename()] = file.contents();
      });
      return files;
    }
  }, {
    key: "getAllFilenames",
    value: function getAllFilenames() {
      function clean(filename) {
        filename = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(filename);

        if (filename.endsWith(".py")) {
          filename = filename.slice(0, -3);
        }

        return filename;
      }

      return ["__main__", "_instructor"].concat(_toConsumableArray(this.main.model.assignment.extraInstructorFiles().map(function (file) {
        return "_instructor." + clean(file.filename());
      })), _toConsumableArray(this.main.model.submission.extraFiles().map(function (file) {
        return clean(file.filename());
      })));
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      console.log(">>>", this.main.model.execution.input(), this.main.model.execution.inputIndex());

      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\n# MAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, "['evaluation'])\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(_on_run__WEBPACK_IMPORTED_MODULE_2__["INSTRUCTOR_MARKER"], "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";

      var studentFiles = this.getAllStudentFiles();
      studentFiles["evaluation"] = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      console.log(">>>", instructorCode);
      var lineOffset = Object(_on_run__WEBPACK_IMPORTED_MODULE_2__["findActualInstructorOffset"])(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: findActualInstructorOffset, INSTRUCTOR_MARKER, NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findActualInstructorOffset", function() { return findActualInstructorOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSTRUCTOR_MARKER", function() { return INSTRUCTOR_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function findActualInstructorOffset(instructorCode) {
  var index = instructorCode.indexOf(INSTRUCTOR_MARKER);
  var before = instructorCode.slice(0, index);
  var match = before.match(NEW_LINE_REGEX);
  return match ? 1 + match.length : 0;
}
var INSTRUCTOR_MARKER = "###Run the actual instructor code###";
var NEW_LINE_REGEX = /\n/g;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentFiles);
  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom bakery import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          files=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(INSTRUCTOR_MARKER, "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa(); // Put the input index back to the front, so we can replay inputs

      this.main.model.execution.inputIndex(1);
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentFiles = this.getAllStudentFiles();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      var lineOffset = findActualInstructorOffset(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;
      //lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode();

      if (this.main.model.assignment.settings.disableStudentRun()) {
        this.code = "";
      } //this.code = this.main.model.submission.code();


      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };

      if (typeof Sk.environ == "undefined") {
        Sk.environ = new Sk.builtin.dict();
      }

      var printerTag = this.main.components.console.printerTag,
          width = printerTag.width() - 50,
          height = Math.max(300, printerTag.height() - 50);
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_WIDTH"), new Sk.builtin.int_(width));
      Sk.environ.set$item(new Sk.builtin.str("DESIGNER_WINDOW_HEIGHT"), new Sk.builtin.int_(height));
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        if (Sk.builtinFiles && Sk.builtinFiles["files"][filename] !== undefined) {
          return Sk.builtinFiles["files"][filename];
        } else {
          throw new Sk.builtin.OSError("File not found: " + filename);
        }
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring, astName) {
      if (filename === "answer.py") {
        /*if (execStack) {
            console.log(execStack.map(([n, o]) => [n, {...o}]));
        }*/
        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(_objectSpread(_objectSpread({}, globals), locals)); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring,
          "ast": astName
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear("Execution finished. No errors to report.");
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\"\n            data-bind=\"class: ui.console.size\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <!-- ko ifnot: ui.secondRow.hideTraceButton -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    <!-- /ko -->\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n        <small data-bind=\"click: ui.feedback.resetScore,\n                          visible: display.instructor() && execution.feedback.label() && submission.score() > 0\"\n            class=\"text-muted\" style=\"cursor: pointer\"><u>(reset)</u></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 700);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Ready";
      this.feedbackModel.message(message);
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);

        if (this.shouldScrollIntoView()) {
          this.scrollIntoView();
        }
      }
    }
  }, {
    key: "shouldScrollIntoView",
    value: function shouldScrollIntoView() {
      return !this.main.model.ui.smallLayout();
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this4 = this;

      return error.traceback.map(function (frame) {
        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, chompSpecialFile, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chompSpecialFile", function() { return chompSpecialFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible, class: ui.files.width\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?images.blockpy'),\n                           click: ui.files.add.bind($data, '?images.blockpy')\">Images</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
function chompSpecialFile(filename) {
  if ("!^?&$*#".includes(filename[0])) {
    return filename.slice(1);
  } else {
    return filename;
  }
}
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(filename, _contents) {
  return {
    filename: function (_filename) {
      function filename() {
        return _filename.apply(this, arguments);
      }

      filename.toString = function () {
        return _filename.toString();
      };

      return filename;
    }(function () {
      return filename;
    }),
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var _filename2 in files) {
      if (files.hasOwnProperty(_filename2)) {
        modelFiles.push(makeModelFile(_filename2, files[_filename2]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    if (modelFileList) {
      modelFileList(modelFiles);
    } else {
      return modelFiles;
    }
  } else {
    if (modelFileList) {
      modelFileList([]);
    } else {
      return [];
    }
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    console.log(main.model.configuration.container.find(".blockpy-file-instructor"), this.main.model.display.instructor(), main, this);
    main.model.configuration.container.find(".blockpy-file-instructor").toggle(this.main.model.display.instructor());
    this.main.model.display.instructor.subscribe(function (visiblity) {
      main.model.configuration.container.find(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "renameFile",
    value: function renameFile(source, destination) {
      if (UNRENAMABLE_FILES.indexOf(source) !== -1) {
        return false;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(hiddenVersion, defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row' data-bind=\"hidden: ui.smallLayout()\">\n         \n         <!-- Description -->\n         <div class='col-md-9 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-3 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <!-- Fullscreen button -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\">\n                <span class='fas' data-bind=\"class: ui.menu.textFullscreen\"></span>\n            </button>\n            <!-- Edit Queued Inputs -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\">\n                <span class='fas fa-list-alt'></span>\n            </button>\n            <!-- Toggle Image Rendering -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-toggle=\"button\"\n                data-bind=\"click: ui.menu.toggleImages\" title=\"Toggle Images\">\n                <span class=\"fas fa-images\"></span>\n            </button>\n            <!-- Pink Bug for actual errors -->\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n            <span data-bind=\"hidden: ui.menu.showClock\" class=\"blockpy-menu-clock\"></span>\n        </div>\n         \n    </div>\n    \n    <!-- ko if: ui.smallLayout() -->\n    <!-- Small layout View as instructor -->\n    <div class=\"form-check\"\n         data-bind=\"visible: ui.role.isGrader\">\n        <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n            data-bind=\"checked: display.instructor\">\n        <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n            View as instructor\n        </label>\n    </div>\n    <!-- ko if: ui.files.visible() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    <!-- /ko -->\n    \n    <div class='row'>\n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div data-bind=\"class: ui.secondRow.width\">\n    <div class='row'>\n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n    </div>\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible() && !ui.smallLayout() -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    \n    </div>\n    \n    \n    <!-- Row 5: Footer Row -->    \n    <!-- ko if: ui.footer.visible -->\n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var configuration = this.main.model.configuration;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode(),
    "part_id": configuration.partId()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  var extraSettings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  this.showOverlay(attempts);
  return $.ajax(_objectSpread({
    type: "POST",
    url: this.urls[endpoint],
    data: data
  }, extraSettings)).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.listUploadedFiles = function (callback) {
  var _this10 = this;

  if (this.main.model.ui.server.isEndpointConnected("listUploadedFiles")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("listUploadedFiles", data, 2, callback, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_LISTING_UPLOADED_FILES(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.uploadFile = function (placement, directory, filename, contents, callback) {
  var _this11 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("uploadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    data["contents"] = contents;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("uploadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this11.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this12 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this12.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this12.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this13 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this13._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this13.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this13.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  mod.clear_existing_student_imports = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    Sk.clearExistingStudentImports();
  });
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/weakref.js":
/*!***************************************!*\
  !*** ./src/skulpt_modules/weakref.js ***!
  \***************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "weakref"
  };
  /*mod.WeakSet = Sk.abstr.buildNativeClass("weakref.WeakSet", {
      constructor: function WeakSet()
  });*/

  var WeakSet = function WeakSet($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, data) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("data", "iterable", Sk.builtin.checkIterable(data));
      self.data = [];
      var iter = Sk.abstr.iter(data);
      var next;

      do {
        next = Sk.abstr.iternext(iter);

        if (next !== undefined) {
          self.data.push(new WeakRef(next));
        }
      } while (next !== undefined);

      return Sk.builtin.none.none$;
    });
    $loc.__iter__ = new Sk.builtin.func(function (self) {
      var viewOfData = [];

      for (var i = 0; i < self.data.length; i++) {
        var item = self.data[i].deref();

        if (item !== undefined) {
          viewOfData.push(item);
        }
      }

      self.data = viewOfData;
      return Sk.abstr.iter(new Sk.builtin.list(viewOfData));
    });
    /*$loc.next$ = new Sk.builtin.func(function (self) {
        return self.tp$iter();
    });*/

    $loc.add = new Sk.builtin.func(function (self, item) {
      self.data.push(new WeakRef(item));
    });
  };

  mod.WeakSet = Sk.misceval.buildClass(mod, WeakSet, "WeakSet", []);
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, AST_DESCRIPTIONS, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AST_DESCRIPTIONS", function() { return AST_DESCRIPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    <p data-bind=\"text: ui.trace.ast\"></p>\n    <p>Variables after this step:</p>\n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var AST_DESCRIPTIONS = {
  "Add": "An addition operator",
  "And": "A boolean AND operator",
  "AnnAssign": "An annotated assignment",
  "Assert": "An assert statement",
  "Assign": "An assignment statement",
  "AsyncFor": "An asychronous for loop",
  "AsyncFunctionDef": "An asychronous function definition",
  "AsyncWith": "An asychronous with statement",
  "Attribute": "An attribute lookup (access a field)",
  "AugAssign": "An augmented assignment",
  "AugLoad": "An augmented load",
  "AugStore": "An augmented store",
  "Await": "An await statement",
  "BinOp": "A binary operator",
  "BitAnd": "A bitwise AND operator",
  "BitOr": "A bitwise OR operator",
  "BitXor": "A bitwise XOR operator",
  "BoolOp": "A boolean operator",
  "Break": "A break statement",
  "Bytes": "A literal bytes string",
  "Call": "A function call",
  "ClassDef": "A class definition",
  "Compare": "A boolean comparison",
  "Constant": "A literal value",
  "Continue": "A continue statement",
  "Del": "A delete statement",
  "Delete": "A deletion",
  "Dict": "A dictionary literal",
  "DictComp": "A dictionary comprehension",
  "Div": "A division operator",
  "Ellipsis": "An ellipsis",
  "Eq": "An equality comparison operator",
  "ExceptHandler": "An except handler",
  "Expr": "An expression used as a statement",
  "Expression": "An evaluated expression",
  "ExtSlice": "A multi-dimensional slice",
  "FloorDiv": "An integer division operator",
  "For": "A FOR loop",
  "FormattedValue": "A formatted value in an f-string",
  "FunctionDef": "A function definition",
  "GeneratorExp": "A generator expression",
  "Global": "A global statement",
  "Gt": "A greater than comparison operator",
  "GtE": "A greater than or equal to comparison operator",
  "If": "An IF statement",
  "IfExp": "An IF expression",
  "Import": "An import statement",
  "ImportFrom": "An import/from statement",
  "In": "An IN operator",
  "Index": "An index",
  "Interactive": "An interactive expression",
  "Invert": "An invert operator",
  "Is": "An IS operator",
  "IsNot": "An IS NOT operator",
  "JoinedStr": "An f-string",
  "LShift": "A left shift operator",
  "Lambda": "A lambda expression",
  "List": "A list literal",
  "ListComp": "A list comprehension",
  "Load": "A load",
  "Lt": "A less than comparison operator",
  "LtE": "A less than or equal to comparison operator",
  "MatMult": "A matrix multiplication operator",
  "Mod": "A modulo operator",
  "Module": "A module",
  "Mult": "A multiplication operator",
  "Name": "A name",
  "NameConstant": "A name constant",
  "Nonlocal": "A nonlocal statement",
  "Not": "A not operator",
  "NotEq": "A not equal to comparison operator",
  "NotIn": "A NOT IN operator",
  "Num": "A numeric literal",
  "Or": "A boolean OR operator",
  "Param": "A parameter",
  "Pass": "A pass statement",
  "Pow": "A power operator",
  "RShift": "A right shift operator",
  "Raise": "A raise statement",
  "Return": "A return statement",
  "Set": "A set literal",
  "SetComp": "A set comprehension",
  "Slice": "A slice",
  "Starred": "A starred argument",
  "Store": "A store",
  "Str": "A string literal",
  "Sub": "A subtraction operator",
  "Subscript": "A subscript",
  "Suite": "A suite",
  "Try": "A try statement",
  "Tuple": "A tuple literal",
  "TypeIgnore": " a type ignore",
  "UAdd": "A unary addition operator",
  "USub": "A unary subtraction operator",
  "UnaryOp": "A unary operator",
  "While": "A while loop",
  "With": "A with statement",
  "Yield": "A yield statement",
  "YieldFrom": "A yield/from statement"
};
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod", "$free", "$cell"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = []; //console.log(variables);

      if (!this.main.model.display.traceExecution()) {
        /*if ("$cell" in variables) {
            variables = {...variables, ...variables.$cell};
        }*/

        /*if ("$free" in variables) {
            variables = {...variables, ...variables.$free};
        }*/
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1 && value !== undefined) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (property) {
        case "dataclass":
          return {
            name: property,
            type: "Decorator",
            value: "<dataclass decorator>"
          };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Parameters: " + value.func_code.co_varnames.join(", ") : " No parameters"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue, extractPart, getCurrentTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractPart", function() { return extractPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentTime", function() { return getCurrentTime; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}

var DEFAULT_SECTION_PATTERN = /^(##### Part (.+))$/gm;
/**
 * Finds the given Part ID using the pattern `#### Part whatever` (on its own separate line). If the pattern
 * is not found, then null is returned. If no pattern is given (empty string or null), then the original text
 * is returned without modifications.
 * @param text
 * @param partId
 * @returns {null|*}
 */

function extractPart(text, partId) {
  if (partId === "" || partId == null) {
    return text;
  }

  var parts = text.split(DEFAULT_SECTION_PATTERN);

  for (var i = 2; i < parts.length; i += 3) {
    /* // Unnecessary assertion, but not bad to think about
    if (!parts[i-1].startsWith("#### Part ")) {
        throw "Error: part format is broken!";
    }*/
    if (parts[i] === partId) {
      var body = parts[i + 1];

      if (body && body[0] === "\n") {
        body = body.slice(1);
      }

      if (i !== parts.length - 3 && body && body.slice(-1) === "\n") {
        body = body.slice(0, -1);
      }

      return body;
    }
  }

  return null;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/

function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

function getCurrentTime() {
  var today = new Date();
  var h = Math.floor(today.getHours() % 12);
  var m = today.getMinutes(); //let s = today.getSeconds();

  if (m < 10) {
    m = "0" + m;
  } //if (s < 10) {s = "0" + s;}


  var p = "am";

  if (today.getHours() >= 12) {
    p = "pm";
  }

  return "".concat(h, ":").concat(m).concat(p);
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9qc29uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL21hcmtkb3duLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3B5dGhvbi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9xdWl6LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy93ZWFrcmVmLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3RyYWNlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwia29cIiJdLCJuYW1lcyI6WyJFRElUT1JfVkVSU0lPTiIsIkJsb2NrUHkiLCJjb25maWd1cmF0aW9uIiwiYXNzaWdubWVudCIsInN1Ym1pc3Npb24iLCJpbml0TW9kZWwiLCJ1bmRlZmluZWQiLCJzZXRBc3NpZ25tZW50IiwiaW5pdE1haW4iLCJpbml0VXRpbGl0aWVzIiwiaW5pdE1vZGVsTWV0aG9kcyIsInR1cm5PbkhhY2tzIiwiaW5pdEludGVyZmFjZSIsImFwcGx5TW9kZWwiLCJpbml0Q29tcG9uZW50cyIsIm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMiLCJzdGFydCIsImtleSIsImRlZmF1bHRWYWx1ZSIsImluaXRpYWxDb25maWd1cmF0aW9uXyIsImxvY2FsU2V0dGluZ3NfIiwiaGFzIiwiZ2V0IiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsIm1vZGVsIiwidXNlciIsImlkIiwia28iLCJvYnNlcnZhYmxlIiwibmFtZSIsInJvbGUiLCJnZXRTZXR0aW5nIiwiY291cnNlSWQiLCJncm91cElkIiwiaW5zdHJ1Y3Rpb25zIiwidXJsIiwidHlwZSIsIkFzc2lnbWVudFR5cGUiLCJCTE9DS1BZIiwicG9pbnRzIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYVN0YXJ0aW5nRmlsZXMiLCJmb3JrZWRJZCIsImZvcmtlZFZlcnNpb24iLCJvd25lcklkIiwidmVyc2lvbiIsInRhZ3MiLCJzYW1wbGVTdWJtaXNzaW9ucyIsInJldmlld2VkIiwiaGlkZGVuIiwiaXBSYW5nZXMiLCJzZXR0aW5ncyIsIm1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbCIsImNvZGUiLCJleHRyYWN0UGFydCIsImV4dHJhRmlsZXMiLCJlbmRwb2ludCIsInNjb3JlIiwiY29ycmVjdCIsInN1Ym1pc3Npb25TdGF0dXMiLCJncmFkaW5nU3RhdHVzIiwiZGlzcGxheSIsImZpbGVuYW1lIiwiaW5zdHJ1Y3RvciIsIm11dGVQcmludGVyIiwicHl0aG9uTW9kZSIsIkRpc3BsYXlNb2RlcyIsIlRFWFQiLCJoaXN0b3J5TW9kZSIsImF1dG9TYXZlIiwiYmlnQ29uc29sZSIsInByZXZpb3VzQ29uc29sZUhlaWdodCIsImN1cnJlbnRDb25zb2xlSGVpZ2h0Iiwic2Vjb25kUm93U2Vjb25kUGFuZWwiLCJTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMiLCJGRUVEQkFDSyIsInByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWwiLCJ0cmFjZUV4ZWN1dGlvbiIsImxvYWRpbmdEYXRhc2V0cyIsImNoYW5nZWRJbnN0cnVjdGlvbnMiLCJ0cmlnZ2VyT25DaGFuZ2UiLCJkaXJ0eVN1Ym1pc3Npb24iLCJmdWxsc2NyZWVuIiwicGFzc2NvZGUiLCJjbGVhcklucHV0cyIsInJlbmRlckltYWdlcyIsImVkaXRvclZlcnNpb24iLCJyZWFkT25seSIsInRvU3RyaW5nIiwidXBsb2FkZWRGaWxlcyIsImJhY2t1cFN1Ym1pc3Npb25Db2RlIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsImxpc3RVcGxvYWRlZEZpbGVzIiwibGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlIiwiZG93bmxvYWRGaWxlIiwiZG93bmxvYWRGaWxlTWVzc2FnZSIsInVwbG9hZEZpbGUiLCJ1cGxvYWRGaWxlTWVzc2FnZSIsIm9uRXhlY3V0aW9uIiwiZXhlY3V0aW9uIiwicmVwb3J0cyIsIm91dHB1dCIsImlucHV0IiwiaW5wdXRJbmRleCIsInN0dWRlbnQiLCJjdXJyZW50U3RlcCIsImxhc3RTdGVwIiwiY3VycmVudExpbmUiLCJsYXN0TGluZSIsImN1cnJlbnRUcmFjZURhdGEiLCJjdXJyZW50VHJhY2VTdGVwIiwicmVzdWx0cyIsImdsb2JhbHMiLCJjYWxscyIsInN5c21vZHVsZXMiLCJmZWVkYmFjayIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxhYmVsIiwibGluZXNFcnJvciIsImxpbmVzVW5jb3ZlcmVkIiwiY2FsbGJhY2tzIiwic2VydmVyQ29ubmVjdGVkIiwiYmxvY2tseVBhdGgiLCJhdHRhY2htZW50UG9pbnQiLCJjb250YWluZXIiLCJ1cmxzIiwicGFydElkIiwiY29uc3RhbnRzIiwiZ3VpIiwibWFrZUludGVyZmFjZSIsIiQiLCJodG1sIiwiYXNzaWdubWVudF9pZCIsImNvbXBvbmVudHMiLCJzZXJ2ZXIiLCJzYW1wbGVzIiwic3RhcnRpbmdfY29kZSIsImV4dHJhX3N0YXJ0aW5nX2ZpbGVzIiwibG9hZE5vU3VibWlzc2lvbiIsImdyYWRpbmdfc3RhdHVzIiwiU3VibWlzc2lvblN0YXR1c2VzIiwiVU5LTk9XTiIsInN1Ym1pc3Npb25fc3RhdHVzIiwidXNlcl9pZCIsImNvdXJzZV9pZCIsImV4dHJhX2ZpbGVzIiwiZGF0YSIsImNvbnNvbGUiLCJkZWJ1ZyIsInJlc2V0SW50ZXJmYWNlIiwiZmlsZVN5c3RlbSIsImRpc21vdW50RXh0cmFGaWxlcyIsIndhc1NlcnZlckNvbm5lY3RlZCIsImZvcmtlZF9pZCIsImZvcmtlZF92ZXJzaW9uIiwiaXBfcmFuZ2VzIiwib25fY2hhbmdlIiwibmV3RmlsZSIsIm9uX2V2YWwiLCJvbl9ydW4iLCJvd25lcl9pZCIsImxvYWRUYWdzIiwibG9hZFNhbXBsZVN1Ym1pc3Npb25zIiwic2FtcGxlX3N1Ym1pc3Npb25zIiwiZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcyIsImxvYWRBc3NpZ25tZW50U2V0dGluZ3MiLCJsb2FkU3VibWlzc2lvbiIsImNvcmdpcyIsImxvYWREYXRhc2V0cyIsInB5dGhvbkVkaXRvciIsImJtIiwicmVmcmVzaCIsInNldFN0YXR1cyIsInNlbGYiLCJ1aSIsInNtYWxsTGF5b3V0IiwicHVyZUNvbXB1dGVkIiwiaXNHcmFkZXIiLCJpc0NoYW5nZWQiLCJjdXJyZW50IiwidXRpbGl0aWVzIiwibWFya2Rvd24iLCJyZXNldCIsIm1lbnUiLCJ2aXNpYmxlIiwib25seUludGVyYWN0aXZlIiwidGV4dEZ1bGxzY3JlZW4iLCJjbGlja0Z1bGxzY3JlZW4iLCJlZGl0SW5wdXRzIiwiZGlhbG9nIiwiRURJVF9JTlBVVFMiLCJ0b2dnbGVJbWFnZXMiLCJ0ZXh0RWRpdG9yIiwiZGlzYWJsZUltYWdlcyIsImVuYWJsZUltYWdlcyIsImNhbk1hcmtTdWJtaXR0ZWQiLCJjYW5DbG9zZSIsInRleHRNYXJrU3VibWl0dGVkIiwiaXNDb21wbGV0ZWQiLCJpc1N1Ym1pdHRlZCIsImNsaWNrTWFya1N1Ym1pdHRlZCIsImFsZXJ0IiwiZW5naW5lIiwiZGVsYXllZFJ1biIsInRvTG93ZXJDYXNlIiwic2hvd1F1ZXVlZElucHV0cyIsImhpZGVRdWV1ZWRJbnB1dHMiLCJzaG93Q2xvY2siLCJoYXNDbG9jayIsInNlY29uZFJvdyIsIndpZHRoIiwiaGlkZVRyYWNlQnV0dG9uIiwiaXNBbGxWaXNpYmxlIiwiaGlkZU1pZGRsZVBhbmVsIiwiaXNGZWVkYmFja1Zpc2libGUiLCJpc1RyYWNlVmlzaWJsZSIsIlRSQUNFIiwiaXNDb25zb2xlU2hvd1Zpc2libGUiLCJzd2l0Y2hMYWJlbCIsImFkdmFuY2VTdGF0ZSIsImN1cnJlbnRQYW5lbCIsIk5PTkUiLCJtYWtlV2lkZSIsInJlc3RvcmVQYW5lbCIsIm9sZFBhbmVsIiwic2l6ZSIsImhpZGVFdmFsdWF0ZSIsIkFDVElWRSIsImJhZGdlIiwicmVzZXRTY29yZSIsInRyYWNlIiwiaGlnaGxpZ2h0ZWRMaW5lIiwic3RlcCIsInRyYWNlRGF0YSIsImxpbmUiLCJhc3QiLCJBU1RfREVTQ1JJUFRJT05TIiwiZmlyc3QiLCJiYWNrd2FyZCIsInByZXZpb3VzIiwiTWF0aCIsIm1heCIsImZvcndhcmQiLCJuZXh0IiwibWluIiwibGFzdCIsImZpbGVzIiwiaGlkZUZpbGVzIiwiaGFzQ29udGVudHMiLCJwYXRoIiwic29tZSIsImZpbGUiLCJsZW5ndGgiLCJhZGQiLCJub3JtYWxUb29sYm94IiwiYmxvY2tFZGl0b3IiLCJUT09MQk9YRVMiLCJKU09OIiwic3RyaW5naWZ5IiwiU2FtcGxlU3VibWlzc2lvbiIsIkJsYW5rIiwibmV3RmlsZURpYWxvZyIsImRlbGV0ZUZpbGUiLCJyZW5hbWUiLCJuZXdOYW1lIiwicmVuYW1lRmlsZSIsImdldFN0dWRlbnRDb2RlIiwicHJlZml4UHkiLCJnZXRGaWxlIiwic3VmZml4UHkiLCJoYW5kbGUiLCJleHRyYVN0dWRlbnRGaWxlcyIsIm9ic2VydmVDb25jYXRlbmF0ZWRGaWxlIiwiZGlzcGxheUZpbGVuYW1lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWRpdG9ycyIsImdldEVkaXRvciIsInZpZXciLCJoaWRlRWRpdG9ycyIsIm1hcCIsInN1YnN0ciIsIm1ha2VNb2RlbEZpbGUiLCJjb250ZW50cyIsImNhblNhdmUiLCJjYW5EZWxldGUiLCJVTkRFTEVUQUJMRV9GSUxFUyIsImluZGV4T2YiLCJjYW5SZW5hbWUiLCJVTlJFTkFNQUJMRV9GSUxFUyIsInVwbG9hZCIsImJpbmQiLCJkb3dubG9hZCIsImltcG9ydERhdGFzZXQiLCJvcGVuRGlhbG9nIiwicHl0aG9uIiwiY29kZU1pcnJvciIsInNldE9wdGlvbiIsImdldE9wdGlvbiIsInVwZGF0ZU1vZGUiLCJuZXdNb2RlIiwib2xkUHl0aG9uTW9kZSIsImlzSGlzdG9yeUF2YWlsYWJsZSIsImlzRW5kcG9pbnRDb25uZWN0ZWQiLCJ0dXJuT2ZmSGlzdG9yeU1vZGUiLCJ1cGRhdGVFZGl0b3IiLCJzZXRSZWFkT25seSIsInR1cm5Pbkhpc3RvcnlNb2RlIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiaGlzdG9yeSIsImxvYWQiLCJFUlJPUl9MT0FESU5HX0hJU1RPUlkiLCJ0b2dnbGVIaXN0b3J5TW9kZSIsIm1vdmVUb1N0YXJ0IiwibW92ZVByZXZpb3VzIiwibW92ZU5leHQiLCJtb3N0UmVjZW50IiwibW92ZVRvTW9zdFJlY2VudCIsInVzZSIsImltYWdlcyIsInJlbG9hZEltYWdlcyIsImJ5TmFtZSIsInNhdmUiLCJidWlsZEVkaXRvciIsIm5ld0RPTSIsImluZGV4IiwibmV3RWxlbWVudCIsImVkaXRvciIsImV4ZWN1dGUiLCJpc1J1bm5pbmciLCJydW5MYWJlbCIsInJ1biIsIlB5Z2FtZUxpYiIsInJ1bm5pbmciLCJTdG9wUHlnYW1lIiwicnVuUXVpZXRseUxhYmVsIiwicnVuUXVpZXRseSIsImV2YWx1YXRlIiwibWVzc2FnZXMiLCJjYXBpdGFsaXplIiwiZm9yY2UiLCJldmVudCIsImFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b24iLCJ0YXJnZXQiLCJwYXJlbnQiLCJmYWRlT3V0IiwiZmFkZUluIiwiZnIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsImFzc2lnbm1lbnRTdWJtaXNzaW9uIiwicGFyc2UiLCJyZXN1bHQiLCJsb2FkQXNzaWdubWVudERhdGFfIiwiZmlsZU5hbWUiLCJyZWFkQXNUZXh0IiwidmFsIiwibG9nIiwiZm9vdGVyIiwibWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyIsIlNrIiwiYnVpbHRpbkZpbGVzIiwiaW1hZ2VNb2R1bGUiLCJhcHBseUJpbmRpbmdzIiwibWFpbiIsInRleHQiLCJFYXN5TURFIiwicHJvdG90eXBlIiwiQmxvY2tQeURpYWxvZyIsImZpbmQiLCJCbG9ja1B5RmVlZGJhY2siLCJCbG9ja1B5VHJhY2UiLCJCbG9ja1B5Q29uc29sZSIsIkJsb2NrUHlFbmdpbmUiLCJCbG9ja1B5RmlsZVN5c3RlbSIsIkVkaXRvcnMiLCJCbG9ja1B5U2VydmVyIiwiQmxvY2tQeUNvcmdpcyIsIkJsb2NrUHlIaXN0b3J5Iiwic2hvdyIsImhpZGUiLCJzdWJzY3JpYmUiLCJjaGFuZ2VkIiwiY2xvY2siLCJ1cGRhdGVDbG9jayIsImdldEN1cnJlbnRUaW1lIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiYWx0TG9nRW50cnkiLCJ1c2VyU3VwcGxpZWRQYXNzY29kZSIsInByb21wdCIsIlNUQVJUX0VWQUxfSFRNTCIsIk5FV19DT05TT0xFX0xJTkVfSFRNTCIsIkNPTlNPTEVfSFRNTCIsIkNvbnNvbGVMaW5lVHlwZSIsIkhUTUwiLCJQTE9UIiwiSU1BR0UiLCJQWUdBTUUiLCJUVVJUTEUiLCJFVkFMIiwiU1RBUlRfRVZBTCIsIlZBTFVFIiwiSU5QVVQiLCJURVNUX0NBU0UiLCJDb25zb2xlTGluZSIsImNvbnRlbnQiLCJvcmlnaW4iLCJjdXJyRmlsZW5hbWUiLCJleGVjdXRpb25CdWZmZXIiLCJmZmkiLCJyZW1hcFRvUHkiLCJyZW1vdmUiLCJDb25zb2xlTGluZVR1cnRsZSIsImFkZENsYXNzIiwid2hlcmUiLCJwcmVwZW5kIiwidG9wIiwib2Zmc2V0Iiwic2Nyb2xsVG9wIiwiQ29uc29sZUxpbmVQeWdhbWUiLCJweWdhbWVPYmoiLCJpbml0aWFsaXplZCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsImNsZWFudXAiLCJjbGVhbnVwRnVuY3Rpb24iLCJsaXN0ZW5lcnMiLCJDb25zb2xlTGluZUltYWdlIiwiQ29uc29sZUxpbmVQbG90IiwiQ29uc29sZUxpbmVUZXh0IiwiZW5jb2RlZFRleHQiLCJlbmNvZGVIVE1MIiwidHJpbSIsImxpbmVEYXRhIiwidG9vbHRpcCIsIkNvbnNvbGVMaW5lVmFsdWUiLCJDb25zb2xlTGluZUlucHV0IiwicHJvbXB0TWVzc2FnZSIsImlucHV0Rm9ybSIsImlucHV0QnRuIiwiaW5wdXRHcm91cCIsImlucHV0Qm94IiwiaW5wdXRNc2ciLCJtYWtlSW50ZXJhY3RpdmUiLCJidXR0b24iLCJyZXNvbHZlT25DbGljayIsInN1Ym1pdHRlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN1Ym1pdEZvcm0iLCJ1c2VySW5wdXR0ZWRWYWx1ZSIsInF1ZXVlZElucHV0IiwicHVzaCIsInByb3AiLCJjbGljayIsImtleXVwIiwia2V5Q29kZSIsImZvY3VzIiwiQ29uc29sZUxpbmVFdmFsdWF0ZSIsIkNvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSIsInRhZyIsInByaW50ZXJUYWciLCJNSU5JTVVNX1dJRFRIIiwiTUlOSU1VTV9IRUlHSFQiLCJERUZBVUxUX0hFSUdIVCIsImhlaWdodCIsImNsZWFyIiwicmVtb3ZlQWxsIiwibGluZUJ1ZmZlciIsInBsb3RCdWZmZXIiLCJlbXB0eSIsInR1cnRsZUxpbmUiLCJUdXJ0bGVHcmFwaGljcyIsImdldFR1cnRsZUxpbmUiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImFzc2V0cyIsImxvYWRBc3NldCIsInB5Z2FtZUxpbmUiLCJyZW5kZXIiLCJjdXJyZW50UHJpbnRlckRpbWVuc2lvbiIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0Iiwic2F2ZVR1cnRsZU91dHB1dCIsImRhdGFVcmwiLCJ0b0RhdGFVUkwiLCJwYWdlIiwiZWFjaCIsImF0dHIiLCJsaW5lVGV4dCIsImZsdXNoIiwiY2hhckF0Iiwic3BsaXRMaW5lcyIsInNwbGl0IiwiYWRkQ29udGVudCIsImkiLCJwbG90cyIsImltYWdlRGF0YSIsImltYWdlIiwiaW1hZ2VCdWZmZXIiLCJ2YWx1ZSIsInByaW50ZWRWYWx1ZSIsImlucHV0QnVmZmVyIiwic3RhcnRFdmFsdWF0aW9uIiwiYW5pbWF0ZSIsIl9JTVBPUlRFRF9EQVRBU0VUUyIsIl9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUyIsInNldEJ1dHRvbkxvYWRlZCIsImJ0biIsInJlbW92ZUNsYXNzIiwibG9hZGVkRGF0YXNldHMiLCJzaWxlbnRseSIsImltcG9ydHMiLCJkYXRhc2V0cyIsImZvckVhY2giLCJCbG9ja01pcnJvckJsb2NrRWRpdG9yIiwiRVhUUkFfVE9PTFMiLCJhcHBseSIsInNsdWciLCJ3aGVuIiwiZG9uZSIsImZvcmNlQmxvY2tSZWZyZXNoIiwicmVtYWtlVG9vbGJveCIsImZhaWwiLCJhcmd1bWVudHMiLCJlcnJvciIsImFsd2F5cyIsImZpbmFsaXplU3Vic2NyaXB0aW9ucyIsInVybF9yZXRyaWV2YWxzIiwicm9vdCIsImltcG9ydERhdGFzZXRzIiwiZ2V0RGF0YXNldCIsImdldFNjcmlwdCIsImdldENvbXBsZXRlIiwiZ2V0U2t1bHB0IiwiZ2V0QmxvY2tseSIsInRleHRUb0Jsb2NrcyIsImhpZGRlbkltcG9ydHMiLCJnZXRKU09OIiwiYmxvY2tweSIsImRvY3VtZW50YXRpb24iLCJib2R5IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJzbHVnZ2VkTmFtZSIsInRpdGxlTmFtZSIsImltZ1NyYyIsInRpdGxlIiwib3ZlcnZpZXciLCJhcHBlbmRUbyIsIkRJQUxPR19IVE1MIiwidGl0bGVUYWciLCJib2R5VGFnIiwiZm9vdGVyVGFnIiwib2theUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwieWVzIiwibm8iLCJtb2RhbCIsImNsb3NlIiwib25jbG9zZSIsImRyYWdnYWJsZSIsIm9uIiwiY29uZmlybSIsInllc1RleHQiLCJBU1NJR05NRU5UX1ZFUlNJT05fQ0hBTkdFRCIsIkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQiLCJyZWFzb24iLCJFUlJPUl9MSVNUSU5HX1VQTE9BREVEX0ZJTEVTIiwiRVJST1JfVVBMT0FESU5HX0ZJTEUiLCJFUlJPUl9TQVZJTkdfQVNTSUdOTU5FTlQiLCJFUlJPUl9TSE9XX1NUVURFTlRfRVJST1IiLCJQT1NJVElWRV9GRUVEQkFDS19GVUxMIiwiU0NSRUVOU0hPVF9CTE9DS1MiLCJFUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUyIsIk9GRkVSX0ZPUksiLCJzZXR1cFVybCIsImluc3RydWN0aW9uc0Fzc2lnbm1lbnRTZXR1cCIsImlucHV0VGV4dCIsImpvaW4iLCJjaGVja2VkIiwiaW5wdXRzIiwiZmlsZVJlYWRlciIsInNsdWdnaWZ5IiwicmVwbGFjZSIsImV4dGVuc2lvbiIsIm1pbWV0eXBlIiwiYmxvYiIsIkJsb2IiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJtc1NhdmVPck9wZW5CbG9iIiwibXNTYXZlQmxvYiIsInRlbXBvcmFyeURvd25sb2FkTGluayIsImhyZWYiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiQWJzdHJhY3RFZGl0b3IiLCJjaGFuZ2VFZGl0b3IiLCJ3YXRjaEZpbGUiLCJ1cGRhdGVkIiwib25GaWxlVXBkYXRlZCIsImRlbGV0ZWQiLCJvbkZpbGVEZWxldGVkIiwibmV3RmlsZW5hbWUiLCJvbGRFZGl0b3IiLCJ0cmFja0N1cnJlbnRGaWxlIiwibmV3RWRpdG9yIiwic3RvcFdhdGNoaW5nRmlsZSIsInBhcnNlRmlsZW5hbWUiLCJBU1NJR05NRU5UX1NFVFRJTkdTIiwiTUFaRSIsIlFVSVoiLCJSRUFESU5HIiwiZ2V0RG9jdW1lbnRhdGlvbiIsIm1ha2VTdGFydFZpZXdUYWIiLCJpY29uIiwibW9kZSIsIkFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwiLCJmaWx0ZXIiLCJzZXR0aW5nIiwicHJldHR5TmFtZSIsIndvcmQiLCJ0b1VwcGVyQ2FzZSIsIkFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUwiLCJCTE9DSyIsIlNQTElUIiwic2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyIsImNsaWVudE5hbWUiLCJzZXJ2ZXJOYW1lIiwic3RhcnRfdmlldyIsImZpZWxkVHlwZSIsImNvbmZpZ1ZhbHVlIiwiQXNzaWdubWVudFNldHRpbmdzVmlldyIsImRpcnR5IiwiY3VycmVudExpc3RlbmVyIiwidXBkYXRlSGFuZGxlIiwibmV3Q29udGVudHMiLCJBc3NpZ25tZW50U2V0dGluZ3MiLCJleHRlbnNpb25zIiwiY29uc3RydWN0b3IiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRfaGVhZGVyIiwiSU1BR0VfRURJVE9SX0hUTUwiLCJJbWFnZUVkaXRvclZpZXciLCJjdXJyZW50U3Vic2NyaXB0aW9uIiwiZGlhbG9ncyIsImRpc3Bvc2UiLCJJbWFnZUVkaXRvciIsIkpTT05fRURJVE9SX0hUTUwiLCJKc29uRWRpdG9yVmlldyIsIkNvZGVNaXJyb3IiLCJmcm9tVGV4dEFyZWEiLCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZyIsImxpbmVOdW1iZXJzIiwiZmlyc3RMaW5lTnVtYmVyIiwiaW5kZW50VW5pdCIsInRhYlNpemUiLCJpbmRlbnRXaXRoVGFicyIsImV4dHJhS2V5cyIsImNtIiwiYmx1ciIsInNldFRpbWVvdXQiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwib2ZmIiwiSnNvbkVkaXRvciIsIk1BUktET1dOX0VESVRPUl9IVE1MIiwiTWFya2Rvd25FZGl0b3JWaWV3IiwibWRlIiwiZWxlbWVudCIsImF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lIiwiZm9yY2VTeW5jIiwibWluSGVpZ2h0IiwicmVuZGVyaW5nQ29uZmlnIiwiY29kZVN5bnRheEhpZ2hsaWdodGluZyIsImNvZGVtaXJyb3IiLCJNYXJrZG93bkVkaXRvciIsIm1ha2VUYWIiLCJQWVRIT05fRURJVE9SX0hUTUwiLCJISVNUT1JZX1RPT0xCQVJfSFRNTCIsImNvbnZlcnRJcHluYlRvUHl0aG9uIiwiaXB5bmIiLCJpc1VzYWJsZSIsImNlbGwiLCJjZWxsX3R5cGUiLCJzb3VyY2UiLCJtYWtlUHl0aG9uIiwiY2VsbHMiLCJQeXRob25FZGl0b3JWaWV3IiwiQmxvY2tseSIsInNldFBhcmVudENvbnRhaW5lciIsIkJsb2NrTWlycm9yIiwidG9vbGJveCIsImltYWdlRG93bmxvYWRIb29rIiwib2xkVXJsIiwiaW1hZ2VVcGxvYWRIb29rIiwicmVqZWN0Iiwic3VibWlzc2lvbklkIiwiaW1hZ2VMaXRlcmFsSG9vayIsIm1ha2VTdWJzY3JpcHRpb25zIiwibGluZUVycm9yU3Vic2NyaXB0aW9uIiwibGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiIsImxpbmVUcmFjZVN1YnNjcmlwdGlvbiIsIm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucyIsIndvcmtzcGFjZSIsImNvbmZpZ3VyZUNvbnRleHRNZW51Iiwib3B0aW9ucyIsImVuYWJsZWQiLCJjYWxsYmFjayIsIm9sZEZpbGVuYW1lIiwiY3VycmVudEJNTGlzdGVuZXIiLCJhZGRDaGFuZ2VMaXN0ZW5lciIsImlzUGFyc29ucyIsImxpbmVzIiwic2V0SGlnaGxpZ2h0ZWRMaW5lcyIsImNsZWFySGlnaGxpZ2h0ZWRMaW5lcyIsImRlbGV0ZUZpbGVMb2NhbGx5XyIsInNldENvZGUiLCJnZXRDb2RlIiwicmVtb3ZlQ2hhbmdlTGlzdGVuZXIiLCJjbGVhckxpbmVTdWJzY3JpcHRpb25zIiwic2V0TW9kZSIsImVuYWJsZUJsb2NrcyIsInJlbG9hZFRvb2xib3giLCJpbWFnZU1vZGUiLCJzZXRJbWFnZU1vZGUiLCJvbGRIZWlnaHQiLCJ1c2VTbWFsbExheW91dCIsInJlc2l6ZVJlc3BvbnNpdmVseSIsInVwZGF0ZUd1dHRlciIsImluZGVudFNpZGViYXIiLCJjdXN0b21Ub29sYm94IiwiZGVjaWRlSWZOb3RFZGl0YWJsZSIsIm9ubHlVcGxvYWRzIiwiaXNSZWFkT25seSIsImVuZHNXaXRoIiwiUHl0aG9uRWRpdG9yIiwiUVVJWl9FRElUT1JfSFRNTCIsIlF1aXpFZGl0b3JWaWV3IiwiUXVpekVkaXRvciIsIlBBU1NFRCIsIkZBSUxFRCIsIkVSUk9SIiwiU0tJUFBFRCIsImNvdW50IiwiU0FNUExFX1NVQk1JU1NJT05TX0hUTUwiLCJiaW5kaW5nSGFuZGxlcnMiLCJjb2RlTWlycm9ySW5zdGFuY2UiLCJpbml0IiwidmFsdWVBY2Nlc3NvciIsImFsbEJpbmRpbmdzIiwidmlld01vZGVsIiwiYmluZGluZ0NvbnRleHQiLCJzZXRTaXplIiwidXBkYXRlIiwiU2FtcGxlU3VibWlzc2lvbnNWaWV3IiwiY29kZU1pcnJvcnMiLCJTYW1wbGVTdWJtaXNzaW9ucyIsIlRBR1NfRURJVE9SX0hUTUwiLCJUYWdzRWRpdG9yVmlldyIsIlRhZ3NFZGl0b3IiLCJURVhUX0VESVRPUl9IVE1MIiwiVGV4dEVkaXRvclZpZXciLCJUZXh0RWRpdG9yIiwiVE9PTEJPWF9FRElUT1JfSFRNTCIsIlRvb2xib3hFZGl0b3JWaWV3IiwiVG9vbGJveEVkaXRvciIsIkVkaXRvcnNFbnVtIiwiU1VCTUlTU0lPTiIsIkFTU0lHTk1FTlQiLCJJTlNUUlVDVElPTlMiLCJPTl9SVU4iLCJPTl9DSEFOR0UiLCJPTl9FVkFMIiwiU1RBUlRJTkdfQ09ERSIsIlNBTVBMRV9TVUJNSVNTSU9OUyIsIklOU1RSVUNUT1JfRklMRSIsIlNQRUNJQUxfTkFNRVNQQUNFUyIsIkFWQUlMQUJMRV9FRElUT1JTIiwiRURJVE9SU19IVE1MIiwicmVnaXN0ZXJlZF8iLCJleHRlbnNpb25zXyIsImJ5TmFtZV8iLCJyZWdpc3RlckVkaXRvciIsImluc3RhbmNlIiwiZXhpdCIsImVudGVyIiwic3BhY2UiLCJhc3NpZ25tZW50VHlwZSIsIkFzc2lnbm1lbnRUeXBlIiwibGFzdEluZGV4T2YiLCJleGVjdXRpb25Nb2RlbCIsImNvbmZpZ3VyYXRpb25zIiwiUnVuQ29uZmlndXJhdGlvbiIsImV2YWwiLCJFdmFsQ29uZmlndXJhdGlvbiIsIk9uUnVuQ29uZmlndXJhdGlvbiIsIk9uQ2hhbmdlQ29uZmlndXJhdGlvbiIsIk9uRXZhbENvbmZpZ3VyYXRpb24iLCJjb25maWd1cmUiLCJnZXRTa3VscHRPcHRpb25zIiwib25FeGVjdXRpb25CZWdpbiIsIm9uRXhlY3V0aW9uRW5kIiwicmVwb3J0IiwidHJhY2luZyIsInJlc2V0U3R1ZGVudE1vZGVsIiwicmVzZXRSZXBvcnRzIiwicmVzZXRFeGVjdXRpb25CdWZmZXIiLCJkaXNhYmxlRmVlZGJhY2siLCJ0aGVuIiwiZmFpbHVyZSIsInByb3ZpZGVTZWNyZXRFcnJvciIsInNob3dFcnJvcnMiLCJleGVjdXRpb25FbmRfIiwiZXZhbHVhdGlvbklucHV0IiwidXNlcklucHV0IiwibWlzY2V2YWwiLCJhc3luY1RvUHJvbWlzZSIsImltcG9ydE1haW5XaXRoQm9keSIsIkZJTEVOQU1FIiwicHJvZ3JhbXMiLCJzYXZlQ29kZSIsInZlcmlmeUNvZGUiLCJ1cGRhdGVQYXJzZSIsInJ1bkluc3RydWN0b3JDb2RlIiwibW9kdWxlIiwiZXhlY3V0aW9uUmVwb3J0cyIsInByZXNlbnRGZWVkYmFjayIsIiRkIiwiRU1QVFlfTU9EVUxFIiwiQ29uZmlndXJhdGlvbiIsImluQnJvd3NlciIsIm9wZW5GaWxlIiwicmVxdWVzdHNHZXQiLCJ0aW1lb3V0Iiwib3BlblVSTCIsInRpbWVvdXRIYW5kbGVyIiwidGltZVBhc3NlZCIsImV4ZWNMaW1pdCIsImRpc2FibGVUaW1lb3V0IiwiZ2V0VGltZW91dFByb21wdCIsImRlbGF5IiwicGFyc2VJbnQiLCJleGVjTGltaXRGdW5jdGlvbiIsIkluZmluaXR5IiwiYmVmb3JlQ2FsbCIsImxvbmdUaW1lb3V0IiwiX19mdXR1cmVfXyIsInB5dGhvbjMiLCJyZWFkIiwiaW1wb3J0RmlsZSIsImZpbGV3cml0ZSIsIndyaXRlRmlsZSIsInByaW50IiwiaW5wdXRmdW4iLCJpbnB1dGZ1blRha2VzUHJvbXB0IiwiaW1hZ2VQcm94eSIsImdldEltYWdlUHJveHkiLCJlbW9qaVByb3h5IiwicGFydCIsInJldGFpbkdsb2JhbHMiLCJ3YXJuIiwibW9ja1VybERhdGEiLCJidWlsdGluIiwiSU9FcnJvciIsImhhc093blByb3BlcnR5IiwiZmlsZURhdGEiLCJyZWFkRmlsZSIsIkVycm9yIiwic3RvcCIsImZ1bmN0aW9uTmFtZSIsInBvc2FyZ3MiLCJrd2FyZ3MiLCJzdHVkZW50TW9kZWwiLCJhcmdzIiwicG9wIiwiYWZ0ZXJTaW5nbGVFeGVjdXRpb24iLCJwcmludFZhbHVlIiwicmVtYXBUb0pzIiwiXyIsIiRyIiwieCIsImlzRG9jc3RyaW5nIiwiU3R1ZGVudENvbmZpZ3VyYXRpb24iLCJVVElMSVRZX01PRFVMRV9DT0RFIiwiJHNrX21vZF9pbnN0cnVjdG9yIiwiQ09WRVJBR0VfTU9EVUxFX0NPREUiLCIkc2tfbW9kX2NvdmVyYWdlIiwiSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24iLCJiZWZvcmVDYWxsQmFja3VwIiwiJHBlZGFsX3RyYWNlciIsImNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cyIsImluZm8iLCJnZXRBbGxGaWxlbmFtZXMiLCJza0ZpbGVuYW1lIiwic3RyIiwicG9wJGl0ZW0iLCJpbmNsdWRlcyIsImNob21wU3BlY2lhbEZpbGUiLCJjbGVhbiIsImZvdW5kIiwic2VhcmNoRm9yRmlsZSIsIk9TRXJyb3IiLCJuZXh0SW5wdXQiLCJjbGVhclRpbWVvdXQiLCJXUkFQX0lOU1RSVUNUT1JfQ09ERSIsInN0dWRlbnRDb2RlIiwiaW5zdHJ1Y3RvckNvZGUiLCJxdWljayIsImlzU2FmZSIsInNhZmVDb2RlIiwiSU5TVFJVQ1RPUl9NQVJLRVIiLCJkaXNhYmxlVGlmYSIsInN0dWRlbnRGaWxlcyIsImdldEFsbFN0dWRlbnRGaWxlcyIsImV2YWx1YXRpb24iLCJkdW1teU91dFNhbmRib3giLCJsaW5lT2Zmc2V0IiwiZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQiLCJTVUNDRVNTIiwiU0NPUkUiLCJvbGRTY29yZSIsIkhJREUiLCJzY3JvbGxpbmciLCJzY3JvbGxUb0JvdHRvbSIsInRwJG5hbWUiLCJwcmVzZW50SW50ZXJuYWxFcnJvciIsImJlZm9yZSIsIm1hdGNoIiwiTkVXX0xJTkVfUkVHRVgiLCJza2lwX3RpZmEiLCJPblNhbXBsZUNvbmZpZ3VyYXRpb24iLCJkaXNhYmxlU3R1ZGVudFJ1biIsIkJvb2xlYW4iLCJlbnZpcm9uIiwiZGljdCIsInNldCRpdGVtIiwiaW50XyIsImNsZWFySW5wdXQiLCJmaW5pc2hUdXJ0bGVzIiwiYmVnaW5FdmFsIiwicGFyc2VyIiwidmVyaWZpZXIiLCJTYW1wbGVDb25maWd1cmF0aW9uIiwiaXNGb3JiaWRkZW4iLCJsb2NhbHMiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwiYXN0TmFtZSIsInBhcnNlR2xvYmFscyIsInByb3BlcnRpZXMiLCJtb2R1bGVzIiwidmlzaXRlZExpbmVzIiwiU2V0IiwidmlzaXRCb2R5Iiwibm9kZSIsImxpbmVubyIsInN0YXRlbWVudCIsIm9yZWxzZSIsImZpbmFsYm9keSIsIkFycmF5IiwiZnJvbSIsImFzdEZyb21QYXJzZSIsImNzdCIsImZsYWdzIiwiZ2V0TGluZXMiLCJwcmVzZW50UnVuRXJyb3IiLCJlcnJvckJ1dHRvbiIsIkZFRURCQUNLX0hUTUwiLCJmZWVkYmFja01vZGVsIiwicG9zaXRpdmUiLCJ2aXNpYmlsaXR5QnVmZmVyIiwidG9wT2ZFbGVtZW50IiwiYm90dG9tT2ZFbGVtZW50IiwiYm90dG9tT2ZTY3JlZW4iLCJ0b3BPZlNjcmVlbiIsImNsZWFyUG9zaXRpdmVGZWVkYmFjayIsImV4ZWN1dGlvblJlc3VsdHMiLCJNRVNTQUdFIiwiQ0FURUdPUlkiLCJMQUJFTCIsIkRBVEEiLCJwb3NpdGl2ZXMiLCJQT1NJVElWRSIsImhpZGVTY29yZSIsImJsb2NrIiwiaGxqcyIsImhpZ2hsaWdodEJsb2NrIiwiZmluZEZpcnN0RXJyb3JMaW5lIiwic3R1ZGVudFJlcG9ydCIsInVuY292ZXJlZExpbmVzIiwicG9zaXRpdmVEYXRhIiwiYWRkUG9zaXRpdmVGZWVkYmFjayIsImNvbG9yIiwib25jbGljayIsInRvRW5kIiwiY3NzIiwiaG92ZXIiLCJ1cGRhdGVGZWVkYmFjayIsIm5vdGlmeUZlZWRiYWNrVXBkYXRlIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImp1c3RfcmV0dXJuIiwiY29udmVydFNrdWxwdEVycm9yIiwiZmlsZW5hbWVFeGVjdXRlZCIsInRyYWNlYmFjayIsImZyYW1lIiwic2NvcGUiLCJpc0luc3RydWN0b3IiLCJlcnIiLCJhbGxGcmFtZXMiLCJidWlsZFRyYWNlYmFjayIsImZlZWRiYWNrRGF0YSIsInF1aWNrJGxvb2t1cCIsImxvY2F0aW9uIiwidHAkZ2V0YXR0ciIsImZyaWVuZGx5TmFtZSIsImhpZGVJZkVtcHR5Iiwibm90SW5zdHJ1Y3RvciIsImluc3RydWN0b3JGaWxlQ2xhc3MiLCJoaWRlSWZOb3RJbnN0cnVjdG9yIiwiRklMRVNfSFRNTCIsIk5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwiLCJTVEFSVElOR19GSUxFUyIsIkJBU0lDX05FV19GSUxFUyIsIklOU1RSVUNUT1JfRElSRUNUT1JZIiwiU1RVREVOVF9ESVJFQ1RPUlkiLCJTZWFyY2hNb2RlcyIsIkVWRVJZV0hFUkUiLCJTVEFSVF9XSVRIX0lOU1RSVUNUT1IiLCJPTkxZX1NUVURFTlRfRklMRVMiLCJERUxFVEFCTEVfU0lNUExFX0ZJTEVTIiwiQmxvY2tQeUZpbGUiLCJvd25lciIsIm1ha2VNb2NrTW9kZWxGaWxlIiwiY29uY2F0ZW5hdGVkRmlsZSIsIm1vZGVsRmlsZUxpc3QiLCJtb2RlbEZpbGVzIiwiY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZSIsImZpbGVzXyIsIm1vdW50RmlsZXMiLCJ3YXRjaE1vZGVsIiwid2F0Y2hlc18iLCJ0b2dnbGUiLCJ2aXNpYmxpdHkiLCJmaWxlc3lzdGVtIiwiZmlsZUFycmF5IiwiY2hhbmdlcyIsInNlY29uZCIsImxvY2FsZUNvbXBhcmUiLCJjaGFuZ2UiLCJtb2RlbEZpbGUiLCJub3RpZnlXYXRjaGVzIiwib2JzZXJ2ZUluQXJyYXlfIiwiYXJyYXkiLCJjb2RlQnVuZGxlIiwiZXhpc3RpbmdGaWxlIiwib2JzZXJ2ZUZpbGVfIiwiZGVzdGluYXRpb24iLCJzdHVkZW50U2VhcmNoIiwic2VhcmNoTW9kZSIsInNwZWNpYWxGaWxlIiwic2VhcmNoRm9yU3BlY2lhbEZpbGVzXyIsInN0dWRlbnRWZXJzaW9uIiwic2VhcmNoRm9yRmlsZUluTGlzdF8iLCJnZW5lcmF0ZWRWZXJzaW9uIiwiZGVmYXVsdFZlcnNpb24iLCJoaWRkZW5WZXJzaW9uIiwiZmlyc3REZWZpbmVkVmFsdWUiLCJpbnN0cnVjdG9yVmVyc2lvbiIsInN0YXJ0aW5nVmVyc2lvbiIsIm1vZGVsTGlzdCIsImtpbmQiLCJmaWxldHlwZSIsIm5hbWVzcGFjZSIsImV4dGVuc2lvblJlZ2V4IiwiZXhlYyIsInByZWZpeCIsInN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwiRk9PVEVSX0hUTUwiLCJjdXJyZW50SWQiLCJlZGl0RXZlbnRzIiwic2VsZWN0b3IiLCJlZGl0SWQiLCJlbnRyeSIsImZpbGVfcGF0aCIsImV2ZW50X3R5cGUiLCJSRU1BUF9FVkVOVF9UWVBFUyIsImRpc3BsYXllZCIsInByZXR0eVByaW50RGF0ZVRpbWUiLCJjbGllbnRfdGltZXN0YW1wIiwiZGlzYWJsZSIsIm9wdGlvbiIsImRpc2FibGVkIiwiaXNFZGl0RXZlbnQiLCJldnQiLCJtb250aE5hbWVzIiwid2Vla0RheXMiLCJpc1NhbWVEYXkiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsInRpbWVTdHJpbmciLCJub3ciLCJEYXRlIiwicGFzdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImRheVN0ciIsImdldERheSIsIm1vbnRoU3RyIiwiZGF0ZSIsImdldEhpc3RvcnkiLCJyZXZlcnNlIiwicmVkdWNlIiwiY29tcGxldGUiLCJlbGVtIiwiY29tcGxldGVfc3RyIiwidGltZSIsIm5ld19saW5lIiwiaGlnaGxpZ2h0VGltZW91dCIsImlzRnVsbHNjcmVlbiIsInJlcXVlc3RGdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJUUkFDRV9IVE1MIiwiUkVUUllJTkciLCJPRkZMSU5FIiwic3RvcmFnZSIsInF1ZXVlIiwiZ2V0RGVmYXVsdCIsIk1BWF9RVUVVRV9TSVpFIiwiVElNRVJfREVMQVkiLCJGQUlMX0RFTEFZIiwidGltZXJzIiwib3ZlcmxheSIsImJsb2NraW5nQXR0ZW1wdHMiLCJjYWNoZWRGaWxlbmFtZXMiLCJjcmVhdGVTdWJzY3JpcHRpb25zIiwiY2hlY2tDYWNoZXMiLCJjaGVja0lQIiwib2xkSVAiLCJpcCIsInNldCIsIl9wb3N0TGF0ZXN0UmV0cnkiLCJwdXNoQW55UXVldWVkIiwiX3Bvc3RSZXRyeSIsImNyZWF0ZUZpbGVTdWJzY3JpcHRpb24iLCJjcmVhdGVFdmVudExvZ3MiLCJvbmJsdXIiLCJvbmZvY3VzIiwiY3JlYXRlU2VydmVyRGF0YSIsIm1pY3Jvc2Vjb25kcyIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNob3dPdmVybGF5IiwiYXR0ZW1wdCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlT3ZlcmxheSIsIl9lbnF1ZXVlRGF0YSIsImNhY2hlIiwiX2RlcXVldWVEYXRhIiwic3BsaWNlIiwicG9zdFJlcXVlc3QiLCJwb3N0IiwidGV4dFN0YXR1cyIsImZhaWx1cmVGdW5jdGlvbiIsImRvbmVGdW5jdGlvbiIsInJlcXVlc3QiLCJjYWNoZWRUaW1lIiwiX3Bvc3RCbG9ja2luZyIsImF0dGVtcHRzIiwiZXh0cmFTZXR0aW5ncyIsImFqYXgiLCJlcnJvclRocm93biIsInN0YXJ0UG9zc2libGVGb3JrIiwicGxhY2VtZW50IiwiZGlyZWN0b3J5IiwiZmQiLCJlbnRyaWVzIiwiZCIsIkZvcm1EYXRhIiwicHJvY2Vzc0RhdGEiLCJjb250ZW50VHlwZSIsIm5ld1N0YXR1cyIsInBvc3RTdGF0dXNDaGFuZ2UiLCJlcnJvckNhbGxiYWNrIiwibG9hZF9maWxlIiwiZm9ya2FibGUiLCJoaWRkZW5PdmVycmlkZSIsImZvcmNlVXBkYXRlIiwiZ2V0UG5nRnJvbUJsb2NrcyIsInBuZ0RhdGEiLCJpbWciLCIkYnVpbHRpbm1vZHVsZSIsIm1vZCIsInNhbXBsZVdyYXBwZXIiLCJfX25hbWVfXyIsIlBJTCIsIkluc3RhbnRQcm9taXNlIiwibGFzdFJlc3VsdCIsImxhc3RFcnJvciIsImNiIiwiYnVpbGRJbWFnZSIsImdldEFzc2V0IiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9uZXJyb3IiLCJzcmMiLCIkZ2JsIiwiJGxvYyIsIl9faW5pdF9fIiwiZnVuYyIsImZpbGVfb3JfdXJsIiwicHlDaGVja0FyZ3MiLCJweUNoZWNrVHlwZSIsImNoZWNrU3RyaW5nIiwiaW1hZ2VQcm9taXNlIiwic3VzcCIsIlN1c3BlbnNpb24iLCJub25lIiwibm9uZSQiLCJyZXN1bWUiLCJwcm9taXNlIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInBpeGVscyIsImdldEltYWdlRGF0YSIsIk5hbWVFcnJvciIsImNvbnNvbGVEYXRhIiwicHJpbnRQSUxJbWFnZSIsImZsaXAiLCJzdHlsZSIsInRyYW5zZm9ybSIsImJ1aWxkQ2xhc3MiLCJwcmlvciIsInRpbWVpdCIsImRpZmZlcmVuY2UiLCJjb25zb2xlX2xvZyIsImNvbnNvbGVfZGVidWciLCJnZXRfb3V0cHV0IiwiaXRlbSIsInRvU2t1bHB0IiwibGlzdCIsInJlc2V0X291dHB1dCIsImdldF9wcm9ncmFtIiwiZ2V0X2V2YWx1YXRpb24iLCJ0cmFjZV9saW5lcyIsInJlYWxMaW5lcyIsInRyYWNlX2NhbGxzIiwic3RhcnRfdHJhY2UiLCJzdG9wX3RyYWNlIiwiZ2V0X3N0dWRlbnRfZXJyb3IiLCJ0dXBsZSIsInBvc2l0aW9uIiwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yIiwiYmFja3VwVGltZSIsImxpbWl0X2V4ZWN1dGlvbl90aW1lIiwiZXhlY1N0YXJ0IiwidW5saW1pdF9leGVjdXRpb25fdGltZSIsInN1cHByZXNzX3Njcm9sbGluZyIsImdldF9wbG90cyIsIm91dHB1dHMiLCJncmFwaCIsInBsb3QiLCJuZXdQbG90IiwidiIsInkiLCJTdHVkZW50RGF0YSIsIm5ld0RpY3QiLCJhYnN0ciIsInNhdHRyIiwib2JqZWN0U2V0SXRlbSIsInVuZml4UmVzZXJ2ZWQiLCJjYWxsX2YiLCJrd2EiLCJweUNoZWNrQXJnc0xlbiIsImNhbGwiLCJidWlsdGlucyIsIm1wJGxvb2t1cCIsImZ1bmN0aW9uT2JqZWN0IiwidHAkY2FsbCIsImNvX2t3YXJncyIsImNvX25hbWUiLCJnZXRfbmFtZXNfYnlfdHlwZSIsImV4Y2x1ZGVfYnVpbHRpbnMiLCJjaGVja0Jvb2wiLCJwcm9wZXJ0eSIsImdldF92YWx1ZXNfYnlfdHlwZSIsImNhbGxzaW1PclN1c3BlbmQiLCJnZXRfc3R1ZGVudF9kYXRhIiwic2V0X2luc3RydWN0aW9ucyIsIm5ld0luc3RydWN0aW9ucyIsImdldF9tb2RlbF9pbmZvIiwiY2xlYXJfZXhpc3Rpbmdfc3R1ZGVudF9pbXBvcnRzIiwiV2Vha1NldCIsImNoZWNrSXRlcmFibGUiLCJpdGVyIiwiaXRlcm5leHQiLCJXZWFrUmVmIiwiX19pdGVyX18iLCJ2aWV3T2ZEYXRhIiwiZGVyZWYiLCJMT0NBTF9TVE9SQUdFX1JFRiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiX2RhdGEiLCJTdHJpbmciLCJnZXRJdGVtIiwiaXNfbmV3Iiwic2VydmVyX3RpbWUiLCJzdG9yZWRfdGltZSIsIklHTk9SRURfR0xPQkFMUyIsInZhcmlhYmxlcyIsInBhcnNlZCIsInBhcnNlVmFsdWUiLCJmdWxsTGVuZ3RoIiwiZnVuY19jb2RlIiwiY29fdmFybmFtZXMiLCJzcSRsZW5ndGgiLCJib29sIiwibm1iZXIiLCJza1R5cGUiLCJmbG9hdF8iLCJOdW1iZXIiLCJhcnJheUNvbnRhaW5zIiwibmVlZGxlIiwiaGF5c3RhY2siLCJhcnJheVVuaXF1ZSIsImEiLCJjb25jYXQiLCJqIiwiZXhwYW5kQXJyYXkiLCJhZGRBcnJheSIsInJlbW92ZUFycmF5IiwiY29weUFycmF5IiwiY2xvbmVOb2RlIiwiY2xvbmUiLCJub2RlVHlwZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJpbmRlbnQiLCJzIiwicmFuZG9tSW50ZWdlciIsImZsb29yIiwicmFuZG9tIiwiV29ya3NwYWNlU3ZnIiwic2h1ZmZsZSIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImJsb2NrcyIsImdldFRvcEJsb2NrcyIsIm1heGltYWxfaW5jcmVhc2UiLCJnZXRSZWxhdGl2ZVRvU3VyZmFjZVhZIiwibW92ZUJ5IiwibW92ZUVsZW1lbnRzIiwibW92ZUNoZWNrIiwiaXNTa0J1aWx0aW4iLCJvYmoiLCJsbmciLCJpc0FzdE5vZGUiLCJERUZBVUxUX1NFQ1RJT05fUEFUVEVSTiIsInBhcnRzIiwibWl4ZWRSZW1hcFRvUHkiLCJrIiwia3ZzIiwiYXJyIiwic3VidmFsIiwiYXNzayQiLCJ0b2RheSIsImgiLCJnZXRIb3VycyIsIm0iLCJnZXRNaW51dGVzIiwicCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Q0FFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUEsSUFBTUEsY0FBYyxHQUFHLE9BQXZCO0FBRUE7Ozs7Ozs7Ozs7QUFTTyxJQUFNQyxPQUFiO0FBQ0k7Ozs7O0FBS0EsbUJBQVlDLGFBQVosRUFBMkJDLFVBQTNCLEVBQXVDQyxVQUF2QyxFQUFtRDtBQUFBOztBQUMvQyxTQUFLQyxTQUFMLENBQWVILGFBQWY7O0FBQ0EsUUFBSUMsVUFBVSxLQUFLRyxTQUFuQixFQUE4QjtBQUMxQixXQUFLQyxhQUFMLENBQW1CTCxhQUFuQixFQUFrQ0MsVUFBbEMsRUFBOENDLFVBQTlDO0FBQ0g7O0FBQ0QsU0FBS0ksUUFBTDtBQUNIO0FBRUQ7Ozs7Ozs7QUFkSjtBQUFBO0FBQUEsK0JBbUJlO0FBQ1AsV0FBS0MsYUFBTDtBQUNBLFdBQUtDLGdCQUFMO0FBQ0EsV0FBS0MsV0FBTDtBQUNBLFdBQUtDLGFBQUw7QUFDQSxXQUFLQyxVQUFMO0FBQ0EsV0FBS0MsY0FBTDtBQUNBLFdBQUtDLHNCQUFMO0FBQ0EsV0FBS0MsS0FBTDtBQUNIO0FBNUJMO0FBQUE7O0FBOEJJOzs7OztBQTlCSiwrQkFtQ2VDLEdBbkNmLEVBbUNvQkMsWUFuQ3BCLEVBbUNrQztBQUMxQixVQUFJRCxHQUFHLElBQUksS0FBS0UscUJBQWhCLEVBQXVDO0FBQ25DLGVBQU8sS0FBS0EscUJBQUwsQ0FBMkJGLEdBQTNCLENBQVA7QUFDSCxPQUZELE1BRU8sSUFBSSxLQUFLRyxjQUFMLENBQW9CQyxHQUFwQixDQUF3QkosR0FBeEIsQ0FBSixFQUFrQztBQUNyQyxlQUFPLEtBQUtHLGNBQUwsQ0FBb0JFLEdBQXBCLENBQXdCTCxHQUF4QixDQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsZUFBT0MsWUFBUDtBQUNIO0FBQ0o7QUFFRDs7Ozs7Ozs7Ozs7OztBQTdDSjtBQUFBO0FBQUEsOEJBeURjaEIsYUF6RGQsRUF5RDZCO0FBQ3JCO0FBQ0EsV0FBS2tCLGNBQUwsR0FBc0IsSUFBSUcsOERBQUosQ0FBd0IsZUFBeEIsQ0FBdEI7QUFDQSxXQUFLSixxQkFBTCxHQUE2QmpCLGFBQTdCLENBSHFCLENBSXJCOztBQUVBLFdBQUtzQixLQUFMLEdBQWE7QUFDVEMsWUFBSSxFQUFFO0FBQ0ZDLFlBQUUsRUFBRUMsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMsU0FBRCxDQUEzQixDQURGO0FBRUYyQixjQUFJLEVBQUVGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLFdBQUQsQ0FBM0IsQ0FGSjs7QUFHRjs7Ozs7QUFLQTRCLGNBQUksRUFBRUgsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBS0csVUFBTCxDQUFnQixXQUFoQixFQUE2QixPQUE3QixDQUFkLENBUko7O0FBU0Y7OztBQUdBQyxrQkFBUSxFQUFFTCxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxnQkFBRCxDQUEzQixDQVpSOztBQWFGOzs7QUFHQStCLGlCQUFPLEVBQUVOLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLGVBQUQsQ0FBM0I7QUFoQlAsU0FERztBQW1CVEMsa0JBQVUsRUFBRTtBQUNSdUIsWUFBRSxFQUFFQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBREk7QUFFUkMsY0FBSSxFQUFFRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxnQkFBZCxDQUZFO0FBR1JNLHNCQUFZLEVBQUVQLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLDZEQUFkLENBSE47O0FBSVI7OztBQUdBTyxhQUFHLEVBQUVSLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FQRztBQVFSO0FBQ0FRLGNBQUksRUFBRVQsRUFBRSxDQUFDQyxVQUFILENBQWNTLDBFQUFhLENBQUNDLE9BQTVCLENBVEU7QUFVUkMsZ0JBQU0sRUFBRVosRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQVZBO0FBV1JZLHNCQUFZLEVBQUViLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLDBCQUFELENBQWIsSUFBNkMsRUFBM0QsQ0FYTjtBQVlSdUMsZUFBSyxFQUFFZCxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUFiLElBQXNDLEVBQXBELENBWkM7QUFhUndDLGtCQUFRLEVBQUVmLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLHNCQUFELENBQWIsSUFBeUMsSUFBdkQsQ0FiRjtBQWNSeUMsZ0JBQU0sRUFBRWhCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLG9CQUFELENBQWIsSUFBdUMsSUFBckQsQ0FkQTtBQWVSMEMsOEJBQW9CLEVBQUVqQixFQUFFLENBQUNrQixlQUFILENBQW1CQyxvRUFBb0IsQ0FBQzVDLGFBQWEsQ0FBQyxtQ0FBRCxDQUFkLENBQXBCLElBQTRFLEVBQS9GLENBZmQ7QUFnQlI2Qyw0QkFBa0IsRUFBRXBCLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FoQlo7QUFpQlJHLGtCQUFRLEVBQUVyQixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBakJGO0FBa0JScUIsdUJBQWEsRUFBRXRCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FsQlA7QUFtQlJzQixpQkFBTyxFQUFFdkIsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQW5CRDtBQW9CUkksa0JBQVEsRUFBRUwsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXBCRjtBQXFCUnVCLGlCQUFPLEVBQUV4QixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBckJEO0FBc0JSd0IsY0FBSSxFQUFFekIsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQXRCRTtBQXVCUlEsMkJBQWlCLEVBQUUxQixFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBdkJYO0FBd0JSUyxrQkFBUSxFQUFFM0IsRUFBRSxDQUFDQyxVQUFILENBQWMxQixhQUFhLENBQUMscUJBQUQsQ0FBM0IsQ0F4QkY7QUF5QlIsb0JBQVF5QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUEzQixDQXpCQTtBQTBCUnFELGdCQUFNLEVBQUU1QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxtQkFBRCxDQUEzQixDQTFCQTtBQTJCUnNELGtCQUFRLEVBQUU3QixFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxzQkFBRCxDQUEzQixDQTNCRjtBQTRCUnVELGtCQUFRLEVBQUVDLGdHQUEyQixDQUFDeEQsYUFBRDtBQTVCN0IsU0FuQkg7QUFpRFRFLGtCQUFVLEVBQUU7QUFDUnNCLFlBQUUsRUFBRUMsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQURJO0FBRVIrQixjQUFJLEVBQUVoQyxFQUFFLENBQUNDLFVBQUgsQ0FBY2dDLCtEQUFXLENBQUMxRCxhQUFhLENBQUMsaUJBQUQsQ0FBYixJQUFvQyxFQUFyQyxFQUF5Q0EsYUFBYSxDQUFDLFFBQUQsQ0FBdEQsQ0FBWCxJQUFnRixFQUE5RixDQUZFO0FBR1IyRCxvQkFBVSxFQUFFbEMsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQUhKO0FBSVJWLGFBQUcsRUFBRVIsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQUpHO0FBS1JrQyxrQkFBUSxFQUFFbkMsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQUxGO0FBTVJtQyxlQUFLLEVBQUVwQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxDQUFkLENBTkM7QUFPUm9DLGlCQUFPLEVBQUVyQyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxLQUFkLENBUEQ7QUFRUjtBQUNBO0FBQ0E7QUFDQTtBQUNBdUIsaUJBQU8sRUFBRXhCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FaRDtBQWFScUMsMEJBQWdCLEVBQUV0QyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxTQUFkLENBYlY7QUFjUnNDLHVCQUFhLEVBQUV2QyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxVQUFkLENBZFA7QUFlUnNCLGlCQUFPLEVBQUV2QixFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkO0FBZkQsU0FqREg7QUFrRVR1QyxlQUFPLEVBQUU7QUFDTDs7OztBQUlBQyxrQkFBUSxFQUFFekMsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQUxMOztBQU1MOzs7O0FBSUF5QyxvQkFBVSxFQUFFMUMsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBRyxLQUFLRyxVQUFMLENBQWdCLG9CQUFoQixFQUFzQyxPQUF0QyxDQUFILEtBQW9ELE1BQWxFLENBVlA7O0FBV0w7OztBQUdBdUMscUJBQVcsRUFBRTNDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FkUjs7QUFlTDs7OztBQUlBMkMsb0JBQVUsRUFBRTVDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQUtHLFVBQUwsQ0FBZ0IscUJBQWhCLEVBQXVDeUMsNkRBQVksQ0FBQ0MsSUFBcEQsQ0FBZCxDQW5CUDs7QUFvQkw7Ozs7QUFJQUMscUJBQVcsRUFBRS9DLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0F4QlI7O0FBeUJMOzs7Ozs7QUFNQStDLGtCQUFRLEVBQUVoRCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBL0JMOztBQWdDTDs7O0FBR0FnRCxvQkFBVSxFQUFFakQsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQW5DUDs7QUFvQ0w7Ozs7O0FBS0FpRCwrQkFBcUIsRUFBRWxELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0F6Q2xCO0FBMENMa0QsOEJBQW9CLEVBQUVuRCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBMUNqQjs7QUEyQ0w7Ozs7QUFJQW1ELDhCQUFvQixFQUFFcEQsRUFBRSxDQUFDQyxVQUFILENBQWNvRCx3RUFBMkIsQ0FBQ0MsUUFBMUMsQ0EvQ2pCO0FBZ0RMQyxzQ0FBNEIsRUFBRXZELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FoRHpCOztBQWlETDs7O0FBR0F1RCx3QkFBYyxFQUFFeEQsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBZCxDQXBEWDs7QUFxREw7Ozs7QUFJQXdELHlCQUFlLEVBQUV6RCxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBekRaOztBQTBETDs7O0FBR0F3Qyw2QkFBbUIsRUFBRTFELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0E3RGhCOztBQThETDs7O0FBR0EwRCx5QkFBZSxFQUFFLElBakVaOztBQWtFTDs7Ozs7O0FBTUFDLHlCQUFlLEVBQUU1RCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBeEVaOztBQXlFTDs7OztBQUlBNEQsb0JBQVUsRUFBRTdELEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0E3RVA7O0FBOEVMOzs7QUFHQTZELGtCQUFRLEVBQUU5RCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBakZMOztBQWtGTDs7O0FBR0E4RCxxQkFBVyxFQUFFL0QsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQXJGUjs7QUFzRkw7OztBQUdBK0Qsc0JBQVksRUFBRWhFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0F6RlQ7QUEwRkxnRSx1QkFBYSxFQUFFNUYsY0ExRlY7QUEyRkw2RixrQkFBUSxFQUFFbEUsRUFBRSxDQUFDQyxVQUFILENBQWMsS0FBS0csVUFBTCxDQUFnQixtQkFBaEIsRUFBcUMsT0FBckMsRUFBOEMrRCxRQUE5QyxPQUEyRCxNQUF6RSxDQTNGTDs7QUE0Rkw7OztBQUdBQyx1QkFBYSxFQUFFcEUsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQS9GVjs7QUFnR0w7Ozs7O0FBS0FvRSw4QkFBb0IsRUFBRXJFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjMUIsYUFBYSxDQUFDLGlCQUFELENBQWIsSUFBb0MsRUFBbEQ7QUFyR2pCLFNBbEVBO0FBeUtUK0YsY0FBTSxFQUFFO0FBQ0o7QUFDQUMsd0JBQWMsRUFBRXZFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FGWjtBQUdKQywrQkFBcUIsRUFBRTFFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FIbkI7QUFJSjtBQUNBMEUscUJBQVcsRUFBRTNFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FMVDtBQU1KRyw0QkFBa0IsRUFBRTVFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FOaEI7QUFPSjtBQUNBNEUsa0JBQVEsRUFBRTdFLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FSTjtBQVNKSyx5QkFBZSxFQUFFOUUsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQVRiO0FBVUo7QUFDQThFLHFCQUFXLEVBQUUvRSxFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCLENBWFQ7QUFZSk8sNEJBQWtCLEVBQUVoRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBWmhCO0FBYUo7QUFDQWdGLGtCQUFRLEVBQUVqRixFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCLENBZE47QUFlSlMseUJBQWUsRUFBRWxGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0FmYjtBQWdCSjtBQUNBa0YsbUJBQVMsRUFBRW5GLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FqQlA7QUFrQkpXLDBCQUFnQixFQUFFcEYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWxCZDtBQW1CSjtBQUNBb0Ysa0JBQVEsRUFBRXJGLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0FwQk47QUFxQkphLHlCQUFlLEVBQUV0RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBckJiO0FBc0JKO0FBQ0FzRix3QkFBYyxFQUFFdkYsRUFBRSxDQUFDQyxVQUFILENBQWN1RSxxREFBVyxDQUFDQyxLQUExQixDQXZCWjtBQXdCSmUsK0JBQXFCLEVBQUV4RixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBeEJuQjtBQXlCSjtBQUNBd0YsMEJBQWdCLEVBQUV6RixFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCLENBMUJkO0FBMkJKaUIsaUNBQXVCLEVBQUUxRixFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBM0JyQjtBQTRCSjtBQUNBMEYsZ0NBQXNCLEVBQUUzRixFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCLENBN0JwQjtBQThCSm1CLHVDQUE2QixFQUFFNUYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQTlCM0I7QUErQko7QUFDQTRGLDJCQUFpQixFQUFFN0YsRUFBRSxDQUFDQyxVQUFILENBQWN1RSxxREFBVyxDQUFDQyxLQUExQixDQWhDZjtBQWlDSnFCLGtDQUF3QixFQUFFOUYsRUFBRSxDQUFDQyxVQUFILENBQWMsRUFBZCxDQWpDdEI7QUFrQ0o7QUFDQThGLHNCQUFZLEVBQUUvRixFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCLENBbkNWO0FBb0NKdUIsNkJBQW1CLEVBQUVoRyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxFQUFkLENBcENqQjtBQXFDSjtBQUNBZ0csb0JBQVUsRUFBRWpHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjdUUscURBQVcsQ0FBQ0MsS0FBMUIsQ0F0Q1I7QUF1Q0p5QiwyQkFBaUIsRUFBRWxHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEVBQWQsQ0F2Q2Y7QUF3Q0o7QUFDQWtHLHFCQUFXLEVBQUVuRyxFQUFFLENBQUNDLFVBQUgsQ0FBY3VFLHFEQUFXLENBQUNDLEtBQTFCO0FBekNULFNBektDO0FBb05UMkIsaUJBQVMsRUFBRTtBQUNQO0FBQ0FDLGlCQUFPLEVBQUUsRUFGRjtBQUdQO0FBQ0FDLGdCQUFNLEVBQUV0RyxFQUFFLENBQUNrQixlQUFILENBQW1CLEVBQW5CLENBSkQ7QUFLUDtBQUNBcUYsZUFBSyxFQUFFdkcsRUFBRSxDQUFDa0IsZUFBSCxDQUFtQixFQUFuQixDQU5BO0FBT1BzRixvQkFBVSxFQUFFeEcsRUFBRSxDQUFDQyxVQUFILENBQWMsQ0FBZCxDQVBMO0FBUVA7QUFDQXdHLGlCQUFPLEVBQUU7QUFDTDtBQUNBaEUsb0JBQVEsRUFBRXpDLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FGTDtBQUdMO0FBQ0F5Ryx1QkFBVyxFQUFFMUcsRUFBRSxDQUFDQyxVQUFILENBQWMsSUFBZCxDQUpSO0FBS0w7QUFDQTBHLG9CQUFRLEVBQUUzRyxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBTkw7QUFPTDtBQUNBMkcsdUJBQVcsRUFBRTVHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FSUjtBQVNMNEcsb0JBQVEsRUFBRTdHLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FUTDtBQVVMO0FBQ0E2Ryw0QkFBZ0IsRUFBRTlHLEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FYYjtBQVlMO0FBQ0E2Riw0QkFBZ0IsRUFBRS9HLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLENBQWQsQ0FiYjtBQWNMO0FBQ0ErRyxtQkFBTyxFQUFFLElBZko7QUFnQkxDLG1CQUFPLEVBQUVqSCxFQUFFLENBQUNDLFVBQUgsQ0FBYyxJQUFkLENBaEJKO0FBaUJMaUgsaUJBQUssRUFBRTtBQWpCRixXQVRGO0FBNEJQeEUsb0JBQVUsRUFBRTtBQUNSdUUsbUJBQU8sRUFBRSxJQUREO0FBRVJFLHNCQUFVLEVBQUV4STtBQUZKLFdBNUJMO0FBZ0NQO0FBQ0F5SSxrQkFBUSxFQUFFO0FBQ047QUFDQUMsbUJBQU8sRUFBRXJILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLE9BQWQsQ0FGSDtBQUdOcUgsb0JBQVEsRUFBRXRILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FISjtBQUlOc0gsaUJBQUssRUFBRXZILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLElBQWQsQ0FKRDtBQUtOMkIsa0JBQU0sRUFBRTVCLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQWQsQ0FMRjtBQU1OdUgsc0JBQVUsRUFBRXhILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FOTjtBQU9OdUcsMEJBQWMsRUFBRXpILEVBQUUsQ0FBQ2tCLGVBQUgsQ0FBbUIsRUFBbkIsQ0FQVjtBQVFOO0FBQ0E4RixtQkFBTyxFQUFFO0FBVEg7QUFqQ0gsU0FwTkY7QUFpUVR6SSxxQkFBYSxFQUFFO0FBQ1g7OztBQUdBbUosbUJBQVMsRUFBRTtBQUNQOzs7QUFHQSx1QkFBVyxLQUFLbEkscUJBQUwsQ0FBMkIsa0JBQTNCO0FBSkosV0FKQTs7QUFVWDs7OztBQUlBbUkseUJBQWUsRUFBRTNILEVBQUUsQ0FBQ0MsVUFBSCxDQUFjLEtBQUtHLFVBQUwsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDLENBQWQsQ0FkTjtBQWVYO0FBQ0F3SCxxQkFBVyxFQUFFLEtBQUtwSSxxQkFBTCxDQUEyQixjQUEzQixDQWhCRjtBQWlCWDtBQUNBcUkseUJBQWUsRUFBRSxLQUFLckkscUJBQUwsQ0FBMkIsa0JBQTNCLENBbEJOO0FBbUJYO0FBQ0FzSSxtQkFBUyxFQUFFLElBcEJBO0FBcUJYO0FBQ0FDLGNBQUksRUFBRSxLQUFLdkkscUJBQUwsQ0FBMkIsTUFBM0IsS0FBc0MsRUF0QmpDOztBQXVCWDs7Ozs7QUFLQXdJLGdCQUFNLEVBQUVoSSxFQUFFLENBQUNDLFVBQUgsQ0FBYzFCLGFBQWEsQ0FBQyxRQUFELENBQWIsSUFBMkIsRUFBekM7QUE1Qkc7QUFqUU4sT0FBYjtBQWdTSDtBQS9WTDtBQUFBOztBQWlXSTs7O0FBaldKLG9DQW9Xb0I7QUFDWixVQUFJMEosU0FBUyxHQUFHLEtBQUtwSSxLQUFMLENBQVd0QixhQUEzQjtBQUNBLFVBQUkySixHQUFHLEdBQUdDLGtFQUFhLENBQUMsSUFBRCxDQUF2QjtBQUNBRixlQUFTLENBQUNILFNBQVYsR0FBc0JNLDZDQUFDLENBQUNILFNBQVMsQ0FBQ0osZUFBWCxDQUFELENBQTZCUSxJQUE3QixDQUFrQ0QsNkNBQUMsQ0FBQ0YsR0FBRCxDQUFuQyxDQUF0QjtBQUNIO0FBeFdMO0FBQUE7QUFBQSxtQ0EwV21CSSxhQTFXbkIsRUEwV2tDO0FBQzFCLFdBQUtDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCakUsY0FBdkIsQ0FBc0MrRCxhQUF0QztBQUNIO0FBNVdMO0FBQUE7QUFBQSw2QkE4V2E3RyxJQTlXYixFQThXbUIsQ0FDWDtBQUNIO0FBaFhMO0FBQUE7QUFBQSwwQ0FrWDBCZ0gsT0FsWDFCLEVBa1htQyxDQUMzQjtBQUNIO0FBcFhMO0FBQUE7QUFBQSxxQ0FzWHFCakssVUF0WHJCLEVBc1hpQztBQUN6QixXQUFLcUIsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnVELElBQXRCLENBQTJCeEQsVUFBVSxDQUFDa0ssYUFBdEM7QUFDQXZILDBFQUFvQixDQUFDM0MsVUFBVSxDQUFDbUssb0JBQVosRUFBa0MsS0FBSzlJLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0J5RCxVQUF4RCxDQUFwQjtBQUNIO0FBelhMO0FBQUE7QUFBQSxtQ0EyWG1CekQsVUEzWG5CLEVBMlgrQkQsVUEzWC9CLEVBMlgyQztBQUNuQyxVQUFJLENBQUNDLFVBQUwsRUFBaUI7QUFDYjtBQUNBLGFBQUttSyxnQkFBTCxDQUFzQnBLLFVBQXRCO0FBQ0EsZUFBTyxLQUFQO0FBQ0gsT0FMa0MsQ0FNbkM7OztBQUNBLFdBQUtxQixLQUFMLENBQVdwQixVQUFYLENBQXNCc0IsRUFBdEIsQ0FBeUJ0QixVQUFVLENBQUNzQixFQUFwQztBQUNBLFdBQUtGLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUI2QixvQkFBbkIsQ0FBd0M1RixVQUFVLENBQUN1RCxJQUFuRDtBQUNBLFdBQUtuQyxLQUFMLENBQVdwQixVQUFYLENBQXNCdUQsSUFBdEIsQ0FBMkJDLCtEQUFXLENBQUN4RCxVQUFVLENBQUN1RCxJQUFaLEVBQWtCLEtBQUtuQyxLQUFMLENBQVd0QixhQUFYLENBQXlCeUosTUFBekIsRUFBbEIsQ0FBWCxJQUFtRSxFQUE5RjtBQUNBLFdBQUtuSSxLQUFMLENBQVdwQixVQUFYLENBQXNCNEQsT0FBdEIsQ0FBOEI1RCxVQUFVLENBQUM0RCxPQUF6QztBQUNBLFdBQUt4QyxLQUFMLENBQVdwQixVQUFYLENBQXNCMkQsS0FBdEIsQ0FBNEIzRCxVQUFVLENBQUMyRCxLQUF2QztBQUNBLFdBQUt2QyxLQUFMLENBQVdwQixVQUFYLENBQXNCMEQsUUFBdEIsQ0FBK0IxRCxVQUFVLENBQUMwRCxRQUExQztBQUNBLFdBQUt0QyxLQUFMLENBQVdwQixVQUFYLENBQXNCK0IsR0FBdEIsQ0FBMEIvQixVQUFVLENBQUMrQixHQUFyQztBQUNBLFdBQUtYLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IrQyxPQUF0QixDQUE4Qi9DLFVBQVUsQ0FBQytDLE9BQXpDO0FBQ0EsV0FBSzNCLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I4RCxhQUF0QixDQUFvQzlELFVBQVUsQ0FBQ29LLGNBQVgsSUFBNkJDLDhFQUFrQixDQUFDQyxPQUFwRjtBQUNBLFdBQUtsSixLQUFMLENBQVdwQixVQUFYLENBQXNCNkQsZ0JBQXRCLENBQXVDN0QsVUFBVSxDQUFDdUssaUJBQVgsSUFBZ0NGLDhFQUFrQixDQUFDQyxPQUExRjtBQUNBLFdBQUtsSixLQUFMLENBQVdwQixVQUFYLENBQXNCOEMsT0FBdEIsQ0FBOEI5QyxVQUFVLENBQUN3SyxPQUF6QztBQUNBLFdBQUtwSixLQUFMLENBQVdDLElBQVgsQ0FBZ0JPLFFBQWhCLENBQXlCNUIsVUFBVSxDQUFDeUssU0FBcEM7QUFDQS9ILDBFQUFvQixDQUFDMUMsVUFBVSxDQUFDMEssV0FBWixFQUF5QixLQUFLdEosS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnlELFVBQS9DLENBQXBCO0FBQ0g7QUEvWUw7QUFBQTtBQUFBLHdDQWlad0JrSCxJQWpaeEIsRUFpWjhCO0FBQ3RCQyxhQUFPLENBQUNDLEtBQVIsQ0FBY0YsSUFBZDtBQUNBLFdBQUtHLGNBQUw7QUFDQSxXQUFLaEIsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCQyxrQkFBM0I7QUFDQSxVQUFJQyxrQkFBa0IsR0FBRyxLQUFLN0osS0FBTCxDQUFXdEIsYUFBWCxDQUF5Qm9KLGVBQXpCLEVBQXpCO0FBQ0EsV0FBSzlILEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUJvSixlQUF6QixDQUF5QyxLQUF6QztBQUNBLFVBQUluSixVQUFVLEdBQUc0SyxJQUFJLENBQUM1SyxVQUF0QjtBQUNBLFdBQUtxQixLQUFMLENBQVdyQixVQUFYLENBQXNCdUIsRUFBdEIsQ0FBeUJ2QixVQUFVLENBQUN1QixFQUFwQztBQUNBLFdBQUtGLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JnRCxPQUF0QixDQUE4QmhELFVBQVUsQ0FBQ2dELE9BQXpDO0FBQ0EsV0FBSzNCLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0I2QixRQUF0QixDQUErQjdCLFVBQVUsQ0FBQzBLLFNBQTFDO0FBQ0EsV0FBS3JKLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0I2QyxRQUF0QixDQUErQjdDLFVBQVUsQ0FBQ21MLFNBQTFDO0FBQ0EsV0FBSzlKLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0I4QyxhQUF0QixDQUFvQzlDLFVBQVUsQ0FBQ29MLGNBQS9DO0FBQ0EsV0FBSy9KLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JvRCxNQUF0QixDQUE2QnBELFVBQVUsQ0FBQ29ELE1BQXhDO0FBQ0EsV0FBSy9CLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JtRCxRQUF0QixDQUErQm5ELFVBQVUsQ0FBQ21ELFFBQTFDO0FBQ0EsV0FBSzlCLEtBQUwsQ0FBV3JCLFVBQVgsV0FBNkJBLFVBQVUsVUFBdkM7QUFDQSxXQUFLcUIsS0FBTCxDQUFXckIsVUFBWCxDQUFzQmlDLElBQXRCLENBQTJCakMsVUFBVSxDQUFDaUMsSUFBdEM7QUFDQSxXQUFLWixLQUFMLENBQVdyQixVQUFYLENBQXNCZ0MsR0FBdEIsQ0FBMEJoQyxVQUFVLENBQUNnQyxHQUFyQztBQUNBLFdBQUtYLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0JvQyxNQUF0QixDQUE2QnBDLFVBQVUsQ0FBQ29DLE1BQXhDO0FBQ0EsV0FBS2YsS0FBTCxDQUFXckIsVUFBWCxDQUFzQnFELFFBQXRCLENBQStCckQsVUFBVSxDQUFDcUwsU0FBMUM7QUFDQSxXQUFLaEssS0FBTCxDQUFXckIsVUFBWCxDQUFzQitCLFlBQXRCLENBQW1DL0IsVUFBVSxDQUFDK0IsWUFBOUM7QUFDQSxXQUFLVixLQUFMLENBQVdyQixVQUFYLENBQXNCMEIsSUFBdEIsQ0FBMkIxQixVQUFVLENBQUMwQixJQUF0QztBQUNBLFdBQUtMLEtBQUwsQ0FBV3JCLFVBQVgsQ0FBc0J1QyxRQUF0QixDQUErQnZDLFVBQVUsQ0FBQ3NMLFNBQVgsSUFBd0IsSUFBdkQ7O0FBQ0EsVUFBSXRMLFVBQVUsQ0FBQ3NMLFNBQWYsRUFBMEI7QUFDdEIsYUFBS3ZCLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQk8sT0FBM0IsQ0FBbUMsZUFBbkMsRUFBb0R2TCxVQUFVLENBQUNzTCxTQUEvRDtBQUNIOztBQUNELFdBQUtqSyxLQUFMLENBQVdyQixVQUFYLENBQXNCd0MsTUFBdEIsQ0FBNkJ4QyxVQUFVLENBQUN3TCxPQUFYLElBQXNCLElBQW5EOztBQUNBLFVBQUl4TCxVQUFVLENBQUN3TCxPQUFmLEVBQXdCO0FBQ3BCLGFBQUt6QixVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DLGFBQW5DLEVBQWtEdkwsVUFBVSxDQUFDd0wsT0FBN0Q7QUFDSDs7QUFDRCxXQUFLbkssS0FBTCxDQUFXckIsVUFBWCxDQUFzQnNDLEtBQXRCLENBQTRCdEMsVUFBVSxDQUFDeUwsTUFBdkM7QUFDQSxXQUFLcEssS0FBTCxDQUFXckIsVUFBWCxDQUFzQnFDLFlBQXRCLENBQW1DckMsVUFBVSxDQUFDa0ssYUFBOUM7QUFDQSxXQUFLN0ksS0FBTCxDQUFXckIsVUFBWCxDQUFzQitDLE9BQXRCLENBQThCL0MsVUFBVSxDQUFDMEwsUUFBekM7QUFDQSxXQUFLQyxRQUFMLENBQWMzTCxVQUFVLENBQUNpRCxJQUF6QjtBQUNBLFdBQUsySSxxQkFBTCxDQUEyQjVMLFVBQVUsQ0FBQzZMLGtCQUF0QztBQUNBbEosMEVBQW9CLENBQUMzQyxVQUFVLENBQUM4TCxzQkFBWixFQUFvQyxLQUFLekssS0FBTCxDQUFXckIsVUFBWCxDQUFzQnlDLG9CQUExRCxDQUFwQjtBQUNBRSwwRUFBb0IsQ0FBQzNDLFVBQVUsQ0FBQ21LLG9CQUFaLEVBQWtDLEtBQUs5SSxLQUFMLENBQVdyQixVQUFYLENBQXNCNEMsa0JBQXhELENBQXBCO0FBQ0FtSixpR0FBc0IsQ0FBQyxLQUFLMUssS0FBTixFQUFhckIsVUFBVSxDQUFDc0QsUUFBeEIsQ0FBdEI7QUFDQSxXQUFLMEksY0FBTCxDQUFvQnBCLElBQUksQ0FBQzNLLFVBQXpCLEVBQXFDRCxVQUFyQztBQUNBLFdBQUtxQixLQUFMLENBQVcyQyxPQUFYLENBQW1Cb0IsZUFBbkIsQ0FBbUMsSUFBbkM7QUFDQSxXQUFLL0QsS0FBTCxDQUFXMkMsT0FBWCxDQUFtQmtCLG1CQUFuQixDQUF1QyxJQUF2QztBQUNBLFdBQUs3RCxLQUFMLENBQVd0QixhQUFYLENBQXlCb0osZUFBekIsQ0FBeUMrQixrQkFBekM7QUFDQSxXQUFLbkIsVUFBTCxDQUFnQmtDLE1BQWhCLENBQXVCQyxZQUF2QixDQUFvQyxJQUFwQztBQUNBLFdBQUtuQyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJDLEVBQTdCLENBQWdDQyxPQUFoQztBQUVBLFdBQUt0QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnNDLFNBQXZCLENBQWlDLFVBQWpDLEVBQTZDdEcscURBQVcsQ0FBQ0MsS0FBekQ7QUFDSDtBQTliTDtBQUFBO0FBQUEsdUNBZ2N1QjtBQUFBOztBQUNmLFVBQUlzRyxJQUFJLEdBQUcsSUFBWDtBQUNBLFVBQUlsTCxLQUFLLEdBQUcsS0FBS0EsS0FBakI7QUFDQUEsV0FBSyxDQUFDbUwsRUFBTixHQUFXO0FBQ1BDLG1CQUFXLEVBQUVqTCxFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsaUJBQ3pCLENBQUNyTCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFBRCxJQUErQjdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQm1KLFdBQTFCLEVBRE47QUFBQSxTQUFoQixDQUROO0FBR1A5SyxZQUFJLEVBQUU7QUFDRmdMLGtCQUFRLEVBQUVuTCxFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQ3RCckwsS0FBSyxDQUFDQyxJQUFOLENBQVdLLElBQVgsT0FBc0IsT0FBdEIsSUFBaUNOLEtBQUssQ0FBQ0MsSUFBTixDQUFXSyxJQUFYLE9BQXNCLFFBRGpDO0FBQUEsV0FBaEI7QUFEUixTQUhDO0FBT1BJLG9CQUFZLEVBQUU7QUFDVjZLLG1CQUFTLEVBQUVwTCxFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQ3ZCckwsS0FBSyxDQUFDMkMsT0FBTixDQUFja0IsbUJBQWQsT0FBd0MsSUFEakI7QUFBQSxXQUFoQixDQUREO0FBSVYySCxpQkFBTyxFQUFFckwsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNyQnJMLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU3pLLFlBQVQsQ0FBc0I2SyxTQUF0QixLQUNJTCxJQUFJLENBQUNPLFNBQUwsQ0FBZUMsUUFBZixDQUF3QjFMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY2tCLG1CQUFkLEVBQXhCLENBREosR0FFSXFILElBQUksQ0FBQ08sU0FBTCxDQUFlQyxRQUFmLENBQXdCMUwsS0FBSyxDQUFDckIsVUFBTixDQUFpQitCLFlBQWpCLEVBQXhCLENBSGlCO0FBQUEsV0FBaEIsQ0FKQztBQVNWaUwsZUFBSyxFQUFFO0FBQUEsbUJBQ0gzTCxLQUFLLENBQUMyQyxPQUFOLENBQWNrQixtQkFBZCxDQUFrQyxJQUFsQyxDQURHO0FBQUE7QUFURyxTQVBQO0FBbUJQK0gsWUFBSSxFQUFFO0FBQ0ZDLGlCQUFPLEVBQUUxTCxFQUFFLENBQUNrTCxZQUFILENBQ0w7QUFBQSxtQkFDSXJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4QixDQUFDN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCNkosZUFBMUIsRUFEbkM7QUFBQSxXQURLLENBRFA7QUFLRkMsd0JBQWMsRUFBRTVMLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDM0JyTCxLQUFLLENBQUMyQyxPQUFOLENBQWNxQixVQUFkLEVBQUQsR0FBK0Isd0JBQS9CLEdBQTBELHNCQUQ5QjtBQUFBLFdBQWhCLENBTGQ7QUFRRmdJLHlCQUFlLEVBQUUsMkJBQUs7QUFDbEJoTSxpQkFBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixDQUFDaEUsS0FBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxFQUExQjtBQUNILFdBVkM7QUFXRmlJLG9CQUFVLEVBQUUsc0JBQU07QUFDZCxpQkFBSSxDQUFDdkQsVUFBTCxDQUFnQndELE1BQWhCLENBQXVCQyxXQUF2QjtBQUNILFdBYkM7QUFjRkMsc0JBQVksRUFBRSx3QkFBTTtBQUNoQixnQkFBSXBNLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY3dCLFlBQWQsRUFBSixFQUFrQztBQUM5QitHLGtCQUFJLENBQUN4QyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJDLEVBQTdCLENBQWdDc0IsVUFBaEMsQ0FBMkNDLGFBQTNDO0FBQ0gsYUFGRCxNQUVPO0FBQ0hwQixrQkFBSSxDQUFDeEMsVUFBTCxDQUFnQm9DLFlBQWhCLENBQTZCQyxFQUE3QixDQUFnQ3NCLFVBQWhDLENBQTJDRSxZQUEzQztBQUNIOztBQUNEdk0saUJBQUssQ0FBQzJDLE9BQU4sQ0FBY3dCLFlBQWQsQ0FBMkIsQ0FBQ25FLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY3dCLFlBQWQsRUFBNUI7QUFDSCxXQXJCQztBQXNCRnFJLDBCQUFnQixFQUFFck0sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUM5QnJMLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJvRCxNQUFqQixNQUE2Qi9CLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJtRCxRQUFqQixFQUE3QixJQUNBOUIsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCd0ssUUFBMUIsRUFGOEI7QUFBQSxXQUFoQixDQXRCaEI7QUEwQkZDLDJCQUFpQixFQUFFdk0sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQixZQUFNO0FBQ3JDLGdCQUFJckwsS0FBSyxDQUFDbUwsRUFBTixDQUFTUyxJQUFULENBQWNlLFdBQWQsRUFBSixFQUFpQztBQUM3QixxQkFBTzNNLEtBQUssQ0FBQ0MsSUFBTixDQUFXUSxPQUFYLEtBQXVCLGdCQUF2QixHQUEwQyxtQkFBakQ7QUFDSCxhQUZELE1BRU8sSUFBSVQsS0FBSyxDQUFDbUwsRUFBTixDQUFTUyxJQUFULENBQWNnQixXQUFkLEVBQUosRUFBaUM7QUFDcEMscUJBQU8sb0JBQVA7QUFDSCxhQUZNLE1BRUEsSUFBSTVNLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY29CLGVBQWQsRUFBSixFQUFxQztBQUN4QyxxQkFBTyxLQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0gsa0JBQUksQ0FBQy9ELEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJvRCxNQUFqQixFQUFELElBQThCL0IsS0FBSyxDQUFDcEIsVUFBTixDQUFpQjRELE9BQWpCLEVBQWxDLEVBQThEO0FBQzFELHVCQUFPLFFBQVA7QUFDSCxlQUZELE1BRU87QUFDSCx1QkFBTyxjQUFQO0FBQ0g7QUFDSjtBQUNKLFdBZGtCLENBMUJqQjtBQXlDRnFLLDRCQUFrQixFQUFFLDhCQUFNO0FBQ3RCLGdCQUFJN00sS0FBSyxDQUFDbUwsRUFBTixDQUFTUyxJQUFULENBQWNlLFdBQWQsRUFBSixFQUFpQztBQUM3QkcsbUJBQUssQ0FBQyx5REFBRCxDQUFMO0FBQ0gsYUFGRCxNQUVPLElBQUk5TSxLQUFLLENBQUNtTCxFQUFOLENBQVNTLElBQVQsQ0FBY2dCLFdBQWQsRUFBSixFQUFpQztBQUNwQzFCLGtCQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjdDLHNCQUF2QixDQUE4QyxZQUE5QztBQUNILGFBRk0sTUFFQSxJQUFJOUYsS0FBSyxDQUFDMkMsT0FBTixDQUFjb0IsZUFBZCxFQUFKLEVBQXFDO0FBQ3hDbUgsa0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JxRSxNQUFoQixDQUF1QkMsVUFBdkI7QUFDSCxhQUZNLE1BRUE7QUFDSDlCLGtCQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QjdDLHNCQUF2QixDQUE4QyxXQUE5QztBQUNIO0FBQ0osV0FuREM7QUFvREY4RyxxQkFBVyxFQUFFek0sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUN6QixDQUFDckwsS0FBSyxDQUFDckIsVUFBTixDQUFpQm1ELFFBQWpCLE1BQStCOUIsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCd0ssUUFBMUIsRUFBaEMsS0FDQXpNLEtBQUssQ0FBQ3BCLFVBQU4sQ0FBaUI2RCxnQkFBakIsR0FBb0N3SyxXQUFwQyxPQUFzRCxXQUY3QjtBQUFBLFdBQWhCLENBcERYO0FBd0RGTixxQkFBVyxFQUFFeE0sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUN6QnJMLEtBQUssQ0FBQ3BCLFVBQU4sQ0FBaUI2RCxnQkFBakIsR0FBb0N3SyxXQUFwQyxPQUFzRCxXQUQ3QjtBQUFBLFdBQWhCLENBeERYO0FBMkRGQywwQkFBZ0IsRUFBRS9NLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDOUIsQ0FBQ3JMLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmtMLGdCQUExQixFQUQ2QjtBQUFBLFdBQWhCLENBM0RoQjtBQThERkMsbUJBQVMsRUFBRWpOLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdkIsQ0FBQ3JMLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQm9MLFFBQTFCLEVBRHNCO0FBQUEsV0FBaEI7QUE5RFQsU0FuQkM7QUFxRlBDLGlCQUFTLEVBQUU7QUFDUEMsZUFBSyxFQUFFcE4sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNuQnJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4QixDQUFDN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCbUosV0FBMUIsRUFBL0IsR0FDSSxXQURKLEdBQ2tCLFVBRkM7QUFBQSxXQUFoQixDQURBO0FBS1BvQyx5QkFBZSxFQUFFck4sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUM3QixDQUFDckwsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLEVBQUQsSUFBK0I3QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEJ1TCxlQUExQixFQURGO0FBQUEsV0FBaEIsQ0FMVjtBQVFQQyxzQkFBWSxFQUFFdE4sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUMxQixDQUFDckwsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCeUwsZUFBMUIsRUFEeUI7QUFBQSxXQUFoQixDQVJQO0FBV1BDLDJCQUFpQixFQUFFeE4sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUMvQnJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY1ksb0JBQWQsT0FBeUNDLHdFQUEyQixDQUFDQyxRQUR0QztBQUFBLFdBQWhCLENBWFo7QUFjUG1LLHdCQUFjLEVBQUV6TixFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQzVCckwsS0FBSyxDQUFDMkMsT0FBTixDQUFjWSxvQkFBZCxPQUF5Q0Msd0VBQTJCLENBQUNxSyxLQUR6QztBQUFBLFdBQWhCLENBZFQ7QUFpQlBDLDhCQUFvQixFQUFFM04sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNsQ3JMLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU21DLFNBQVQsQ0FBbUJLLGlCQUFuQixNQUEwQzNOLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU21DLFNBQVQsQ0FBbUJNLGNBQW5CLEVBRFI7QUFBQSxXQUFoQixDQWpCZjtBQW9CUEcscUJBQVcsRUFBRTVOLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDekJyTCxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsT0FBdUMsSUFBdkMsR0FDSSxZQURKLEdBQ21CLEVBRk07QUFBQSxXQUFoQixDQXBCTjtBQXdCUGtILHNCQUFZLEVBQUUsd0JBQVk7QUFDdEIsZ0JBQUlDLFlBQVksR0FBR2pPLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY1ksb0JBQWpDOztBQUNBLGdCQUFJMEssWUFBWSxPQUFPekssd0VBQTJCLENBQUMwSyxJQUFuRCxFQUF5RDtBQUNyREQsMEJBQVksQ0FBQ3pLLHdFQUEyQixDQUFDQyxRQUE3QixDQUFaO0FBQ0gsYUFGRCxNQUVPLElBQUl3SyxZQUFZLE9BQU96Syx3RUFBMkIsQ0FBQ3FLLEtBQW5ELEVBQTBEO0FBQzdESSwwQkFBWSxDQUFDekssd0VBQTJCLENBQUMwSyxJQUE3QixDQUFaO0FBQ0gsYUFGTSxNQUVBLElBQUlsTyxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsT0FBdUMsSUFBM0MsRUFBaUQ7QUFDcERtSCwwQkFBWSxDQUFDekssd0VBQTJCLENBQUNxSyxLQUE3QixDQUFaO0FBQ0gsYUFGTSxNQUVBO0FBQ0hJLDBCQUFZLENBQUN6Syx3RUFBMkIsQ0FBQzBLLElBQTdCLENBQVo7QUFDSDtBQUNKLFdBbkNNO0FBb0NQQyxrQkFBUSxFQUFFLG9CQUFZO0FBQ2xCLGdCQUFNRixZQUFZLEdBQUdqTyxLQUFLLENBQUMyQyxPQUFOLENBQWNZLG9CQUFuQztBQUNBdkQsaUJBQUssQ0FBQzJDLE9BQU4sQ0FBY2UsNEJBQWQsQ0FBMkN1SyxZQUFZLEVBQXZEO0FBQ0FBLHdCQUFZLENBQUN6Syx3RUFBMkIsQ0FBQzBLLElBQTdCLENBQVo7QUFDSCxXQXhDTTtBQXlDUEUsc0JBQVksRUFBRSx3QkFBVztBQUNyQixnQkFBTUMsUUFBUSxHQUFHck8sS0FBSyxDQUFDMkMsT0FBTixDQUFjZSw0QkFBL0I7O0FBQ0EsZ0JBQUkySyxRQUFRLE9BQU8sSUFBbkIsRUFBeUI7QUFDckJyTyxtQkFBSyxDQUFDMkMsT0FBTixDQUFjWSxvQkFBZCxDQUFtQzhLLFFBQVEsRUFBM0M7QUFDQUEsc0JBQVEsQ0FBQyxJQUFELENBQVI7QUFDSDtBQUNKO0FBL0NNLFNBckZKO0FBc0lQN0UsZUFBTyxFQUFFO0FBQ0w4RSxjQUFJLEVBQUVuTyxFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQ2pCLENBQUNyTCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsRUFBRCxJQUErQjdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQm1KLFdBQTFCLEVBQWhDLElBQ0NwTCxLQUFLLENBQUMyQyxPQUFOLENBQWNZLG9CQUFkLE9BQXlDQyx3RUFBMkIsQ0FBQzBLLElBRHRFLEdBRUksV0FGSixHQUdJLFVBSmM7QUFBQSxXQUFoQixDQUREO0FBT0xLLHNCQUFZLEVBQUVwTyxFQUFFLENBQUNrTCxZQUFILENBQWlCO0FBQUEsbUJBQzNCckwsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCc00sWUFBMUIsTUFBNEMsQ0FBQ3ZPLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCUSxPQUF4QixFQUE3QyxJQUNBcEgsS0FBSyxDQUFDeUUsTUFBTixDQUFhNkIsV0FBYixPQUErQjNCLHFEQUFXLENBQUM2SixNQUZoQjtBQUFBLFdBQWpCO0FBUFQsU0F0SUY7QUFrSlBqSCxnQkFBUSxFQUFFO0FBQ05rSCxlQUFLLEVBQUV0TyxFQUFFLENBQUNrTCxZQUFILENBQWdCLFlBQVk7QUFDL0IsZ0JBQUlyTCxLQUFLLENBQUN1RyxTQUFOLENBQWdCZ0IsUUFBaEIsQ0FBeUJFLFFBQXpCLE9BQXdDLElBQTVDLEVBQWtEO0FBQzlDLHFCQUFPLFlBQVA7QUFDSDs7QUFDRCxvQkFBUXpILEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JnQixRQUFoQixDQUF5QkUsUUFBekIsR0FBb0N3RixXQUFwQyxFQUFSO0FBQ0k7QUFDQSxtQkFBSyxNQUFMO0FBQ0ksdUJBQU8sWUFBUDs7QUFDSixtQkFBSyxTQUFMO0FBQ0ksdUJBQU8scUJBQVA7O0FBQ0osbUJBQUssUUFBTDtBQUNJLHVCQUFPLG9CQUFQOztBQUNKLG1CQUFLLFFBQUw7QUFDSSx1QkFBTyxvQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0ksdUJBQU8sc0JBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNBLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyxzQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0EsbUJBQUssWUFBTDtBQUNJLHVCQUFPLHNCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDSSx1QkFBTyx3QkFBUDs7QUFDSixtQkFBSyxjQUFMO0FBQ0ksdUJBQU8sb0JBQVA7O0FBQ0osbUJBQUssV0FBTDtBQUNJLHVCQUFPLGlCQUFQO0FBdkJSO0FBeUJILFdBN0JNLENBREQ7QUErQk54RixrQkFBUSxFQUFFdEgsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQixZQUFZO0FBQ2xDLGdCQUFJckwsS0FBSyxDQUFDdUcsU0FBTixDQUFnQmdCLFFBQWhCLENBQXlCRSxRQUF6QixPQUF3QyxJQUE1QyxFQUFrRDtBQUM5QyxxQkFBTyxFQUFQO0FBQ0g7O0FBQ0Qsb0JBQVF6SCxLQUFLLENBQUN1RyxTQUFOLENBQWdCZ0IsUUFBaEIsQ0FBeUJFLFFBQXpCLEdBQW9Dd0YsV0FBcEMsRUFBUjtBQUNJO0FBQ0EsbUJBQUssTUFBTDtBQUNJLHVCQUFPLEVBQVA7O0FBQ0osbUJBQUssU0FBTDtBQUNJLHVCQUFPLGVBQVA7O0FBQ0osbUJBQUssUUFBTDtBQUNJLHVCQUFPLGNBQVA7O0FBQ0osbUJBQUssUUFBTDtBQUNJLHVCQUFPLGNBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNJLHVCQUFPLGdCQUFQOztBQUNKLG1CQUFLLFVBQUw7QUFDQSxtQkFBSyxVQUFMO0FBQ0ksdUJBQU8saUJBQVA7O0FBQ0osbUJBQUssVUFBTDtBQUNBLG1CQUFLLGNBQUw7QUFDSSx1QkFBTyxjQUFQOztBQUNKLG1CQUFLLFlBQUw7QUFDSSx1QkFBTyxrQkFBUDs7QUFDSixtQkFBSyxVQUFMO0FBQ0ksdUJBQU8sVUFBUDs7QUFDSixtQkFBSyxXQUFMO0FBQ0ksdUJBQU8sV0FBUDtBQXZCUjtBQXlCSCxXQTdCUyxDQS9CSjtBQTZETnlCLG9CQUFVLEVBQUUsc0JBQU07QUFDZDFPLGlCQUFLLENBQUNwQixVQUFOLENBQWlCMkQsS0FBakIsQ0FBdUIsQ0FBdkI7QUFDQXZDLGlCQUFLLENBQUNwQixVQUFOLENBQWlCNEQsT0FBakIsQ0FBeUIsS0FBekI7QUFDQTBJLGdCQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1Qi9DLGdCQUF2QixDQUF3QzVGLEtBQUssQ0FBQ3BCLFVBQU4sQ0FBaUIyRCxLQUFqQixFQUF4QyxFQUFrRXZDLEtBQUssQ0FBQ3BCLFVBQU4sQ0FBaUI0RCxPQUFqQixFQUFsRSxFQUE4RixJQUE5RixFQUFvRyxJQUFwRztBQUNIO0FBakVLLFNBbEpIO0FBcU5QbU0sYUFBSyxFQUFFO0FBQ0g5TyxhQUFHLEVBQUVNLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDakJyTCxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLE9BQStDLElBRDlCO0FBQUEsV0FBaEIsQ0FERjtBQUlIMkgseUJBQWUsRUFBRXpPLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0IsWUFBTTtBQUNuQyxnQkFBSXJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY1ksb0JBQWQsT0FBeUNDLHdFQUEyQixDQUFDcUssS0FBekUsRUFBZ0Y7QUFDNUUscUJBQU8sRUFBUDtBQUNIOztBQUNELGdCQUFJZ0IsSUFBSSxHQUFHN08sS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixFQUFYO0FBQ0EsZ0JBQUlKLFFBQVEsR0FBRzlHLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUFmO0FBQ0EsZ0JBQUlnSSxTQUFTLEdBQUc5TyxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLEVBQWhCOztBQUNBLGdCQUFJLENBQUM2SCxTQUFELElBQWNELElBQUksS0FBSyxJQUEzQixFQUFpQztBQUM3QixxQkFBTyxFQUFQO0FBQ0gsYUFGRCxNQUVPLElBQUlBLElBQUksS0FBSyxDQUFiLEVBQWdCO0FBQ25CLHFCQUFPLEVBQVA7QUFDSCxhQUZNLE1BRUE7QUFDSCxxQkFBTyxDQUFDQyxTQUFTLENBQUNELElBQUksR0FBQyxDQUFOLENBQVQsQ0FBa0JFLElBQW5CLENBQVA7QUFDSDtBQUNKLFdBZGdCLENBSmQ7QUFtQkhBLGNBQUksRUFBRTVPLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0IsWUFBWTtBQUM5QixnQkFBSXdELElBQUksR0FBRzdPLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsRUFBWDtBQUNBLGdCQUFJSixRQUFRLEdBQUc5RyxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBZjtBQUNBLGdCQUFJZ0ksU0FBUyxHQUFHOU8sS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JLLGdCQUF4QixFQUFoQjs7QUFDQSxnQkFBSSxDQUFDNkgsU0FBRCxJQUFjRCxJQUFJLEtBQUssSUFBM0IsRUFBaUM7QUFDN0IscUJBQU8sVUFBUDtBQUNIOztBQUNELGdCQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNaLHFCQUFPLFlBQVA7QUFDSCxhQUZELE1BRU8sSUFBSUEsSUFBSSxLQUFLL0gsUUFBYixFQUF1QjtBQUMxQixxQkFBTyxjQUFQO0FBQ0gsYUFGTSxNQUVBO0FBQ0g7QUFDQSxxQkFBTyxVQUFTZ0ksU0FBUyxDQUFDRCxJQUFJLEdBQUMsQ0FBTixDQUFULENBQWtCRSxJQUFsQztBQUNIO0FBQ0osV0FmSyxDQW5CSDtBQW1DSEMsYUFBRyxFQUFFN08sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQixZQUFZO0FBQzdCLGdCQUFJd0QsSUFBSSxHQUFHN08sS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixFQUFYO0FBQ0EsZ0JBQUlKLFFBQVEsR0FBRzlHLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCRSxRQUF4QixFQUFmO0FBQ0EsZ0JBQUlnSSxTQUFTLEdBQUc5TyxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkssZ0JBQXhCLEVBQWhCOztBQUNBLGdCQUFJLENBQUM2SCxTQUFMLEVBQWdCO0FBQ1oscUJBQU8sRUFBUDtBQUNIOztBQUNELG9CQUFRRCxJQUFSO0FBQ0ksbUJBQUssQ0FBTDtBQUNJLHVCQUFPLG9CQUFQOztBQUNKLG1CQUFLL0gsUUFBTDtBQUNJLHVCQUFPLG9CQUFQOztBQUNKO0FBQ0ksdUJBQU8sbUJBQW1CbUksd0RBQWdCLENBQUNILFNBQVMsQ0FBQ0QsSUFBSSxHQUFDLENBQU4sQ0FBVCxDQUFrQkcsR0FBbkIsQ0FBMUM7QUFOUjtBQVFILFdBZkksQ0FuQ0Y7QUFtREhFLGVBQUssRUFBRSxpQkFBWTtBQUNmbFAsaUJBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsQ0FBeUMsQ0FBekM7QUFDSCxXQXJERTtBQXNESGlJLGtCQUFRLEVBQUUsb0JBQVk7QUFDbEIsZ0JBQUlDLFFBQVEsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZdFAsS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixLQUE2QyxDQUF6RCxDQUFmO0FBQ0FsSCxpQkFBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JNLGdCQUF4QixDQUF5Q2tJLFFBQXpDO0FBQ0gsV0F6REU7QUEwREhHLGlCQUFPLEVBQUUsbUJBQVk7QUFDakIsZ0JBQUlDLElBQUksR0FBR0gsSUFBSSxDQUFDSSxHQUFMLENBQVN6UCxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3QkUsUUFBeEIsRUFBVCxFQUE2QzlHLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsS0FBNkMsQ0FBMUYsQ0FBWDtBQUNBbEgsaUJBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCTSxnQkFBeEIsQ0FBeUNzSSxJQUF6QztBQUNILFdBN0RFO0FBOERIRSxjQUFJLEVBQUUsZ0JBQVk7QUFDZDFQLGlCQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLENBQXlDbEgsS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JFLFFBQXhCLEVBQXpDO0FBQ0gsV0FoRUU7QUFpRUh5QyxjQUFJLEVBQUVwSixFQUFFLENBQUNrTCxZQUFILENBQWdCLFlBQVk7QUFDOUIsZ0JBQUl3RCxJQUFJLEdBQUc3TyxLQUFLLENBQUN1RyxTQUFOLENBQWdCSyxPQUFoQixDQUF3Qk0sZ0JBQXhCLEVBQVg7QUFDQSxnQkFBSUosUUFBUSxHQUFHOUcsS0FBSyxDQUFDdUcsU0FBTixDQUFnQkssT0FBaEIsQ0FBd0JFLFFBQXhCLEVBQWY7QUFDQSxnQkFBSWdJLFNBQVMsR0FBRzlPLEtBQUssQ0FBQ3VHLFNBQU4sQ0FBZ0JLLE9BQWhCLENBQXdCSyxnQkFBeEIsRUFBaEI7O0FBQ0EsZ0JBQUksQ0FBQzZILFNBQUwsRUFBZ0I7QUFDWixxQkFBTyxFQUFQO0FBQ0g7O0FBQ0Qsb0JBQVFELElBQVI7QUFDSSxtQkFBSyxDQUFMO0FBQ0ksdUJBQU8sRUFBUDs7QUFDSixtQkFBSy9ILFFBQUw7QUFDSSx1QkFBT2dJLFNBQVMsQ0FBQ0QsSUFBSSxHQUFHLENBQVIsQ0FBaEI7O0FBQ0o7QUFDSSx1QkFBT0MsU0FBUyxDQUFDRCxJQUFELENBQWhCO0FBTlI7QUFRSCxXQWZLO0FBakVILFNBck5BO0FBdVNQYyxhQUFLLEVBQUU7QUFDSDlELGlCQUFPLEVBQUUxTCxFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQ3JCckwsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLE1BQThCLENBQUM3QyxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIyTixTQUExQixFQURWO0FBQUEsV0FBaEIsQ0FETjtBQUlIckMsZUFBSyxFQUFFcE4sRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNuQnJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4QixDQUFDN0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCbUosV0FBMUIsRUFBL0IsR0FDSSxXQURKLEdBQ2tCLFVBRkM7QUFBQSxXQUFoQixDQUpKO0FBUUh5RSxxQkFBVyxFQUFFLHFCQUFTQyxJQUFULEVBQWU7QUFDeEIsb0JBQVFBLElBQVI7QUFDSSxtQkFBSyxXQUFMO0FBQWtCLHVCQUFPOVAsS0FBSyxDQUFDcEIsVUFBTixDQUFpQnVELElBQWpCLEVBQVA7O0FBQ2xCLG1CQUFLLGtCQUFMO0FBQXlCLHVCQUFPbkMsS0FBSyxDQUFDckIsVUFBTixDQUFpQitCLFlBQWpCLEVBQVA7O0FBQ3pCLG1CQUFLLGVBQUw7QUFBc0IsdUJBQU9WLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ1QyxRQUFqQixPQUFnQyxJQUF2Qzs7QUFDdEIsbUJBQUssYUFBTDtBQUFvQix1QkFBT2xCLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ3QyxNQUFqQixPQUE4QixJQUFyQzs7QUFDcEIsbUJBQUssb0JBQUw7QUFBMkIsdUJBQU9uQixLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDMk8sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUMvRUEsSUFBSSxDQUFDcE4sUUFBTCxPQUFvQixvQkFEMkQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFM0IsbUJBQUssaUJBQUw7QUFBd0IsdUJBQU81QyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDMk8sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM1RUEsSUFBSSxDQUFDcE4sUUFBTCxPQUFvQixpQkFEd0Q7QUFBQSxpQkFBakQsQ0FBUDs7QUFFeEIsbUJBQUssbUJBQUw7QUFBMEIsdUJBQU81QyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDMk8sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM5RUEsSUFBSSxDQUFDcE4sUUFBTCxPQUFvQixtQkFEMEQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFMUIsbUJBQUssbUJBQUw7QUFBMEIsdUJBQU81QyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDMk8sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM5RUEsSUFBSSxDQUFDcE4sUUFBTCxPQUFvQixtQkFEMEQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFMUIsbUJBQUssa0JBQUw7QUFBeUIsdUJBQU81QyxLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWpCLEdBQXdDMk8sSUFBeEMsQ0FBNkMsVUFBQUMsSUFBSTtBQUFBLHlCQUM3RUEsSUFBSSxDQUFDcE4sUUFBTCxPQUFvQixrQkFEeUQ7QUFBQSxpQkFBakQsQ0FBUDs7QUFFekIsbUJBQUssZUFBTDtBQUFzQix1QkFBTzVDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJpRCxJQUFqQixHQUF3QnFPLE1BQS9COztBQUN0QixtQkFBSyw2QkFBTDtBQUFvQyx1QkFBT2pRLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJrRCxpQkFBakIsR0FBcUNvTyxNQUE1Qzs7QUFDcEM7QUFBUyx1QkFBTyxLQUFQO0FBakJiO0FBbUJILFdBNUJFO0FBNkJIQyxhQUFHLEVBQUUsYUFBU0osSUFBVCxFQUFlO0FBQ2hCLG9CQUFRQSxJQUFSO0FBQ0ksbUJBQUssb0JBQUw7QUFDQSxtQkFBSyxtQkFBTDtBQUNBLG1CQUFLLG1CQUFMO0FBQ0EsbUJBQUssZUFBTDtBQUNBLG1CQUFLLG1CQUFMO0FBQ0k1RSxvQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQzRGLElBQW5DO0FBQ0E7O0FBQ0osbUJBQUssaUJBQUw7QUFDSTVFLG9CQUFJLENBQUN4QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEYsSUFBbkMsRUFBeUMsSUFBekM7QUFDQTs7QUFDSixtQkFBSyxrQkFBTDtBQUNJLG9CQUFJSyxhQUFhLEdBQUdqRixJQUFJLENBQUN4QyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJDLEVBQTdCLENBQWdDcUYsV0FBaEMsQ0FBNENDLFNBQTVDLENBQXNELFFBQXRELENBQXBCO0FBQ0FGLDZCQUFhLEdBQUdHLElBQUksQ0FBQ0MsU0FBTCxDQUFlSixhQUFmLEVBQThCLElBQTlCLEVBQW9DLENBQXBDLENBQWhCO0FBQ0FqRixvQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQzRGLElBQW5DLEVBQXlDSyxhQUF6QztBQUNBOztBQUNKLG1CQUFLLDZCQUFMO0FBQ0luUSxxQkFBSyxDQUFDckIsVUFBTixDQUFpQmtELGlCQUFqQixDQUFtQyxDQUFDMk8sNEVBQWdCLENBQUNDLEtBQWpCLEVBQUQsQ0FBbkM7QUFDQXZGLG9CQUFJLENBQUN4QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJPLE9BQTNCLENBQW1DNEYsSUFBbkM7QUFDQTs7QUFDSixtQkFBSyxlQUFMO0FBQ0k5UCxxQkFBSyxDQUFDckIsVUFBTixDQUFpQnVDLFFBQWpCLENBQTBCLEVBQTFCO0FBQ0FnSyxvQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQzRGLElBQW5DO0FBQ0E7QUFDQTs7QUFDSixtQkFBSyxhQUFMO0FBQ0k5UCxxQkFBSyxDQUFDckIsVUFBTixDQUFpQndDLE1BQWpCLENBQXdCLEVBQXhCO0FBQ0ErSixvQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlCLFVBQWhCLENBQTJCTyxPQUEzQixDQUFtQzRGLElBQW5DO0FBQ0E7O0FBQ0osbUJBQUssWUFBTDtBQUNJNUUsb0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQitHLGFBQTNCLENBQXlDLFlBQXpDO0FBQ0E7O0FBQ0osbUJBQUssU0FBTDtBQUNJeEYsb0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQitHLGFBQTNCLENBQXlDLFNBQXpDO0FBQ0E7O0FBQ0osbUJBQUssVUFBTDtBQUNJeEYsb0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQitHLGFBQTNCLENBQXlDLFVBQXpDO0FBQ0E7O0FBQ0o7QUF0Q0o7O0FBeUNBMVEsaUJBQUssQ0FBQzJDLE9BQU4sQ0FBY0MsUUFBZCxDQUF1QmtOLElBQXZCO0FBQ0gsV0F4RUU7QUF5RUgsb0JBQVEsbUJBQVc7QUFDZixtQkFBTzVFLElBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQmdILFVBQTNCLENBQXNDM1EsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEVBQXRDLENBQVA7QUFDSCxXQTNFRTtBQTRFSGdPLGdCQUFNLEVBQUUsZ0JBQUNDLE9BQUQsRUFBYTtBQUNqQixtQkFBTzNGLElBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpQixVQUFoQixDQUEyQm1ILFVBQTNCLENBQXNDOVEsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEVBQXRDLEVBQWdFaU8sT0FBaEUsQ0FBUDtBQUNILFdBOUVFO0FBK0VIRSx3QkFBYyxFQUFFLDBCQUFXO0FBQ3ZCLGdCQUFJQyxRQUFRLEdBQUc5RixJQUFJLENBQUN4QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJzSCxPQUEzQixDQUFtQyxtQkFBbkMsQ0FBZjtBQUNBLGdCQUFJQyxRQUFRLEdBQUdoRyxJQUFJLENBQUN4QyxVQUFMLENBQWdCaUIsVUFBaEIsQ0FBMkJzSCxPQUEzQixDQUFtQyxtQkFBbkMsQ0FBZjtBQUNBLGdCQUFJOU8sSUFBSSxHQUFHK0ksSUFBSSxDQUFDbEwsS0FBTCxDQUFXcEIsVUFBWCxDQUFzQnVELElBQXRCLEVBQVg7O0FBQ0EsZ0JBQUk2TyxRQUFRLElBQUlBLFFBQVEsQ0FBQ0csTUFBckIsSUFBK0JILFFBQVEsQ0FBQ0csTUFBVCxFQUFuQyxFQUFzRDtBQUNsRGhQLGtCQUFJLEdBQUc2TyxRQUFRLENBQUNHLE1BQVQsS0FBb0JoUCxJQUEzQjtBQUNIOztBQUNELGdCQUFJK08sUUFBUSxJQUFJQSxRQUFRLENBQUNDLE1BQXJCLElBQStCRCxRQUFRLENBQUNDLE1BQVQsRUFBbkMsRUFBc0Q7QUFDbERoUCxrQkFBSSxHQUFHQSxJQUFJLEdBQUcrTyxRQUFRLENBQUNDLE1BQVQsRUFBZDtBQUNIOztBQUNELG1CQUFPaFAsSUFBUDtBQUNILFdBMUZFO0FBMkZIaVAsMkJBQWlCLEVBQUVDLHVFQUF1QixDQUFDclIsS0FBSyxDQUFDcEIsVUFBTixDQUFpQnlELFVBQWxCLENBM0Z2QztBQTRGSGpCLDhCQUFvQixFQUFFaVEsdUVBQXVCLENBQUNyUixLQUFLLENBQUNyQixVQUFOLENBQWlCeUMsb0JBQWxCLENBNUYxQztBQTZGSEcsNEJBQWtCLEVBQUU4UCx1RUFBdUIsQ0FBQ3JSLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUI0QyxrQkFBbEIsQ0E3RnhDO0FBOEZIK1AseUJBQWUsRUFBRSx5QkFBU3hCLElBQVQsRUFBZTtBQUM1QixnQkFBSUEsSUFBSSxLQUFLLG9CQUFiLEVBQW1DO0FBQy9CLHFCQUFPLFVBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxLQUFLLGlCQUFiLEVBQWdDO0FBQzVCLHFCQUFPLFFBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxLQUFLLG1CQUFiLEVBQWtDO0FBQzlCLHFCQUFPLGVBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxLQUFLLG1CQUFiLEVBQWtDO0FBQzlCLHFCQUFPLGVBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxLQUFLLGtCQUFiLEVBQWlDO0FBQzdCLHFCQUFPLFNBQVA7QUFDSDs7QUFDRCxnQkFBSUEsSUFBSSxDQUFDeUIsVUFBTCxDQUFnQixHQUFoQixDQUFKLEVBQTBCO0FBQ3RCLHFCQUFPekIsSUFBSSxDQUFDMEIsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUNELG1CQUFPMUIsSUFBUDtBQUNIO0FBbEhFLFNBdlNBO0FBMlpQMkIsZUFBTyxFQUFFO0FBQ0xqRyxpQkFBTyxFQUFFckwsRUFBRSxDQUFDa0wsWUFBSCxDQUFpQjtBQUFBLG1CQUN0QkgsSUFBSSxDQUFDeEMsVUFBTCxDQUFnQitJLE9BQWhCLENBQXdCQyxTQUF4QixDQUFrQzFSLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0MsUUFBZCxFQUFsQyxDQURzQjtBQUFBLFdBQWpCLENBREo7QUFJTDJLLGVBQUssRUFBRXBOLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDbkJyTCxLQUFLLENBQUMyQyxPQUFOLENBQWNFLFVBQWQsTUFBOEIsQ0FBQzdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQm1KLFdBQTFCLEVBQS9CLEdBQ0ksV0FESixHQUNrQixVQUZDO0FBQUEsV0FBaEIsQ0FKRjtBQVFMdUcsY0FBSSxFQUFFeFIsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNqQixDQUFDckwsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLEVBQUQsS0FDRzdDLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjJQLFdBQTFCLE1BQ0E1UixLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEI2SixlQUExQixFQUZILENBQUQsR0FFb0QsTUFGcEQsR0FHQTlMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0MsUUFBZCxLQUEyQjVDLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU3NHLE9BQVQsQ0FBaUJqRyxPQUFqQixFQUEzQixHQUF3RCxNQUp0QztBQUFBLFdBQWhCLENBUkQ7QUFjTEcsZUFBSyxFQUFFLGlCQUFXO0FBQ2RULGdCQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnZELFFBQXZCLENBQWdDLGNBQWhDLEVBQWdELEVBQWhELEVBQW9ELEVBQXBELEVBQXdELEVBQXhELEVBQTRELFdBQTVEO0FBQ0FwRixpQkFBSyxDQUFDcEIsVUFBTixDQUFpQnVELElBQWpCLENBQXNCbkMsS0FBSyxDQUFDckIsVUFBTixDQUFpQnFDLFlBQWpCLEVBQXRCO0FBQ0FoQixpQkFBSyxDQUFDcEIsVUFBTixDQUFpQnlELFVBQWpCLENBQTRCckMsS0FBSyxDQUFDckIsVUFBTixDQUFpQjRDLGtCQUFqQixHQUFzQ3NRLEdBQXRDLENBQ3hCLFVBQUE3QixJQUFJLEVBQUk7QUFDSixrQkFBSXBOLFFBQVEsR0FBR29OLElBQUksQ0FBQ3BOLFFBQUwsR0FBZ0JrUCxNQUFoQixDQUF1QixDQUF2QixDQUFmO0FBQ0EscUJBQU9DLDZEQUFhLENBQUNuUCxRQUFELEVBQVdvTixJQUFJLENBQUNnQyxRQUFMLEVBQVgsQ0FBcEI7QUFDSCxhQUp1QixDQUE1QjtBQU1ILFdBdkJJO0FBd0JMQyxpQkFBTyxFQUFFOVIsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUNyQixDQUFDckwsS0FBSyxDQUFDMkMsT0FBTixDQUFjUSxRQUFkLEVBRG9CO0FBQUEsV0FBaEIsQ0F4Qko7QUEwQkwrTyxtQkFBUyxFQUFFL1IsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUN2QixDQUFDLENBQUNyTCxLQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIyTixTQUExQixFQUFELElBQTBDNVAsS0FBSyxDQUFDMkMsT0FBTixDQUFjRSxVQUFkLEVBQTNDLEtBQ0FzUCx5REFBaUIsQ0FBQ0MsT0FBbEIsQ0FBMEJwUyxLQUFLLENBQUMyQyxPQUFOLENBQWNDLFFBQWQsRUFBMUIsTUFBd0QsQ0FBQyxDQUZsQztBQUFBLFdBQWhCLENBMUJOO0FBNkJMeVAsbUJBQVMsRUFBRWxTLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDdkIsQ0FBQyxDQUFDckwsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCMk4sU0FBMUIsRUFBRCxJQUEwQzVQLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxFQUEzQyxLQUNBeVAseURBQWlCLENBQUNGLE9BQWxCLENBQTBCcFMsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLEVBQTFCLE1BQXdELENBQUMsQ0FGbEM7QUFBQSxXQUFoQixDQTdCTjtBQWdDTDJQLGdCQUFNLEVBQUVuTSxtRUFBVSxDQUFDb00sSUFBWCxDQUFnQnRILElBQWhCLENBaENIO0FBaUNMdUgsa0JBQVEsRUFBRXZNLHFFQUFZLENBQUNzTSxJQUFiLENBQWtCdEgsSUFBbEIsQ0FqQ0w7QUFrQ0x3SCx1QkFBYSxFQUFFLHlCQUFNO0FBQ2pCeEgsZ0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JrQyxNQUFoQixDQUF1QitILFVBQXZCO0FBQ0gsV0FwQ0k7QUFxQ0xDLGdCQUFNLEVBQUU7QUFDSjVPLHNCQUFVLEVBQUUsc0JBQU07QUFDZCxrQkFBSTZPLFVBQVUsR0FBRzNILElBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QkMsRUFBN0IsQ0FBZ0NzQixVQUFoQyxDQUEyQ3dHLFVBQTVEO0FBQ0EscUJBQU9BLFVBQVUsQ0FBQ0MsU0FBWCxDQUFxQixZQUFyQixFQUFtQyxDQUFDRCxVQUFVLENBQUNFLFNBQVgsQ0FBcUIsWUFBckIsQ0FBcEMsQ0FBUDtBQUNILGFBSkc7QUFLSkMsc0JBQVUsRUFBRSxvQkFBQ0MsT0FBRCxFQUFhO0FBQ3JCL0gsa0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCdkQsUUFBdkIsQ0FBZ0MsZUFBaEMsRUFBaUQsRUFBakQsRUFBcUQsRUFBckQsRUFBeUQ2TixPQUF6RCxFQUFrRWpULEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0MsUUFBZCxFQUFsRTtBQUNBNUMsbUJBQUssQ0FBQzJDLE9BQU4sQ0FBY0ksVUFBZCxDQUF5QmtRLE9BQXpCOztBQUNBLGtCQUFJalQsS0FBSyxDQUFDMkMsT0FBTixDQUFjQyxRQUFkLE9BQTZCLFdBQWpDLEVBQThDO0FBQzFDc0ksb0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2Qm9JLGFBQTdCLEdBQTZDRCxPQUE3QztBQUNIO0FBQ0osYUFYRztBQVlKRSw4QkFBa0IsRUFBRWhULEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxxQkFDaENyTCxLQUFLLENBQUNtTCxFQUFOLENBQVN4QyxNQUFULENBQWdCeUssbUJBQWhCLENBQW9DLGFBQXBDLENBRGdDO0FBQUEsYUFBaEIsQ0FaaEI7QUFjSkMsOEJBQWtCLEVBQUUsOEJBQU07QUFDdEJuSSxrQkFBSSxDQUFDeEMsVUFBTCxDQUFnQm9DLFlBQWhCLENBQTZCd0ksWUFBN0I7QUFDQXBJLGtCQUFJLENBQUN4QyxVQUFMLENBQWdCb0MsWUFBaEIsQ0FBNkJ5SSxXQUE3QixDQUF5QyxLQUF6QztBQUNBdlQsbUJBQUssQ0FBQzJDLE9BQU4sQ0FBY08sV0FBZCxDQUEwQixLQUExQjtBQUNILGFBbEJHO0FBbUJKc1EsNkJBQWlCLEVBQUUsNkJBQU07QUFDckJ0SSxrQkFBSSxDQUFDeEMsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUI3RCxXQUF2QixDQUFtQyxVQUFDMk8sUUFBRCxFQUFhO0FBQzVDLG9CQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEJ4SSxzQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlMLE9BQWhCLENBQXdCQyxJQUF4QixDQUE2QkgsUUFBUSxDQUFDRSxPQUF0QztBQUNBM1QsdUJBQUssQ0FBQzJDLE9BQU4sQ0FBY08sV0FBZCxDQUEwQixJQUExQjtBQUNBZ0ksc0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JvQyxZQUFoQixDQUE2QnlJLFdBQTdCLENBQXlDLElBQXpDO0FBQ0gsaUJBSkQsTUFJTztBQUNIckksc0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0J3RCxNQUFoQixDQUF1QjJILHFCQUF2QjtBQUNIO0FBQ0osZUFSRDtBQVNILGFBN0JHO0FBOEJKQyw2QkFBaUIsRUFBRSw2QkFBTTtBQUNyQixrQkFBSTlULEtBQUssQ0FBQzJDLE9BQU4sQ0FBY08sV0FBZCxFQUFKLEVBQWlDO0FBQzdCbEQscUJBQUssQ0FBQ21MLEVBQU4sQ0FBU3NHLE9BQVQsQ0FBaUJtQixNQUFqQixDQUF3QlMsa0JBQXhCO0FBQ0gsZUFGRCxNQUVPO0FBQ0hyVCxxQkFBSyxDQUFDbUwsRUFBTixDQUFTc0csT0FBVCxDQUFpQm1CLE1BQWpCLENBQXdCWSxpQkFBeEI7QUFDSDtBQUNKLGFBcENHO0FBcUNKRyxtQkFBTyxFQUFFO0FBQ0xuVSxtQkFBSyxFQUFFLGlCQUFJO0FBQUUwTCxvQkFBSSxDQUFDeEMsVUFBTCxDQUFnQmlMLE9BQWhCLENBQXdCSSxXQUF4QjtBQUF3QyxlQURoRDtBQUVMM0Usc0JBQVEsRUFBRSxvQkFBSTtBQUFFbEUsb0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JpTCxPQUFoQixDQUF3QkssWUFBeEI7QUFBeUMsZUFGcEQ7QUFHTHhFLGtCQUFJLEVBQUUsZ0JBQUk7QUFBRXRFLG9CQUFJLENBQUN4QyxVQUFMLENBQWdCaUwsT0FBaEIsQ0FBd0JNLFFBQXhCO0FBQXFDLGVBSDVDO0FBSUxDLHdCQUFVLEVBQUUsc0JBQUk7QUFBRWhKLG9CQUFJLENBQUN4QyxVQUFMLENBQWdCaUwsT0FBaEIsQ0FBd0JRLGdCQUF4QjtBQUE2QyxlQUoxRDtBQUtMQyxpQkFBRyxFQUFFLGVBQUk7QUFBRWxKLG9CQUFJLENBQUN4QyxVQUFMLENBQWdCaUwsT0FBaEIsQ0FBd0JTLEdBQXhCO0FBQWdDO0FBTHRDO0FBckNMLFdBckNIO0FBa0ZMQyxnQkFBTSxFQUFFO0FBQ0pDLHdCQUFZLEVBQUU7QUFBQSxxQkFBTXBKLElBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0IrSSxPQUFoQixDQUF3QjhDLE1BQXhCLENBQStCLE9BQS9CLEVBQXdDRCxZQUF4QyxFQUFOO0FBQUE7QUFEVixXQWxGSDtBQXFGTHJTLGtCQUFRLEVBQUU7QUFDTnVTLGdCQUFJLEVBQUU7QUFBQSxxQkFBTXRKLElBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCakQsY0FBdkIsRUFBTjtBQUFBO0FBREEsV0FyRkw7QUF3Rkw3RCwyQkFBaUIsRUFBRTtBQUNmNFMsdUJBQVcsRUFBRSxxQkFBQ0MsTUFBRCxFQUFTQyxLQUFULEVBQWdCQyxVQUFoQixFQUErQjtBQUN4QyxrQkFBSUMsTUFBTSxHQUFHM0osSUFBSSxDQUFDeEMsVUFBTCxDQUFnQitJLE9BQWhCLENBQXdCOEMsTUFBeEIsQ0FBK0Isb0JBQS9CLENBQWI7QUFDQU0sb0JBQU0sQ0FBQ0osV0FBUCxDQUFtQkMsTUFBbkIsRUFBMkJDLEtBQTNCLEVBQWtDQyxVQUFsQztBQUNIO0FBSmM7QUF4RmQsU0EzWkY7QUEwZlBFLGVBQU8sRUFBRTtBQUNMQyxtQkFBUyxFQUFFNVUsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUN2QnJMLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYTZCLFdBQWIsT0FBK0IzQixxREFBVyxDQUFDNkosTUFEcEI7QUFBQSxXQUFoQixDQUROO0FBSUx3RyxrQkFBUSxFQUFFN1UsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQjtBQUFBLG1CQUN0QnJMLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYTZCLFdBQWIsT0FBK0IzQixxREFBVyxDQUFDNkosTUFBM0MsR0FBb0QsTUFBcEQsR0FBNkQsS0FEdkM7QUFBQSxXQUFoQixDQUpMO0FBT0x5RyxhQUFHLEVBQUUsZUFBTTtBQUNQLGdCQUFJalYsS0FBSyxDQUFDeUUsTUFBTixDQUFhNkIsV0FBYixPQUErQjNCLHFEQUFXLENBQUM2SixNQUEvQyxFQUF1RDtBQUNuRCxrQkFBSSxPQUFPMEcsU0FBUCxLQUFxQixXQUFyQixJQUFvQ0EsU0FBUyxDQUFDQyxPQUFsRCxFQUEyRDtBQUN2REQseUJBQVMsQ0FBQ0UsVUFBVjtBQUNIOztBQUNEcFYsbUJBQUssQ0FBQ3lFLE1BQU4sQ0FBYTZCLFdBQWIsQ0FBeUIzQixxREFBVyxDQUFDQyxLQUFyQztBQUNILGFBTEQsTUFLTztBQUNIc0csa0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JxRSxNQUFoQixDQUF1QkMsVUFBdkI7QUFDSDtBQUNKLFdBaEJJO0FBaUJMcUkseUJBQWUsRUFBRWxWLEVBQUUsQ0FBQ2tMLFlBQUgsQ0FBZ0I7QUFBQSxtQkFDN0JyTCxLQUFLLENBQUN5RSxNQUFOLENBQWE2QixXQUFiLE9BQStCM0IscURBQVcsQ0FBQzZKLE1BQTNDLEdBQW9ELE1BQXBELEdBQTZELHNCQURoQztBQUFBLFdBQWhCLENBakJaO0FBb0JMOEcsb0JBQVUsRUFBRSxzQkFBTTtBQUNkLGdCQUFJdFYsS0FBSyxDQUFDeUUsTUFBTixDQUFhNkIsV0FBYixPQUErQjNCLHFEQUFXLENBQUM2SixNQUEvQyxFQUF1RDtBQUNuRCxrQkFBSSxPQUFPMEcsU0FBUCxLQUFxQixXQUFyQixJQUFvQ0EsU0FBUyxDQUFDQyxPQUFsRCxFQUEyRDtBQUN2REQseUJBQVMsQ0FBQ0UsVUFBVjtBQUNIOztBQUNEcFYsbUJBQUssQ0FBQ3lFLE1BQU4sQ0FBYTZCLFdBQWIsQ0FBeUIzQixxREFBVyxDQUFDQyxLQUFyQztBQUNILGFBTEQsTUFLTztBQUNIc0csa0JBQUksQ0FBQ3hDLFVBQUwsQ0FBZ0JxRSxNQUFoQixDQUF1QkMsVUFBdkIsQ0FBa0MsSUFBbEM7QUFDSDtBQUNKLFdBN0JJO0FBOEJMdUksa0JBQVEsRUFBRTtBQUFBLG1CQUNOckssSUFBSSxDQUFDeEMsVUFBTCxDQUFnQnFFLE1BQWhCLENBQXVCd0ksUUFBdkIsRUFETTtBQUFBO0FBOUJMLFNBMWZGO0FBMmhCUDVNLGNBQU0sRUFBRTtBQUNKbEUsZ0JBQU0sRUFBRyxnQkFBQW5DLFFBQVE7QUFBQSxtQkFDYixtQkFBbUJ0QyxLQUFLLENBQUN5RSxNQUFOLENBQWFuQyxRQUFiLEdBRE47QUFBQSxXQURiO0FBSUo4USw2QkFBbUIsRUFBRSw2QkFBQzlRLFFBQUQ7QUFBQSxtQkFDakJ0QyxLQUFLLENBQUN0QixhQUFOLENBQW9Cb0osZUFBcEIsTUFDQTlILEtBQUssQ0FBQ3RCLGFBQU4sQ0FBb0J3SixJQUFwQixLQUE2QnBKLFNBRDdCLElBRUFrQixLQUFLLENBQUN0QixhQUFOLENBQW9Cd0osSUFBcEIsQ0FBeUI1RixRQUF6QixNQUF1Q3hELFNBSHRCO0FBQUEsV0FKakI7QUFRSjBXLGtCQUFRLEVBQUVyVixFQUFFLENBQUNrTCxZQUFILENBQWdCO0FBQUEsbUJBQ3RCb0ssOERBQVUsQ0FBQ3pWLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYUkscUJBQWIsTUFDUDdFLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYWtCLHFCQUFiLEVBRE8sSUFFUDNGLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYU0sa0JBQWIsRUFGTyxJQUdQL0UsS0FBSyxDQUFDeUUsTUFBTixDQUFhUSxlQUFiLEVBSE8sSUFJUGpGLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYWdCLGVBQWIsRUFKTyxJQUtQekYsS0FBSyxDQUFDeUUsTUFBTixDQUFhVSxrQkFBYixFQUxPLElBTVBuRixLQUFLLENBQUN5RSxNQUFOLENBQWFZLGVBQWIsRUFOTyxJQU9QckYsS0FBSyxDQUFDeUUsTUFBTixDQUFhYSxTQUFiLEVBUE8sSUFRUHRGLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYW9CLHVCQUFiLEVBUk8sSUFTUDdGLEtBQUssQ0FBQ3lFLE1BQU4sQ0FBYXNCLDZCQUFiLEVBVE8sSUFTeUMsRUFUMUMsQ0FEWTtBQUFBLFdBQWhCLENBUk47QUFvQkoyUCxlQUFLLEVBQUU7QUFDSGhSLDBCQUFjLEVBQUUsd0JBQUM2RSxJQUFELEVBQU9vTSxLQUFQLEVBQWlCO0FBQzdCO0FBQ0Esa0JBQUlDLHlCQUF5QixHQUFHck4sNkNBQUMsQ0FBQ29OLEtBQUssQ0FBQ0UsTUFBUCxDQUFqQyxDQUY2QixDQUc3Qjs7QUFDQXROLDJEQUFDLENBQUNvTixLQUFLLENBQUNFLE1BQVAsQ0FBRCxDQUFnQkMsTUFBaEIsR0FBeUJDLE9BQXpCLENBQWlDLEdBQWpDLEVBQXNDQyxNQUF0QyxDQUE2QyxHQUE3QyxFQUo2QixDQUs3Qjs7QUFDQSxrQkFBSUMsRUFBRSxHQUFHLElBQUlDLFVBQUosRUFBVDtBQUNBLGtCQUFJdkcsS0FBSyxHQUFHaUcseUJBQXlCLENBQUMsQ0FBRCxDQUF6QixDQUE2QmpHLEtBQXpDOztBQUNBc0csZ0JBQUUsQ0FBQ0UsTUFBSCxHQUFZLFVBQVNDLENBQVQsRUFBWTtBQUNwQixvQkFBSUMsb0JBQW9CLEdBQUcvRixJQUFJLENBQUNnRyxLQUFMLENBQVdGLENBQUMsQ0FBQ1AsTUFBRixDQUFTVSxNQUFwQixDQUEzQjtBQUNBckwsb0JBQUksQ0FBQ3NMLG1CQUFMLENBQXlCSCxvQkFBekI7QUFDSCxlQUhEOztBQUlBSixnQkFBRSxDQUFDUSxRQUFILEdBQWM5RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVN0UCxJQUF2QjtBQUNBNFYsZ0JBQUUsQ0FBQ1MsVUFBSCxDQUFjL0csS0FBSyxDQUFDLENBQUQsQ0FBbkI7QUFDQWlHLHVDQUF5QixDQUFDZSxHQUExQixDQUE4QixFQUE5QjtBQUNILGFBaEJFO0FBaUJIL1EsNEJBQWdCLEVBQUUsMEJBQUMyRCxJQUFELEVBQU9vTSxLQUFQLEVBQWlCO0FBQy9Cbk0scUJBQU8sQ0FBQ29OLEdBQVIsQ0FBWWpCLEtBQVo7QUFDQXpLLGtCQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1Qi9DLGdCQUF2QixDQUF3Q3NGLElBQUksQ0FBQ2xMLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0IyRCxLQUF0QixFQUF4QyxFQUN3QzJJLElBQUksQ0FBQ2xMLEtBQUwsQ0FBV3BCLFVBQVgsQ0FBc0I0RCxPQUF0QixFQUR4QyxFQUV3QyxLQUZ4QyxFQUUrQyxJQUYvQztBQUdBK0YsMkRBQUMsQ0FBQ29OLEtBQUssQ0FBQ0UsTUFBUCxDQUFELENBQWdCRSxPQUFoQixDQUF3QixHQUF4QixFQUE2QkMsTUFBN0IsQ0FBb0MsR0FBcEM7QUFDSDtBQXZCRTtBQXBCSCxTQTNoQkQ7QUF5a0JQYSxjQUFNLEVBQUU7QUFDSmhMLGlCQUFPLEVBQUUxTCxFQUFFLENBQUNrTCxZQUFILENBQ0w7QUFBQSxtQkFDSXJMLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxNQUE4QixDQUFDN0MsS0FBSyxDQUFDbUwsRUFBTixDQUFTQyxXQUFULEVBRG5DO0FBQUEsV0FESztBQURMO0FBemtCRCxPQUFYO0FBZ2xCQTBMLDBGQUErQixDQUFDNUwsSUFBRCxFQUFPbEwsS0FBUCxDQUEvQjtBQUNIO0FBcGhDTDtBQUFBO0FBQUEsa0NBc2hDa0I7QUFDVjtBQUNBK1csUUFBRSxDQUFDQyxZQUFILENBQWdCckgsS0FBaEIsQ0FBc0Isa0JBQXRCLElBQTRDc0gsbUVBQVcsQ0FBQzNTLFFBQVosRUFBNUMsQ0FGVSxDQUdWO0FBQ0E7QUFDSDtBQUVEOzs7OztBQTdoQ0o7QUFBQTtBQUFBLGlDQWlpQ2lCO0FBQ1RuRSxRQUFFLENBQUMrVyxhQUFILENBQWlCLEtBQUtsWCxLQUF0QixFQUE2QixLQUFLQSxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBekIsQ0FBbUMsQ0FBbkMsQ0FBN0I7QUFDSDtBQW5pQ0w7QUFBQTtBQUFBLG9DQXFpQ29CO0FBQ1osVUFBSWtQLElBQUksR0FBRyxJQUFYO0FBQ0EsV0FBSzFMLFNBQUwsR0FBaUI7QUFDYkMsZ0JBQVEsRUFBRSxrQkFBQzBMLElBQUQ7QUFBQSxpQkFBVUEsSUFBSSxHQUFHQyxPQUFPLENBQUNDLFNBQVIsQ0FBa0I1TCxRQUFsQixDQUEyQjBMLElBQTNCLENBQUgsR0FBc0MsU0FBcEQ7QUFBQTtBQURHLE9BQWpCO0FBR0g7QUExaUNMO0FBQUE7QUFBQSxxQ0E0aUNxQjtBQUNiLFVBQUluUCxTQUFTLEdBQUcsS0FBS2pJLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUJ1SixTQUF6QztBQUNBLFVBQUlTLFVBQVUsR0FBRyxLQUFLQSxVQUFMLEdBQWtCLEVBQW5DO0FBQ0EsVUFBSXlPLElBQUksR0FBRyxJQUFYLENBSGEsQ0FJYjtBQUNBOztBQUNBek8sZ0JBQVUsQ0FBQ3dELE1BQVgsR0FBb0IsSUFBSXFMLHNEQUFKLENBQWtCSixJQUFsQixFQUF3QmxQLFNBQVMsQ0FBQ3VQLElBQVYsQ0FBZSxpQkFBZixDQUF4QixDQUFwQjtBQUNBOU8sZ0JBQVUsQ0FBQ25CLFFBQVgsR0FBc0IsSUFBSWtRLDREQUFKLENBQW9CTixJQUFwQixFQUEwQmxQLFNBQVMsQ0FBQ3VQLElBQVYsQ0FBZSxtQkFBZixDQUExQixDQUF0QjtBQUNBOU8sZ0JBQVUsQ0FBQ2lHLEtBQVgsR0FBbUIsSUFBSStJLG9EQUFKLENBQWlCUCxJQUFqQixDQUFuQjtBQUNBek8sZ0JBQVUsQ0FBQ2MsT0FBWCxHQUFxQixJQUFJbU8sd0RBQUosQ0FBbUJSLElBQW5CLEVBQXlCbFAsU0FBUyxDQUFDdVAsSUFBVixDQUFlLGtCQUFmLENBQXpCLENBQXJCO0FBQ0E5TyxnQkFBVSxDQUFDcUUsTUFBWCxHQUFvQixJQUFJNkssd0RBQUosQ0FBa0JULElBQWxCLENBQXBCO0FBQ0F6TyxnQkFBVSxDQUFDaUIsVUFBWCxHQUF3QixJQUFJa08seURBQUosQ0FBc0JWLElBQXRCLENBQXhCO0FBQ0F6TyxnQkFBVSxDQUFDK0ksT0FBWCxHQUFxQixJQUFJcUcsa0RBQUosQ0FBWVgsSUFBWixFQUFrQmxQLFNBQVMsQ0FBQ3VQLElBQVYsQ0FBZSxpQkFBZixDQUFsQixDQUFyQixDQVphLENBYWI7O0FBQ0E5TyxnQkFBVSxDQUFDb0MsWUFBWCxHQUEwQixLQUFLcEMsVUFBTCxDQUFnQitJLE9BQWhCLENBQXdCOEMsTUFBeEIsQ0FBK0IsUUFBL0IsQ0FBMUI7QUFDQTdMLGdCQUFVLENBQUNDLE1BQVgsR0FBb0IsSUFBSW9QLHVEQUFKLENBQWtCWixJQUFsQixDQUFwQjtBQUNBek8sZ0JBQVUsQ0FBQ2tDLE1BQVgsR0FBb0IsSUFBSW9OLHNEQUFKLENBQWtCYixJQUFsQixDQUFwQjtBQUNBek8sZ0JBQVUsQ0FBQ2lMLE9BQVgsR0FBcUIsSUFBSXNFLHdEQUFKLENBQW1CZCxJQUFuQixFQUF5QmxQLFNBQVMsQ0FBQ3VQLElBQVYsQ0FBZSwwQkFBZixDQUF6QixDQUFyQjtBQUNIO0FBOWpDTDtBQUFBO0FBQUEsMkJBZ2tDVztBQUNILFdBQUt4WCxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBekIsQ0FBbUNpUSxJQUFuQztBQUNIO0FBbGtDTDtBQUFBO0FBQUEsMkJBb2tDVztBQUNILFdBQUtsWSxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBekIsQ0FBbUNrUSxJQUFuQztBQUNIO0FBdGtDTDtBQUFBO0FBQUEsNkNBd2tDNkI7QUFBQTs7QUFDckIsV0FBS25ZLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUJrQixtQkFBbkIsQ0FBdUN1VSxTQUF2QyxDQUFpRCxVQUFDQyxPQUFELEVBQWE7QUFDMUQsY0FBSSxDQUFDM1AsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJ2RCxRQUF2QixDQUFnQyx1QkFBaEMsRUFBeUQsRUFBekQsRUFBNkQsRUFBN0QsRUFDZ0NpVCxPQURoQyxFQUN5QyxpQkFEekM7QUFFSCxPQUhEO0FBSUEsV0FBS0MsS0FBTCxHQUFhLElBQWI7QUFDQSxVQUFNclEsU0FBUyxHQUFHLEtBQUtqSSxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBM0M7O0FBQ0EsVUFBTXNRLFdBQVcsR0FBRyxTQUFkQSxXQUFjO0FBQUEsZUFBTXRRLFNBQVMsQ0FBQ3VQLElBQVYsQ0FBZSxxQkFBZixFQUFzQ0osSUFBdEMsQ0FBMkNvQixrRUFBYyxFQUF6RCxDQUFOO0FBQUEsT0FBcEI7O0FBQ0EsVUFBSSxLQUFLeFksS0FBTCxDQUFXbUwsRUFBWCxDQUFjUyxJQUFkLENBQW1Cd0IsU0FBbkIsRUFBSixFQUFvQztBQUNoQyxhQUFLa0wsS0FBTCxHQUFhRyxXQUFXLENBQUNGLFdBQUQsRUFBYyxJQUFkLENBQXhCO0FBQ0g7O0FBRUQsV0FBS3ZZLEtBQUwsQ0FBV21MLEVBQVgsQ0FBY1MsSUFBZCxDQUFtQndCLFNBQW5CLENBQTZCZ0wsU0FBN0IsQ0FBdUMsVUFBQ0MsT0FBRCxFQUFhO0FBQ2hELFlBQUksTUFBSSxDQUFDclksS0FBTCxDQUFXbUwsRUFBWCxDQUFjUyxJQUFkLENBQW1Cd0IsU0FBbkIsRUFBSixFQUFvQztBQUNoQyxjQUFJLE1BQUksQ0FBQ2tMLEtBQVQsRUFBZ0I7QUFDWkkseUJBQWEsQ0FBQyxNQUFJLENBQUNKLEtBQU4sQ0FBYjtBQUNBLGtCQUFJLENBQUNBLEtBQUwsR0FBYSxJQUFiO0FBQ0g7QUFDSixTQUxELE1BS087QUFDSCxjQUFJLENBQUMsTUFBSSxDQUFDQSxLQUFWLEVBQWlCO0FBQ2Isa0JBQUksQ0FBQ0EsS0FBTCxHQUFhRyxXQUFXLENBQUNGLFdBQUQsRUFBYyxJQUFkLENBQXhCO0FBQ0g7QUFDSjtBQUNKLE9BWEQ7QUFZSDtBQWhtQ0w7QUFBQTtBQUFBLDRCQWttQ1k7QUFDSixXQUFLdlksS0FBTCxDQUFXMkMsT0FBWCxDQUFtQkMsUUFBbkIsQ0FBNEIsV0FBNUI7QUFDSDtBQXBtQ0w7QUFBQTtBQUFBLHFDQXNtQ3FCO0FBQ2IsV0FBSzhGLFVBQUwsQ0FBZ0JxRSxNQUFoQixDQUF1QnBCLEtBQXZCLEdBRGEsQ0FFYjs7QUFDQSxXQUFLakQsVUFBTCxDQUFnQkMsTUFBaEIsQ0FBdUJnUSxXQUF2QixHQUFxQyxJQUFyQztBQUNIO0FBMW1DTDtBQUFBO0FBQUEsc0NBNG1Dc0I7QUFDZCxVQUFJQyxvQkFBb0IsR0FBR0MsTUFBTSxDQUFDLDRCQUFELENBQWpDO0FBQ0EsV0FBSzdZLEtBQUwsQ0FBVzJDLE9BQVgsQ0FBbUJzQixRQUFuQixDQUE0QjJVLG9CQUE1QjtBQUNIO0FBL21DTDtBQUFBO0FBQUEsOEJBaW5DYyxDQUVUO0FBbm5DTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFFQTs7Ozs7QUFJQSxJQUFNRSxlQUFlLHNIQUFyQjtBQUtBOzs7OztBQUlBLElBQU1DLHFCQUFxQixHQUFHLGFBQTlCO0FBRUE7Ozs7O0FBSU8sSUFBTUMsWUFBWSwrcEJBQWxCO0FBbUJQOzs7OztBQUlPLElBQUlDLGVBQWUsR0FBRztBQUN6QmhXLE1BQUksRUFBRSxNQURtQjtBQUV6QmlXLE1BQUksRUFBRSxNQUZtQjtBQUd6QkMsTUFBSSxFQUFFLE1BSG1CO0FBSXpCQyxPQUFLLEVBQUUsT0FKa0I7QUFLekJDLFFBQU0sRUFBRSxRQUxpQjtBQU16QkMsUUFBTSxFQUFFLFFBTmlCO0FBT3pCQyxNQUFJLEVBQUUsTUFQbUI7QUFRekJDLFlBQVUsRUFBRSxZQVJhO0FBU3pCQyxPQUFLLEVBQUUsT0FUa0I7QUFVekJDLE9BQUssRUFBRSxPQVZrQjtBQVd6QkMsV0FBUyxFQUFFO0FBWGMsQ0FBdEI7QUFjUDs7Ozs7SUFJTUMsVztBQUNGLHVCQUFZekMsSUFBWixFQUFrQnZXLElBQWxCLEVBQXdCaVosT0FBeEIsRUFBaUM7QUFBQTs7QUFDN0I7Ozs7O0FBS0EsU0FBSzFDLElBQUwsR0FBWUEsSUFBWjtBQUNBOzs7OztBQUlBLFNBQUt2VyxJQUFMLEdBQVlBLElBQVo7QUFDQTs7Ozs7QUFJQSxTQUFLaVosT0FBTCxHQUFlQSxPQUFmO0FBQ0E7Ozs7O0FBSUEsU0FBS0MsTUFBTCxHQUFjO0FBQ1ZsWCxjQUFRLEVBQUVtVSxFQUFFLENBQUNnRCxZQURIO0FBRVZsTCxVQUFJLEVBQUVzSSxJQUFJLENBQUN6TyxVQUFMLENBQWdCcUUsTUFBaEIsQ0FBdUJpTixlQUF2QixDQUF1Q25MLElBRm5DO0FBR1ZFLFVBQUksRUFBRW9JLElBQUksQ0FBQ3pPLFVBQUwsQ0FBZ0JxRSxNQUFoQixDQUF1QmlOLGVBQXZCLENBQXVDakw7QUFIbkMsS0FBZDtBQUtBOzs7Ozs7QUFLQSxTQUFLdkcsSUFBTCxHQUFZRCxDQUFDLENBQUMsYUFBRCxFQUFnQjtBQUN6QixlQUFVLHdCQURlO0FBRXpCLHdCQUFrQjRPLElBQUksQ0FBQ25YLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUJzSixlQUZsQjtBQUd6QixxQkFBZSxTQUhVO0FBSXpCLHdCQUFrQixNQUpPO0FBS3pCLG1CQUFhLEtBQUs4UixNQUFMLENBQVlqTCxJQUxBO0FBTXpCLGVBQVMsVUFBVSxLQUFLaUwsTUFBTCxDQUFZakwsSUFBdEIsR0FBNkIsU0FBN0IsR0FBeUMsS0FBS2lMLE1BQUwsQ0FBWS9LO0FBTnJDLEtBQWhCLENBQWI7QUFRQTs7Ozs7QUFJQSxTQUFLbEQsT0FBTCxHQUFlLENBQUNzTCxJQUFJLENBQUNuWCxLQUFMLENBQVcyQyxPQUFYLENBQW1CRyxXQUFuQixFQUFoQjtBQUNBOzs7OztBQUlBLFNBQUs2UixLQUFMLEdBQWEsQ0FBYjtBQUNIO0FBRUQ7Ozs7Ozs7OytCQUlXO0FBQ1AsYUFBT29DLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQixLQUFLTCxPQUF0QixDQUFQO0FBQ0g7QUFFRDs7Ozs7OzhCQUdTO0FBQ0wsV0FBS3JSLElBQUwsQ0FBVTJSLE1BQVY7QUFDSDs7Ozs7O0lBR0NDLGlCOzs7OztBQUNGO0FBQ0EsNkJBQVlqRCxJQUFaLEVBQWtCO0FBQUE7O0FBQUE7O0FBQ2QsOEJBQU1BLElBQU4sRUFBWThCLGVBQWUsQ0FBQ0ssTUFBNUI7O0FBQ0EsVUFBSzlRLElBQUwsQ0FBVTZSLFFBQVYsQ0FBbUIsK0JBQW5COztBQUZjO0FBR2pCOzs7OzJCQUVNQyxLLEVBQU87QUFDVixVQUFJLEtBQUt6TyxPQUFULEVBQWtCO0FBQ2R5TyxhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLL1IsSUFBbkIsRUFEYyxDQUVkOztBQUNBLFlBQUlnUyxHQUFHLEdBQUcsS0FBS2hTLElBQUwsQ0FBVWlTLE1BQVYsR0FBbUJELEdBQTdCLENBSGMsQ0FJZDs7QUFDQWpTLFNBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVW1TLFNBQVYsQ0FBb0JGLEdBQXBCLEVBTGMsQ0FNZDtBQUNIO0FBQ0o7Ozs7RUFoQjJCWixXOztJQW1CMUJlLGlCOzs7OztBQUNGLDZCQUFZeEQsSUFBWixFQUFrQjdJLElBQWxCLEVBQXdCdEssVUFBeEIsRUFBb0M0VyxTQUFwQyxFQUErQztBQUFBOztBQUFBOztBQUMzQyxnQ0FBTXpELElBQU4sRUFBWThCLGVBQWUsQ0FBQ0ksTUFBNUI7O0FBQ0EsV0FBSzdRLElBQUwsQ0FBVTZSLFFBQVYsQ0FBbUIsK0JBQW5COztBQUNBLFdBQUsvTCxJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLdEssVUFBTCxHQUFrQkEsVUFBbEI7QUFDQSxXQUFLNFcsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxXQUFLQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsV0FBS0MsTUFBTCxHQUFjQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZCxDQVAyQyxDQVEzQzs7QUFSMkM7QUFTOUM7Ozs7MkJBRU1WLEssRUFBTztBQUNWLFVBQUksS0FBS3pPLE9BQVQsRUFBa0I7QUFDZCxhQUFLckQsSUFBTCxDQUFVeVMsTUFBVixDQUFpQixLQUFLSCxNQUF0QjtBQUNBUixhQUFLLENBQUNDLE9BQU4sQ0FBYyxLQUFLL1IsSUFBbkI7QUFDQSxZQUFJZ1MsR0FBRyxHQUFHLEtBQUtoUyxJQUFMLENBQVVpUyxNQUFWLEdBQW1CRCxHQUE3QjtBQUNBalMsU0FBQyxDQUFDLE1BQUQsQ0FBRCxDQUFVbVMsU0FBVixDQUFvQkYsR0FBcEI7QUFDSDtBQUNKOzs7OEJBRVMsQ0FDTjtBQUNIOzs7MkJBRU07QUFDSCxXQUFLVSxPQUFMLEdBQWUsWUFBTSxDQUFFLENBQXZCOztBQUNBLFdBQUsvRCxJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJtQyxTQUFuQixDQUE2QmMsWUFBN0I7QUFDSDs7OzZCQUVRK00sZSxFQUFpQkMsUyxFQUFXO0FBQUE7O0FBQ2pDLFdBQUtQLFdBQUwsR0FBbUIsSUFBbkI7O0FBQ0EsV0FBS0ssT0FBTCxHQUFlO0FBQUEsZUFBTUMsZUFBZSxDQUFDLE1BQUksQ0FBQ1AsU0FBTixFQUFpQlEsU0FBakIsQ0FBckI7QUFBQSxPQUFmO0FBQ0g7Ozs7RUFqQzJCeEIsVzs7SUFxQzFCeUIsZ0I7Ozs7O0FBQ0YsNEJBQVlsRSxJQUFaLEVBQWtCMEMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQTs7QUFDdkIsZ0NBQU0xQyxJQUFOLEVBQVk4QixlQUFlLENBQUNHLEtBQTVCLEVBQW1DUyxPQUFuQzs7QUFDQSxXQUFLclIsSUFBTCxDQUFVNlIsUUFBVixDQUFtQiw4QkFBbkI7O0FBRnVCO0FBRzFCOzs7OzJCQUVNQyxLLEVBQU87QUFDVixVQUFJLEtBQUt6TyxPQUFULEVBQWtCO0FBQ2RyQyxlQUFPLENBQUNvTixHQUFSLENBQVksS0FBS2lELE9BQWpCO0FBQ0EsYUFBS3JSLElBQUwsQ0FBVXlTLE1BQVYsQ0FBaUIsS0FBS3BCLE9BQXRCO0FBQ0FTLGFBQUssQ0FBQ1csTUFBTixDQUFhLEtBQUt6UyxJQUFsQixFQUhjLENBSWQ7QUFDSDtBQUNKOzs7O0VBYjBCb1IsVzs7SUFnQnpCMEIsZTs7Ozs7QUFDRiwyQkFBWW5FLElBQVosRUFBa0IwQyxPQUFsQixFQUEyQjtBQUFBOztBQUFBOztBQUN2QixnQ0FBTTFDLElBQU4sRUFBWThCLGVBQWUsQ0FBQ0UsSUFBNUIsRUFBa0NVLE9BQWxDOztBQUNBLFdBQUtyUixJQUFMLENBQVU2UixRQUFWLENBQW1CLDZCQUFuQjs7QUFGdUI7QUFHMUI7Ozs7MkJBRU1DLEssRUFBTztBQUNWLFVBQUksS0FBS3pPLE9BQVQsRUFBa0I7QUFDZHlPLGFBQUssQ0FBQ1csTUFBTixDQUFhLEtBQUt6UyxJQUFsQixFQURjLENBRWQ7QUFDSDtBQUNKOzs7O0VBWHlCb1IsVzs7SUFjeEIyQixlOzs7Ozs7Ozs7Ozs7OytCQUVTMUIsTyxFQUFTO0FBQ2hCLFdBQUtBLE9BQUwsR0FBZSxLQUFLQSxPQUFMLEdBQWVBLE9BQTlCO0FBQ0g7OzsyQkFFTVMsSyxFQUFPO0FBQ1YsVUFBSSxLQUFLek8sT0FBVCxFQUFrQjtBQUNkLFlBQUkyUCxXQUFXLEdBQUdDLDZEQUFVLENBQUMsS0FBSzVCLE9BQU4sQ0FBNUI7O0FBQ0EsWUFBSSxDQUFDMkIsV0FBRCxJQUFnQkEsV0FBVyxDQUFDRSxJQUFaLEdBQW1CekwsTUFBbkIsSUFBNkIsQ0FBakQsRUFBb0Q7QUFDaER1TCxxQkFBVyxHQUFHLElBQWQ7QUFDSDs7QUFDRCxZQUFJRyxRQUFRLEdBQUdwVCxDQUFDLENBQUMsZUFBRCxFQUFrQjtBQUFFLGtCQUFRaVQ7QUFBVixTQUFsQixDQUFoQjtBQUNBLGFBQUtoVCxJQUFMLENBQVV5UyxNQUFWLENBQWlCVSxRQUFqQjtBQUNBckIsYUFBSyxDQUFDVyxNQUFOLENBQWEsS0FBS3pTLElBQWxCO0FBQ0EsYUFBS0EsSUFBTCxDQUFVb1QsT0FBVjtBQUNIO0FBQ0o7Ozs7RUFqQnlCaEMsVzs7SUFvQnhCaUMsZ0I7Ozs7O0FBRUYsNEJBQVkxRSxJQUFaLEVBQWtCMEMsT0FBbEIsRUFBMkI7QUFBQTs7QUFBQSw4QkFDakIxQyxJQURpQixFQUNYOEIsZUFBZSxDQUFDUSxLQURMLEVBQ1lJLE9BRFo7QUFFMUI7Ozs7MkJBRU1TLEssRUFBTztBQUNWLFVBQUksS0FBS3pPLE9BQVQsRUFBa0I7QUFDZCxZQUFJMlAsV0FBVyxHQUFHQyw2REFBVSxDQUFDLEtBQUs1QixPQUFOLENBQTVCO0FBQ0EsWUFBSThCLFFBQVEsR0FBR3BULENBQUMsQ0FBQyxlQUFELEVBQWtCO0FBQUUsa0JBQVFpVDtBQUFWLFNBQWxCLENBQWhCO0FBQ0EsYUFBS2hULElBQUwsQ0FBVXlTLE1BQVYsQ0FBaUJVLFFBQWpCO0FBQ0FyQixhQUFLLENBQUNXLE1BQU4sQ0FBYSxLQUFLelMsSUFBbEI7QUFDQSxhQUFLQSxJQUFMLENBQVVvVCxPQUFWO0FBQ0g7QUFDSjs7OztFQWQwQmhDLFc7O0lBaUJ6QmtDLGdCOzs7OztBQUNGLDRCQUFZM0UsSUFBWixFQUFrQjRFLGFBQWxCLEVBQWlDO0FBQUE7O0FBQUE7O0FBQzdCLGdDQUFNNUUsSUFBTixFQUFZOEIsZUFBZSxDQUFDUyxLQUE1QixFQUFtQ3FDLGFBQW5DO0FBQ0EsV0FBS2xRLE9BQUwsR0FBZSxJQUFmO0FBRjZCO0FBR2hDO0FBRUQ7Ozs7Ozs7OzJCQUlPeU8sSyxFQUFPO0FBQ1Y7QUFDQSxVQUFJLEtBQUt6TyxPQUFULEVBQWtCO0FBQ2Q7QUFDQSxZQUFJbVEsU0FBUyxHQUFHelQsQ0FBQyxDQUFDLHVCQUFELENBQWpCLENBRmMsQ0FHZDs7QUFDQSxZQUFJMFQsUUFBUSxHQUFHMVQsQ0FBQyxDQUFDLG1CQUFELEVBQXNCO0FBQUMsa0JBQVE7QUFBVCxTQUF0QixDQUFoQixDQUpjLENBS2Q7O0FBQ0EsWUFBSTJULFVBQVUsR0FBRzNULENBQUMsQ0FBQyxhQUFELEVBQWdCO0FBQUMsbUJBQVM7QUFBVixTQUFoQixDQUFsQjtBQUNBMlQsa0JBQVUsQ0FBQ2pCLE1BQVgsQ0FBa0JlLFNBQWxCO0FBQ0FFLGtCQUFVLENBQUNqQixNQUFYLENBQWtCZ0IsUUFBbEIsRUFSYyxDQVNkOztBQUNBLFlBQUlFLFFBQVEsR0FBRzVULENBQUMsQ0FBQyxhQUFELENBQWhCOztBQUNBLFlBQUksS0FBS3NSLE9BQUwsS0FBaUIsSUFBckIsRUFBMkI7QUFDdkIsY0FBSTJCLFdBQVcsR0FBR0MsNkRBQVUsQ0FBQyxLQUFLNUIsT0FBTixDQUE1QjtBQUNBLGNBQUl1QyxRQUFRLEdBQUc3VCxDQUFDLENBQUMsZUFBRCxFQUFtQjtBQUFDLG9CQUFRaVQ7QUFBVCxXQUFuQixDQUFoQjtBQUNBVyxrQkFBUSxDQUFDbEIsTUFBVCxDQUFnQm1CLFFBQWhCO0FBQ0g7O0FBQ0RELGdCQUFRLENBQUNsQixNQUFULENBQWdCMVMsQ0FBQyxDQUFDLE1BQUQsQ0FBakIsRUFDSzBTLE1BREwsQ0FDWWlCLFVBRFosRUFoQmMsQ0FrQmQ7O0FBQ0EsYUFBSzFULElBQUwsQ0FBVXlTLE1BQVYsQ0FBaUJrQixRQUFqQjtBQUNBN0IsYUFBSyxDQUFDVyxNQUFOLENBQWEsS0FBS3pTLElBQWxCLEVBcEJjLENBcUJkOztBQUNBLGVBQU8sS0FBSzZULGVBQUwsQ0FBcUJMLFNBQXJCLEVBQWdDQyxRQUFoQyxDQUFQO0FBQ0g7O0FBQ0QsYUFBTyxFQUFQO0FBQ0g7OztvQ0FFZXZWLEssRUFBTzRWLE0sRUFBUTtBQUFBOztBQUMzQixVQUFJQyxjQUFKO0FBQ0EsVUFBSUMsZ0JBQWdCLEdBQUcsSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBYTtBQUM1Q0gsc0JBQWMsR0FBR0csT0FBakI7QUFDSCxPQUZzQixDQUF2QjtBQUdBLFVBQUkvVixVQUFVLEdBQUcsS0FBS3dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsRUFBakI7O0FBQ0EsVUFBSWdXLFVBQVUsR0FBRyxTQUFiQSxVQUFhLEdBQU07QUFDbkIsWUFBSUMsaUJBQWlCLEdBQUdsVyxLQUFLLENBQUNpUSxHQUFOLEVBQXhCO0FBQ0FJLFVBQUUsQ0FBQzhGLFdBQUgsQ0FBZUMsSUFBZixDQUFvQkYsaUJBQXBCOztBQUNBLGNBQUksQ0FBQ3pGLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsQ0FBcUNBLFVBQVUsR0FBQyxDQUFoRDs7QUFDQSxjQUFJLENBQUN3USxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJHLEtBQTFCLEdBQWtDb1csSUFBbEMsQ0FBdUNGLGlCQUF2Qzs7QUFDQUwsc0JBQWMsQ0FBQ0ssaUJBQUQsQ0FBZDtBQUNBbFcsYUFBSyxDQUFDcVcsSUFBTixDQUFXLFVBQVgsRUFBdUIsSUFBdkI7QUFDQVQsY0FBTSxDQUFDUyxJQUFQLENBQVksVUFBWixFQUF3QixJQUF4Qjs7QUFDQSxjQUFJLENBQUN2VSxJQUFMLENBQVVvVCxPQUFWO0FBQ0gsT0FURDs7QUFVQVUsWUFBTSxDQUFDVSxLQUFQLENBQWFMLFVBQWI7QUFDQWpXLFdBQUssQ0FBQ3VXLEtBQU4sQ0FBWSxVQUFDN0csQ0FBRCxFQUFPO0FBQ2YsWUFBSUEsQ0FBQyxDQUFDOEcsT0FBRixLQUFjLEVBQWxCLEVBQXNCO0FBQ2xCUCxvQkFBVTtBQUNiO0FBQ0osT0FKRDtBQUtBalcsV0FBSyxDQUFDeVcsS0FBTjtBQUNBM1QsYUFBTyxDQUFDb04sR0FBUixDQUFZalEsVUFBWixFQUF3QixLQUFLd1EsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ3VKLE1BQTFEOztBQUNBLFVBQUl0SixVQUFVLEdBQUcsS0FBS3dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0N1SixNQUFuRCxFQUEyRDtBQUN2RCxZQUFJMk0saUJBQWlCLEdBQUcsS0FBS3pGLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NDLFVBQWxDLENBQXhCO0FBQ0FELGFBQUssQ0FBQ2lRLEdBQU4sQ0FBVWlHLGlCQUFWO0FBQ0EsYUFBS3pGLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsQ0FBcUNBLFVBQVUsR0FBQyxDQUFoRDtBQUNBLGVBQU8sSUFBSThWLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQWE7QUFDNUJoVyxlQUFLLENBQUNxVyxJQUFOLENBQVcsVUFBWCxFQUF1QixJQUF2QjtBQUNBVCxnQkFBTSxDQUFDUyxJQUFQLENBQVksVUFBWixFQUF3QixJQUF4Qjs7QUFDQSxnQkFBSSxDQUFDdlUsSUFBTCxDQUFVb1QsT0FBVjs7QUFDQWMsaUJBQU8sQ0FBQ0UsaUJBQUQsQ0FBUDtBQUNILFNBTE0sQ0FBUDtBQU1IOztBQUNELGFBQU9KLGdCQUFQO0FBQ0g7Ozs7RUEzRTBCNUMsVzs7SUE4RXpCd0QsbUI7Ozs7O0FBQ0YsK0JBQVlqRyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsOEJBQ1JBLElBRFEsRUFDRixXQURFO0FBRWpCOzs7RUFINkIyRSxnQjs7SUFNNUJ1Qix3Qjs7Ozs7QUFDRixvQ0FBWWxHLElBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDZCxnQ0FBTUEsSUFBTixFQUFZOEIsZUFBZSxDQUFDTyxVQUE1Qjs7QUFDQSxXQUFLaFIsSUFBTCxDQUFVeVMsTUFBVixDQUFpQjFTLENBQUMsQ0FBQ3VRLGVBQUQsQ0FBbEI7O0FBQ0EsV0FBS3RRLElBQUwsQ0FBVXdVLEtBQVYsQ0FBZ0IsWUFBTTtBQUNsQixhQUFLN0YsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1CMkosT0FBbkIsQ0FBMkJTLFFBQTNCOztBQUNBO0FBQ0gsS0FIRDs7QUFIYztBQU9qQjs7OzsyQkFFTStFLEssRUFBTztBQUNWQSxXQUFLLENBQUNXLE1BQU4sQ0FBYSxLQUFLelMsSUFBbEI7QUFDSDs7OztFQVprQ29SLFc7O0FBZWhDLElBQU1qQyxjQUFiO0FBRUk7Ozs7Ozs7O0FBUUEsMEJBQWFSLElBQWIsRUFBbUJtRyxHQUFuQixFQUF3QjtBQUFBOztBQUNwQixTQUFLbkcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS21HLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtDLFVBQUwsR0FBa0JELEdBQUcsQ0FBQzlGLElBQUosQ0FBUyxrQkFBVCxDQUFsQjtBQUVBLFNBQUtnRyxhQUFMLEdBQXFCLEdBQXJCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixHQUF0QjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsS0FBS0gsVUFBTCxDQUFnQkksTUFBaEIsRUFBdEIsQ0FQb0IsQ0FPNEI7O0FBQ2hELFNBQUt4RyxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLcWEsY0FBbkQ7QUFFQSxTQUFLalgsTUFBTCxHQUFjLEtBQUswUSxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJFLE1BQXhDLENBVm9CLENBV3BCOztBQUNBLFNBQUt4RSxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBSzJiLEtBQUwsR0Fib0IsQ0FlcEI7QUFDSDs7QUExQkw7QUFBQTs7QUE0Qkk7Ozs7QUE1QkosNEJBZ0NZO0FBQ0osV0FBS25YLE1BQUwsQ0FBWW9YLFNBQVo7QUFFQSxXQUFLQyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFdBQUtSLFVBQUwsQ0FBZ0JTLEtBQWhCLEdBTEksQ0FNSjs7QUFDQSxVQUFJLEtBQUs3RyxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixPQUFvRCxLQUFLa2EsVUFBTCxDQUFnQkksTUFBaEIsRUFBeEQsRUFBa0Y7QUFDOUUsYUFBS0osVUFBTCxDQUFnQkksTUFBaEIsQ0FBdUIsS0FBS0QsY0FBNUI7QUFDQSxhQUFLdkcsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCVSxxQkFBeEIsQ0FBOEMsS0FBS2thLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQTlDO0FBQ0g7O0FBRUQsV0FBS00sVUFBTCxHQUFrQixJQUFsQjtBQUNBbEgsUUFBRSxDQUFDbUgsY0FBSCxHQUFvQjtBQUNoQnJJLGNBQU0sRUFBRSxLQUFLc0ksYUFBTCxDQUFtQjNMLElBQW5CLENBQXdCLElBQXhCLENBRFE7QUFFaEJqRixhQUFLLEVBQUUsS0FBSzZRLFFBQUwsRUFGUztBQUdoQlQsY0FBTSxFQUFFLEtBQUtVLFNBQUwsRUFIUTtBQUloQkMsY0FBTSxFQUFFLEtBQUtDLFNBQUwsQ0FBZS9MLElBQWYsQ0FBb0IsSUFBcEI7QUFKUSxPQUFwQjtBQU9BLFdBQUtnTSxVQUFMLEdBQWtCLElBQWxCO0FBQ0g7QUFyREw7QUFBQTtBQUFBLDhCQXVEY25lLElBdkRkLEVBdURvQjtBQUNaLGFBQU9BLElBQVA7QUFDSDtBQXpETDtBQUFBO0FBQUEsb0NBMkRvQjtBQUNaLFVBQUksS0FBSzRkLFVBQUwsS0FBb0IsSUFBeEIsRUFBOEI7QUFDMUIsYUFBS0EsVUFBTCxHQUFrQixJQUFJN0QsaUJBQUosQ0FBc0IsS0FBS2pELElBQTNCLENBQWxCO0FBQ0EsYUFBSzhHLFVBQUwsQ0FBZ0JRLE1BQWhCLENBQXVCLEtBQUtsQixVQUE1QixFQUYwQixDQUcxQjs7QUFDQSxZQUFJLEtBQUtwRyxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixPQUFvRCxLQUFLa2EsVUFBTCxDQUFnQkksTUFBaEIsRUFBeEQsRUFBa0Y7QUFDOUUsY0FBSWUsdUJBQXVCLEdBQUcsS0FBS25CLFVBQUwsQ0FBZ0JoUSxLQUFoQixFQUE5QjtBQUNBLGVBQUtnUSxVQUFMLENBQWdCSSxNQUFoQixDQUF1QmUsdUJBQXZCO0FBQ0EsZUFBS3ZILElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QlUscUJBQXhCLENBQThDLEtBQUtrYSxVQUFMLENBQWdCSSxNQUFoQixFQUE5QztBQUNBNUcsWUFBRSxDQUFDbUgsY0FBSCxDQUFrQlAsTUFBbEIsR0FBMkJlLHVCQUF1QixHQUFDLEVBQW5EO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLEtBQUtULFVBQUwsQ0FBZ0J6VixJQUFoQixDQUFxQixDQUFyQixDQUFQO0FBQ0g7QUF4RUw7QUFBQTtBQUFBLHVDQTBFdUJtVyxRQTFFdkIsRUEwRWlDQyxTQTFFakMsRUEwRTRDO0FBQ3BDO0FBQ0EsVUFBSSxLQUFLekgsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCVSxxQkFBeEIsT0FBb0QsS0FBS2thLFVBQUwsQ0FBZ0JJLE1BQWhCLEVBQXBELElBQ0FpQixTQUFTLEdBQUcsS0FBS2xCLGNBRHJCLEVBQ3FDO0FBQ2pDLGFBQUtILFVBQUwsQ0FBZ0JJLE1BQWhCLENBQXVCLEtBQUdpQixTQUExQjtBQUNBLGFBQUt6SCxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JVLHFCQUF4QixDQUE4QyxLQUFLa2EsVUFBTCxDQUFnQkksTUFBaEIsRUFBOUM7QUFDSCxPQU5tQyxDQU9wQzs7O0FBQ0EsVUFBSWdCLFFBQVEsR0FBRyxLQUFLcEIsVUFBTCxDQUFnQmhRLEtBQWhCLEVBQWYsRUFBd0M7QUFDcEMsYUFBSzRKLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQm1DLFNBQW5CLENBQTZCYSxRQUE3QjtBQUNIO0FBQ0o7QUFyRkw7QUFBQTtBQUFBLG9DQXVGb0I7QUFDWixVQUFJLEtBQUtnSixJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQzRjLGdCQUFwQyxFQUFKLEVBQTREO0FBQ3hELFlBQUksS0FBS1osVUFBVCxFQUFxQjtBQUNqQixjQUFJbkQsTUFBTSxHQUFHLEtBQUttRCxVQUFMLENBQWdCelYsSUFBaEIsQ0FBcUJnUCxJQUFyQixDQUEwQixRQUExQixFQUFvQzlILElBQXBDLEdBQTJDLENBQTNDLENBQWI7QUFDQSxjQUFJb1AsT0FBTyxHQUFHaEUsTUFBTSxDQUFDaUUsU0FBUCxDQUFpQixXQUFqQixDQUFkO0FBQ0EsZUFBSzVILElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCckQsU0FBNUIsQ0FBc0MsZUFBdEMsRUFBdUR3WixPQUF2RDtBQUNILFNBSkQsTUFJTyxJQUFJLEtBQUtOLFVBQVQsRUFBcUI7QUFDeEIsY0FBSTFELE9BQU0sR0FBRyxLQUFLMEQsVUFBTCxDQUFnQjFELE1BQTdCOztBQUNBLGNBQUlnRSxRQUFPLEdBQUdoRSxPQUFNLENBQUNpRSxTQUFQLENBQWlCLFdBQWpCLENBQWQ7O0FBQ0EsZUFBSzVILElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCckQsU0FBNUIsQ0FBc0MsZUFBdEMsRUFBdUR3WixRQUF2RDtBQUNILFNBSk0sTUFJQSxDQUNIO0FBQ0g7QUFDSjtBQUNKLEtBckdMLENBdUdJOztBQXZHSjtBQUFBO0FBQUEsZ0NBd0dnQjtBQUNSLGFBQU8sSUFBUDtBQUNIO0FBMUdMO0FBQUE7QUFBQSwrQkE0R2U7QUFDUCxhQUFPelAsSUFBSSxDQUFDQyxHQUFMLENBQVMsS0FBS2tPLGFBQWQsRUFBNkIsS0FBS0QsVUFBTCxDQUFnQmhRLEtBQWhCLEtBQXdCLEVBQXJELENBQVA7QUFDSDtBQTlHTDtBQUFBO0FBQUEsZ0NBZ0hnQjtBQUNSLGFBQU84QixJQUFJLENBQUNDLEdBQUwsQ0FBUyxLQUFLbU8sY0FBZCxFQUE4QixLQUFLRixVQUFMLENBQWdCSSxNQUFoQixLQUF5QixFQUF2RCxDQUFQO0FBQ0g7QUFsSEw7QUFBQTtBQUFBLDhCQW9IYztBQUNOLGFBQU8sS0FBS3hHLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkcsV0FBeEIsRUFBUDtBQUNIO0FBRUQ7Ozs7Ozs7O0FBeEhKO0FBQUE7QUFBQSxnQ0ErSGdCK0wsSUEvSGhCLEVBK0hzQm1RLElBL0h0QixFQStINEI7QUFDcEIsV0FBS3pCLFVBQUwsQ0FBZ0IvRixJQUFoQixDQUFxQix5QkFBckIsRUFBZ0R5SCxJQUFoRCxDQUFxRCxZQUFXO0FBQzVELFlBQUkxVyxDQUFDLENBQUMsSUFBRCxDQUFELENBQVEyVyxJQUFSLENBQWEsV0FBYixLQUE2QnJRLElBQWpDLEVBQXVDO0FBQ25DdEcsV0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRMlAsSUFBUjtBQUNILFNBRkQsTUFFTztBQUNIM1AsV0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRNFAsSUFBUjtBQUNIO0FBQ0osT0FORDtBQU9IO0FBdklMO0FBQUE7O0FBeUlJOzs7O0FBeklKLDBCQTZJVWdILFFBN0lWLEVBNklvQjtBQUNaO0FBQ0E7QUFDQSxVQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNYO0FBQ0g7O0FBQ0QsVUFBSUMsS0FBSyxHQUFHLEtBQVo7O0FBQ0EsVUFBSUQsUUFBUSxDQUFDRSxNQUFULENBQWdCRixRQUFRLENBQUNsUCxNQUFULEdBQWdCLENBQWhDLE1BQXVDLElBQTNDLEVBQWlEO0FBQzdDbVAsYUFBSyxHQUFHLElBQVI7QUFDSDs7QUFDRCxVQUFJRSxVQUFVLEdBQUdILFFBQVEsQ0FBQ0ksS0FBVCxDQUFlLElBQWYsQ0FBakI7O0FBQ0EsVUFBSSxLQUFLekIsVUFBTCxLQUFvQixJQUF4QixFQUE4QjtBQUMxQixhQUFLQSxVQUFMLEdBQWtCLElBQUl2QyxlQUFKLENBQW9CLEtBQUtwRSxJQUF6QixFQUErQjhCLGVBQWUsQ0FBQ2hXLElBQS9DLEVBQXFEcWMsVUFBVSxDQUFDLENBQUQsQ0FBL0QsQ0FBbEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLeEIsVUFBTCxDQUFnQjBCLFVBQWhCLENBQTJCRixVQUFVLENBQUMsQ0FBRCxDQUFyQztBQUNIOztBQUNELFdBQUssSUFBSUcsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHSCxVQUFVLENBQUNyUCxNQUFYLEdBQWtCLENBQXBDLEVBQXVDd1AsQ0FBQyxFQUF4QyxFQUE0QztBQUN4QyxhQUFLaFosTUFBTCxDQUFZcVcsSUFBWixDQUFpQixLQUFLZ0IsVUFBdEI7QUFDQSxhQUFLQSxVQUFMLENBQWdCVyxNQUFoQixDQUF1QixLQUFLbEIsVUFBNUI7QUFDQSxhQUFLTyxVQUFMLEdBQWtCLElBQUl2QyxlQUFKLENBQW9CLEtBQUtwRSxJQUF6QixFQUErQjhCLGVBQWUsQ0FBQ2hXLElBQS9DLEVBQXFEcWMsVUFBVSxDQUFDRyxDQUFELENBQS9ELENBQWxCO0FBQ0g7O0FBQ0QsVUFBSUwsS0FBSixFQUFXO0FBQ1AsYUFBSzNZLE1BQUwsQ0FBWXFXLElBQVosQ0FBaUIsS0FBS2dCLFVBQXRCO0FBQ0EsYUFBS0EsVUFBTCxDQUFnQlcsTUFBaEIsQ0FBdUIsS0FBS2xCLFVBQTVCO0FBQ0EsYUFBS08sVUFBTCxHQUFrQixJQUFsQjtBQUNIO0FBQ0o7QUF2S0w7QUFBQTtBQUFBLHlCQTBLUzRCLEtBMUtULEVBMEtnQjtBQUNSLFdBQUszQixVQUFMLEdBQWtCLElBQUl6QyxlQUFKLENBQW9CLEtBQUtuRSxJQUF6QixFQUErQnVJLEtBQS9CLENBQWxCO0FBQ0EsV0FBSzNCLFVBQUwsQ0FBZ0JVLE1BQWhCLENBQXVCLEtBQUtsQixVQUE1QjtBQUNBLGFBQU8sS0FBS1EsVUFBWjtBQUNIO0FBOUtMO0FBQUE7QUFBQSwyQkFnTFd6UCxJQWhMWCxFQWdMaUJ0SyxVQWhMakIsRUFnTDZCNFcsU0FoTDdCLEVBZ0x3QztBQUNoQyxVQUFJLEtBQUs0RCxVQUFMLEtBQW9CLElBQXhCLEVBQThCO0FBQzFCLGFBQUtBLFVBQUwsR0FBa0IsSUFBSTdELGlCQUFKLENBQXNCLEtBQUt4RCxJQUEzQixFQUFpQzdJLElBQWpDLEVBQXVDdEssVUFBdkMsRUFBbUQ0VyxTQUFuRCxDQUFsQjtBQUNBLGFBQUs0RCxVQUFMLENBQWdCQyxNQUFoQixDQUF1QixLQUFLbEIsVUFBNUI7QUFDSDs7QUFDRCxhQUFPLEtBQUtpQixVQUFaO0FBQ0g7QUF0TEw7QUFBQTtBQUFBLGtDQXdMa0JtQixTQXhMbEIsRUF3TDZCO0FBQ3JCblcsYUFBTyxDQUFDb04sR0FBUixDQUFZLE1BQVosRUFBb0IrSSxTQUFTLENBQUNDLEtBQTlCO0FBQ0EsV0FBS0MsV0FBTCxHQUFtQixJQUFJeEUsZ0JBQUosQ0FBcUIsS0FBS2xFLElBQTFCLEVBQWdDd0ksU0FBUyxDQUFDQyxLQUExQyxDQUFuQjtBQUNBLFdBQUtDLFdBQUwsQ0FBaUJwQixNQUFqQixDQUF3QixLQUFLbEIsVUFBN0I7QUFDQSxhQUFPLEtBQUtzQyxXQUFaO0FBQ0g7QUE3TEw7QUFBQTtBQUFBLCtCQStMZUMsS0EvTGYsRUErTHNCO0FBQ2QsVUFBSUMsWUFBWSxHQUFHLElBQUlsRSxnQkFBSixDQUFxQixLQUFLMUUsSUFBMUIsRUFBZ0MySSxLQUFoQyxDQUFuQjtBQUNBQyxrQkFBWSxDQUFDdEIsTUFBYixDQUFvQixLQUFLbEIsVUFBekI7QUFDQSxhQUFPd0MsWUFBUDtBQUNIO0FBRUQ7Ozs7OztBQXJNSjtBQUFBO0FBQUEsMEJBME1VaEUsYUExTVYsRUEwTXlCO0FBQ2pCLFdBQUtpRSxXQUFMLEdBQW1CLElBQUlsRSxnQkFBSixDQUFxQixLQUFLM0UsSUFBMUIsRUFBZ0M0RSxhQUFoQyxDQUFuQjtBQUNBLGFBQU8sS0FBS2lFLFdBQUwsQ0FBaUJ2QixNQUFqQixDQUF3QixLQUFLbEIsVUFBN0IsQ0FBUDtBQUNIO0FBN01MO0FBQUE7QUFBQSwrQkFnTmU7QUFDUCxXQUFLeUMsV0FBTCxHQUFtQixJQUFJNUMsbUJBQUosQ0FBd0IsS0FBS2pHLElBQTdCLENBQW5CO0FBQ0EsYUFBTyxLQUFLNkksV0FBTCxDQUFpQnZCLE1BQWpCLENBQXdCLEtBQUtsQixVQUE3QixDQUFQO0FBQ0g7QUFuTkw7QUFBQTtBQUFBLGdDQXFOZ0I7QUFDUixVQUFJMEMsZUFBZSxHQUFHLElBQUk1Qyx3QkFBSixDQUE2QixLQUFLbEcsSUFBbEMsQ0FBdEI7QUFDQSxhQUFPOEksZUFBZSxDQUFDeEIsTUFBaEIsQ0FBdUIsS0FBS2xCLFVBQTVCLENBQVA7QUFDSDtBQUVEOzs7OztBQTFOSjtBQUFBO0FBQUEscUNBOE5xQjtBQUNiLFdBQUtELEdBQUwsQ0FBUzRDLE9BQVQsQ0FBaUI7QUFDYnhGLGlCQUFTLEVBQUUsS0FBSzRDLEdBQUwsQ0FBU1AsSUFBVCxDQUFjLGNBQWQsSUFBZ0MsS0FBS08sR0FBTCxDQUFTUCxJQUFULENBQWMsY0FBZDtBQUQ5QixPQUFqQixFQUVHLEdBRkg7QUFHSDtBQWxPTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7QUNoV0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtDQUVBOztBQUVPLElBQUlvRCxrQkFBa0IsR0FBRyxFQUF6QjtBQUNBLElBQUlDLDJCQUEyQixHQUFHLEVBQWxDO0FBRVA7Ozs7Ozs7QUFNQSxJQUFJQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQVVDLEdBQVYsRUFBZTtBQUNqQ0EsS0FBRyxDQUFDakcsUUFBSixDQUFhLFFBQWIsRUFDS0EsUUFETCxDQUNjLGFBRGQsRUFFS2tHLFdBRkwsQ0FFaUIsYUFGakIsRUFHS3hELElBSEwsQ0FHVSxVQUhWLEVBR3NCLElBSHRCLEVBSUszRixJQUpMLENBSVUsUUFKVixFQUtLOEgsSUFMTCxDQUtVLGNBTFYsRUFLMEIsTUFMMUI7QUFNSCxDQVBEO0FBVUE7Ozs7Ozs7Ozs7O0FBU08sU0FBU2xILGFBQVQsQ0FBdUJiLElBQXZCLEVBQTZCO0FBQ2hDLE9BQUtBLElBQUwsR0FBWUEsSUFBWjtBQUVBLE9BQUtxSixjQUFMLEdBQXNCLEVBQXRCO0FBQ0EsT0FBSzNWLFlBQUw7QUFDSDs7QUFFRG1OLGFBQWEsQ0FBQ1YsU0FBZCxDQUF3QnpNLFlBQXhCLEdBQXVDLFVBQVU0VixRQUFWLEVBQW9CO0FBQUE7O0FBQ3ZEO0FBQ0EsTUFBSXpnQixLQUFLLEdBQUcsS0FBS21YLElBQUwsQ0FBVW5YLEtBQXRCO0FBQUEsTUFDSTZVLE1BQU0sR0FBRyxLQUFLc0MsSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBRGxDO0FBQUEsTUFFSW5DLE1BQU0sR0FBRyxLQUFLd08sSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFGbEM7QUFHQSxNQUFJK1gsT0FBTyxHQUFHLEVBQWQ7QUFDQTFnQixPQUFLLENBQUNyQixVQUFOLENBQWlCc0QsUUFBakIsQ0FBMEIwZSxRQUExQixHQUFxQ3BCLEtBQXJDLENBQTJDLEdBQTNDLEVBQWdEcUIsT0FBaEQsQ0FBd0QsVUFBQ3ZnQixJQUFELEVBQVU7QUFDOUQsUUFBSUEsSUFBSSxJQUFJLEVBQUVBLElBQUksSUFBSXdnQixzQkFBc0IsQ0FBQ0MsV0FBakMsQ0FBWixFQUEyRDtBQUN2REosYUFBTyxDQUFDNUQsSUFBUixDQUFhaUUsS0FBYixDQUFtQkwsT0FBbkIsRUFBNEIsS0FBSSxDQUFDaE8sYUFBTCxDQUFtQnNPLHVEQUFJLENBQUMzZ0IsSUFBRCxDQUF2QixFQUErQkEsSUFBL0IsRUFBcUNvZ0IsUUFBckMsQ0FBNUI7QUFDSDtBQUNKLEdBSkQsRUFOdUQsQ0FZdkQ7O0FBQ0FsWSxHQUFDLENBQUMwWSxJQUFGLENBQU9GLEtBQVAsQ0FBYXhZLENBQWIsRUFBZ0JtWSxPQUFoQixFQUF5QlEsSUFBekIsQ0FBOEIsWUFBWTtBQUN0QztBQUNBck0sVUFBTSxDQUFDOUosRUFBUCxDQUFVb1csaUJBQVY7QUFDQXRNLFVBQU0sQ0FBQzlKLEVBQVAsQ0FBVXFGLFdBQVYsQ0FBc0JnUixhQUF0QjtBQUNILEdBSkQsRUFJR0MsSUFKSCxDQUlRLFVBQVVqTCxDQUFWLEVBQWE7QUFDakI1TSxXQUFPLENBQUNvTixHQUFSLENBQVkwSyxTQUFaO0FBQ0E5WCxXQUFPLENBQUMrWCxLQUFSLENBQWNuTCxDQUFkO0FBQ0gsR0FQRCxFQU9Hb0wsTUFQSCxDQU9VLFlBQVk7QUFDbEI3WSxVQUFNLENBQUM4WSxxQkFBUDtBQUNILEdBVEQ7QUFVSCxDQXZCRDtBQXlCQTs7Ozs7Ozs7Ozs7Ozs7QUFZQXpKLGFBQWEsQ0FBQ1YsU0FBZCxDQUF3QjVFLGFBQXhCLEdBQXdDLFVBQVVzTyxJQUFWLEVBQWdCM2dCLElBQWhCLEVBQXNCO0FBQUE7O0FBQzFELE1BQUlxaEIsY0FBYyxHQUFHLEVBQXJCOztBQUNBLE1BQUksS0FBS3ZLLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQnhDLE1BQW5CLENBQTBCeUssbUJBQTFCLENBQThDLGdCQUE5QyxDQUFKLEVBQXFFO0FBQ2pFLFFBQUl1TyxJQUFJLEdBQUcsS0FBS3hLLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QndKLElBQTlCLENBQW1DMFosY0FBbkMsR0FBb0QsVUFBcEQsR0FBaUVaLElBQWpFLEdBQXdFLEdBQXhFLEdBQThFQSxJQUF6RjtBQUNBLFNBQUs3SixJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JpQixlQUF4QixDQUF3Q2taLElBQXhDLENBQTZDemMsSUFBN0MsRUFGaUUsQ0FHakU7O0FBQ0EsUUFBSXdoQixVQUFVLEdBQUd0WixDQUFDLENBQUN1WixTQUFGLENBQVlILElBQUksR0FBRyxhQUFuQixDQUFqQixDQUppRSxDQUtqRTs7QUFDQSxRQUFJSSxXQUFXLEdBQUd4WixDQUFDLENBQUN1WixTQUFGLENBQVlILElBQUksR0FBRyxjQUFuQixDQUFsQjtBQUNBLFFBQUlLLFNBQVMsR0FBR3paLENBQUMsQ0FBQ3pJLEdBQUYsQ0FBTTZoQixJQUFJLEdBQUcsWUFBYixFQUEyQixVQUFVcFksSUFBVixFQUFnQjtBQUN2RHdOLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QixhQUFhZ0ssSUFBYixHQUFvQixjQUE3QyxJQUErRHpYLElBQS9EO0FBQ0gsS0FGZSxDQUFoQjtBQUdBLFFBQUkwWSxVQUFVLEdBQUcxWixDQUFDLENBQUN1WixTQUFGLENBQVlILElBQUksR0FBRyxhQUFuQixDQUFqQixDQVZpRSxDQVdqRTs7QUFDQXBaLEtBQUMsQ0FBQzBZLElBQUYsQ0FBT1ksVUFBUCxFQUFtQkcsU0FBbkIsRUFBOEJDLFVBQTlCLEVBQTBDZixJQUExQyxDQUErQyxZQUFNO0FBQ2pELFlBQUksQ0FBQ1YsY0FBTCxDQUFvQjFELElBQXBCLENBQXlCa0UsSUFBekI7O0FBQ0EsWUFBSSxDQUFDN0osSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQ21YLFlBQXJDLENBQWtEQyxhQUFsRCxDQUFnRXJGLElBQWhFLENBQXFFa0UsSUFBckU7O0FBQ0EsWUFBSSxDQUFDN0osSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQ29XLGlCQUFyQzs7QUFDQSxZQUFJLENBQUNoSyxJQUFMLENBQVV6TyxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NDLEVBQWxDLENBQXFDcUYsV0FBckMsQ0FBaURnUixhQUFqRDs7QUFDQSxZQUFJLENBQUNqSyxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JpQixlQUF4QixDQUF3Q3VXLE1BQXhDLENBQStDOVosSUFBL0M7QUFDSCxLQU5EO0FBT0FxaEIsa0JBQWMsQ0FBQzVFLElBQWYsQ0FBb0IrRSxVQUFwQixFQUFnQ0csU0FBaEMsRUFBMkNDLFVBQTNDO0FBQ0g7O0FBQ0QsU0FBT1AsY0FBUDtBQUNILENBeEJEO0FBMEJBOzs7Ozs7Ozs7QUFPQTFKLGFBQWEsQ0FBQ1YsU0FBZCxDQUF3QjNFLFVBQXhCLEdBQXFDLFlBQVk7QUFBQTs7QUFDN0MsTUFBSSxLQUFLd0UsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1CeEMsTUFBbkIsQ0FBMEJ5SyxtQkFBMUIsQ0FBOEMsZ0JBQTlDLENBQUosRUFBcUU7QUFDakUsUUFBSXVPLElBQUksR0FBRyxLQUFLeEssSUFBTCxDQUFVblgsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCd0osSUFBOUIsQ0FBbUMwWixjQUE5QztBQUNBclosS0FBQyxDQUFDNlosT0FBRixDQUFVVCxJQUFJLEdBQUcsWUFBakIsRUFBZ0MsVUFBQ3BZLElBQUQsRUFBVTtBQUN0QztBQUNBLFVBQUlvWCxRQUFRLEdBQUdwWCxJQUFJLENBQUM4WSxPQUFwQjtBQUNBLFVBQUlDLGFBQWEsR0FBR1gsSUFBSSxHQUFDLG9CQUF6QjtBQUNBLFVBQUluaUIsS0FBSyxHQUFHK0ksQ0FBQyxxREFBOEMrWixhQUE5QyxpQ0FBYjtBQUNBLFVBQUlDLElBQUksR0FBR2hhLENBQUMsQ0FBQyxpQkFBRCxFQUFvQjtBQUFDLGlCQUFTO0FBQVYsT0FBcEIsQ0FBWjtBQUNBaWEsWUFBTSxDQUFDQyxJQUFQLENBQVk5QixRQUFaLEVBQXNCK0IsSUFBdEIsR0FBNkI3USxHQUE3QixDQUFpQyxVQUFDeFIsSUFBRCxFQUFVO0FBQ3ZDLFlBQUlzaUIsV0FBVyxHQUFHM0IsdURBQUksQ0FBQ0wsUUFBUSxDQUFDdGdCLElBQUQsQ0FBUixDQUFlQSxJQUFoQixDQUF0QjtBQUNBLFlBQUl1aUIsU0FBUyxHQUFHdmlCLElBQWhCO0FBQ0EsWUFBSWlnQixHQUFHLEdBQUcvWCxDQUFDLENBQUMsMEhBQUQsQ0FBWDtBQUNBLFlBQUlzYSxNQUFNLEdBQUdsQixJQUFJLEdBQUMscUJBQUwsR0FBMkJ0aEIsSUFBM0IsR0FBZ0MsV0FBN0M7O0FBQ0EsWUFBSSxNQUFJLENBQUNtZ0IsY0FBTCxDQUFvQnBPLE9BQXBCLENBQTRCdVEsV0FBNUIsSUFBMkMsQ0FBQyxDQUFoRCxFQUFtRDtBQUMvQ3RDLHlCQUFlLENBQUNDLEdBQUQsQ0FBZjtBQUNILFNBRkQsTUFFTztBQUNIQSxhQUFHLENBQUN0RCxLQUFKLENBQVcsWUFBTTtBQUNiLGtCQUFJLENBQUN0SyxhQUFMLENBQW1CaVEsV0FBbkIsRUFBZ0MsWUFBWWhDLFFBQVEsQ0FBQ3RnQixJQUFELENBQVIsQ0FBZXlpQixLQUEzRDs7QUFDQXpDLDJCQUFlLENBQUNDLEdBQUQsQ0FBZjtBQUNILFdBSEQ7QUFJSCxTQVpzQyxDQWF2Qzs7O0FBQ0EvWCxTQUFDLENBQUMsV0FBRCxDQUFELENBQ0k7QUFESixTQUVLMFMsTUFGTCxDQUVZMVMsQ0FBQyxDQUFDLFNBQVNvWSxRQUFRLENBQUN0Z0IsSUFBRCxDQUFSLENBQWV5aUIsS0FBeEIsR0FBZ0MsT0FBakMsQ0FGYixFQUdLN0gsTUFITCxDQUdZMVMsQ0FBQyxDQUFDLFNBQVNvWSxRQUFRLENBQUN0Z0IsSUFBRCxDQUFSLENBQWUwaUIsUUFBeEIsR0FBbUMsT0FBcEMsQ0FIYixFQUlLOUgsTUFKTCxDQUlZMVMsQ0FBQyxDQUFDLFdBQUQsQ0FBRCxDQUFlMFMsTUFBZixDQUFzQnFGLEdBQXRCLENBSlosRUFLSzBDLFFBTEwsQ0FLY1QsSUFMZDtBQU1ILE9BcEJEO0FBcUJBQSxVQUFJLENBQUNTLFFBQUwsQ0FBY3hqQixLQUFkLEVBM0JzQyxDQTRCdEM7O0FBQ0EsWUFBSSxDQUFDMlgsSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCZ00sSUFBNUIsQ0FBaUMsaUJBQWpDLEVBQW9EMVksS0FBcEQsRUFBMkQsSUFBM0Q7QUFDSCxLQTlCRDtBQStCSDtBQUNKLENBbkNELEM7Ozs7Ozs7Ozs7OztBQzdHQTtBQUNBLE9BQU8sS0FBVSxFQUFFLGtCQUtkOzs7Ozs7Ozs7Ozs7QUNOTDtBQUNBLE9BQU8sS0FBVSxFQUFFLGtCQUtkOzs7Ozs7Ozs7Ozs7O0FDTkw7QUFBQTtBQUFBO0FBQUE7QUFFTyxJQUFJeWpCLFdBQVcsNGtDQUFmO0FBeUJQOzs7Ozs7Ozs7Ozs7QUFXTyxTQUFTMUwsYUFBVCxDQUF1QkosSUFBdkIsRUFBNkJtRyxHQUE3QixFQUFrQztBQUFBOztBQUNyQyxPQUFLbkcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsT0FBS21HLEdBQUwsR0FBV0EsR0FBWDtBQUVBLE9BQUs0RixRQUFMLEdBQWdCNUYsR0FBRyxDQUFDOUYsSUFBSixDQUFTLGNBQVQsQ0FBaEI7QUFDQSxPQUFLMkwsT0FBTCxHQUFlN0YsR0FBRyxDQUFDOUYsSUFBSixDQUFTLGFBQVQsQ0FBZjtBQUNBLE9BQUs0TCxTQUFMLEdBQWlCOUYsR0FBRyxDQUFDOUYsSUFBSixDQUFTLGVBQVQsQ0FBakI7QUFDQSxPQUFLNkwsVUFBTCxHQUFrQi9GLEdBQUcsQ0FBQzlGLElBQUosQ0FBUyxhQUFULENBQWxCO0FBQ0EsT0FBSzhMLFdBQUwsR0FBbUJoRyxHQUFHLENBQUM5RixJQUFKLENBQVMsY0FBVCxDQUFuQjs7QUFFQSxPQUFLK0wsR0FBTCxHQUFXLFlBQU0sQ0FBRSxDQUFuQjs7QUFDQSxPQUFLQyxFQUFMLEdBQVUsWUFBTSxDQUFFLENBQWxCOztBQUNBLE9BQUtILFVBQUwsQ0FBZ0JyRyxLQUFoQixDQUFzQixZQUFNO0FBQ3hCLFNBQUksQ0FBQ3VHLEdBQUw7O0FBQ0EsU0FBSSxDQUFDakcsR0FBTCxDQUFTbUcsS0FBVCxDQUFlLE1BQWY7QUFDSCxHQUhEO0FBSUEsT0FBS0gsV0FBTCxDQUFpQnRHLEtBQWpCLENBQXVCLFlBQU07QUFDekIsU0FBSSxDQUFDd0csRUFBTCxHQUR5QixDQUV6Qjs7QUFDSCxHQUhEO0FBSUg7O0FBRURqTSxhQUFhLENBQUNELFNBQWQsQ0FBd0JvTSxLQUF4QixHQUFnQyxZQUFZO0FBQ3hDLE9BQUtwRyxHQUFMLENBQVNtRyxLQUFULENBQWUsTUFBZjtBQUNILENBRkQ7QUFJQTs7Ozs7Ozs7OztBQVFBbE0sYUFBYSxDQUFDRCxTQUFkLENBQXdCWSxJQUF4QixHQUErQixVQUFVNEssS0FBVixFQUFpQlAsSUFBakIsRUFBdUJvQixPQUF2QixFQUFnQztBQUMzRCxPQUFLVCxRQUFMLENBQWMxYSxJQUFkLENBQW1Cc2EsS0FBbkI7QUFDQSxPQUFLSyxPQUFMLENBQWEzYSxJQUFiLENBQWtCK1osSUFBbEI7QUFDQSxPQUFLakYsR0FBTCxDQUFTbUcsS0FBVCxDQUFlLE1BQWY7QUFDQSxPQUFLSixVQUFMLENBQWdCbEwsSUFBaEI7QUFDQSxPQUFLbUYsR0FBTCxDQUFTc0csU0FBVCxDQUFtQjtBQUNmLGNBQVU7QUFESyxHQUFuQjtBQUlBLE9BQUt0RyxHQUFMLENBQVN1RyxFQUFULENBQVksaUJBQVosRUFBK0IsVUFBVXpOLENBQVYsRUFBYTtBQUN4QyxRQUFJdU4sT0FBTyxLQUFLN2tCLFNBQVosSUFBeUI2a0IsT0FBTyxLQUFLLElBQXpDLEVBQStDO0FBQzNDQSxhQUFPO0FBQ1Y7QUFDSixHQUpEO0FBS0gsQ0FkRDs7QUFnQkFwTSxhQUFhLENBQUNELFNBQWQsQ0FBd0J3TSxPQUF4QixHQUFrQyxVQUFVaEIsS0FBVixFQUFpQlAsSUFBakIsRUFBdUJnQixHQUF2QixFQUE0QkMsRUFBNUIsRUFBZ0NPLE9BQWhDLEVBQXlDO0FBQ3ZFLE1BQUlBLE9BQU8sS0FBS2psQixTQUFoQixFQUEyQjtBQUN2QmlsQixXQUFPLEdBQUcsTUFBVjtBQUNIOztBQUNELE9BQUs3TCxJQUFMLENBQVU0SyxLQUFWLEVBQWlCUCxJQUFqQixFQUF1QmlCLEVBQXZCO0FBQ0EsT0FBS0QsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS0MsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsT0FBS0gsVUFBTCxDQUFnQm5MLElBQWhCLEdBQXVCMVAsSUFBdkIsQ0FBNEJ1YixPQUE1QixFQVB1RSxDQVF2RTtBQUNILENBVEQ7O0FBV0F4TSxhQUFhLENBQUNELFNBQWQsQ0FBd0IwTSwwQkFBeEIsR0FBcUQsWUFBWTtBQUM3RCxPQUFLRixPQUFMLENBQWEsb0JBQWIsRUFBbUMsOEdBQW5DO0FBQ0gsQ0FGRDs7QUFJQXZNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QjJNLHlCQUF4QixHQUFvRCxVQUFVQyxNQUFWLEVBQWtCO0FBQ2xFLE9BQUtoTSxJQUFMLENBQVUsMEJBQVYsdUpBQ3lFZ00sTUFEekU7QUFFSCxDQUhEOztBQUtBM00sYUFBYSxDQUFDRCxTQUFkLENBQXdCNk0sNEJBQXhCLEdBQXVELFVBQVVELE1BQVYsRUFBa0I7QUFDckUsT0FBS2hNLElBQUwsQ0FBVSw4QkFBViwySkFDeUVnTSxNQUR6RTtBQUVILENBSEQ7O0FBS0EzTSxhQUFhLENBQUNELFNBQWQsQ0FBd0I4TSxvQkFBeEIsR0FBK0MsVUFBVUYsTUFBVixFQUFrQjtBQUM3RCxPQUFLaE0sSUFBTCxDQUFVLHFCQUFWLCtIQUNxRGdNLE1BRHJEO0FBRUgsQ0FIRDs7QUFLQTNNLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3QitNLHdCQUF4QixHQUFtRCxVQUFVSCxNQUFWLEVBQWtCO0FBQ2pFLE9BQUtoTSxJQUFMLENBQVUseUJBQVYsc0pBQ3lFZ00sTUFEekU7QUFFSCxDQUhEOztBQUtBM00sYUFBYSxDQUFDRCxTQUFkLENBQXdCZ04sd0JBQXhCLEdBQW1ELFVBQVUvQyxLQUFWLEVBQWlCO0FBQ2hFLE9BQUtySixJQUFMLENBQVUsZ0JBQVYsaUhBQWtJcUosS0FBbEk7QUFDSCxDQUZEOztBQUlBaEssYUFBYSxDQUFDRCxTQUFkLENBQXdCaU4sc0JBQXhCLEdBQWlELFVBQVV6QixLQUFWLEVBQWlCdGIsT0FBakIsRUFBMEI7QUFDdkUsT0FBSzBRLElBQUwsQ0FBVTRLLEtBQVYsRUFBaUJ0YixPQUFqQjtBQUNILENBRkQ7O0FBSUErUCxhQUFhLENBQUNELFNBQWQsQ0FBd0JrTixpQkFBeEIsR0FBNEMsWUFBWSxDQUNwRDtBQUNILENBRkQ7O0FBSUFqTixhQUFhLENBQUNELFNBQWQsQ0FBd0JtTixnQ0FBeEIsR0FBMkQsWUFBWTtBQUNuRSxPQUFLdk0sSUFBTCxDQUFVLGtDQUFWO0FBRUgsQ0FIRDs7QUFLQVgsYUFBYSxDQUFDRCxTQUFkLENBQXdCekQscUJBQXhCLEdBQWdELFlBQVk7QUFDeEQsT0FBS3FFLElBQUwsQ0FBVSx1QkFBVjtBQUVILENBSEQ7O0FBS0FYLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3Qm9OLFVBQXhCLEdBQXFDLFlBQVk7QUFDN0MsTUFBSUMsUUFBUSxHQUFHLEtBQUt4TixJQUFMLENBQVVuWCxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJ3SixJQUE5QixDQUFtQzBjLDJCQUFsRDtBQUNBRCxVQUFRLEdBQUdBLFFBQVEseUJBQWlCQSxRQUFqQixtREFBc0UsRUFBekY7QUFDQSxPQUFLek0sSUFBTCxDQUFVLDZCQUFWLHNhQVErRXlNLFFBUi9FLDB5QkF1QnlELEtBQUt4TixJQUFMLENBQVVuWCxLQUFWLENBQWdCQyxJQUFoQixDQUFxQk8sUUFBckIsRUF2QnpEO0FBMEJILENBN0JEOztBQStCQStXLGFBQWEsQ0FBQ0QsU0FBZCxDQUF3Qm5MLFdBQXhCLEdBQXNDLFlBQVk7QUFBQTs7QUFDOUMsTUFBSTBZLFNBQVMsR0FBRyxLQUFLMU4sSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ29lLElBQWxDLENBQXVDLElBQXZDLENBQWhCO0FBQ0EsTUFBSTVnQixXQUFXLEdBQUcsS0FBS2lULElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QnVCLFdBQXhCLEtBQXdDLEVBQXhDLEdBQTZDLFNBQS9EOztBQUNBLE1BQUlxZixHQUFHLEdBQUcsU0FBTkEsR0FBTSxHQUFNO0FBQ1osUUFBSXdCLE9BQU8sR0FBRyxNQUFJLENBQUN6SCxHQUFMLENBQVM5RixJQUFULENBQWMsMEJBQWQsRUFBMEN1RixJQUExQyxDQUErQyxTQUEvQyxDQUFkOztBQUNBLFFBQUlpSSxNQUFNLEdBQUcsTUFBSSxDQUFDMUgsR0FBTCxDQUFTOUYsSUFBVCxDQUFjLHFCQUFkLEVBQXFDYixHQUFyQyxHQUEyQzRJLEtBQTNDLENBQWlELElBQWpELENBQWI7O0FBQ0EsVUFBSSxDQUFDcEksSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCdUIsV0FBeEIsQ0FBb0MsQ0FBQzZnQixPQUFyQzs7QUFDQSxVQUFJLENBQUM1TixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJHLEtBQTFCLENBQWdDc2UsTUFBaEM7QUFDSCxHQUxEOztBQU1BLE9BQUtsQixPQUFMLENBQWEsd0JBQWIsa0tBSXFDNWYsV0FKckMsb01BUXlEMmdCLFNBUnpELDhNQWFEdEIsR0FiQyxFQWFJLEtBQUtDLEVBYlQsRUFhYSxNQWJiLEVBVDhDLENBdUI5QztBQUNILENBeEJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hMQTtBQUVPLFNBQVNwZCxVQUFULENBQW9CcEcsS0FBcEIsRUFBMkIyVixLQUEzQixFQUFrQztBQUNyQyxNQUFJc1AsVUFBVSxHQUFHLElBQUkvTyxVQUFKLEVBQWpCO0FBQ0EsTUFBSXZHLEtBQUssR0FBR2dHLEtBQUssQ0FBQ0UsTUFBTixDQUFhbEcsS0FBekI7O0FBQ0FzVixZQUFVLENBQUM5TyxNQUFYLEdBQXFCLFVBQUFDLENBQUM7QUFBQSxXQUNsQnBXLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU3NHLE9BQVQsQ0FBaUJqRyxPQUFqQixHQUEyQnBGLFVBQTNCLENBQXNDZ1EsQ0FBdEMsQ0FEa0I7QUFBQSxHQUF0Qjs7QUFHQTZPLFlBQVUsQ0FBQ3hPLFFBQVgsR0FBc0I5RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVN0UCxJQUEvQjtBQUNBNGtCLFlBQVUsQ0FBQ3ZPLFVBQVgsQ0FBc0IvRyxLQUFLLENBQUMsQ0FBRCxDQUEzQjtBQUNBZ0csT0FBSyxDQUFDRSxNQUFOLENBQWFpSyxLQUFiLEdBQXFCLEVBQXJCO0FBQ0g7QUFFTSxTQUFTb0YsUUFBVCxDQUFrQjlOLElBQWxCLEVBQXdCO0FBQzNCLFNBQU9BLElBQUksQ0FBQytOLE9BQUwsQ0FBYSxhQUFiLEVBQTRCLEdBQTVCLEVBQWlDbFksV0FBakMsRUFBUDtBQUNIO0FBRU0sU0FBUy9HLFlBQVQsQ0FBc0JsRyxLQUF0QixFQUE2QjJWLEtBQTdCLEVBQW9DO0FBQUEsOEJBQ0szVixLQUFLLENBQUNtTCxFQUFOLENBQVNzRyxPQUFULENBQWlCakcsT0FBakIsR0FBMkJ0RixZQUEzQixFQURMO0FBQUEsTUFDbEM3RixJQURrQyx5QkFDbENBLElBRGtDO0FBQUEsTUFDNUIra0IsU0FENEIseUJBQzVCQSxTQUQ0QjtBQUFBLE1BQ2pCcFQsUUFEaUIseUJBQ2pCQSxRQURpQjtBQUFBLE1BQ1BxVCxRQURPLHlCQUNQQSxRQURPLEVBRXZDOzs7QUFDQWhsQixNQUFJLEdBQUc2a0IsUUFBUSxDQUFDN2tCLElBQUQsQ0FBZjtBQUNBQSxNQUFJLEdBQUdBLElBQUksR0FBRytrQixTQUFkLENBSnVDLENBS3ZDOztBQUNBLE1BQUlFLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVMsQ0FBQ3ZULFFBQUQsQ0FBVCxFQUFxQjtBQUFDcFIsUUFBSSxFQUFFeWtCO0FBQVAsR0FBckIsQ0FBWDs7QUFDQSxNQUFJRyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGdCQUFyQixFQUF1QztBQUNuQ0YsVUFBTSxDQUFDQyxTQUFQLENBQWlCRSxVQUFqQixDQUE0QkwsSUFBNUIsRUFBa0NqbEIsSUFBbEM7QUFDSCxHQUZELE1BRU07QUFDRixRQUFJdWxCLHFCQUFxQixHQUFHSixNQUFNLENBQUN6SyxRQUFQLENBQWdCQyxhQUFoQixDQUE4QixHQUE5QixDQUE1QjtBQUNBNEsseUJBQXFCLENBQUNDLElBQXRCLEdBQTZCTCxNQUFNLENBQUNNLEdBQVAsQ0FBV0MsZUFBWCxDQUEyQlQsSUFBM0IsQ0FBN0I7QUFDQU0seUJBQXFCLENBQUNuVCxRQUF0QixHQUFpQ3BTLElBQWpDO0FBQ0EwYSxZQUFRLENBQUN3SCxJQUFULENBQWN5RCxXQUFkLENBQTBCSixxQkFBMUI7QUFDQUEseUJBQXFCLENBQUM1SSxLQUF0QjtBQUNBakMsWUFBUSxDQUFDd0gsSUFBVCxDQUFjMEQsV0FBZCxDQUEwQkwscUJBQTFCO0FBQ0g7QUFDSjtBQUVNLElBQU1NLGNBQWI7QUFDSSwwQkFBWS9PLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUNuQixTQUFLbkcsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS21HLEdBQUwsR0FBV0EsR0FBWDtBQUVBLFNBQUszVCxVQUFMLEdBQWtCd04sSUFBSSxDQUFDek8sVUFBTCxDQUFnQmlCLFVBQWxDO0FBQ0EsU0FBSy9HLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLb04sSUFBTCxHQUFZLElBQVo7QUFDSDs7QUFSTDtBQUFBO0FBQUEsaUNBVWlCO0FBQ1QsV0FBS3JHLFVBQUwsQ0FBZ0JnSCxVQUFoQixDQUEyQixLQUFLL04sUUFBaEM7QUFDQSxXQUFLdVUsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCQyxRQUF4QixDQUFpQyxXQUFqQztBQUNBLFdBQUt1VSxJQUFMLENBQVV6TyxVQUFWLENBQXFCK0ksT0FBckIsQ0FBNkIwVSxZQUE3QixDQUEwQyxXQUExQztBQUNIO0FBZEw7QUFBQTtBQUFBLG9DQWdCb0I7QUFDWjtBQUNBLFdBQUtoUCxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JDLFFBQXhCLENBQWlDLFdBQWpDO0FBQ0EsV0FBS3VVLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUIrSSxPQUFyQixDQUE2QjBVLFlBQTdCLENBQTBDLFdBQTFDO0FBQ0g7QUFwQkw7QUFBQTtBQUFBLGtDQXNCa0JuVyxJQXRCbEIsRUFzQndCO0FBQ2hCLFVBQUlBLElBQUksQ0FBQ3BOLFFBQUwsS0FBa0IsS0FBS0EsUUFBM0IsRUFBcUM7QUFDakM7QUFDQSxhQUFLdVUsSUFBTCxDQUFVek8sVUFBVixDQUFxQitJLE9BQXJCLENBQTZCMFUsWUFBN0IsQ0FBMEMsS0FBS3ZqQixRQUEvQyxFQUZpQyxDQUdqQztBQUNBO0FBQ0g7QUFDSjtBQTdCTDtBQUFBO0FBQUEsdUNBK0J1QjtBQUNmLFdBQUsrRyxVQUFMLENBQWdCeWMsU0FBaEIsQ0FBMEIsS0FBS3hqQixRQUEvQixFQUF5QztBQUNyQ3lqQixlQUFPLEVBQUUsS0FBS0MsYUFBTCxDQUFtQjlULElBQW5CLENBQXdCLElBQXhCLENBRDRCO0FBRXJDK1QsZUFBTyxFQUFFLEtBQUtDLGFBQUwsQ0FBbUJoVSxJQUFuQixDQUF3QixJQUF4QjtBQUY0QixPQUF6QztBQUlIO0FBcENMO0FBQUE7QUFBQSwwQkFzQ1VpVSxXQXRDVixFQXNDdUJDLFNBdEN2QixFQXNDa0M7QUFDMUIsV0FBSzlqQixRQUFMLEdBQWdCNmpCLFdBQWhCO0FBQ0EsV0FBS3pXLElBQUwsR0FBWSxLQUFLckcsVUFBTCxDQUFnQnNILE9BQWhCLENBQXdCd1YsV0FBeEIsQ0FBWjtBQUNBLFdBQUtFLGdCQUFMO0FBQ0g7QUFFRDs7Ozs7OztBQTVDSjtBQUFBO0FBQUEseUJBa0RTRixXQWxEVCxFQWtEc0JDLFNBbER0QixFQWtEaUNFLFNBbERqQyxFQWtENEM7QUFDcEMsV0FBS2pkLFVBQUwsQ0FBZ0JrZCxnQkFBaEIsQ0FBaUMsS0FBS2prQixRQUF0QztBQUNBLFdBQUtvTixJQUFMLEdBQVksSUFBWjtBQUNBLFdBQUtwTixRQUFMLEdBQWdCLElBQWhCO0FBQ0g7QUF0REw7QUFBQTtBQUFBLCtCQXdEZStTLEtBeERmLEVBd0RzQjtBQUNkLFVBQUkvUyxRQUFRLEdBQUcrUyxLQUFLLENBQUNFLE1BQU4sQ0FBYVksUUFBNUI7QUFDQSxVQUFJekUsUUFBUSxHQUFHMkQsS0FBSyxDQUFDRSxNQUFOLENBQWFVLE1BQTVCO0FBQ0EsV0FBS3ZHLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUJhLFFBQWpCO0FBQ0g7QUE1REw7QUFBQTtBQUFBLG1DQThEbUI7QUFDWCxVQUFJcFAsUUFBUSxHQUFHa1YsZ0RBQU8sQ0FBQ2dQLGFBQVIsQ0FBc0IsS0FBS2xrQixRQUEzQixDQUFmO0FBQ0EsYUFBTztBQUNIdkMsWUFBSSxFQUFFdUMsUUFBUSxDQUFDdkMsSUFEWjtBQUVIK2tCLGlCQUFTLEVBQUV4aUIsUUFBUSxDQUFDaEMsSUFGakI7QUFHSG9SLGdCQUFRLEVBQUUsS0FBS2hDLElBQUwsQ0FBVW1CLE1BQVYsRUFIUDtBQUlIa1UsZ0JBQVEsRUFBRTtBQUpQLE9BQVA7QUFNSDtBQXRFTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFFQSxJQUFNMEIsbUJBQW1CLEdBQUcsQ0FDeEIsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixRQUF2QixFQUFpQyxTQUFqQyxFQUE0QyxzREFBNUMsQ0FEd0IsRUFFeEIsQ0FBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixTQUFqQixFQUE0QixNQUE1QixFQUFvQywySUFBcEMsQ0FGd0IsRUFHeEIsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixFQUF6QixFQUE2QixRQUE3QixFQUF1QyxrR0FBdkMsQ0FId0IsRUFJeEI7QUFDQSxDQUFDLFdBQUQsRUFBYyxZQUFkLEVBQTRCL2pCLG9EQUFZLENBQUNDLElBQXpDLEVBQStDRCxvREFBL0MsRUFBNkQseUVBQTdELENBTHdCLEVBTXhCLENBQUMsVUFBRCxFQUFhLFVBQWIsRUFBeUIsRUFBekIsRUFBNkIsUUFBN0IsRUFBdUMsNkVBQXZDLENBTndCLEVBT3hCLENBQUMsZ0JBQUQsRUFBbUIsaUJBQW5CLEVBQXNDLEtBQXRDLEVBQTZDLE1BQTdDLEVBQXFELDBHQUFyRCxDQVB3QixFQVF4QixDQUFDLFFBQUQsRUFBVyxTQUFYLEVBQXNCLEVBQXRCLEVBQTBCLFFBQTFCLEVBQW9DLDZYQUFwQyxDQVJ3QixFQVN4QixDQUFDLFdBQUQsRUFBYyxZQUFkLEVBQTRCLEtBQTVCLEVBQW1DLE1BQW5DLEVBQTJDLCtEQUEzQyxDQVR3QixFQVV4QixDQUFDLGtCQUFELEVBQXFCLG9CQUFyQixFQUEyQyxLQUEzQyxFQUFrRCxNQUFsRCxFQUEwRCxvRkFBMUQsQ0FWd0IsRUFXeEIsQ0FBQyxpQkFBRCxFQUFvQixrQkFBcEIsRUFBd0MsS0FBeEMsRUFBK0MsTUFBL0MsRUFBdUQsNEVBQXZELENBWHdCLEVBWXhCLENBQUMsc0JBQUQsRUFBeUIsd0JBQXpCLEVBQW1ELEtBQW5ELEVBQTBELE1BQTFELEVBQWtFLDJOQUFsRSxDQVp3QixFQWF4QixDQUFDLG1CQUFELEVBQXNCLHFCQUF0QixFQUE2QyxLQUE3QyxFQUFvRCxNQUFwRCxFQUE0RCw0SEFBNUQsQ0Fid0IsRUFjeEIsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDLEVBQStDLHFFQUEvQyxDQWR3QixFQWV4QixDQUFDLGNBQUQsRUFBaUIsZUFBakIsRUFBa0MsS0FBbEMsRUFBeUMsTUFBekMsRUFBaUQscUhBQWpELENBZndCLEVBZ0J4QixDQUFDLGFBQUQsRUFBZ0IsY0FBaEIsRUFBZ0MsS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsMkRBQS9DLENBaEJ3QixFQWlCeEIsQ0FBQyxjQUFELEVBQWlCLFdBQWpCLEVBQThCLEtBQTlCLEVBQXFDLE1BQXJDLEVBQTZDLDZFQUE3QyxDQWpCd0IsRUFrQnhCLENBQUMsY0FBRCxFQUFpQixZQUFqQixFQUErQixJQUEvQixFQUFxQyxNQUFyQyxFQUE2QywwR0FBN0MsQ0FsQndCLEVBbUJ4QixDQUFDLFVBQUQsRUFBYSxXQUFiLEVBQTBCLEtBQTFCLEVBQWlDLE1BQWpDLEVBQXlDLHdMQUF6QyxDQW5Cd0IsRUFvQnhCLENBQUMsaUJBQUQsRUFBb0Isa0JBQXBCLEVBQXdDLEtBQXhDLEVBQStDLE1BQS9DLEVBQXVELDRIQUF2RCxDQXBCd0IsRUFxQnhCLENBQUMsYUFBRCxFQUFnQixjQUFoQixFQUFnQyxLQUFoQyxFQUF1QyxNQUF2QyxFQUErQywyR0FBL0MsQ0FyQndCLEVBc0J4QjtBQUNBLENBQUMsZ0JBQUQsRUFBbUIsaUJBQW5CLEVBQXNDLEtBQXRDLEVBQTZDLE1BQTdDLEVBQXFELGlHQUFyRCxDQXZCd0IsRUF3QnhCLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIsSUFBNUIsRUFBa0MsTUFBbEMsRUFBMEMsZ0VBQTFDLENBeEJ3QixFQXlCeEIsQ0FBQyxrQkFBRCxFQUFxQixvQkFBckIsRUFBMkMsS0FBM0MsRUFBa0QsTUFBbEQsRUFBMEQsNkhBQTFELENBekJ3QixFQTBCeEIsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDLEVBQStDLGlEQUEvQyxDQTFCd0IsRUEyQnhCLENBQUMsaUJBQUQsRUFBb0IsbUJBQXBCLEVBQXlDLEtBQXpDLEVBQWdELE1BQWhELEVBQXdELDREQUF4RCxDQTNCd0IsRUE0QnhCLENBQUMsU0FBRCxFQUFZLFVBQVosRUFBd0IsS0FBeEIsRUFBK0IsTUFBL0IsRUFBdUMsOERBQXZDLENBNUJ3QixFQTZCeEIsQ0FBQyxjQUFELEVBQWlCLGVBQWpCLEVBQWtDLEtBQWxDLEVBQXlDLE1BQXpDLEVBQWlELG1FQUFqRCxDQTdCd0IsRUE4QnhCLENBQUMsMEJBQUQsRUFBNkIsNkJBQTdCLEVBQTRELEtBQTVELEVBQW1FLE1BQW5FLEVBQTJFLGtFQUEzRSxDQTlCd0IsRUErQnhCO0FBQ0EsQ0FBQyxzQkFBRCxFQUF5Qix3QkFBekIsRUFBbUQsS0FBbkQsRUFBMEQsTUFBMUQsRUFBa0UsaUlBQWxFLENBaEN3QixFQWlDeEIsQ0FBQyxvQkFBRCxFQUF1QixzQkFBdkIsRUFBK0MsS0FBL0MsRUFBc0QsTUFBdEQsRUFBOEQsMkRBQTlELENBakN3QixFQWtDeEIsQ0FBQyxpQkFBRCxFQUFvQixtQkFBcEIsRUFBeUMsS0FBekMsRUFBZ0QsTUFBaEQsRUFBd0QsaURBQXhELENBbEN3QixFQW1DeEIsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDLEVBQStDLDREQUEvQyxDQW5Dd0IsRUFvQ3hCLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEIsS0FBMUIsRUFBaUMsTUFBakMsRUFBeUMsNERBQXpDLENBcEN3QixDQUE1QjtBQXVDTyxJQUFJbkMsYUFBYSxHQUFHO0FBQ3ZCQyxTQUFPLEVBQUUsU0FEYztBQUV2QmttQixNQUFJLEVBQUUsTUFGaUI7QUFHdkJDLE1BQUksRUFBRSxNQUhpQjtBQUl2QkMsU0FBTyxFQUFFO0FBSmMsQ0FBcEI7O0FBT1AsU0FBU0MsZ0JBQVQsQ0FBMEI5bUIsSUFBMUIsRUFBZ0M7QUFDNUIsT0FBSyxJQUFJb2YsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHc0gsbUJBQW1CLENBQUM5VyxNQUF0QyxFQUE4Q3dQLENBQUMsRUFBL0MsRUFBbUQ7QUFDL0MsUUFBSXNILG1CQUFtQixDQUFDdEgsQ0FBRCxDQUFuQixDQUF1QixDQUF2QixNQUE4QnBmLElBQWxDLEVBQXdDO0FBQ3BDLGFBQU8wbUIsbUJBQW1CLENBQUN0SCxDQUFELENBQW5CLENBQXVCLENBQXZCLENBQVA7QUFDSDtBQUNKOztBQUNELFNBQU8sbUNBQVA7QUFDSDs7QUFFRCxTQUFTMkgsZ0JBQVQsQ0FBMEIvbUIsSUFBMUIsRUFBZ0NnbkIsSUFBaEMsRUFBc0NDLElBQXRDLEVBQTRDO0FBQ3hDLHNLQUM0RUEsSUFENUUsK0ZBRTJFQSxJQUYzRSx3REFHa0NELElBSGxDLDRIQUk0RmhuQixJQUo1RjtBQU1IOztBQUVELElBQU1rbkIsMkNBQTJDLEdBQUdSLG1CQUFtQixDQUNuRTtBQURtRSxDQUVsRVMsTUFGK0MsQ0FFeEMsVUFBQ0MsT0FBRDtBQUFBLFNBQWFBLE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZSxNQUE1QjtBQUFBLENBRndDLEVBRy9DNVYsR0FIK0MsQ0FHM0MsVUFBQzRWLE9BQUQsRUFBYTtBQUNkLE1BQUlDLFVBQVUsR0FBR0QsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXbEksS0FBWCxDQUFpQixHQUFqQixFQUFzQjFOLEdBQXRCLENBQTBCLFVBQUE4VixJQUFJO0FBQUEsV0FBR0EsSUFBSSxDQUFDdEksTUFBTCxDQUFZLENBQVosRUFBZXVJLFdBQWYsS0FBNkJELElBQUksQ0FBQ25XLEtBQUwsQ0FBVyxDQUFYLENBQWhDO0FBQUEsR0FBOUIsRUFBOEVzVCxJQUE5RSxDQUFtRixHQUFuRixDQUFqQjtBQUNBLHVMQUdnRTJDLE9BQU8sQ0FBQyxDQUFELENBSHZFLGdCQUcrRUMsVUFIL0UsMk5BT21GRCxPQUFPLENBQUMsQ0FBRCxDQVAxRiw4RUFRc0RBLE9BQU8sQ0FBQyxDQUFELENBUjdELDhMQWFjQSxPQUFPLENBQUMsQ0FBRCxDQWJyQjtBQWtCSCxDQXZCK0MsRUF1QjdDM0MsSUF2QjZDLENBdUJ4QyxNQXZCd0MsQ0FBcEQ7QUF5Qk8sSUFBTStDLCtCQUErQixtMEpBdUd0QlQsZ0JBQWdCLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUJwa0Isb0RBQVksQ0FBQzhrQixLQUFwQyxDQXZHTSxtQ0F3R3RCVixnQkFBZ0IsQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQnBrQixvREFBWSxDQUFDK2tCLEtBQWxDLENBeEdNLG1DQXlHdEJYLGdCQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCcGtCLG9EQUFZLENBQUNDLElBQXBDLENBekdNLDBMQThHdEJra0IsZ0JBQWdCLENBQUMsV0FBRCxDQTlHTSxxNENBdUl0QkEsZ0JBQWdCLENBQUMsVUFBRCxDQXZJTSxtaEJBa0p0QkEsZ0JBQWdCLENBQUMsVUFBRCxDQWxKTSx3NkJBb0t0QkEsZ0JBQWdCLENBQUMsU0FBRCxDQXBLTSxzd0JBb0x0QkEsZ0JBQWdCLENBQUMsTUFBRCxDQXBMTSw4ZkErTHRCQSxnQkFBZ0IsQ0FBQyxRQUFELENBL0xNLCtGQW9NbENJLDJDQXBNa0Msc0NBQXJDO0FBME1BLFNBQVNTLHNCQUFULENBQWdDaG9CLEtBQWhDLEVBQXVDO0FBQzFDLE1BQUlpQyxRQUFRLEdBQUcsRUFBZjtBQUNBOGtCLHFCQUFtQixDQUFDbkcsT0FBcEIsQ0FBNEIsVUFBQTZHLE9BQU8sRUFBSTtBQUNuQyxRQUFJUSxVQUFVLEdBQUdSLE9BQU8sQ0FBQyxDQUFELENBQXhCO0FBQUEsUUFBNkJTLFVBQVUsR0FBR1QsT0FBTyxDQUFDLENBQUQsQ0FBakQ7QUFBQSxRQUFzRC9uQixZQUFZLEdBQUcrbkIsT0FBTyxDQUFDLENBQUQsQ0FBNUU7QUFDQSxRQUFJM0gsS0FBSyxHQUFHOWYsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNELFFBQWpCLENBQTBCZ21CLFVBQTFCLEdBQVosQ0FGbUMsQ0FHbkM7O0FBQ0EsUUFBSW5JLEtBQUssS0FBS3BnQixZQUFkLEVBQTRCO0FBQ3hCdUMsY0FBUSxDQUFDaW1CLFVBQUQsQ0FBUixHQUF1QnBJLEtBQXZCO0FBQ0g7QUFDSixHQVBEO0FBUUEsU0FBT3hQLElBQUksQ0FBQ0MsU0FBTCxDQUFldE8sUUFBZixDQUFQO0FBQ0g7QUFFTSxTQUFTeUksc0JBQVQsQ0FBZ0MxSyxLQUFoQyxFQUF1Q2lDLFFBQXZDLEVBQWlEO0FBQ3BELE1BQUlBLFFBQUosRUFBYztBQUNWQSxZQUFRLEdBQUdxTyxJQUFJLENBQUNnRyxLQUFMLENBQVdyVSxRQUFYLENBQVg7QUFDQThrQix1QkFBbUIsQ0FBQ25HLE9BQXBCLENBQTRCLFVBQUE2RyxPQUFPLEVBQUk7QUFDbkMsVUFBSVEsVUFBVSxHQUFHUixPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFVBQTZCUyxVQUFVLEdBQUdULE9BQU8sQ0FBQyxDQUFELENBQWpEOztBQUNBLFVBQUlTLFVBQVUsSUFBSWptQixRQUFsQixFQUE0QjtBQUN4QmpDLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmdtQixVQUExQixFQUFzQ2htQixRQUFRLENBQUNpbUIsVUFBRCxDQUE5QztBQUNILE9BRkQsTUFFTztBQUNIbG9CLGFBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQmdtQixVQUExQixFQUFzQ1IsT0FBTyxDQUFDLENBQUQsQ0FBN0M7QUFDSDtBQUNKLEtBUEQ7O0FBU0EsUUFBSXhsQixRQUFRLENBQUNrbUIsVUFBYixFQUF5QjtBQUNyQm5vQixXQUFLLENBQUMyQyxPQUFOLENBQWNJLFVBQWQsQ0FBeUJkLFFBQVEsQ0FBQ2ttQixVQUFsQztBQUNIO0FBQ0o7QUFDSjtBQUVNLFNBQVNqbUIsMkJBQVQsQ0FBcUN4RCxhQUFyQyxFQUFvRDtBQUN2RCxNQUFJdUQsUUFBUSxHQUFHLEVBQWY7QUFDQThrQixxQkFBbUIsQ0FBQ25HLE9BQXBCLENBQTRCLFVBQUE2RyxPQUFPLEVBQUk7QUFDbkMsUUFBSVEsVUFBVSxHQUFHUixPQUFPLENBQUMsQ0FBRCxDQUF4QjtBQUFBLFFBQTZCUyxVQUFVLEdBQUdULE9BQU8sQ0FBQyxDQUFELENBQWpEO0FBQUEsUUFBc0QvbkIsWUFBWSxHQUFHK25CLE9BQU8sQ0FBQyxDQUFELENBQTVFO0FBQUEsUUFDSVcsU0FBUyxHQUFHWCxPQUFPLENBQUMsQ0FBRCxDQUR2Qjs7QUFFQSxRQUFJL29CLGFBQWEsQ0FBQyx5QkFBdUJ3cEIsVUFBeEIsQ0FBYixLQUFxRHBwQixTQUF6RCxFQUFvRTtBQUNoRW1ELGNBQVEsQ0FBQ2dtQixVQUFELENBQVIsR0FBdUI5bkIsRUFBRSxDQUFDQyxVQUFILENBQWNWLFlBQWQsQ0FBdkI7QUFDSCxLQUZELE1BRU87QUFDSCxVQUFJMm9CLFdBQVcsR0FBRzNwQixhQUFhLENBQUMseUJBQXVCd3BCLFVBQXhCLENBQS9COztBQUNBLFVBQUlFLFNBQVMsS0FBSyxNQUFsQixFQUEwQjtBQUN0QkMsbUJBQVcsR0FBR0EsV0FBVyxDQUFDcGIsV0FBWixPQUE4QixNQUE1QztBQUNIOztBQUNEaEwsY0FBUSxDQUFDZ21CLFVBQUQsQ0FBUixHQUF1QjluQixFQUFFLENBQUNDLFVBQUgsQ0FBY2lvQixXQUFkLENBQXZCO0FBQ0g7QUFDSixHQVpEO0FBY0EsU0FBT3BtQixRQUFQO0FBQ0g7O0lBRUtxbUIsc0I7Ozs7O0FBQ0Ysa0NBQVluUixJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBS2lMLEtBQUwsR0FBYSxLQUFiO0FBRm1CO0FBR3RCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsd0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYixDQUYwQixDQUcxQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFLQyxlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0JqVyxJQUFsQixDQUF1QixJQUF2QixDQUF2QixDQVAwQixDQVMxQjtBQUNIOzs7aUNBRVlrVyxXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWIsQ0FEWSxDQUVaOztBQUVBLGFBQUtBLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZNVMsSyxFQUFPO0FBQ2hCLFdBQUs0UyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYixDQURZLENBRVo7QUFDQTs7QUFDQSxhQUFLQSxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTlCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBV0gsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQTVDZ0NSLCtEOztBQStDOUIsSUFBTXlDLGtCQUFrQixHQUFHO0FBQzlCdG9CLE1BQUksRUFBRSxxQkFEd0I7QUFFOUJ1b0IsWUFBVSxFQUFFLENBQUMsOEJBQUQsQ0FGa0I7QUFHOUJDLGFBQVcsRUFBRVAsc0JBSGlCO0FBSTlCUSxVQUFRLEVBQUVqQjtBQUpvQixDQUEzQixDOzs7Ozs7Ozs7Ozs7O0FDcllQO0FBQUE7QUFBTyxJQUFNa0IsY0FBYyxnNUNBQXBCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZQO0FBRU8sSUFBTUMsaUJBQWlCLHNnQ0FBdkI7O0lBMEJEQyxlOzs7OztBQUNGLDJCQUFZOVIsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUEsNkJBQ2JuRyxJQURhLEVBQ1BtRyxHQURPO0FBRXRCOzs7OzBCQUVLbUosVyxFQUFhQyxTLEVBQVc7QUFDMUIsaUZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUVBLFVBQUluaUIsYUFBYSxHQUFHLEtBQUs0UyxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0I0QixhQUF4QixFQUFwQjs7QUFDQSxVQUFJQSxhQUFhLEtBQUssSUFBdEIsRUFBNEI7QUFDeEIsYUFBSytQLFlBQUw7QUFDSDs7QUFFRCxXQUFLNFUsbUJBQUwsR0FBMkIsS0FBS2xaLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0I7QUFDQTs7Ozs7O0FBT0g7OzttQ0FFYztBQUFBOztBQUNYLFdBQUsyRSxJQUFMLENBQVV6TyxVQUFWLENBQXFCQyxNQUFyQixDQUE0QjNDLGlCQUE1QixDQUE4QyxVQUFDeU4sUUFBRCxFQUFjO0FBQ3hELFlBQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQixlQUFJLENBQUN5RCxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0I0QixhQUF4QixDQUFzQ2tQLFFBQVEsQ0FBQzlELEtBQS9DO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZUFBSSxDQUFDd0gsSUFBTCxDQUFVek8sVUFBVixDQUFxQnlnQixPQUFyQixDQUE2QmhGLDRCQUE3QixDQUEwRDFRLFFBQVEsQ0FBQ2pNLE9BQW5FO0FBQ0g7QUFDSixPQU5EO0FBT0g7OztpQ0FFWWtoQixXLEVBQWEsQ0FFekI7OztpQ0FFWS9TLEssRUFBTztBQUNoQjs7Ozs7O0FBTUg7Ozt5QkFFSThRLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLc0MsbUJBQUwsQ0FBeUJFLE9BQXpCOztBQUNBLGdGQUFXM0MsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQWxEeUJSLCtEOztBQXFEdkIsSUFBTW1ELFdBQVcsR0FBRztBQUN2QmhwQixNQUFJLEVBQUUsT0FEaUI7QUFFdkJ1b0IsWUFBVSxFQUFFLENBQUMsaUJBQUQsQ0FGVztBQUd2QkMsYUFBVyxFQUFFSSxlQUhVO0FBSXZCSCxVQUFRLEVBQUVFO0FBSmEsQ0FBcEIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pGUDtBQUNBO0FBRU8sSUFBTU0sZ0JBQWdCLG1CQUN2QlAsOERBRHVCLDRGQUF0Qjs7SUFPRFEsYzs7Ozs7QUFDRiwwQkFBWXBTLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTW5HLElBQU4sRUFBWW1HLEdBQVo7QUFDQSxVQUFLekssVUFBTCxHQUFrQjJXLFVBQVUsQ0FBQ0MsWUFBWCxDQUF3Qm5NLEdBQUcsQ0FBQzlGLElBQUosQ0FBUyxzQkFBVCxFQUFpQyxDQUFqQyxDQUF4QixFQUE2RDtBQUMzRWtTLDZCQUF1QixFQUFFLElBRGtEO0FBRTNFQyxpQkFBVyxFQUFFLElBRjhEO0FBRzNFQyxxQkFBZSxFQUFFLENBSDBEO0FBSTNFQyxnQkFBVSxFQUFFLENBSitEO0FBSzNFQyxhQUFPLEVBQUUsQ0FMa0U7QUFNM0VDLG9CQUFjLEVBQUUsS0FOMkQ7QUFPM0V6QyxVQUFJLEVBQUUsTUFQcUU7QUFRM0UwQyxlQUFTLEVBQUU7QUFDUCxlQUFPLFlBREE7QUFFUCxxQkFBYSxZQUZOO0FBR1AsZUFBTyxhQUFVQyxFQUFWLEVBQWM7QUFDakIsY0FBSUEsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBSixFQUFnQztBQUM1QmtYLGNBQUUsQ0FBQ25YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLEtBQTNCO0FBQ0gsV0FGRCxNQUVPO0FBQ0htWCxjQUFFLENBQUN0bkIsT0FBSCxDQUFXK0QsS0FBWCxDQUFpQndqQixJQUFqQjtBQUNIO0FBQ0osU0FUTTtBQVVQLGVBQU8sYUFBVUQsRUFBVixFQUFjO0FBQ2pCQSxZQUFFLENBQUNuWCxTQUFILENBQWEsWUFBYixFQUEyQixDQUFDbVgsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBNUI7QUFDSDtBQVpNO0FBUmdFLEtBQTdELENBQWxCO0FBdUJBLFVBQUt3VixLQUFMLEdBQWEsS0FBYjtBQXpCbUI7QUEwQnRCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsZ0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtqVixZQUFMLENBQWtCLEtBQUt0RCxJQUFMLENBQVVtQixNQUFWLEVBQWxCLEVBSDBCLENBSTFCOztBQUNBLFdBQUsrWCxtQkFBTCxHQUEyQixLQUFLbFosSUFBTCxDQUFVbUIsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQUwwQixDQU0xQjs7QUFDQSxXQUFLZ1csZUFBTCxHQUF1QixLQUFLQyxZQUFMLENBQWtCalcsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBdkI7QUFDQSxXQUFLSyxVQUFMLENBQWdCZ1IsRUFBaEIsQ0FBbUIsUUFBbkIsRUFBNkIsS0FBSzJFLGVBQWxDOztBQUNBLFVBQUk5QixTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEI7QUFDQXlELGtCQUFVLENBQUMsS0FBS3RYLFVBQUwsQ0FBZ0I3SCxPQUFoQixDQUF3QndILElBQXhCLENBQTZCLEtBQUtLLFVBQWxDLENBQUQsRUFBZ0QsQ0FBaEQsQ0FBVjtBQUNILE9BWnlCLENBYTFCOzs7QUFDQSxXQUFLQSxVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQzJULFdBQVcsQ0FBQ2xWLFVBQVosQ0FBdUIsR0FBdkIsS0FBK0IsQ0FBQyxLQUFLNEYsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRSxVQUF4QixFQUF0RTtBQUVIOzs7aUNBRVk2bEIsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFWLFVBQUwsQ0FBZ0J1WCxRQUFoQixDQUF5QjFCLFdBQXpCO0FBQ0EsYUFBSzdWLFVBQUwsQ0FBZ0I3SCxPQUFoQjtBQUNBLGFBQUt1ZCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTVTLEssRUFBTztBQUNoQixXQUFLNFMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLdlksSUFBTCxDQUFVbUIsTUFBVixDQUFpQixLQUFLMEIsVUFBTCxDQUFnQndYLFFBQWhCLEVBQWpCO0FBQ0EsYUFBSzlCLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUtzQyxtQkFBTCxDQUF5QkUsT0FBekI7QUFDQSxXQUFLdlcsVUFBTCxDQUFnQnlYLEdBQWhCLENBQW9CLFFBQXBCLEVBQThCLEtBQUs5QixlQUFuQztBQUNBLFdBQUszVixVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQyxLQUF0Qzs7QUFDQSwrRUFBVzJULFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUF4RXdCUiwrRDs7QUEyRXRCLElBQU1xRSxVQUFVLEdBQUc7QUFDdEJscUIsTUFBSSxFQUFFLE1BRGdCO0FBRXRCdW9CLFlBQVUsRUFBRSxDQUFDLE9BQUQsQ0FGVTtBQUd0QkMsYUFBVyxFQUFFVSxjQUhTO0FBSXRCVCxVQUFRLEVBQUVRO0FBSlksQ0FBbkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JGUDtBQUNBO0FBRU8sSUFBTWtCLG9CQUFvQixtQkFDM0J6Qiw4REFEMkIsd0VBQTFCOztJQU1EMEIsa0I7Ozs7O0FBQ0YsOEJBQVl0VCxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBS29OLEdBQUwsR0FBVyxJQUFJclQsT0FBSixDQUFZO0FBQ25Cc1QsYUFBTyxFQUFFck4sR0FBRyxDQUFDOUYsSUFBSixDQUFTLDBCQUFULEVBQXFDLENBQXJDLENBRFU7QUFFbkJvVCw2QkFBdUIsRUFBRSxLQUZOO0FBR25CQyxlQUFTLEVBQUUsSUFIUTtBQUluQkMsZUFBUyxFQUFFLE9BSlE7QUFLbkI7QUFDQTtBQUNBQyxxQkFBZSxFQUFFO0FBQ2JDLDhCQUFzQixFQUFFO0FBRFgsT0FQRTtBQVVuQmpCLG9CQUFjLEVBQUUsS0FWRztBQVduQkQsYUFBTyxFQUFFO0FBWFUsS0FBWixDQUFYO0FBYUEsVUFBS3ZCLEtBQUwsR0FBYSxLQUFiO0FBZm1CO0FBZ0J0Qjs7OzswQkFFSzlCLFcsRUFBYUMsUyxFQUFXO0FBQzFCLG9GQUFZRCxXQUFaLEVBQXlCQyxTQUF6Qjs7QUFDQSxXQUFLNkIsS0FBTCxHQUFhLEtBQWI7QUFDQSxXQUFLalYsWUFBTCxDQUFrQixLQUFLdEQsSUFBTCxDQUFVbUIsTUFBVixFQUFsQixFQUgwQixDQUkxQjs7QUFDQSxXQUFLK1gsbUJBQUwsR0FBMkIsS0FBS2xaLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUJpSCxTQUFqQixDQUEyQixLQUFLOUUsWUFBTCxDQUFrQmQsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBM0IsQ0FBM0IsQ0FMMEIsQ0FNMUI7O0FBQ0EsV0FBS2dXLGVBQUwsR0FBdUIsS0FBS0MsWUFBTCxDQUFrQmpXLElBQWxCLENBQXVCLElBQXZCLENBQXZCO0FBQ0EsV0FBS2tZLEdBQUwsQ0FBU08sVUFBVCxDQUFvQnBILEVBQXBCLENBQXVCLFFBQXZCLEVBQWlDLEtBQUsyRSxlQUF0Qzs7QUFDQSxVQUFJOUIsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCO0FBQ0F5RCxrQkFBVSxDQUFDLEtBQUtPLEdBQUwsQ0FBU08sVUFBVCxDQUFvQmpnQixPQUFwQixDQUE0QndILElBQTVCLENBQWlDLEtBQUtrWSxHQUFMLENBQVNPLFVBQTFDLENBQUQsRUFBd0QsQ0FBeEQsQ0FBVjtBQUNIO0FBQ0o7OztpQ0FFWXZDLFcsRUFBYTtBQUN0QixXQUFLSCxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUttQyxHQUFMLENBQVM1SyxLQUFULENBQWU0SSxXQUFmO0FBQ0EsYUFBS2dDLEdBQUwsQ0FBU08sVUFBVCxDQUFvQmpnQixPQUFwQjtBQUNBLGFBQUt1ZCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTVTLEssRUFBTztBQUNoQixXQUFLNFMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLdlksSUFBTCxDQUFVbUIsTUFBVixDQUFpQixLQUFLdVosR0FBTCxDQUFTNUssS0FBVCxFQUFqQjtBQUNBLGFBQUt5SSxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7Ozt5QkFFSTlCLFcsRUFBYUMsUyxFQUFXRSxTLEVBQVc7QUFDcEM7QUFDQSxXQUFLc0MsbUJBQUwsQ0FBeUJFLE9BQXpCO0FBQ0EsV0FBS3NCLEdBQUwsQ0FBU08sVUFBVCxDQUFvQlgsR0FBcEIsQ0FBd0IsUUFBeEIsRUFBa0MsS0FBSzlCLGVBQXZDOztBQUNBLG1GQUFXL0IsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQTFENEJSLCtEOztBQTZEMUIsSUFBTWdGLGNBQWMsR0FBRztBQUMxQjdxQixNQUFJLEVBQUUsVUFEb0I7QUFFMUJ1b0IsWUFBVSxFQUFFLENBQUMsS0FBRCxDQUZjO0FBRzFCQyxhQUFXLEVBQUU0QixrQkFIYTtBQUkxQjNCLFVBQVEsRUFBRTBCO0FBSmdCLENBQXZCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFUDs7Ozs7O0FBTUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFTyxJQUFJeG5CLFlBQVksR0FBRztBQUN0QjhrQixPQUFLLEVBQUUsT0FEZTtBQUV0QkMsT0FBSyxFQUFFLE9BRmU7QUFHdEI5a0IsTUFBSSxFQUFFO0FBSGdCLENBQW5COztBQU1QLFNBQVNrb0IsT0FBVCxDQUFpQjlxQixJQUFqQixFQUF1QmduQixJQUF2QixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDL0IsMkpBQ2lFQSxJQURqRSw4RkFFMEVBLElBRjFFLHdEQUdrQ0QsSUFIbEMsc0hBSXNGaG5CLElBSnRGO0FBTUg7O0FBRU0sSUFBTStxQixrQkFBa0IsOHZCQWVqQkQsT0FBTyxDQUFDLFFBQUQsRUFBVyxVQUFYLEVBQXVCbm9CLFlBQVksQ0FBQzhrQixLQUFwQyxDQWZVLDJCQWdCakJxRCxPQUFPLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUJub0IsWUFBWSxDQUFDK2tCLEtBQWxDLENBaEJVLDJCQWlCakJvRCxPQUFPLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUJub0IsWUFBWSxDQUFDQyxJQUFwQyxDQWpCVSw2bUtBeUh6Qm9vQiw2REF6SHlCLDBIQUF4Qjs7QUFtSVAsU0FBU0Msb0JBQVQsQ0FBOEJucEIsSUFBOUIsRUFBb0M7QUFDaEMsTUFBSW9wQixLQUFLLEdBQUdqYixJQUFJLENBQUNnRyxLQUFMLENBQVduVSxJQUFYLENBQVo7O0FBQ0EsTUFBSXFwQixRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFTQyxJQUFULEVBQWU7QUFDMUIsUUFBSUEsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLE1BQXZCLEVBQStCO0FBQzNCLGFBQU9ELElBQUksQ0FBQ0UsTUFBTCxDQUFZMWIsTUFBWixHQUFxQixDQUFyQixJQUNILENBQUN3YixJQUFJLENBQUNFLE1BQUwsQ0FBWSxDQUFaLEVBQWVwYSxVQUFmLENBQTBCLEdBQTFCLENBREw7QUFFSCxLQUhELE1BR087QUFDSCxhQUFPa2EsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLFVBQW5CLElBQ0hELElBQUksQ0FBQ0MsU0FBTCxLQUFtQixLQUR2QjtBQUVIO0FBQ0osR0FSRDs7QUFTQSxNQUFJRSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFTSCxJQUFULEVBQWU7QUFDNUIsUUFBSUEsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLE1BQXZCLEVBQStCO0FBQzNCLGFBQU9ELElBQUksQ0FBQ0UsTUFBTCxDQUFZN0csSUFBWixDQUFpQixJQUFqQixDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUkyRyxJQUFJLENBQUNDLFNBQUwsS0FBbUIsVUFBbkIsSUFDUEQsSUFBSSxDQUFDQyxTQUFMLEtBQW1CLEtBRGhCLEVBQ3VCO0FBQzFCLGFBQU8sUUFBTUQsSUFBSSxDQUFDRSxNQUFMLENBQVk3RyxJQUFaLENBQWlCLElBQWpCLENBQU4sR0FBNkIsS0FBcEM7QUFDSDtBQUNKLEdBUEQ7O0FBUUEsU0FBT3lHLEtBQUssQ0FBQ00sS0FBTixDQUFZckUsTUFBWixDQUFtQmdFLFFBQW5CLEVBQTZCM1osR0FBN0IsQ0FBaUMrWixVQUFqQyxFQUE2QzlHLElBQTdDLENBQWtELElBQWxELENBQVA7QUFDSDs7SUFFS2dILGdCOzs7OztBQUNGLDRCQUFZM1UsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLDhCQUFNbkcsSUFBTixFQUFZbUcsR0FBRyxDQUFDOUYsSUFBSixDQUFTLDZCQUFULENBQVo7QUFDQXVVLFdBQU8sQ0FBQ0Msa0JBQVIsQ0FBMkI3VSxJQUFJLENBQUNuWCxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBekIsQ0FBbUMsQ0FBbkMsQ0FBM0I7QUFDQSxVQUFLOEMsRUFBTCxHQUFVLElBQUlraEIsV0FBSixDQUFnQjtBQUN0QixtQkFBYSxNQUFLM08sR0FBTCxDQUFTLENBQVQsQ0FEUztBQUV0QixhQUFPbkcsSUFBSSxDQUFDek8sVUFBTCxDQUFnQnFFLE1BQWhCLENBQXVCa0ksR0FBdkIsQ0FBMkJ6QyxJQUEzQixDQUFnQzJFLElBQUksQ0FBQ3pPLFVBQUwsQ0FBZ0JxRSxNQUFoRCxDQUZlO0FBR3RCLG9CQUFjLElBSFE7QUFJdEIsMEJBQW9Cb0ssSUFBSSxDQUFDblgsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QnFKLFdBSnZCO0FBS3RCLGlCQUFXb1AsSUFBSSxDQUFDblgsS0FBTCxDQUFXckIsVUFBWCxDQUFzQnNELFFBQXRCLENBQStCaXFCLE9BQS9CLEVBTFc7QUFNdEIsbUJBQWEsSUFOUztBQU90QkMsdUJBQWlCLEVBQUUsMkJBQUNDLE1BQUQsRUFBWTtBQUMzQixlQUFPQSxNQUFQO0FBQ0gsT0FUcUI7QUFVdEJDLHFCQUFlLEVBQUUseUJBQUMvRyxJQUFELEVBQVU7QUFDdkI7QUFDQSxlQUFPLElBQUk3SSxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVNFAsTUFBVixFQUFxQjtBQUNwQyxjQUFNQyxZQUFZLEdBQUdwVixJQUFJLENBQUNuWCxLQUFMLENBQVdwQixVQUFYLENBQXNCc0IsRUFBdEIsRUFBckI7QUFDQWlYLGNBQUksQ0FBQ3pPLFVBQUwsQ0FBZ0JDLE1BQWhCLENBQXVCdkMsVUFBdkIsQ0FBa0MsWUFBbEMsRUFBZ0RtbUIsWUFBaEQsRUFBOERqSCxJQUFJLENBQUNqbEIsSUFBbkUsRUFBeUVpbEIsSUFBekUsRUFBK0UsVUFBQzdSLFFBQUQsRUFBYztBQUN6RmlKLG1CQUFPLENBQUNwTSxJQUFJLENBQUNDLFNBQUwsQ0FBZWtELFFBQVEsQ0FBQ25SLFFBQXhCLENBQUQsQ0FBUCxDQUR5RixDQUV6RjtBQUNILFdBSEQsRUFGb0MsQ0FNcEM7QUFDQTtBQUNILFNBUk0sQ0FBUDtBQVNILE9BckJxQjtBQXNCdEJrcUIsc0JBQWdCLEVBQUUsMEJBQUNKLE1BQUQsRUFBWTtBQUMxQjtBQUNBLDJCQUFXQSxNQUFYO0FBQ0gsT0F6QnFCLENBMEJ0Qjs7QUExQnNCLEtBQWhCLENBQVY7QUE2QkEsVUFBSzdELEtBQUwsR0FBYSxLQUFiO0FBQ0EsVUFBS2xrQixRQUFMLEdBQWdCLEtBQWhCOztBQUNBLFVBQUtvb0IsaUJBQUw7O0FBQ0EsVUFBS0MscUJBQUwsR0FBNkIsSUFBN0I7QUFDQSxVQUFLQyx5QkFBTCxHQUFpQyxJQUFqQztBQUNBLFVBQUtDLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0EsVUFBSzFaLGFBQUwsR0FBcUIsTUFBS2lFLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBckI7O0FBRUEsVUFBSzhwQiw4QkFBTDs7QUF4Q21CO0FBeUN0Qjs7Ozs0Q0FFdUI7QUFBQTs7QUFDcEIsV0FBSzloQixFQUFMLENBQVFxRixXQUFSLENBQW9CMGMsU0FBcEIsQ0FBOEJDLG9CQUE5QixHQUFxRCxVQUFDQyxPQUFELEVBQWE7QUFDOURBLGVBQU8sQ0FBQ2xRLElBQVIsQ0FBYTtBQUNUbVEsaUJBQU8sRUFBRSxJQURBO0FBRVQ3VixjQUFJLEVBQUUsWUFGRztBQUdUOFYsa0JBQVEsRUFBRTtBQUFBLG1CQUFNLE1BQUksQ0FBQy9WLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFyQixDQUE0QnNZLGlCQUFsQztBQUFBO0FBSEQsU0FBYjtBQUtILE9BTkQ7QUFPSDs7OzBCQUVLaUMsVyxFQUFhQyxTLEVBQVc7QUFBQTs7QUFDMUIsVUFBSXlHLFdBQVcsR0FBRyxLQUFLdnFCLFFBQXZCOztBQUNBLGtGQUFZNmpCLFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjs7QUFFQSxVQUFJOUIsV0FBVyxLQUFLLFdBQXBCLEVBQWlDO0FBQzdCLFlBQUkwRyxXQUFXLEtBQUssV0FBcEIsRUFBaUM7QUFDN0IsZUFBS2phLGFBQUwsR0FBcUIsS0FBS2lFLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkksVUFBeEIsRUFBckI7QUFDSDs7QUFDRCxhQUFLb1UsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCSSxVQUF4QixDQUFtQ0MsWUFBWSxDQUFDQyxJQUFoRDtBQUNILE9BTEQsTUFLTztBQUNILGFBQUtrVSxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JJLFVBQXhCLENBQW1DLEtBQUttUSxhQUF4QztBQUNIOztBQUVELFdBQUtJLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFkMEIsQ0FnQjFCOztBQUNBLFdBQUsrWCxtQkFBTCxHQUEyQixLQUFLbFosSUFBTCxDQUFVbUIsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQWpCMEIsQ0FtQjFCOztBQUNBLFdBQUs0YSxpQkFBTCxHQUF5QixLQUFLM0UsWUFBTCxDQUFrQmpXLElBQWxCLENBQXVCLElBQXZCLENBQXpCO0FBQ0EsV0FBS3pILEVBQUwsQ0FBUXNpQixpQkFBUixDQUEwQixLQUFLRCxpQkFBL0I7O0FBRUEsVUFBSTNHLFdBQVcsS0FBSyxXQUFwQixFQUFpQztBQUM3QixhQUFLMWIsRUFBTCxDQUFRdWlCLFNBQVIsR0FBb0I7QUFBQSxpQkFBTSxLQUFOO0FBQUEsU0FBcEI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLdmlCLEVBQUwsQ0FBUXVpQixTQUFSLEdBQW9CLEtBQUtuVyxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ3FyQixTQUF4RDtBQUVBLGFBQUtaLHFCQUFMLEdBQTZCLEtBQUt2VixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0ksVUFBbkMsQ0FBOEN5USxTQUE5QyxDQUF3RCxVQUFDbVYsS0FBRCxFQUFVO0FBQzNGLGlCQUFPLE1BQUksQ0FBQ3hpQixFQUFMLENBQVF5aUIsbUJBQVIsQ0FBNEJELEtBQTVCLEVBQW1DLG1CQUFuQyxDQUFQO0FBQ0gsU0FGNEIsQ0FBN0I7QUFHQSxhQUFLWix5QkFBTCxHQUFpQyxLQUFLeFYsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNLLGNBQW5DLENBQWtEd1EsU0FBbEQsQ0FBNEQsVUFBQ21WLEtBQUQ7QUFBQSxpQkFDekYsTUFBSSxDQUFDeGlCLEVBQUwsQ0FBUXlpQixtQkFBUixDQUE0QkQsS0FBNUIsRUFBbUMsdUJBQW5DLENBRHlGO0FBQUEsU0FBNUQsQ0FBakM7QUFJQSxhQUFLWCxxQkFBTCxHQUE2QixLQUFLelYsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1Cd0QsS0FBbkIsQ0FBeUJDLGVBQXpCLENBQXlDd0osU0FBekMsQ0FBbUQsVUFBQ21WLEtBQUQsRUFBVztBQUN2RixnQkFBSSxDQUFDeGlCLEVBQUwsQ0FBUTBpQixxQkFBUixDQUE4QixvQkFBOUI7O0FBQ0EsZ0JBQUksQ0FBQzFpQixFQUFMLENBQVF5aUIsbUJBQVIsQ0FBNEJELEtBQTVCLEVBQW1DLG9CQUFuQztBQUNILFNBSDRCLENBQTdCO0FBSUgsT0F2Q3lCLENBMEMxQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FwRCxnQkFBVSxDQUFDO0FBQUEsZUFBTSxNQUFJLENBQUNwZixFQUFMLENBQVFDLE9BQVIsRUFBTjtBQUFBLE9BQUQsRUFBMEIsQ0FBMUIsQ0FBVjtBQUNIOzs7aUNBRVkwZCxXLEVBQWE7QUFDdEIsVUFBSUEsV0FBVyxLQUFLNXBCLFNBQXBCLEVBQStCO0FBQzNCLFlBQUksS0FBS2tSLElBQUwsS0FBYyxJQUFsQixFQUF3QjtBQUNwQjBZLHFCQUFXLEdBQUcsS0FBSzFZLElBQUwsQ0FBVW1CLE1BQVYsRUFBZDtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0F1WCxxQkFBVyxHQUFHLEVBQWQ7QUFDSDtBQUNKLE9BUEQsTUFPTyxJQUFJQSxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDN0I7QUFDQSxhQUFLdlIsSUFBTCxDQUFVek8sVUFBVixDQUFxQmlCLFVBQXJCLENBQWdDK2pCLGtCQUFoQyxDQUFtRCxLQUFLOXFCLFFBQXhEO0FBQ0E7QUFDSDs7QUFDRCxXQUFLMmxCLEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBS3hkLEVBQUwsQ0FBUTRpQixPQUFSLENBQWdCakYsV0FBaEIsRUFGWSxDQUdaOztBQUNBLGFBQUtILEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZNVMsSyxFQUFPO0FBQ2hCLFdBQUs1SyxFQUFMLENBQVEwaUIscUJBQVI7QUFFQSxXQUFLbEYsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7O0FBQ0EsWUFBSSxDQUFDLEtBQUtwUixJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JPLFdBQXhCLEVBQUwsRUFBNEM7QUFDeEMsZUFBSzhNLElBQUwsQ0FBVW1CLE1BQVYsQ0FBaUIsS0FBS3BHLEVBQUwsQ0FBUTZpQixPQUFSLEVBQWpCO0FBQ0g7O0FBQ0QsYUFBS3JGLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUsyQixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtXLG1CQUFMLENBQXlCRSxPQUF6QjtBQUNBLFdBQUtyZSxFQUFMLENBQVE4aUIsb0JBQVIsQ0FBNkIsS0FBS1QsaUJBQWxDOztBQUNBLFVBQUksS0FBS2pXLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3Qk8sV0FBeEIsRUFBSixFQUEyQztBQUN2QyxhQUFLaVUsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1Cc0csT0FBbkIsQ0FBMkJtQixNQUEzQixDQUFrQ1Msa0JBQWxDO0FBQ0g7O0FBQ0QsV0FBS3lhLHNCQUFMOztBQUNBLGlGQUFXckgsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OzZDQUV3QjtBQUNyQixXQUFLM2IsRUFBTCxDQUFRMGlCLHFCQUFSOztBQUNBLFVBQUksS0FBS2YscUJBQVQsRUFBZ0M7QUFDNUIsYUFBS0EscUJBQUwsQ0FBMkJ0RCxPQUEzQjtBQUNBLGFBQUtzRCxxQkFBTCxHQUE2QixJQUE3QjtBQUNIOztBQUNELFVBQUksS0FBS0MseUJBQVQsRUFBb0M7QUFDaEMsYUFBS0EseUJBQUwsQ0FBK0J2RCxPQUEvQjtBQUNBLGFBQUt1RCx5QkFBTCxHQUFpQyxJQUFqQztBQUNIOztBQUNELFVBQUksS0FBS0MscUJBQVQsRUFBZ0M7QUFDNUIsYUFBS0EscUJBQUwsQ0FBMkJ4RCxPQUEzQjtBQUNBLGFBQUt3RCxxQkFBTCxHQUE2QixJQUE3QjtBQUNIO0FBQ0o7Ozt3Q0FFbUI7QUFBQTs7QUFDaEIsV0FBSzdoQixFQUFMLENBQVFnakIsT0FBUixDQUFnQixLQUFLNVcsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCSSxVQUF4QixFQUFoQjtBQUNBLFdBQUtvVSxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JJLFVBQXhCLENBQW1DcVYsU0FBbkMsQ0FBNkMsVUFBQWtQLElBQUksRUFBSTtBQUNqRCxjQUFJLENBQUN2YyxFQUFMLENBQVFnakIsT0FBUixDQUFnQnpHLElBQWhCO0FBQ0gsT0FGRDtBQUdBLFdBQUtuUSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQytyQixZQUFwQyxDQUFpRDVWLFNBQWpELENBQTJELFVBQUE2VSxPQUFPLEVBQUk7QUFDbEUsWUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDVixnQkFBSSxDQUFDbGlCLEVBQUwsQ0FBUWdqQixPQUFSLENBQWdCL3FCLFlBQVksQ0FBQ0MsSUFBN0I7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBSSxDQUFDOEgsRUFBTCxDQUFRZ2pCLE9BQVIsQ0FBZ0IsTUFBSSxDQUFDNVcsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCSSxVQUF4QixFQUFoQjtBQUNIO0FBQ0osT0FORDtBQU9BLFdBQUtvVSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ2lxQixPQUFwQyxDQUE0QzlULFNBQTVDLENBQXNELEtBQUs2VixhQUFMLENBQW1CemIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBdEQ7QUFDQSxXQUFLMkUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0NzSyxZQUFwQyxDQUFpRDZMLFNBQWpELENBQTJELFVBQUE4VixTQUFTLEVBQUk7QUFDcEUsY0FBSSxDQUFDbmpCLEVBQUwsQ0FBUW9qQixZQUFSLENBQXFCRCxTQUFyQjtBQUNILE9BRkQsRUFiZ0IsQ0FpQmhCOztBQUNBLFdBQUtFLFNBQUwsR0FBaUIsSUFBakI7O0FBQ0EsVUFBSSxLQUFLalgsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1CQyxXQUFuQixFQUFKLEVBQXNDO0FBQ2xDLGFBQUtpakIsY0FBTDtBQUNIOztBQUNELFdBQUtsWCxJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJDLFdBQW5CLENBQStCZ04sU0FBL0IsQ0FBeUMsVUFBQWlXLGNBQWMsRUFBSTtBQUN2RCxZQUFJQSxjQUFKLEVBQW9CO0FBQ2hCLGdCQUFJLENBQUNBLGNBQUw7QUFDSCxTQUZELE1BRU8sSUFBSSxNQUFJLENBQUNELFNBQUwsS0FBbUIsSUFBdkIsRUFBNkI7QUFDaEMsZ0JBQUksQ0FBQ3JqQixFQUFMLENBQVFyTSxhQUFSLENBQXNCaWYsTUFBdEIsR0FBK0IsTUFBSSxDQUFDeVEsU0FBcEM7O0FBQ0EsZ0JBQUksQ0FBQ3JqQixFQUFMLENBQVFzQixVQUFSLENBQW1CaWlCLGtCQUFuQjs7QUFDQSxnQkFBSSxDQUFDRixTQUFMLEdBQWlCLElBQWpCO0FBQ0g7QUFDSixPQVJEO0FBU0g7OztxQ0FFZ0I7QUFDYixXQUFLcmpCLEVBQUwsQ0FBUXNCLFVBQVIsQ0FBbUJraUIsWUFBbkIsQ0FBZ0M7QUFBQ0MscUJBQWEsRUFBRTtBQUFoQixPQUFoQztBQUNBLFdBQUtKLFNBQUwsR0FBaUIsS0FBS3JqQixFQUFMLENBQVFyTSxhQUFSLENBQXNCaWYsTUFBdkM7QUFDQSxXQUFLNVMsRUFBTCxDQUFRck0sYUFBUixDQUFzQmlmLE1BQXRCLEdBQStCLEdBQS9CLENBSGEsQ0FHdUI7O0FBQ3BDLFdBQUs1UyxFQUFMLENBQVFzQixVQUFSLENBQW1CaWlCLGtCQUFuQjtBQUNIOzs7a0NBRWFwQyxPLEVBQVM7QUFDbkIsVUFBSUEsT0FBTyxLQUFLLFFBQWhCLEVBQTBCO0FBQ3RCLFlBQUl1QyxhQUFhLEdBQUcsS0FBS3RYLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3NILE9BQWhDLENBQXdDLGtCQUF4QyxDQUFwQjs7QUFDQSxZQUFJd2QsYUFBYSxJQUFJLElBQXJCLEVBQTJCO0FBQ3ZCdkMsaUJBQU8sR0FBRyxPQUFWO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSTtBQUNBQSxtQkFBTyxHQUFHNWIsSUFBSSxDQUFDZ0csS0FBTCxDQUFXbVksYUFBYSxDQUFDdGQsTUFBZCxFQUFYLENBQVY7QUFDSCxXQUZELENBRUUsT0FBT2lGLENBQVAsRUFBVTtBQUNSNU0sbUJBQU8sQ0FBQytYLEtBQVIsQ0FBY25MLENBQWQsRUFEUSxDQUNVOztBQUNsQjhWLG1CQUFPLEdBQUcsU0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxXQUFLbmhCLEVBQUwsQ0FBUXJNLGFBQVIsQ0FBc0J3dEIsT0FBdEIsR0FBZ0NBLE9BQWhDLENBZG1CLENBZW5COztBQUNBLFVBQUk7QUFDQSxhQUFLbmhCLEVBQUwsQ0FBUXFGLFdBQVIsQ0FBb0JnUixhQUFwQjtBQUNILE9BRkQsQ0FFRSxPQUFPaEwsQ0FBUCxFQUFVO0FBQ1I1TSxlQUFPLENBQUMrWCxLQUFSLENBQWNuTCxDQUFkO0FBQ0EsYUFBS3JMLEVBQUwsQ0FBUXJNLGFBQVIsQ0FBc0J3dEIsT0FBdEIsR0FBZ0MsT0FBaEM7QUFDQSxhQUFLbmhCLEVBQUwsQ0FBUXFGLFdBQVIsQ0FBb0JnUixhQUFwQjtBQUNIO0FBQ0o7OztxREFFZ0M7QUFBQTs7QUFDN0IsV0FBS2pLLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkUsVUFBeEIsQ0FBbUN1VixTQUFuQyxDQUE2QyxVQUFDQyxPQUFELEVBQWE7QUFDdEQsY0FBSSxDQUFDOUUsV0FBTCxDQUFpQixNQUFJLENBQUNtYixtQkFBTCxFQUFqQjtBQUNILE9BRkQ7QUFHQSxXQUFLdlgsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0Mwc0IsV0FBcEMsQ0FBZ0R2VyxTQUFoRCxDQUEwRCxVQUFDQyxPQUFELEVBQWE7QUFDbkUsY0FBSSxDQUFDOUUsV0FBTCxDQUFpQixNQUFJLENBQUNtYixtQkFBTCxFQUFqQjtBQUNILE9BRkQ7QUFHQSxXQUFLdlgsSUFBTCxDQUFVblgsS0FBVixDQUFnQnRCLGFBQWhCLENBQThCeUosTUFBOUIsQ0FBcUNpUSxTQUFyQyxDQUErQyxVQUFDQyxPQUFELEVBQWEsQ0FDeEQ7QUFDSCxPQUZEO0FBR0g7OzswQ0FFcUI7QUFDbEIsVUFBSXJZLEtBQUssR0FBRyxLQUFLbVgsSUFBTCxDQUFVblgsS0FBdEI7QUFDQSxhQUFPQSxLQUFLLENBQUMyQyxPQUFOLENBQWNPLFdBQWQsTUFDSGxELEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJzRCxRQUFqQixDQUEwQjBzQixXQUExQixNQUEyQyxDQUFDM3VCLEtBQUssQ0FBQzJDLE9BQU4sQ0FBY0UsVUFBZCxFQURoRDtBQUdIOzs7Z0NBRVcrckIsVSxFQUFZO0FBQ3BCLFdBQUt2cUIsUUFBTCxHQUFnQnVxQixVQUFoQjtBQUNBLFdBQUs3akIsRUFBTCxDQUFRd0ksV0FBUixDQUFvQnFiLFVBQXBCO0FBQ0g7OzsrQkFFVWpaLEssRUFBTztBQUNkLFVBQUkvUyxRQUFRLEdBQUcrUyxLQUFLLENBQUNFLE1BQU4sQ0FBYVksUUFBNUI7QUFDQSxVQUFJdFUsSUFBSSxHQUFHd1QsS0FBSyxDQUFDRSxNQUFOLENBQWFVLE1BQXhCOztBQUNBLFVBQUkzVCxRQUFRLENBQUNpc0IsUUFBVCxDQUFrQixRQUFsQixDQUFKLEVBQWlDO0FBQzdCMXNCLFlBQUksR0FBR21wQixvQkFBb0IsQ0FBQ25wQixJQUFELENBQTNCO0FBQ0g7O0FBQ0QsV0FBS2dWLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsZUFBckMsRUFBc0QsRUFBdEQsRUFBMEQsRUFBMUQsRUFBOERqRCxJQUE5RCxFQUFvRSxLQUFLUyxRQUF6RTtBQUNBLFdBQUtvTixJQUFMLENBQVVtQixNQUFWLENBQWlCaFAsSUFBakI7QUFDQSxXQUFLZ1YsSUFBTCxDQUFVek8sVUFBVixDQUFxQnFFLE1BQXJCLENBQTRCa0ksR0FBNUIsR0FSYyxDQVNkO0FBQ0g7OzttQ0FFYztBQUNYLFVBQUlzQixNQUFNLHFGQUFWOztBQUNBLFVBQUlBLE1BQU0sQ0FBQ2xXLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEJrVyxNQUFNLENBQUM2TyxTQUFQLEtBQXFCLEtBQXJELEVBQTREO0FBQ3hEN08sY0FBTSxDQUFDbFcsSUFBUCxHQUFjNmtCLGlFQUFRLENBQUMsS0FBSy9OLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjBCLElBQTNCLEVBQUQsQ0FBdEI7QUFDSDs7QUFDRGtXLFlBQU0sQ0FBQzhPLFFBQVAsR0FBa0IsZUFBbEI7QUFDQSxXQUFLbE8sSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ2RCxRQUE1QixDQUFxQyxpQkFBckMsRUFBd0QsRUFBeEQsRUFBNEQsRUFBNUQsRUFBZ0UsRUFBaEUsRUFBb0VtUixNQUFNLENBQUNsVyxJQUEzRTtBQUNBLGFBQU9rVyxNQUFQO0FBQ0g7Ozs7RUFuUjBCMlAsK0Q7O0FBdVJ4QixJQUFNNEksWUFBWSxHQUFHO0FBQ3hCenVCLE1BQUksRUFBRSxRQURrQjtBQUV4QnVvQixZQUFVLEVBQUUsQ0FBQyxLQUFELEVBQVEsVUFBUixDQUZZO0FBR3hCQyxhQUFXLEVBQUVpRCxnQkFIVztBQUl4QmhELFVBQVEsRUFBRXNDO0FBSmMsQ0FBckIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN2NQO0FBRU8sSUFBTTJELGdCQUFnQix1RkFBdEI7O0lBTURDLGM7Ozs7O0FBQ0YsMEJBQVk3WCxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBS3pLLFVBQUwsR0FBa0IyVyxVQUFVLENBQUNDLFlBQVgsQ0FBd0JuTSxHQUFHLENBQUM5RixJQUFKLENBQVMsc0JBQVQsRUFBaUMsQ0FBakMsQ0FBeEIsRUFBNkQ7QUFDM0VrUyw2QkFBdUIsRUFBRSxJQURrRDtBQUUzRUMsaUJBQVcsRUFBRSxJQUY4RDtBQUczRUMscUJBQWUsRUFBRSxDQUgwRDtBQUkzRUMsZ0JBQVUsRUFBRSxDQUorRDtBQUszRUMsYUFBTyxFQUFFLENBTGtFO0FBTTNFQyxvQkFBYyxFQUFFLEtBTjJEO0FBTzNFQyxlQUFTLEVBQUU7QUFDUCxlQUFPLFlBREE7QUFFUCxxQkFBYSxZQUZOO0FBR1AsZUFBTyxhQUFVQyxFQUFWLEVBQWM7QUFDakIsY0FBSUEsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBSixFQUFnQztBQUM1QmtYLGNBQUUsQ0FBQ25YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLEtBQTNCO0FBQ0gsV0FGRCxNQUVPO0FBQ0htWCxjQUFFLENBQUN0bkIsT0FBSCxDQUFXK0QsS0FBWCxDQUFpQndqQixJQUFqQjtBQUNIO0FBQ0osU0FUTTtBQVVQLGVBQU8sYUFBVUQsRUFBVixFQUFjO0FBQ2pCQSxZQUFFLENBQUNuWCxTQUFILENBQWEsWUFBYixFQUEyQixDQUFDbVgsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBNUI7QUFDSDtBQVpNO0FBUGdFLEtBQTdELENBQWxCO0FBc0JBLFVBQUt3VixLQUFMLEdBQWEsS0FBYjtBQXhCbUI7QUF5QnRCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsZ0ZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtqVixZQUFMLENBQWtCLEtBQUt0RCxJQUFMLENBQVVtQixNQUFWLEVBQWxCLEVBSDBCLENBSTFCOztBQUNBLFdBQUsrWCxtQkFBTCxHQUEyQixLQUFLbFosSUFBTCxDQUFVbUIsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQUwwQixDQU0xQjs7QUFDQSxXQUFLZ1csZUFBTCxHQUF1QixLQUFLQyxZQUFMLENBQWtCalcsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBdkI7QUFDQSxXQUFLSyxVQUFMLENBQWdCZ1IsRUFBaEIsQ0FBbUIsUUFBbkIsRUFBNkIsS0FBSzJFLGVBQWxDOztBQUNBLFVBQUk5QixTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEI7QUFDQXlELGtCQUFVLENBQUMsS0FBS3RYLFVBQUwsQ0FBZ0I3SCxPQUFoQixDQUF3QndILElBQXhCLENBQTZCLEtBQUtLLFVBQWxDLENBQUQsRUFBZ0QsQ0FBaEQsQ0FBVjtBQUNILE9BWnlCLENBYTFCOzs7QUFDQSxXQUFLQSxVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQzJULFdBQVcsQ0FBQ2xWLFVBQVosQ0FBdUIsR0FBdkIsS0FBK0IsQ0FBQyxLQUFLNEYsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRSxVQUF4QixFQUF0RTtBQUNIOzs7aUNBRVk2bEIsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFWLFVBQUwsQ0FBZ0J1WCxRQUFoQixDQUF5QjFCLFdBQXpCO0FBQ0EsYUFBSzdWLFVBQUwsQ0FBZ0I3SCxPQUFoQjtBQUNBLGFBQUt1ZCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTVTLEssRUFBTztBQUNoQixXQUFLNFMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLdlksSUFBTCxDQUFVbUIsTUFBVixDQUFpQixLQUFLMEIsVUFBTCxDQUFnQndYLFFBQWhCLEVBQWpCO0FBQ0EsYUFBSzlCLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O3lCQUVJOUIsVyxFQUFhQyxTLEVBQVdFLFMsRUFBVztBQUNwQztBQUNBLFdBQUtzQyxtQkFBTCxDQUF5QkUsT0FBekI7QUFDQSxXQUFLdlcsVUFBTCxDQUFnQnlYLEdBQWhCLENBQW9CLFFBQXBCLEVBQThCLEtBQUs5QixlQUFuQztBQUNBLFdBQUszVixVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQyxLQUF0Qzs7QUFDQSwrRUFBVzJULFdBQVgsRUFBd0JDLFNBQXhCO0FBQ0g7Ozs7RUF0RXdCUiwrRDs7QUF5RXRCLElBQU0rSSxVQUFVLEdBQUc7QUFDdEI1dUIsTUFBSSxFQUFFLE1BRGdCO0FBRXRCdW9CLFlBQVUsRUFBRSxDQUFDLE9BQUQsQ0FGVTtBQUd0QkMsYUFBVyxFQUFFbUcsY0FIUztBQUl0QmxHLFVBQVEsRUFBRWlHO0FBSlksQ0FBbkIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRlA7Ozs7QUFLQTtBQUVPLElBQU05bEIsa0JBQWtCLEdBQUc7QUFDOUJDLFNBQU8sRUFBRSxTQURxQjtBQUU5QmdtQixRQUFNLEVBQUUsUUFGc0I7QUFHOUJDLFFBQU0sRUFBRSxRQUhzQjtBQUk5QkMsT0FBSyxFQUFFLE9BSnVCO0FBSzlCQyxTQUFPLEVBQUU7QUFMcUIsQ0FBM0I7QUFRQSxJQUFNN2UsZ0JBQWI7QUFDSSw0QkFBWW5RLElBQVosRUFBa0JvRSxNQUFsQixFQUEwQnRDLElBQTFCLEVBQWdDO0FBQUE7O0FBQzVCLFNBQUs5QixJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLb0UsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS3RDLElBQUwsR0FBWUEsSUFBWjtBQUNIOztBQUxMO0FBQUE7QUFBQSxnQ0FnQmdCO0FBQ1IsYUFBTztBQUNIOUIsWUFBSSxFQUFFLEtBQUtBLElBRFI7QUFFSG9FLGNBQU0sRUFBRSxLQUFLQSxNQUZWO0FBR0h0QyxZQUFJLEVBQUUsS0FBS0E7QUFIUixPQUFQO0FBS0g7QUF0Qkw7QUFBQTtBQUFBLDBCQU9pQm10QixLQVBqQixFQU93QjtBQUNoQixhQUFPLElBQUk5ZSxnQkFBSixDQUFxQixjQUFZOGUsS0FBSyxJQUFJLENBQXJCLENBQXJCLEVBQ3FCcm1CLGtCQUFrQixDQUFDQyxPQUR4QyxFQUNpRCxLQURqRCxDQUFQO0FBRUg7QUFWTDtBQUFBO0FBQUEsZ0NBWXVCSyxJQVp2QixFQVk2QjtBQUNyQixhQUFPLElBQUlpSCxnQkFBSixDQUFxQmpILElBQUksQ0FBQ2xKLElBQTFCLEVBQWdDa0osSUFBSSxDQUFDOUUsTUFBckMsRUFBNkM4RSxJQUFJLENBQUNwSCxJQUFsRCxDQUFQO0FBQ0g7QUFkTDs7QUFBQTtBQUFBO0FBeUJPLElBQU1vdEIsdUJBQXVCLGtlQUE3QjtBQWdCUHB2QixFQUFFLENBQUNxdkIsZUFBSCxDQUFtQkMsa0JBQW5CLEdBQXdDO0FBQ3BDQyxNQUFJLEVBQUUsY0FBUy9FLE9BQVQsRUFBa0JnRixhQUFsQixFQUFpQ0MsV0FBakMsRUFBOENDLFNBQTlDLEVBQXlEQyxjQUF6RCxFQUF5RTtBQUMzRTtBQUNBO0FBQ0F0bUIsV0FBTyxDQUFDb04sR0FBUixDQUFZLE1BQVo7QUFDQSxRQUFJcVQsRUFBRSxHQUFHVCxVQUFVLENBQUNDLFlBQVgsQ0FBd0JrQixPQUF4QixFQUFpQztBQUN0Q2pCLDZCQUF1QixFQUFFLElBRGE7QUFFdENDLGlCQUFXLEVBQUUsSUFGeUI7QUFHdENDLHFCQUFlLEVBQUUsQ0FIcUI7QUFJdENDLGdCQUFVLEVBQUUsQ0FKMEI7QUFLdENDLGFBQU8sRUFBRSxDQUw2QjtBQU10Q0Msb0JBQWMsRUFBRSxLQU5zQjtBQU90Q0MsZUFBUyxFQUFFO0FBQ1AsZUFBTyxZQURBO0FBRVAscUJBQWEsWUFGTjtBQUdQLGVBQU8sYUFBVUMsRUFBVixFQUFjO0FBQ2pCLGNBQUlBLEVBQUUsQ0FBQ2xYLFNBQUgsQ0FBYSxZQUFiLENBQUosRUFBZ0M7QUFDNUJrWCxjQUFFLENBQUNuWCxTQUFILENBQWEsWUFBYixFQUEyQixLQUEzQjtBQUNILFdBRkQsTUFFTztBQUNIbVgsY0FBRSxDQUFDdG5CLE9BQUgsQ0FBVytELEtBQVgsQ0FBaUJ3akIsSUFBakI7QUFDSDtBQUNKLFNBVE07QUFVUCxlQUFPLGFBQVVELEVBQVYsRUFBYztBQUNqQkEsWUFBRSxDQUFDblgsU0FBSCxDQUFhLFlBQWIsRUFBMkIsQ0FBQ21YLEVBQUUsQ0FBQ2xYLFNBQUgsQ0FBYSxZQUFiLENBQTVCO0FBQ0g7QUFaTTtBQVAyQixLQUFqQyxDQUFUO0FBc0JBa1gsTUFBRSxDQUFDOEYsT0FBSCxDQUFXLE1BQVgsRUFBbUIsT0FBbkI7QUFDQSxXQUFPOUYsRUFBUDtBQUNILEdBN0JtQztBQThCcEMrRixRQUFNLEVBQUUsZ0JBQVNyRixPQUFULEVBQWtCZ0YsYUFBbEIsRUFBaUNDLFdBQWpDLEVBQThDQyxTQUE5QyxFQUF5REMsY0FBekQsRUFBeUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0F0bUIsV0FBTyxDQUFDb04sR0FBUixDQUFZLFFBQVo7QUFDSDtBQW5DbUMsQ0FBeEM7O0lBc0NNcVoscUI7Ozs7O0FBQ0YsaUNBQVk5WSxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFBQTs7QUFDbkIsOEJBQU1uRyxJQUFOLEVBQVltRyxHQUFaO0FBQ0EsVUFBS0EsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsVUFBSzRTLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxVQUFLM0gsS0FBTCxHQUFhLEtBQWI7QUFKbUI7QUFLdEI7Ozs7Z0NBRVc3VCxNLEVBQVFDLEssRUFBT0MsVSxFQUFZLENBRXRDOzs7cUNBRWdCO0FBQ2JwTCxhQUFPLENBQUNvTixHQUFSLENBQVksb0JBQVo7QUFDSDs7OzBCQUVLNlAsVyxFQUFhQyxTLEVBQVc7QUFBQTs7QUFDMUIsdUZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtqVixZQUFMLENBQWtCLEtBQUt0RCxJQUFMLENBQVVtQixNQUFWLEVBQWxCLEVBSDBCLENBSTFCOztBQUNBLFdBQUsrWCxtQkFBTCxHQUEyQixLQUFLbFosSUFBTCxDQUFVbUIsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQUwwQixDQU0xQjs7QUFDQSxXQUFLZ1csZUFBTCxHQUF1QixLQUFLQyxZQUFMLENBQWtCalcsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBdkIsQ0FQMEIsQ0FRMUI7QUFDQTs7QUFDQSxVQUFJa1UsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCbGQsZUFBTyxDQUFDb04sR0FBUixDQUFZLEtBQUswRyxHQUFqQjtBQUNBOVQsZUFBTyxDQUFDb04sR0FBUixDQUFZLEtBQUswRyxHQUFMLENBQVM5RixJQUFULENBQWMsYUFBZCxDQUFaO0FBQ0FoTyxlQUFPLENBQUNvTixHQUFSLENBQVksS0FBSzBHLEdBQUwsQ0FBUzlGLElBQVQsQ0FBYyxhQUFkLEVBQTZCM0YsR0FBN0IsQ0FBaUMsVUFBQzROLENBQUQsRUFBR3dLLEVBQUg7QUFBQSxpQkFBVXpnQixPQUFPLENBQUNvTixHQUFSLENBQVksS0FBWixFQUFtQnFULEVBQUUsQ0FBQ1QsVUFBdEIsQ0FBVjtBQUFBLFNBQWpDLENBQVo7QUFDQSxhQUFLbE0sR0FBTCxDQUFTOUYsSUFBVCxDQUFjLGFBQWQsRUFBNkIzRixHQUE3QixDQUFpQyxVQUFDNE4sQ0FBRCxFQUFJd0ssRUFBSjtBQUFBLGlCQUFXQSxFQUFFLENBQUNULFVBQUgsQ0FBY3hlLE9BQWQsRUFBWDtBQUFBLFNBQWpDO0FBQ0F4QixlQUFPLENBQUNvTixHQUFSLENBQVksU0FBWixFQUxvQixDQU1wQjs7QUFDQXVULGtCQUFVLENBQUM7QUFBQSxpQkFBTSxNQUFJLENBQUM3TSxHQUFMLENBQVM5RixJQUFULENBQWMsYUFBZCxFQUE2QjNGLEdBQTdCLENBQWlDLFVBQUM0TixDQUFELEVBQUl3SyxFQUFKO0FBQUEsbUJBQVdBLEVBQUUsQ0FBQ1QsVUFBSCxDQUFjeGUsT0FBZCxFQUFYO0FBQUEsV0FBakMsQ0FBTjtBQUFBLFNBQUQsRUFBNkUsQ0FBN0UsQ0FBVjtBQUNILE9BbEJ5QixDQW1CMUI7QUFDQTs7QUFDSDs7O2lDQUVZMGQsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EvZSxlQUFPLENBQUNvTixHQUFSLENBQVksS0FBS3NaLFdBQWpCLEVBRlksQ0FHWjtBQUNBOztBQUNBLGFBQUszSCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTVTLEssRUFBTztBQUNoQixXQUFLNFMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLdlksSUFBTCxDQUFVbUIsTUFBVixDQUFpQixLQUFLK2UsV0FBTCxDQUFpQnJlLEdBQWpCLENBQXFCLFVBQUFvWSxFQUFFO0FBQUEsaUJBQUlBLEVBQUUsQ0FBQ0ksUUFBSCxFQUFKO0FBQUEsU0FBdkIsQ0FBakI7QUFDQSxhQUFLOUIsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7eUJBRUk5QixXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3NDLG1CQUFMLENBQXlCRSxPQUF6QjtBQUNBLFdBQUs4RyxXQUFMLEdBQW1CLEVBQW5CLENBSG9DLENBSXBDO0FBQ0E7O0FBQ0Esc0ZBQVd6SixXQUFYLEVBQXdCQyxTQUF4QjtBQUNIOzs7O0VBbEUrQlIsK0Q7O0FBcUU3QixJQUFNaUssaUJBQWlCLEdBQUc7QUFDN0I5dkIsTUFBSSxFQUFFLG9CQUR1QjtBQUU3QnVvQixZQUFVLEVBQUUsQ0FBQyw2QkFBRCxDQUZpQjtBQUc3QkMsYUFBVyxFQUFFb0gscUJBSGdCO0FBSTdCbkgsVUFBUSxFQUFFeUc7QUFKbUIsQ0FBMUIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuS1A7QUFFTyxJQUFNYSxnQkFBZ0IsaU9BQXRCOztJQWtCREMsYzs7Ozs7QUFDRiwwQkFBWWxaLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUFBLDZCQUNibkcsSUFEYSxFQUNQbUcsR0FBRyxDQUFDOUYsSUFBSixDQUFTLHNCQUFULENBRE87QUFFdEI7OztFQUh3QjBPLCtEOztBQU10QixJQUFNb0ssVUFBVSxHQUFHO0FBQ3RCandCLE1BQUksRUFBRSxNQURnQjtBQUV0QnVvQixZQUFVLEVBQUUsQ0FBQyxlQUFELENBRlU7QUFHdEJDLGFBQVcsRUFBRXdILGNBSFM7QUFJdEJ2SCxVQUFRLEVBQUVzSDtBQUpZLENBQW5CLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQlA7QUFDQTtBQUVPLElBQU1HLGdCQUFnQixtQkFDdkJ4SCw4REFEdUIsdUZBQXRCOztJQU9EeUgsYzs7Ozs7QUFDRiwwQkFBWXJaLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTW5HLElBQU4sRUFBWW1HLEdBQVo7QUFDQSxVQUFLekssVUFBTCxHQUFrQjJXLFVBQVUsQ0FBQ0MsWUFBWCxDQUF3Qm5NLEdBQUcsQ0FBQzlGLElBQUosQ0FBUyxzQkFBVCxFQUFpQyxDQUFqQyxDQUF4QixFQUE2RDtBQUMzRWtTLDZCQUF1QixFQUFFLElBRGtEO0FBRTNFQyxpQkFBVyxFQUFFLElBRjhEO0FBRzNFQyxxQkFBZSxFQUFFLENBSDBEO0FBSTNFQyxnQkFBVSxFQUFFLENBSitEO0FBSzNFQyxhQUFPLEVBQUUsQ0FMa0U7QUFNM0VDLG9CQUFjLEVBQUUsS0FOMkQ7QUFPM0VDLGVBQVMsRUFBRTtBQUNQLGVBQU8sWUFEQTtBQUVQLHFCQUFhLFlBRk47QUFHUCxlQUFPLGFBQVVDLEVBQVYsRUFBYztBQUNqQixjQUFJQSxFQUFFLENBQUNsWCxTQUFILENBQWEsWUFBYixDQUFKLEVBQWdDO0FBQzVCa1gsY0FBRSxDQUFDblgsU0FBSCxDQUFhLFlBQWIsRUFBMkIsS0FBM0I7QUFDSCxXQUZELE1BRU87QUFDSG1YLGNBQUUsQ0FBQ3RuQixPQUFILENBQVcrRCxLQUFYLENBQWlCd2pCLElBQWpCO0FBQ0g7QUFDSixTQVRNO0FBVVAsZUFBTyxhQUFVRCxFQUFWLEVBQWM7QUFDakJBLFlBQUUsQ0FBQ25YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLENBQUNtWCxFQUFFLENBQUNsWCxTQUFILENBQWEsWUFBYixDQUE1QjtBQUNIO0FBWk07QUFQZ0UsS0FBN0QsQ0FBbEI7QUFzQkEsVUFBS3dWLEtBQUwsR0FBYSxLQUFiO0FBeEJtQjtBQXlCdEI7Ozs7MEJBRUs5QixXLEVBQWFDLFMsRUFBVztBQUMxQixnRkFBWUQsV0FBWixFQUF5QkMsU0FBekI7O0FBQ0EsV0FBSzZCLEtBQUwsR0FBYSxLQUFiO0FBQ0EsV0FBS2pWLFlBQUwsQ0FBa0IsS0FBS3RELElBQUwsQ0FBVW1CLE1BQVYsRUFBbEIsRUFIMEIsQ0FJMUI7O0FBQ0EsV0FBSytYLG1CQUFMLEdBQTJCLEtBQUtsWixJQUFMLENBQVVtQixNQUFWLENBQWlCaUgsU0FBakIsQ0FBMkIsS0FBSzlFLFlBQUwsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTNCLENBQTNCLENBTDBCLENBTTFCOztBQUNBLFdBQUtnVyxlQUFMLEdBQXVCLEtBQUtDLFlBQUwsQ0FBa0JqVyxJQUFsQixDQUF1QixJQUF2QixDQUF2QjtBQUNBLFdBQUtLLFVBQUwsQ0FBZ0JnUixFQUFoQixDQUFtQixRQUFuQixFQUE2QixLQUFLMkUsZUFBbEM7O0FBQ0EsVUFBSTlCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBeUQsa0JBQVUsQ0FBQyxLQUFLdFgsVUFBTCxDQUFnQjdILE9BQWhCLENBQXdCd0gsSUFBeEIsQ0FBNkIsS0FBS0ssVUFBbEMsQ0FBRCxFQUFnRCxDQUFoRCxDQUFWO0FBQ0gsT0FaeUIsQ0FhMUI7OztBQUNBLFdBQUtBLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDMlQsV0FBVyxDQUFDbFYsVUFBWixDQUF1QixHQUF2QixLQUErQixDQUFDLEtBQUs0RixJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JFLFVBQXhCLEVBQXRFO0FBQ0g7OztpQ0FFWTZsQixXLEVBQWE7QUFDdEIsV0FBS0gsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLMVYsVUFBTCxDQUFnQnVYLFFBQWhCLENBQXlCMUIsV0FBekI7QUFDQSxhQUFLN1YsVUFBTCxDQUFnQjdILE9BQWhCO0FBQ0EsYUFBS3VkLEtBQUwsR0FBYSxLQUFiO0FBQ0g7QUFDSjs7O2lDQUVZNVMsSyxFQUFPO0FBQ2hCLFdBQUs0UyxLQUFMLEdBQWEsQ0FBQyxLQUFLQSxLQUFuQjs7QUFDQSxVQUFJLEtBQUtBLEtBQVQsRUFBZ0I7QUFDWixhQUFLQSxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUt2WSxJQUFMLENBQVVtQixNQUFWLENBQWlCLEtBQUswQixVQUFMLENBQWdCd1gsUUFBaEIsRUFBakI7QUFDQSxhQUFLOUIsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7eUJBRUk5QixXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3NDLG1CQUFMLENBQXlCRSxPQUF6QjtBQUNBLFdBQUt2VyxVQUFMLENBQWdCeVgsR0FBaEIsQ0FBb0IsUUFBcEIsRUFBOEIsS0FBSzlCLGVBQW5DO0FBQ0EsV0FBSzNWLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDLEtBQXRDOztBQUNBLCtFQUFXMlQsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQXRFd0JSLCtEOztBQXlFdEIsSUFBTXVLLFVBQVUsR0FBRztBQUN0QnB3QixNQUFJLEVBQUUsTUFEZ0I7QUFFdEJ1b0IsWUFBVSxFQUFFLENBQUMsTUFBRCxDQUZVO0FBR3RCQyxhQUFXLEVBQUUySCxjQUhTO0FBSXRCMUgsVUFBUSxFQUFFeUg7QUFKWSxDQUFuQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRlA7QUFFTyxJQUFNRyxtQkFBbUIsNmZBQXpCOztJQWNEQyxpQjs7Ozs7QUFDRiw2QkFBWXhaLElBQVosRUFBa0JtRyxHQUFsQixFQUF1QjtBQUFBOztBQUFBOztBQUNuQiw4QkFBTW5HLElBQU4sRUFBWW1HLEdBQVo7QUFDQSxVQUFLekssVUFBTCxHQUFrQjJXLFVBQVUsQ0FBQ0MsWUFBWCxDQUF3Qm5NLEdBQUcsQ0FBQzlGLElBQUosQ0FBUyx5QkFBVCxFQUFvQyxDQUFwQyxDQUF4QixFQUFnRTtBQUM5RWtTLDZCQUF1QixFQUFFLElBRHFEO0FBRTlFQyxpQkFBVyxFQUFFLElBRmlFO0FBRzlFQyxxQkFBZSxFQUFFLENBSDZEO0FBSTlFQyxnQkFBVSxFQUFFLENBSmtFO0FBSzlFQyxhQUFPLEVBQUUsQ0FMcUU7QUFNOUVDLG9CQUFjLEVBQUUsS0FOOEQ7QUFPOUV6QyxVQUFJLEVBQUUsTUFQd0U7QUFROUUwQyxlQUFTLEVBQUU7QUFDUCxlQUFPLFlBREE7QUFFUCxxQkFBYSxZQUZOO0FBR1AsZUFBTyxhQUFVQyxFQUFWLEVBQWM7QUFDakIsY0FBSUEsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBSixFQUFnQztBQUM1QmtYLGNBQUUsQ0FBQ25YLFNBQUgsQ0FBYSxZQUFiLEVBQTJCLEtBQTNCO0FBQ0gsV0FGRCxNQUVPO0FBQ0htWCxjQUFFLENBQUN0bkIsT0FBSCxDQUFXK0QsS0FBWCxDQUFpQndqQixJQUFqQjtBQUNIO0FBQ0osU0FUTTtBQVVQLGVBQU8sYUFBVUQsRUFBVixFQUFjO0FBQ2pCQSxZQUFFLENBQUNuWCxTQUFILENBQWEsWUFBYixFQUEyQixDQUFDbVgsRUFBRSxDQUFDbFgsU0FBSCxDQUFhLFlBQWIsQ0FBNUI7QUFDSDtBQVpNO0FBUm1FLEtBQWhFLENBQWxCO0FBdUJBLFVBQUt3VixLQUFMLEdBQWEsS0FBYjtBQXpCbUI7QUEwQnRCOzs7OzBCQUVLOUIsVyxFQUFhQyxTLEVBQVc7QUFDMUIsbUZBQVlELFdBQVosRUFBeUJDLFNBQXpCOztBQUNBLFdBQUs2QixLQUFMLEdBQWEsS0FBYjtBQUNBLFdBQUtqVixZQUFMLENBQWtCLEtBQUt0RCxJQUFMLENBQVVtQixNQUFWLEVBQWxCLEVBSDBCLENBSTFCOztBQUNBLFdBQUsrWCxtQkFBTCxHQUEyQixLQUFLbFosSUFBTCxDQUFVbUIsTUFBVixDQUFpQmlILFNBQWpCLENBQTJCLEtBQUs5RSxZQUFMLENBQWtCZCxJQUFsQixDQUF1QixJQUF2QixDQUEzQixDQUEzQixDQUwwQixDQU0xQjs7QUFDQSxXQUFLZ1csZUFBTCxHQUF1QixLQUFLQyxZQUFMLENBQWtCalcsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBdkI7QUFDQSxXQUFLOEssR0FBTCxDQUFTOUYsSUFBVCxDQUFjLHVCQUFkLEVBQXVDcU0sRUFBdkMsQ0FBMEMsT0FBMUMsRUFBbUQsS0FBSzJFLGVBQXhELEVBUjBCLENBUzFCOztBQUNBLFVBQUk5QixTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEI7QUFDQXlELGtCQUFVLENBQUMsS0FBS3RYLFVBQUwsQ0FBZ0I3SCxPQUFoQixDQUF3QndILElBQXhCLENBQTZCLEtBQUtLLFVBQWxDLENBQUQsRUFBZ0QsQ0FBaEQsQ0FBVjtBQUNILE9BYnlCLENBYzFCOzs7QUFDQSxXQUFLQSxVQUFMLENBQWdCQyxTQUFoQixDQUEwQixVQUExQixFQUFzQzJULFdBQVcsQ0FBQ2xWLFVBQVosQ0FBdUIsR0FBdkIsS0FBK0IsQ0FBQyxLQUFLNEYsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRSxVQUF4QixFQUF0RTtBQUVIOzs7aUNBRVk2bEIsVyxFQUFhO0FBQ3RCLFdBQUtILEtBQUwsR0FBYSxDQUFDLEtBQUtBLEtBQW5COztBQUNBLFVBQUksS0FBS0EsS0FBVCxFQUFnQjtBQUNaLGFBQUtBLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSzFWLFVBQUwsQ0FBZ0J1WCxRQUFoQixDQUF5QjFCLFdBQXpCO0FBQ0EsYUFBSzdWLFVBQUwsQ0FBZ0I3SCxPQUFoQjtBQUNBLGFBQUt1ZCxLQUFMLEdBQWEsS0FBYjtBQUNIO0FBQ0o7OztpQ0FFWTVTLEssRUFBTztBQUNoQixXQUFLNFMsS0FBTCxHQUFhLENBQUMsS0FBS0EsS0FBbkI7O0FBQ0EsVUFBSSxLQUFLQSxLQUFULEVBQWdCO0FBQ1osYUFBS0EsS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLdlksSUFBTCxDQUFVbUIsTUFBVixDQUFpQixLQUFLMEIsVUFBTCxDQUFnQndYLFFBQWhCLEVBQWpCOztBQUNBLFlBQUksS0FBS2xULElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DaXFCLE9BQXBDLE9BQWtELFFBQXRELEVBQWdFO0FBQzVELGVBQUsvVSxJQUFMLENBQVV6TyxVQUFWLENBQXFCb0MsWUFBckIsQ0FBa0NtakIsYUFBbEMsQ0FBZ0QsUUFBaEQ7QUFDSDs7QUFDRCxhQUFLMUYsS0FBTCxHQUFhLEtBQWI7QUFDSDtBQUNKOzs7eUJBRUk5QixXLEVBQWFDLFMsRUFBV0UsUyxFQUFXO0FBQ3BDO0FBQ0EsV0FBS3NDLG1CQUFMLENBQXlCRSxPQUF6QjtBQUNBLFdBQUs5TCxHQUFMLENBQVM5RixJQUFULENBQWMsMEJBQWQsRUFBMEM4UyxHQUExQyxDQUE4QyxPQUE5QyxFQUF1RCxLQUFLOUIsZUFBNUQsRUFIb0MsQ0FJcEM7O0FBQ0EsV0FBSzNWLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQTBCLFVBQTFCLEVBQXNDLEtBQXRDOztBQUNBLGtGQUFXMlQsV0FBWCxFQUF3QkMsU0FBeEI7QUFDSDs7OztFQTdFMkJSLCtEOztBQWdGekIsSUFBTTBLLGFBQWEsR0FBRztBQUN6QnZ3QixNQUFJLEVBQUUsU0FEbUI7QUFFekJ1b0IsWUFBVSxFQUFFLENBQUMsa0JBQUQsQ0FGYTtBQUd6QkMsYUFBVyxFQUFFOEgsaUJBSFk7QUFJekI3SCxVQUFRLEVBQUU0SDtBQUplLENBQXRCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEdQOzs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJTyxJQUFJRyxXQUFXLEdBQUc7QUFDckJDLFlBQVUsRUFBRSxZQURTO0FBRXJCQyxZQUFVLEVBQUUsWUFGUztBQUdyQkMsY0FBWSxFQUFFLGNBSE87QUFJckJDLFFBQU0sRUFBRSxRQUphO0FBS3JCQyxXQUFTLEVBQUUsV0FMVTtBQU1yQkMsU0FBTyxFQUFFLFNBTlk7QUFPckJDLGVBQWEsRUFBRSxlQVBNO0FBUXJCQyxvQkFBa0IsRUFBRSxvQkFSQztBQVNyQkMsaUJBQWUsRUFBRTtBQVRJLENBQWxCO0FBWVAsSUFBTUMsa0JBQWtCLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBM0I7QUFFQSxJQUFNQyxpQkFBaUIsR0FBRyxDQUN0QmYsdURBRHNCLEVBQ1YzQiwyREFEVSxFQUNJbkcsOEVBREosRUFDd0IySCx1REFEeEIsRUFDb0NwRiwrREFEcEMsRUFFdEJpRiw0RUFGc0IsRUFFSDVGLHVEQUZHLEVBRVNxRyw2REFGVCxFQUV3QjNCLHVEQUZ4QixFQUVvQzVGLDBEQUZwQyxDQUExQjtBQUtPLElBQU1vSSxZQUFZLEdBQUdELGlCQUFpQixDQUFDM2YsR0FBbEIsQ0FBc0IsVUFBQWdELE1BQU07QUFBQSx5SEFFREEsTUFBTSxDQUFDeFUsSUFGTiwyREFJbER3VSxNQUFNLENBQUNpVSxRQUoyQztBQUFBO0FBUXBEOzs7OztBQVJ3QixFQWExQmhFLElBYjBCLENBYXJCLElBYnFCLENBQXJCO0FBZUEsSUFBTWhOLE9BQWI7QUFDSSxtQkFBWVgsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBSzlSLE9BQUwsR0FBZSxJQUFmO0FBQ0EsU0FBS2ttQixXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixFQUFuQjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxFQUFmO0FBQ0FKLHFCQUFpQixDQUFDNVEsT0FBbEIsQ0FBMEIsVUFBQS9MLE1BQU07QUFBQSxhQUFJLEtBQUksQ0FBQ2dkLGNBQUwsQ0FBb0JoZCxNQUFwQixDQUFKO0FBQUEsS0FBaEM7QUFDQSxTQUFLc0MsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCQyxRQUF4QixDQUFpQ3dWLFNBQWpDLENBQTJDLEtBQUsrTixZQUFoRCxFQUE4RCxJQUE5RDtBQUNIOztBQVZMO0FBQUE7QUFBQSxtQ0FZbUI1YyxJQVpuQixFQVl5QjtBQUNqQixVQUFJcWYsVUFBVSxHQUFHcmYsSUFBSSxDQUFDcWYsVUFBdEI7QUFDQSxVQUFJa0osUUFBUSxHQUFHLElBQUl2b0IsSUFBSSxDQUFDc2YsV0FBVCxDQUFxQixLQUFLMVIsSUFBMUIsRUFBZ0MsS0FBS21HLEdBQXJDLENBQWY7QUFDQXdVLGNBQVEsQ0FBQ3p4QixJQUFULEdBQWdCa0osSUFBSSxDQUFDbEosSUFBckI7QUFDQSxXQUFLcXhCLFdBQUwsQ0FBaUI1VSxJQUFqQixDQUFzQmdWLFFBQXRCO0FBQ0EsV0FBS0YsT0FBTCxDQUFhcm9CLElBQUksQ0FBQ2xKLElBQUwsQ0FBVTRNLFdBQVYsRUFBYixJQUF3QzZrQixRQUF4Qzs7QUFDQSxXQUFLLElBQUlyUyxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUdtSixVQUFVLENBQUMzWSxNQUE3QixFQUFxQ3dQLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsYUFBS2tTLFdBQUwsQ0FBaUIvSSxVQUFVLENBQUNuSixDQUFELENBQTNCLElBQWtDcVMsUUFBbEM7QUFDSDtBQUNKO0FBckJMO0FBQUE7QUFBQSwyQkF1Qld6eEIsSUF2QlgsRUF1QmlCO0FBQ1QsYUFBTyxLQUFLdXhCLE9BQUwsQ0FBYXZ4QixJQUFJLENBQUM0TSxXQUFMLEVBQWIsQ0FBUDtBQUNIO0FBekJMO0FBQUE7QUFBQSxpQ0EyQmlCd1osV0EzQmpCLEVBMkI4QjtBQUN0QixVQUFJQyxTQUFTLEdBQUcsS0FBS2xiLE9BQXJCO0FBQ0EsVUFBSW9iLFNBQVMsR0FBRyxLQUFLbFYsU0FBTCxDQUFlK1UsV0FBZixFQUE0QkMsU0FBNUIsQ0FBaEI7O0FBQ0EsVUFBSUEsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCQSxpQkFBUyxDQUFDcUwsSUFBVixDQUFldEwsV0FBZixFQUE0QkMsU0FBNUIsRUFBdUNFLFNBQXZDO0FBQ0g7O0FBQ0QsV0FBS3BiLE9BQUwsR0FBZW9iLFNBQWY7QUFDQSxXQUFLcGIsT0FBTCxDQUFhd21CLEtBQWIsQ0FBbUJ2TCxXQUFuQixFQUFnQ0MsU0FBaEM7QUFDSDtBQW5DTDtBQUFBO0FBQUEsOEJBaURjNVcsSUFqRGQsRUFpRG9CO0FBQUEsa0NBQ2NnSSxPQUFPLENBQUNnUCxhQUFSLENBQXNCaFgsSUFBdEIsQ0FEZDtBQUFBLFVBQ1BtaUIsS0FETyx5QkFDUEEsS0FETztBQUFBLFVBQ0E1eEIsSUFEQSx5QkFDQUEsSUFEQTtBQUFBLFVBQ01PLElBRE4seUJBQ01BLElBRE47O0FBRVosVUFBSUEsSUFBSSxLQUFLLFVBQVQsSUFBdUJrUCxJQUFJLElBQUksS0FBSzZoQixXQUF4QyxFQUFxRDtBQUNqRCxlQUFPLEtBQUtBLFdBQUwsQ0FBaUI3aEIsSUFBakIsQ0FBUDtBQUNIOztBQUNELFVBQUlvaUIsY0FBYyxHQUFHLEtBQUsvYSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJpQyxJQUEzQixFQUFyQjs7QUFDQSxVQUFJc3hCLGNBQWMsS0FBS0MseUVBQWMsQ0FBQ3J4QixPQUF0QyxFQUErQztBQUMzQyxZQUFJVCxJQUFJLEtBQUssUUFBVCxJQUFxQk8sSUFBSSxLQUFLLEtBQWxDLEVBQXlDO0FBQ3JDLGNBQUksTUFBSXN4QixjQUFKLElBQXNCLEtBQUtQLFdBQS9CLEVBQTRDO0FBQ3hDLG1CQUFPLEtBQUtBLFdBQUwsQ0FBaUIsTUFBSU8sY0FBckIsQ0FBUDtBQUNILFdBRkQsTUFFTztBQUNIMW9CLG1CQUFPLENBQUMrWCxLQUFSLENBQWMsMkNBQWQsRUFBMkQyUSxjQUEzRDtBQUNBLG1CQUFPLEtBQUtSLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxVQUFJOXdCLElBQUksSUFBSSxLQUFLK3dCLFdBQWpCLEVBQThCO0FBQzFCLGVBQU8sS0FBS0EsV0FBTCxDQUFpQi93QixJQUFqQixDQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxLQUFLOHdCLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNILE9BcEJXLENBcUJaOztBQUNIO0FBdkVMO0FBQUE7QUFBQSxrQ0FxQ3lCNWhCLElBckN6QixFQXFDK0I7QUFDdkIsVUFBSW1pQixLQUFLLEdBQUduaUIsSUFBSSxDQUFDdVAsTUFBTCxDQUFZLENBQVosQ0FBWjs7QUFDQSxVQUFJa1Msa0JBQWtCLENBQUNuZixPQUFuQixDQUEyQjZmLEtBQTNCLE1BQXNDLENBQUMsQ0FBM0MsRUFBOEM7QUFDMUNuaUIsWUFBSSxHQUFHQSxJQUFJLENBQUNnQyxNQUFMLENBQVksQ0FBWixDQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0htZ0IsYUFBSyxHQUFHLEVBQVI7QUFDSDs7QUFDRCxVQUFJNXhCLElBQUksR0FBR3lQLElBQUksQ0FBQ2dDLE1BQUwsQ0FBWSxDQUFaLEVBQWVoQyxJQUFJLENBQUNzaUIsV0FBTCxDQUFpQixHQUFqQixDQUFmLENBQVg7QUFDQSxVQUFJeHhCLElBQUksR0FBR2tQLElBQUksQ0FBQ2dDLE1BQUwsQ0FBWWhDLElBQUksQ0FBQ3NpQixXQUFMLENBQWlCLEdBQWpCLENBQVosQ0FBWDtBQUNBLGFBQU87QUFBQyxpQkFBU0gsS0FBVjtBQUFpQixnQkFBUTV4QixJQUF6QjtBQUErQixnQkFBUU87QUFBdkMsT0FBUDtBQUNIO0FBL0NMOztBQUFBO0FBQUEsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFZTyxJQUFNZ1gsYUFBYjtBQUNJLHlCQUFZVCxJQUFaLEVBQWtCO0FBQUE7O0FBQ2QsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS2tiLGNBQUwsR0FBc0IsS0FBS2xiLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUF0QztBQUVBLFNBQUsrckIsY0FBTCxHQUFzQjtBQUNsQnJkLFNBQUcsRUFBRSxJQUFJc2QsNERBQUosQ0FBcUJwYixJQUFyQixDQURhO0FBRWxCcWIsVUFBSSxFQUFFLElBQUlDLDhEQUFKLENBQXNCdGIsSUFBdEIsQ0FGWTtBQUdsQmxXLFdBQUssRUFBRSxJQUFJeXhCLGlFQUFKLENBQXVCdmIsSUFBdkIsQ0FIVztBQUlsQmpXLGNBQVEsRUFBRSxJQUFJeXhCLHVFQUFKLENBQTBCeGIsSUFBMUIsQ0FKUTtBQUtsQmhXLFlBQU0sRUFBRSxJQUFJeXhCLG1FQUFKLENBQXdCemIsSUFBeEI7QUFMVSxLQUF0QixDQUpjLENBWWQ7O0FBQ0FKLE1BQUUsQ0FBQzhiLFNBQUgsQ0FBYSxLQUFLUCxjQUFMLENBQW9CcmQsR0FBcEIsQ0FBd0I2ZCxnQkFBeEIsRUFBYixFQWJjLENBZWQ7O0FBQ0EsU0FBSzlZLGVBQUwsR0FBdUIsRUFBdkI7QUFFQTs7Ozs7QUFJQSxTQUFLK1ksZ0JBQUwsR0FBd0IsSUFBeEI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLElBQXRCO0FBQ0g7QUFFRDs7Ozs7QUEzQko7QUFBQTtBQUFBLG1DQThCbUI7QUFDWCxVQUFJQyxNQUFNLEdBQUcsS0FBS1osY0FBTCxDQUFvQjdyQixPQUFqQztBQUNBeXNCLFlBQU0sQ0FBQyxVQUFELENBQU4sR0FBcUIsRUFBckI7QUFDQUEsWUFBTSxDQUFDLFFBQUQsQ0FBTixHQUFtQixFQUFuQjtBQUNBQSxZQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CLEVBQXBCO0FBQ0FBLFlBQU0sQ0FBQyxZQUFELENBQU4sR0FBdUIsRUFBdkI7QUFDQUEsWUFBTSxDQUFDLE9BQUQsQ0FBTixHQUFrQixLQUFLOWIsSUFBTCxDQUFVblgsS0FBNUI7QUFDSDtBQXJDTDtBQUFBO0FBQUEsd0NBdUN3QjtBQUNoQixVQUFJNEcsT0FBTyxHQUFHLEtBQUt5ckIsY0FBTCxDQUFvQnpyQixPQUFsQztBQUNBQSxhQUFPLENBQUNTLEtBQVIsR0FBZ0IsRUFBaEI7QUFDQVQsYUFBTyxDQUFDQyxXQUFSLENBQW9CLElBQXBCO0FBQ0FELGFBQU8sQ0FBQ00sZ0JBQVIsQ0FBeUIsQ0FBekI7QUFDQU4sYUFBTyxDQUFDRSxRQUFSLENBQWlCLENBQWpCO0FBQ0FGLGFBQU8sQ0FBQ0csV0FBUixDQUFvQixJQUFwQjtBQUNBSCxhQUFPLENBQUNLLGdCQUFSLENBQXlCNFcsU0FBekI7QUFDQWpYLGFBQU8sQ0FBQ08sT0FBUixHQUFrQixJQUFsQjtBQUNBUCxhQUFPLENBQUNzc0IsT0FBUixHQUFrQixFQUFsQjtBQUNIO0FBakRMO0FBQUE7QUFBQSwyQ0FtRDJCO0FBQ25CLFdBQUtsWixlQUFMLEdBQXVCO0FBQ25CLGlCQUFTLEVBRFU7QUFFbkIsZ0JBQVEsQ0FGVztBQUduQixnQkFBUTtBQUhXLE9BQXZCO0FBS0g7QUF6REw7QUFBQTs7QUEyREk7OztBQTNESiw0QkE4RFk7QUFDSjtBQUNBO0FBQ0EsV0FBS21aLGlCQUFMLEdBSEksQ0FJSjs7QUFDQSxXQUFLQyxZQUFMLEdBTEksQ0FNSjs7QUFDQSxXQUFLQyxvQkFBTCxHQVBJLENBUUo7O0FBQ0EsV0FBS2xjLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCb1UsS0FBN0IsR0FUSSxDQVVKOztBQUNBLFdBQUt6RyxJQUFMLENBQVV6TyxVQUFWLENBQXFCbkIsUUFBckIsQ0FBOEJxVyxLQUE5QjtBQUNIO0FBMUVMO0FBQUE7QUFBQSxpQ0E0RXNDO0FBQUEsVUFBdkIwVixlQUF1Qix1RUFBUCxLQUFPO0FBQzlCO0FBQ0E7QUFDQSxXQUFLcmUsR0FBTCxDQUFTcWUsZUFBVCxFQUg4QixDQUk5QjtBQUNIO0FBakZMO0FBQUE7QUFBQSwyQkFtRlcsQ0FFTjtBQXJGTDtBQUFBO0FBQUEsMEJBdUYrQjtBQUFBOztBQUFBLFVBQXZCQSxlQUF1Qix1RUFBUCxLQUFPO0FBQ3ZCLFdBQUs1MEIsYUFBTCxHQUFxQixLQUFLNHpCLGNBQUwsQ0FBb0JyZCxHQUFwQixDQUF3QmIsR0FBeEIsQ0FBNEIsSUFBNUIsQ0FBckI7QUFDQSxVQUFJN04sU0FBUyxHQUFHLEtBQUt1TyxPQUFMLEdBQWV5ZSxJQUFmLENBQ1osS0FBSzcwQixhQUFMLENBQW1CZ1YsT0FBbkIsQ0FBMkJsQixJQUEzQixDQUFnQyxLQUFLOVQsYUFBckMsQ0FEWSxFQUVaLEtBQUtBLGFBQUwsQ0FBbUI4MEIsT0FBbkIsQ0FBMkJoaEIsSUFBM0IsQ0FBZ0MsS0FBSzlULGFBQXJDLENBRlksQ0FBaEI7O0FBSUEsVUFBSSxDQUFDLEtBQUt5WSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJzRCxRQUEzQixDQUFvQ3F4QixlQUFwQyxFQUFELElBQTBELENBQUNBLGVBQS9ELEVBQWdGO0FBQzVFL3NCLGlCQUFTLENBQUNndEIsSUFBVixDQUFlLFlBQU07QUFDakIsZUFBSSxDQUFDNzBCLGFBQUwsQ0FBbUIrMEIsa0JBQW5COztBQUNBLGlCQUFPLEtBQUksQ0FBQ3h5QixLQUFMLEVBQVA7QUFDSCxTQUhEO0FBSUgsT0FMRCxNQUtPO0FBQ0hzRixpQkFBUyxDQUFDZ3RCLElBQVYsQ0FBZSxLQUFLNzBCLGFBQUwsQ0FBbUJnMUIsVUFBbkIsQ0FBOEJsaEIsSUFBOUIsQ0FBbUMsS0FBSzlULGFBQXhDLENBQWY7QUFDSDs7QUFDRDZILGVBQVMsQ0FBQ2d0QixJQUFWLENBQWUsS0FBSzcwQixhQUFMLFlBQTJCOFQsSUFBM0IsQ0FBZ0MsS0FBSzlULGFBQXJDLENBQWY7QUFDSDtBQXRHTDtBQUFBO0FBQUEsNEJBd0dZO0FBQ0osV0FBS0EsYUFBTCxHQUFxQixLQUFLNHpCLGNBQUwsQ0FBb0JyeEIsS0FBcEIsQ0FBMEJtVCxHQUExQixDQUE4QixJQUE5QixDQUFyQjtBQUNBLFdBQUtVLE9BQUwsR0FBZXllLElBQWYsQ0FDSSxLQUFLNzBCLGFBQUwsQ0FBbUJnVixPQUFuQixDQUEyQmxCLElBQTNCLENBQWdDLEtBQUs5VCxhQUFyQyxDQURKLEVBRUksS0FBS0EsYUFBTCxDQUFtQjgwQixPQUFuQixDQUEyQmhoQixJQUEzQixDQUFnQyxLQUFLOVQsYUFBckMsQ0FGSixFQUlLNjBCLElBSkwsQ0FJVSxLQUFLNzBCLGFBQUwsWUFBMkI4VCxJQUEzQixDQUFnQyxLQUFLOVQsYUFBckMsQ0FKVixFQUtLNjBCLElBTEwsQ0FLVSxLQUFLSSxhQUFMLENBQW1CbmhCLElBQW5CLENBQXdCLElBQXhCLENBTFY7QUFNSDtBQWhITDtBQUFBO0FBQUEsK0JBa0hlO0FBQUE7O0FBQ1AsV0FBSzJFLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQzZKLE1BQS9DO0FBQ0EsVUFBSW9sQixlQUFlLEdBQUcsS0FBS3pjLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCK0wsUUFBN0IsRUFBdEI7QUFDQS9MLGFBQU8sQ0FBQ29OLEdBQVIsQ0FBWWdkLGVBQVo7QUFDQUEscUJBQWUsQ0FBQ0wsSUFBaEIsQ0FBcUIsVUFBQ00sU0FBRCxFQUFlO0FBQ2hDLGNBQUksQ0FBQ24xQixhQUFMLEdBQXFCLE1BQUksQ0FBQzR6QixjQUFMLENBQW9CRSxJQUFwQixDQUF5QnBlLEdBQXpCLENBQTZCLE1BQTdCLEVBQW1DeWYsU0FBbkMsQ0FBckI7O0FBQ0EsWUFBSXR0QixTQUFTLEdBQUcsTUFBSSxDQUFDdU8sT0FBTCxHQUFleWUsSUFBZixDQUNaLE1BQUksQ0FBQzcwQixhQUFMLENBQW1CZ1YsT0FBbkIsQ0FBMkJsQixJQUEzQixDQUFnQyxNQUFJLENBQUM5VCxhQUFyQyxDQURZLEVBRVosTUFBSSxDQUFDQSxhQUFMLENBQW1CODBCLE9BQW5CLENBQTJCaGhCLElBQTNCLENBQWdDLE1BQUksQ0FBQzlULGFBQXJDLENBRlksQ0FBaEI7O0FBSUEsWUFBSSxDQUFDLE1BQUksQ0FBQ3lZLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DcXhCLGVBQXBDLEVBQUQsSUFDQSxNQUFJLENBQUNuYyxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ3QyxNQUEzQixFQURKLEVBQ3lDO0FBQ3JDLGdCQUFJLENBQUN6QyxhQUFMLENBQW1CKzBCLGtCQUFuQjs7QUFDQWx0QixtQkFBUyxDQUFDZ3RCLElBQVYsQ0FBZSxNQUFJLENBQUNweUIsTUFBTCxDQUFZcVIsSUFBWixDQUFpQixNQUFqQixDQUFmO0FBQ0gsU0FKRCxNQUlPO0FBQ0hqTSxtQkFBUyxDQUFDZ3RCLElBQVYsQ0FBZSxNQUFJLENBQUM3MEIsYUFBTCxDQUFtQmcxQixVQUFuQixDQUE4QmxoQixJQUE5QixDQUFtQyxNQUFJLENBQUM5VCxhQUF4QyxDQUFmLEVBQ0s2MEIsSUFETCxDQUNVLE1BQUksQ0FBQ2hlLFFBQUwsQ0FBYy9DLElBQWQsQ0FBbUIsTUFBbkIsQ0FEVjtBQUVIOztBQUNEak0saUJBQVMsQ0FBQ2d0QixJQUFWLENBQWUsTUFBSSxDQUFDNzBCLGFBQUwsWUFBMkI4VCxJQUEzQixDQUFnQyxNQUFJLENBQUM5VCxhQUFyQyxDQUFmO0FBQ0gsT0FmRDtBQWdCSDtBQXRJTDtBQUFBO0FBQUEsNkJBd0lhO0FBQ0wsV0FBS0EsYUFBTCxHQUFxQixLQUFLNHpCLGNBQUwsQ0FBb0JueEIsTUFBcEIsQ0FBMkJpVCxHQUEzQixDQUErQixJQUEvQixDQUFyQjtBQUNBLFdBQUtVLE9BQUwsR0FBZXllLElBQWYsQ0FDSSxLQUFLNzBCLGFBQUwsQ0FBbUJnVixPQUFuQixDQUEyQmxCLElBQTNCLENBQWdDLEtBQUs5VCxhQUFyQyxDQURKLEVBRUksS0FBS0EsYUFBTCxDQUFtQjgwQixPQUFuQixDQUEyQmhoQixJQUEzQixDQUFnQyxLQUFLOVQsYUFBckMsQ0FGSixFQUlLNjBCLElBSkwsQ0FJVSxLQUFLaGUsUUFBTCxDQUFjL0MsSUFBZCxDQUFtQixJQUFuQixDQUpWLEVBS0srZ0IsSUFMTCxDQUtVLEtBQUs3MEIsYUFBTCxZQUEyQjhULElBQTNCLENBQWdDLEtBQUs5VCxhQUFyQyxDQUxWO0FBTUg7QUFoSkw7QUFBQTtBQUFBLCtCQWtKZTtBQUNQLFdBQUtBLGFBQUwsR0FBcUIsS0FBSzR6QixjQUFMLENBQW9CcHhCLFFBQXBCLENBQTZCa1QsR0FBN0IsQ0FBaUMsSUFBakMsQ0FBckI7QUFDSDtBQXBKTDtBQUFBO0FBQUEsOEJBc0pjO0FBQUE7O0FBQ04sV0FBSytDLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQzZKLE1BQS9DO0FBQ0EsYUFBT3VJLEVBQUUsQ0FBQytjLFFBQUgsQ0FBWUMsY0FBWixDQUEyQjtBQUFBLGVBQzlCaGQsRUFBRSxDQUFDaWQsa0JBQUgsQ0FBc0IsTUFBSSxDQUFDdDFCLGFBQUwsQ0FBbUJrRSxRQUF6QyxFQUFtRCxLQUFuRCxFQUNzQixNQUFJLENBQUNsRSxhQUFMLENBQW1CeUQsSUFEekMsRUFDK0MsSUFEL0MsRUFFc0IsTUFBSSxDQUFDekQsYUFBTCxDQUFtQjRJLFVBRnpDLENBRDhCO0FBQUEsT0FBM0IsQ0FBUDtBQUtIO0FBRUQ7Ozs7QUEvSko7QUFBQTtBQUFBLGdDQWtLZ0I7QUFDUixVQUFJMnNCLFFBQVEsR0FBRyxXQUFmLENBRFEsQ0FFUjs7QUFDQSxVQUFJLENBQUMsS0FBSzljLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JrMEIsUUFBaEIsQ0FBeUJELFFBQXpCLElBQXFDdlksSUFBckMsRUFBTCxFQUFrRDtBQUM5QyxlQUFPLEtBQVA7QUFDSDs7QUFDRCxXQUFLdkUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCOUIsTUFBMUIsQ0FBaUMsVUFBakM7QUFDQSxXQUFLMFMsSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ3ckIsUUFBNUIsR0FQUSxDQVFSOztBQUNBLFVBQUlwbkIsTUFBTSxHQUFHLElBQWI7QUFDQSxVQUFJeEYsUUFBUSxHQUFHLEtBQUs0UCxJQUFMLENBQVV6TyxVQUFWLENBQXFCbkIsUUFBcEM7QUFDQXdGLFlBQU0sQ0FBQ3FtQixZQUFQO0FBQ0FybUIsWUFBTSxDQUFDcW5CLFVBQVA7QUFDQXJuQixZQUFNLENBQUNzbkIsV0FBUDtBQUNBdG5CLFlBQU0sQ0FBQ3VuQixpQkFBUCxDQUF5QkwsUUFBekIsRUFBbUMsSUFBbkMsRUFBeUMsVUFBVU0sTUFBVixFQUFrQjtBQUN2RCxZQUFJeGQsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsWUFBcEIsRUFBa0MsU0FBbEMsQ0FBSixFQUFrRDtBQUM5QztBQUNBO0FBQ0EsY0FBSSxDQUFDOWdCLE9BQUQsSUFDQSxFQUFFak0sUUFBUSxLQUFLLFlBQWIsSUFBNkJDLEtBQUssS0FBSyxXQUF6QyxDQURKLEVBQzJEO0FBQ3ZESCxvQkFBUSxDQUFDa3RCLGVBQVQsQ0FBeUJodEIsUUFBekIsRUFBbUNDLEtBQW5DLEVBQTBDRixPQUExQyxFQUFtRHVILElBQW5EO0FBQ0g7O0FBQ0RoQyxnQkFBTSxDQUFDb0ssSUFBUCxDQUFZek8sVUFBWixDQUF1Qm5CLFFBQXZCLENBQWdDa3RCLGVBQWhDLENBQWdERixNQUFNLENBQUNHLEVBQXZEO0FBQ0EzbkIsZ0JBQU0sQ0FBQ29LLElBQVAsQ0FBWW5YLEtBQVosQ0FBa0J1RyxTQUFsQixDQUE0QjlCLE1BQTVCLENBQW1DLFVBQW5DO0FBQ0g7QUFDSixPQVhEO0FBWUFzSSxZQUFNLENBQUNvSyxJQUFQLENBQVl6TyxVQUFaLENBQXVCQyxNQUF2QixDQUE4QnZELFFBQTlCLENBQXVDLFFBQXZDLEVBQWlELFdBQWpEO0FBQ0g7QUE3TEw7QUFBQTs7QUFnTUk7Ozs7QUFoTUosb0NBb01vQjtBQUNaLFVBQUksS0FBSzR0QixjQUFMLEtBQXdCLElBQTVCLEVBQWtDO0FBQzlCLGFBQUtBLGNBQUw7QUFDSDtBQUNKO0FBRUQ7Ozs7QUExTUo7QUFBQTtBQUFBLHNDQTZNc0I7QUFDZCxVQUFJLEtBQUtELGdCQUFMLEtBQTBCLElBQTlCLEVBQW9DO0FBQ2hDLGFBQUtBLGdCQUFMO0FBQ0g7QUFDSjtBQWpOTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCTyxJQUFNNEIsWUFBWSxHQUFHLG1EQUFyQjtBQUVQOzs7OztBQUlPLElBQU1DLGFBQWI7QUFFSSx5QkFBWXpkLElBQVosRUFBa0I7QUFBQTs7QUFDZCxTQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLdlUsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFNBQUtULElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBS21GLFVBQUwsR0FBa0J4SSxTQUFsQjtBQUNIOztBQVBMO0FBQUE7QUFBQSx3QkFTUWlPLE1BVFIsRUFTZ0I7QUFBQTs7QUFDUjtBQUNBLFdBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBZ0ssUUFBRSxDQUFDeWQsZ0JBQUgsR0FBc0IsS0FBS3JkLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBaEQ7QUFDQXVRLFFBQUUsQ0FBQ3ZOLE9BQUgsR0FBYSxLQUFLMk4sSUFBTCxDQUFVek8sVUFBVixDQUFxQmMsT0FBbEM7QUFDQXVOLFFBQUUsQ0FBQzhGLFdBQUgsR0FBaUIsRUFBakI7QUFDQTlGLFFBQUUsQ0FBQzhiLFNBQUgsQ0FBYSxLQUFLQyxnQkFBTCxFQUFiLEVBTlEsQ0FPUjs7QUFDQS9iLFFBQUUsQ0FBQzhkLFNBQUgsR0FBZSxLQUFLQyxRQUFMLENBQWN0aUIsSUFBZCxDQUFtQixJQUFuQixDQUFmLENBUlEsQ0FTUjs7QUFDQXVFLFFBQUUsQ0FBQ2dlLFdBQUgsR0FBaUIsVUFBQ3AwQixHQUFELEVBQU00SSxJQUFOLEVBQVl5ckIsT0FBWjtBQUFBLGVBQXdCLEtBQUksQ0FBQ0MsT0FBTCxDQUFhdDBCLEdBQWIsRUFBa0I0SSxJQUFsQixFQUF3QnlyQixPQUF4QixDQUF4QjtBQUFBLE9BQWpCLENBVlEsQ0FXUjs7O0FBQ0FqZSxRQUFFLENBQUNtZSxjQUFILEdBQW9CLFVBQUNDLFVBQUQsRUFBYUMsU0FBYixFQUEyQjtBQUMzQyxZQUFJLEtBQUksQ0FBQ2plLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Db3pCLGNBQXBDLEVBQUosRUFBMEQ7QUFDdEQsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQUl0WixhQUFhLEdBQUcsS0FBSSxDQUFDdVosZ0JBQUwsQ0FBc0JILFVBQVUsR0FBQyxJQUFYLEdBQWtCLEVBQXhDLENBQXBCOztBQUNBLFlBQUlJLEtBQUssR0FBRzFjLE1BQU0sQ0FBQ2tELGFBQUQsRUFBZ0JoRixFQUFFLENBQUNxZSxTQUFILEdBQWEsSUFBN0IsQ0FBbEI7O0FBQ0EsWUFBSUcsS0FBSyxLQUFLLElBQVYsSUFBa0JBLEtBQUssSUFBRSxDQUE3QixFQUFnQztBQUM1QkEsZUFBSyxHQUFHeGUsRUFBRSxDQUFDcWUsU0FBSCxHQUFlSSxRQUFRLENBQUNELEtBQUQsRUFBUSxFQUFSLENBQVIsR0FBc0IsSUFBN0M7QUFDQXhlLFlBQUUsQ0FBQ3FlLFNBQUgsR0FBZUcsS0FBZjs7QUFDQXhlLFlBQUUsQ0FBQzBlLGlCQUFILEdBQXVCO0FBQUEsbUJBQ25CLEtBQUksQ0FBQ3RlLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Db3pCLGNBQXBDLEtBQXVESyxRQUF2RCxHQUFrRUgsS0FEL0M7QUFBQSxXQUF2QjtBQUVIOztBQUNELGVBQU9BLEtBQVA7QUFDSCxPQWJELENBWlEsQ0EwQlI7OztBQUNBeGUsUUFBRSxDQUFDNGUsVUFBSCxHQUFnQixLQUFLQSxVQUFMLENBQWdCbmpCLElBQWhCLENBQXFCLElBQXJCLENBQWhCO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7QUF0Q0w7QUFBQTtBQUFBLHFDQXdDcUJvakIsV0F4Q3JCLEVBd0NrQztBQUMxQixVQUFJQSxXQUFKLEVBQWlCO0FBQ2IsZUFBTyxpS0FBUDtBQUNILE9BRkQsTUFFTztBQUNILGVBQU8scUZBQVA7QUFDSDtBQUNKO0FBOUNMO0FBQUE7QUFBQSx1Q0FnRHVCO0FBQ2YsYUFBTztBQUNIQyxrQkFBVSxFQUFFOWUsRUFBRSxDQUFDK2UsT0FEWjtBQUVIO0FBQ0FDLFlBQUksRUFBRSxLQUFLQyxVQUFMLENBQWdCeGpCLElBQWhCLENBQXFCLElBQXJCLENBSEg7QUFJSDtBQUNBO0FBQ0E7QUFDQXlqQixpQkFBUyxFQUFFLEtBQUtDLFNBQUwsQ0FBZTFqQixJQUFmLENBQW9CLElBQXBCLENBUFI7QUFRSDtBQUNBL0wsY0FBTSxFQUFFLEtBQUswdkIsS0FBTCxDQUFXM2pCLElBQVgsQ0FBZ0IsSUFBaEIsQ0FUTDtBQVVIO0FBQ0E0akIsZ0JBQVEsRUFBRSxLQUFLMXZCLEtBQUwsQ0FBVzhMLElBQVgsQ0FBZ0IsSUFBaEIsQ0FYUDtBQVlINmpCLDJCQUFtQixFQUFFLElBWmxCO0FBYUg7QUFDQUMsa0JBQVUsRUFBRSxLQUFLQyxhQUFMLENBQW1CL2pCLElBQW5CLENBQXdCLElBQXhCLENBZFQ7QUFlSDtBQUNBZ2tCLGtCQUFVLEVBQUUsb0JBQUNDLElBQUQ7QUFBQSxtRUFBcURBLElBQUksQ0FBQ3hwQixXQUFMLEVBQXJEO0FBQUEsU0FoQlQ7QUFpQkg7QUFDQXlwQixxQkFBYSxFQUFFO0FBbEJaLE9BQVA7QUFvQkg7QUFFRDs7Ozs7Ozs7O0FBdkVKO0FBQUE7QUFBQSwrQkErRWU5ekIsUUEvRWYsRUErRXlCO0FBQ2pCNEcsYUFBTyxDQUFDbXRCLElBQVIsQ0FBYSx1QkFBYixFQURpQixDQUVqQjtBQUNIO0FBbEZMO0FBQUE7QUFBQSw0QkFvRlloMkIsR0FwRlosRUFvRmlCNEksSUFwRmpCLEVBb0Z1QnlyQixPQXBGdkIsRUFvRmdDO0FBQ3hCO0FBQ0EsVUFBSTRCLFdBQVcsR0FBRyxLQUFLemYsSUFBTCxDQUFVek8sVUFBVixDQUFxQmlCLFVBQXJCLENBQWdDc0gsT0FBaEMsQ0FBd0Msb0JBQXhDLENBQWxCOztBQUNBLFVBQUkybEIsV0FBVyxJQUFJLElBQW5CLEVBQXlCO0FBQ3JCLGNBQU8sSUFBSTdmLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV0MsT0FBZixDQUF1Qix3RUFBdkIsQ0FBUDtBQUNIOztBQUNERixpQkFBVyxHQUFHdG1CLElBQUksQ0FBQ2dHLEtBQUwsQ0FBV3NnQixXQUFXLENBQUN6bEIsTUFBWixFQUFYLENBQWQ7O0FBQ0EsV0FBSyxJQUFJdk8sUUFBVCxJQUFxQmcwQixXQUFyQixFQUFrQztBQUM5QixZQUFJQSxXQUFXLENBQUNHLGNBQVosQ0FBMkJuMEIsUUFBM0IsQ0FBSixFQUEwQztBQUN0QyxlQUFLLElBQUk2YyxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUdtWCxXQUFXLENBQUNoMEIsUUFBRCxDQUFYLENBQXNCcU4sTUFBeEMsRUFBZ0R3UCxDQUFDLElBQUcsQ0FBcEQsRUFBdUQ7QUFDbkQsZ0JBQUltWCxXQUFXLENBQUNoMEIsUUFBRCxDQUFYLENBQXNCNmMsQ0FBdEIsTUFBNkI5ZSxHQUFqQyxFQUFzQztBQUNsQyxrQkFBSXEyQixRQUFRLEdBQUcsS0FBSzdmLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3N0QixRQUFoQyxDQUF5Q3IwQixRQUF6QyxDQUFmO0FBQ0EscUJBQVFvMEIsUUFBUjtBQUNIO0FBQ0o7QUFDSjtBQUNKLE9BaEJ1QixDQWlCeEI7OztBQUNBLFlBQU8sSUFBSWpnQixFQUFFLENBQUM4ZixPQUFILENBQVdDLE9BQWYsQ0FBdUIsd0JBQXNCbjJCLEdBQXRCLEdBQTBCLDZDQUFqRCxDQUFQLENBbEJ3QixDQW1CeEI7QUFDSDtBQXhHTDtBQUFBO0FBQUEsK0JBMEdlO0FBQ1A2SSxhQUFPLENBQUNtdEIsSUFBUixDQUFhLHVCQUFiLEVBRE8sQ0FFUDtBQUNIO0FBN0dMO0FBQUE7QUFBQSxnQ0ErR2dCO0FBQ1JudEIsYUFBTyxDQUFDbXRCLElBQVIsQ0FBYSx1QkFBYixFQURRLENBRVI7QUFDSDtBQWxITDtBQUFBO0FBQUEsMEJBb0hVN1csS0FwSFYsRUFvSGlCO0FBQ1QsV0FBSzNJLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCMnNCLEtBQTdCLENBQW1DclcsS0FBbkM7QUFDSDtBQXRITDtBQUFBO0FBQUEsNEJBd0hZO0FBQ0p0VyxhQUFPLENBQUNtdEIsSUFBUixDQUFhLHVCQUFiLEVBREksQ0FFSjtBQUNIO0FBM0hMO0FBQUE7QUFBQSxpQ0E2SGlCO0FBQ1QsVUFBSSxLQUFLeGYsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCdUIsV0FBeEIsRUFBSixFQUEyQztBQUN2QyxhQUFLaVQsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCRyxLQUExQixDQUFnQyxFQUFoQztBQUNIOztBQUNELFdBQUt5USxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJJLFVBQTFCLENBQXFDLENBQXJDO0FBQ0g7QUFsSUw7QUFBQTtBQUFBLGtDQTRJa0JoRyxHQTVJbEIsRUE0SXVCO0FBQ2Y7QUFDQSxhQUFPQSxHQUFQO0FBQ0g7QUEvSUw7QUFBQTtBQUFBLDJCQWlKVyxDQUVOO0FBbkpMO0FBQUE7QUFBQSwrQkFxSmUsQ0FFVjtBQXZKTDtBQUFBO0FBQUEsZ0NBeUpnQmlDLFFBekpoQixFQXlKMEI7QUFDbEIsYUFBTyxLQUFQO0FBQ0g7QUEzSkw7QUFBQTtBQUFBLDRCQTZKWTJ4QixNQTdKWixFQTZKb0I7QUFDWixZQUFNLElBQUkyQyxLQUFKLENBQVUsNEJBQVYsQ0FBTjtBQUNIO0FBL0pMO0FBQUE7QUFBQSw0QkFpS1kzVixLQWpLWixFQWlLbUI7QUFDWCxZQUFNLElBQUkyVixLQUFKLENBQVUsNEJBQVYsQ0FBTjtBQUNIO0FBbktMO0FBQUE7QUFBQSw2QkFxS1kzZ0IsTUFyS1osRUFxS29CO0FBQ1o7QUFDQSxVQUFJLEtBQUtZLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCZ1YsVUFBakMsRUFBNkM7QUFDekMsYUFBS3JILElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCZ1YsVUFBN0IsQ0FBd0N0RCxPQUF4QztBQUNBLGFBQUsvRCxJQUFMLENBQVV6TyxVQUFWLENBQXFCYyxPQUFyQixDQUE2QmdWLFVBQTdCLENBQXdDMlksSUFBeEM7QUFDSDtBQUNKO0FBM0tMO0FBQUE7QUFBQSxzQ0E2S3NCLENBQ2Q7QUFDSDtBQS9LTDtBQUFBO0FBQUEsK0JBaUxlQyxZQWpMZixFQWlMNkJDLE9Bakw3QixFQWlMc0NDLE1Bakx0QyxFQWlMOEM7QUFDdEM7QUFDQTtBQUNBLFVBQUlDLFlBQVksR0FBRyxLQUFLcGdCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NJLE9BQXJEOztBQUNBLFVBQUksRUFBRSxXQUFXMndCLFlBQWIsQ0FBSixFQUFnQztBQUM1QkEsb0JBQVksQ0FBQ2x3QixLQUFiLEdBQXFCLEVBQXJCO0FBQ0g7O0FBQ0QsVUFBSSxFQUFFK3ZCLFlBQVksSUFBSUcsWUFBWSxDQUFDbHdCLEtBQS9CLENBQUosRUFBMkM7QUFDdkNrd0Isb0JBQVksQ0FBQ2x3QixLQUFiLENBQW1CK3ZCLFlBQW5CLElBQW1DLEVBQW5DO0FBQ0g7O0FBQ0QsVUFBSUksSUFBSSxHQUFHLEVBQVgsQ0FWc0MsQ0FXdEM7O0FBQ0EsV0FBSyxJQUFJL1gsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHNFgsT0FBTyxDQUFDcG5CLE1BQTFCLEVBQWtDd1AsQ0FBQyxJQUFHLENBQXRDLEVBQXlDO0FBQ3JDK1gsWUFBSSxDQUFDLFVBQVEvWCxDQUFULENBQUosR0FBa0I0WCxPQUFPLENBQUM1WCxDQUFELENBQXpCO0FBQ0g7O0FBQ0QsVUFBSTZYLE1BQU0sSUFBSUEsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhLElBQTNCLEVBQWlDO0FBQzdCRSxZQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCRixNQUFNLENBQUMsQ0FBRCxDQUF2QjtBQUNIOztBQUNELFVBQUlBLE1BQU0sSUFBSUEsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhLElBQTNCLEVBQWlDO0FBQzdCRSxZQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CRixNQUFNLENBQUMsQ0FBRCxDQUF6QjtBQUNILE9BcEJxQyxDQXFCdEM7OztBQUNBQyxrQkFBWSxDQUFDbHdCLEtBQWIsQ0FBbUIrdkIsWUFBbkIsRUFBaUN0YSxJQUFqQyxDQUFzQzBhLElBQXRDO0FBQ0g7QUF4TUw7QUFBQTtBQUFBLHdDQW9JK0I7QUFDdkIsVUFBSXpnQixFQUFFLENBQUM4RixXQUFILENBQWU1TSxNQUFuQixFQUEyQjtBQUN2QixlQUFPOEcsRUFBRSxDQUFDOEYsV0FBSCxDQUFlNGEsR0FBZixFQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxFQUFQO0FBQ0g7QUFDSjtBQTFJTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFFTyxJQUFNaEYsaUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRMWxCLE1BRFIsRUFDZ0I1SyxJQURoQixFQUNzQjtBQUNkO0FBQ0EsV0FBS2dWLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DQyxPQUFuQyxDQUEyQyxZQUEzQztBQUNBLFdBQUs1RSxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsV0FBS1QsSUFBTCxHQUFZLFNBQVNBLElBQXJCO0FBQ0E0VSxRQUFFLENBQUMyZ0Isb0JBQUgsR0FBMEIsSUFBMUI7QUFDQTNnQixRQUFFLENBQUM0ZSxVQUFILEdBQWdCLElBQWhCOztBQUVBLGlGQUFVNW9CLE1BQVY7O0FBRUFnSyxRQUFFLENBQUMyZixhQUFILEdBQW1CLElBQW5CO0FBQ0EzZixRQUFFLENBQUMzUCxPQUFILEdBQWEsS0FBSytQLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NRLE9BQWxDLEVBQWI7QUFFQSxXQUFLK1AsSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ2RCxRQUE1QixDQUFxQyxZQUFyQyxFQUFtRCxFQUFuRCxFQUF1RCxFQUF2RCxFQUEyRGpELElBQTNELEVBQWlFLGFBQWpFO0FBQ0EsV0FBS2dWLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsU0FBckMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0QsS0FBS2pELElBQTdELEVBQW1FLGFBQW5FO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFsQkw7QUFBQTtBQUFBLDRCQW9CWW95QixNQXBCWixFQW9Cb0I7QUFBQTs7QUFDWi9xQixhQUFPLENBQUNvTixHQUFSLENBQVksY0FBWjtBQUNBLFdBQUtPLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsb0JBQXJDLEVBQTJELEVBQTNELEVBQStELEVBQS9ELEVBQW1FLEVBQW5FLEVBQXVFLGFBQXZFO0FBQ0EsV0FBSytSLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ0MsS0FBL0M7QUFDQSxXQUFLdVMsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ1EsT0FBbEMsQ0FBMEMyUCxFQUFFLENBQUMzUCxPQUE3QztBQUNBMlAsUUFBRSxDQUFDM1AsT0FBSCxHQUFhLEVBQWI7QUFDQSxVQUFJNnJCLE1BQU0sR0FBRyxLQUFLOWIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCQyxPQUF2QztBQUNBLFVBQUk1RCxRQUFRLEdBQUcsS0FBS0EsUUFBcEI7QUFDQSxXQUFLdVUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCSyxPQUExQixDQUFrQ08sT0FBbEMsR0FBNENvdEIsTUFBNUM7QUFDQSxXQUFLcGQsSUFBTCxDQUFVek8sVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJtdUIsVUFBN0IsQ0FBd0M1Z0IsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQnJELE1BQU0sQ0FBQ0csRUFBUCxDQUFVbUQsQ0FBVixDQUFZQyxFQUFaLEVBQWpCLENBQXhDO0FBQ0EsYUFBTyxJQUFJcmIsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVTRQLE1BQVYsRUFBcUI7QUFDcEM7QUFDQSxhQUFJLENBQUN4bEIsUUFBTDs7QUFDQW1zQixjQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CO0FBQ2hCLHFCQUFXLElBREs7QUFFaEIsbUJBQVMsS0FBSSxDQUFDbG1CLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJyTCxLQUZyQjtBQUdoQixtQkFBUyxLQUFJLENBQUM1QixNQUFMLENBQVlpTixlQUFaLENBQTRCckwsS0FBNUIsQ0FBa0NrRCxHQUFsQyxDQUFzQyxVQUFBa21CLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDaHBCLElBQU47QUFBQSxXQUF2QyxDQUhPO0FBSWhCLHVCQUFhLEtBQUksQ0FBQ2hDLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJyTCxLQUE1QixDQUFrQzZZLE1BQWxDLENBQXlDLFVBQUF1USxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxXQUFQO0FBQUEsV0FBMUMsRUFBOERubUIsR0FBOUQsQ0FBa0UsVUFBQWttQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ2hwQixJQUFOO0FBQUEsV0FBbkUsQ0FKRztBQUtoQixxQkFBV3dsQixNQUxLO0FBTWhCLG9CQUFVLEtBQUksQ0FBQ3BkLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkUsTUFOcEI7QUFPaEIsd0JBQWMsS0FBSSxDQUFDdEUsSUFQSDtBQVFoQixtQkFBUyxLQUFJLENBQUNnVixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUyxLQVIzQjtBQVNoQixxQkFBVztBQVRLLFNBQXBCO0FBV0FxVixlQUFPO0FBQ1YsT0FmTSxDQUFQO0FBZ0JIO0FBOUNMO0FBQUE7QUFBQSw0QkFnRFk2RSxLQWhEWixFQWdEbUI7QUFBQTs7QUFDWC9YLGFBQU8sQ0FBQ29OLEdBQVIsQ0FBWSxjQUFaLEVBQTRCMkssS0FBNUI7QUFDQSxXQUFLcEssSUFBTCxDQUFVblgsS0FBVixDQUFnQnlFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDd3FCLE1BQS9DO0FBQ0EsVUFBSThELE1BQU0sR0FBRyxLQUFLOWIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCQyxPQUF2QztBQUNBLFdBQUsyUSxJQUFMLENBQVV6TyxVQUFWLENBQXFCQyxNQUFyQixDQUE0QnZELFFBQTVCLENBQXFDLGVBQXJDLEVBQXNELEVBQXRELEVBQTBELEVBQTFELEVBQThEbWMsS0FBSyxDQUFDamQsUUFBTixFQUE5RCxFQUFnRixhQUFoRjtBQUNBLGFBQU8sSUFBSW1ZLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVU0UCxNQUFWLEVBQXFCO0FBQ3BDMkcsY0FBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjtBQUNoQixxQkFBVyxLQURLO0FBRWhCLG1CQUFTMVIsS0FGTztBQUdoQix3QkFBYyxNQUFJLENBQUNwZixJQUhIO0FBSWhCLHFCQUFXO0FBSkssU0FBcEI7QUFNQXVhLGVBQU87QUFDVixPQVJNLENBQVA7QUFTSDtBQTlETDs7QUFBQTtBQUFBLEVBQXVDdWIsNkRBQXZDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQU1DLG1CQUFtQixHQUFHLDBCQUEwQkMsb0ZBQWtCLENBQUM3ekIsUUFBbkIsRUFBdEQ7QUFDQSxJQUFNOHpCLG9CQUFvQixHQUFHQyx5RUFBN0I7QUFFTyxJQUFNQyx1QkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1F2ckIsTUFEUixFQUNnQjtBQUFBOztBQUNSLHVGQUFVQSxNQUFWLEVBRFEsQ0FFUjs7O0FBQ0FnSyxRQUFFLENBQUMwZSxpQkFBSCxHQUF1QjtBQUFBLGVBQ25CLEtBQUksQ0FBQ3RlLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Db3pCLGNBQXBDLEtBQXVESyxRQUF2RCxHQUFrRSxJQUQvQztBQUFBLE9BQXZCOztBQUVBM2UsUUFBRSxDQUFDcWUsU0FBSCxHQUFlcmUsRUFBRSxDQUFDMGUsaUJBQUgsRUFBZixDQUxRLENBTVI7O0FBQ0ExZSxRQUFFLENBQUMyZ0Isb0JBQUgsR0FBMEIsSUFBMUIsQ0FQUSxDQU93QjtBQUNoQzs7QUFDQSxXQUFLdmdCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QkcsV0FBeEIsQ0FBb0MsSUFBcEMsRUFUUSxDQVVSOztBQUNBaVUsUUFBRSxDQUFDOEYsV0FBSCxHQUFpQixFQUFqQixDQVhRLENBWVI7QUFDQTtBQUNBOztBQUNBOUYsUUFBRSxDQUFDd2hCLGdCQUFILEdBQXNCeGhCLEVBQUUsQ0FBQzRlLFVBQXpCO0FBQ0E1ZSxRQUFFLENBQUM0ZSxVQUFILEdBQWdCLElBQWhCLENBaEJRLENBaUJSOztBQUNBNWUsUUFBRSxDQUFDQyxZQUFILENBQWdCckgsS0FBaEIsQ0FBc0IsNkJBQXRCLElBQXVEdW9CLG1CQUF2RDtBQUNBbmhCLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLHFCQUF0QixJQUErQ3lvQixvQkFBL0MsQ0FuQlEsQ0FvQlI7QUFDQTs7QUFDQXJoQixRQUFFLENBQUNDLFlBQUgsQ0FBZ0JySCxLQUFoQixDQUFzQixpQ0FBdEIsSUFBMkQ2b0IsMEVBQTNEO0FBQ0EsYUFBT3poQixFQUFFLENBQUNDLFlBQUgsQ0FBZ0JySCxLQUFoQixDQUFzQixpQ0FBdEIsQ0FBUCxDQXZCUSxDQXdCUjs7QUFDQW9ILFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLDJCQUF0QixJQUFxRGdsQiwrREFBckQsQ0F6QlEsQ0EwQlI7O0FBQ0EsV0FBS3J0QixVQUFMLEdBQWtCLEtBQUtteEIsMkJBQUwsRUFBbEIsQ0EzQlEsQ0E0QlI7O0FBQ0ExaEIsUUFBRSxDQUFDMGhCLDJCQUFILEdBQWlDLEtBQUtBLDJCQUF0QztBQUNBLGFBQU8sSUFBUDtBQUNIO0FBaENMO0FBQUE7QUFBQSwwQkFrQ1UzWSxLQWxDVixFQWtDaUI7QUFDVCx5RkFBWUEsS0FBWjs7QUFDQXRXLGFBQU8sQ0FBQ2t2QixJQUFSLENBQWEsVUFBYixFQUF5QjVZLEtBQXpCO0FBQ0g7QUFyQ0w7QUFBQTtBQUFBLGtEQXVDa0M7QUFDMUIsVUFBSXhZLFVBQVUsR0FBRyxLQUFLNlAsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCMUQsVUFBMUIsQ0FBcUN5RSxVQUF0RCxDQUQwQixDQUUxQjs7QUFDQSxVQUFJQSxVQUFVLEtBQUt4SSxTQUFuQixFQUE4QjtBQUFBLG1EQUNMLEtBQUs2NUIsZUFBTCxFQURLO0FBQUE7O0FBQUE7QUFDMUIsOERBQTZDO0FBQUEsZ0JBQXBDLzFCLFFBQW9DO0FBQ3pDLGdCQUFJZzJCLFVBQVUsR0FBRyxJQUFJN2hCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV2dDLEdBQWYsQ0FBbUJqMkIsUUFBbkIsQ0FBakI7QUFDQTs7OztBQUdBMEUsc0JBQVUsQ0FBQ3d4QixRQUFYLENBQW9CRixVQUFwQjtBQUNIO0FBUHlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRN0I7O0FBQ0QsYUFBT3R4QixVQUFQO0FBQ0g7QUFwREw7QUFBQTtBQUFBLHlDQXNEeUI7QUFDakIsVUFBTXFJLEtBQUssR0FBRztBQUNWLHFCQUFhLEtBQUt3SCxJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJ3RSxLQUFuQixDQUF5Qm9CLGNBQXpCO0FBREgsT0FBZCxDQURpQixDQUlqQjs7QUFDQSxXQUFLb0csSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQTNCLEdBQWtEd2YsT0FBbEQsQ0FBMEQsVUFBQTVRLElBQUksRUFBSTtBQUM5RCxZQUFJLENBQUUsT0FBTytvQixRQUFQLENBQWdCL29CLElBQUksQ0FBQ3BOLFFBQUwsR0FBZ0IsQ0FBaEIsQ0FBaEIsQ0FBTixFQUE0QztBQUN4QytNLGVBQUssQ0FBQ0ssSUFBSSxDQUFDcE4sUUFBTCxFQUFELENBQUwsR0FBeUJvMkIsK0RBQWdCLENBQUNocEIsSUFBSSxDQUFDZ0MsUUFBTCxFQUFELENBQXpDO0FBQ0g7QUFDSixPQUpELEVBTGlCLENBVWpCOztBQUNBLFdBQUttRixJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUEzQixHQUF3Q3VlLE9BQXhDLENBQWdELFVBQUE1USxJQUFJLEVBQUk7QUFDcERMLGFBQUssQ0FBQ0ssSUFBSSxDQUFDcE4sUUFBTCxFQUFELENBQUwsR0FBeUJvTixJQUFJLENBQUNnQyxRQUFMLEVBQXpCO0FBQ0gsT0FGRDtBQUdBLGFBQU9yQyxLQUFQO0FBQ0g7QUFyRUw7QUFBQTtBQUFBLHNDQXVFc0I7QUFDZCxlQUFTc3BCLEtBQVQsQ0FBZXIyQixRQUFmLEVBQXlCO0FBQ3JCQSxnQkFBUSxHQUFHbzJCLCtEQUFnQixDQUFDcDJCLFFBQUQsQ0FBM0I7O0FBQ0EsWUFBSUEsUUFBUSxDQUFDaXNCLFFBQVQsQ0FBa0IsS0FBbEIsQ0FBSixFQUE4QjtBQUMxQmpzQixrQkFBUSxHQUFHQSxRQUFRLENBQUM0TyxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFDLENBQW5CLENBQVg7QUFDSDs7QUFDRCxlQUFPNU8sUUFBUDtBQUNIOztBQUNELGNBQ0ksVUFESixFQUVJLGFBRkosNEJBR08sS0FBS3VVLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUEzQixHQUFrRHlRLEdBQWxELENBQXNELFVBQUE3QixJQUFJO0FBQUEsZUFBSSxpQkFBaUJpcEIsS0FBSyxDQUFDanBCLElBQUksQ0FBQ3BOLFFBQUwsRUFBRCxDQUExQjtBQUFBLE9BQTFELENBSFAsc0JBSU8sS0FBS3VVLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnlELFVBQTNCLEdBQXdDd1AsR0FBeEMsQ0FBNEMsVUFBQTdCLElBQUk7QUFBQSxlQUFJaXBCLEtBQUssQ0FBQ2pwQixJQUFJLENBQUNwTixRQUFMLEVBQUQsQ0FBVDtBQUFBLE9BQWhELENBSlA7QUFNSDtBQXJGTDtBQUFBO0FBQUEscUNBdUZxQmd6QixXQXZGckIsRUF1RmtDO0FBQzFCLFVBQUlBLFdBQUosRUFBaUI7QUFDYixlQUFPLHNOQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyx1SkFBUDtBQUNIO0FBQ0o7QUE3Rkw7QUFBQTtBQUFBLDZCQStGYWh6QixRQS9GYixFQStGdUI7QUFDZixVQUFJczJCLEtBQUssR0FBRyxLQUFLL2hCLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3d2QixhQUFoQyxDQUE4Q3YyQixRQUE5QyxFQUF3RCxLQUF4RCxDQUFaOztBQUNBLFVBQUlzMkIsS0FBSyxLQUFLcDZCLFNBQWQsRUFBeUI7QUFDckIsY0FBTSxJQUFJaVksRUFBRSxDQUFDOGYsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixxQkFBbUJ4MkIsUUFBMUMsQ0FBTjtBQUNILE9BRkQsTUFFTztBQUNILGVBQU9zMkIsS0FBSyxDQUFDbG5CLFFBQU4sRUFBUDtBQUNIO0FBQ0o7QUF0R0w7QUFBQTtBQUFBLCtCQXdHZXBQLFFBeEdmLEVBd0d5QjtBQUNqQixVQUFJQSxRQUFRLEtBQUssYUFBakIsRUFBZ0M7QUFDNUIsZUFBTyxLQUFLdVUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCdUQsSUFBM0IsRUFBUDtBQUNILE9BRkQsTUFFTyxJQUFJUyxRQUFRLEtBQUsseUJBQWpCLEVBQTRDO0FBQy9DLGVBQU8sS0FBS3VVLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNDLEtBQTNCLEVBQVA7QUFDSCxPQUZNLE1BRUEsSUFBSTJCLFFBQVEsS0FBSywwQkFBakIsRUFBNkM7QUFDaEQsZUFBTyxLQUFLdVUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCd0MsTUFBM0IsTUFBdUMsRUFBOUM7QUFDSCxPQUZNLE1BRUEsSUFBSXlCLFFBQVEsS0FBSywyQkFBakIsRUFBOEM7QUFDakQsZUFBTyt4QiwrREFBUDtBQUNILE9BRk0sTUFFQSxJQUFJNWQsRUFBRSxDQUFDQyxZQUFILEtBQW9CbFksU0FBeEIsRUFBbUM7QUFDdEMsY0FBTSxJQUFJaVksRUFBRSxDQUFDOGYsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixrQ0FBdkIsQ0FBTjtBQUNILE9BRk0sTUFFQSxJQUFJcmlCLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QnBVLFFBQXpCLE1BQXVDOUQsU0FBM0MsRUFBc0Q7QUFDekQsZUFBT2lZLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QnBVLFFBQXpCLENBQVA7QUFDSCxPQUZNLE1BRUE7QUFDSCxZQUFJczJCLEtBQUssR0FBRyxLQUFLL2hCLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJpQixVQUFyQixDQUFnQ3d2QixhQUFoQyxDQUE4Q3YyQixRQUE5QyxFQUF3RCxLQUF4RCxDQUFaOztBQUNBLFlBQUlzMkIsS0FBSyxLQUFLcDZCLFNBQWQsRUFBeUI7QUFDckIsZ0JBQU0sSUFBSWlZLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3VDLE9BQWYsQ0FBdUIsc0JBQW9CeDJCLFFBQXBCLEdBQStCLEdBQXRELENBQU47QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBT3MyQixLQUFLLENBQUNsbkIsUUFBTixFQUFQO0FBQ0g7QUFDSjtBQUNKO0FBN0hMO0FBQUE7QUFBQSwwQkErSFUrSixhQS9IVixFQStIeUI7QUFDakI7QUFDQXZTLGFBQU8sQ0FBQ29OLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLEtBQUtPLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkcsS0FBMUIsRUFBbkIsRUFBc0QsS0FBS3lRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsRUFBdEQ7O0FBQ0EsVUFBSSxLQUFLd1EsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCSSxVQUExQixLQUF5QyxLQUFLd1EsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCRyxLQUExQixHQUFrQ3VKLE1BQS9FLEVBQXVGO0FBQ25GLFlBQUl0SixVQUFVLEdBQUcsS0FBS3dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsRUFBakI7QUFDQSxZQUFJMHlCLFNBQVMsR0FBRyxLQUFLbGlCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NDLFVBQWxDLENBQWhCO0FBQ0EsYUFBS3dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkksVUFBMUIsQ0FBcUNBLFVBQVUsR0FBQyxDQUFoRDtBQUNBLGVBQU8weUIsU0FBUDtBQUNILE9BTEQsTUFLTztBQUNILGVBQU8sVUFBUDtBQUNIO0FBQ0Q7Ozs7QUFHSDtBQTdJTDtBQUFBO0FBQUEsK0JBK0llakMsWUEvSWYsRUErSTZCQyxPQS9JN0IsRUErSXNDQyxNQS9JdEMsRUErSThDO0FBQ3RDLFVBQUlDLFlBQVksR0FBRyxLQUFLcGdCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0NJLE9BQXJELENBRHNDLENBRXRDOztBQUNBLFVBQUkyd0IsWUFBWSxDQUFDckUsT0FBYixJQUF3QnFFLFlBQVksQ0FBQ3JFLE9BQWIsQ0FBcUJqakIsTUFBakQsRUFBeUQ7QUFDckQsZ0dBQWlCbW5CLFlBQWpCLEVBQStCQyxPQUEvQixFQUF3Q0MsTUFBeEM7QUFDSDtBQUNKO0FBckpMOztBQUFBO0FBQUEsRUFBNkMxQyxnRUFBN0MsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUVPLElBQU1qQyxxQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1E1bEIsTUFEUixFQUNnQjtBQUNSLHFGQUFVQSxNQUFWOztBQUNBLFdBQUtuSyxRQUFMLEdBQWdCLGNBQWhCO0FBQ0EsV0FBS1QsSUFBTCxHQUFZLEtBQUtnVixJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ1QyxRQUEzQixFQUFaO0FBRUFvNEIsa0JBQVksQ0FBQyxLQUFLbmlCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3Qm1CLGVBQXpCLENBQVo7QUFFQSxhQUFPLElBQVA7QUFDSDtBQVRMOztBQUFBO0FBQUEsRUFBMkN3MEIsbUVBQTNDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHTyxJQUFNaUIsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFVQyxXQUFWLEVBQXVCQyxjQUF2QixFQUF1Q0MsS0FBdkMsRUFBOENDLE1BQTlDLEVBQXNEO0FBQ3RGLE1BQUlDLFFBQVEsR0FBR3RwQixJQUFJLENBQUNDLFNBQUwsQ0FBZWlwQixXQUFmLENBQWY7QUFFQSwwa0JBa0I2Q0ksUUFsQjdDLHdCQW1CT0EsUUFuQlAseUxBMEJGQyx5REExQkUsZUEyQkZKLGNBM0JFO0FBZ0VILENBbkVNO0FBcUVBLElBQU03RyxtQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1E3bEIsTUFEUixFQUNnQjtBQUNSLG1GQUFVQSxNQUFWOztBQUNBLFdBQUtuSyxRQUFMLEdBQWdCLHFCQUFoQjtBQUNBLFdBQUtULElBQUwsR0FBWSxLQUFLZ1YsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCd0MsTUFBM0IsTUFBdUMsRUFBbkQ7QUFFQSxVQUFJMjRCLFdBQVcsR0FBRyxLQUFLM2lCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9DNjNCLFdBQXBDLEVBQWxCO0FBRUEsVUFBSTdHLE1BQU0sR0FBRyxLQUFLOWIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCQyxPQUF2QyxDQVBRLENBUVI7O0FBQ0EsVUFBSXV6QixZQUFZLEdBQUcsS0FBS0Msa0JBQUwsRUFBbkI7QUFDQUQsa0JBQVksQ0FBQyxZQUFELENBQVosR0FBNkIsS0FBSzVpQixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDSSxPQUFsQyxDQUEwQ3F6QixVQUExQyxJQUF3RCxNQUFyRjtBQUNBLFdBQUtDLGVBQUw7QUFDQSxVQUFJVCxjQUFjLEdBQUcsS0FBS3QzQixJQUExQjtBQUNBLFVBQUl3M0IsTUFBTSxHQUFHLENBQUMxRyxNQUFNLENBQUMsUUFBRCxDQUFOLENBQWlCalYsS0FBbEIsSUFBMkJpVixNQUFNLENBQUMsVUFBRCxDQUFOLENBQW1CdmYsT0FBM0Q7QUFDQStsQixvQkFBYyxHQUFHRixvQkFBb0IsQ0FBQ1EsWUFBRCxFQUFlTixjQUFmLEVBQStCSyxXQUEvQixFQUE0Q0gsTUFBNUMsQ0FBckM7QUFDQW53QixhQUFPLENBQUNvTixHQUFSLENBQVksS0FBWixFQUFtQjZpQixjQUFuQjtBQUNBLFVBQUlVLFVBQVUsR0FBR0MsMEVBQTBCLENBQUNYLGNBQUQsQ0FBM0MsQ0FoQlEsQ0FnQnFEOztBQUM3RHhHLFlBQU0sQ0FBQyxZQUFELENBQU4sR0FBdUI7QUFDbkIsdUJBQWUsRUFESTtBQUVuQixvQkFBWSwwQkFGTztBQUduQixnQkFBUXdHLGNBSFc7QUFJbkIsc0JBQWNVLFVBSkssQ0FLbkI7O0FBTG1CLE9BQXZCO0FBT0EsV0FBS2g0QixJQUFMLEdBQVlzM0IsY0FBWjs7QUFFQSxtRkFBVTFzQixNQUFWLEVBMUJRLENBNEJSOzs7QUFDQWdLLFFBQUUsQ0FBQzNQLE9BQUgsR0FBYSxLQUFLK1AsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCMUQsVUFBMUIsQ0FBcUN1RSxPQUFsRDtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBakNMO0FBQUE7QUFBQSw0QkFtQ1ltdEIsTUFuQ1osRUFtQ29CO0FBQ1ovcUIsYUFBTyxDQUFDb04sR0FBUixDQUFZLGdCQUFaLEVBRFksQ0FFWjs7QUFDQSxXQUFLTyxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEIxRCxVQUExQixDQUFxQ3VFLE9BQXJDLEdBQStDMlAsRUFBRSxDQUFDM1AsT0FBbEQ7QUFDQSxXQUFLK1AsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCMUQsVUFBMUIsQ0FBcUN5RSxVQUFyQyxHQUFrRHlQLEVBQUUsQ0FBQ3pQLFVBQXJEO0FBQ0FrQyxhQUFPLENBQUNvTixHQUFSLENBQVkyZCxNQUFaO0FBQ0EsVUFBSXB0QixPQUFPLEdBQUdvdEIsTUFBTSxDQUFDRyxFQUFQLENBQVV2cUIsT0FBVixDQUFrQnVxQixFQUFoQztBQUNBbHJCLGFBQU8sQ0FBQ29OLEdBQVIsQ0FBWTJkLE1BQU0sQ0FBQ0csRUFBbkI7QUFDQSxXQUFLdmQsSUFBTCxDQUFVek8sVUFBVixDQUFxQm5CLFFBQXJCLENBQThCa3RCLGVBQTlCLENBQThDdHRCLE9BQTlDO0FBQ0EsV0FBS2dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0MsWUFBbEMsRUFBZ0QsU0FBaEQsSUFBNkQsSUFBN0Q7QUFDQSxVQUFJa04sT0FBTyxHQUFHcUQsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQnp3QixPQUFPLENBQUNrekIsT0FBekIsQ0FBZDtBQUNBLFdBQUtsakIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCNEQsT0FBM0IsQ0FBbUNrUixPQUFPLElBQUksS0FBS3lELElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjRELE9BQTNCLEVBQTlDLEVBWFksQ0FZWjs7QUFDQSxVQUFJRCxLQUFLLEdBQUd3VSxFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCendCLE9BQU8sQ0FBQ216QixLQUF6QixDQUFaO0FBQ0EvM0IsV0FBSyxHQUFHOE0sSUFBSSxDQUFDQyxHQUFMLENBQVMsR0FBVCxFQUFjRCxJQUFJLENBQUNJLEdBQUwsQ0FBUyxHQUFULEVBQWNsTixLQUFkLENBQWQsQ0FBUjtBQUNBLFVBQUlnNEIsUUFBUSxHQUFHLEtBQUtwakIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMkQsS0FBM0IsRUFBZjtBQUNBLFdBQUs0VSxJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkIyRCxLQUEzQixDQUFpQzhNLElBQUksQ0FBQ0MsR0FBTCxDQUFTaXJCLFFBQVQsRUFBbUJoNEIsS0FBbkIsQ0FBakMsRUFoQlksQ0FpQlo7O0FBQ0EsVUFBSTRWLElBQUksR0FBR3BCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUJ6d0IsT0FBTyxDQUFDcXpCLElBQXpCLENBQVgsQ0FsQlksQ0FtQlo7O0FBQ0EsV0FBS3JqQixJQUFMLENBQVV6TyxVQUFWLENBQXFCQyxNQUFyQixDQUE0Qi9DLGdCQUE1QixDQUE2Q3JELEtBQTdDLEVBQW9EbVIsT0FBcEQsRUFBNkR5RSxJQUE3RCxFQUFtRSxLQUFuRTtBQUNBLFdBQUtoQixJQUFMLENBQVVuWCxLQUFWLENBQWdCeUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUNDLEtBQS9DLEVBckJZLENBc0JaOztBQUVBOzs7O0FBSUEsVUFBSSxDQUFDbVMsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IzeEIsVUFBcEIsQ0FBK0I0M0IsU0FBcEMsRUFBK0M7QUFDM0MsWUFBSTtBQUNBLGVBQUt0akIsSUFBTCxDQUFVek8sVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJreEIsY0FBN0I7QUFDSCxTQUZELENBRUUsT0FBT3RrQixDQUFQLEVBQVUsQ0FDWDtBQUNKO0FBQ0o7QUFyRUw7QUFBQTtBQUFBLDRCQXVFWW1MLEtBdkVaLEVBdUVtQjtBQUNYL1gsYUFBTyxDQUFDb04sR0FBUixDQUFZLGdCQUFaLEVBQThCMkssS0FBOUI7QUFDQSxVQUFJMFIsTUFBTSxHQUFHLEtBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQXZDOztBQUNBLFVBQUkrYSxLQUFLLENBQUNvWixPQUFOLEtBQWtCLGNBQXRCLEVBQXNDO0FBQ2xDMUgsY0FBTSxDQUFDLFlBQUQsQ0FBTixDQUFxQixTQUFyQixJQUFrQyxJQUFsQztBQUNBLGFBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCeUUsTUFBaEIsQ0FBdUI2QixXQUF2QixDQUFtQzNCLG1EQUFXLENBQUNDLEtBQS9DO0FBQ0gsT0FIRCxNQUdPO0FBQ0gsYUFBS3VTLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ3dxQixNQUEvQyxFQURHLENBRUg7O0FBQ0EsYUFBS2hZLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJuQixRQUFyQixDQUE4QnF6QixvQkFBOUIsQ0FBbURyWixLQUFuRCxFQUEwRCxLQUFLM2UsUUFBL0QsRUFIRyxDQUlIO0FBQ0E7QUFDQTtBQUNILE9BYlUsQ0FjWDs7QUFDSDtBQXRGTDs7QUFBQTtBQUFBLEVBQXlDMDFCLG1FQUF6QyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFFTyxTQUFTOEIsMEJBQVQsQ0FBb0NYLGNBQXBDLEVBQW9EO0FBQ3ZELE1BQU05a0IsS0FBSyxHQUFHOGtCLGNBQWMsQ0FBQ3JuQixPQUFmLENBQXVCeW5CLGlCQUF2QixDQUFkO0FBQ0EsTUFBTWdCLE1BQU0sR0FBR3BCLGNBQWMsQ0FBQ2pvQixLQUFmLENBQXFCLENBQXJCLEVBQXdCbUQsS0FBeEIsQ0FBZjtBQUNBLE1BQU1tbUIsS0FBSyxHQUFHRCxNQUFNLENBQUNDLEtBQVAsQ0FBYUMsY0FBYixDQUFkO0FBQ0EsU0FBT0QsS0FBSyxHQUFJLElBQUVBLEtBQUssQ0FBQzdxQixNQUFaLEdBQXNCLENBQWxDO0FBQ0g7QUFFTSxJQUFNNHBCLGlCQUFpQixHQUFHLHNDQUExQjtBQUNBLElBQU1rQixjQUFjLEdBQUcsS0FBdkI7QUFDUDs7OztBQUdPLElBQU14QixvQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLENBQVVRLFlBQVYsRUFBd0JOLGNBQXhCLEVBQXdDQyxLQUF4QyxFQUErQ0MsTUFBL0MsRUFBdUQ7QUFDdkYsTUFBSUMsUUFBUSxHQUFHdHBCLElBQUksQ0FBQ0MsU0FBTCxDQUFld3BCLFlBQWYsQ0FBZjtBQUNBLE1BQUlpQixTQUFTLEdBQUd0QixLQUFLLEdBQUcsTUFBSCxHQUFXLE9BQWhDLENBRnVGLENBSXZGOztBQUVBLDAwQkF5QmtDc0IsU0F6QmxDLDBMQTZCOEJwQixRQTdCOUIsOE1BcUNGQyxpQkFyQ0UsZUFzQ0ZKLGNBdENFO0FBMkVILENBakZNO0FBbUZBLElBQU0vRyxrQkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBQ1EzbEIsTUFEUixFQUNnQjtBQUNSLGtGQUFVQSxNQUFWOztBQUNBLFdBQUtuSyxRQUFMLEdBQWdCLG9CQUFoQjtBQUNBLFdBQUtULElBQUwsR0FBWSxLQUFLZ1YsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0MsS0FBM0IsRUFBWjtBQUVBLFVBQUk2NEIsV0FBVyxHQUFHLEtBQUszaUIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0M2M0IsV0FBcEMsRUFBbEIsQ0FMUSxDQU1SOztBQUNBLFdBQUszaUIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCSSxVQUExQixDQUFxQyxDQUFyQztBQUVBLFVBQUlzc0IsTUFBTSxHQUFHLEtBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQXZDLENBVFEsQ0FVUjs7QUFDQSxVQUFJdXpCLFlBQVksR0FBRyxLQUFLQyxrQkFBTCxFQUFuQjtBQUNBLFdBQUtFLGVBQUw7QUFDQSxVQUFJVCxjQUFjLEdBQUcsS0FBS3QzQixJQUExQjtBQUNBLFVBQUl3M0IsTUFBTSxHQUFHLENBQUMxRyxNQUFNLENBQUMsUUFBRCxDQUFOLENBQWlCalYsS0FBbEIsSUFBMkJpVixNQUFNLENBQUMsVUFBRCxDQUFOLENBQW1CdmYsT0FBM0Q7QUFDQStsQixvQkFBYyxHQUFHRixvQkFBb0IsQ0FBQ1EsWUFBRCxFQUFlTixjQUFmLEVBQStCSyxXQUEvQixFQUE0Q0gsTUFBNUMsQ0FBckM7QUFDQSxVQUFJUSxVQUFVLEdBQUdDLDBCQUEwQixDQUFDWCxjQUFELENBQTNDLENBaEJRLENBZ0JxRDtBQUM3RDs7QUFDQXhHLFlBQU0sQ0FBQyxZQUFELENBQU4sR0FBdUI7QUFDbkIsdUJBQWUsRUFESTtBQUVuQixvQkFBWSx5QkFGTztBQUduQixnQkFBUXdHLGNBSFc7QUFJbkIsc0JBQWNVLFVBSkssQ0FLbkI7O0FBTG1CLE9BQXZCO0FBUUEsV0FBS2g0QixJQUFMLEdBQVlzM0IsY0FBWjtBQUVBMWlCLFFBQUUsQ0FBQzJmLGFBQUgsR0FBbUIsS0FBbkI7QUFFQSxhQUFPLElBQVA7QUFDSDtBQWhDTDtBQUFBO0FBQUEsNEJBa0NZbkMsTUFsQ1osRUFrQ29CO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBS3BkLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQjFELFVBQTFCLENBQXFDdUUsT0FBckMsR0FBK0MyUCxFQUFFLENBQUMzUCxPQUFsRDtBQUNBLFdBQUsrUCxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEIxRCxVQUExQixDQUFxQ3lFLFVBQXJDLEdBQWtEeVAsRUFBRSxDQUFDelAsVUFBckQ7QUFDQXlQLFFBQUUsQ0FBQzNQLE9BQUgsR0FBYSxFQUFiO0FBQ0EsVUFBSUQsT0FBTyxHQUFHb3RCLE1BQU0sQ0FBQ0csRUFBUCxDQUFVdHFCLE1BQVYsQ0FBaUJzcUIsRUFBL0I7QUFDQSxXQUFLdmQsSUFBTCxDQUFVek8sVUFBVixDQUFxQm5CLFFBQXJCLENBQThCa3RCLGVBQTlCLENBQThDdHRCLE9BQTlDO0FBQ0EsV0FBS2dRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBMUIsQ0FBa0MsWUFBbEMsRUFBZ0QsU0FBaEQsSUFBNkQsSUFBN0Q7QUFDQSxVQUFJa04sT0FBTyxHQUFHcUQsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQnp3QixPQUFPLENBQUNrekIsT0FBekIsQ0FBZDtBQUNBLFdBQUtsakIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCNEQsT0FBM0IsQ0FBbUNrUixPQUFPLElBQUksS0FBS3lELElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQjRELE9BQTNCLEVBQTlDLEVBWFksQ0FZWjs7QUFDQSxVQUFJRCxLQUFLLEdBQUd3VSxFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCendCLE9BQU8sQ0FBQ216QixLQUF6QixDQUFaO0FBQ0EvM0IsV0FBSyxHQUFHOE0sSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZRCxJQUFJLENBQUNJLEdBQUwsQ0FBUyxDQUFULEVBQVlsTixLQUFaLENBQVosQ0FBUjtBQUNBLFVBQUlnNEIsUUFBUSxHQUFHLEtBQUtwakIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMkQsS0FBM0IsRUFBZjtBQUNBQSxXQUFLLEdBQUc4TSxJQUFJLENBQUNDLEdBQUwsQ0FBU2lyQixRQUFULEVBQW1CaDRCLEtBQW5CLENBQVI7QUFDQSxXQUFLNFUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnBCLFVBQWhCLENBQTJCMkQsS0FBM0IsQ0FBaUNBLEtBQWpDLEVBakJZLENBa0JaOztBQUNBLFVBQUk0VixJQUFJLEdBQUdwQixFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCendCLE9BQU8sQ0FBQ3F6QixJQUF6QixDQUFYLENBbkJZLENBb0JaOztBQUNBLFdBQUtyakIsSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEIvQyxnQkFBNUIsQ0FBNkNyRCxLQUE3QyxFQUFvRG1SLE9BQXBELEVBQTZEeUUsSUFBN0QsRUFBbUUsS0FBbkU7QUFDQSxXQUFLaEIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnlFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDQyxLQUEvQyxFQXRCWSxDQXVCWjs7QUFFQTs7OztBQUlBLFVBQUksQ0FBQ21TLEVBQUUsQ0FBQ3lkLGdCQUFILENBQW9CM3hCLFVBQXBCLENBQStCNDNCLFNBQXBDLEVBQStDO0FBQzNDLFlBQUk7QUFDQSxlQUFLdGpCLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCa3hCLGNBQTdCO0FBQ0gsU0FGRCxDQUVFLE9BQU90a0IsQ0FBUCxFQUFVLENBQ1g7QUFDSjtBQUNKO0FBckVMO0FBQUE7QUFBQSw0QkF1RVltTCxLQXZFWixFQXVFbUI7QUFDWC9YLGFBQU8sQ0FBQytYLEtBQVIsQ0FBYyxlQUFkLEVBQStCQSxLQUEvQjtBQUNBLFVBQUkwUixNQUFNLEdBQUcsS0FBSzliLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSSthLEtBQUssQ0FBQ29aLE9BQU4sS0FBa0IsY0FBdEIsRUFBc0M7QUFDbEMxSCxjQUFNLENBQUMsWUFBRCxDQUFOLENBQXFCLFNBQXJCLElBQWtDLElBQWxDO0FBQ0EsYUFBSzliLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ0MsS0FBL0M7QUFDSCxPQUhELE1BR087QUFDSCxhQUFLdVMsSUFBTCxDQUFVblgsS0FBVixDQUFnQnlFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDd3FCLE1BQS9DLEVBREcsQ0FFSDs7QUFDQSxhQUFLaFksSUFBTCxDQUFVek8sVUFBVixDQUFxQm5CLFFBQXJCLENBQThCcXpCLG9CQUE5QixDQUFtRHJaLEtBQW5ELEVBQTBELEtBQUszZSxRQUEvRCxFQUhHLENBSUg7QUFDQTtBQUNBO0FBQ0gsT0FiVSxDQWNYOztBQUNIO0FBdEZMOztBQUFBO0FBQUEsRUFBd0MwMUIsbUVBQXhDO0FBMEZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TEE7QUFFTyxJQUFNMkMscUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRbHVCLE1BRFIsRUFDZ0I7QUFDUixxRkFBVUEsTUFBVjs7QUFDQSxXQUFLbkssUUFBTCxHQUFnQixXQUFoQjtBQUNBLFdBQUtULElBQUwsR0FBWSxLQUFLZ1YsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0MsS0FBM0IsRUFBWjtBQUVBLGFBQU8sSUFBUDtBQUNIO0FBUEw7O0FBQUE7QUFBQSxFQUEyQ3l4QiwwREFBM0MsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUVPLElBQU1ILGdCQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSx3QkFDUXhsQixNQURSLEVBQ2dCO0FBQ1IsV0FBS29LLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DQyxPQUFuQyxDQUEyQyxZQUEzQztBQUNBLFdBQUs1RSxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsV0FBS1QsSUFBTCxHQUFZLEtBQUtnVixJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJ3RSxLQUFuQixDQUF5Qm9CLGNBQXpCLEVBQVo7O0FBQ0EsVUFBSSxLQUFLb0csSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0NpNUIsaUJBQXBDLEVBQUosRUFBNkQ7QUFDekQsYUFBSy80QixJQUFMLEdBQVksRUFBWjtBQUNILE9BTk8sQ0FPUjs7O0FBQ0EsV0FBS2dWLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCbkQsUUFBNUIsQ0FBcUMsV0FBckMsRUFBa0QsS0FBSzJSLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLEVBQWxELEVBQXFGLElBQXJGO0FBQ0EsV0FBS2dWLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsU0FBckMsRUFBZ0QsRUFBaEQsRUFBb0QsRUFBcEQsRUFBd0QsRUFBeEQsRUFBNEQsV0FBNUQsRUFUUSxDQVVSOztBQUNBLGdGQUFVMkgsTUFBVjs7QUFFQUEsWUFBTSxDQUFDcEIsS0FBUDtBQUNBLFdBQUswb0IsV0FBTDtBQUVBLFdBQUtsZCxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDLFVBQWxDLElBQWdEO0FBQzVDLG1CQUFXMjBCLE9BQU8sQ0FBQyxLQUFLaDVCLElBQUwsQ0FBVXVaLElBQVYsRUFBRCxDQUQwQjtBQUU1QyxnQkFBUSxLQUFLdlo7QUFGK0IsT0FBaEQ7O0FBS0EsVUFBSSxPQUFPNFUsRUFBRSxDQUFDcWtCLE9BQVYsSUFBcUIsV0FBekIsRUFBc0M7QUFDbENya0IsVUFBRSxDQUFDcWtCLE9BQUgsR0FBYSxJQUFJcmtCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3dFLElBQWYsRUFBYjtBQUNIOztBQUNELFVBQU05ZCxVQUFVLEdBQUcsS0FBS3BHLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJjLE9BQXJCLENBQTZCK1QsVUFBaEQ7QUFBQSxVQUNJaFEsS0FBSyxHQUFHZ1EsVUFBVSxDQUFDaFEsS0FBWCxLQUFtQixFQUQvQjtBQUFBLFVBRUlvUSxNQUFNLEdBQUd0TyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxHQUFULEVBQWNpTyxVQUFVLENBQUNJLE1BQVgsS0FBb0IsRUFBbEMsQ0FGYjtBQUdBNUcsUUFBRSxDQUFDcWtCLE9BQUgsQ0FBV0UsUUFBWCxDQUFvQixJQUFJdmtCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV2dDLEdBQWYsQ0FBbUIsdUJBQW5CLENBQXBCLEVBQWlFLElBQUk5aEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMEUsSUFBZixDQUFvQmh1QixLQUFwQixDQUFqRTtBQUNBd0osUUFBRSxDQUFDcWtCLE9BQUgsQ0FBV0UsUUFBWCxDQUFvQixJQUFJdmtCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV2dDLEdBQWYsQ0FBbUIsd0JBQW5CLENBQXBCLEVBQWtFLElBQUk5aEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMEUsSUFBZixDQUFvQjVkLE1BQXBCLENBQWxFO0FBRUE1RyxRQUFFLENBQUMyZixhQUFILEdBQW1CLEtBQW5CO0FBRUEsV0FBSzhFLFVBQUw7QUFFQSxhQUFPLElBQVA7QUFDSDtBQXBDTDtBQUFBO0FBQUEsNEJBc0NZakgsTUF0Q1osRUFzQ29CO0FBQUE7O0FBQ1ovcUIsYUFBTyxDQUFDb04sR0FBUixDQUFZLGFBQVo7QUFDQSxVQUFJcFAsT0FBTyxHQUFHO0FBQ1Ysa0JBQVUsS0FBSzJQLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkcsS0FBMUIsR0FBa0NvZSxJQUFsQyxDQUF1QyxJQUF2QyxDQURBO0FBRVYsbUJBQVcsS0FBSzNOLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkUsTUFBMUIsR0FBbUNvTCxHQUFuQyxDQUF1QyxVQUFBOUMsSUFBSTtBQUFBLGlCQUFJQSxJQUFJLENBQUM4SyxPQUFUO0FBQUEsU0FBM0MsRUFBNkRpTCxJQUE3RCxDQUFrRSxJQUFsRTtBQUZELE9BQWQ7QUFJQSxXQUFLM04sSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ2RCxRQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxFQUFwRCxFQUF3RCxFQUF4RCxFQUE0RGtMLElBQUksQ0FBQ0MsU0FBTCxDQUFlL0ksT0FBZixDQUE1RCxFQUFxRixXQUFyRjtBQUNBLFdBQUsyUCxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JvQixlQUF4QixDQUF3QyxLQUF4QztBQUNBLFdBQUtvVCxJQUFMLENBQVV6TyxVQUFWLENBQXFCYyxPQUFyQixDQUE2Qml5QixhQUE3QjtBQUNBLFdBQUt0a0IsSUFBTCxDQUFVblgsS0FBVixDQUFnQnlFLE1BQWhCLENBQXVCNkIsV0FBdkIsQ0FBbUMzQixtREFBVyxDQUFDQyxLQUEvQztBQUNBLFdBQUt1UyxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDUSxPQUFsQyxDQUEwQzJQLEVBQUUsQ0FBQzNQLE9BQTdDO0FBQ0EyUCxRQUFFLENBQUMzUCxPQUFILEdBQWEsRUFBYjtBQUNBLFVBQUk2ckIsTUFBTSxHQUFHLEtBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsVUFBSTVELFFBQVEsR0FBRyxLQUFLQSxRQUFwQjtBQUNBLFdBQUt1VSxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJLLE9BQTFCLENBQWtDTyxPQUFsQyxHQUE0Q290QixNQUE1Qzs7QUFDQSxVQUFJLENBQUMsS0FBS3BkLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQTNCLENBQW9Dc00sWUFBcEMsRUFBTCxFQUF5RDtBQUNyRCxhQUFLNEksSUFBTCxDQUFVek8sVUFBVixDQUFxQmMsT0FBckIsQ0FBNkJreUIsU0FBN0I7QUFDSDs7QUFDRCxhQUFPLElBQUlqZixPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVNFAsTUFBVixFQUFxQjtBQUNwQyxhQUFJLENBQUN6ZCxJQUFMLENBQVUwbEIsTUFBTSxDQUFDRyxFQUFqQixFQUFxQkgsTUFBTSxDQUFDRyxFQUE1QixFQUErQixDQUFDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDOXhCLFFBQVEsR0FBRyxLQUFqRDs7QUFDQSxhQUFJLENBQUNrRSxRQUFMOztBQUNBbXNCLGNBQU0sQ0FBQyxTQUFELENBQU4sR0FBb0I7QUFDaEIscUJBQVcsSUFESztBQUVoQixtQkFBUyxLQUFJLENBQUNsbUIsTUFBTCxDQUFZaU4sZUFBWixDQUE0QnJMLEtBRnJCO0FBR2hCLG1CQUFTLEtBQUksQ0FBQzVCLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJyTCxLQUE1QixDQUFrQ2tELEdBQWxDLENBQXNDLFVBQUFrbUIsQ0FBQztBQUFBLG1CQUFJQSxDQUFDLENBQUNocEIsSUFBTjtBQUFBLFdBQXZDLENBSE87QUFJaEIsdUJBQWEsS0FBSSxDQUFDaEMsTUFBTCxDQUFZaU4sZUFBWixDQUE0QnJMLEtBQTVCLENBQWtDNlksTUFBbEMsQ0FBeUMsVUFBQXVRLENBQUM7QUFBQSxtQkFBSSxDQUFDQSxDQUFDLENBQUNDLFdBQVA7QUFBQSxXQUExQyxFQUE4RG5tQixHQUE5RCxDQUFrRSxVQUFBa21CLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDaHBCLElBQU47QUFBQSxXQUFuRSxDQUpHO0FBS2hCLHFCQUFXd2xCLE1BTEs7QUFNaEIsb0JBQVUsS0FBSSxDQUFDcGQsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCRSxNQU5wQjtBQU9oQixtQkFBUyxLQUFJLENBQUMwUSxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJHLEtBUG5CO0FBUWhCLG1CQUFTLEtBQUksQ0FBQ3lRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NTLEtBUjNCO0FBU2hCLHFCQUFXO0FBVEssU0FBcEI7QUFXQXFWLGVBQU87QUFDVixPQWZNLENBQVA7QUFnQkg7QUF4RUw7QUFBQTtBQUFBLDRCQTBFWTZFLEtBMUVaLEVBMEVtQjtBQUFBOztBQUNYL1gsYUFBTyxDQUFDK1gsS0FBUixDQUFjLGFBQWQsRUFBNkJBLEtBQTdCO0FBQ0EsV0FBS3BLLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J5RSxNQUFoQixDQUF1QjZCLFdBQXZCLENBQW1DM0IsbURBQVcsQ0FBQ3dxQixNQUEvQztBQUNBLFVBQUk4RCxNQUFNLEdBQUcsS0FBSzliLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBdkM7O0FBQ0EsVUFBSXlzQixNQUFNLENBQUMwSSxNQUFQLENBQWNqb0IsT0FBZCxJQUF5QnVmLE1BQU0sQ0FBQzJJLFFBQVAsQ0FBZ0Jsb0IsT0FBN0MsRUFBc0Q7QUFDbEQsYUFBS3lELElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsZUFBckMsRUFBc0QsRUFBdEQsRUFBMEQsRUFBMUQsRUFBOERtYyxLQUFLLENBQUNqZCxRQUFOLEVBQTlELEVBQWdGLFdBQWhGO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBSzZTLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJDLE1BQXJCLENBQTRCdkQsUUFBNUIsQ0FBcUMsYUFBckMsRUFBb0Qsb0JBQXBELEVBQTBFLEVBQTFFLEVBQThFbWMsS0FBSyxDQUFDamQsUUFBTixFQUE5RSxFQUFnRyxXQUFoRztBQUNIOztBQUNELGFBQU8sSUFBSW1ZLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVU0UCxNQUFWLEVBQXFCO0FBQ3BDMkcsY0FBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQjtBQUNoQixxQkFBVyxLQURLO0FBRWhCLG1CQUFTMVIsS0FGTztBQUdoQixtQkFBUyxNQUFJLENBQUN4VSxNQUFMLENBQVlpTixlQUFaLENBQTRCckwsS0FBNUIsQ0FBa0NrRCxHQUFsQyxDQUFzQyxVQUFBa21CLENBQUM7QUFBQSxtQkFBSUEsQ0FBQyxDQUFDaHBCLElBQU47QUFBQSxXQUF2QyxDQUhPO0FBSWhCLHVCQUFhLE1BQUksQ0FBQ2hDLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJyTCxLQUE1QixDQUFrQzZZLE1BQWxDLENBQXlDLFVBQUF1USxDQUFDO0FBQUEsbUJBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxXQUFQO0FBQUEsV0FBMUMsRUFBOERubUIsR0FBOUQsQ0FBa0UsVUFBQWttQixDQUFDO0FBQUEsbUJBQUlBLENBQUMsQ0FBQ2hwQixJQUFOO0FBQUEsV0FBbkUsQ0FKRztBQUtoQixtQkFBUyxNQUFJLENBQUNvSSxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJHLEtBTG5CO0FBTWhCLG1CQUFTLE1BQUksQ0FBQ3lRLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkssT0FBMUIsQ0FBa0NTLEtBTjNCO0FBT2hCLHFCQUFXO0FBUEssU0FBcEI7QUFTQXFWLGVBQU87QUFDVixPQVhNLENBQVA7QUFZSDtBQS9GTDs7QUFBQTtBQUFBLEVBQXNDdWIsNkRBQXRDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFFTyxJQUFNNEQsbUJBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNROXVCLE1BRFIsRUFDZ0I7QUFDUixtRkFBVUEsTUFBVixFQURRLENBRVI7OztBQUNBLFdBQUtuSyxRQUFMLEdBQWdCLFdBQWhCO0FBQ0EsV0FBS1QsSUFBTCxHQUFZLHlCQUFaO0FBRUEsYUFBTyxJQUFQO0FBQ0g7QUFSTDs7QUFBQTtBQUFBLEVBQXlDODFCLDZEQUF6QyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBRU8sSUFBTUEsb0JBQWI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQUNRbHJCLE1BRFIsRUFDZ0I7QUFBQTs7QUFDUixvRkFBVUEsTUFBVixFQURRLENBRVI7OztBQUNBLFVBQUk5SyxRQUFRLEdBQUcsS0FBS2tWLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JpQyxRQUEvQjs7QUFDQThVLFFBQUUsQ0FBQzBlLGlCQUFILEdBQXVCO0FBQUEsZUFDbkIsS0FBSSxDQUFDdGUsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0QsUUFBM0IsQ0FBb0NvekIsY0FBcEMsS0FBdURLLFFBQXZELEdBQWtFLElBRC9DO0FBQUEsT0FBdkI7O0FBRUEzZSxRQUFFLENBQUNxZSxTQUFILEdBQWVyZSxFQUFFLENBQUMwZSxpQkFBSCxFQUFmLENBTlEsQ0FPUjs7QUFDQTFlLFFBQUUsQ0FBQzJnQixvQkFBSCxHQUEwQixLQUFLN29CLElBQUwsQ0FBVTJELElBQVYsQ0FBZSxJQUFmLENBQTFCLENBUlEsQ0FVUjs7QUFDQSxXQUFLMkUsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRyxXQUF4QixDQUFvQyxLQUFwQyxFQVhRLENBYVI7QUFDQTs7QUFFQWlVLFFBQUUsQ0FBQ0MsWUFBSCxDQUFnQnJILEtBQWhCLENBQXNCLDZCQUF0QixJQUF1RGdsQiw0REFBdkQ7QUFFQSxhQUFPLElBQVA7QUFDSDtBQXBCTDtBQUFBO0FBQUEsNkJBc0JhL3hCLFFBdEJiLEVBc0J1QjtBQUNmLFVBQUlzMkIsS0FBSyxHQUFHLEtBQUsvaEIsSUFBTCxDQUFVek8sVUFBVixDQUFxQmlCLFVBQXJCLENBQWdDd3ZCLGFBQWhDLENBQThDdjJCLFFBQTlDLEVBQXdELElBQXhELENBQVosQ0FEZSxDQUVmOztBQUNBLFVBQUlzMkIsS0FBSyxLQUFLcDZCLFNBQWQsRUFBeUI7QUFDckIsWUFBSWlZLEVBQUUsQ0FBQ0MsWUFBSCxJQUFtQkQsRUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCcFUsUUFBekIsTUFBdUM5RCxTQUE5RCxFQUF5RTtBQUNyRSxpQkFBT2lZLEVBQUUsQ0FBQ0MsWUFBSCxDQUFnQixPQUFoQixFQUF5QnBVLFFBQXpCLENBQVA7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBTSxJQUFJbVUsRUFBRSxDQUFDOGYsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixxQkFBcUJ4MkIsUUFBNUMsQ0FBTjtBQUNIO0FBQ0osT0FORCxNQU1PO0FBQ0gsZUFBT3MyQixLQUFLLENBQUNsbkIsUUFBTixFQUFQO0FBQ0g7QUFDSjtBQWxDTDtBQUFBO0FBQUEsK0JBb0NlcFAsUUFwQ2YsRUFvQ3lCO0FBQ2pCLFVBQUksS0FBS2s1QixXQUFMLENBQWlCbDVCLFFBQWpCLENBQUosRUFBZ0M7QUFDNUIsY0FBTSwyQkFBMkJBLFFBQTNCLEdBQXNDLEdBQTVDO0FBQ0gsT0FGRCxNQUVPLElBQUlBLFFBQVEsS0FBSyxhQUFqQixFQUFnQztBQUNuQyxlQUFPLEtBQUt1VSxJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixFQUFQO0FBQ0gsT0FGTSxNQUVBLElBQUk0VSxFQUFFLENBQUNDLFlBQUgsS0FBb0JsWSxTQUF4QixFQUFtQztBQUN0QyxjQUFNLElBQUlpWSxFQUFFLENBQUM4ZixPQUFILENBQVd1QyxPQUFmLENBQXVCLGtDQUF2QixDQUFOO0FBQ0gsT0FGTSxNQUVBLElBQUlyaUIsRUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCcFUsUUFBekIsTUFBdUM5RCxTQUEzQyxFQUFzRDtBQUN6RCxlQUFPaVksRUFBRSxDQUFDQyxZQUFILENBQWdCLE9BQWhCLEVBQXlCcFUsUUFBekIsQ0FBUDtBQUNILE9BRk0sTUFFQTtBQUNILFlBQUlzMkIsS0FBSyxHQUFHLEtBQUsvaEIsSUFBTCxDQUFVek8sVUFBVixDQUFxQmlCLFVBQXJCLENBQWdDd3ZCLGFBQWhDLENBQThDdjJCLFFBQTlDLEVBQXdELElBQXhELENBQVo7O0FBQ0EsWUFBSXMyQixLQUFLLEtBQUtwNkIsU0FBZCxFQUF5QjtBQUNyQixnQkFBTSxJQUFJaVksRUFBRSxDQUFDOGYsT0FBSCxDQUFXdUMsT0FBZixDQUF1QixzQkFBb0J4MkIsUUFBcEIsR0FBK0IsR0FBdEQsQ0FBTjtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFPczJCLEtBQUssQ0FBQ2xuQixRQUFOLEVBQVA7QUFDSDtBQUNKO0FBQ0o7QUFyREw7QUFBQTtBQUFBLDBCQXVEVStKLGFBdkRWLEVBdUR5QjtBQUNqQixhQUFPLEtBQUs1RSxJQUFMLENBQVV6TyxVQUFWLENBQXFCYyxPQUFyQixDQUE2QjlDLEtBQTdCLENBQW1DcVYsYUFBbkMsQ0FBUDtBQUNIO0FBekRMO0FBQUE7QUFBQSxnQ0EyRGdCblosUUEzRGhCLEVBMkQwQjtBQUNsQixhQUFPQSxRQUFRLENBQUMyTyxVQUFULENBQW9CLGtCQUFwQixLQUNIM08sUUFBUSxDQUFDMk8sVUFBVCxDQUFvQixnQkFBcEIsQ0FERyxJQUVIM08sUUFBUSxDQUFDMk8sVUFBVCxDQUFvQixnQkFBcEIsQ0FGSjtBQUdIO0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFqRUo7QUFBQTtBQUFBLHlCQTZFU25LLE9BN0VULEVBNkVrQjIwQixNQTdFbEIsRUE2RTBCQyxVQTdFMUIsRUE2RXNDQyxZQTdFdEMsRUE2RW9EcjVCLFFBN0VwRCxFQTZFOERvMUIsV0E3RTlELEVBNkUyRWtFLE9BN0UzRSxFQTZFb0Y7QUFDNUUsVUFBSXQ1QixRQUFRLEtBQUssV0FBakIsRUFBOEI7QUFDMUI7OztBQUdBLFlBQUlpRSxXQUFXLEdBQUcsS0FBS2tHLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJuTCxJQUE5QztBQUNBekgsZUFBTyxHQUFHLEtBQUsrUCxJQUFMLENBQVV6TyxVQUFWLENBQXFCaUcsS0FBckIsQ0FBMkJ3dEIsWUFBM0IsaUNBQTRDLzBCLE9BQTVDLEdBQXdEMjBCLE1BQXhELEVBQVYsQ0FMMEIsQ0FNMUI7QUFDQTtBQUNBOztBQUNBLGFBQUtodkIsTUFBTCxDQUFZaU4sZUFBWixDQUE0QnJMLEtBQTVCLENBQWtDbU8sSUFBbEMsQ0FBdUM7QUFDbkMsa0JBQVFqVyxXQUQyQjtBQUVuQyxzQkFBWWpFLFFBRnVCO0FBR25DO0FBQ0Esa0JBQVFvNUIsVUFKMkI7QUFLbkMsb0JBQVVDLFlBTHlCO0FBTW5DLHdCQUFjNzBCLE9BQU8sQ0FBQ2cxQixVQU5hO0FBT25DLHFCQUFXaDFCLE9BQU8sQ0FBQ2kxQixPQVBnQjtBQVFuQyx5QkFBZXJFLFdBUm9CO0FBU25DLGlCQUFPa0U7QUFUNEIsU0FBdkM7QUFXQSxhQUFLbnZCLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJuTCxJQUE1QixHQUFtQ2hJLFdBQVcsR0FBRyxDQUFqRDtBQUNBLGFBQUtrRyxNQUFMLENBQVlpTixlQUFaLENBQTRCakwsSUFBNUIsR0FBbUNpdEIsVUFBbkM7QUFDSDtBQUNKO0FBckdMO0FBQUE7O0FBeUdJOzs7O0FBekdKLCtCQTZHZTtBQUNQLFVBQUl6MUIsU0FBUyxHQUFHLEtBQUs0USxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEM7QUFDQUEsZUFBUyxDQUFDSyxPQUFWLENBQWtCSyxnQkFBbEIsQ0FBbUMsS0FBSzhGLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJyTCxLQUEvRDtBQUNBcEksZUFBUyxDQUFDSyxPQUFWLENBQWtCQyxXQUFsQixDQUE4QixLQUFLa0csTUFBTCxDQUFZaU4sZUFBWixDQUE0Qm5MLElBQTFEO0FBQ0F0SSxlQUFTLENBQUNLLE9BQVYsQ0FBa0JFLFFBQWxCLENBQTJCLEtBQUtpRyxNQUFMLENBQVlpTixlQUFaLENBQTRCbkwsSUFBdkQ7QUFDQXRJLGVBQVMsQ0FBQ0ssT0FBVixDQUFrQkcsV0FBbEIsQ0FBOEIsS0FBS2dHLE1BQUwsQ0FBWWlOLGVBQVosQ0FBNEJqTCxJQUExRDtBQUNBeEksZUFBUyxDQUFDSyxPQUFWLENBQWtCSSxRQUFsQixDQUEyQixLQUFLK0YsTUFBTCxDQUFZaU4sZUFBWixDQUE0QmpMLElBQXZEO0FBQ0F4SSxlQUFTLENBQUNLLE9BQVYsQ0FBa0JNLGdCQUFsQixDQUFtQyxLQUFLNkYsTUFBTCxDQUFZaU4sZUFBWixDQUE0Qm5MLElBQS9EO0FBQ0g7QUFySEw7QUFBQTtBQUFBLDZCQXVIYUcsR0F2SGIsRUF1SGtCO0FBQ1YsVUFBSXN0QixZQUFZLEdBQUcsSUFBSUMsR0FBSixFQUFuQjs7QUFDQSxVQUFJQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDQyxJQUFELEVBQVU7QUFDdEIsWUFBSUEsSUFBSSxDQUFDQyxNQUFMLEtBQWdCNTlCLFNBQXBCLEVBQStCO0FBQzNCdzlCLHNCQUFZLENBQUNwc0IsR0FBYixDQUFpQnVzQixJQUFJLENBQUNDLE1BQXRCO0FBQ0g7O0FBQ0QsWUFBSUQsSUFBSSxDQUFDbGEsSUFBVCxFQUFlO0FBQ1hrYSxjQUFJLENBQUNsYSxJQUFMLENBQVUzQixPQUFWLENBQWtCLFVBQUMrYixTQUFEO0FBQUEsbUJBQWVILFNBQVMsQ0FBQ0csU0FBRCxDQUF4QjtBQUFBLFdBQWxCO0FBQ0g7O0FBQ0QsWUFBSUYsSUFBSSxDQUFDRyxNQUFULEVBQWlCO0FBQ2JILGNBQUksQ0FBQ0csTUFBTCxDQUFZaGMsT0FBWixDQUFvQixVQUFDK2IsU0FBRDtBQUFBLG1CQUFlSCxTQUFTLENBQUNHLFNBQUQsQ0FBeEI7QUFBQSxXQUFwQjtBQUNIOztBQUNELFlBQUlGLElBQUksQ0FBQ0ksU0FBVCxFQUFvQjtBQUNoQkosY0FBSSxDQUFDSSxTQUFMLENBQWVqYyxPQUFmLENBQXVCLFVBQUMrYixTQUFEO0FBQUEsbUJBQWVILFNBQVMsQ0FBQ0csU0FBRCxDQUF4QjtBQUFBLFdBQXZCO0FBQ0g7QUFDSixPQWJEOztBQWNBSCxlQUFTLENBQUN4dEIsR0FBRCxDQUFUO0FBQ0EsYUFBTzh0QixLQUFLLENBQUNDLElBQU4sQ0FBV1QsWUFBWCxDQUFQO0FBQ0g7QUFFRDs7OztBQTNJSjtBQUFBO0FBQUEsa0NBOElrQjtBQUNWLFVBQUlySixNQUFNLEdBQUcsS0FBSzliLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQkMsT0FBdkMsQ0FEVSxDQUVWOztBQUNBLFVBQUkrbUIsS0FBSyxHQUFHLEVBQVosQ0FIVSxDQUlWOztBQUNBLFVBQUl2ZSxHQUFKOztBQUNBLFVBQUk7QUFDQSxZQUFJc0gsS0FBSyxHQUFHUyxFQUFFLENBQUNULEtBQUgsQ0FBUyxLQUFLMVQsUUFBZCxFQUF3QixLQUFLVCxJQUE3QixDQUFaO0FBQ0E2TSxXQUFHLEdBQUcrSCxFQUFFLENBQUNpbUIsWUFBSCxDQUFnQjFtQixLQUFLLENBQUMybUIsR0FBdEIsRUFBMkIsS0FBS3I2QixRQUFoQyxFQUEwQzBULEtBQUssQ0FBQzRtQixLQUFoRCxDQUFOO0FBQ0EzUCxhQUFLLEdBQUcsS0FBSzRQLFFBQUwsQ0FBY251QixHQUFkLENBQVI7QUFDSCxPQUpELENBSUUsT0FBT3VTLEtBQVAsRUFBYztBQUNaO0FBQ0EwUixjQUFNLENBQUMsUUFBRCxDQUFOLEdBQW1CO0FBQ2YscUJBQVcsS0FESTtBQUVmLG1CQUFTMVIsS0FGTTtBQUdmLG1CQUFTLElBSE07QUFJZixtQkFBU2dNO0FBSk0sU0FBbkI7QUFNQS9qQixlQUFPLENBQUMrWCxLQUFSLENBQWNBLEtBQWQ7QUFDQS9YLGVBQU8sQ0FBQ29OLEdBQVIsQ0FBWSxLQUFLaFUsUUFBakIsRUFBMkIsS0FBS1QsSUFBaEM7QUFDQSxlQUFPLEtBQVA7QUFDSCxPQXJCUyxDQXNCVjs7O0FBQ0E4d0IsWUFBTSxDQUFDLFFBQUQsQ0FBTixHQUFtQjtBQUNmLG1CQUFXLElBREk7QUFFZixlQUFPamtCLEdBRlE7QUFHZixpQkFBU0EsR0FBRyxDQUFDdVQsSUFBSixDQUFTdFMsTUFBVCxLQUFvQixDQUhkO0FBSWYsaUJBQVNzZDtBQUpNLE9BQW5CO0FBTUEsYUFBTyxJQUFQO0FBQ0g7QUE1S0w7QUFBQTtBQUFBLGlDQThLaUI7QUFDVCxVQUFJMEYsTUFBTSxHQUFHLEtBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQXZDOztBQUNBLFVBQUl5c0IsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQnZmLE9BQXRCLEVBQStCO0FBQzNCLGFBQUt5RCxJQUFMLENBQVV6TyxVQUFWLENBQXFCbkIsUUFBckIsQ0FBOEJxVyxLQUE5QixDQUFvQywwQ0FBcEM7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLekcsSUFBTCxDQUFVek8sVUFBVixDQUFxQm5CLFFBQXJCLENBQThCNjFCLGVBQTlCLENBQThDbkssTUFBTSxDQUFDcnNCLE9BQVAsQ0FBZTJhLEtBQTdEO0FBQ0g7QUFDSjtBQXJMTDtBQUFBO0FBQUEseUNBdUx5QjtBQUFBOztBQUNqQixVQUFJMFIsTUFBTSxHQUFHLEtBQUs5YixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQXZDO0FBQ0EsVUFBSWUsUUFBUSxHQUFHLEtBQUs0UCxJQUFMLENBQVV6TyxVQUFWLENBQXFCbkIsUUFBcEM7O0FBQ0EsVUFBSSxDQUFDMHJCLE1BQU0sQ0FBQyxTQUFELENBQU4sQ0FBa0J2ZixPQUF2QixFQUFnQztBQUM1QixZQUFJMnBCLFdBQVcsR0FBRyxLQUFLbG1CLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QnVKLFNBQTlCLENBQXdDdVAsSUFBeEMsQ0FBNkMsd0JBQTdDLENBQWxCO0FBQ0EsWUFBSWhRLE9BQU8sR0FBR0QsUUFBUSxDQUFDNjFCLGVBQVQsQ0FBeUJuSyxNQUFNLENBQUNyc0IsT0FBUCxDQUFlMmEsS0FBeEMsRUFBK0MsSUFBL0MsQ0FBZDtBQUNBOGIsbUJBQVcsQ0FBQ25lLElBQVosQ0FBaUIsT0FBakIsRUFBMEIsNkJBQTFCO0FBQ0FtZSxtQkFBVyxDQUFDemhCLE9BQVosQ0FBb0I7QUFBQyxxQkFBVyxPQUFaO0FBQXFCLHVCQUFhLEtBQUt6RSxJQUFMLENBQVVuWCxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJzSjtBQUFoRSxTQUFwQjtBQUNBcTFCLG1CQUFXLENBQUNyZ0IsS0FBWixDQUFrQjtBQUFBLGlCQUFNLE1BQUksQ0FBQzdGLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFyQixDQUE0Qm9ZLHdCQUE1QixDQUFxRDljLE9BQXJELENBQU47QUFBQSxTQUFsQjtBQUNBNjFCLG1CQUFXLENBQUNubEIsSUFBWjtBQUNIO0FBQ0o7QUFsTUw7O0FBQUE7QUFBQSxFQUEwQzBjLDZEQUExQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGTyxJQUFJMEksYUFBYSw0NkRBQWpCO0FBa0RBLElBQU03bEIsZUFBYjtBQUVJOzs7Ozs7Ozs7QUFTQSwyQkFBWU4sSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBRUEsU0FBS2lnQixhQUFMLEdBQXFCLEtBQUtwbUIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCZ0IsUUFBL0M7QUFFQSxTQUFLRSxRQUFMLEdBQWdCLEtBQUs2VixHQUFMLENBQVM5RixJQUFULENBQWMsNEJBQWQsQ0FBaEI7QUFDQSxTQUFLOVAsS0FBTCxHQUFhLEtBQUs0VixHQUFMLENBQVM5RixJQUFULENBQWMseUJBQWQsQ0FBYjtBQUNBLFNBQUtoUSxPQUFMLEdBQWUsS0FBSzhWLEdBQUwsQ0FBUzlGLElBQVQsQ0FBYywyQkFBZCxDQUFmO0FBQ0EsU0FBS2dtQixRQUFMLEdBQWdCLEtBQUtsZ0IsR0FBTCxDQUFTOUYsSUFBVCxDQUFjLDRCQUFkLENBQWhCLENBVG1CLENBV25COztBQUNBLFNBQUtMLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLENBQWdDaVcsU0FBaEMsQ0FBMEM7QUFBQSxhQUFNLEtBQUksQ0FBQ2pCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3Qm9CLGVBQXhCLENBQXdDLElBQXhDLENBQU47QUFBQSxLQUExQztBQUNIOztBQXhCTDtBQUFBOztBQTBCSTs7O0FBMUJKLHFDQTZCcUI7QUFDYndFLE9BQUMsQ0FBQyxZQUFELENBQUQsQ0FBZ0IyWCxPQUFoQixDQUF3QjtBQUNwQnhGLGlCQUFTLEVBQUUsS0FBSzRDLEdBQUwsQ0FBUzdDLE1BQVQsR0FBa0JEO0FBRFQsT0FBeEIsRUFFRyxHQUZIO0FBR0g7QUFqQ0w7QUFBQTs7QUFtQ0k7Ozs7QUFuQ0osd0NBdUN3QjtBQUNoQixVQUFJaWpCLGdCQUFnQixHQUFHLEdBQXZCO0FBQ0EsVUFBSUMsWUFBWSxHQUFHLEtBQUtwZ0IsR0FBTCxDQUFTN0MsTUFBVCxHQUFrQkQsR0FBckMsQ0FGZ0IsQ0FHaEI7O0FBQ0EsVUFBSW1qQixlQUFlLEdBQUdELFlBQVksR0FBR0QsZ0JBQXJDO0FBQ0EsVUFBSUcsY0FBYyxHQUFHcjFCLENBQUMsQ0FBQ2lkLE1BQUQsQ0FBRCxDQUFVOUssU0FBVixLQUF3Qm5TLENBQUMsQ0FBQ2lkLE1BQUQsQ0FBRCxDQUFVN0gsTUFBVixFQUE3QztBQUNBLFVBQUlrZ0IsV0FBVyxHQUFHdDFCLENBQUMsQ0FBQ2lkLE1BQUQsQ0FBRCxDQUFVOUssU0FBVixFQUFsQixDQU5nQixDQU9oQjs7QUFDQSxhQUNLZ2pCLFlBQVksR0FBR0UsY0FBaEIsSUFDQ0MsV0FBVyxHQUFHRixlQUZuQjtBQUdIO0FBbERMO0FBQUE7O0FBb0RJOzs7O0FBcERKLDRCQXdEMkI7QUFBQSxVQUFqQm4yQixPQUFpQix1RUFBVCxPQUFTO0FBQ25CLFdBQUsrMUIsYUFBTCxDQUFtQi8xQixPQUFuQixDQUEyQkEsT0FBM0I7QUFDQSxXQUFLKzFCLGFBQUwsQ0FBbUI5MUIsUUFBbkIsQ0FBNEIsSUFBNUI7QUFDQSxXQUFLODFCLGFBQUwsQ0FBbUI3MUIsS0FBbkIsQ0FBeUIsSUFBekI7QUFDQSxXQUFLNjFCLGFBQUwsQ0FBbUJ4N0IsTUFBbkIsQ0FBMEIsS0FBMUI7QUFDQSxXQUFLdzdCLGFBQUwsQ0FBbUI1MUIsVUFBbkIsQ0FBOEJrVyxTQUE5QjtBQUNBLFdBQUswZixhQUFMLENBQW1CMzFCLGNBQW5CLENBQWtDaVcsU0FBbEM7QUFDQSxXQUFLaWdCLHFCQUFMO0FBQ0g7QUFoRUw7QUFBQTtBQUFBLDRDQXFGNEIsQ0FFdkI7QUFFRDs7Ozs7QUF6Rko7QUFBQTtBQUFBLG1DQTZGbUJDLGdCQTdGbkIsRUE2RnFDO0FBQUE7O0FBQzdCO0FBQ0EsVUFBSXYyQixPQUFPLEdBQUd1UCxFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCbUcsZ0JBQWdCLENBQUNDLE9BQWxDLENBQWQ7QUFDQSxVQUFJdjJCLFFBQVEsR0FBR3NQLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUJtRyxnQkFBZ0IsQ0FBQ0UsUUFBbEMsQ0FBZjtBQUNBLFVBQUl2MkIsS0FBSyxHQUFHcVAsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQm1HLGdCQUFnQixDQUFDRyxLQUFsQyxDQUFaO0FBQ0EsVUFBSS9sQixJQUFJLEdBQUdwQixFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCbUcsZ0JBQWdCLENBQUN2RCxJQUFsQyxDQUFYO0FBQ0EsVUFBSWp4QixJQUFJLEdBQUd3MEIsZ0JBQWdCLENBQUNJLElBQTVCO0FBQ0EsVUFBSUMsU0FBUyxHQUFHcm5CLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUJtRyxnQkFBZ0IsQ0FBQ00sUUFBbEMsQ0FBaEIsQ0FQNkIsQ0FTN0I7O0FBQ0EsVUFBSUMsU0FBUyxHQUFHLEtBQUtubkIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCb0QsTUFBM0IsRUFBaEI7O0FBQ0EsVUFBSXU4QixTQUFTLElBQUk3MkIsUUFBUSxDQUFDd0YsV0FBVCxPQUEyQixVQUE1QyxFQUF3RDtBQUNwRHhGLGdCQUFRLEdBQUcsV0FBWDtBQUNBQyxhQUFLLEdBQUcsV0FBUjtBQUNBRixlQUFPLEdBQUcscUJBQVY7QUFDSCxPQWY0QixDQWlCN0I7OztBQUNBLFVBQUlDLFFBQVEsQ0FBQ3dGLFdBQVQsT0FBMkIsWUFBM0IsSUFBMkN2RixLQUFLLENBQUN1RixXQUFOLE9BQXdCLFNBQXZFLEVBQWtGO0FBQzlFdkYsYUFBSyxHQUFHLHFCQUFSO0FBQ0gsT0FwQjRCLENBc0I3Qjs7O0FBQ0EsVUFBSUQsUUFBUSxLQUFLLFlBQWIsSUFBNkJDLEtBQUssS0FBSyxXQUEzQyxFQUF3RDtBQUNwREQsZ0JBQVEsR0FBRyxXQUFYO0FBQ0gsT0F6QjRCLENBMkI3Qjs7O0FBQ0FELGFBQU8sR0FBRyxLQUFLMlAsSUFBTCxDQUFVMUwsU0FBVixDQUFvQkMsUUFBcEIsQ0FBNkJsRSxPQUE3QixFQUFzQzJkLE9BQXRDLENBQThDLFVBQTlDLEVBQTBELFdBQTFELENBQVY7QUFDQSxXQUFLb1ksYUFBTCxDQUFtQi8xQixPQUFuQixDQUEyQkEsT0FBM0I7QUFDQSxXQUFLKzFCLGFBQUwsQ0FBbUI5MUIsUUFBbkIsQ0FBNEJBLFFBQTVCO0FBQ0EsV0FBSzgxQixhQUFMLENBQW1CNzFCLEtBQW5CLENBQXlCQSxLQUF6QixFQS9CNkIsQ0FnQzdCOztBQUNBLFdBQUtGLE9BQUwsQ0FBYWdRLElBQWIsQ0FBa0IsVUFBbEIsRUFBOEIzRixHQUE5QixDQUFtQyxVQUFDNE4sQ0FBRCxFQUFJOGUsS0FBSixFQUFjO0FBQzdDL1ksY0FBTSxDQUFDZ1osSUFBUCxDQUFZQyxjQUFaLENBQTJCRixLQUEzQjtBQUNILE9BRkQsRUFqQzZCLENBb0M3QjtBQUNBOztBQUNBLFdBQUtwbkIsSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEJ2RCxRQUE1QixDQUFxQyxjQUFyQyxFQUFxRHFDLFFBQXJELEVBQStEQyxLQUEvRCxFQUFzRUYsT0FBdEUsRUFBK0UsV0FBL0UsRUF0QzZCLENBd0M3Qjs7QUFDQSxXQUFLMlAsSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQzBpQixxQkFBckMsR0F6QzZCLENBMkM3Qjs7QUFDQSxVQUFJMWUsSUFBSSxHQUFHMEksZUFBZSxDQUFDaW5CLGtCQUFoQixDQUFtQ24xQixJQUFuQyxDQUFYO0FBQ0EsV0FBS2cwQixhQUFMLENBQW1CNTFCLFVBQW5CLENBQThCa1csU0FBOUI7O0FBQ0EsVUFBSTlPLElBQUksS0FBSyxJQUFULElBQWlCQSxJQUFJLEtBQUtqUSxTQUE5QixFQUF5QztBQUNyQyxhQUFLeStCLGFBQUwsQ0FBbUI1MUIsVUFBbkIsQ0FBOEJtVixJQUE5QixDQUFtQy9OLElBQW5DO0FBQ0gsT0FoRDRCLENBa0Q3Qjs7O0FBQ0EsVUFBSTR2QixhQUFhLEdBQUcsS0FBS3huQixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDSSxPQUF0RDtBQUNBLFdBQUsyMkIsYUFBTCxDQUFtQjMxQixjQUFuQixDQUFrQ2lXLFNBQWxDOztBQUNBLFVBQUk4Z0IsYUFBYSxDQUFDanJCLE9BQWxCLEVBQTJCO0FBQ3ZCLFlBQUlrckIsY0FBYyxHQUFHLEVBQXJCO0FBQ0EsYUFBS3puQixJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJDLE9BQTFCLENBQWtDbTFCLE1BQWxDLENBQXlDcE8sS0FBekMsQ0FBK0MzTSxPQUEvQyxDQUF1RCxVQUFDN1IsSUFBRCxFQUFVO0FBQzdELGNBQUk0dkIsYUFBYSxDQUFDcFIsS0FBZCxDQUFvQm5iLE9BQXBCLENBQTRCckQsSUFBNUIsTUFBc0MsQ0FBQyxDQUEzQyxFQUE4QztBQUMxQzZ2QiwwQkFBYyxDQUFDOWhCLElBQWYsQ0FBb0IvTixJQUFwQjtBQUNIO0FBQ0osU0FKRDtBQUtBLGFBQUt3dUIsYUFBTCxDQUFtQjMxQixjQUFuQixDQUFrQ2czQixjQUFsQztBQUNIOztBQTdENEIsaUNBK0RwQm5mLENBL0RvQjtBQWdFekIsWUFBSW9mLFlBQVksR0FBR1QsU0FBUyxDQUFDM2UsQ0FBRCxDQUE1Qjs7QUFDQSxjQUFJLENBQUNxZixtQkFBTCxDQUF5QkQsWUFBWSxDQUFDcjNCLE9BQXRDLEVBQStDLE1BQS9DLEVBQXVELE9BQXZELEVBQWdFO0FBQUEsaUJBQU0sTUFBSSxDQUFDMlAsSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCcVksc0JBQTVCLENBQW1Ec2EsWUFBWSxDQUFDL2IsS0FBaEUsRUFBdUUrYixZQUFZLENBQUNyM0IsT0FBcEYsQ0FBTjtBQUFBLFNBQWhFO0FBakV5Qjs7QUErRDdCLFdBQUssSUFBSWlZLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBQzJlLFNBQVMsQ0FBQ251QixNQUExQixFQUFrQ3dQLENBQUMsSUFBRSxDQUFyQyxFQUF3QztBQUFBLGNBQS9CQSxDQUErQjtBQUd2QztBQUNKO0FBaEtMO0FBQUE7QUFBQSw0Q0FrSzRCO0FBQ3BCLFdBQUsrZCxRQUFMLENBQWN4ZixLQUFkO0FBQ0EsV0FBSzdHLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QnVKLFNBQTlCLENBQXdDdVAsSUFBeEMsQ0FBNkMsd0JBQTdDLEVBQXVFVyxJQUF2RTtBQUNIO0FBcktMO0FBQUE7QUFBQSx3Q0F1S3dCZixJQXZLeEIsRUF1SzhCaVEsSUF2SzlCLEVBdUtvQzBYLEtBdktwQyxFQXVLMkNDLE9BdkszQyxFQXVLb0RDLEtBdktwRCxFQXVLMkQ7QUFBQTs7QUFDbkQsVUFBSXpCLFFBQVEsR0FBR2oxQixDQUFDLENBQUMsZUFBRCxDQUFoQjtBQUNBaTFCLGNBQVEsQ0FBQ25qQixRQUFULENBQWtCLDJDQUF5Q2dOLElBQTNEO0FBQ0FtVyxjQUFRLENBQUMwQixHQUFULENBQWEsT0FBYixFQUFzQkgsS0FBdEI7QUFDQXZCLGNBQVEsQ0FBQ3RlLElBQVQsQ0FBYyxPQUFkLEVBQXVCOUgsSUFBdkI7O0FBQ0EsVUFBSTZuQixLQUFKLEVBQVc7QUFDUCxhQUFLekIsUUFBTCxDQUFjdmlCLE1BQWQsQ0FBcUJ1aUIsUUFBckI7QUFDSCxPQUZELE1BRU87QUFDSCxhQUFLQSxRQUFMLENBQWNqakIsT0FBZCxDQUFzQmlqQixRQUF0QjtBQUNIOztBQUNEQSxjQUFRLENBQUM1aEIsT0FBVCxDQUFpQjtBQUFDLG1CQUFXLE9BQVo7QUFBcUIscUJBQWEsS0FBS3pFLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J0QixhQUFoQixDQUE4QnNKO0FBQWhFLE9BQWpCOztBQUNBLFVBQUlnM0IsT0FBTyxLQUFLbGdDLFNBQWhCLEVBQTJCO0FBQ3ZCMCtCLGdCQUFRLENBQUN4Z0IsS0FBVCxDQUFlZ2lCLE9BQWY7QUFDSDs7QUFDRHhCLGNBQVEsQ0FBQzJCLEtBQVQsQ0FBZSxZQUFNO0FBQ2pCLGNBQUksQ0FBQ2hvQixJQUFMLENBQVV6TyxVQUFWLENBQXFCQyxNQUFyQixDQUE0QnZELFFBQTVCLENBQXFDLFlBQXJDLEVBQW1ELFVBQW5ELEVBQStELE9BQS9ELEVBQXdFZ1MsSUFBeEUsRUFBOEUsRUFBOUU7QUFDSCxPQUZEO0FBR0g7QUFFRDs7OztBQTFMSjtBQUFBO0FBQUEsb0NBNkxvQjJtQixnQkE3THBCLEVBNkxzQztBQUM5QixXQUFLcUIsY0FBTCxDQUFvQnJCLGdCQUFwQixFQUQ4QixDQUc5QjtBQUNBOztBQUVBLFdBQUtzQixvQkFBTDtBQUNIO0FBcE1MO0FBQUE7QUFBQSwyQ0FzTTJCO0FBQ25CLFVBQUksQ0FBQyxLQUFLMXhCLGlCQUFMLEVBQUwsRUFBK0I7QUFDM0IsYUFBSzJQLEdBQUwsQ0FBUzlGLElBQVQsQ0FBYyw0QkFBZCxFQUE0Q1UsSUFBNUMsR0FBbURuQyxPQUFuRCxDQUEyRCxJQUEzRDs7QUFDQSxZQUFJLEtBQUt1cEIsb0JBQUwsRUFBSixFQUFpQztBQUM3QixlQUFLQyxjQUFMO0FBQ0g7QUFDSjtBQUNKO0FBN01MO0FBQUE7QUFBQSwyQ0ErTTJCO0FBQ25CLGFBQU8sQ0FBQyxLQUFLcG9CLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQkMsV0FBbkIsRUFBUjtBQUNIO0FBak5MO0FBQUE7QUFBQSxvQ0FtTm9CbVcsS0FuTnBCLEVBbU4yQmllLFdBbk4zQixFQW1Od0M7QUFDaEMsVUFBSUEsV0FBVyxLQUFLMWdDLFNBQXBCLEVBQStCO0FBQzNCMGdDLG1CQUFXLEdBQUcsS0FBZDtBQUNIOztBQUNELFVBQUloNEIsT0FBSixFQUFhRSxLQUFiLEVBQW9CRCxRQUFwQixFQUE4QmkxQixNQUE5QjtBQUNBaDFCLFdBQUssR0FBRzZaLEtBQUssQ0FBQ29aLE9BQWQ7QUFDQWx6QixjQUFRLEdBQUcsU0FBWDtBQUNBRCxhQUFPLEdBQUcsS0FBS2k0QixrQkFBTCxDQUF3QmxlLEtBQXhCLENBQVY7O0FBRUEsVUFBSWllLFdBQUosRUFBaUI7QUFDYixlQUFPaDRCLE9BQVA7QUFDSDs7QUFDRCxXQUFLKzFCLGFBQUwsQ0FBbUIvMUIsT0FBbkIsQ0FBMkJBLE9BQTNCO0FBQ0EsV0FBSysxQixhQUFMLENBQW1COTFCLFFBQW5CLENBQTRCQSxRQUE1QjtBQUNBLFdBQUs4MUIsYUFBTCxDQUFtQjcxQixLQUFuQixDQUF5QkEsS0FBekI7QUFDQSxXQUFLNjFCLGFBQUwsQ0FBbUI1MUIsVUFBbkIsQ0FBOEJrVyxTQUE5Qjs7QUFDQSxVQUFJNmUsTUFBTSxLQUFLNTlCLFNBQVgsSUFBd0I0OUIsTUFBTSxLQUFLLElBQXZDLEVBQTZDO0FBQ3pDLGFBQUthLGFBQUwsQ0FBbUI1MUIsVUFBbkIsQ0FBOEJtVixJQUE5QixDQUFtQzRmLE1BQW5DO0FBQ0g7QUFDSjtBQXRPTDtBQUFBO0FBQUEsbUNBd09tQm5iLEtBeE9uQixFQXdPMEJtZSxnQkF4TzFCLEVBd080QztBQUFBOztBQUNwQyxhQUFPbmUsS0FBSyxDQUFDb2UsU0FBTixDQUFnQjl0QixHQUFoQixDQUFvQixVQUFBK3RCLEtBQUssRUFBSTtBQUNoQyxZQUFJbEQsTUFBTSxHQUFHa0QsS0FBSyxDQUFDbEQsTUFBbkI7O0FBQ0EsWUFBSWtELEtBQUssQ0FBQ2g5QixRQUFOLENBQWU0TyxLQUFmLENBQXFCLENBQXJCLEVBQXdCLENBQUMsQ0FBekIsTUFBZ0NrdUIsZ0JBQXBDLEVBQXNEO0FBQ2xEaEQsZ0JBQU0sSUFBSSxNQUFJLENBQUN2bEIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCQyxPQUExQixDQUFrQzNELFVBQWxDLENBQTZDczNCLFVBQXZEO0FBQ0g7O0FBQ0QsWUFBSW5xQixJQUFJLDZDQUFtQzR2QixLQUFLLENBQUNoOUIsUUFBekMsZ0JBQVI7QUFDQSxZQUFJbU0sSUFBSSw0Q0FBbUMydEIsTUFBbkMsY0FBUjtBQUNBLFlBQUltRCxLQUFLLEdBQUlELEtBQUssQ0FBQ0MsS0FBTixLQUFnQixVQUFoQixJQUNiRCxLQUFLLENBQUNDLEtBQU4sS0FBZ0IvZ0MsU0FESixzQkFDNkI4Z0MsS0FBSyxDQUFDQyxLQURuQyxJQUM2QyxFQUR6RDtBQUVBLFlBQUlsVSxNQUFNLEdBQUcsRUFBYjs7QUFDQSxZQUFJaVUsS0FBSyxDQUFDalUsTUFBTixLQUFpQjdzQixTQUFyQixFQUFnQztBQUM1QjZzQixnQkFBTSwwQkFBbUJpVSxLQUFLLENBQUNqVSxNQUF6QixrQkFBTjtBQUNIOztBQUNELGVBQU8zYixJQUFJLEdBQUdqQixJQUFQLEdBQWM4d0IsS0FBZCxHQUFzQmxVLE1BQTdCO0FBQ0gsT0FkTSxDQUFQO0FBZUg7QUF4UEw7QUFBQTtBQUFBLHVDQTBQdUJwSyxLQTFQdkIsRUEwUDhCbWUsZ0JBMVA5QixFQTBQZ0RJLFlBMVBoRCxFQTBQOEQ7QUFDdEQsVUFBSXovQixJQUFJLEdBQUdraEIsS0FBSyxDQUFDb1osT0FBakI7QUFDQSxVQUFJbkQsSUFBSSxHQUFHemdCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUJyVyxLQUFLLENBQUNpVyxJQUF2QixDQUFYO0FBQ0EsVUFBSWhkLEdBQUcsYUFBTW5hLElBQU4sZUFBZW0zQixJQUFJLENBQUMsQ0FBRCxDQUFuQixpQkFBUDtBQUNBLFVBQUltSSxTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsVUFBSXQvQixJQUFJLEtBQUssY0FBYixFQUE2QjtBQUN6QixZQUFJa2hCLEtBQUssQ0FBQ3dlLEdBQU4sSUFBYXhlLEtBQUssQ0FBQ3dlLEdBQU4sQ0FBVUosU0FBdkIsSUFBb0NwZSxLQUFLLENBQUN3ZSxHQUFOLENBQVVKLFNBQVYsQ0FBb0IxdkIsTUFBNUQsRUFBb0U7QUFDaEUsY0FBTSt2QixTQUFTLEdBQUcsS0FBS0MsY0FBTCxDQUFvQjFlLEtBQUssQ0FBQ3dlLEdBQTFCLEVBQStCTCxnQkFBL0IsQ0FBbEI7QUFDQSxjQUFNbnBCLE1BQU0sR0FBRyxDQUFDLFlBQUQsQ0FBZjs7QUFDQSxjQUFJeXBCLFNBQVMsQ0FBQy92QixNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3RCc0csa0JBQU0sQ0FBQ3VHLElBQVAsT0FBQXZHLE1BQU0scUJBQVN5cEIsU0FBUyxDQUFDeHVCLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBVCwrQkFDb0J3dUIsU0FBUyxDQUFDL3ZCLE1BQVYsR0FBbUIsQ0FEdkMsbURBRVMrdkIsU0FBUyxDQUFDeHVCLEtBQVYsQ0FBZ0IsQ0FBQyxDQUFqQixFQUFvQixDQUFDLENBQXJCLENBRlQsR0FBTjtBQUdILFdBSkQsTUFJTztBQUNIK0Usa0JBQU0sQ0FBQ3VHLElBQVAsT0FBQXZHLE1BQU0scUJBQVN5cEIsU0FBVCxFQUFOO0FBQ0g7O0FBQ0RMLG1CQUFTLEdBQUdwcEIsTUFBTSxDQUFDdU8sSUFBUCxDQUFZLFFBQVosQ0FBWjtBQUNIO0FBQ0osT0FiRCxNQWFPO0FBQ0gsWUFBSWdiLFlBQUosRUFBa0I7QUFDZHRsQixhQUFHLEdBQUcsb0ZBQWtGQSxHQUF4RjtBQUNIOztBQUNELFlBQUkrRyxLQUFLLENBQUNvZSxTQUFOLElBQW1CcGUsS0FBSyxDQUFDb2UsU0FBTixDQUFnQjF2QixNQUF2QyxFQUErQztBQUMzQzB2QixtQkFBUyxHQUFHLHFCQUFxQixLQUFLTSxjQUFMLENBQW9CMWUsS0FBcEIsRUFBMkJtZSxnQkFBM0IsRUFBNkM1YSxJQUE3QyxDQUFrRCxRQUFsRCxDQUFqQztBQUNIO0FBQ0o7O0FBQ0QsYUFBT3RLLEdBQUcsR0FBQyxJQUFKLEdBQVNtbEIsU0FBaEI7QUFDSDtBQXJSTDtBQUFBO0FBQUEseUNBdVJ5QnBlLEtBdlJ6QixFQXVSZ0NtZSxnQkF2UmhDLEVBdVJrRDtBQUMxQyxVQUFJbmUsS0FBSyxDQUFDb1osT0FBTixLQUFrQixjQUF0QixFQUFzQztBQUNsQyxhQUFLeGpCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DRSxRQUFuQyxDQUE0QyxTQUE1QztBQUNBLGFBQUswUCxJQUFMLENBQVVuWCxLQUFWLENBQWdCdUcsU0FBaEIsQ0FBMEJnQixRQUExQixDQUFtQ0csS0FBbkMsQ0FBeUMsZUFBekM7QUFDSCxPQUhELE1BR087QUFDSCxhQUFLeVAsSUFBTCxDQUFVblgsS0FBVixDQUFnQnVHLFNBQWhCLENBQTBCZ0IsUUFBMUIsQ0FBbUNFLFFBQW5DLENBQTRDLFVBQTVDO0FBQ0EsYUFBSzBQLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DRyxLQUFuQyxDQUF5QyxnQkFBekM7QUFDSDs7QUFDRCxVQUFJRixPQUFPLEdBQUcsS0FBS2k0QixrQkFBTCxDQUF3QmxlLEtBQXhCLEVBQStCbWUsZ0JBQS9CLEVBQWlELElBQWpELENBQWQ7QUFDQSxXQUFLdm9CLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J1RyxTQUFoQixDQUEwQmdCLFFBQTFCLENBQW1DQyxPQUFuQyxDQUEyQ0EsT0FBM0M7QUFFQSxXQUFLNjNCLG9CQUFMO0FBRUEsV0FBS2xvQixJQUFMLENBQVV6TyxVQUFWLENBQXFCQyxNQUFyQixDQUE0QnZELFFBQTVCLENBQXFDLGdCQUFyQyxFQUF1RCxVQUF2RCxFQUFtRSxnQkFBbkUsRUFBcUZvQyxPQUFyRixFQUE4Rms0QixnQkFBOUY7QUFDSDtBQXJTTDtBQUFBO0FBQUEsdUNBa0U4QlEsWUFsRTlCLEVBa0U0QztBQUNwQyxVQUFJQSxZQUFZLENBQUNDLFlBQWpCLEVBQStCO0FBQzNCLFlBQUlDLFFBQVEsR0FBR0YsWUFBWSxDQUFDQyxZQUFiLENBQTBCLElBQUlwcEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXZ0MsR0FBZixDQUFtQixVQUFuQixDQUExQixDQUFmOztBQUNBLFlBQUl1SCxRQUFKLEVBQWM7QUFDVixjQUFJcnhCLElBQUksR0FBR3F4QixRQUFRLENBQUNDLFVBQVQsQ0FBb0IsSUFBSXRwQixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1CLE1BQW5CLENBQXBCLENBQVg7O0FBQ0EsY0FBSTlwQixJQUFKLEVBQVU7QUFDTixtQkFBT2dJLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUI3b0IsSUFBakIsQ0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxhQUFPLElBQVA7QUFDQTs7Ozs7O0FBTUg7QUFuRkw7O0FBQUE7QUFBQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQ2hEQTs7QUFFQSxJQUFNb2MsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBU3ZvQixRQUFULEVBQW1CMDlCLFlBQW5CLEVBQWlDQyxXQUFqQyxFQUE4Q0MsYUFBOUMsRUFBNkQ7QUFDekUsTUFBSUYsWUFBWSxLQUFLeGhDLFNBQXJCLEVBQWdDO0FBQzVCd2hDLGdCQUFZLEdBQUcxOUIsUUFBZjtBQUNIOztBQUNELE1BQUk2OUIsbUJBQW1CLEdBQUcsRUFBMUI7QUFDQSxNQUFJQyxtQkFBbUIsR0FBRyxNQUExQjs7QUFDQSxNQUFJLENBQUNGLGFBQUwsRUFBb0I7QUFDaEJDLHVCQUFtQixHQUFHLHlCQUF0QjtBQUNBQyx1QkFBbUIsR0FBRyxzQkFBdEI7QUFDSDs7QUFDRCw4Q0FDc0JELG1CQUR0QiwySkFJMkQ3OUIsUUFKM0QsdUVBS21EQSxRQUxuRCw2Q0FNeUIyOUIsV0FOekIsdUNBTWlFMzlCLFFBTmpFLG9CQU1tRjg5QixtQkFObkYsOEJBT1VKLFlBUFY7QUFTSCxDQW5CRDs7QUFxQk8sSUFBSUssVUFBVSwrUEFTZnhWLE9BQU8sQ0FBQyxXQUFELEVBQWNyc0IsU0FBZCxFQUF5QkEsU0FBekIsRUFBb0MsSUFBcEMsQ0FUUSxtQkFVZnFzQixPQUFPLENBQUMsa0JBQUQsRUFBcUIsY0FBckIsQ0FWUSxtQkFXZkEsT0FBTyxDQUFDLDhCQUFELEVBQWlDLFVBQWpDLENBWFEsbUJBWWZBLE9BQU8sQ0FBQyxtQkFBRCxFQUFzQixlQUF0QixDQVpRLG1CQWFmQSxPQUFPLENBQUMsWUFBRCxFQUFlLFFBQWYsQ0FiUSxtQkFjZkEsT0FBTyxDQUFDLGVBQUQsRUFBa0IsV0FBbEIsRUFBK0IsSUFBL0IsQ0FkUSxtQkFlZkEsT0FBTyxDQUFDLGFBQUQsRUFBZ0IsU0FBaEIsRUFBMkIsSUFBM0IsQ0FmUSxtQkFnQmZBLE9BQU8sQ0FBQyw2QkFBRCxFQUFnQyxvQkFBaEMsRUFBc0QsSUFBdEQsQ0FoQlEsbUJBaUJmQSxPQUFPLENBQUMsZUFBRCxFQUFrQixNQUFsQixFQUEwQixJQUExQixDQWpCUSwyd0pBQWQ7QUFzR1AsSUFBTXlWLCtCQUErQiw0MkNBQXJDO0FBbUNBOzs7Ozs7Ozs7Ozs7QUFZTyxJQUFJQyxjQUFjLEdBQUcsQ0FDeEI7QUFDQSxXQUZ3QixFQUd4QjtBQUNBLGtCQUp3QixFQUt4Qiw4QkFMd0IsRUFNeEIsbUJBTndCLEVBT3hCLFlBUHdCLEVBUXhCLG1CQVJ3QixDQUFyQjtBQVdBLElBQU1DLGVBQWUsR0FBRyxDQUMzQixlQUQyQixFQUUzQixhQUYyQixFQUczQixvQkFIMkIsRUFJM0Isa0JBSjJCLEVBSzNCLGVBTDJCLEVBTTNCLDZCQU4yQixFQU8zQixtQkFQMkIsRUFRM0IsbUJBUjJCLENBQXhCO0FBV0EsU0FBUzlILGdCQUFULENBQTBCcDJCLFFBQTFCLEVBQW9DO0FBQ3ZDLE1BQUksVUFBVW0yQixRQUFWLENBQW1CbjJCLFFBQVEsQ0FBQyxDQUFELENBQTNCLENBQUosRUFBcUM7QUFDakMsV0FBT0EsUUFBUSxDQUFDNE8sS0FBVCxDQUFlLENBQWYsQ0FBUDtBQUNILEdBRkQsTUFFTztBQUNILFdBQU81TyxRQUFQO0FBQ0g7QUFDSjtBQUVELElBQU1tK0Isb0JBQW9CLEdBQUcsY0FBN0I7QUFDQSxJQUFNQyxpQkFBaUIsR0FBRyxXQUExQjtBQUVBLElBQU1DLFdBQVcsR0FBRztBQUNoQkMsWUFBVSxFQUFFLFlBREk7QUFFaEJDLHVCQUFxQixFQUFFLHVCQUZQO0FBR2hCQyxvQkFBa0IsRUFBRTtBQUhKLENBQXBCO0FBTUEsSUFBTUMsc0JBQXNCLEdBQUcsQ0FBQyxlQUFELEVBQWtCLGFBQWxCLENBQS9CO0FBRU8sSUFBTWx2QixpQkFBaUIsR0FBRyxDQUFDLFdBQUQsRUFBYyxrQkFBZCxFQUFrQyx5QkFBbEMsRUFDQyxtQkFERCxFQUNzQixZQUR0QixFQUNvQyxtQkFEcEMsQ0FBMUI7QUFHQSxJQUFNRyxpQkFBaUIsR0FBRyxDQUFDLFdBQUQsRUFBYyxrQkFBZCxFQUFrQyx5QkFBbEMsRUFDQyxtQkFERCxFQUNzQixZQUR0QixFQUNvQyxtQkFEcEMsRUFFQyxlQUZELEVBRWtCLGFBRmxCLEVBR0Msb0JBSEQsRUFHdUIsa0JBSHZCLEVBSUMsZUFKRCxFQUlrQiw2QkFKbEIsRUFLQyxtQkFMRCxFQUtzQixtQkFMdEIsQ0FBMUI7O0lBT0RndkIsVyxHQUNGLHFCQUFZbnFCLElBQVosRUFBa0J2VSxRQUFsQixFQUE0Qm9QLFFBQTVCLEVBQXNDO0FBQUE7O0FBQ2xDLE9BQUttRixJQUFMLEdBQVlBLElBQVo7QUFDQSxPQUFLdlUsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxPQUFLb1AsUUFBTCxHQUFnQkEsUUFBUSxJQUFJLEVBQTVCO0FBQ0EsT0FBS3V2QixLQUFMLEdBQWEsSUFBYjtBQUNBLE9BQUtwd0IsTUFBTCxHQUFjLElBQWQ7QUFDSCxDOztBQUdFLFNBQVNZLGFBQVQsQ0FBdUJuUCxRQUF2QixFQUFpQ29QLFFBQWpDLEVBQTJDO0FBQzlDLFNBQU87QUFBQyxnQkFBWTdSLEVBQUUsQ0FBQ0MsVUFBSCxDQUFjd0MsUUFBZCxDQUFiO0FBQXNDb1AsWUFBUSxFQUFFN1IsRUFBRSxDQUFDQyxVQUFILENBQWM0UixRQUFRLElBQUksRUFBMUI7QUFBaEQsR0FBUDtBQUNIOztBQUVELFNBQVN3dkIsaUJBQVQsQ0FBMkI1K0IsUUFBM0IsRUFBcUNvUCxTQUFyQyxFQUErQztBQUMzQyxTQUFPO0FBQUVwUCxZQUFRO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLE1BQUU7QUFBQSxhQUFNQSxRQUFOO0FBQUEsS0FBRixDQUFWO0FBQTRCb1AsWUFBUSxFQUFFO0FBQUEsYUFBTUEsU0FBTjtBQUFBO0FBQXRDLEdBQVA7QUFDSDs7QUFFTSxTQUFTMVEsb0JBQVQsQ0FBOEJtZ0MsZ0JBQTlCLEVBQWdEQyxhQUFoRCxFQUErRDtBQUNsRSxNQUFJRCxnQkFBSixFQUFzQjtBQUNsQixRQUFJOXhCLEtBQUssR0FBR1csSUFBSSxDQUFDZ0csS0FBTCxDQUFXbXJCLGdCQUFYLENBQVo7QUFDQSxRQUFJRSxVQUFVLEdBQUcsRUFBakI7O0FBQ0EsU0FBSyxJQUFJLytCLFVBQVQsSUFBcUIrTSxLQUFyQixFQUE0QjtBQUN4QixVQUFJQSxLQUFLLENBQUNvbkIsY0FBTixDQUFxQm4wQixVQUFyQixDQUFKLEVBQW9DO0FBQ2hDKytCLGtCQUFVLENBQUM3a0IsSUFBWCxDQUFnQi9LLGFBQWEsQ0FBQ25QLFVBQUQsRUFBVytNLEtBQUssQ0FBQy9NLFVBQUQsQ0FBaEIsQ0FBN0I7QUFDSDtBQUNKLEtBUGlCLENBUWxCOzs7QUFDQSxRQUFJOCtCLGFBQUosRUFBbUI7QUFDZkEsbUJBQWEsQ0FBQ0MsVUFBRCxDQUFiO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBT0EsVUFBUDtBQUNIO0FBQ0osR0FkRCxNQWNPO0FBQ0gsUUFBSUQsYUFBSixFQUFtQjtBQUNmQSxtQkFBYSxDQUFDLEVBQUQsQ0FBYjtBQUNILEtBRkQsTUFFTztBQUNILGFBQU8sRUFBUDtBQUNIO0FBQ0o7QUFDSjtBQUVNLFNBQVNFLHNCQUFULENBQWdDRixhQUFoQyxFQUErQztBQUNsRCxTQUFPcHhCLElBQUksQ0FBQ0MsU0FBTCxDQUFlbXhCLGFBQWEsR0FBRzd2QixHQUFoQixDQUFvQixVQUFBN0IsSUFBSSxFQUFJO0FBQzlDLFdBQU87QUFDSHBOLGNBQVEsRUFBRW9OLElBQUksQ0FBQ3BOLFFBQUwsRUFEUDtBQUVIb1AsY0FBUSxFQUFFaEMsSUFBSSxDQUFDZ0MsUUFBTDtBQUZQLEtBQVA7QUFJSCxHQUxxQixDQUFmLENBQVA7QUFNSDtBQUVNLFNBQVNYLHVCQUFULENBQWlDcXdCLGFBQWpDLEVBQWdEO0FBQ25ELFNBQU92aEMsRUFBRSxDQUFDa0wsWUFBSCxDQUFnQixZQUFNO0FBQ3pCLFFBQUlrTCxNQUFNLEdBQUcsRUFBYjtBQUNBbXJCLGlCQUFhLEdBQUc5Z0IsT0FBaEIsQ0FBd0IsVUFBQTVRLElBQUk7QUFBQSxhQUN4QnVHLE1BQU0sQ0FBQ3ZHLElBQUksQ0FBQ3BOLFFBQUwsRUFBRCxDQUFOLEdBQTBCb04sSUFBSSxDQUFDZ0MsUUFBTCxFQURGO0FBQUEsS0FBNUI7QUFFQSxXQUFPMUIsSUFBSSxDQUFDQyxTQUFMLENBQWVnRyxNQUFmLENBQVA7QUFDSCxHQUxNLENBQVA7QUFNSDtBQUVEOzs7O0FBR08sSUFBTXNCLGlCQUFiO0FBQ0ksNkJBQVlWLElBQVosRUFBa0I7QUFBQTs7QUFDZCxTQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLMHFCLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBS0MsVUFBTDtBQUVBLFNBQUtDLFVBQUw7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBRUF4NEIsV0FBTyxDQUFDb04sR0FBUixDQUFZTyxJQUFJLENBQUNuWCxLQUFMLENBQVd0QixhQUFYLENBQXlCdUosU0FBekIsQ0FBbUN1UCxJQUFuQyxDQUF3QywwQkFBeEMsQ0FBWixFQUFpRixLQUFLTCxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JFLFVBQXhCLEVBQWpGLEVBQXVIc1UsSUFBdkgsRUFBNkgsSUFBN0g7QUFDQUEsUUFBSSxDQUFDblgsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QnVKLFNBQXpCLENBQW1DdVAsSUFBbkMsQ0FBd0MsMEJBQXhDLEVBQW9FeXFCLE1BQXBFLENBQTJFLEtBQUs5cUIsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCRSxVQUF4QixFQUEzRTtBQUNBLFNBQUtzVSxJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JFLFVBQXhCLENBQW1DdVYsU0FBbkMsQ0FBNkMsVUFBQzhwQixTQUFELEVBQWM7QUFDdkQvcUIsVUFBSSxDQUFDblgsS0FBTCxDQUFXdEIsYUFBWCxDQUF5QnVKLFNBQXpCLENBQW1DdVAsSUFBbkMsQ0FBd0MsMEJBQXhDLEVBQW9FeXFCLE1BQXBFLENBQTJFQyxTQUEzRTtBQUNILEtBRkQ7QUFHSDs7QUFkTDtBQUFBO0FBQUEsOEJBZ0JjdC9CLFFBaEJkLEVBZ0J3QnNxQixRQWhCeEIsRUFnQmtDO0FBQzFCLFVBQUksRUFBRXRxQixRQUFRLElBQUksS0FBS28vQixRQUFuQixDQUFKLEVBQWtDO0FBQzlCLGFBQUtBLFFBQUwsQ0FBY3AvQixRQUFkLElBQTBCLEVBQTFCO0FBQ0g7O0FBQ0QsV0FBS28vQixRQUFMLENBQWNwL0IsUUFBZCxFQUF3QmthLElBQXhCLENBQTZCb1EsUUFBN0I7QUFDSDtBQXJCTDtBQUFBO0FBQUEscUNBdUJxQnRxQixRQXZCckIsRUF1QitCO0FBQ3ZCLGFBQU8sS0FBS28vQixRQUFMLENBQWNwL0IsUUFBZCxDQUFQO0FBQ0g7QUF6Qkw7QUFBQTtBQUFBLGlDQTJCaUI7QUFBQTs7QUFDVCxVQUFJdS9CLFVBQVUsR0FBRyxJQUFqQjtBQUNBLE9BQUMsS0FBS2hyQixJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUE1QixFQUNDLEtBQUs4VSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkI0QyxrQkFENUIsRUFFQyxLQUFLNFYsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBRjVCLEVBRWtEd2YsT0FGbEQsQ0FFMEQsVUFBQXdoQixTQUFTO0FBQUEsZUFDL0RBLFNBQVMsQ0FBQ2hxQixTQUFWLENBQW9CLFVBQVNpcUIsT0FBVCxFQUFrQjtBQUNsQ0EsaUJBQU8sQ0FBQzNmLElBQVIsQ0FBYSxVQUFDeFQsS0FBRCxFQUFRb3pCLE1BQVI7QUFBQSxtQkFBbUJBLE1BQU0sQ0FBQzc5QixNQUFQLENBQWM4OUIsYUFBZCxDQUE0QnJ6QixLQUFLLENBQUN6SyxNQUFsQyxDQUFuQjtBQUFBLFdBQWIsRUFDS21jLE9BREwsQ0FDYSxVQUFVNGhCLE1BQVYsRUFBa0I7QUFDdkIsZ0JBQUlDLFNBQVMsR0FBR0QsTUFBTSxDQUFDMWlCLEtBQXZCOztBQUNBLGdCQUFJMGlCLE1BQU0sQ0FBQy85QixNQUFQLEtBQWtCLE9BQXRCLEVBQStCO0FBQzNCO0FBQ0Esa0JBQUl1TCxJQUFJLEdBQUdteUIsVUFBVSxDQUFDajRCLE9BQVgsQ0FBbUJ1NEIsU0FBUyxDQUFDNy9CLFFBQVYsRUFBbkIsRUFBeUM2L0IsU0FBUyxDQUFDendCLFFBQVYsRUFBekMsRUFBK0R5d0IsU0FBUyxDQUFDendCLFFBQXpFLENBQVg7QUFDQW13Qix3QkFBVSxDQUFDTyxhQUFYLENBQXlCMXlCLElBQXpCO0FBQ0gsYUFKRCxNQUlPLElBQUl3eUIsTUFBTSxDQUFDLzlCLE1BQVAsS0FBa0IsU0FBdEIsRUFBaUM7QUFDcEM7QUFDQSxrQkFBSXVMLEtBQUksR0FBR215QixVQUFVLENBQUN6VSxrQkFBWCxDQUE4QitVLFNBQVMsQ0FBQzcvQixRQUFWLEVBQTlCLENBQVg7O0FBQ0Esa0JBQUl1L0IsVUFBVSxDQUFDaHJCLElBQVgsQ0FBZ0JuWCxLQUFoQixDQUFzQjJDLE9BQXRCLENBQThCQyxRQUE5QixPQUE2QzYvQixTQUFTLENBQUM3L0IsUUFBVixFQUFqRCxFQUF1RTtBQUNuRXUvQiwwQkFBVSxDQUFDaHJCLElBQVgsQ0FBZ0JuWCxLQUFoQixDQUFzQjJDLE9BQXRCLENBQThCQyxRQUE5QixDQUF1QyxXQUF2QztBQUNIO0FBQ0o7QUFDSixXQWRMO0FBZUgsU0FoQkQsRUFnQkcsS0FoQkgsRUFnQlMsYUFoQlQsQ0FEK0Q7QUFBQSxPQUZuRTtBQXFCSCxLQWxETCxDQW9ESTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7Ozs7OztBQWhFSjtBQUFBO0FBQUEsaUNBcUVpQm9OLElBckVqQixFQXFFdUI7QUFDZixVQUFJQSxJQUFJLENBQUNwTixRQUFMLEtBQWtCLFdBQXRCLEVBQW1DO0FBQy9Cb04sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUtnRyxJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUF6QztBQUNILE9BRkQsTUFFTyxJQUFJNk4sSUFBSSxDQUFDcE4sUUFBTCxLQUFrQixZQUF0QixFQUFvQztBQUN2Q29OLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLZ0csSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0MsS0FBekM7QUFDSCxPQUZNLE1BRUEsSUFBSStPLElBQUksQ0FBQ3BOLFFBQUwsS0FBa0IsZUFBdEIsRUFBdUM7QUFDMUNvTixZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBS2dHLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnVDLFFBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUk4TyxJQUFJLENBQUNwTixRQUFMLEtBQWtCLGFBQXRCLEVBQXFDO0FBQ3hDb04sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUtnRyxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ3QyxNQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJNk8sSUFBSSxDQUFDcE4sUUFBTCxLQUFrQixrQkFBdEIsRUFBMEM7QUFDN0NvTixZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBS2dHLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQitCLFlBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUlzUCxJQUFJLENBQUNwTixRQUFMLEtBQWtCLG1CQUF0QixFQUEyQztBQUM5Q29OLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLZ0csSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCcUMsWUFBekM7QUFDSCxPQUZNLE1BRUEsSUFBSWdQLElBQUksQ0FBQ3BOLFFBQUwsS0FBa0Isb0JBQXRCLEVBQTRDO0FBQy9DLGFBQUsrL0IsZUFBTCxDQUFxQjN5QixJQUFyQixFQUEyQixLQUFLbUgsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQXREO0FBQ0gsT0FGTSxNQUVBLElBQUk0TyxJQUFJLENBQUNwTixRQUFMLEtBQWtCLGtCQUF0QixFQUEwQztBQUM3QyxhQUFLKy9CLGVBQUwsQ0FBcUIzeUIsSUFBckIsRUFBMkIsS0FBS21ILElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnlDLG9CQUF0RDtBQUNILE9BRk0sTUFFQSxJQUFJNE8sSUFBSSxDQUFDcE4sUUFBTCxLQUFrQixtQkFBdEIsRUFBMkM7QUFDOUMsYUFBSysvQixlQUFMLENBQXFCM3lCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ5QyxvQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSTRPLElBQUksQ0FBQ3BOLFFBQUwsS0FBa0IsbUJBQXRCLEVBQTJDO0FBQzlDLGFBQUsrL0IsZUFBTCxDQUFxQjN5QixJQUFyQixFQUEyQixLQUFLbUgsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQXREO0FBQ0gsT0FGTSxNQUVBLElBQUk0TyxJQUFJLENBQUNwTixRQUFMLEtBQWtCLGVBQXRCLEVBQXVDO0FBQzFDb04sWUFBSSxDQUFDbUIsTUFBTCxHQUFjLEtBQUtnRyxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJpRCxJQUF6QztBQUNILE9BRk0sTUFFQSxJQUFJb08sSUFBSSxDQUFDcE4sUUFBTCxLQUFrQiw4QkFBdEIsRUFBc0Q7QUFDekRvTixZQUFJLENBQUNtQixNQUFMLEdBQWMsS0FBS2dHLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnNELFFBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUkrTixJQUFJLENBQUNwTixRQUFMLEtBQWtCLDZCQUF0QixFQUFxRDtBQUN4RG9OLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLZ0csSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCa0QsaUJBQXpDO0FBQ0gsT0FGTSxNQUVBLElBQUltTyxJQUFJLENBQUNwTixRQUFMLEtBQWtCLG1CQUF0QixFQUEyQztBQUM5Q29OLFlBQUksQ0FBQ21CLE1BQUwsR0FBYyxLQUFLZ0csSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQTlCO0FBQ0gsT0FGTSxNQUVBLElBQUlxTixJQUFJLENBQUNwTixRQUFMLENBQWMyTyxVQUFkLENBQXlCLEdBQXpCLENBQUosRUFBbUM7QUFDdEMsYUFBS294QixlQUFMLENBQXFCM3lCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkI0QyxrQkFBdEQ7QUFDSCxPQUZNLE1BRUEsSUFBSXlPLElBQUksQ0FBQ3BOLFFBQUwsQ0FBYzJPLFVBQWQsQ0FBeUIsR0FBekIsS0FDQXZCLElBQUksQ0FBQ3BOLFFBQUwsQ0FBYzJPLFVBQWQsQ0FBeUIsR0FBekIsQ0FEQSxJQUVBdkIsSUFBSSxDQUFDcE4sUUFBTCxDQUFjMk8sVUFBZCxDQUF5QixHQUF6QixDQUZKLEVBRW1DO0FBQ3RDLGFBQUtveEIsZUFBTCxDQUFxQjN5QixJQUFyQixFQUEyQixLQUFLbUgsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQXREO0FBQ0gsT0FKTSxNQUlBO0FBQ0gsYUFBS3VoQyxlQUFMLENBQXFCM3lCLElBQXJCLEVBQTJCLEtBQUttSCxJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUF0RDtBQUNIO0FBQ0o7QUEzR0w7QUFBQTtBQUFBLG9DQTZHb0IyTixJQTdHcEIsRUE2RzBCNHlCLEtBN0cxQixFQTZHaUM7QUFDekI1eUIsVUFBSSxDQUFDdXhCLEtBQUwsR0FBYXFCLEtBQWI7QUFDQSxVQUFJQyxVQUFVLEdBQUc3eUIsSUFBSSxDQUFDdXhCLEtBQUwsRUFBakI7O0FBQ0EsV0FBSyxJQUFJOWhCLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR29qQixVQUFVLENBQUM1eUIsTUFBN0IsRUFBcUN3UCxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLFlBQUlvakIsVUFBVSxDQUFDcGpCLENBQUQsQ0FBVixDQUFjN2MsUUFBZCxPQUE2Qm9OLElBQUksQ0FBQ3BOLFFBQXRDLEVBQWdEO0FBQzVDb04sY0FBSSxDQUFDbUIsTUFBTCxHQUFjMHhCLFVBQVUsQ0FBQ3BqQixDQUFELENBQVYsQ0FBY3pOLFFBQTVCO0FBQ0g7QUFDSjs7QUFDRCxVQUFJaEMsSUFBSSxDQUFDbUIsTUFBTCxLQUFnQixJQUFwQixFQUEwQjtBQUN0QixZQUFJakgsT0FBTyxHQUFHNkgsYUFBYSxDQUFDL0IsSUFBSSxDQUFDcE4sUUFBTixDQUEzQjtBQUNBb04sWUFBSSxDQUFDbUIsTUFBTCxHQUFjakgsT0FBTyxDQUFDOEgsUUFBdEI7QUFDQTR3QixhQUFLLENBQUM5bEIsSUFBTixDQUFXNVMsT0FBWDtBQUNIO0FBQ0o7QUExSEw7QUFBQTtBQUFBLGlDQTRIaUI7QUFDVCxXQUFLQSxPQUFMLENBQWEsV0FBYjtBQUNBLFdBQUtBLE9BQUwsQ0FBYSxtQkFBYjtBQUNBLFdBQUtBLE9BQUwsQ0FBYSxZQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLGtCQUFiO0FBQ0EsV0FBS0EsT0FBTCxDQUFhLDhCQUFiO0FBQ0g7QUFsSUw7QUFBQTtBQUFBLHlDQW9JeUI7QUFDakIsV0FBSyxJQUFJN0osSUFBVCxJQUFpQixLQUFLd2hDLE1BQXRCLEVBQThCO0FBQzFCLFlBQUksS0FBS0EsTUFBTCxDQUFZOUssY0FBWixDQUEyQjEyQixJQUEzQixDQUFKLEVBQXNDO0FBQ2xDLGNBQUk4UixpQkFBaUIsQ0FBQ0MsT0FBbEIsQ0FBMEIvUixJQUExQixNQUFvQyxDQUFDLENBQXpDLEVBQTRDO0FBQ3hDLG1CQUFPLEtBQUt3aEMsTUFBTCxDQUFZeGhDLElBQVosQ0FBUDtBQUNBLG1CQUFPLEtBQUsyaEMsUUFBTCxDQUFjM2hDLElBQWQsQ0FBUDtBQUNIO0FBQ0o7QUFDSixPQVJnQixDQVNqQjs7QUFDSDtBQTlJTDtBQUFBO0FBQUEsNEJBZ0pZdUMsUUFoSlosRUFnSnNCb1AsUUFoSnRCLEVBZ0pnQ3l3QixTQWhKaEMsRUFnSjJDO0FBQ25DLFVBQUk3L0IsUUFBUSxJQUFJLEtBQUtpL0IsTUFBckIsRUFBNkI7QUFDekI7QUFDQSxZQUFJaUIsWUFBWSxHQUFHLEtBQUtqQixNQUFMLENBQVlqL0IsUUFBWixDQUFuQjs7QUFDQSxZQUFJNi9CLFNBQVMsS0FBSzNqQyxTQUFsQixFQUE2QjtBQUN6QixlQUFLaWtDLFlBQUwsQ0FBa0JELFlBQWxCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hBLHNCQUFZLENBQUMzeEIsTUFBYixHQUFzQnN4QixTQUF0QjtBQUNIOztBQUNESyxvQkFBWSxDQUFDM3hCLE1BQWIsQ0FBb0JhLFFBQVEsSUFBSSxFQUFoQztBQUNBLGVBQU84d0IsWUFBUDtBQUNILE9BVkQsTUFVTztBQUNIO0FBQ0EsWUFBSTU0QixPQUFPLEdBQUcsSUFBSW8zQixXQUFKLENBQWdCLEtBQUtucUIsSUFBckIsRUFBMkJ2VSxRQUEzQixDQUFkO0FBQ0EsYUFBS2kvQixNQUFMLENBQVlqL0IsUUFBWixJQUF3QnNILE9BQXhCOztBQUNBLFlBQUl1NEIsU0FBUyxLQUFLM2pDLFNBQWxCLEVBQTZCO0FBQ3pCLGVBQUtpa0MsWUFBTCxDQUFrQjc0QixPQUFsQjtBQUNILFNBRkQsTUFFTztBQUNIQSxpQkFBTyxDQUFDaUgsTUFBUixHQUFpQnN4QixTQUFqQjtBQUNIOztBQUNELFlBQUl6d0IsUUFBUSxLQUFLbFQsU0FBakIsRUFBNEI7QUFDeEJvTCxpQkFBTyxDQUFDaUgsTUFBUixDQUFlYSxRQUFmO0FBQ0g7O0FBQ0QsZUFBTzlILE9BQVA7QUFDSDtBQUNKO0FBektMO0FBQUE7QUFBQSw4QkEyS2N0SCxRQTNLZCxFQTJLd0JvUCxRQTNLeEIsRUEyS2tDO0FBQzFCQSxjQUFRLEdBQUdBLFFBQVEsSUFBSSxFQUF2QjtBQUNBLFdBQUs2dkIsTUFBTCxDQUFZai9CLFFBQVosRUFBc0J1TyxNQUF0QixDQUE2QmEsUUFBN0I7QUFDSDtBQTlLTDtBQUFBO0FBQUEsNkJBZ0xhcFAsUUFoTGIsRUFnTHVCO0FBQ2YsYUFBTyxLQUFLaS9CLE1BQUwsQ0FBWWovQixRQUFaLEVBQXNCdU8sTUFBdEIsRUFBUDtBQUNIO0FBbExMO0FBQUE7QUFBQSw0QkFvTFl2TyxRQXBMWixFQW9Mc0I7QUFDZCxhQUFPLEtBQUtpL0IsTUFBTCxDQUFZai9CLFFBQVosQ0FBUDtBQUNIO0FBRUQ7Ozs7OztBQXhMSjtBQUFBO0FBQUEsK0JBNkxlQSxRQTdMZixFQTZMeUI7QUFDakIsVUFBSXkrQixzQkFBc0IsQ0FBQ2p2QixPQUF2QixDQUErQnhQLFFBQS9CLE1BQTZDLENBQUMsQ0FBbEQsRUFBcUQ7QUFDakQsWUFBSW9OLElBQUksR0FBRyxLQUFLMGQsa0JBQUwsQ0FBd0I5cUIsUUFBeEIsQ0FBWDtBQUNBb04sWUFBSSxDQUFDbUIsTUFBTCxDQUFZLElBQVo7QUFDQSxlQUFPLElBQVA7QUFDSCxPQUpELE1BSU8sSUFBSSxLQUFLMHdCLE1BQUwsQ0FBWWovQixRQUFaLEVBQXNCMitCLEtBQXRCLEtBQWdDLElBQXBDLEVBQTBDO0FBQzdDLGVBQU8sS0FBUDtBQUNILE9BRk0sTUFFQTtBQUNIO0FBQ0EsWUFBSXJJLEtBQUssR0FBRyxLQUFLMkksTUFBTCxDQUFZai9CLFFBQVosRUFBc0IyK0IsS0FBdEIsQ0FBNEJwbkIsTUFBNUIsQ0FBbUMsVUFBQXNvQixTQUFTO0FBQUEsaUJBQUlBLFNBQVMsQ0FBQzcvQixRQUFWLE9BQXlCQSxRQUE3QjtBQUFBLFNBQTVDLENBQVo7QUFDQSxlQUFPczJCLEtBQUssSUFBSSxLQUFoQjtBQUNIO0FBQ0o7QUF6TUw7QUFBQTtBQUFBLHVDQTJNdUJ0MkIsUUEzTXZCLEVBMk1pQztBQUN6QixVQUFJb04sSUFBSSxHQUFHLEtBQUs2eEIsTUFBTCxDQUFZai9CLFFBQVosQ0FBWDtBQUNBLGFBQU8sS0FBS2kvQixNQUFMLENBQVlqL0IsUUFBWixDQUFQOztBQUNBLFVBQUlBLFFBQVEsSUFBSSxLQUFLby9CLFFBQXJCLEVBQStCO0FBQzNCLGFBQUtBLFFBQUwsQ0FBY3AvQixRQUFkLEVBQXdCZ2UsT0FBeEIsQ0FBZ0MsVUFBQXNNLFFBQVE7QUFBQSxpQkFBSUEsUUFBUSxDQUFDM0csT0FBVCxFQUFKO0FBQUEsU0FBeEM7QUFDSDs7QUFDRCxhQUFPdlcsSUFBUDtBQUNIO0FBbE5MO0FBQUE7QUFBQSwrQkFvTmUyYixNQXBOZixFQW9OdUJxWCxXQXBOdkIsRUFvTm9DO0FBQzVCLFVBQUkxd0IsaUJBQWlCLENBQUNGLE9BQWxCLENBQTBCdVosTUFBMUIsTUFBc0MsQ0FBQyxDQUEzQyxFQUE4QztBQUMxQyxlQUFPLEtBQVA7QUFDSCxPQUZELE1BRU8sSUFBSSxLQUFLa1csTUFBTCxDQUFZai9CLFFBQVosRUFBc0IyK0IsS0FBdEIsS0FBZ0MsSUFBcEMsRUFBMEM7QUFDN0MsZUFBTyxLQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0g7QUFDQSxZQUFJckksS0FBSyxHQUFHLEtBQUsySSxNQUFMLENBQVlqL0IsUUFBWixFQUFzQjIrQixLQUF0QixDQUE0QnBuQixNQUE1QixDQUFtQyxVQUFBc29CLFNBQVM7QUFBQSxpQkFBSUEsU0FBUyxDQUFDNy9CLFFBQVYsT0FBeUJBLFFBQTdCO0FBQUEsU0FBNUMsQ0FBWjtBQUNBLGVBQU9zMkIsS0FBSyxJQUFJLEtBQWhCO0FBQ0g7QUFDSjtBQTlOTDtBQUFBO0FBQUEsa0NBZ09rQmxwQixJQWhPbEIsRUFnT3dCO0FBQ2hCLFVBQUlBLElBQUksQ0FBQ3BOLFFBQUwsSUFBaUIsS0FBS28vQixRQUExQixFQUFvQztBQUNoQyxhQUFLQSxRQUFMLENBQWNoeUIsSUFBSSxDQUFDcE4sUUFBbkIsRUFBNkJnZSxPQUE3QixDQUFxQyxVQUFBc00sUUFBUTtBQUFBLGlCQUFJQSxRQUFRLENBQUM3RyxPQUFULENBQWlCclcsSUFBakIsQ0FBSjtBQUFBLFNBQTdDO0FBQ0g7QUFDSjtBQXBPTDtBQUFBO0FBQUEsa0NBc09rQjNQLElBdE9sQixFQXNPd0I0aUMsYUF0T3hCLEVBc091QztBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0EsVUFBSTVpQyxJQUFJLENBQUNrUixVQUFMLENBQWdCLElBQWhCLENBQUosRUFBMkI7QUFDdkJsUixZQUFJLEdBQUdBLElBQUksQ0FBQ21SLEtBQUwsQ0FBVyxDQUFYLENBQVA7QUFDSDs7QUFDRCxVQUFJMHhCLFVBQVUsR0FBR2pDLFdBQVcsQ0FBQ0MsVUFBN0IsQ0F6QitCLENBMEIvQjs7QUFDQSxVQUFJN2dDLElBQUksQ0FBQ2tSLFVBQUwsQ0FBZ0J3dkIsb0JBQWhCLENBQUosRUFBMkM7QUFDdkMxZ0MsWUFBSSxHQUFHQSxJQUFJLENBQUNtUixLQUFMLENBQVd1dkIsb0JBQW9CLENBQUM5d0IsTUFBaEMsQ0FBUDtBQUNBaXpCLGtCQUFVLEdBQUdqQyxXQUFXLENBQUNFLHFCQUF6QjtBQUNILE9BOUI4QixDQStCL0I7OztBQUNBLFVBQUk5Z0MsSUFBSSxDQUFDa1IsVUFBTCxDQUFnQnl2QixpQkFBaEIsQ0FBSixFQUF3QztBQUNwQzNnQyxZQUFJLEdBQUdBLElBQUksQ0FBQ21SLEtBQUwsQ0FBV3d2QixpQkFBaUIsQ0FBQy93QixNQUE3QixDQUFQO0FBQ0FpekIsa0JBQVUsR0FBR2pDLFdBQVcsQ0FBQ0csa0JBQXpCO0FBQ0gsT0FIRCxNQUdPLElBQUk2QixhQUFKLEVBQW1CO0FBQ3RCQyxrQkFBVSxHQUFHakMsV0FBVyxDQUFDRyxrQkFBekI7QUFDSCxPQXJDOEIsQ0FzQy9COzs7QUFDQSxVQUFJaHdCLGlCQUFpQixHQUFHLEtBQUsrRixJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ5RCxVQUEzQixFQUF4QjtBQUNBLFVBQUlqQixvQkFBb0IsR0FBRyxLQUFLK1YsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCeUMsb0JBQTNCLEVBQTNCO0FBQ0EsVUFBSUcsa0JBQWtCLEdBQUcsS0FBSzRWLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQjRDLGtCQUEzQixFQUF6QixDQXpDK0IsQ0EwQy9COztBQUNBLFVBQUk0aEMsV0FBVyxHQUFHLEtBQUtDLHNCQUFMLENBQTRCL2lDLElBQTVCLEVBQWtDNmlDLFVBQWxDLENBQWxCOztBQUNBLFVBQUlDLFdBQVcsS0FBS3JrQyxTQUFwQixFQUErQjtBQUMzQixlQUFPcWtDLFdBQVA7QUFDSCxPQTlDOEIsQ0ErQy9COzs7QUFDQSxVQUFJRSxjQUFjLEdBQUcsS0FBS0Msb0JBQUwsQ0FBMEJseUIsaUJBQTFCLEVBQTZDL1EsSUFBN0MsQ0FBckI7QUFDQSxVQUFJa2pDLGdCQUFnQixHQUFHLEtBQUtELG9CQUFMLENBQTBCbHlCLGlCQUExQixFQUE2QyxNQUFJL1EsSUFBakQsQ0FBdkI7QUFDQSxVQUFJbWpDLGNBQWMsR0FBRyxLQUFLRixvQkFBTCxDQUEwQmxpQyxvQkFBMUIsRUFBZ0QsTUFBSWYsSUFBcEQsQ0FBckI7QUFDQSxVQUFJb2pDLGFBQWEsR0FBRyxLQUFLSCxvQkFBTCxDQUEwQmxpQyxvQkFBMUIsRUFBZ0QsTUFBSWYsSUFBcEQsQ0FBcEI7O0FBQ0EsVUFBSTZpQyxVQUFVLEtBQUtqQyxXQUFXLENBQUNHLGtCQUEvQixFQUFtRDtBQUMvQyxlQUFPc0Msc0VBQWlCLENBQUNELGFBQUQsRUFBZ0JELGNBQWhCLEVBQWdDSCxjQUFoQyxFQUFnREUsZ0JBQWhELENBQXhCO0FBQ0g7O0FBQ0QsVUFBSUksaUJBQWlCLEdBQUcsS0FBS0wsb0JBQUwsQ0FBMEJsaUMsb0JBQTFCLEVBQWdELE1BQUlmLElBQXBELENBQXhCO0FBQ0EsVUFBSXVqQyxlQUFlLEdBQUcsS0FBS04sb0JBQUwsQ0FBMEIvaEMsa0JBQTFCLEVBQThDLE1BQUlsQixJQUFsRCxDQUF0Qjs7QUFDQSxVQUFJNmlDLFVBQVUsS0FBS2pDLFdBQVcsQ0FBQ0UscUJBQS9CLEVBQXNEO0FBQ2xELGVBQU91QyxzRUFBaUIsQ0FBQ0MsaUJBQUQsRUFBb0JGLGFBQXBCLEVBQW1DRyxlQUFuQyxFQUNDSixjQURELEVBQ2lCSCxjQURqQixFQUNpQ0UsZ0JBRGpDLENBQXhCO0FBRUgsT0FIRCxNQUdPLElBQUlMLFVBQVUsS0FBS2pDLFdBQVcsQ0FBQ0MsVUFBL0IsRUFBMkM7QUFDOUMsZUFBT3dDLHNFQUFpQixDQUFDRixjQUFELEVBQWlCSCxjQUFqQixFQUFpQ0UsZ0JBQWpDLEVBQ0NJLGlCQURELEVBQ29CRixhQURwQixFQUNtQ0csZUFEbkMsQ0FBeEI7QUFFSDtBQUNKO0FBdFNMO0FBQUE7QUFBQSx5Q0F3U3lCQyxTQXhTekIsRUF3U29DamhDLFFBeFNwQyxFQXdTOEM7QUFDdEMsV0FBSyxJQUFJNmMsQ0FBQyxHQUFDLENBQVgsRUFBY0EsQ0FBQyxHQUFHb2tCLFNBQVMsQ0FBQzV6QixNQUE1QixFQUFvQ3dQLENBQUMsRUFBckMsRUFBeUM7QUFDckMsWUFBSW9rQixTQUFTLENBQUNwa0IsQ0FBRCxDQUFULENBQWE3YyxRQUFiLE9BQTRCQSxRQUFoQyxFQUEwQztBQUN0QyxpQkFBT2loQyxTQUFTLENBQUNwa0IsQ0FBRCxDQUFoQjtBQUNIO0FBQ0o7O0FBQ0QsYUFBTzNnQixTQUFQO0FBQ0g7QUEvU0w7QUFBQTtBQUFBLDJDQWlUMkI4RCxRQWpUM0IsRUFpVHFDc2dDLFVBalRyQyxFQWlUaUQ7QUFDekMsVUFBSUEsVUFBVSxLQUFLakMsV0FBVyxDQUFDRyxrQkFBL0IsRUFBbUQ7QUFDL0MsWUFBSXgrQixRQUFRLEtBQUssV0FBakIsRUFBOEI7QUFDMUIsaUJBQU80K0IsaUJBQWlCLENBQUMsdUJBQUQsRUFBMEIsS0FBS3JxQixJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkJ1RCxJQUEzQixFQUExQixDQUF4QjtBQUNIOztBQUNELGVBQU9yRCxTQUFQO0FBQ0g7O0FBQ0QsY0FBUThELFFBQVI7QUFDSSxhQUFLLFdBQUw7QUFDSSxpQkFBTzQrQixpQkFBaUIsQ0FBQyx1QkFBRCxFQUEwQixLQUFLcnFCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFoQixDQUEyQnVELElBQTNCLEVBQTFCLENBQXhCOztBQUNKLGFBQUssV0FBTDtBQUNJLGlCQUFPcS9CLGlCQUFpQixDQUFDLHVCQUFELEVBQTBCLEtBQUtycUIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCc0MsS0FBM0IsRUFBMUIsQ0FBeEI7O0FBQ0osYUFBSyxjQUFMO0FBQ0ksaUJBQU91Z0MsaUJBQWlCLENBQUMsMEJBQUQsRUFBNkIsS0FBS3JxQixJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBaEIsQ0FBMkJ1QyxRQUEzQixFQUE3QixDQUF4Qjs7QUFDSixhQUFLLFlBQUw7QUFDSSxpQkFBT3NnQyxpQkFBaUIsQ0FBQyx3QkFBRCxFQUEyQixLQUFLcnFCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQndDLE1BQTNCLEVBQTNCLENBQXhCOztBQUNKLGFBQUssaUJBQUw7QUFDSSxpQkFBT3FnQyxpQkFBaUIsQ0FBQyw2QkFBRCxFQUFnQyxLQUFLcnFCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQitCLFlBQTNCLEVBQWhDLENBQXhCOztBQUNKLGFBQUssa0JBQUw7QUFDSSxpQkFBTzhnQyxpQkFBaUIsQ0FBQyw4QkFBRCxFQUFpQyxLQUFLcnFCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JyQixVQUFoQixDQUEyQnFDLFlBQTNCLEVBQWpDLENBQXhCO0FBWlI7O0FBY0EsYUFBT2xDLFNBQVA7QUFDSDtBQXZVTDtBQUFBO0FBQUEsa0NBeVVrQmdsQyxJQXpVbEIsRUF5VXdCO0FBQUE7O0FBQ2hCLFVBQUl2aEIsSUFBSSxHQUFHaGEsQ0FBQyxDQUFDcTRCLCtCQUFELENBQVo7QUFDQSxVQUFJaCtCLFFBQVEsR0FBRzJmLElBQUksQ0FBQy9LLElBQUwsQ0FBVSwwQ0FBVixDQUFmO0FBQ0EsVUFBSXVzQixRQUFRLEdBQUd4aEIsSUFBSSxDQUFDL0ssSUFBTCxDQUFVLDBDQUFWLENBQWY7QUFDQSxVQUFJd3NCLFNBQVMsR0FBR3poQixJQUFJLENBQUMvSyxJQUFMLENBQVUsMkNBQVYsQ0FBaEI7QUFDQSxVQUFJeXNCLGNBQWMsR0FBRyxpQkFBckI7QUFDQXJoQyxjQUFRLENBQUNpaEIsRUFBVCxDQUFZLE9BQVosRUFBcUIsWUFBTTtBQUN2QixZQUFJdUIsU0FBUyxHQUFHNmUsY0FBYyxDQUFDQyxJQUFmLENBQW9CdGhDLFFBQVEsQ0FBQytULEdBQVQsRUFBcEIsRUFBb0MsQ0FBcEMsQ0FBaEI7QUFDQXlPLGlCQUFTLEdBQUdBLFNBQVMsS0FBS3RtQixTQUFkLEdBQTBCLGNBQTFCLEdBQTJDc21CLFNBQXZELENBRnVCLENBR3ZCOztBQUNBMmUsZ0JBQVEsQ0FBQzNzQixJQUFULENBQWNnTyxTQUFkO0FBQ0gsT0FMRDs7QUFNQSxVQUFJN0IsR0FBRyxHQUFHLFNBQU5BLEdBQU0sR0FBTTtBQUNaLFlBQUk0Z0IsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsWUFBSUwsSUFBSSxLQUFLLFlBQWIsRUFBMkI7QUFDdkJLLGdCQUFNLEdBQUdILFNBQVMsQ0FBQ3J0QixHQUFWLEVBQVQ7QUFDSCxTQUZELE1BRU8sSUFBSW10QixJQUFJLEtBQUssVUFBYixFQUF5QjtBQUM1QkssZ0JBQU0sR0FBRyxHQUFUO0FBQ0g7O0FBRUQsWUFBSXZoQyxRQUFRLENBQUMrVCxHQUFULEVBQUosRUFBb0I7QUFDaEIvVCxrQkFBUSxHQUFHdWhDLE1BQU0sR0FBQ3ZoQyxRQUFRLENBQUMrVCxHQUFULEVBQWxCOztBQUNBLGdCQUFJLENBQUN6TSxPQUFMLENBQWF0SCxRQUFiO0FBQ0g7QUFDSixPQVpEOztBQWFBMmYsVUFBSSxDQUFDNmhCLE1BQUwsQ0FBWSxVQUFDaHVCLENBQUQsRUFBTztBQUNmQSxTQUFDLENBQUNpdUIsY0FBRjtBQUNBOWdCLFdBQUc7O0FBQ0gsY0FBSSxDQUFDcE0sSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCd1gsS0FBNUI7QUFDSCxPQUpEO0FBS0EsV0FBS3ZNLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFyQixDQUE0QjRYLE9BQTVCLENBQW9DLGVBQXBDLEVBQXFEdkIsSUFBckQsRUFBMkRnQixHQUEzRCxFQUFnRSxZQUFJLENBQUUsQ0FBdEUsRUFBd0UsS0FBeEU7QUFDSDtBQXhXTDs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7QUNoU0E7QUFBQTtBQUFBO0FBQ08sSUFBSStnQixXQUFXLGszRUFBZixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEUDtBQUVPLElBQU1qWixvQkFBb0IsMDRDQUExQjtBQThCUDs7Ozs7Ozs7O0FBUU8sSUFBTXBULGNBQWI7QUFDSSwwQkFBWWQsSUFBWixFQUFrQm1HLEdBQWxCLEVBQXVCO0FBQUE7O0FBQ25CLFNBQUtuRyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLbUcsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBS2luQixTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBSzV3QixPQUFMLEdBQWUsRUFBZjtBQUNBLFNBQUs2d0IsVUFBTCxHQUFrQixFQUFsQjtBQUNIOztBQVBMO0FBQUE7QUFBQSx5QkFTUzd3QixPQVRULEVBU2tCO0FBQUE7O0FBQ1YsV0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsV0FBSzZ3QixVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsV0FBS0MsUUFBTCxHQUFnQmw4QixDQUFDLENBQUMsMkJBQUQsQ0FBRCxDQUErQnlWLEtBQS9CLEVBQWhCO0FBQ0EsVUFBSTBtQixNQUFNLEdBQUcsQ0FBYjtBQUNBL3dCLGFBQU8sQ0FDRjZULE1BREwsQ0FDWSxVQUFDbWQsS0FBRDtBQUFBLGVBQ0osQ0FBQ0EsS0FBSyxDQUFDQyxTQUFOLENBQWdCcnpCLFVBQWhCLENBQTJCLGNBQTNCLENBQUQsSUFDSW96QixLQUFLLENBQUNFLFVBQU4sS0FBcUIsU0FEekIsSUFFSUYsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLGNBRnpCLEtBR0ssQ0FBQyxLQUFJLENBQUMxdEIsSUFBTCxDQUFVblgsS0FBVixDQUFnQnJCLFVBQWhCLENBQTJCb0QsTUFBM0IsRUFBRCxJQUF3QzRpQyxLQUFLLENBQUNFLFVBQU4sS0FBcUIsa0JBSGxFLENBREk7QUFBQSxPQURaLEVBT0tqa0IsT0FQTCxDQU9hLFVBQUMrakIsS0FBRCxFQUFRaHdCLEtBQVIsRUFBa0I7QUFDdkIsWUFBSWt3QixVQUFVLEdBQUdDLGlCQUFpQixDQUFDSCxLQUFLLENBQUNFLFVBQVAsQ0FBakIsSUFBdUNGLEtBQUssQ0FBQ0UsVUFBOUQ7QUFDQSxZQUFJRSxTQUFTLEdBQUdDLG1CQUFtQixDQUFDTCxLQUFLLENBQUNNLGdCQUFQLENBQW5CLEdBQTZDLEtBQTdDLEdBQW1ESixVQUFuRTtBQUNBLFlBQUlLLE9BQU8sR0FBSVAsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLFdBQXBDO0FBQ0EsWUFBSU0sTUFBTSxHQUFHNThCLENBQUMsQ0FBQyxtQkFBRCxFQUFzQjtBQUFDNk8sY0FBSSxFQUFFMnRCLFNBQVA7QUFBa0JLLGtCQUFRLEVBQUVGO0FBQTVCLFNBQXRCLENBQWQ7O0FBQ0EsWUFBSSxLQUFJLENBQUNHLFdBQUwsQ0FBaUJWLEtBQWpCLENBQUosRUFBNkI7QUFDekJRLGdCQUFNLENBQUNqbUIsSUFBUCxDQUFZLE9BQVosRUFBcUJ3bEIsTUFBckI7O0FBQ0EsZUFBSSxDQUFDRixVQUFMLENBQWdCMW5CLElBQWhCLENBQXFCNm5CLEtBQXJCOztBQUNBRCxnQkFBTSxJQUFJLENBQVY7QUFDSDs7QUFDRCxhQUFJLENBQUNELFFBQUwsQ0FBY3hwQixNQUFkLENBQXFCa3FCLE1BQXJCO0FBQ0gsT0FsQkw7QUFtQkEsV0FBS1YsUUFBTCxDQUFjOXRCLEdBQWQsQ0FBa0J0SCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlvMUIsTUFBTSxHQUFDLENBQW5CLENBQWxCO0FBQ0EsV0FBS0QsUUFBTCxDQUFjakMsTUFBZCxDQUFxQixVQUFDOEMsR0FBRCxFQUFTO0FBQzFCLGFBQUksQ0FBQ2h5QixZQUFMO0FBQ0gsT0FGRDtBQUdIO0FBckNMO0FBQUE7QUFBQSxrQ0F1Q2tCO0FBQ1YsV0FBS214QixRQUFMLENBQWM5dEIsR0FBZCxDQUFrQixDQUFsQjtBQUNBLFdBQUtyRCxZQUFMO0FBQ0g7QUExQ0w7QUFBQTtBQUFBLG1DQTRDbUI7QUFDWCxVQUFJaXhCLFNBQVMsR0FBRy9PLFFBQVEsQ0FBQyxLQUFLaVAsUUFBTCxDQUFjOXRCLEdBQWQsRUFBRCxFQUFzQixFQUF0QixDQUF4QjtBQUNBLFdBQUs4dEIsUUFBTCxDQUFjOXRCLEdBQWQsQ0FBa0J0SCxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlpMUIsU0FBUyxHQUFDLENBQXRCLENBQWxCO0FBQ0EsV0FBS2p4QixZQUFMO0FBQ0g7QUFoREw7QUFBQTtBQUFBLCtCQWtEZTtBQUNQLFVBQUlpeEIsU0FBUyxHQUFHL08sUUFBUSxDQUFDLEtBQUtpUCxRQUFMLENBQWM5dEIsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsV0FBSzh0QixRQUFMLENBQWM5dEIsR0FBZCxDQUFrQnRILElBQUksQ0FBQ0ksR0FBTCxDQUFTLEtBQUsrMEIsVUFBTCxDQUFnQnYwQixNQUFoQixHQUF1QixDQUFoQyxFQUFtQ3MwQixTQUFTLEdBQUMsQ0FBN0MsQ0FBbEI7QUFDQSxXQUFLanhCLFlBQUw7QUFDSDtBQXRETDtBQUFBO0FBQUEsdUNBd0R1QjtBQUNmLFdBQUtteEIsUUFBTCxDQUFjOXRCLEdBQWQsQ0FBa0IsS0FBSzZ0QixVQUFMLENBQWdCdjBCLE1BQWhCLEdBQXVCLENBQXpDO0FBQ0EsV0FBS3FELFlBQUw7QUFDSDtBQTNETDtBQUFBO0FBQUEsbUNBNkRtQjtBQUNYLFVBQUksS0FBS2t4QixVQUFMLENBQWdCdjBCLE1BQXBCLEVBQTRCO0FBQ3hCLFlBQUlzMEIsU0FBUyxHQUFHL08sUUFBUSxDQUFDLEtBQUtpUCxRQUFMLENBQWM5dEIsR0FBZCxFQUFELEVBQXNCLEVBQXRCLENBQXhCO0FBQ0EsYUFBS1EsSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQzRpQixPQUFyQyxDQUE2QyxLQUFLNlcsVUFBTCxDQUFnQkQsU0FBaEIsRUFBMkIvOEIsT0FBeEU7QUFDSDtBQUNKO0FBbEVMO0FBQUE7QUFBQSwwQkFvRVU7QUFDRixVQUFJLEtBQUtnOUIsVUFBTCxDQUFnQnYwQixNQUFwQixFQUE0QjtBQUN4QixZQUFJczBCLFNBQVMsR0FBRy9PLFFBQVEsQ0FBQyxLQUFLaVAsUUFBTCxDQUFjOXRCLEdBQWQsRUFBRCxFQUFzQixFQUF0QixDQUF4QjtBQUNBLFlBQUl4VSxJQUFJLEdBQUcsS0FBS3FpQyxVQUFMLENBQWdCRCxTQUFoQixFQUEyQi84QixPQUF0QztBQUNBLGFBQUsyUCxJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJzRyxPQUFuQixDQUEyQm1CLE1BQTNCLENBQWtDUyxrQkFBbEM7QUFDQSxhQUFLOEQsSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDa0YsSUFBbEMsQ0FBdUNtQixNQUF2QyxDQUE4Q2hQLElBQTlDO0FBQ0g7QUFDSjtBQTNFTDtBQUFBO0FBQUEsZ0NBNkVnQndpQyxLQTdFaEIsRUE2RXVCO0FBQ2YsYUFBUSxDQUFDQSxLQUFLLENBQUNFLFVBQU4sS0FBcUIsV0FBckIsSUFDQUYsS0FBSyxDQUFDRSxVQUFOLEtBQXFCLGFBRHRCLEtBRUEsS0FBSzF0QixJQUFMLENBQVVuWCxLQUFWLENBQWdCMkMsT0FBaEIsQ0FBd0JDLFFBQXhCLE9BQXVDK2hDLEtBQUssQ0FBQ0MsU0FGckQ7QUFHSDtBQWpGTDs7QUFBQTtBQUFBO0FBcUZBLElBQU1FLGlCQUFpQixHQUFHO0FBQ3RCLG1CQUFpQixlQURLO0FBRXRCLGlCQUFlLG9CQUZPO0FBR3RCLGVBQWEsYUFIUztBQUl0QixpQkFBZSxvQkFKTztBQUt0QixpQkFBZSxhQUxPO0FBTXRCLG1CQUFpQixjQU5LO0FBT3RCLHNCQUFvQjtBQVBFLENBQTFCO0FBVUEsSUFBTVMsVUFBVSxHQUFHLENBQ2YsS0FEZSxFQUNSLEtBRFEsRUFDRCxLQURDLEVBRWYsS0FGZSxFQUVSLEtBRlEsRUFFRCxNQUZDLEVBRU8sTUFGUCxFQUdmLEtBSGUsRUFHUixNQUhRLEVBR0EsS0FIQSxFQUlmLEtBSmUsRUFJUixLQUpRLENBQW5CO0FBTUEsSUFBTUMsUUFBUSxHQUFHLENBQ2IsS0FEYSxFQUNOLEtBRE0sRUFDQyxLQURELEVBRWIsS0FGYSxFQUVOLEtBRk0sRUFFQyxLQUZELEVBR2IsS0FIYSxDQUFqQjs7QUFNQSxTQUFTQyxTQUFULENBQW1CdjJCLEtBQW5CLEVBQTBCb3pCLE1BQTFCLEVBQWtDO0FBQzlCLFNBQU9wekIsS0FBSyxDQUFDdzJCLE9BQU4sT0FBb0JwRCxNQUFNLENBQUNvRCxPQUFQLEVBQXBCLElBQ0h4MkIsS0FBSyxDQUFDeTJCLFFBQU4sT0FBcUJyRCxNQUFNLENBQUNxRCxRQUFQLEVBRGxCLElBRUh6MkIsS0FBSyxDQUFDMDJCLFdBQU4sT0FBd0J0RCxNQUFNLENBQUNzRCxXQUFQLEVBRjVCO0FBR0g7QUFFRDs7Ozs7Ozs7QUFNQSxTQUFTWixtQkFBVCxDQUE2QmEsVUFBN0IsRUFBeUM7QUFDckM7Ozs7OztBQU1BO0FBQ0EsTUFBSUEsVUFBVSxLQUFLL21DLFNBQW5CLEVBQThCO0FBQzFCLFdBQU8sZ0JBQVA7QUFDSDs7QUFDRCxNQUFJZ25DLEdBQUcsR0FBRyxJQUFJQyxJQUFKLEVBQVY7QUFDQSxNQUFJQyxJQUFJLEdBQUcsSUFBSUQsSUFBSixDQUFTdlEsUUFBUSxDQUFDcVEsVUFBRCxFQUFhLEVBQWIsQ0FBakIsQ0FBWDs7QUFDQSxNQUFJSixTQUFTLENBQUNLLEdBQUQsRUFBTUUsSUFBTixDQUFiLEVBQTBCO0FBQ3RCLFdBQU8sY0FBWUEsSUFBSSxDQUFDQyxrQkFBTCxFQUFuQjtBQUNILEdBRkQsTUFFTztBQUNILFFBQUlDLE1BQU0sR0FBR1YsUUFBUSxDQUFDUSxJQUFJLENBQUNHLE1BQUwsRUFBRCxDQUFyQjtBQUNBLFFBQUlDLFFBQVEsR0FBR2IsVUFBVSxDQUFDUyxJQUFJLENBQUNMLFFBQUwsRUFBRCxDQUF6QjtBQUNBLFFBQUlVLElBQUksR0FBR0gsTUFBTSxHQUFHLElBQVQsR0FBZ0JFLFFBQWhCLEdBQTJCLEdBQTNCLEdBQWlDSixJQUFJLENBQUNOLE9BQUwsRUFBNUM7O0FBQ0EsUUFBSUksR0FBRyxDQUFDRixXQUFKLE9BQXNCSSxJQUFJLENBQUNKLFdBQUwsRUFBMUIsRUFBOEM7QUFDMUMsYUFBT1MsSUFBSSxHQUFHLE1BQVAsR0FBY0wsSUFBSSxDQUFDQyxrQkFBTCxFQUFyQjtBQUNILEtBRkQsTUFFTztBQUNILGFBQU9JLElBQUksR0FBRyxJQUFQLEdBQVlMLElBQUksQ0FBQ0osV0FBTCxFQUFaLEdBQWlDLE1BQWpDLEdBQXdDSSxJQUFJLENBQUNDLGtCQUFMLEVBQS9DO0FBQ0g7QUFDSjtBQUNKO0FBR0Q7Ozs7Ozs7QUFLQWh1QixjQUFjLENBQUNYLFNBQWYsQ0FBeUIzRSxVQUF6QixHQUFzQyxZQUFXO0FBQzdDLE1BQUl6RyxNQUFNLEdBQUcsS0FBS2lMLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFsQztBQUNBLE1BQUlxVyxJQUFJLEdBQUcsa0JBQVg7QUFDQSxPQUFLcEwsSUFBTCxDQUFVek8sVUFBVixDQUFxQkMsTUFBckIsQ0FBNEIyOUIsVUFBNUIsQ0FBdUMsVUFBVS84QixJQUFWLEVBQWdCO0FBQ25EZ1osUUFBSSxHQUFHaFosSUFBSSxDQUFDZzlCLE9BQUwsR0FBZUMsTUFBZixDQUFzQixVQUFVQyxRQUFWLEVBQW9CQyxJQUFwQixFQUEwQjtBQUNuRCxVQUFJQyxZQUFZLEdBQUczQixtQkFBbUIsQ0FBQzBCLElBQUksQ0FBQ0UsSUFBTixDQUF0QztBQUNBLFVBQUlDLFFBQVEsR0FBRyxRQUFNRixZQUFOLEdBQW1CLGVBQW5CLEdBQW1DRCxJQUFJLENBQUN2a0MsSUFBeEMsR0FBNkMsUUFBNUQ7QUFDQSxhQUFPc2tDLFFBQVEsR0FBQyxJQUFULEdBQWNJLFFBQXJCO0FBQ0gsS0FKTSxFQUlKLEVBSkksQ0FBUDtBQUtBMzZCLFVBQU0sQ0FBQ2dNLElBQVAsQ0FBWSxjQUFaLEVBQTRCcUssSUFBNUIsRUFBa0MsWUFBVyxDQUFFLENBQS9DO0FBQ0gsR0FQRDtBQVFILENBWEQsQzs7Ozs7Ozs7Ozs7OztBQ2hNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJTyxJQUFJL2UsMkJBQTJCLEdBQUc7QUFDckNDLFVBQVEsRUFBRSxVQUQyQjtBQUVyQ29LLE9BQUssRUFBRSxPQUY4QjtBQUdyQ0ssTUFBSSxFQUFFO0FBSCtCLENBQWxDO0FBTVA7Ozs7OztBQUtPLFNBQVM0SSwrQkFBVCxDQUF5QzVMLElBQXpDLEVBQStDbEwsS0FBL0MsRUFBc0Q7QUFDekQ7QUFDQSxNQUFJOG1DLGdCQUFnQixHQUFHLElBQXZCO0FBQ0E5bUMsT0FBSyxDQUFDbUwsRUFBTixDQUFTekssWUFBVCxDQUFzQjhLLE9BQXRCLENBQThCNE0sU0FBOUIsQ0FBd0MsWUFBTTtBQUMxQyxRQUFJMHVCLGdCQUFnQixLQUFLLElBQXpCLEVBQStCO0FBQzNCeE4sa0JBQVksQ0FBQ3dOLGdCQUFELENBQVo7QUFDSDs7QUFDREEsb0JBQWdCLEdBQUczYyxVQUFVLENBQUMsWUFBTTtBQUNoQ25xQixXQUFLLENBQUN0QixhQUFOLENBQW9CdUosU0FBcEIsQ0FBOEJ1UCxJQUE5QixDQUFtQyxnQ0FBbkMsRUFBcUUzRixHQUFyRSxDQUEwRSxVQUFDNE4sQ0FBRCxFQUFJOGUsS0FBSixFQUFjO0FBQ3BGL1ksY0FBTSxDQUFDZ1osSUFBUCxDQUFZQyxjQUFaLENBQTJCRixLQUEzQjtBQUNILE9BRkQ7QUFHSCxLQUo0QixFQUkxQixHQUowQixDQUE3QjtBQUtILEdBVEQsRUFIeUQsQ0FhekQ7O0FBQ0F2K0IsT0FBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5Qm9VLFNBQXpCLENBQW1DLFVBQUMydUIsWUFBRCxFQUFrQjtBQUNqRDc3QixRQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnZELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQzJoQyxZQUFZLENBQUN6aUMsUUFBYixFQURoQyxFQUN5RCxFQUR6RDs7QUFFQSxRQUFJeWlDLFlBQUosRUFBa0I7QUFDZDtBQUNBL21DLFdBQUssQ0FBQ3RCLGFBQU4sQ0FBb0J1SixTQUFwQixDQUE4QjZOLE1BQTlCLEdBQXVDLENBQXZDLEVBQTBDa3hCLGlCQUExQyxZQUFvRSxVQUFBakgsR0FBRyxFQUFJO0FBQ3ZFLFlBQUl2NEIsT0FBTywwREFBbUR1NEIsR0FBRyxDQUFDdjRCLE9BQXZELGVBQW1FdTRCLEdBQUcsQ0FBQzEvQixJQUF2RSxNQUFYO0FBQ0E2SyxZQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnZELFFBQXZCLENBQWdDLDRCQUFoQyxFQUE4RCxFQUE5RCxFQUFrRSxFQUFsRSxFQUNnQ29DLE9BRGhDLEVBQzBDLEVBRDFDO0FBRUFzRixhQUFLLENBQUN0RixPQUFELENBQUw7QUFDSCxPQUxELEVBS0crckIsSUFMSCxDQUtRLFlBQU07QUFDVnJvQixZQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnZELFFBQXZCLENBQWdDLDhCQUFoQyxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUNnQyxFQURoQyxFQUNvQyxFQURwQztBQUVBcEYsYUFBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixJQUF6QjtBQUNBaEUsYUFBSyxDQUFDdEIsYUFBTixDQUFvQnVKLFNBQXBCLENBQThCaTNCLEdBQTlCLENBQWtDLFlBQWxDLEVBQWdELE1BQWhEO0FBQ0gsT0FWRDtBQVdILEtBYkQsTUFhTztBQUNIbmtCLGNBQVEsQ0FBQ2tzQixjQUFULEdBQTBCMVQsSUFBMUIsQ0FBK0IsWUFBTTtBQUNqQ3JvQixZQUFJLENBQUN4QyxVQUFMLENBQWdCQyxNQUFoQixDQUF1QnZELFFBQXZCLENBQWdDLDJCQUFoQyxFQUE2RCxFQUE3RCxFQUFpRSxFQUFqRSxFQUNnQzJoQyxZQUFZLENBQUN6aUMsUUFBYixFQURoQyxFQUN5RCxFQUR6RDtBQUVBdEUsYUFBSyxDQUFDMkMsT0FBTixDQUFjcUIsVUFBZCxDQUF5QixLQUF6QjtBQUNILE9BSkQ7QUFLSDtBQUNKLEdBdkJEO0FBd0JILEMsQ0FFRDs7QUFFTyxTQUFTc0UsYUFBVCxDQUF1QjZPLElBQXZCLEVBQTZCO0FBQ2hDLCtGQUlFOEwscURBSkYsZ3JKQTBHRTBkLG1EQTFHRixxUkFvSE0zbkIsdURBcEhOLDBHQXVITXNrQix5REF2SE4sMEhBMkhNNEosbURBM0hOLDJMQW1JRXZHLG1EQW5JRix5RUF1SUVsUCx1REF2SUYseUpBK0lNNlMscURBL0lOO0FBcUpILEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbk9EO0FBQ0E7QUFFQTs7Ozs7QUFJTyxJQUFJMy9CLFdBQVcsR0FBRztBQUNyQkMsT0FBSyxFQUFFLE9BRGM7QUFFckI0SixRQUFNLEVBQUUsUUFGYTtBQUdyQjI0QixVQUFRLEVBQUUsVUFIVztBQUlyQmhZLFFBQU0sRUFBRSxRQUphO0FBS3JCaVksU0FBTyxFQUFFO0FBTFksQ0FBbEI7QUFRUDs7Ozs7Ozs7O0FBUU8sU0FBU3J2QixhQUFULENBQXVCWixJQUF2QixFQUE2QjtBQUNoQyxPQUFLQSxJQUFMLEdBQVlBLElBQVosQ0FEZ0MsQ0FHaEM7O0FBQ0EsT0FBS2pQLElBQUwsR0FBWWlQLElBQUksQ0FBQ25YLEtBQUwsQ0FBV3RCLGFBQVgsQ0FBeUJ3SixJQUFyQyxDQUpnQyxDQU1oQzs7QUFDQSxPQUFLbS9CLE9BQUwsR0FBZSxJQUFJdG5DLDREQUFKLENBQXdCLFNBQXhCLENBQWYsQ0FQZ0MsQ0FTaEM7O0FBQ0EsT0FBS3VuQyxLQUFMLEdBQWE7QUFDVCxnQkFBWWgzQixJQUFJLENBQUNnRyxLQUFMLENBQVcsS0FBSyt3QixPQUFMLENBQWFFLFVBQWIsQ0FBd0IsVUFBeEIsRUFBb0MsSUFBcEMsQ0FBWCxDQURIO0FBRVQsd0JBQW9CajNCLElBQUksQ0FBQ2dHLEtBQUwsQ0FBVyxLQUFLK3dCLE9BQUwsQ0FBYUUsVUFBYixDQUF3QixrQkFBeEIsRUFBNEMsSUFBNUMsQ0FBWDtBQUZYLEdBQWI7QUFJQSxPQUFLQyxjQUFMLEdBQXNCO0FBQ2xCLGdCQUFZLEdBRE07QUFFbEIsd0JBQW9CO0FBRkYsR0FBdEI7QUFLQSxPQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsT0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUVBLE9BQUtDLE1BQUwsR0FBYyxFQUFkO0FBRUEsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLQyxnQkFBTCxHQUF3QixDQUF4QjtBQUVBLE9BQUtDLGVBQUwsR0FBdUIsRUFBdkI7QUFDQSxPQUFLQyxtQkFBTDtBQUNBLE9BQUtDLFdBQUw7QUFFQSxPQUFLcnZCLFdBQUwsR0FBbUIsSUFBbkI7QUFDSDtBQUVEOzs7OztBQUlBWixhQUFhLENBQUNULFNBQWQsQ0FBd0Iyd0IsT0FBeEIsR0FBa0MsVUFBVXgwQixRQUFWLEVBQW9CO0FBQ2xELE1BQUlBLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQixRQUFJLEtBQUsyekIsT0FBTCxDQUFheG5DLEdBQWIsQ0FBaUIsSUFBakIsQ0FBSixFQUE0QjtBQUN4QixVQUFJcW9DLEtBQUssR0FBRyxLQUFLYixPQUFMLENBQWF2bkMsR0FBYixDQUFpQixJQUFqQixDQUFaOztBQUNBLFVBQUlvb0MsS0FBSyxLQUFLejBCLFFBQVEsQ0FBQzAwQixFQUF2QixFQUEyQjtBQUN2QixZQUFJM2dDLE9BQU8sR0FBRzhJLElBQUksQ0FBQ0MsU0FBTCxDQUFlO0FBQ3pCLGlCQUFPMjNCLEtBRGtCO0FBRXpCLGlCQUFPejBCLFFBQVEsQ0FBQzAwQjtBQUZTLFNBQWYsQ0FBZDs7QUFJQSxZQUFJLEtBQUt4dkIsV0FBVCxFQUFzQjtBQUNsQixlQUFLQSxXQUFMLENBQWlCLGFBQWpCLEVBQWdDN1osU0FBaEMsRUFBMkNBLFNBQTNDLEVBQXNEMEksT0FBdEQ7QUFDSCxTQUZELE1BRU87QUFDSCxlQUFLcEMsUUFBTCxDQUFjLGFBQWQsRUFBNkJ0RyxTQUE3QixFQUF3Q0EsU0FBeEMsRUFBbUQwSSxPQUFuRDtBQUNIOztBQUNELGFBQUs2L0IsT0FBTCxDQUFhZSxHQUFiLENBQWlCLElBQWpCLEVBQXVCMzBCLFFBQVEsQ0FBQzAwQixFQUFoQztBQUNIO0FBQ0osS0FkRCxNQWNPO0FBQ0gsV0FBS2QsT0FBTCxDQUFhZSxHQUFiLENBQWlCLElBQWpCLEVBQXVCMzBCLFFBQVEsQ0FBQzAwQixFQUFoQztBQUNIO0FBQ0o7QUFDSixDQXBCRDtBQXNCQTs7Ozs7O0FBSUFwd0IsYUFBYSxDQUFDVCxTQUFkLENBQXdCMHdCLFdBQXhCLEdBQXNDLFlBQVk7QUFBQTs7QUFDOUMsTUFBSSxLQUFLWCxPQUFMLENBQWF4bkMsR0FBYixDQUFpQixnQkFBakIsQ0FBSixFQUF3QztBQUNwQyxRQUFJMEosSUFBSSxHQUFHK0csSUFBSSxDQUFDZ0csS0FBTCxDQUFXLEtBQUsrd0IsT0FBTCxDQUFhdm5DLEdBQWIsQ0FBaUIsZ0JBQWpCLENBQVgsQ0FBWDs7QUFDQSxTQUFLdW9DLGdCQUFMLENBQXNCOStCLElBQXRCLEVBQTRCLFlBQTVCLEVBQ3NCLGdCQUR0QixFQUN3QyxLQUFLaytCLFdBRDdDO0FBRUg7O0FBQ0QsT0FBS0ssZUFBTCxDQUFxQmxuQixPQUFyQixDQUE2QixVQUFDaGUsUUFBRCxFQUFjO0FBQ3ZDLFFBQUksS0FBSSxDQUFDeWtDLE9BQUwsQ0FBYXhuQyxHQUFiLENBQWlCLGFBQWErQyxRQUE5QixDQUFKLEVBQTZDO0FBQ3pDLFVBQUkyRyxLQUFJLEdBQUcrRyxJQUFJLENBQUNnRyxLQUFMLENBQVcsS0FBSSxDQUFDK3dCLE9BQUwsQ0FBYXZuQyxHQUFiLENBQWlCLGFBQWE4QyxRQUE5QixDQUFYLENBQVg7O0FBQ0EsV0FBSSxDQUFDeWxDLGdCQUFMLENBQXNCOStCLEtBQXRCLEVBQTRCM0csUUFBNUIsRUFBc0MsVUFBdEMsRUFBa0QsS0FBSSxDQUFDNmtDLFdBQXZEO0FBQ0g7QUFDSixHQUxEO0FBTUEsTUFBSTkrQixNQUFNLEdBQUcsSUFBYjtBQUNBNlosUUFBTSxDQUFDQyxJQUFQLENBQVksS0FBSzZrQixLQUFqQixFQUF3QjFtQixPQUF4QixDQUFnQyxVQUFVdGUsUUFBVixFQUFvQjtBQUNoRCxLQUFDLFNBQVNnbUMsYUFBVCxDQUF1QjcwQixRQUF2QixFQUFpQztBQUM5QixVQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEIsWUFBSS9LLE1BQU0sQ0FBQzIrQixLQUFQLENBQWFobEMsUUFBYixFQUF1QjJOLE1BQTNCLEVBQW1DO0FBQy9CLGNBQUkxRyxJQUFJLEdBQUcrRyxJQUFJLENBQUNnRyxLQUFMLENBQVczTixNQUFNLENBQUMyK0IsS0FBUCxDQUFhaGxDLFFBQWIsRUFBdUJtMUIsR0FBdkIsRUFBWCxDQUFYO0FBQ0EsY0FBSTkyQixHQUFHLEdBQUdnSSxNQUFNLENBQUNULElBQVAsQ0FBWTVGLFFBQVosQ0FBVjs7QUFDQXFHLGdCQUFNLENBQUM0L0IsVUFBUCxDQUFrQmgvQixJQUFsQixFQUF3QmpILFFBQXhCLEVBQWtDLElBQWxDLEVBQXdDZ21DLGFBQXhDO0FBQ0g7QUFDSjtBQUNKLEtBUkQsRUFRRztBQUFDLGlCQUFXO0FBQVosS0FSSDtBQVNILEdBVkQ7QUFXSCxDQXhCRDs7QUEwQkF2d0IsYUFBYSxDQUFDVCxTQUFkLENBQXdCa3hCLHNCQUF4QixHQUFpRCxVQUFVeG9DLEtBQVYsRUFBaUI0QyxRQUFqQixFQUEyQjtBQUFBOztBQUN4RTVDLE9BQUssQ0FBQ29ZLFNBQU4sQ0FBZ0IsVUFBQ3BHLFFBQUQ7QUFBQSxXQUNaLE1BQUksQ0FBQ21GLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QlEsUUFBeEIsS0FBcUMsTUFBSSxDQUFDcUMsUUFBTCxDQUFjNUMsUUFBZCxFQUF3Qm9QLFFBQXhCLENBQXJDLEdBQXlFLEtBRDdEO0FBQUEsR0FBaEIsRUFDb0YsSUFEcEY7QUFFQSxPQUFLODFCLGVBQUwsQ0FBcUJockIsSUFBckIsQ0FBMEJsYSxRQUExQjtBQUNILENBSkQ7QUFNQTs7Ozs7QUFHQW1WLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3Qnl3QixtQkFBeEIsR0FBOEMsWUFBWTtBQUN0RCxNQUFJL25DLEtBQUssR0FBRyxLQUFLbVgsSUFBTCxDQUFVblgsS0FBdEI7QUFDQSxPQUFLd29DLHNCQUFMLENBQTRCeG9DLEtBQUssQ0FBQ3BCLFVBQU4sQ0FBaUJ1RCxJQUE3QyxFQUFtRCxXQUFuRDtBQUNBLE9BQUtxbUMsc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnNDLEtBQTdDLEVBQW9ELFlBQXBEO0FBQ0EsT0FBS3VuQyxzQkFBTCxDQUE0QnhvQyxLQUFLLENBQUNyQixVQUFOLENBQWlCd0MsTUFBN0MsRUFBcUQsYUFBckQ7QUFDQSxPQUFLcW5DLHNCQUFMLENBQTRCeG9DLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUJ1QyxRQUE3QyxFQUF1RCxlQUF2RDtBQUNBLE9BQUtzbkMsc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQitCLFlBQTdDLEVBQTJELGtCQUEzRDtBQUNBLE9BQUs4bkMsc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDckIsVUFBTixDQUFpQnFDLFlBQTdDLEVBQTJELG1CQUEzRDtBQUNBLE9BQUt3bkMsc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDbUwsRUFBTixDQUFTd0UsS0FBVCxDQUFleUIsaUJBQTNDLEVBQThELDhCQUE5RDtBQUNBLE9BQUtvM0Isc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDbUwsRUFBTixDQUFTd0UsS0FBVCxDQUFlcE8sa0JBQTNDLEVBQStELCtCQUEvRDtBQUNBLE9BQUtpbkMsc0JBQUwsQ0FBNEJ4b0MsS0FBSyxDQUFDbUwsRUFBTixDQUFTd0UsS0FBVCxDQUFldk8sb0JBQTNDLEVBQWlFLGlDQUFqRTtBQUNILENBWEQ7O0FBYUEyVyxhQUFhLENBQUNULFNBQWQsQ0FBd0JteEIsZUFBeEIsR0FBMEMsWUFBVztBQUFBOztBQUNqRGpqQixRQUFNLENBQUNrakIsTUFBUCxHQUFnQixZQUFNO0FBQ2xCLFVBQUksQ0FBQ3RqQyxRQUFMLENBQWMsYUFBZCxFQUE2QnRHLFNBQTdCLEVBQXdDQSxTQUF4QyxFQUFtREEsU0FBbkQ7QUFDSCxHQUZEOztBQUdBMG1CLFFBQU0sQ0FBQ21qQixPQUFQLEdBQWlCLFlBQU07QUFDbkIsVUFBSSxDQUFDdmpDLFFBQUwsQ0FBYyxlQUFkLEVBQStCdEcsU0FBL0IsRUFBMENBLFNBQTFDLEVBQXFEQSxTQUFyRDtBQUNILEdBRkQsQ0FKaUQsQ0FRakQ7O0FBQ0gsQ0FURDtBQVdBOzs7Ozs7Ozs7OztBQVNBaVosYUFBYSxDQUFDVCxTQUFkLENBQXdCbUsscUJBQXhCLEdBQWdELFlBQVksQ0FDeEQ7QUFDSCxDQUZEO0FBSUE7Ozs7OztBQUlBMUosYUFBYSxDQUFDVCxTQUFkLENBQXdCc3hCLGdCQUF4QixHQUEyQyxZQUFZO0FBQ25ELE1BQUlqcUMsVUFBVSxHQUFHLEtBQUt3WSxJQUFMLENBQVVuWCxLQUFWLENBQWdCckIsVUFBakM7QUFDQSxNQUFJc0IsSUFBSSxHQUFHLEtBQUtrWCxJQUFMLENBQVVuWCxLQUFWLENBQWdCQyxJQUEzQjtBQUNBLE1BQUlyQixVQUFVLEdBQUcsS0FBS3VZLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JwQixVQUFqQztBQUNBLE1BQUkrRCxPQUFPLEdBQUcsS0FBS3dVLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUE5QjtBQUNBLE1BQU1qRSxhQUFhLEdBQUcsS0FBS3lZLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0J0QixhQUF0QztBQUNBLE1BQUlvbkMsR0FBRyxHQUFHLElBQUlDLElBQUosRUFBVjtBQUNBLE1BQUk4QyxZQUFZLEdBQUcvQyxHQUFHLENBQUNnRCxPQUFKLEVBQW5CO0FBQ0EsU0FBTztBQUNILHFCQUFpQm5xQyxVQUFVLENBQUN1QixFQUFYLEVBRGQ7QUFFSCwyQkFBdUJELElBQUksQ0FBQ1EsT0FBTCxFQUZwQjtBQUdILGlCQUFhUixJQUFJLENBQUNPLFFBQUwsRUFIVjtBQUlILHFCQUFpQjVCLFVBQVUsQ0FBQ3NCLEVBQVgsRUFKZDtBQUtILGVBQVdELElBQUksQ0FBQ0MsRUFBTCxFQUxSO0FBTUgsZUFBV3ZCLFVBQVUsQ0FBQ2dELE9BQVgsRUFOUjtBQU9ILGlCQUFha25DLFlBUFY7QUFRSCxnQkFBWS9DLEdBQUcsQ0FBQ2lELGlCQUFKLEVBUlQ7QUFTSCxnQkFBWXBtQyxPQUFPLENBQUNzQixRQUFSLEVBVFQ7QUFVSCxlQUFXdkYsYUFBYSxDQUFDeUosTUFBZDtBQVZSLEdBQVA7QUFZSCxDQXBCRDtBQXNCQTs7Ozs7Ozs7QUFNQTRQLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnJNLFNBQXhCLEdBQW9DLFVBQVUzSSxRQUFWLEVBQW9CbUMsTUFBcEIsRUFBNEIrQyxPQUE1QixFQUFxQztBQUNyRSxPQUFLMlAsSUFBTCxDQUFVblgsS0FBVixDQUFnQnlFLE1BQWhCLENBQXVCbkMsUUFBdkIsRUFBaUNtQyxNQUFqQztBQUNBLE9BQUswUyxJQUFMLENBQVVuWCxLQUFWLENBQWdCeUUsTUFBaEIsQ0FBdUJuQyxRQUFRLEdBQUcsU0FBbEMsRUFBNkNrRixPQUFPLElBQUksRUFBeEQ7QUFDSCxDQUhEO0FBS0E7Ozs7OztBQUlBdVEsYUFBYSxDQUFDVCxTQUFkLENBQXdCMHhCLFdBQXhCLEdBQXNDLFVBQVVDLE9BQVYsRUFBbUI7QUFDckQsT0FBS3BCLGdCQUFMLElBQXlCLENBQXpCOztBQUNBLE1BQUksQ0FBQzlzQixRQUFRLENBQUNtdUIsc0JBQVQsQ0FBZ0MsaUJBQWhDLEVBQW1EajVCLE1BQXhELEVBQWdFO0FBQzVELFNBQUsyM0IsT0FBTCxHQUFlci9CLENBQUMsQ0FBQyxzQ0FBRCxDQUFoQjtBQUNBLFNBQUtxL0IsT0FBTCxDQUFhNWtCLFFBQWIsQ0FBc0JqSSxRQUFRLENBQUN3SCxJQUEvQjtBQUNIOztBQUNELFVBQVEwbUIsT0FBUjtBQUNJLFNBQUssQ0FBTDtBQUNJLFdBQUtyQixPQUFMLENBQWExSSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUswSSxPQUFMLENBQWExSSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKLFNBQUssQ0FBTDtBQUNJLFdBQUswSSxPQUFMLENBQWExSSxHQUFiLENBQWlCLGtCQUFqQixFQUFxQyxNQUFyQztBQUNBOztBQUNKO0FBQ0ksV0FBSzBJLE9BQUwsQ0FBYTFJLEdBQWIsQ0FBaUIsa0JBQWpCLEVBQXFDLE9BQXJDO0FBQ0E7QUFaUjtBQWNILENBcEJEO0FBc0JBOzs7OztBQUdBbm5CLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QjZ4QixXQUF4QixHQUFzQyxZQUFZO0FBQzlDLE9BQUt0QixnQkFBTCxJQUF5QixDQUF6Qjs7QUFDQSxNQUFJLEtBQUtBLGdCQUFMLElBQXlCLENBQTdCLEVBQWdDO0FBQzVCLFNBQUtELE9BQUwsQ0FBYXp0QixNQUFiO0FBQ0g7QUFDSixDQUxEOztBQU9BcEMsYUFBYSxDQUFDVCxTQUFkLENBQXdCOHhCLFlBQXhCLEdBQXVDLFVBQVVDLEtBQVYsRUFBaUI5L0IsSUFBakIsRUFBdUI7QUFDMUQ7QUFDQSxNQUFJMEcsTUFBTSxHQUFHLEtBQUtxM0IsS0FBTCxDQUFXK0IsS0FBWCxFQUFrQnA1QixNQUEvQjtBQUNBLE1BQUlYLEdBQUcsR0FBRyxLQUFLazRCLGNBQUwsQ0FBb0I2QixLQUFwQixDQUFWOztBQUNBLE1BQUlwNUIsTUFBTSxHQUFHWCxHQUFiLEVBQWtCO0FBQ2QsU0FBS2c0QixLQUFMLENBQVcrQixLQUFYLElBQW9CLEtBQUsvQixLQUFMLENBQVcrQixLQUFYLEVBQWtCNzNCLEtBQWxCLENBQXdCdkIsTUFBTSxHQUFHWCxHQUFqQyxFQUFzQ0EsR0FBdEMsQ0FBcEI7QUFDSCxHQU55RCxDQU8xRDs7O0FBQ0EsTUFBSTdQLEdBQUcsR0FBRzZRLElBQUksQ0FBQ0MsU0FBTCxDQUFlaEgsSUFBZixDQUFWO0FBQ0EsTUFBSW9MLEtBQUssR0FBRyxLQUFLMnlCLEtBQUwsQ0FBVytCLEtBQVgsRUFBa0JqM0IsT0FBbEIsQ0FBMEIzUyxHQUExQixDQUFaOztBQUNBLE1BQUlrVixLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2QsU0FBSzJ5QixLQUFMLENBQVcrQixLQUFYLEVBQWtCdnNCLElBQWxCLENBQXVCcmQsR0FBdkI7QUFDQSxTQUFLNG5DLE9BQUwsQ0FBYWUsR0FBYixDQUFpQmlCLEtBQWpCLEVBQXdCLzRCLElBQUksQ0FBQ0MsU0FBTCxDQUFlLEtBQUsrMkIsS0FBTCxDQUFXK0IsS0FBWCxDQUFmLENBQXhCO0FBQ0g7QUFDSixDQWREOztBQWdCQXR4QixhQUFhLENBQUNULFNBQWQsQ0FBd0JneUIsWUFBeEIsR0FBdUMsVUFBVUQsS0FBVixFQUFpQjkvQixJQUFqQixFQUF1QjtBQUMxRCxNQUFJOUosR0FBRyxHQUFHNlEsSUFBSSxDQUFDQyxTQUFMLENBQWVoSCxJQUFmLENBQVY7QUFDQSxNQUFJb0wsS0FBSyxHQUFHLEtBQUsyeUIsS0FBTCxDQUFXK0IsS0FBWCxFQUFrQmozQixPQUFsQixDQUEwQjNTLEdBQTFCLENBQVo7O0FBQ0EsTUFBSWtWLEtBQUssSUFBSSxDQUFiLEVBQWdCO0FBQ1osU0FBSzJ5QixLQUFMLENBQVcrQixLQUFYLEVBQWtCRSxNQUFsQixDQUF5QjUwQixLQUF6QjtBQUNBLFNBQUsweUIsT0FBTCxDQUFhZSxHQUFiLENBQWlCaUIsS0FBakIsRUFBd0IvNEIsSUFBSSxDQUFDQyxTQUFMLENBQWUsS0FBSysyQixLQUFMLENBQVcrQixLQUFYLENBQWYsQ0FBeEI7QUFDSDtBQUNKLENBUEQ7O0FBVUF0eEIsYUFBYSxDQUFDVCxTQUFkLENBQXdCaXhCLFVBQXhCLEdBQXFDLFVBQVVoL0IsSUFBVixFQUFnQmpILFFBQWhCLEVBQTBCaXpCLEtBQTFCLEVBQWlDckksUUFBakMsRUFBMkM7QUFBQTs7QUFDNUU7QUFDQSxNQUFJc2MsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBTTtBQUNwQjtBQUNBLFVBQUksQ0FBQ0osWUFBTCxDQUFrQjltQyxRQUFsQixFQUE0QmlILElBQTVCOztBQUNBaEIsS0FBQyxDQUFDa2hDLElBQUYsQ0FBTyxNQUFJLENBQUN2aEMsSUFBTCxDQUFVNUYsUUFBVixDQUFQLEVBQTRCaUgsSUFBNUIsRUFDSzJYLElBREwsQ0FDVSxVQUFDek4sUUFBRCxFQUFjO0FBQ2hCLFlBQUksQ0FBQzYxQixZQUFMLENBQWtCaG5DLFFBQWxCLEVBQTRCaUgsSUFBNUI7O0FBQ0EsVUFBSWtLLFFBQVEsQ0FBQ0MsT0FBYixFQUFzQjtBQUNsQixjQUFJLENBQUN6SSxTQUFMLENBQWUzSSxRQUFmLEVBQXlCcUMsV0FBVyxDQUFDQyxLQUFyQztBQUNILE9BRkQsTUFFTztBQUNINEUsZUFBTyxDQUFDK1gsS0FBUixDQUFjOU4sUUFBZDs7QUFDQSxjQUFJLENBQUN4SSxTQUFMLENBQWUzSSxRQUFmLEVBQXlCcUMsV0FBVyxDQUFDd3FCLE1BQXJDLEVBQTZDMWIsUUFBUSxDQUFDak0sT0FBdEQ7QUFDSDs7QUFDRCxVQUFJMGxCLFFBQUosRUFBYztBQUNWQSxnQkFBUSxDQUFDelosUUFBRCxDQUFSO0FBQ0g7O0FBQ0QsVUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLGNBQUksQ0FBQ3UwQixPQUFMLENBQWF4MEIsUUFBUSxDQUFDMDBCLEVBQXRCO0FBQ0g7QUFDSixLQWZMLEVBZ0JJO0FBaEJKLEtBaUJLOW1CLElBakJMLENBaUJVLFVBQUNFLEtBQUQsRUFBUW1vQixVQUFSLEVBQXVCO0FBQ3pCLFlBQUksQ0FBQ3orQixTQUFMLENBQWUzSSxRQUFmLEVBQXlCcUMsV0FBVyxDQUFDd2lDLFFBQXJDLEVBQStDdUMsVUFBVSxDQUFDcGxDLFFBQVgsRUFBL0M7O0FBQ0EsWUFBSSxDQUFDaWtDLFVBQUwsQ0FBZ0JoL0IsSUFBaEIsRUFBc0JqSCxRQUF0QixFQUFnQ2l6QixLQUFLLEdBQUcsTUFBSSxDQUFDbVMsVUFBN0MsRUFBeUR4YSxRQUF6RDtBQUNILEtBcEJMO0FBcUJILEdBeEJEOztBQXlCQSxNQUFJcUksS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEJpVSxlQUFXO0FBQ2QsR0FGRCxNQUVPO0FBQ0hyZixjQUFVLENBQUNxZixXQUFELEVBQWNqVSxLQUFkLENBQVY7QUFDSDtBQUNKLENBaENEO0FBa0NBOzs7Ozs7Ozs7Ozs7O0FBV0F4ZCxhQUFhLENBQUNULFNBQWQsQ0FBd0Ird0IsZ0JBQXhCLEdBQTJDLFVBQVU5K0IsSUFBVixFQUFnQjNHLFFBQWhCLEVBQTBCTixRQUExQixFQUFvQ2l6QixLQUFwQyxFQUEyQ29VLGVBQTNDLEVBQTREQyxZQUE1RCxFQUEwRTtBQUFBOztBQUNqSCxNQUFJUCxLQUFLLEdBQUcvbUMsUUFBUSxHQUFHTSxRQUF2Qjs7QUFDQSxNQUFJaW5DLE9BQU8sR0FBRyxTQUFWQSxPQUFVLEdBQU07QUFDaEI7QUFDQSxVQUFJLENBQUN4QyxPQUFMLENBQWFlLEdBQWIsQ0FBaUJpQixLQUFqQixFQUF3Qi80QixJQUFJLENBQUNDLFNBQUwsQ0FBZWhILElBQWYsQ0FBeEI7O0FBQ0EsUUFBSXE5QixJQUFJLEdBQUcsTUFBSSxDQUFDUyxPQUFMLENBQWF5QixPQUFiLENBQXFCTyxLQUFyQixDQUFYLENBSGdCLENBSWhCOzs7QUFDQTlnQyxLQUFDLENBQUNraEMsSUFBRixDQUFPLE1BQUksQ0FBQ3ZoQyxJQUFMLENBQVU1RixRQUFWLENBQVAsRUFBNEJpSCxJQUE1QixFQUNLMlgsSUFETCxDQUNVLFVBQUN6TixRQUFELEVBQWM7QUFDaEIsVUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLGNBQUksQ0FBQ3UwQixPQUFMLENBQWF4MEIsUUFBYixFQURrQixDQUVsQjs7O0FBQ0EsWUFBSXEyQixVQUFVLEdBQUcsTUFBSSxDQUFDekMsT0FBTCxDQUFheUIsT0FBYixDQUFxQk8sS0FBckIsQ0FBakI7O0FBQ0EsWUFBSXpDLElBQUksSUFBSWtELFVBQVosRUFBd0I7QUFDcEIsZ0JBQUksQ0FBQ3pDLE9BQUwsQ0FBYWx0QixNQUFiLENBQW9Ca3ZCLEtBQXBCO0FBQ0g7O0FBQ0QsY0FBSSxDQUFDcCtCLFNBQUwsQ0FBZTNJLFFBQWYsRUFBeUJxQyxXQUFXLENBQUNDLEtBQXJDO0FBQ0gsT0FSRCxNQVFPO0FBQ0g7QUFDQSxjQUFJLENBQUNxRyxTQUFMLENBQWUzSSxRQUFmLEVBQXlCcUMsV0FBVyxDQUFDd3FCLE1BQXJDLEVBQTZDMWIsUUFBUSxDQUFDak0sT0FBdEQ7O0FBQ0EsWUFBSWlNLFFBQVEsQ0FBQ0MsT0FBVCxLQUFxQixLQUF6QixFQUFnQztBQUM1QjtBQUNBLGNBQUlvMkIsV0FBVSxHQUFHLE1BQUksQ0FBQ3pDLE9BQUwsQ0FBYXlCLE9BQWIsQ0FBcUJPLEtBQXJCLENBQWpCOztBQUNBLGNBQUl6QyxJQUFJLElBQUlrRCxXQUFaLEVBQXdCO0FBQ3BCLGtCQUFJLENBQUN6QyxPQUFMLENBQWFsdEIsTUFBYixDQUFvQmt2QixLQUFwQjtBQUNIOztBQUNELGNBQUlNLGVBQUosRUFBcUI7QUFDakJBLDJCQUFlLENBQUNsMkIsUUFBRCxDQUFmO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0F4QkwsRUF5Qks0TixJQXpCTCxDQXlCVSxVQUFDRSxLQUFELEVBQVFtb0IsVUFBUixFQUF1QjtBQUN6QixZQUFJLENBQUN6K0IsU0FBTCxDQUFlM0ksUUFBZixFQUF5QnFDLFdBQVcsQ0FBQ3dpQyxRQUFyQyxFQUErQ3VDLFVBQVUsQ0FBQ3BsQyxRQUFYLEVBQS9DLEVBRHlCLENBRXpCOzs7QUFDQSxVQUFJd2xDLFVBQVUsR0FBRyxNQUFJLENBQUN6QyxPQUFMLENBQWF5QixPQUFiLENBQXFCTyxLQUFyQixDQUFqQjs7QUFDQSxVQUFJekMsSUFBSSxJQUFJa0QsVUFBWixFQUF3QjtBQUNwQixjQUFJLENBQUN6QixnQkFBTCxDQUFzQjkrQixJQUF0QixFQUE0QjNHLFFBQTVCLEVBQXNDTixRQUF0QyxFQUFnRGl6QixLQUFLLEdBQUcsTUFBSSxDQUFDbVMsVUFBN0Q7QUFDSDtBQUNKLEtBaENMLEVBaUNLeG1CLElBakNMLENBaUNVMG9CLFlBakNWO0FBa0NILEdBdkNEOztBQXdDQXRRLGNBQVksQ0FBQyxLQUFLcU8sTUFBTCxDQUFZMEIsS0FBWixDQUFELENBQVo7O0FBQ0EsTUFBSTlULEtBQUssS0FBSyxJQUFkLEVBQW9CO0FBQ2hCLFdBQU9zVSxPQUFPLEVBQWQ7QUFDSCxHQUZELE1BRU87QUFDSCxTQUFLbEMsTUFBTCxDQUFZMEIsS0FBWixJQUFxQmxmLFVBQVUsQ0FBQzBmLE9BQUQsRUFBVXRVLEtBQVYsQ0FBL0I7QUFDSDtBQUNKLENBaEREOztBQWtEQXhkLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3Qnl5QixhQUF4QixHQUF3QyxVQUFVem5DLFFBQVYsRUFBb0JpSCxJQUFwQixFQUEwQnlnQyxRQUExQixFQUFvQ3QyQixPQUFwQyxFQUE2QzhmLE9BQTdDLEVBQXdFO0FBQUE7O0FBQUEsTUFBbEJ5VyxhQUFrQix1RUFBSixFQUFJO0FBQzVHLE9BQUtqQixXQUFMLENBQWlCZ0IsUUFBakI7QUFDQSxTQUFPemhDLENBQUMsQ0FBQzJoQyxJQUFGO0FBQ0h0cEMsUUFBSSxFQUFFLE1BREg7QUFFSEQsT0FBRyxFQUFFLEtBQUt1SCxJQUFMLENBQVU1RixRQUFWLENBRkY7QUFHSGlILFFBQUksRUFBRUE7QUFISCxLQUlBMGdDLGFBSkEsR0FNRi9vQixJQU5FLENBTUcsVUFBQ3pOLFFBQUQsRUFBYztBQUNoQixVQUFJLENBQUMwMUIsV0FBTDs7QUFDQSxVQUFJLENBQUNsK0IsU0FBTCxDQUFlM0ksUUFBZixFQUF5QnFDLFdBQVcsQ0FBQ0MsS0FBckM7O0FBQ0E4TyxXQUFPLENBQUNELFFBQUQsQ0FBUDs7QUFDQSxVQUFJLENBQUN3MEIsT0FBTCxDQUFheDBCLFFBQWI7QUFDSCxHQVhFLEVBWUY0TixJQVpFLENBWUcsVUFBQ2pMLENBQUQsRUFBSXN6QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUNsQyxRQUFJSCxRQUFRLElBQUksQ0FBaEIsRUFBbUI7QUFDZixZQUFJLENBQUNiLFdBQUw7O0FBQ0EsWUFBSSxDQUFDbCtCLFNBQUwsQ0FBZTNJLFFBQWYsRUFBeUJxQyxXQUFXLENBQUN3cUIsTUFBckMsRUFBNkN1YSxVQUFVLENBQUNwbEMsUUFBWCxFQUE3Qzs7QUFDQSxVQUFJa3ZCLE9BQUosRUFBYTtBQUNUQSxlQUFPLENBQUNwZCxDQUFELEVBQUlzekIsVUFBSixFQUFnQlMsV0FBaEIsQ0FBUDtBQUNIO0FBQ0osS0FORCxNQU1PO0FBQ0hoZ0IsZ0JBQVUsQ0FBQyxZQUFNO0FBQ2IsY0FBSSxDQUFDZ2YsV0FBTDs7QUFDQSxjQUFJLENBQUNsK0IsU0FBTCxDQUFlM0ksUUFBZixFQUF5QnFDLFdBQVcsQ0FBQ3dpQyxRQUFyQyxFQUErQ3VDLFVBQVUsQ0FBQ3BsQyxRQUFYLEVBQS9DOztBQUNBLGNBQUksQ0FBQ3lsQyxhQUFMLENBQW1Cem5DLFFBQW5CLEVBQTZCaUgsSUFBN0IsRUFBbUN5Z0MsUUFBUSxHQUFHLENBQTlDLEVBQWlEdDJCLE9BQWpELEVBQTBEOGYsT0FBMUQ7QUFDSCxPQUpTLEVBSVAsTUFBSSxDQUFDa1UsVUFKRSxDQUFWO0FBS0g7QUFDSixHQTFCRSxDQUFQO0FBMkJILENBN0JEOztBQWdDQTN2QixhQUFhLENBQUNULFNBQWQsQ0FBd0I1UyxjQUF4QixHQUF5QyxVQUFVK0QsYUFBVixFQUF5QjtBQUFBOztBQUM5RCxNQUFJekksS0FBSyxHQUFHLEtBQUttWCxJQUFMLENBQVVuWCxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUNtTCxFQUFOLENBQVN4QyxNQUFULENBQWdCeUssbUJBQWhCLENBQW9DLGdCQUFwQyxDQUFKLEVBQTJEO0FBQ3ZELFFBQUk3SixJQUFJLEdBQUcsS0FBS3EvQixnQkFBTCxFQUFYO0FBQ0FyL0IsUUFBSSxDQUFDLGVBQUQsQ0FBSixHQUF3QmQsYUFBeEI7O0FBQ0EsU0FBS3NoQyxhQUFMLENBQW1CLGdCQUFuQixFQUFxQ3hnQyxJQUFyQyxFQUEyQyxDQUEzQyxFQUNtQixVQUFDa0ssUUFBRCxFQUFjO0FBQ1YsVUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCLGNBQUksQ0FBQ3lELElBQUwsQ0FBVVgsbUJBQVYsQ0FBOEIvQyxRQUE5QjtBQUNILE9BRkQsTUFFTztBQUNILGNBQUksQ0FBQ3hJLFNBQUwsQ0FBZSxnQkFBZixFQUFpQ3RHLFdBQVcsQ0FBQ3dxQixNQUE3QyxFQUFxRDFiLFFBQVEsQ0FBQ2pNLE9BQTlEOztBQUNBLGNBQUksQ0FBQzJQLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFyQixDQUE0QitYLHlCQUE1QixDQUFzRHhRLFFBQVEsQ0FBQ2pNLE9BQS9EO0FBQ0g7QUFDSixLQVJwQixFQVNtQixVQUFDNE8sQ0FBRCxFQUFJc3pCLFVBQUosRUFBZ0JTLFdBQWhCLEVBQWdDO0FBQzVCLFlBQUksQ0FBQ2h6QixJQUFMLENBQVV6TyxVQUFWLENBQXFCd0QsTUFBckIsQ0FBNEIrWCx5QkFBNUIsQ0FBc0R5bEIsVUFBdEQ7O0FBQ0FsZ0MsYUFBTyxDQUFDK1gsS0FBUixDQUFjbkwsQ0FBZCxFQUFpQnN6QixVQUFqQixFQUE2QlMsV0FBN0I7QUFDSCxLQVpwQjtBQWFILEdBaEJELE1BZ0JPO0FBQ0gsU0FBS2wvQixTQUFMLENBQWUsZ0JBQWYsRUFBaUN0RyxXQUFXLENBQUN5aUMsT0FBN0M7QUFDSDtBQUNKLENBckJEOztBQXVCQXJ2QixhQUFhLENBQUNULFNBQWQsQ0FBd0I1UixjQUF4QixHQUF5QyxZQUFZO0FBQUE7O0FBQ2pELE1BQUkxRixLQUFLLEdBQUcsS0FBS21YLElBQUwsQ0FBVW5YLEtBQXRCOztBQUNBLE1BQUlBLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU3hDLE1BQVQsQ0FBZ0J5SyxtQkFBaEIsQ0FBb0MsZ0JBQXBDLENBQUosRUFBMkQ7QUFDdkQsUUFBSTdKLElBQUksR0FBRyxLQUFLcS9CLGdCQUFMLEVBQVg7QUFDQXIvQixRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCdkosS0FBSyxDQUFDckIsVUFBTixDQUFpQm9ELE1BQWpCLEVBQWpCO0FBQ0F3SCxRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CdkosS0FBSyxDQUFDckIsVUFBTixDQUFpQm1ELFFBQWpCLEVBQW5CO0FBQ0F5SCxRQUFJLENBQUMsUUFBRCxDQUFKLEdBQWlCdkosS0FBSyxDQUFDckIsVUFBTixZQUFqQjtBQUNBNEssUUFBSSxDQUFDLEtBQUQsQ0FBSixHQUFjdkosS0FBSyxDQUFDckIsVUFBTixDQUFpQmdDLEdBQWpCLEVBQWQ7QUFDQTRJLFFBQUksQ0FBQyxRQUFELENBQUosR0FBaUJ2SixLQUFLLENBQUNyQixVQUFOLENBQWlCb0MsTUFBakIsRUFBakI7QUFDQXdJLFFBQUksQ0FBQyxXQUFELENBQUosR0FBb0J2SixLQUFLLENBQUNyQixVQUFOLENBQWlCcUQsUUFBakIsRUFBcEI7QUFDQXVILFFBQUksQ0FBQyxNQUFELENBQUosR0FBZXZKLEtBQUssQ0FBQ3JCLFVBQU4sQ0FBaUIwQixJQUFqQixFQUFmO0FBQ0FrSixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1CeWUsMEZBQXNCLENBQUNob0IsS0FBRCxDQUF6Qzs7QUFFQSxTQUFLK3BDLGFBQUwsQ0FBbUIsZ0JBQW5CLEVBQXFDeGdDLElBQXJDLEVBQTJDLENBQTNDLEVBQ21CLEtBQUs2Z0MsaUJBQUwsQ0FBdUI1M0IsSUFBdkIsQ0FBNEIsSUFBNUIsQ0FEbkIsRUFFbUIsVUFBQzRELENBQUQsRUFBSXN6QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUM1QixZQUFJLENBQUNoekIsSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCbVksd0JBQTVCLENBQXFEcWxCLFVBQXJEOztBQUNBbGdDLGFBQU8sQ0FBQytYLEtBQVIsQ0FBY25MLENBQWQsRUFBaUJzekIsVUFBakIsRUFBNkJTLFdBQTdCO0FBQ0gsS0FMcEI7QUFNSCxHQWpCRCxNQWlCTztBQUNILFNBQUtsL0IsU0FBTCxDQUFlLGdCQUFmLEVBQWlDdEcsV0FBVyxDQUFDeWlDLE9BQTdDLEVBQXNELDRDQUF0RDtBQUNIO0FBQ0osQ0F0QkQ7O0FBd0JBcnZCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnhTLFdBQXhCLEdBQXNDLFVBQVVvb0IsUUFBVixFQUFvQjtBQUFBOztBQUN0RCxNQUFJLEtBQUsvVixJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJ4QyxNQUFuQixDQUEwQnlLLG1CQUExQixDQUE4QyxhQUE5QyxDQUFKLEVBQWtFO0FBQzlELFFBQUlwVCxLQUFLLEdBQUcsS0FBS21YLElBQUwsQ0FBVW5YLEtBQXRCO0FBQ0EsUUFBSXVKLElBQUksR0FBRyxLQUFLcS9CLGdCQUFMLEVBQVg7O0FBQ0EsU0FBS21CLGFBQUwsQ0FBbUIsYUFBbkIsRUFBa0N4Z0MsSUFBbEMsRUFBd0MsQ0FBeEMsRUFBMkMyakIsUUFBM0MsRUFDbUIsVUFBQzlXLENBQUQsRUFBSXN6QixVQUFKLEVBQWdCUyxXQUFoQixFQUFnQztBQUM1QixZQUFJLENBQUNoekIsSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCMkgscUJBQTVCOztBQUNBckssYUFBTyxDQUFDK1gsS0FBUixDQUFjbkwsQ0FBZCxFQUFpQnN6QixVQUFqQixFQUE2QlMsV0FBN0I7QUFDSCxLQUpwQjtBQUtIO0FBQ0osQ0FWRDs7QUFZQXB5QixhQUFhLENBQUNULFNBQWQsQ0FBd0J0UixpQkFBeEIsR0FBNEMsVUFBVWtuQixRQUFWLEVBQW9CO0FBQUE7O0FBQzVELE1BQUksS0FBSy9WLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQnhDLE1BQW5CLENBQTBCeUssbUJBQTFCLENBQThDLG1CQUE5QyxDQUFKLEVBQXdFO0FBQ3BFLFFBQUlwVCxLQUFLLEdBQUcsS0FBS21YLElBQUwsQ0FBVW5YLEtBQXRCO0FBQ0EsUUFBSXVKLElBQUksR0FBRyxLQUFLcS9CLGdCQUFMLEVBQVg7O0FBQ0EsU0FBS21CLGFBQUwsQ0FBbUIsbUJBQW5CLEVBQXdDeGdDLElBQXhDLEVBQThDLENBQTlDLEVBQWlEMmpCLFFBQWpELEVBQ21CLFVBQUM5VyxDQUFELEVBQUlzekIsVUFBSixFQUFnQlMsV0FBaEIsRUFBZ0M7QUFDNUIsYUFBSSxDQUFDaHpCLElBQUwsQ0FBVXpPLFVBQVYsQ0FBcUJ3RCxNQUFyQixDQUE0QmlZLDRCQUE1QixDQUF5RHVsQixVQUF6RDs7QUFDQWxnQyxhQUFPLENBQUMrWCxLQUFSLENBQWNuTCxDQUFkLEVBQWlCc3pCLFVBQWpCLEVBQTZCUyxXQUE3QjtBQUNILEtBSnBCO0FBS0g7QUFDSixDQVZEOztBQVlBcHlCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QmxSLFVBQXhCLEdBQXFDLFVBQVVpa0MsU0FBVixFQUFxQkMsU0FBckIsRUFBZ0MxbkMsUUFBaEMsRUFBMENvUCxRQUExQyxFQUFvRGtiLFFBQXBELEVBQThEO0FBQUE7O0FBQy9GLE1BQUlsdEIsS0FBSyxHQUFHLEtBQUttWCxJQUFMLENBQVVuWCxLQUF0Qjs7QUFDQSxNQUFJQSxLQUFLLENBQUNtTCxFQUFOLENBQVN4QyxNQUFULENBQWdCeUssbUJBQWhCLENBQW9DLFlBQXBDLENBQUosRUFBdUQ7QUFDbkQsUUFBSTdKLElBQUksR0FBRyxLQUFLcS9CLGdCQUFMLEVBQVg7QUFDQXIvQixRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9COGdDLFNBQXBCO0FBQ0E5Z0MsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQitnQyxTQUFwQjtBQUNBL2dDLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUIzRyxRQUFuQjtBQUNBMkcsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQnlJLFFBQW5CO0FBQ0EsUUFBSXU0QixFQUFFLEdBQUcvbkIsTUFBTSxDQUFDZ29CLE9BQVAsQ0FBZWpoQyxJQUFmLEVBQXFCaTlCLE1BQXJCLENBQTRCLFVBQUNpRSxDQUFELEVBQUdyMEIsQ0FBSDtBQUFBLGFBQVVxMEIsQ0FBQyxDQUFDeHZCLE1BQUYsT0FBQXd2QixDQUFDLHFCQUFXcjBCLENBQVgsRUFBRCxFQUFnQnEwQixDQUExQjtBQUFBLEtBQTVCLEVBQTBELElBQUlDLFFBQUosRUFBMUQsQ0FBVDtBQUNBLFdBQU8sS0FBS1gsYUFBTCxDQUFtQixZQUFuQixFQUFpQ1EsRUFBakMsRUFBcUMsQ0FBckMsRUFDbUJyZCxRQURuQixFQUVtQixVQUFDOVcsQ0FBRCxFQUFJc3pCLFVBQUosRUFBZ0JTLFdBQWhCLEVBQWdDO0FBQzVCLGFBQUksQ0FBQ2h6QixJQUFMLENBQVV6TyxVQUFWLENBQXFCd0QsTUFBckIsQ0FBNEJrWSxvQkFBNUIsQ0FBaURzbEIsVUFBakQ7O0FBQ0FsZ0MsYUFBTyxDQUFDK1gsS0FBUixDQUFjbkwsQ0FBZCxFQUFpQnN6QixVQUFqQixFQUE2QlMsV0FBN0I7QUFDSCxLQUxwQixFQUtzQjtBQUFDUSxpQkFBVyxFQUFFLEtBQWQ7QUFBcUJDLGlCQUFXLEVBQUU7QUFBbEMsS0FMdEIsQ0FBUDtBQU1ILEdBYkQsTUFhTztBQUNILFNBQUszL0IsU0FBTCxDQUFlLFlBQWYsRUFBNkJ0RyxXQUFXLENBQUN5aUMsT0FBekMsRUFBa0Qsd0NBQWxEO0FBQ0g7QUFDSixDQWxCRDs7QUFvQkFydkIsYUFBYSxDQUFDVCxTQUFkLENBQXdCbFMsUUFBeEIsR0FBbUMsVUFBVXkvQixVQUFWLEVBQXNCcDlCLFFBQXRCLEVBQWdDQyxLQUFoQyxFQUF1Q0YsT0FBdkMsRUFBZ0RvOUIsU0FBaEQsRUFBMkQ7QUFDMUYsTUFBSSxLQUFLenRCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QjBCLFFBQXhCLEVBQUosRUFBd0M7QUFDcEMsU0FBSzRHLFNBQUwsQ0FBZSxVQUFmLEVBQTJCdEcsV0FBVyxDQUFDeWlDLE9BQXZDO0FBQ0E7QUFDSDs7QUFDRCxNQUFJLEtBQUtqd0IsSUFBTCxDQUFVblgsS0FBVixDQUFnQm1MLEVBQWhCLENBQW1CeEMsTUFBbkIsQ0FBMEJ5SyxtQkFBMUIsQ0FBOEMsVUFBOUMsQ0FBSixFQUErRDtBQUMzRCxRQUFJN0osSUFBSSxHQUFHLEtBQUtxL0IsZ0JBQUwsRUFBWDtBQUNBci9CLFFBQUksQ0FBQyxZQUFELENBQUosR0FBcUJzN0IsVUFBckI7QUFDQXQ3QixRQUFJLENBQUMsVUFBRCxDQUFKLEdBQW1COUIsUUFBbkI7QUFDQThCLFFBQUksQ0FBQyxPQUFELENBQUosR0FBZ0I3QixLQUFoQjtBQUNBNkIsUUFBSSxDQUFDLFNBQUQsQ0FBSixHQUFrQi9CLE9BQWxCO0FBQ0ErQixRQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CcTdCLFNBQXBCO0FBQ0EsU0FBSzM1QixTQUFMLENBQWUsVUFBZixFQUEyQnRHLFdBQVcsQ0FBQzZKLE1BQXZDLEVBUDJELENBUTNEOztBQUNBLFNBQUsrNUIsVUFBTCxDQUFnQmgvQixJQUFoQixFQUFzQixVQUF0QixFQUFrQyxDQUFsQyxFQUFxQyxZQUFNLENBQzFDLENBREQ7QUFFSCxHQVhELE1BV087QUFDSCxTQUFLMEIsU0FBTCxDQUFlLFVBQWYsRUFBMkJ0RyxXQUFXLENBQUN5aUMsT0FBdkM7QUFDSDtBQUNKLENBbkJEOztBQXFCQXJ2QixhQUFhLENBQUNULFNBQWQsQ0FBd0JoUyxTQUF4QixHQUFvQyxVQUFVZ2xDLFNBQVYsRUFBcUIxcUIsS0FBckIsRUFBNEI7QUFDNUQsTUFBSSxLQUFLekksSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCMEIsUUFBeEIsRUFBSixFQUF3QztBQUNwQyxTQUFLNEcsU0FBTCxDQUFlLFdBQWYsRUFBNEJ0RyxXQUFXLENBQUN5aUMsT0FBeEM7QUFDQTtBQUNIOztBQUNELE1BQUksS0FBS2p3QixJQUFMLENBQVVuWCxLQUFWLENBQWdCbUwsRUFBaEIsQ0FBbUJ4QyxNQUFuQixDQUEwQnlLLG1CQUExQixDQUE4QyxXQUE5QyxDQUFKLEVBQWdFO0FBQzVELFFBQUk3SixJQUFJLEdBQUcsS0FBS3EvQixnQkFBTCxFQUFYO0FBQ0FyL0IsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQitnQyxTQUFwQjtBQUNBL2dDLFFBQUksQ0FBQyxPQUFELENBQUosR0FBZ0JxVyxLQUFoQjtBQUNBLFNBQUszVSxTQUFMLENBQWUsV0FBZixFQUE0QnRHLFdBQVcsQ0FBQzZKLE1BQXhDLEVBSjRELENBSzVEOztBQUNBLFNBQUs2NUIsZ0JBQUwsQ0FBc0I5K0IsSUFBdEIsRUFBNEIsZUFBNUIsRUFBNkMsV0FBN0MsRUFBMEQsQ0FBMUQ7QUFDSCxHQVBELE1BT087QUFDSCxTQUFLMEIsU0FBTCxDQUFlLFdBQWYsRUFBNEJ0RyxXQUFXLENBQUN5aUMsT0FBeEM7QUFDSDtBQUNKLENBZkQ7O0FBaUJBcnZCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnhSLHNCQUF4QixHQUFpRCxVQUFTK2tDLFNBQVQsRUFBb0I7QUFBQTs7QUFDakUsTUFBSSxLQUFLMXpCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QjBCLFFBQXhCLEVBQUosRUFBd0M7QUFDcEMsU0FBSzRHLFNBQUwsQ0FBZSx3QkFBZixFQUF5Q3RHLFdBQVcsQ0FBQ3lpQyxPQUFyRDtBQUNBO0FBQ0g7O0FBQ0QsTUFBSSxLQUFLandCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQnhDLE1BQW5CLENBQTBCeUssbUJBQTFCLENBQThDLHdCQUE5QyxDQUFKLEVBQTZFO0FBQ3pFLFFBQUk3SixJQUFJLEdBQUcsS0FBS3EvQixnQkFBTCxFQUFYO0FBQ0FyL0IsUUFBSSxDQUFDLFFBQUQsQ0FBSixHQUFpQnNoQyxTQUFqQjs7QUFDQSxRQUFJQyxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQUN2aEMsSUFBRCxFQUFVO0FBQzdCLFVBQUlBLElBQUksQ0FBQ21LLE9BQVQsRUFBa0I7QUFDZCxlQUFJLENBQUN5RCxJQUFMLENBQVVuWCxLQUFWLENBQWdCcEIsVUFBaEIsQ0FBMkI2RCxnQkFBM0IsQ0FBNENvb0MsU0FBNUM7QUFDSDtBQUNKLEtBSkQ7O0FBS0EsU0FBS2QsYUFBTCxDQUFtQix3QkFBbkIsRUFBNkN4Z0MsSUFBN0MsRUFBbUQsQ0FBbkQsRUFBc0R1aEMsZ0JBQXRELEVBQ21CLFVBQUMxMEIsQ0FBRCxFQUFJc3pCLFVBQUosRUFBZ0JTLFdBQWhCLEVBQWdDO0FBQzVCLGFBQUksQ0FBQ2h6QixJQUFMLENBQVV6TyxVQUFWLENBQXFCd0QsTUFBckIsQ0FBNEJ1WSxnQ0FBNUI7O0FBQ0FqYixhQUFPLENBQUMrWCxLQUFSLENBQWNuTCxDQUFkLEVBQWlCc3pCLFVBQWpCLEVBQTZCUyxXQUE3QjtBQUNILEtBSnBCO0FBS0g7QUFDSixDQW5CRDtBQXFCQTs7Ozs7OztBQUtBcHlCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QnRTLFFBQXhCLEdBQW1DLFVBQVVwQyxRQUFWLEVBQW9CaEMsSUFBcEIsRUFBMEJzc0IsUUFBMUIsRUFBb0M2ZCxhQUFwQyxFQUFtRDtBQUNsRixNQUFJL3FDLEtBQUssR0FBRyxLQUFLbVgsSUFBTCxDQUFVblgsS0FBdEI7QUFDQSxNQUFJMkksTUFBTSxHQUFHLElBQWI7O0FBQ0EsTUFBSTNJLEtBQUssQ0FBQ21MLEVBQU4sQ0FBU3hDLE1BQVQsQ0FBZ0J5SyxtQkFBaEIsQ0FBb0MsV0FBcEMsQ0FBSixFQUFzRDtBQUNsRCxRQUFJN0osSUFBSSxHQUFHLEtBQUtxL0IsZ0JBQUwsRUFBWDtBQUNBci9CLFFBQUksQ0FBQyxVQUFELENBQUosR0FBbUIzRyxRQUFuQjtBQUNBMkcsUUFBSSxDQUFDLE1BQUQsQ0FBSixHQUFlM0ksSUFBZjs7QUFDQSxTQUFLbXBDLGFBQUwsQ0FBbUIsS0FBSzdoQyxJQUFMLENBQVU4aUMsU0FBN0IsRUFBd0N6aEMsSUFBeEMsRUFBOEMsQ0FBOUMsRUFDbUIsVUFBVWtLLFFBQVYsRUFBb0I7QUFDaEIsVUFBSUEsUUFBUSxDQUFDQyxPQUFiLEVBQXNCO0FBQ2xCd1osZ0JBQVEsQ0FBQ3paLFFBQVEsQ0FBQ2xLLElBQVYsQ0FBUjtBQUNILE9BRkQsTUFFTztBQUNId2hDLHFCQUFhLENBQUN0M0IsUUFBUSxDQUFDak0sT0FBVixDQUFiO0FBQ0FtQixjQUFNLENBQUNzQyxTQUFQLENBQWlCLFVBQWpCLEVBQTZCdEcsV0FBVyxDQUFDd3FCLE1BQXpDLEVBQWlEMWIsUUFBUSxDQUFDak0sT0FBMUQ7QUFDSDtBQUNKLEtBUnBCLEVBU21CLFVBQVU0TyxDQUFWLEVBQWFzekIsVUFBYixFQUF5QlMsV0FBekIsRUFBc0M7QUFDbENZLG1CQUFhLENBQUMsc0NBQUQsQ0FBYjtBQUNBdmhDLGFBQU8sQ0FBQytYLEtBQVIsQ0FBYzRvQixXQUFkO0FBQ0gsS0FacEI7QUFhSCxHQWpCRCxNQWlCTztBQUNIWSxpQkFBYSxDQUFDLDJCQUFELENBQWI7QUFDQSxTQUFLOS9CLFNBQUwsQ0FBZSxVQUFmLEVBQTJCdEcsV0FBVyxDQUFDeWlDLE9BQXZDLEVBQWdELHNDQUFoRDtBQUNIO0FBQ0osQ0F4QkQ7O0FBMEJBcnZCLGFBQWEsQ0FBQ1QsU0FBZCxDQUF3QjlSLFFBQXhCLEdBQW1DLFVBQVU1QyxRQUFWLEVBQW9Cb1AsUUFBcEIsRUFBOEJ1akIsS0FBOUIsRUFBcUM7QUFDcEUsTUFBSUEsS0FBSyxLQUFLejJCLFNBQWQsRUFBeUI7QUFDckJ5MkIsU0FBSyxHQUFHLEtBQUtrUyxXQUFiO0FBQ0g7O0FBQ0QsTUFBSXpuQyxLQUFLLEdBQUcsS0FBS21YLElBQUwsQ0FBVW5YLEtBQXRCOztBQUNBLE1BQUlBLEtBQUssQ0FBQzJDLE9BQU4sQ0FBYzBCLFFBQWQsRUFBSixFQUE4QjtBQUMxQixTQUFLNEcsU0FBTCxDQUFlLFVBQWYsRUFBMkJ0RyxXQUFXLENBQUN5aUMsT0FBdkM7QUFDQTtBQUNIOztBQUNELE1BQUlwbkMsS0FBSyxDQUFDbUwsRUFBTixDQUFTeEMsTUFBVCxDQUFnQnlLLG1CQUFoQixDQUFvQyxVQUFwQyxDQUFKLEVBQXFEO0FBQ2pELFFBQUk3SixJQUFJLEdBQUcsS0FBS3EvQixnQkFBTCxFQUFYO0FBQ0FyL0IsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQjNHLFFBQW5CO0FBQ0EyRyxRQUFJLENBQUMsTUFBRCxDQUFKLEdBQWV5SSxRQUFmO0FBQ0EsU0FBSy9HLFNBQUwsQ0FBZSxVQUFmLEVBQTJCdEcsV0FBVyxDQUFDNkosTUFBdkM7QUFDQSxXQUFPLEtBQUs2NUIsZ0JBQUwsQ0FBc0I5K0IsSUFBdEIsRUFBNEIzRyxRQUE1QixFQUFzQyxVQUF0QyxFQUFrRDJ5QixLQUFsRCxFQUF5RCxLQUFLNlUsaUJBQUwsQ0FBdUI1M0IsSUFBdkIsQ0FBNEIsSUFBNUIsQ0FBekQsQ0FBUDtBQUNILEdBTkQsTUFNTztBQUNILFdBQU8sS0FBS3ZILFNBQUwsQ0FBZSxVQUFmLEVBQTJCdEcsV0FBVyxDQUFDeWlDLE9BQXZDLENBQVA7QUFDSDtBQUNKLENBbEJEOztBQW9CQXJ2QixhQUFhLENBQUNULFNBQWQsQ0FBd0I4eUIsaUJBQXhCLEdBQTRDLFVBQVUzMkIsUUFBVixFQUFvQjtBQUM1RCxNQUFJLENBQUNBLFFBQVEsQ0FBQ0MsT0FBVixJQUFxQkQsUUFBUSxDQUFDdzNCLFFBQWxDLEVBQTRDO0FBQ3hDLFNBQUs5ekIsSUFBTCxDQUFVek8sVUFBVixDQUFxQndELE1BQXJCLENBQTRCd1ksVUFBNUI7QUFDSDtBQUNKLENBSkQ7O0FBTUEzTSxhQUFhLENBQUNULFNBQWQsQ0FBd0IxUixnQkFBeEIsR0FBMkMsVUFBVXJELEtBQVYsRUFBaUJDLE9BQWpCLEVBQTBCMG9DLGNBQTFCLEVBQTBDQyxXQUExQyxFQUF1RDtBQUFBOztBQUM5RixNQUFJLEtBQUtoMEIsSUFBTCxDQUFVblgsS0FBVixDQUFnQjJDLE9BQWhCLENBQXdCMEIsUUFBeEIsRUFBSixFQUF3QztBQUNwQyxTQUFLNEcsU0FBTCxDQUFlLGtCQUFmLEVBQW1DdEcsV0FBVyxDQUFDeWlDLE9BQS9DO0FBQ0E7QUFDSDs7QUFDRCxNQUFJbGEsUUFBUSxHQUFHLEtBQUsvVixJQUFMLENBQVVuWCxLQUFWLENBQWdCdEIsYUFBaEIsQ0FBOEJtSixTQUE5QixDQUF3QzZMLE9BQXZEOztBQUNBLE1BQUksS0FBS3lELElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0JtTCxFQUFoQixDQUFtQnhDLE1BQW5CLENBQTBCeUssbUJBQTFCLENBQThDLGtCQUE5QyxDQUFKLEVBQXVFO0FBQ25FLFFBQUk3SixJQUFJLEdBQUcsS0FBS3EvQixnQkFBTCxFQUFYO0FBQ0FyL0IsUUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQmhILEtBQWhCO0FBQ0FnSCxRQUFJLENBQUMsU0FBRCxDQUFKLEdBQWtCL0csT0FBbEI7QUFDQStHLFFBQUksQ0FBQyxpQkFBRCxDQUFKLEdBQTBCMmhDLGNBQTFCO0FBQ0EzaEMsUUFBSSxDQUFDLGNBQUQsQ0FBSixHQUF1QjRoQyxXQUF2QjtBQUNBLFNBQUtoMEIsSUFBTCxDQUFVek8sVUFBVixDQUFxQm9DLFlBQXJCLENBQWtDQyxFQUFsQyxDQUFxQ3FGLFdBQXJDLENBQWlEZzdCLGdCQUFqRCxDQUFrRSxVQUFDQyxPQUFELEVBQVVDLEdBQVYsRUFBa0I7QUFDaEYvaEMsVUFBSSxDQUFDLE9BQUQsQ0FBSixHQUFnQjhoQyxPQUFoQjs7QUFDQSxVQUFJQyxHQUFHLENBQUNueEIsTUFBUixFQUFnQjtBQUNabXhCLFdBQUcsQ0FBQ254QixNQUFKO0FBQ0g7O0FBQ0QsYUFBSSxDQUFDb3VCLFVBQUwsQ0FBZ0JoL0IsSUFBaEIsRUFBc0Isa0JBQXRCLEVBQTBDLENBQTFDLEVBQ2dCLFVBQUNrSyxRQUFELEVBQWM7QUFDVixZQUFJQSxRQUFRLENBQUNDLE9BQWIsRUFBc0I7QUFDbEIsaUJBQUksQ0FBQ3pJLFNBQUwsQ0FBZSxrQkFBZixFQUFtQ3RHLFdBQVcsQ0FBQ0MsS0FBL0M7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSSxDQUFDcUcsU0FBTCxDQUFlLGtCQUFmLEVBQW1DdEcsV0FBVyxDQUFDd3FCLE1BQS9DLEVBQXVEMWIsUUFBUSxDQUFDak0sT0FBaEU7QUFDSDs7QUFDRCxZQUFJLENBQUMwakMsY0FBRCxJQUFtQjFvQyxPQUFuQixJQUE4QjBxQixRQUFsQyxFQUE0QztBQUN4Q0Esa0JBQVEsQ0FBQzNqQixJQUFJLENBQUMsZUFBRCxDQUFMLENBQVI7QUFDSDtBQUNKLE9BVmpCO0FBV0gsS0FoQkQ7QUFpQkg7QUFDSixDQTlCRCxDOzs7Ozs7Ozs7Ozs7O0FDaGxCQTtBQUFBO0FBQU8sSUFBTTh1QixnQkFBZ0Isc3NDQUF0QixDOzs7Ozs7Ozs7Ozs7QUNBUDtBQUFBO0FBQU8sSUFBSWtULGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBU2xyQyxJQUFULEVBQWU7QUFDdkMsTUFBSW1yQyxHQUFKLEVBQVNDLGFBQVQ7QUFDQUQsS0FBRyxHQUFHO0FBQUNFLFlBQVEsRUFBRTtBQUFYLEdBQU47O0FBRUEsTUFBSSxDQUFDMzBCLEVBQUUsQ0FBQzQwQixHQUFSLEVBQWE7QUFDVDUwQixNQUFFLENBQUM0MEIsR0FBSCxHQUFTO0FBQUNydEIsWUFBTSxFQUFFO0FBQVQsS0FBVDtBQUNILEdBTnNDLENBUXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTc3RCLGNBQVQsQ0FBd0I3TCxHQUF4QixFQUE2QnhwQixNQUE3QixFQUFxQztBQUNqQyxTQUFLczFCLFVBQUwsR0FBa0J0MUIsTUFBbEI7QUFDQSxTQUFLdTFCLFNBQUwsR0FBa0IvTCxHQUFsQjtBQUNIOztBQUVENkwsZ0JBQWMsQ0FBQ3QwQixTQUFmLENBQXlCaWMsSUFBekIsR0FBZ0MsVUFBU3dZLEVBQVQsRUFBYTtBQUN6QyxRQUFJLEtBQUtELFNBQVQsRUFBb0I7QUFDaEIsYUFBTyxJQUFQO0FBQ0g7O0FBRUQsUUFBSTtBQUNBLFdBQUtELFVBQUwsR0FBa0JFLEVBQUUsQ0FBQyxLQUFLRixVQUFOLENBQXBCO0FBQ0gsS0FGRCxDQUVFLE9BQU16MUIsQ0FBTixFQUFTO0FBQ1AsV0FBS3kxQixVQUFMLEdBQWtCL3NDLFNBQWxCO0FBQ0EsV0FBS2d0QyxTQUFMLEdBQWtCMTFCLENBQWxCO0FBQ0g7O0FBRUQsV0FBTyxLQUFLeTFCLFVBQUwsWUFBMkJwdkIsT0FBM0IsR0FBcUMsS0FBS292QixVQUExQyxHQUF1RCxJQUE5RDtBQUNILEdBYkQ7O0FBZUFELGdCQUFjLENBQUN0MEIsU0FBZixZQUFpQyxVQUFTeTBCLEVBQVQsRUFBYTtBQUMxQyxRQUFJLEtBQUtELFNBQVQsRUFBb0I7QUFDaEIsVUFBSTtBQUNBLGFBQUtELFVBQUwsR0FBa0JFLEVBQUUsQ0FBQyxLQUFLRCxTQUFOLENBQXBCO0FBQ0EsYUFBS0EsU0FBTCxHQUFrQmh0QyxTQUFsQjtBQUNILE9BSEQsQ0FHRSxPQUFNc1gsQ0FBTixFQUFTO0FBQ1AsYUFBS3kxQixVQUFMLEdBQWtCL3NDLFNBQWxCO0FBQ0EsYUFBS2d0QyxTQUFMLEdBQWlCMTFCLENBQWpCO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLEtBQUt5MUIsVUFBTCxZQUEyQnB2QixPQUEzQixHQUFxQyxLQUFLb3ZCLFVBQTFDLEdBQXVELElBQTlEO0FBQ0gsR0FaRDs7QUFjQSxNQUFJRyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFTcnNCLFNBQVQsRUFBb0IsQ0FFcEMsQ0FGRDs7QUFJQSxXQUFTc3NCLFFBQVQsQ0FBa0I1ckMsSUFBbEIsRUFBd0I7QUFDcEIsV0FBTyxJQUFJb2MsT0FBSixDQUFZLFVBQVNDLE9BQVQsRUFBa0I0UCxNQUFsQixFQUEwQjtBQUN6QyxVQUFJdlYsRUFBRSxDQUFDNDBCLEdBQUgsQ0FBT3J0QixNQUFQLENBQWNqZSxJQUFkLE1BQXdCdkIsU0FBNUIsRUFBdUM7QUFDbkM7QUFDQTRkLGVBQU8sQ0FBQzNGLEVBQUUsQ0FBQzQwQixHQUFILENBQU9ydEIsTUFBUCxDQUFjamUsSUFBZCxDQUFELENBQVA7QUFDSCxPQUhELE1BR087QUFDSCxZQUFJaXJDLEdBQUcsR0FBRyxJQUFJWSxLQUFKLEVBQVY7QUFDQVosV0FBRyxDQUFDYSxXQUFKLEdBQWtCLFdBQWxCOztBQUNBYixXQUFHLENBQUNuMUIsTUFBSixHQUFhLFlBQVk7QUFDckJZLFlBQUUsQ0FBQzQwQixHQUFILENBQU9ydEIsTUFBUCxDQUFjamUsSUFBZCxJQUFzQmlyQyxHQUF0QjtBQUNBNXVCLGlCQUFPLENBQUM0dUIsR0FBRCxDQUFQO0FBQ0gsU0FIRDs7QUFJQUEsV0FBRyxDQUFDYyxPQUFKLEdBQWMsWUFBWTtBQUN0QjtBQUNBOWYsZ0JBQU0sQ0FBQ2pzQixJQUFELENBQU47QUFDSCxTQUhEOztBQUlBaXJDLFdBQUcsQ0FBQ2UsR0FBSixHQUFVaHNDLElBQVY7QUFDSDtBQUNKLEtBakJNLENBQVA7QUFrQkg7O0FBRUQsTUFBSXVmLEtBQUssR0FBRyxTQUFSQSxLQUFRLENBQVMwc0IsSUFBVCxFQUFlQyxJQUFmLEVBQXFCO0FBQzdCO0FBQ0E7QUFFQUEsUUFBSSxDQUFDQyxRQUFMLEdBQWdCLElBQUl6MUIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixVQUFVdmhDLElBQVYsRUFBZ0J3aEMsV0FBaEIsRUFBNkI7QUFDN0QzMUIsUUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixVQUF2QixFQUFtQ3JyQixTQUFuQyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRDtBQUNBdkssUUFBRSxDQUFDOGYsT0FBSCxDQUFXK1YsV0FBWCxDQUF1QixhQUF2QixFQUFzQyxRQUF0QyxFQUFnRDcxQixFQUFFLENBQUM4ZixPQUFILENBQVdnVyxXQUFYLENBQXVCSCxXQUF2QixDQUFoRDtBQUNBeGhDLFVBQUksQ0FBQ3doQyxXQUFMLEdBQW1CQSxXQUFuQixDQUg2RCxDQUk3RDs7QUFDQSxVQUFJSSxZQUFZLEdBQUdiLFFBQVEsQ0FBQ2wxQixFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCOFUsV0FBakIsQ0FBRCxDQUEzQjtBQUNBLFVBQUlLLElBQUksR0FBRyxJQUFJaDJCLEVBQUUsQ0FBQytjLFFBQUgsQ0FBWWtaLFVBQWhCLEVBQVg7QUFDQTloQyxVQUFJLENBQUMwVSxLQUFMLEdBQWE3SSxFQUFFLENBQUM4ZixPQUFILENBQVdvVyxJQUFYLENBQWdCQyxLQUE3Qjs7QUFDQUgsVUFBSSxDQUFDSSxNQUFMLEdBQWMsWUFBVztBQUNyQixZQUFJSixJQUFJLENBQUN4akMsSUFBTCxDQUFVLE9BQVYsQ0FBSixFQUF3QjtBQUNwQjtBQUNBLGdCQUFNd2pDLElBQUksQ0FBQ3hqQyxJQUFMLENBQVUsT0FBVixDQUFOO0FBQ0gsU0FIRCxNQUdPLENBQ0g7QUFDSDtBQUNKLE9BUEQ7O0FBUUF3akMsVUFBSSxDQUFDeGpDLElBQUwsR0FBWTtBQUNSM0ksWUFBSSxFQUFFLFlBREU7QUFFUndzQyxlQUFPLEVBQUVOLFlBQVksQ0FBQ3ZaLElBQWIsQ0FBa0IsVUFBU3pULEtBQVQsRUFBZ0I7QUFDdkM1VSxjQUFJLENBQUMwVSxLQUFMLEdBQWFFLEtBQWI7QUFDQTVVLGNBQUksQ0FBQzRQLE1BQUwsR0FBY0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWQ7QUFDQTlQLGNBQUksQ0FBQzRQLE1BQUwsQ0FBWXZOLEtBQVosR0FBb0JyQyxJQUFJLENBQUMwVSxLQUFMLENBQVdyUyxLQUEvQjtBQUNBckMsY0FBSSxDQUFDNFAsTUFBTCxDQUFZNkMsTUFBWixHQUFxQnpTLElBQUksQ0FBQzBVLEtBQUwsQ0FBV2pDLE1BQWhDO0FBQ0F6UyxjQUFJLENBQUM0UCxNQUFMLENBQVl1eUIsVUFBWixDQUF1QixJQUF2QixFQUE2QkMsU0FBN0IsQ0FBdUNwaUMsSUFBSSxDQUFDMFUsS0FBNUMsRUFBbUQsQ0FBbkQsRUFBc0QsQ0FBdEQsRUFBeUQxVSxJQUFJLENBQUMwVSxLQUFMLENBQVdyUyxLQUFwRSxFQUEyRXJDLElBQUksQ0FBQzBVLEtBQUwsQ0FBV2pDLE1BQXRGO0FBQ0F6UyxjQUFJLENBQUNxaUMsTUFBTCxHQUFjcmlDLElBQUksQ0FBQzRQLE1BQUwsQ0FBWXV5QixVQUFaLENBQXVCLElBQXZCLEVBQTZCRyxZQUE3QixDQUEwQyxDQUExQyxFQUE2QyxDQUE3QyxFQUFnRHRpQyxJQUFJLENBQUMwVSxLQUFMLENBQVdyUyxLQUEzRCxFQUFrRXJDLElBQUksQ0FBQzBVLEtBQUwsQ0FBV2pDLE1BQTdFLEVBQXFGcFUsSUFBbkcsQ0FOdUMsQ0FPdkM7QUFDSCxTQVJRLEVBUU4sVUFBU3cyQixHQUFULEVBQWM7QUFDYjcwQixjQUFJLENBQUMwVSxLQUFMLEdBQWEsRUFBYjtBQUNBLGdCQUFNbWdCLEdBQU4sQ0FGYSxDQUdiO0FBQ0gsU0FaUTtBQUZELE9BQVo7QUFpQkEsYUFBT2dOLElBQVA7QUFDSCxLQWxDZSxDQUFoQjtBQW9DQVIsUUFBSSxDQUFDcjBCLElBQUwsR0FBWSxJQUFJbkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixVQUFTdmhDLElBQVQsRUFBZTtBQUMzQyxVQUFJNkwsRUFBRSxDQUFDdk4sT0FBSCxLQUFlMUssU0FBbkIsRUFBOEI7QUFDMUIsY0FBTSxJQUFJaVksRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFcsU0FBZixDQUF5Qix3REFBekIsQ0FBTjtBQUNIOztBQUVELFVBQUlDLFdBQVcsR0FBRztBQUNkOXRCLGFBQUssRUFBRTFVLElBQUksQ0FBQzBVLEtBREU7QUFFZDhzQixtQkFBVyxFQUFFeGhDLElBQUksQ0FBQ3doQztBQUZKLE9BQWxCO0FBS0EzMUIsUUFBRSxDQUFDdk4sT0FBSCxDQUFXbWtDLGFBQVgsQ0FBeUJELFdBQXpCO0FBQ0gsS0FYVyxDQUFaO0FBYUFuQixRQUFJLENBQUNxQixJQUFMLEdBQVksSUFBSTcyQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFVBQVN2aEMsSUFBVCxFQUFlO0FBQzNDQSxVQUFJLENBQUMwVSxLQUFMLENBQVdpdUIsS0FBWCxDQUFpQkMsU0FBakIsR0FBNkIsWUFBN0I7O0FBQ0EsVUFBSS8yQixFQUFFLENBQUN2TixPQUFILEtBQWUxSyxTQUFuQixFQUE4QjtBQUMxQixjQUFNLElBQUlpWSxFQUFFLENBQUM4ZixPQUFILENBQVc0VyxTQUFmLENBQXlCLHdEQUF6QixDQUFOO0FBQ0g7O0FBQ0QsYUFBT3ZpQyxJQUFQO0FBQ0gsS0FOVyxDQUFaO0FBT0gsR0E1REQ7O0FBNkRBc2dDLEtBQUcsQ0FBQ1UsS0FBSixHQUFZbjFCLEVBQUUsQ0FBQytjLFFBQUgsQ0FBWWlhLFVBQVosQ0FBdUJ2QyxHQUF2QixFQUE0QjVyQixLQUE1QixFQUFtQyxPQUFuQyxFQUE0QyxFQUE1QyxDQUFaO0FBRUEsU0FBTzRyQixHQUFQO0FBQ0gsQ0E3SU0sQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFPLElBQU1oVCxhQUFhLDQ1Q0FBbkIsQzs7Ozs7Ozs7Ozs7O0FDQVA7QUFBQTtBQUFBOzs7Ozs7OztBQVFPLElBQUlMLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsR0FBVztBQUN2QztBQUNBLE1BQUlxVCxHQUFHLEdBQUcsRUFBVjtBQUNBLE1BQUl5QixJQUFJLEdBQUdsMkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXb1csSUFBWCxDQUFnQkMsS0FBM0I7QUFFQSxNQUFJYyxLQUFLLEdBQUcsSUFBWjtBQUNBeEMsS0FBRyxDQUFDeUMsTUFBSixHQUFhLElBQUlsM0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixVQUFTcHNDLElBQVQsRUFBZTtBQUM1QzBXLE1BQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsUUFBdkIsRUFBaUNyckIsU0FBakMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0M7QUFDQSxRQUFJNHNCLFVBQUo7O0FBQ0EsUUFBSUYsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEJFLGdCQUFVLEdBQUcsQ0FBYjtBQUNILEtBRkQsTUFFTztBQUNIQSxnQkFBVSxHQUFHbkksSUFBSSxDQUFDRCxHQUFMLEtBQWFrSSxLQUExQjtBQUNIOztBQUNEeGtDLFdBQU8sQ0FBQ29OLEdBQVIsQ0FBWUcsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQnYzQixJQUFqQixDQUFaLEVBQW9DNnRDLFVBQVUsR0FBQyxJQUEvQztBQUNBRixTQUFLLEdBQUdqSSxJQUFJLENBQUNELEdBQUwsRUFBUjtBQUNILEdBVlksQ0FBYjtBQVlBOzs7O0FBR0EwRixLQUFHLENBQUMyQyxXQUFKLEdBQWtCLElBQUlwM0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQzdDampDLFdBQU8sQ0FBQ29OLEdBQVIsQ0FBWSwyQkFBSzBLLFNBQUwsRUFBaUJ6UCxHQUFqQixDQUFxQmtGLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQTVCLENBQVo7QUFDSCxHQUZpQixDQUFsQjtBQUlBOzs7O0FBR0E0VCxLQUFHLENBQUM0QyxhQUFKLEdBQW9CLElBQUlyM0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQy9DampDLFdBQU8sQ0FBQ29OLEdBQVIsQ0FBWTBLLFNBQVo7QUFDSCxHQUZtQixDQUFwQjtBQUlBOzs7OztBQUlBa3FCLEtBQUcsQ0FBQzZDLFVBQUosR0FBaUIsSUFBSXQzQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDNUMxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixZQUF2QixFQUFxQ3JyQixTQUFyQyxFQUFnRCxDQUFoRCxFQUFtRCxDQUFuRDs7QUFDQSxRQUFJdkssRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I5Z0IsT0FBbkMsRUFBNEM7QUFDeEMsVUFBSWpOLE1BQU0sR0FBR3NRLEVBQUUsQ0FBQ3lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCLFFBQS9CLEdBQWI7QUFDQS90QixZQUFNLEdBQUdBLE1BQU0sQ0FBQ29MLEdBQVAsQ0FBVyxVQUFTeThCLElBQVQsRUFBZTtBQUFFLGVBQU9BLElBQUksQ0FBQ0MsUUFBTCxFQUFQO0FBQXlCLE9BQXJELENBQVQ7QUFDQSxhQUFPLElBQUl4M0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMlgsSUFBZixDQUFvQi9uQyxNQUFwQixDQUFQO0FBQ0gsS0FKRCxNQUlPO0FBQ0gsYUFBTyxJQUFJc1EsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMlgsSUFBZixDQUFvQixFQUFwQixDQUFQO0FBQ0g7QUFDSixHQVRnQixDQUFqQjtBQVdBOzs7OztBQUlBaEQsS0FBRyxDQUFDaUQsWUFBSixHQUFtQixJQUFJMTNCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsWUFBVztBQUM5QzExQixNQUFFLENBQUM4ZixPQUFILENBQVc4VixXQUFYLENBQXVCLGNBQXZCLEVBQXVDcnJCLFNBQXZDLEVBQWtELENBQWxELEVBQXFELENBQXJEOztBQUNBLFFBQUl2SyxFQUFFLENBQUN5ZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjlnQixPQUFuQyxFQUE0QztBQUN4Q3FELFFBQUUsQ0FBQ3lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCL3RCLE1BQS9CLENBQXNDb1gsU0FBdEM7QUFDSDs7QUFDRCxXQUFPOUcsRUFBRSxDQUFDOGYsT0FBSCxDQUFXb1csSUFBWCxDQUFnQkMsS0FBdkI7QUFDSCxHQU5rQixDQUFuQjtBQVFBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFHQTFCLEtBQUcsQ0FBQ2tELFdBQUosR0FBa0IsSUFBSTMzQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDN0MxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixhQUF2QixFQUFzQ3JyQixTQUF0QyxFQUFpRCxDQUFqRCxFQUFvRCxDQUFwRDtBQUNBLFdBQU92SyxFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJuRCxFQUFFLENBQUN5ZCxnQkFBSCxDQUFvQixVQUFwQixFQUFnQ3J5QixJQUFqRCxDQUFQO0FBQ0gsR0FIaUIsQ0FBbEI7QUFLQTs7OztBQUdBcXBDLEtBQUcsQ0FBQ21ELGNBQUosR0FBcUIsSUFBSTUzQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDaEQxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixnQkFBdkIsRUFBeUNyckIsU0FBekMsRUFBb0QsQ0FBcEQsRUFBdUQsQ0FBdkQ7QUFDQSxXQUFPdkssRUFBRSxDQUFDa0QsR0FBSCxDQUFPQyxTQUFQLENBQWlCbkQsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0J5RixVQUEvQixJQUE2QyxFQUE5RCxDQUFQO0FBQ0gsR0FIb0IsQ0FBckI7QUFLQXVSLEtBQUcsQ0FBQ29ELFdBQUosR0FBa0IsSUFBSTczQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDN0MsUUFBSTExQixFQUFFLENBQUN5ZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjlnQixPQUFuQyxFQUE0QztBQUN4QyxVQUFJNlosS0FBSyxHQUFHeFcsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JxYSxTQUEzQztBQUNBLGFBQU85M0IsRUFBRSxDQUFDa0QsR0FBSCxDQUFPQyxTQUFQLENBQWlCcVQsS0FBakIsQ0FBUDtBQUNILEtBSEQsTUFHTztBQUNILGFBQU8sSUFBSXhXLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzJYLElBQWYsQ0FBb0IsRUFBcEIsQ0FBUDtBQUNIO0FBQ0osR0FQaUIsQ0FBbEI7QUFTQWhELEtBQUcsQ0FBQ3NELFdBQUosR0FBa0IsSUFBSS8zQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDN0M7QUFDQTtBQUNBLFFBQUkxMUIsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I5Z0IsT0FBbkMsRUFBNEM7QUFDeEMsVUFBSXJNLEtBQUssR0FBRzBQLEVBQUUsQ0FBQ3lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCbnRCLEtBQTNDO0FBQ0EsYUFBTzBQLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQjdTLEtBQWpCLENBQVA7QUFDSDs7QUFDRCxXQUFPLElBQUkwUCxFQUFFLENBQUM4ZixPQUFILENBQVd3RSxJQUFmLENBQW9CLEVBQXBCLENBQVA7QUFDSCxHQVJpQixDQUFsQjtBQVVBbVEsS0FBRyxDQUFDdUQsV0FBSixHQUFrQixJQUFJaDRCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsWUFBVztBQUM3QztBQUNBLFFBQUkxMUIsRUFBRSxDQUFDNGUsVUFBSCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QjVlLFFBQUUsQ0FBQzRlLFVBQUgsR0FBZ0I1ZSxFQUFFLENBQUN3aEIsZ0JBQW5CO0FBQ0g7O0FBQ0R4aEIsTUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0J0QixPQUEvQixDQUF1Q3BXLElBQXZDLENBQTRDLElBQTVDLEVBTDZDLENBTTdDO0FBQ0gsR0FQaUIsQ0FBbEI7QUFTQTB1QixLQUFHLENBQUN3RCxVQUFKLEdBQWlCLElBQUlqNEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQzVDO0FBQ0ExMUIsTUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0J0QixPQUEvQixDQUF1Q3VFLEdBQXZDOztBQUNBLFFBQUkxZ0IsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0J0QixPQUEvQixDQUF1Q2pqQixNQUF2QyxLQUFrRCxDQUF0RCxFQUF5RDtBQUNyRDhHLFFBQUUsQ0FBQzRlLFVBQUgsR0FBZ0IsSUFBaEI7QUFDSCxLQUwyQyxDQU01Qzs7QUFDSCxHQVBnQixDQUFqQjtBQVNBOzs7O0FBR0E2VixLQUFHLENBQUN5RCxpQkFBSixHQUF3QixJQUFJbDRCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsWUFBVztBQUNuRDExQixNQUFFLENBQUM4ZixPQUFILENBQVc4VixXQUFYLENBQXVCLG1CQUF2QixFQUE0Q3JyQixTQUE1QyxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDs7QUFDQSxRQUFJdkssRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I5Z0IsT0FBbkMsRUFBNEM7QUFDeEMsYUFBTyxJQUFJcUQsRUFBRSxDQUFDOGYsT0FBSCxDQUFXcVksS0FBZixDQUFxQixDQUFDakMsSUFBRCxFQUFPQSxJQUFQLENBQXJCLENBQVA7QUFDSCxLQUZELE1BRU87QUFDSCxVQUFJMXJCLEtBQUssR0FBR3hLLEVBQUUsQ0FBQ3lkLGdCQUFILENBQW9CLFNBQXBCLEVBQStCalQsS0FBM0M7QUFBQSxVQUNJNHRCLFFBQVEsR0FBRyxFQURmOztBQUVBLFVBQUk1dEIsS0FBSyxJQUFJQSxLQUFLLENBQUNvZSxTQUFmLElBQTRCcGUsS0FBSyxDQUFDb2UsU0FBTixDQUFnQjF2QixNQUFoQixHQUF5QixDQUF6RCxFQUE0RDtBQUN4RGsvQixnQkFBUSxDQUFDLE1BQUQsQ0FBUixHQUFtQjV0QixLQUFLLENBQUNvZSxTQUFOLENBQWdCLENBQWhCLEVBQW1CakQsTUFBdEM7QUFDSCxPQUZELE1BRU87QUFDSG5iLGFBQUssR0FBRzByQixJQUFSO0FBQ0g7O0FBQ0RrQyxjQUFRLEdBQUdwNEIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPQyxTQUFQLENBQWlCaTFCLFFBQWpCLENBQVg7QUFDQSxhQUFPLElBQUlwNEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXcVksS0FBZixDQUFxQixDQUFDM3RCLEtBQUQsRUFBUTR0QixRQUFSLENBQXJCLENBQVA7QUFDSDtBQUNKLEdBZnVCLENBQXhCO0FBa0JBM0QsS0FBRyxDQUFDNEQsd0JBQUosR0FBK0IsSUFBSXI0QixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDMUQxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QiwwQkFBdkIsRUFBbURyckIsU0FBbkQsRUFBOEQsQ0FBOUQsRUFBaUUsQ0FBakU7QUFDQSxXQUFPLENBQUN2SyxFQUFFLENBQUN5ZCxnQkFBSCxDQUFvQixTQUFwQixFQUErQjlnQixPQUFoQyxJQUNDcUQsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JqVCxLQURoQyxJQUVDeEssRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JqVCxLQUEvQixDQUFxQ29aLE9BQXJDLEtBQWlELGdCQUZ6RDtBQUdILEdBTDhCLENBQS9CO0FBT0EsTUFBSTBVLFVBQVUsR0FBR3Z3QyxTQUFqQjtBQUNBMHNDLEtBQUcsQ0FBQzhELG9CQUFKLEdBQTJCLElBQUl2NEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQ3REMTFCLE1BQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsc0JBQXZCLEVBQStDcnJCLFNBQS9DLEVBQTBELENBQTFELEVBQTZELENBQTdEO0FBQ0ErdEIsY0FBVSxHQUFHdDRCLEVBQUUsQ0FBQ3FlLFNBQWhCOztBQUNBLFFBQUlyZSxFQUFFLENBQUMwZSxpQkFBUCxFQUEwQjtBQUN0QjFlLFFBQUUsQ0FBQ3FlLFNBQUgsR0FBZXJlLEVBQUUsQ0FBQzBlLGlCQUFILEVBQWY7QUFDQTFlLFFBQUUsQ0FBQ3c0QixTQUFILEdBQWV4SixJQUFJLENBQUNELEdBQUwsRUFBZjtBQUNIO0FBQ0osR0FQMEIsQ0FBM0I7QUFRQTBGLEtBQUcsQ0FBQ2dFLHNCQUFKLEdBQTZCLElBQUl6NEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQ3hEMTFCLE1BQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsd0JBQXZCLEVBQWlEcnJCLFNBQWpELEVBQTRELENBQTVELEVBQStELENBQS9EO0FBQ0F2SyxNQUFFLENBQUNxZSxTQUFILEdBQWVpYSxVQUFmO0FBQ0F0NEIsTUFBRSxDQUFDdzRCLFNBQUgsR0FBZXhKLElBQUksQ0FBQ0QsR0FBTCxFQUFmO0FBQ0gsR0FKNEIsQ0FBN0I7QUFNQTBGLEtBQUcsQ0FBQ2lFLGtCQUFKLEdBQXlCLElBQUkxNEIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQ3BEMTFCLE1BQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsb0JBQXZCLEVBQTZDcnJCLFNBQTdDLEVBQXdELENBQXhELEVBQTJELENBQTNEO0FBQ0F2SyxNQUFFLENBQUN5ZCxnQkFBSCxDQUFvQjN4QixVQUFwQixDQUErQjQzQixTQUEvQixHQUEyQyxJQUEzQztBQUNILEdBSHdCLENBQXpCO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQStRLEtBQUcsQ0FBQ2tFLFNBQUosR0FBZ0IsSUFBSTM0QixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDM0MxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixXQUF2QixFQUFvQ3JyQixTQUFwQyxFQUErQyxDQUEvQyxFQUFrRCxDQUFsRDs7QUFDQSxRQUFJdkssRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0I5Z0IsT0FBbkMsRUFBNEM7QUFDeEMsVUFBSWk4QixPQUFPLEdBQUc1NEIsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0IsUUFBL0IsR0FBZDtBQUNBbWIsYUFBTyxHQUFHQSxPQUFPLENBQUNub0IsTUFBUixDQUFlLFVBQVMvZ0IsTUFBVCxFQUFpQjtBQUN0QyxlQUFPQSxNQUFNLENBQUM3RixJQUFQLEtBQWdCLE1BQXZCO0FBQ0gsT0FGUyxFQUVQaVIsR0FGTyxDQUVILFVBQVMrOUIsS0FBVCxFQUFnQjtBQUNuQixlQUFPO0FBQUMsa0JBQVFBLEtBQUssQ0FBQy8xQixPQUFOLENBQWNoSSxHQUFkLENBQWtCLFVBQVNnK0IsSUFBVCxFQUFlO0FBQzdDLGdCQUFJQyxPQUFPLEdBQUc7QUFBRSxzQkFBUUQsSUFBSSxDQUFDanZDLElBQWY7QUFDVix1QkFBUztBQURDLGFBQWQ7O0FBRUEsZ0JBQUlpdkMsSUFBSSxDQUFDanZDLElBQUwsS0FBYyxNQUFkLElBQXdCaXZDLElBQUksQ0FBQ2p2QyxJQUFMLEtBQWMsU0FBMUMsRUFBcUQ7QUFDakRrdkMscUJBQU8sQ0FBQyxHQUFELENBQVAsR0FBZUQsSUFBSSxDQUFDdG1DLElBQUwsQ0FBVXNJLEdBQVYsQ0FBYyxVQUFTaytCLENBQVQsRUFBWTtBQUFFLHVCQUFPQSxDQUFDLENBQUNoWSxDQUFUO0FBQWEsZUFBekMsQ0FBZjtBQUNBK1gscUJBQU8sQ0FBQyxHQUFELENBQVAsR0FBZUQsSUFBSSxDQUFDdG1DLElBQUwsQ0FBVXNJLEdBQVYsQ0FBYyxVQUFTaytCLENBQVQsRUFBWTtBQUFFLHVCQUFPQSxDQUFDLENBQUNDLENBQVQ7QUFBYSxlQUF6QyxDQUFmO0FBQ0gsYUFIRCxNQUdPLElBQUlILElBQUksQ0FBQ2p2QyxJQUFMLEtBQWMsTUFBbEIsRUFBMEI7QUFDN0JrdkMscUJBQU8sQ0FBQyxRQUFELENBQVAsR0FBb0JELElBQUksQ0FBQ3RtQyxJQUF6QjtBQUNIOztBQUNELG1CQUFPdW1DLE9BQVA7QUFDSCxXQVZlLENBQVQ7QUFXUCxvQkFBVSxFQVhIO0FBV08sb0JBQVUsRUFYakI7QUFZUCxtQkFBUyxFQVpGO0FBWU0sb0JBQVU7QUFaaEIsU0FBUDtBQWNILE9BakJTLENBQVY7QUFrQkEsYUFBTy80QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJ5MUIsT0FBakIsQ0FBUDtBQUNILEtBckJELE1BcUJPO0FBQ0gsYUFBTzU0QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUIsRUFBakIsQ0FBUDtBQUNIO0FBQ0osR0ExQmUsQ0FBaEIsQ0ExTHVDLENBdU52Qzs7QUFDQXN4QixLQUFHLENBQUN5RSxXQUFKLEdBQWtCbDVCLEVBQUUsQ0FBQytjLFFBQUgsQ0FBWWlhLFVBQVosQ0FBdUJ2QyxHQUF2QixFQUE0QixVQUFTYyxJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDL0RBLFFBQUksQ0FBQ0MsUUFBTCxHQUFnQixJQUFJejFCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsVUFBU3ZoQyxJQUFULEVBQWU7QUFDL0M7QUFDQSxVQUFJZ2xDLE9BQU8sR0FBRyxJQUFJbjVCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3dFLElBQWYsRUFBZDtBQUNBdGtCLFFBQUUsQ0FBQ281QixLQUFILENBQVNDLEtBQVQsQ0FBZWxsQyxJQUFmLEVBQXFCLElBQUk2TCxFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1CLE1BQW5CLENBQXJCLEVBQWlEcVgsT0FBakQsRUFBMEQsSUFBMUQ7QUFDQWhsQyxVQUFJLENBQUNxcEIsTUFBTCxHQUFjeGQsRUFBRSxDQUFDeWQsZ0JBQUgsQ0FBb0IsU0FBcEIsRUFBK0JydEIsT0FBN0M7O0FBQ0EsVUFBSStELElBQUksQ0FBQ3FwQixNQUFMLEtBQWdCejFCLFNBQXBCLEVBQStCO0FBQzNCb00sWUFBSSxDQUFDcXBCLE1BQUwsR0FBY3JwQixJQUFJLENBQUNxcEIsTUFBTCxDQUFZRyxFQUExQjs7QUFDQSxhQUFLLElBQUlqMUIsR0FBVCxJQUFnQnlMLElBQUksQ0FBQ3FwQixNQUFyQixFQUE2QjtBQUN6QixjQUFJcnBCLElBQUksQ0FBQ3FwQixNQUFMLENBQVl3QyxjQUFaLENBQTJCdDNCLEdBQTNCLENBQUosRUFBcUM7QUFDakNzWCxjQUFFLENBQUNvNUIsS0FBSCxDQUFTRSxhQUFULENBQXVCSCxPQUF2QixFQUFnQ241QixFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJuRCxFQUFFLENBQUN1NUIsYUFBSCxDQUFpQjd3QyxHQUFqQixDQUFqQixDQUFoQyxFQUN1QnlMLElBQUksQ0FBQ3FwQixNQUFMLENBQVk5MEIsR0FBWixDQUR2QjtBQUVIO0FBQ0o7QUFDSixPQVJELE1BUU87QUFDSHlMLFlBQUksQ0FBQ3FwQixNQUFMLEdBQWMsRUFBZDtBQUNIOztBQUNELGFBQU94ZCxFQUFFLENBQUM4ZixPQUFILENBQVdvVyxJQUFYLENBQWdCQyxLQUF2QjtBQUNILEtBakJlLENBQWhCOztBQWtCQSxRQUFJcUQsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBU0MsR0FBVCxFQUFjO0FBQ3ZCejVCLFFBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRaLGNBQVgsQ0FBMEIsTUFBMUIsRUFBa0NudkIsU0FBUyxDQUFDclIsTUFBNUMsRUFBb0QsQ0FBcEQsRUFBdUR5bEIsUUFBdkQsRUFBaUUsSUFBakUsRUFBdUUsSUFBdkU7QUFDQSxVQUFJOEIsSUFBSSxHQUFHc0YsS0FBSyxDQUFDeGxCLFNBQU4sQ0FBZ0I5RixLQUFoQixDQUFzQmsvQixJQUF0QixDQUEyQnB2QixTQUEzQixFQUFzQyxDQUF0QyxDQUFYO0FBQ0EsVUFBSWdXLE1BQU0sR0FBRyxJQUFJdmdCLEVBQUUsQ0FBQzQ1QixRQUFILENBQVl0VixJQUFoQixDQUFxQm1WLEdBQXJCLENBQWI7QUFFQSxVQUFJdGxDLElBQUksR0FBR3NzQixJQUFJLENBQUMsQ0FBRCxDQUFmO0FBQ0EsVUFBSUosWUFBWSxHQUFHSSxJQUFJLENBQUMsQ0FBRCxDQUF2QjtBQUNBQSxVQUFJLEdBQUdBLElBQUksQ0FBQ2htQixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBRUEsVUFBSXdULE1BQU0sR0FBR3NTLE1BQU0sQ0FBQ3NaLFNBQVAsQ0FBaUIsSUFBSTc1QixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1CLFFBQW5CLENBQWpCLENBQWI7O0FBQ0EsVUFBSTdULE1BQU0sS0FBS2xtQixTQUFmLEVBQTBCO0FBQ3RCa21CLGNBQU0sR0FBR2pPLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUI1UyxNQUFqQixDQUFUOztBQUNBLFlBQUlBLE1BQU0sQ0FBQzZELFdBQVAsS0FBdUJpVSxLQUEzQixFQUFrQztBQUM5QjlYLGdCQUFNLENBQUNwRSxPQUFQLENBQWUsVUFBUzB0QixJQUFULEVBQWU7QUFDMUJ2M0IsY0FBRSxDQUFDOEYsV0FBSCxDQUFlQyxJQUFmLENBQW9Cd3hCLElBQXBCO0FBQ0gsV0FGRDtBQUdILFNBSkQsTUFJTztBQUNIdjNCLFlBQUUsQ0FBQzhGLFdBQUgsQ0FBZUMsSUFBZixDQUFvQnBXLEtBQXBCO0FBQ0g7QUFDSjs7QUFFRCxVQUFJNkMsSUFBSSxHQUFHMkIsSUFBSSxDQUFDbTFCLFVBQUwsQ0FBZ0IsSUFBSXRwQixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1CLE1BQW5CLENBQWhCLENBQVg7QUFDQSxVQUFJZ1ksY0FBYyxHQUFHdG5DLElBQUksQ0FBQ3FuQyxTQUFMLENBQWV4WixZQUFmLENBQXJCO0FBQ0EsVUFBSTdnQixNQUFNLEdBQUdzNkIsY0FBYyxDQUFDQyxPQUFmLENBQXVCdFosSUFBdkIsQ0FBYjtBQUNBLGFBQU9qaEIsTUFBUDtBQUNILEtBekJEOztBQTBCQWc2QixVQUFNLENBQUNRLFNBQVAsR0FBbUIsSUFBbkIsQ0E3QytELENBOEMvRDs7QUFDQVIsVUFBTSxDQUFDUyxPQUFQLEdBQWdCLElBQUlqNkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXZ0MsR0FBZixDQUFtQixNQUFuQixDQUFoQjtBQUNBMFQsUUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQixJQUFJeDFCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0I4RCxNQUFwQixDQUFwQjtBQUVBaEUsUUFBSSxDQUFDLFVBQUQsQ0FBSixHQUFtQixJQUFJeDFCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsVUFBU3ZoQyxJQUFULEVBQWU7QUFDbEQsYUFBTyxJQUFJNkwsRUFBRSxDQUFDOGYsT0FBSCxDQUFXZ0MsR0FBZixDQUFtQixFQUFuQixDQUFQO0FBQ0gsS0FGa0IsQ0FBbkI7QUFJQTBULFFBQUksQ0FBQzBFLGlCQUFMLEdBQXlCLElBQUlsNkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixVQUFTdmhDLElBQVQsRUFBZXRLLElBQWYsRUFBcUJzd0MsZ0JBQXJCLEVBQXVDO0FBQ2hGbjZCLFFBQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsbUJBQXZCLEVBQTRDcnJCLFNBQTVDLEVBQXVELENBQXZELEVBQTBELENBQTFEOztBQUNBLFVBQUk0dkIsZ0JBQWdCLEtBQUtweUMsU0FBekIsRUFBb0M7QUFDaENveUMsd0JBQWdCLEdBQUcsSUFBbkI7QUFDSCxPQUZELE1BRU87QUFDSG42QixVQUFFLENBQUM4ZixPQUFILENBQVcrVixXQUFYLENBQXVCLGtCQUF2QixFQUEyQyxTQUEzQyxFQUFzRDcxQixFQUFFLENBQUM4ZixPQUFILENBQVdzYSxTQUFYLENBQXFCRCxnQkFBckIsQ0FBdEQ7QUFDQUEsd0JBQWdCLEdBQUduNkIsRUFBRSxDQUFDa0QsR0FBSCxDQUFPMmQsU0FBUCxDQUFpQnNaLGdCQUFqQixDQUFuQjtBQUNIOztBQUNELFVBQUkzNkIsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsV0FBSyxJQUFJNjZCLFFBQVQsSUFBcUJsbUMsSUFBSSxDQUFDcXBCLE1BQTFCLEVBQWtDO0FBQzlCLFlBQUlycEIsSUFBSSxDQUFDcXBCLE1BQUwsQ0FBWXdDLGNBQVosQ0FBMkJxYSxRQUEzQixDQUFKLEVBQTBDO0FBQ3RDLGNBQUlsbUMsSUFBSSxDQUFDcXBCLE1BQUwsQ0FBWTZjLFFBQVosRUFBc0J6VyxPQUF0QixLQUFrQy81QixJQUFJLENBQUMrNUIsT0FBM0MsRUFBb0Q7QUFDaEQ7QUFDQSxnQkFBSXVXLGdCQUFnQixJQUFJRSxRQUFRLENBQUM3L0IsVUFBVCxDQUFvQixJQUFwQixDQUF4QixFQUFtRDtBQUMvQztBQUNIOztBQUNEZ0Ysa0JBQU0sQ0FBQ3VHLElBQVAsQ0FBWS9GLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBT0MsU0FBUCxDQUFpQm5ELEVBQUUsQ0FBQ3U1QixhQUFILENBQWlCYyxRQUFqQixDQUFqQixDQUFaO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sSUFBSXI2QixFQUFFLENBQUM4ZixPQUFILENBQVcyWCxJQUFmLENBQW9CajRCLE1BQXBCLENBQVA7QUFDSCxLQXJCd0IsQ0FBekI7QUF1QkFnMkIsUUFBSSxDQUFDOEUsa0JBQUwsR0FBMEIsSUFBSXQ2QixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFVBQVN2aEMsSUFBVCxFQUFldEssSUFBZixFQUFxQnN3QyxnQkFBckIsRUFBdUM7QUFDakZuNkIsUUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixvQkFBdkIsRUFBNkNyckIsU0FBN0MsRUFBd0QsQ0FBeEQsRUFBMkQsQ0FBM0Q7O0FBQ0EsVUFBSTR2QixnQkFBZ0IsS0FBS3B5QyxTQUF6QixFQUFvQztBQUNoQ295Qyx3QkFBZ0IsR0FBRyxJQUFuQjtBQUNILE9BRkQsTUFFTztBQUNIbjZCLFVBQUUsQ0FBQzhmLE9BQUgsQ0FBVytWLFdBQVgsQ0FBdUIsa0JBQXZCLEVBQTJDLFNBQTNDLEVBQXNENzFCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3NhLFNBQVgsQ0FBcUJELGdCQUFyQixDQUF0RDtBQUNBQSx3QkFBZ0IsR0FBR242QixFQUFFLENBQUNrRCxHQUFILENBQU8yZCxTQUFQLENBQWlCc1osZ0JBQWpCLENBQW5CO0FBQ0g7O0FBQ0QsVUFBSTM2QixNQUFNLEdBQUcsRUFBYjs7QUFDQSxXQUFLLElBQUk2NkIsUUFBVCxJQUFxQmxtQyxJQUFJLENBQUNxcEIsTUFBMUIsRUFBa0M7QUFDOUIsWUFBSXJwQixJQUFJLENBQUNxcEIsTUFBTCxDQUFZd0MsY0FBWixDQUEyQnFhLFFBQTNCLENBQUosRUFBMEM7QUFDdEMsY0FBSWxtQyxJQUFJLENBQUNxcEIsTUFBTCxDQUFZNmMsUUFBWixFQUFzQnpXLE9BQXRCLEtBQWtDLzVCLElBQUksQ0FBQys1QixPQUEzQyxFQUFvRDtBQUNoRCxnQkFBSXVXLGdCQUFnQixJQUFJRSxRQUFRLENBQUM3L0IsVUFBVCxDQUFvQixJQUFwQixDQUF4QixFQUFtRDtBQUMvQztBQUNIOztBQUNEZ0Ysa0JBQU0sQ0FBQ3VHLElBQVAsQ0FBWTVSLElBQUksQ0FBQ3FwQixNQUFMLENBQVk2YyxRQUFaLENBQVo7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsYUFBTyxJQUFJcjZCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzJYLElBQWYsQ0FBb0JqNEIsTUFBcEIsQ0FBUDtBQUNILEtBcEJ5QixDQUExQjtBQXFCSCxHQWxHaUIsRUFrR2YsYUFsR2UsQ0FBbEI7QUFtR0FpMUIsS0FBRyxDQUFDNWtDLE9BQUosR0FBY21RLEVBQUUsQ0FBQytjLFFBQUgsQ0FBWXdkLGdCQUFaLENBQTZCOUYsR0FBRyxDQUFDeUUsV0FBakMsQ0FBZDtBQUVBekUsS0FBRyxDQUFDK0YsZ0JBQUosR0FBdUIsSUFBSXg2QixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFlBQVc7QUFDbEQxMUIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixrQkFBdkIsRUFBMkNyckIsU0FBM0MsRUFBc0QsQ0FBdEQsRUFBeUQsQ0FBekQ7QUFDQSxXQUFPa3FCLEdBQUcsQ0FBQzVrQyxPQUFYO0FBQ0gsR0FIc0IsQ0FBdkI7QUFLQTRrQyxLQUFHLENBQUNnRyxnQkFBSixHQUF1QixJQUFJejZCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsVUFBU2dGLGVBQVQsRUFBMEI7QUFDakUxNkIsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixrQkFBdkIsRUFBMkNyckIsU0FBM0MsRUFBc0QsQ0FBdEQsRUFBeUQsQ0FBekQ7QUFDQW13QixtQkFBZSxHQUFHMTZCLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUI2WixlQUFqQixDQUFsQjtBQUNBMTZCLE1BQUUsQ0FBQ3lkLGdCQUFILENBQW9CLE9BQXBCLEVBQTZCN3hCLE9BQTdCLENBQXFDa0IsbUJBQXJDLENBQXlENHRDLGVBQXpEO0FBQ0gsR0FKc0IsQ0FBdkI7QUFNQWpHLEtBQUcsQ0FBQ2tHLGNBQUosR0FBcUIsSUFBSTM2QixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFVBQVNocUIsSUFBVCxFQUFlO0FBQ3BEMUwsTUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixnQkFBdkIsRUFBeUNyckIsU0FBekMsRUFBb0QsQ0FBcEQsRUFBdUQsQ0FBdkQ7QUFDQSxRQUFJdGhCLEtBQUssR0FBRytXLEVBQUUsQ0FBQ3lkLGdCQUFILENBQW9CLE9BQXBCLENBQVo7QUFDQS9SLFFBQUksR0FBRzFMLEVBQUUsQ0FBQ2tELEdBQUgsQ0FBTzJkLFNBQVAsQ0FBaUJuVixJQUFqQixFQUF1QmxELEtBQXZCLENBQTZCLEdBQTdCLENBQVA7O0FBQ0EsU0FBSyxJQUFJRSxDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUdnRCxJQUFJLENBQUN4UyxNQUF2QixFQUErQndQLENBQUMsRUFBaEMsRUFBb0M7QUFDaEN6ZixXQUFLLEdBQUdBLEtBQUssQ0FBQ3lpQixJQUFJLENBQUNoRCxDQUFELENBQUwsQ0FBYjtBQUNIOztBQUNELFdBQU8xSSxFQUFFLENBQUNrRCxHQUFILENBQU9DLFNBQVAsQ0FBaUJsYSxLQUFLLEVBQXRCLENBQVA7QUFDSCxHQVJvQixDQUFyQjtBQVVBd3JDLEtBQUcsQ0FBQ21HLDhCQUFKLEdBQXFDLElBQUk1NkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixZQUFXO0FBQ2hFMTFCLE1BQUUsQ0FBQzhmLE9BQUgsQ0FBVzhWLFdBQVgsQ0FBdUIsa0JBQXZCLEVBQTJDcnJCLFNBQTNDLEVBQXNELENBQXRELEVBQXlELENBQXpEO0FBQ0F2SyxNQUFFLENBQUMwaEIsMkJBQUg7QUFDSCxHQUhvQyxDQUFyQztBQUtBLFNBQU8rUyxHQUFQO0FBQ0gsQ0F4Vk0sQzs7Ozs7Ozs7Ozs7O0FDUlA7QUFBQTtBQUFPLElBQUlELGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBU2xyQyxJQUFULEVBQWU7QUFDdkMsTUFBSW1yQyxHQUFKLEVBQVNDLGFBQVQ7QUFDQUQsS0FBRyxHQUFHO0FBQUNFLFlBQVEsRUFBRTtBQUFYLEdBQU47QUFFQTs7OztBQUlBLE1BQUlrRyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFTdEYsSUFBVCxFQUFlQyxJQUFmLEVBQXFCO0FBQy9CQSxRQUFJLENBQUNDLFFBQUwsR0FBZ0IsSUFBSXoxQixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFmLENBQW9CLFVBQVV2aEMsSUFBVixFQUFnQjNCLElBQWhCLEVBQXNCO0FBQ3REd04sUUFBRSxDQUFDOGYsT0FBSCxDQUFXOFYsV0FBWCxDQUF1QixVQUF2QixFQUFtQ3JyQixTQUFuQyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRDtBQUNBdkssUUFBRSxDQUFDOGYsT0FBSCxDQUFXK1YsV0FBWCxDQUF1QixNQUF2QixFQUErQixVQUEvQixFQUEyQzcxQixFQUFFLENBQUM4ZixPQUFILENBQVdnYixhQUFYLENBQXlCdG9DLElBQXpCLENBQTNDO0FBQ0EyQixVQUFJLENBQUMzQixJQUFMLEdBQVksRUFBWjtBQUNBLFVBQUl1b0MsSUFBSSxHQUFHLzZCLEVBQUUsQ0FBQ281QixLQUFILENBQVMyQixJQUFULENBQWN2b0MsSUFBZCxDQUFYO0FBQ0EsVUFBSWlHLElBQUo7O0FBQ0EsU0FBRztBQUNDQSxZQUFJLEdBQUd1SCxFQUFFLENBQUNvNUIsS0FBSCxDQUFTNEIsUUFBVCxDQUFrQkQsSUFBbEIsQ0FBUDs7QUFDQSxZQUFJdGlDLElBQUksS0FBSzFRLFNBQWIsRUFBd0I7QUFDcEJvTSxjQUFJLENBQUMzQixJQUFMLENBQVV1VCxJQUFWLENBQWUsSUFBSWsxQixPQUFKLENBQVl4aUMsSUFBWixDQUFmO0FBQ0g7QUFDSixPQUxELFFBS1NBLElBQUksS0FBSzFRLFNBTGxCOztBQU1BLGFBQU9pWSxFQUFFLENBQUM4ZixPQUFILENBQVdvVyxJQUFYLENBQWdCQyxLQUF2QjtBQUNILEtBYmUsQ0FBaEI7QUFlQVgsUUFBSSxDQUFDMEYsUUFBTCxHQUFnQixJQUFJbDdCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRWLElBQWYsQ0FBb0IsVUFBU3ZoQyxJQUFULEVBQWU7QUFDL0MsVUFBTWduQyxVQUFVLEdBQUcsRUFBbkI7O0FBQ0EsV0FBSyxJQUFJenlCLENBQUMsR0FBQyxDQUFYLEVBQWNBLENBQUMsR0FBR3ZVLElBQUksQ0FBQzNCLElBQUwsQ0FBVTBHLE1BQTVCLEVBQW9Dd1AsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQyxZQUFNNnVCLElBQUksR0FBR3BqQyxJQUFJLENBQUMzQixJQUFMLENBQVVrVyxDQUFWLEVBQWEweUIsS0FBYixFQUFiOztBQUNBLFlBQUk3RCxJQUFJLEtBQUt4dkMsU0FBYixFQUF3QjtBQUNwQm96QyxvQkFBVSxDQUFDcDFCLElBQVgsQ0FBZ0J3eEIsSUFBaEI7QUFDSDtBQUNKOztBQUNEcGpDLFVBQUksQ0FBQzNCLElBQUwsR0FBWTJvQyxVQUFaO0FBQ0EsYUFBT243QixFQUFFLENBQUNvNUIsS0FBSCxDQUFTMkIsSUFBVCxDQUFjLElBQUkvNkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMlgsSUFBZixDQUFvQjBELFVBQXBCLENBQWQsQ0FBUDtBQUNILEtBVmUsQ0FBaEI7QUFZQTs7OztBQUlBM0YsUUFBSSxDQUFDcjhCLEdBQUwsR0FBVyxJQUFJNkcsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNFYsSUFBZixDQUFvQixVQUFTdmhDLElBQVQsRUFBZW9qQyxJQUFmLEVBQXFCO0FBQ2hEcGpDLFVBQUksQ0FBQzNCLElBQUwsQ0FBVXVULElBQVYsQ0FBZSxJQUFJazFCLE9BQUosQ0FBWTFELElBQVosQ0FBZjtBQUNILEtBRlUsQ0FBWDtBQUdILEdBbkNEOztBQW9DQTlDLEtBQUcsQ0FBQ29HLE9BQUosR0FBYzc2QixFQUFFLENBQUMrYyxRQUFILENBQVlpYSxVQUFaLENBQXVCdkMsR0FBdkIsRUFBNEJvRyxPQUE1QixFQUFxQyxTQUFyQyxFQUFnRCxFQUFoRCxDQUFkO0FBRUEsU0FBT3BHLEdBQVA7QUFDSCxDQS9DTSxDOzs7Ozs7Ozs7Ozs7QUNBUDtBQUFBO0FBQUEsSUFBSTRHLGlCQUFKOztBQUNBLElBQUk7QUFDQUEsbUJBQWlCLEdBQUdDLFlBQXBCO0FBQ0EsTUFBSTdHLEdBQUcsR0FBRywyQkFBVjtBQUNBNEcsbUJBQWlCLENBQUNFLE9BQWxCLENBQTBCOUcsR0FBMUIsRUFBK0JBLEdBQS9CO0FBQ0E0RyxtQkFBaUIsQ0FBQ0csVUFBbEIsQ0FBNkIvRyxHQUE3QjtBQUNILENBTEQsQ0FLRSxPQUFNcDFCLENBQU4sRUFBUztBQUNQZzhCLG1CQUFpQixHQUFHO0FBQ2hCSSxTQUFLLEVBQVMsRUFERTtBQUVoQkYsV0FBTyxFQUFPLGlCQUFTcHlDLEVBQVQsRUFBYXlXLEdBQWIsRUFBa0I7QUFBRSxhQUFPLEtBQUs2N0IsS0FBTCxDQUFXdHlDLEVBQVgsSUFBaUJ1eUMsTUFBTSxDQUFDOTdCLEdBQUQsQ0FBOUI7QUFBc0MsS0FGeEQ7QUFHaEIrN0IsV0FBTyxFQUFPLGlCQUFTeHlDLEVBQVQsRUFBYTtBQUFFLGFBQU8sS0FBS3N5QyxLQUFMLENBQVd6YixjQUFYLENBQTBCNzJCLEVBQTFCLElBQWdDLEtBQUtzeUMsS0FBTCxDQUFXdHlDLEVBQVgsQ0FBaEMsR0FBaUQsSUFBeEQ7QUFBK0QsS0FINUU7QUFJaEJxeUMsY0FBVSxFQUFJLG9CQUFTcnlDLEVBQVQsRUFBYTtBQUFFLGFBQU8sT0FBTyxLQUFLc3lDLEtBQUwsQ0FBV3R5QyxFQUFYLENBQWQ7QUFBK0IsS0FKNUM7QUFLaEIwZCxTQUFLLEVBQVMsaUJBQVc7QUFBRSxhQUFPLEtBQUs0MEIsS0FBTCxHQUFhLEVBQXBCO0FBQXlCO0FBTHBDLEdBQXBCO0FBT0g7QUFFRDs7Ozs7Ozs7Ozs7OztBQVdPLFNBQVN6eUMsbUJBQVQsQ0FBNkJpa0MsU0FBN0IsRUFBd0M7QUFDM0MsT0FBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFDSDtBQUNEOzs7Ozs7OztBQU9BamtDLG1CQUFtQixDQUFDdVgsU0FBcEIsQ0FBOEI4d0IsR0FBOUIsR0FBcUMsVUFBUzNvQyxHQUFULEVBQWNxZ0IsS0FBZCxFQUFxQjtBQUN0RHN5QixtQkFBaUIsQ0FBQ0UsT0FBbEIsQ0FBMEIsS0FBS3RPLFNBQUwsR0FBZSxHQUFmLEdBQW1CdmtDLEdBQW5CLEdBQXVCLFFBQWpELEVBQTJEcWdCLEtBQTNEO0FBQ0FzeUIsbUJBQWlCLENBQUNFLE9BQWxCLENBQTBCLEtBQUt0TyxTQUFMLEdBQWUsR0FBZixHQUFtQnZrQyxHQUFuQixHQUF1QixZQUFqRCxFQUErRDhJLENBQUMsQ0FBQ3U5QixHQUFGLEVBQS9EO0FBQ0gsQ0FIRDtBQUtBOzs7Ozs7O0FBS0EvbEMsbUJBQW1CLENBQUN1WCxTQUFwQixDQUE4QjZDLE1BQTlCLEdBQXVDLFVBQVMxYSxHQUFULEVBQWM7QUFDakQyeUMsbUJBQWlCLENBQUNHLFVBQWxCLENBQTZCLEtBQUt2TyxTQUFMLEdBQWUsR0FBZixHQUFtQnZrQyxHQUFuQixHQUF1QixRQUFwRDtBQUNBMnlDLG1CQUFpQixDQUFDRyxVQUFsQixDQUE2QixLQUFLdk8sU0FBTCxHQUFlLEdBQWYsR0FBbUJ2a0MsR0FBbkIsR0FBdUIsWUFBcEQ7QUFDSCxDQUhEO0FBS0E7Ozs7Ozs7QUFLQU0sbUJBQW1CLENBQUN1WCxTQUFwQixDQUE4QnhYLEdBQTlCLEdBQW9DLFVBQVNMLEdBQVQsRUFBYztBQUM5QyxTQUFPMnlDLGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLMU8sU0FBTCxHQUFlLEdBQWYsR0FBbUJ2a0MsR0FBbkIsR0FBdUIsUUFBakQsQ0FBUDtBQUNILENBRkQ7QUFJQTs7Ozs7Ozs7QUFNQU0sbUJBQW1CLENBQUN1WCxTQUFwQixDQUE4Qnd4QixPQUE5QixHQUF3QyxVQUFTcnBDLEdBQVQsRUFBYztBQUNsRCxTQUFPKzFCLFFBQVEsQ0FBQzRjLGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLMU8sU0FBTCxHQUFlLEdBQWYsR0FBbUJ2a0MsR0FBbkIsR0FBdUIsWUFBakQsQ0FBRCxDQUFmO0FBQ0gsQ0FGRDtBQUlBOzs7Ozs7Ozs7O0FBUUFNLG1CQUFtQixDQUFDdVgsU0FBcEIsQ0FBOEJpd0IsVUFBOUIsR0FBMkMsVUFBUzluQyxHQUFULEVBQWNDLFlBQWQsRUFBNEI7QUFDbkUsTUFBSSxLQUFLRyxHQUFMLENBQVNKLEdBQVQsQ0FBSixFQUFtQjtBQUNmLFdBQU8sS0FBS0ssR0FBTCxDQUFTTCxHQUFULENBQVA7QUFDSCxHQUZELE1BRU87QUFDSCxTQUFLMm9DLEdBQUwsQ0FBUzNvQyxHQUFULEVBQWNDLFlBQWQ7QUFDQSxXQUFPQSxZQUFQO0FBQ0g7QUFDSixDQVBEO0FBU0E7Ozs7Ozs7QUFLQUssbUJBQW1CLENBQUN1WCxTQUFwQixDQUE4QnpYLEdBQTlCLEdBQW9DLFVBQVNKLEdBQVQsRUFBYztBQUM5QyxTQUFPMnlDLGlCQUFpQixDQUFDTSxPQUFsQixDQUEwQixLQUFLMU8sU0FBTCxHQUFlLEdBQWYsR0FBbUJ2a0MsR0FBbkIsR0FBdUIsUUFBakQsTUFBK0QsSUFBdEU7QUFDSCxDQUZEO0FBSUE7Ozs7Ozs7Ozs7QUFRQU0sbUJBQW1CLENBQUN1WCxTQUFwQixDQUE4QnE3QixNQUE5QixHQUF1QyxVQUFTbHpDLEdBQVQsRUFBY216QyxXQUFkLEVBQTJCO0FBQzlELE1BQUlDLFdBQVcsR0FBR1QsaUJBQWlCLENBQUNNLE9BQWxCLENBQTBCLEtBQUsxTyxTQUFMLEdBQWUsR0FBZixHQUFtQnZrQyxHQUFuQixHQUF1QixZQUFqRCxDQUFsQjtBQUNBLFNBQVFtekMsV0FBVyxJQUFJQyxXQUFXLEdBQUMsSUFBbkM7QUFDSCxDQUhELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekdPLElBQU0zTCxVQUFVLDgzRkFBaEI7QUF3RUEsSUFBTWo0QixnQkFBZ0IsR0FBRztBQUM1QixTQUFPLHNCQURxQjtBQUU1QixTQUFPLHdCQUZxQjtBQUc1QixlQUFhLHlCQUhlO0FBSTVCLFlBQVUscUJBSmtCO0FBSzVCLFlBQVUseUJBTGtCO0FBTTVCLGNBQVkseUJBTmdCO0FBTzVCLHNCQUFvQixvQ0FQUTtBQVE1QixlQUFhLCtCQVJlO0FBUzVCLGVBQWEsc0NBVGU7QUFVNUIsZUFBYSx5QkFWZTtBQVc1QixhQUFXLG1CQVhpQjtBQVk1QixjQUFZLG9CQVpnQjtBQWE1QixXQUFTLG9CQWJtQjtBQWM1QixXQUFTLG1CQWRtQjtBQWU1QixZQUFVLHdCQWZrQjtBQWdCNUIsV0FBUyx1QkFoQm1CO0FBaUI1QixZQUFVLHdCQWpCa0I7QUFrQjVCLFlBQVUsb0JBbEJrQjtBQW1CNUIsV0FBUyxtQkFuQm1CO0FBb0I1QixXQUFTLHdCQXBCbUI7QUFxQjVCLFVBQVEsaUJBckJvQjtBQXNCNUIsY0FBWSxvQkF0QmdCO0FBdUI1QixhQUFXLHNCQXZCaUI7QUF3QjVCLGNBQVksaUJBeEJnQjtBQXlCNUIsY0FBWSxzQkF6QmdCO0FBMEI1QixTQUFPLG9CQTFCcUI7QUEyQjVCLFlBQVUsWUEzQmtCO0FBNEI1QixVQUFRLHNCQTVCb0I7QUE2QjVCLGNBQVksNEJBN0JnQjtBQThCNUIsU0FBTyxxQkE5QnFCO0FBK0I1QixjQUFZLGFBL0JnQjtBQWdDNUIsUUFBTSxpQ0FoQ3NCO0FBaUM1QixtQkFBaUIsbUJBakNXO0FBa0M1QixVQUFRLG1DQWxDb0I7QUFtQzVCLGdCQUFjLHlCQW5DYztBQW9DNUIsY0FBWSwyQkFwQ2dCO0FBcUM1QixjQUFZLDhCQXJDZ0I7QUFzQzVCLFNBQU8sWUF0Q3FCO0FBdUM1QixvQkFBa0Isa0NBdkNVO0FBd0M1QixpQkFBZSx1QkF4Q2E7QUF5QzVCLGtCQUFnQix3QkF6Q1k7QUEwQzVCLFlBQVUsb0JBMUNrQjtBQTJDNUIsUUFBTSxvQ0EzQ3NCO0FBNEM1QixTQUFPLGdEQTVDcUI7QUE2QzVCLFFBQU0saUJBN0NzQjtBQThDNUIsV0FBUyxrQkE5Q21CO0FBK0M1QixZQUFVLHFCQS9Da0I7QUFnRDVCLGdCQUFjLDBCQWhEYztBQWlENUIsUUFBTSxnQkFqRHNCO0FBa0Q1QixXQUFTLFVBbERtQjtBQW1ENUIsaUJBQWUsMkJBbkRhO0FBb0Q1QixZQUFVLG9CQXBEa0I7QUFxRDVCLFFBQU0sZ0JBckRzQjtBQXNENUIsV0FBUyxvQkF0RG1CO0FBdUQ1QixlQUFhLGFBdkRlO0FBd0Q1QixZQUFVLHVCQXhEa0I7QUF5RDVCLFlBQVUscUJBekRrQjtBQTBENUIsVUFBUSxnQkExRG9CO0FBMkQ1QixjQUFZLHNCQTNEZ0I7QUE0RDVCLFVBQVEsUUE1RG9CO0FBNkQ1QixRQUFNLGlDQTdEc0I7QUE4RDVCLFNBQU8sNkNBOURxQjtBQStENUIsYUFBVyxrQ0EvRGlCO0FBZ0U1QixTQUFPLG1CQWhFcUI7QUFpRTVCLFlBQVUsVUFqRWtCO0FBa0U1QixVQUFRLDJCQWxFb0I7QUFtRTVCLFVBQVEsUUFuRW9CO0FBb0U1QixrQkFBZ0IsaUJBcEVZO0FBcUU1QixjQUFZLHNCQXJFZ0I7QUFzRTVCLFNBQU8sZ0JBdEVxQjtBQXVFNUIsV0FBUyxvQ0F2RW1CO0FBd0U1QixXQUFTLG1CQXhFbUI7QUF5RTVCLFNBQU8sbUJBekVxQjtBQTBFNUIsUUFBTSx1QkExRXNCO0FBMkU1QixXQUFTLGFBM0VtQjtBQTRFNUIsVUFBUSxrQkE1RW9CO0FBNkU1QixTQUFPLGtCQTdFcUI7QUE4RTVCLFlBQVUsd0JBOUVrQjtBQStFNUIsV0FBUyxtQkEvRW1CO0FBZ0Y1QixZQUFVLG9CQWhGa0I7QUFpRjVCLFNBQU8sZUFqRnFCO0FBa0Y1QixhQUFXLHFCQWxGaUI7QUFtRjVCLFdBQVMsU0FuRm1CO0FBb0Y1QixhQUFXLG9CQXBGaUI7QUFxRjVCLFdBQVMsU0FyRm1CO0FBc0Y1QixTQUFPLGtCQXRGcUI7QUF1RjVCLFNBQU8sd0JBdkZxQjtBQXdGNUIsZUFBYSxhQXhGZTtBQXlGNUIsV0FBUyxTQXpGbUI7QUEwRjVCLFNBQU8saUJBMUZxQjtBQTJGNUIsV0FBUyxpQkEzRm1CO0FBNEY1QixnQkFBYyxnQkE1RmM7QUE2RjVCLFVBQVEsMkJBN0ZvQjtBQThGNUIsVUFBUSw4QkE5Rm9CO0FBK0Y1QixhQUFXLGtCQS9GaUI7QUFnRzVCLFdBQVMsY0FoR21CO0FBaUc1QixVQUFRLGtCQWpHb0I7QUFrRzVCLFdBQVMsbUJBbEdtQjtBQW1HNUIsZUFBYTtBQW5HZSxDQUF6QjtBQXNHQSxJQUFNeUksWUFBYjtBQUVJLHdCQUFZUCxJQUFaLEVBQWtCbUcsR0FBbEIsRUFBdUI7QUFBQTs7QUFDbkIsU0FBS25HLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUttRyxHQUFMLEdBQVdBLEdBQVg7QUFFQSxTQUFLdzFCLGVBQUwsR0FBdUIsQ0FBQyxVQUFELEVBQWEsU0FBYixFQUF3QixhQUF4QixFQUNDLGFBREQsRUFDZ0IsVUFEaEIsRUFDNEIsY0FENUIsRUFDNEMsT0FENUMsRUFDcUQsT0FEckQsQ0FBdkIsQ0FKbUIsQ0FPbkI7QUFDSDtBQUVEOzs7Ozs7OztBQVpKO0FBQUE7QUFBQSxpQ0FrQmlCQyxTQWxCakIsRUFrQjRCO0FBQ3BCLFVBQUl4OEIsTUFBTSxHQUFHLEVBQWI7QUFDQSxVQUFJOGxCLE9BQU8sR0FBRyxFQUFkLENBRm9CLENBR3BCOztBQUNBLFVBQUksQ0FBQyxLQUFLbGxCLElBQUwsQ0FBVW5YLEtBQVYsQ0FBZ0IyQyxPQUFoQixDQUF3QmdCLGNBQXhCLEVBQUwsRUFBK0M7QUFDM0M7Ozs7QUFHQTs7O0FBR0EsYUFBSyxJQUFJeXRDLFFBQVQsSUFBcUIyQixTQUFyQixFQUFnQztBQUM1QixjQUFJanpCLEtBQUssR0FBR2l6QixTQUFTLENBQUMzQixRQUFELENBQXJCOztBQUNBLGNBQUksS0FBSzBCLGVBQUwsQ0FBcUIxZ0MsT0FBckIsQ0FBNkJnL0IsUUFBN0IsTUFBMkMsQ0FBQyxDQUE1QyxJQUFpRHR4QixLQUFLLEtBQUtoaEIsU0FBL0QsRUFBMEU7QUFDdEVzeUMsb0JBQVEsR0FBR0EsUUFBUSxDQUFDanNCLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEIsRUFBMUIsRUFDTkEsT0FETSxDQUNFLE9BREYsRUFDVyxFQURYLENBQVg7QUFFQSxnQkFBSTZ0QixNQUFNLFNBQVY7O0FBQ0EsZ0JBQUk7QUFDQUEsb0JBQU0sR0FBR3Q3QixZQUFZLENBQUN1N0IsVUFBYixDQUF3QjdCLFFBQXhCLEVBQWtDdHhCLEtBQWxDLENBQVQ7QUFDSCxhQUZELENBRUUsZ0JBQU07QUFDSmt6QixvQkFBTSxHQUFHO0FBQUMsd0JBQVE1QixRQUFUO0FBQW1CLHdCQUFRLFNBQTNCO0FBQXNDLHlCQUFTdHhCLEtBQUssQ0FBQ3hiLFFBQU47QUFBL0MsZUFBVDtBQUNIOztBQUNELGdCQUFJMHVDLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ2pCejhCLG9CQUFNLENBQUN1RyxJQUFQLENBQVlrMkIsTUFBWjtBQUNILGFBRkQsTUFFTyxJQUFJbHpCLEtBQUssQ0FBQytJLFdBQU4sS0FBc0I5UixFQUFFLENBQUM4ZixPQUFILENBQVd0QyxNQUFyQyxFQUE2QztBQUNoRDhILHFCQUFPLENBQUN2ZixJQUFSLENBQWFnRCxLQUFLLENBQUM0VSxFQUFOLENBQVNnWCxRQUFULENBQWtCcUUsQ0FBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxhQUFPO0FBQUMsc0JBQWN4NUIsTUFBZjtBQUF1QixtQkFBVzhsQjtBQUFsQyxPQUFQO0FBQ0g7QUFqREw7QUFBQTs7QUFtREk7Ozs7OztBQW5ESiwrQkF5RHNCK1UsUUF6RHRCLEVBeURnQ3R4QixLQXpEaEMsRUF5RHVDb3pCLFVBekR2QyxFQXlEbUQ7QUFDM0MsVUFBSXB6QixLQUFLLEtBQUtoaEIsU0FBZCxFQUF5QjtBQUNyQixlQUFPO0FBQUMsa0JBQVFzeUMsUUFBVDtBQUNILGtCQUFRLFNBREw7QUFFSCxtQkFBUztBQUZOLFNBQVA7QUFJSDs7QUFDRCxjQUFRQSxRQUFSO0FBQ0ksYUFBSyxXQUFMO0FBQ0ksaUJBQU87QUFDSC93QyxnQkFBSSxFQUFFK3dDLFFBREg7QUFFSHh3QyxnQkFBSSxFQUFFLFdBRkg7QUFHSGtmLGlCQUFLLEVBQUU7QUFISixXQUFQO0FBRlI7O0FBUUEsY0FBUUEsS0FBSyxDQUFDK0ksV0FBZDtBQUNJLGFBQUs5UixFQUFFLENBQUM4ZixPQUFILENBQVc0VixJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVEyRSxRQUFUO0FBQ0gsb0JBQVEsVUFETDtBQUVILHFCQUNLdHhCLEtBQUssQ0FBQ3F6QixTQUFOLENBQWdCQyxXQUFoQixLQUFnQ3QwQyxTQUFoQyxHQUNHLGtCQUFnQmdoQixLQUFLLENBQUNxekIsU0FBTixDQUFnQkMsV0FBaEIsQ0FBNEJ0dUIsSUFBNUIsQ0FBaUMsSUFBakMsQ0FEbkIsR0FFRztBQUxMLFdBQVA7O0FBT0osYUFBSy9OLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3RDLE1BQWhCO0FBQXdCLGlCQUFPLElBQVA7O0FBQ3hCLGFBQUt4ZCxFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFoQjtBQUNJLGNBQUlxYSxVQUFVLElBQUlwekIsS0FBSyxDQUFDaXdCLENBQU4sQ0FBUTkvQixNQUFSLElBQWtCLEVBQXBDLEVBQXdDO0FBQ3BDLG1CQUFPO0FBQUMsc0JBQVFtaEMsUUFBVDtBQUNILHNCQUFRLFFBREw7QUFFSCx1QkFBU3R4QixLQUFLLENBQUNnWSxFQUFOLEdBQVdpWTtBQUZqQixhQUFQO0FBSUgsV0FMRCxNQUtPO0FBQ0gsbUJBQU87QUFBQyxzQkFBUXFCLFFBQVQ7QUFDSCxzQkFBUSxRQURMO0FBRUgsdUJBQVMsTUFBSXR4QixLQUFLLENBQUN1ekIsU0FBTixFQUFKLEdBQXNCO0FBRjVCLGFBQVA7QUFJSDs7QUFDTCxhQUFLdDhCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV29XLElBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUW1FLFFBQVQ7QUFDSCxvQkFBUSxNQURMO0FBRUgscUJBQVM7QUFGTixXQUFQOztBQUlKLGFBQUtyNkIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXeWMsSUFBaEI7QUFDSSxpQkFBTztBQUFDLG9CQUFRbEMsUUFBVDtBQUNILG9CQUFRLFNBREw7QUFFSCxxQkFBU3R4QixLQUFLLENBQUNnWSxFQUFOLEdBQVdpWTtBQUZqQixXQUFQOztBQUlKLGFBQUtoNUIsRUFBRSxDQUFDOGYsT0FBSCxDQUFXMGMsS0FBaEI7QUFDSSxpQkFBTztBQUFDLG9CQUFRbkMsUUFBVDtBQUNILG9CQUFRLFVBQVV0eEIsS0FBSyxDQUFDMHpCLE1BQWhCLEdBQXlCLFNBQXpCLEdBQW9DLE9BRHpDO0FBRUgscUJBQVMxekIsS0FBSyxDQUFDZ1ksRUFBTixHQUFXaVk7QUFGakIsV0FBUDs7QUFJSixhQUFLaDVCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzBFLElBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUTZWLFFBQVQ7QUFDSCxvQkFBUSxTQURMO0FBRUgscUJBQVN0eEIsS0FBSyxDQUFDZ1ksRUFBTixHQUFXaVk7QUFGakIsV0FBUDs7QUFJSixhQUFLaDVCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzRjLE1BQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUXJDLFFBQVQ7QUFDSCxvQkFBUSxPQURMO0FBRUgscUJBQVN0eEIsS0FBSyxDQUFDZ1ksRUFBTixHQUFXaVk7QUFGakIsV0FBUDs7QUFJSixhQUFLaDVCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3FZLEtBQWhCO0FBQ0ksaUJBQU87QUFBQyxvQkFBUWtDLFFBQVQ7QUFDSCxvQkFBUSxPQURMO0FBRUgscUJBQVN0eEIsS0FBSyxDQUFDZ1ksRUFBTixHQUFXaVk7QUFGakIsV0FBUDs7QUFJSixhQUFLaDVCLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzJYLElBQWhCO0FBQ0ksY0FBSTF1QixLQUFLLENBQUNpd0IsQ0FBTixDQUFROS9CLE1BQVIsSUFBa0IsRUFBdEIsRUFBMEI7QUFDdEIsbUJBQU87QUFBQyxzQkFBUW1oQyxRQUFUO0FBQ0gsc0JBQVEsTUFETDtBQUVILHVCQUFTdHhCLEtBQUssQ0FBQ2dZLEVBQU4sR0FBV2lZLENBRmpCO0FBR0gsNkJBQWVqd0I7QUFIWixhQUFQO0FBS0gsV0FORCxNQU1PO0FBQ0gsbUJBQU87QUFBQyxzQkFBUXN4QixRQUFUO0FBQ0gsc0JBQVEsTUFETDtBQUVILHVCQUFTLFVBQVF0eEIsS0FBSyxDQUFDaXdCLENBQU4sQ0FBUTkvQixNQUFoQixHQUF1QixnQkFGN0I7QUFHSCw2QkFBZTZQO0FBSFosYUFBUDtBQUtIOztBQUNMLGFBQUsvSSxFQUFFLENBQUM4ZixPQUFILENBQVd3RSxJQUFoQjtBQUNJLGlCQUFPO0FBQUMsb0JBQVErVixRQUFUO0FBQ0gsb0JBQVEsWUFETDtBQUVILHFCQUFTdHhCLEtBQUssQ0FBQ2dZLEVBQU4sR0FBV2lZO0FBRmpCLFdBQVA7O0FBSUosYUFBSzJELE1BQUw7QUFDSSxpQkFBTztBQUFDLG9CQUFRdEMsUUFBVDtBQUNILG9CQUFRdHhCLEtBQUssR0FBRyxDQUFSLEtBQWMsQ0FBZCxHQUFrQixTQUFsQixHQUE4QixPQURuQztBQUVILHFCQUFTQTtBQUZOLFdBQVA7O0FBSUosYUFBSzJ5QixNQUFMO0FBQ0ksaUJBQU87QUFBQyxvQkFBUXJCLFFBQVQ7QUFDSCxvQkFBUSxRQURMO0FBRUgscUJBQVN0eEI7QUFGTixXQUFQOztBQUlKLGFBQUtxYixPQUFMO0FBQ0ksaUJBQU87QUFBQyxvQkFBUWlXLFFBQVQ7QUFDSCxvQkFBUSxTQURMO0FBRUgscUJBQVV0eEIsS0FBSyxHQUFHLE1BQUgsR0FBVztBQUZ2QixXQUFQOztBQUlKO0FBQ0ksaUJBQU87QUFBQyxvQkFBUXN4QixRQUFUO0FBQ0gsb0JBQVF0eEIsS0FBSyxDQUFDNmEsT0FBTixLQUFrQjc3QixTQUFsQixHQUE4QmdoQixLQUE5QixHQUFzQ0EsS0FBSyxDQUFDNmEsT0FEakQ7QUFFSCxxQkFBUzdhLEtBQUssQ0FBQ2dZLEVBQU4sS0FBYWg1QixTQUFiLEdBQXlCZ2hCLEtBQXpCLEdBQWlDQSxLQUFLLENBQUNnWSxFQUFOLEdBQVdpWTtBQUZsRCxXQUFQO0FBdkZSO0FBNEZIO0FBcEtMOztBQUFBO0FBQUEsSSxDQXlLQSx1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZWQTs7Ozs7O0FBTUEsU0FBUzRELGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxRQUEvQixFQUF5QztBQUNyQyxTQUFPQSxRQUFRLENBQUN6aEMsT0FBVCxDQUFpQndoQyxNQUFqQixJQUEyQixDQUFDLENBQW5DO0FBQ0g7QUFFRDs7Ozs7Ozs7OztBQVFBLFNBQVNFLFdBQVQsQ0FBcUJsUixLQUFyQixFQUE0QjtBQUN4QixNQUFJbVIsQ0FBQyxHQUFHblIsS0FBSyxDQUFDb1IsTUFBTixFQUFSOztBQUNBLE9BQUksSUFBSXYwQixDQUFDLEdBQUMsQ0FBVixFQUFhQSxDQUFDLEdBQUNzMEIsQ0FBQyxDQUFDOWpDLE1BQWpCLEVBQXlCLEVBQUV3UCxDQUEzQixFQUE4QjtBQUMxQixTQUFJLElBQUl3MEIsQ0FBQyxHQUFDeDBCLENBQUMsR0FBQyxDQUFaLEVBQWV3MEIsQ0FBQyxHQUFDRixDQUFDLENBQUM5akMsTUFBbkIsRUFBMkIsRUFBRWdrQyxDQUE3QixFQUFnQztBQUM1QixVQUFHRixDQUFDLENBQUN0MEIsQ0FBRCxDQUFELEtBQVNzMEIsQ0FBQyxDQUFDRSxDQUFELENBQWIsRUFBa0I7QUFBQ0YsU0FBQyxDQUFDeEssTUFBRixDQUFTMEssQ0FBQyxFQUFWLEVBQWMsQ0FBZDtBQUFrQjtBQUN4QztBQUNKOztBQUVELFNBQU9GLENBQVA7QUFDSDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTRyxXQUFULENBQXFCdFIsS0FBckIsRUFBNEJ1UixRQUE1QixFQUFzQ0MsV0FBdEMsRUFBbUQ7QUFDL0MsTUFBSUMsU0FBUyxHQUFHelIsS0FBSyxDQUFDcGIsTUFBTixDQUFhLFVBQVM4bUIsSUFBVCxFQUFlO0FBQ3hDLFdBQU84RixXQUFXLENBQUNoaUMsT0FBWixDQUFvQms4QixJQUFwQixNQUE4QixDQUFDLENBQXRDO0FBQ0gsR0FGZSxDQUFoQjtBQUdBLFNBQU93RixXQUFXLENBQUNPLFNBQVMsQ0FBQ0wsTUFBVixDQUFpQkcsUUFBakIsQ0FBRCxDQUFsQjtBQUNIO0FBRUQ7Ozs7Ozs7QUFLQSxTQUFTRyxTQUFULENBQW1CN1gsSUFBbkIsRUFBeUI7QUFDckI7QUFDQSxNQUFJOFgsS0FBSyxHQUFHOVgsSUFBSSxDQUFDK1gsUUFBTCxJQUFpQixDQUFqQixHQUFxQno1QixRQUFRLENBQUMwNUIsY0FBVCxDQUF3QmhZLElBQUksQ0FBQ2lZLFNBQTdCLENBQXJCLEdBQStEalksSUFBSSxDQUFDNlgsU0FBTCxDQUFlLEtBQWYsQ0FBM0UsQ0FGcUIsQ0FJckI7O0FBQ0EsTUFBSUssS0FBSyxHQUFHbFksSUFBSSxDQUFDbVksVUFBakI7O0FBQ0EsU0FBTUQsS0FBTixFQUFhO0FBQ1RKLFNBQUssQ0FBQ3Z1QixXQUFOLENBQWtCc3VCLFNBQVMsQ0FBQ0ssS0FBRCxDQUEzQjtBQUNBQSxTQUFLLEdBQUdBLEtBQUssQ0FBQ0UsV0FBZDtBQUNIOztBQUVELFNBQU9OLEtBQVA7QUFDSDtBQUVEOzs7Ozs7OztBQU1PLFNBQVNPLE1BQVQsQ0FBZ0JqYyxHQUFoQixFQUFxQjtBQUN4QixTQUFPQSxHQUFHLENBQUMxVCxPQUFKLENBQVksVUFBWixFQUF3QixNQUF4QixDQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBS08sU0FBU25FLElBQVQsQ0FBYzZYLEdBQWQsRUFBbUI7QUFDdEIsU0FBT0EsR0FBRyxDQUFDMVQsT0FBSixDQUFZLEtBQVosRUFBbUIsR0FBbkIsRUFBd0JsWSxXQUF4QixFQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBS08sU0FBU3dJLFVBQVQsQ0FBb0JzL0IsQ0FBcEIsRUFBdUI7QUFDMUIsTUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDdkIsV0FBTyxFQUFQO0FBQ0g7O0FBQ0QsU0FBT0EsQ0FBQyxDQUFDMTFCLE1BQUYsQ0FBUyxDQUFULEVBQVl1SSxXQUFaLEtBQTRCbXRCLENBQUMsQ0FBQ3ZqQyxLQUFGLENBQVEsQ0FBUixDQUFuQztBQUNIO0FBRUQ7Ozs7Ozs7O0FBT0EsU0FBU3dqQyxhQUFULENBQXVCdmxDLEdBQXZCLEVBQTJCSCxHQUEzQixFQUFnQztBQUM1QixTQUFPRCxJQUFJLENBQUM0bEMsS0FBTCxDQUFXNWxDLElBQUksQ0FBQzZsQyxNQUFMLE1BQWU1bEMsR0FBRyxHQUFDRyxHQUFKLEdBQVEsQ0FBdkIsSUFBMEJBLEdBQXJDLENBQVA7QUFDSDtBQUVEOzs7Ozs7Ozs7QUFPTyxTQUFTZ00sVUFBVCxDQUFvQm9kLEdBQXBCLEVBQXlCO0FBQzVCLFNBQU9BLEdBQUcsQ0FBQzFULE9BQUosQ0FBWSxJQUFaLEVBQWtCLE9BQWxCLEVBQ0ZBLE9BREUsQ0FDTSxJQUROLEVBQ1ksTUFEWixFQUVGQSxPQUZFLENBRU0sSUFGTixFQUVZLE1BRlosRUFHRkEsT0FIRSxDQUdNLElBSE4sRUFHWSxRQUhaLEVBSUZBLE9BSkUsQ0FJTSxJQUpOLEVBSVksUUFKWixDQUFQO0FBS0g7QUFFRDs7OztBQUdBLElBQUksT0FBTzRHLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDaENBLFNBQU8sQ0FBQ29wQixZQUFSLENBQXFCNzlCLFNBQXJCLENBQStCODlCLE9BQS9CLEdBQXlDLFlBQVc7QUFDaEQsUUFBSUMsT0FBTyxHQUFHLEtBQUtDLFVBQUwsRUFBZDtBQUNBLFFBQUkvbkMsS0FBSyxHQUFHOG5DLE9BQU8sQ0FBQ0UsU0FBUixHQUFvQixDQUFoQztBQUFBLFFBQ0k1M0IsTUFBTSxHQUFHMDNCLE9BQU8sQ0FBQ0csVUFEckI7QUFFQSxRQUFJQyxNQUFNLEdBQUcsS0FBS0MsWUFBTCxDQUFrQixLQUFsQixDQUFiO0FBQ0EsUUFBSTFGLENBQUMsR0FBRyxDQUFSO0FBQUEsUUFBV2pZLENBQUMsR0FBRyxDQUFmO0FBQUEsUUFDSTRkLGdCQUFnQixHQUFHaDRCLE1BQU0sR0FBQzgzQixNQUFNLENBQUN4bEMsTUFEckM7O0FBRUEsU0FBSyxJQUFJd1AsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2cyQixNQUFNLENBQUN4bEMsTUFBM0IsRUFBbUN3UCxDQUFDLEVBQXBDLEVBQXVDO0FBQ25DO0FBQ0EsVUFBSThlLEtBQUssR0FBR2tYLE1BQU0sQ0FBQ2gyQixDQUFELENBQWxCO0FBQ0EsVUFBSTJjLFVBQVUsR0FBR21DLEtBQUssQ0FBQ3FYLHNCQUFOLEVBQWpCOztBQUNBLFVBQUluMkIsQ0FBQyxJQUFJLENBQVQsRUFBWTtBQUNSc1ksU0FBQyxHQUFHLENBQUo7QUFDSCxPQUZELE1BRU87QUFDSEEsU0FBQyxHQUFHLENBQUNxRSxVQUFVLENBQUNyRSxDQUFaLEdBQWNpZCxhQUFhLENBQUMsRUFBRCxFQUFLem5DLEtBQUwsQ0FBL0I7QUFDSDs7QUFDRGd4QixXQUFLLENBQUNzWCxNQUFOLENBQWE5ZCxDQUFiLEVBQ2EsQ0FBQ3FFLFVBQVUsQ0FBQzRULENBQVosR0FBY0EsQ0FEM0I7QUFFQUEsT0FBQyxHQUFHQSxDQUFDLEdBQUdnRixhQUFhLENBQUMsQ0FBRCxFQUFJVyxnQkFBSixDQUFyQjtBQUNIO0FBQ0osR0FwQkQ7QUFxQkg7QUFFRDs7Ozs7O0FBSUEsU0FBU0csWUFBVCxDQUFzQm5xQixNQUF0QixFQUE4QjlWLE1BQTlCLEVBQXNDa2dDLFNBQXRDLEVBQWlEO0FBQzdDLE9BQUssSUFBSXQyQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa00sTUFBTSxDQUFDMWIsTUFBM0IsRUFBbUN3UCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3BDLFFBQUlrTCxPQUFPLEdBQUdnQixNQUFNLENBQUNsTSxDQUFELENBQXBCOztBQUNBLFFBQUlzMkIsU0FBUyxDQUFDcHJCLE9BQUQsQ0FBYixFQUF3QjtBQUNwQmdCLFlBQU0sQ0FBQzRkLE1BQVAsQ0FBYzlwQixDQUFkLEVBQWlCLENBQWpCO0FBQ0E1SixZQUFNLENBQUNpSCxJQUFQLENBQVk2TixPQUFaO0FBQ0FsTCxPQUFDO0FBQ0o7QUFDSjtBQUNKOztBQUdNLFNBQVNpa0IsaUJBQVQsR0FBNkI7QUFDaEMsT0FBSyxJQUFJamtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2QixTQUFTLENBQUNyUixNQUE5QixFQUFzQ3dQLENBQUMsRUFBdkMsRUFBMkM7QUFDdkMsUUFBSTZCLFNBQVMsQ0FBQzdCLENBQUQsQ0FBVCxJQUFnQixJQUFwQixFQUEwQjtBQUN0QixhQUFPNkIsU0FBUyxDQUFDN0IsQ0FBRCxDQUFoQjtBQUNIO0FBQ0o7O0FBQ0QsU0FBTzNnQixTQUFQO0FBQ0g7QUFFRDs7Ozs7Ozs7Ozs7QUFVQSxTQUFTazNDLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQXlCO0FBQ3JCLFNBQVFBLEdBQUcsWUFBWWwvQixFQUFFLENBQUM4ZixPQUFILENBQVd3RSxJQUEzQixJQUNGNGEsR0FBRyxZQUFZbC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzJYLElBRHhCLElBRUZ5SCxHQUFHLFlBQVlsL0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXcVksS0FGeEIsSUFHRitHLEdBQUcsWUFBWWwvQixFQUFFLENBQUM4ZixPQUFILENBQVd5YyxJQUh4QixJQUlGMkMsR0FBRyxZQUFZbC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzBFLElBSnhCLElBS0YwYSxHQUFHLFlBQVlsL0IsRUFBRSxDQUFDOGYsT0FBSCxDQUFXNGMsTUFMeEIsSUFNRndDLEdBQUcsWUFBWWwvQixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQU54QixJQU9Gb2QsR0FBRyxZQUFZbC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3FmLEdBUC9CLENBRHFCLENBU3JCO0FBQ0E7QUFDSDs7QUFFRCxTQUFTQyxTQUFULENBQW1CRixHQUFuQixFQUF1QjtBQUNuQixTQUFPQSxHQUFHLFlBQVl6ekIsTUFBZixJQUF5QixjQUFjeXpCLEdBQTlDO0FBQ0g7O0FBRUQsSUFBTUcsdUJBQXVCLEdBQUcsdUJBQWhDO0FBRUE7Ozs7Ozs7OztBQVFPLFNBQVNoMEMsV0FBVCxDQUFxQmdWLElBQXJCLEVBQTJCalAsTUFBM0IsRUFBbUM7QUFDdEMsTUFBSUEsTUFBTSxLQUFLLEVBQVgsSUFBaUJBLE1BQU0sSUFBSSxJQUEvQixFQUFxQztBQUNqQyxXQUFPaVAsSUFBUDtBQUNIOztBQUNELE1BQU1pL0IsS0FBSyxHQUFHai9CLElBQUksQ0FBQ21JLEtBQUwsQ0FBVzYyQix1QkFBWCxDQUFkOztBQUNBLE9BQUssSUFBSTMyQixDQUFDLEdBQUMsQ0FBWCxFQUFjQSxDQUFDLEdBQUc0MkIsS0FBSyxDQUFDcG1DLE1BQXhCLEVBQWdDd1AsQ0FBQyxJQUFFLENBQW5DLEVBQXNDO0FBQ2xDOzs7O0FBSUEsUUFBSTQyQixLQUFLLENBQUM1MkIsQ0FBRCxDQUFMLEtBQWF0WCxNQUFqQixFQUF5QjtBQUNyQixVQUFJb2EsSUFBSSxHQUFHOHpCLEtBQUssQ0FBQzUyQixDQUFDLEdBQUMsQ0FBSCxDQUFoQjs7QUFDQSxVQUFJOEMsSUFBSSxJQUFJQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEtBQVksSUFBeEIsRUFBOEI7QUFDMUJBLFlBQUksR0FBR0EsSUFBSSxDQUFDL1EsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUNELFVBQUlpTyxDQUFDLEtBQUs0MkIsS0FBSyxDQUFDcG1DLE1BQU4sR0FBZSxDQUFyQixJQUEwQnNTLElBQTFCLElBQWtDQSxJQUFJLENBQUMvUSxLQUFMLENBQVcsQ0FBQyxDQUFaLE1BQW1CLElBQXpELEVBQStEO0FBQzNEK1EsWUFBSSxHQUFHQSxJQUFJLENBQUMvUSxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUFQO0FBQ0g7O0FBQ0QsYUFBTytRLElBQVA7QUFDSDtBQUNKOztBQUNELFNBQU8sSUFBUDtBQUNIO0FBRUQ7Ozs7Ozs7O0FBT0EsU0FBUyt6QixjQUFULENBQXdCTCxHQUF4QixFQUE0QjtBQUN4QixNQUFJTSxDQUFKO0FBQ0EsTUFBSUMsR0FBSjtBQUNBLE1BQUkvMkIsQ0FBSjtBQUNBLE1BQUlnM0IsR0FBSixDQUp3QixDQUt4Qjs7QUFDQSxNQUFJVCxXQUFXLENBQUNDLEdBQUQsQ0FBZixFQUFxQjtBQUNqQjtBQUNBLFdBQU9BLEdBQVA7QUFDSCxHQUhELE1BR08sSUFBSXp6QixNQUFNLENBQUNsTCxTQUFQLENBQWlCaFQsUUFBakIsQ0FBMEJvc0MsSUFBMUIsQ0FBK0J1RixHQUEvQixNQUF3QyxnQkFBNUMsRUFBOEQ7QUFDakU7QUFDQVEsT0FBRyxHQUFHLEVBQU47O0FBQ0EsU0FBS2gzQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd3MkIsR0FBRyxDQUFDaG1DLE1BQXBCLEVBQTRCLEVBQUV3UCxDQUE5QixFQUFpQztBQUM3QjtBQUNBLFVBQUlpM0IsTUFBTSxHQUFHVCxHQUFHLENBQUN4MkIsQ0FBRCxDQUFoQjs7QUFDQSxVQUFHLENBQUN1MkIsV0FBVyxDQUFDVSxNQUFELENBQWYsRUFBd0I7QUFDcEJELFdBQUcsQ0FBQzM1QixJQUFKLENBQVN3NUIsY0FBYyxDQUFDSSxNQUFELENBQXZCO0FBQ0gsT0FGRCxNQUVLO0FBQ0RELFdBQUcsQ0FBQzM1QixJQUFKLENBQVM0NUIsTUFBVDtBQUNIO0FBQ0o7O0FBQ0QsV0FBTyxJQUFJMy9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzJYLElBQWYsQ0FBb0JpSSxHQUFwQixDQUFQO0FBQ0gsR0FiTSxNQWFBLElBQUlSLEdBQUcsS0FBSyxJQUFaLEVBQWtCO0FBQUM7QUFDdEIsV0FBT2wvQixFQUFFLENBQUM4ZixPQUFILENBQVdvVyxJQUFYLENBQWdCQyxLQUF2QjtBQUNILEdBRk0sTUFFQSxJQUFJLFFBQU8rSSxHQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDaEMsUUFBRyxDQUFDRCxXQUFXLENBQUNDLEdBQUQsQ0FBZixFQUFxQjtBQUNqQjtBQUNBTyxTQUFHLEdBQUcsRUFBTixDQUZpQixDQUVSOztBQUNULFdBQUtELENBQUwsSUFBVU4sR0FBVixFQUFlO0FBQ1g7QUFDQU8sV0FBRyxDQUFDMTVCLElBQUosQ0FBU3c1QixjQUFjLENBQUNDLENBQUQsQ0FBdkIsRUFGVyxDQUdYOztBQUNBQyxXQUFHLENBQUMxNUIsSUFBSixDQUFTdzVCLGNBQWMsQ0FBQ0wsR0FBRyxDQUFDTSxDQUFELENBQUosQ0FBdkI7QUFDSCxPQVJnQixDQVNqQjs7O0FBQ0EsYUFBTyxJQUFJeC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3dFLElBQWYsQ0FBb0JtYixHQUFwQixDQUFQO0FBQ0gsS0FYRCxNQVdLO0FBQ0QsYUFBT1AsR0FBUDtBQUNIO0FBQ0osR0FmTSxNQWVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2hDLFdBQU8sSUFBSWwvQixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1Cb2QsR0FBbkIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNoQyxXQUFPbC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBVzhmLEtBQVgsQ0FBaUJWLEdBQWpCLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDakMsV0FBTyxJQUFJbC9CLEVBQUUsQ0FBQzhmLE9BQUgsQ0FBV3ljLElBQWYsQ0FBb0IyQyxHQUFwQixDQUFQO0FBQ0gsR0FGTSxNQUVBLElBQUcsT0FBT0EsR0FBUCxLQUFlLFVBQWxCLEVBQThCO0FBQ2pDLFdBQU8sSUFBSWwvQixFQUFFLENBQUM4ZixPQUFILENBQVdnQyxHQUFmLENBQW1Cb2QsR0FBRyxDQUFDNTFDLElBQXZCLENBQVA7QUFDSDtBQUNKOztBQUdNLFNBQVNtWSxjQUFULEdBQTBCO0FBQzdCLE1BQU1vK0IsS0FBSyxHQUFHLElBQUk3USxJQUFKLEVBQWQ7QUFDQSxNQUFJOFEsQ0FBQyxHQUFHeG5DLElBQUksQ0FBQzRsQyxLQUFMLENBQVcyQixLQUFLLENBQUNFLFFBQU4sS0FBaUIsRUFBNUIsQ0FBUjtBQUNBLE1BQUlDLENBQUMsR0FBR0gsS0FBSyxDQUFDSSxVQUFOLEVBQVIsQ0FINkIsQ0FJN0I7O0FBQ0EsTUFBSUQsQ0FBQyxHQUFHLEVBQVIsRUFBWTtBQUFDQSxLQUFDLEdBQUcsTUFBTUEsQ0FBVjtBQUFhLEdBTEcsQ0FNN0I7OztBQUNBLE1BQUlFLENBQUMsR0FBRyxJQUFSOztBQUNBLE1BQUlMLEtBQUssQ0FBQ0UsUUFBTixNQUFrQixFQUF0QixFQUEwQjtBQUN0QkcsS0FBQyxHQUFHLElBQUo7QUFDSDs7QUFDRCxtQkFBVUosQ0FBVixjQUFlRSxDQUFmLFNBQW1CRSxDQUFuQjtBQUNILEM7Ozs7Ozs7Ozs7O0FDcFRELG9EOzs7Ozs7Ozs7OztBQ0FBLHNEIiwiZmlsZSI6ImJsb2NrcHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqUXVlcnlcIiksIHJlcXVpcmUoXCJrb1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImJsb2NrcHlcIiwgW1wialF1ZXJ5XCIsIFwia29cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYmxvY2tweVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImpRdWVyeVwiKSwgcmVxdWlyZShcImtvXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJibG9ja3B5XCJdID0gZmFjdG9yeShyb290W1wialF1ZXJ5XCJdLCByb290W1wia29cIl0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanF1ZXJ5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfa25vY2tvdXRfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2Jsb2NrcHkuanNcIik7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhcnRpbmcgcG9pbnQgb2YgdGhlIEJsb2NrUHkgYXBwbGljYXRpb24sIGNvbnRhaW5pbmcgdGhlIG1haW5cbiAqIEJsb2NrUHkgY2xhc3MuXG4gKi9cbmltcG9ydCBcIi4vY3NzL2Jsb2NrcHkuY3NzXCI7XG5pbXBvcnQgXCIuL2Nzcy9ib290c3RyYXBfcmV0aGVtZS5jc3NcIjtcbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcbmltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgaW1hZ2VNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9pbWFnZVwiO1xuaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyB3ZWFrcmVmTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvd2Vha3JlZlwiO1xuLy9pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIG1hdHBsb3RsaWJNb2R1bGV9IGZyb20gXCJza3VscHRfbW9kdWxlcy9tYXRwbG90bGliMlwiO1xuaW1wb3J0IHtMb2NhbFN0b3JhZ2VXcmFwcGVyfSBmcm9tIFwic3RvcmFnZS5qc1wiO1xuaW1wb3J0IHtFZGl0b3JzRW51bX0gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7RGlzcGxheU1vZGVzfSBmcm9tIFwiZWRpdG9yL3B5dGhvbi5qc1wiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcInNlcnZlci5qc1wiO1xuaW1wb3J0IHttYWtlSW50ZXJmYWNlLCBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zLCBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9IGZyb20gXCJpbnRlcmZhY2UuanNcIjtcbmltcG9ydCB7RWRpdG9yc30gZnJvbSBcImVkaXRvcnMuanNcIjtcbmltcG9ydCB7XG4gICAgQmxvY2tQeUZpbGVTeXN0ZW0sXG4gICAgbG9hZENvbmNhdGVuYXRlZEZpbGUsXG4gICAgbWFrZU1vZGVsRmlsZSxcbiAgICBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZSxcbiAgICBVTkRFTEVUQUJMRV9GSUxFUyxcbiAgICBVTlJFTkFNQUJMRV9GSUxFU1xufSBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0IHt1cGxvYWRGaWxlLCBkb3dubG9hZEZpbGV9IGZyb20gXCIuL2VkaXRvci9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7QmxvY2tQeUVuZ2luZX0gZnJvbSBcImVuZ2luZS5qc1wiO1xuaW1wb3J0IHtBU1RfREVTQ1JJUFRJT05TLCBCbG9ja1B5VHJhY2V9IGZyb20gXCIuL3RyYWNlXCI7XG5pbXBvcnQge0Jsb2NrUHlDb25zb2xlfSBmcm9tIFwiLi9jb25zb2xlXCI7XG5pbXBvcnQge0Jsb2NrUHlGZWVkYmFja30gZnJvbSBcImZlZWRiYWNrLmpzXCI7XG5pbXBvcnQge0Jsb2NrUHlTZXJ2ZXJ9IGZyb20gXCIuL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5RGlhbG9nfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7QXNzaWdtZW50VHlwZSwgbG9hZEFzc2lnbm1lbnRTZXR0aW5ncywgbWFrZUFzc2lnbm1lbnRTZXR0aW5nc01vZGVsfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuaW1wb3J0IHtCbG9ja1B5Q29yZ2lzLCBfSU1QT1JURURfQ09NUExFVEVfREFUQVNFVFMsIF9JTVBPUlRFRF9EQVRBU0VUU30gZnJvbSBcIi4vY29yZ2lzXCI7XG5pbXBvcnQge0Jsb2NrUHlIaXN0b3J5fSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge2NhcGl0YWxpemUsIGV4dHJhY3RQYXJ0LCBnZXRDdXJyZW50VGltZX0gZnJvbSBcIi4vdXRpbGl0aWVzXCI7XG5pbXBvcnQge1NhbXBsZVN1Ym1pc3Npb24sIFN1Ym1pc3Npb25TdGF0dXNlc30gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuXG5leHBvcnQge19JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfTtcblxuY29uc3QgRURJVE9SX1ZFUlNJT04gPSBcIjUuMS4yXCI7XG5cbi8qKlxuICogTWFqb3IgZW50cnkgcG9pbnQgZm9yIGNyZWF0aW5nIGEgQmxvY2tQeSBpbnN0YW5jZS5cbiAqIFR3byBtb3N0IGltcG9ydGFudCBmaWVsZHMgYXJlIGBtb2RlbGAgYW5kIGBjb21wb25lbnRzYC5cbiAqIFRoZSBgbW9kZWxgIGhvbGRzIGFsbCB0aGUgZGF0YSBhYm91dCB0aGUgaW50ZXJmYWNlLlxuICogVGhlIGBjb21wb25lbnRzYCBhcmUgcmVmZXJlbmNlcyB0byB0aGUgZGlzcGFyYXRlIHBhcnRzIG9mIEJsb2NrUHkuXG4gKlxuICogTW9zdCBvZiB0aGlzIGNsYXNzZXMgZGVmaW5pdGlvbiBpcyBqdXN0IGluaXRpYWxpemluZyB0aGUgbW9kZWwgYW5kIHVwZGF0aW5nXG4gKiBpdCBvbiBhbiBhc3NpZ25tZW50IHN3aXRjaC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIC0gVXNlciBsZXZlbCBzZXR0aW5ncyAoZS5nLiwgd2hhdCBlZGl0b3IgbW9kZSwgd2hldGhlciB0byBtdXRlIHNlbWFudGljIGVycm9ycywgZXRjLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudCAtIEFzc2lnbm1lbnQgbGV2ZWwgc2V0dGluZ3MgKGRhdGEgYWJvdXQgdGhlIGxvYWRlZCBhc3NpZ25tZW50LCB1c2VyLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIC0gSW5jbHVkZXMgdGhlIHNvdXJjZSBjb2RlIG9mIGFueSBwcm9ncmFtcyB0byBiZSBsb2FkZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAoYXNzaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFzc2lnbm1lbnQoY29uZmlndXJhdGlvbiwgYXNzaWdubWVudCwgc3VibWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWFpbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBCbG9ja1B5IG9iamVjdCBieSBpbml0aWFsaXppbmcgaXRzIGludGVyZmFjZSxcbiAgICAgKiBtb2RlbCwgYW5kIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0TWFpbigpIHtcbiAgICAgICAgdGhpcy5pbml0VXRpbGl0aWVzKCk7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsTWV0aG9kcygpO1xuICAgICAgICB0aGlzLnR1cm5PbkhhY2tzKCk7XG4gICAgICAgIHRoaXMuaW5pdEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmFwcGx5TW9kZWwoKTtcbiAgICAgICAgdGhpcy5pbml0Q29tcG9uZW50cygpO1xuICAgICAgICB0aGlzLm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBkZWZhdWx0IHZhbHVlIG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdG8gbG9vayB1cCBhIHZhbHVlIGZvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0VmFsdWUgLSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBhbnl3aGVyZSwgdXNlIHRoaXMgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5nKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxTZXR0aW5nc18uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU2V0dGluZ3NfLmdldChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RlbCB0byBpdHMgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBDYXRlZ29yaWVzOlxuICAgICAqICAgKiB1c2VyOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIgKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGFzc2lnbm1lbnQ6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgYXNzaWdubWVudCAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogc3VibWlzc2lvbjogdmFsdWVzIGZvciB0aGUgY3VycmVudCBzdWJtaXNzaW9uIChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBkaXNwbGF5OiBmbGFncyByZWxhdGVkIHRvIGN1cnJlbnQgdmlzaWJpbGl0eSAoc3RvcmVkIHRvIGxvY2FsU2V0dGluZ3MpXG4gICAgICogICAqIHN0YXR1czogbWVzc2FnZXMgcmVsYXRlZCB0byBjdXJyZW50IHN0YXR1cyAobm90IHN0b3JlZClcbiAgICAgKiAgICogZXhlY3V0aW9uOiB2YWx1ZXMgcmVsYXRlZCB0byBsYXN0IHJ1biAobm90IHN0b3JlZClcbiAgICAgKiAgICogY29uZmlndXJhdGlvbjogY29uc3RhbnQgdmFsdWVzIHJlbGF0ZWQgdG8gc2V0dXAgKG5vdCBzdG9yZWQpXG4gICAgICovXG4gICAgaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgLy8gQ29ubmVjdCB0byBsb2NhbCBzdG9yYWdlXG4gICAgICAgIHRoaXMubG9jYWxTZXR0aW5nc18gPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcImxvY2FsU2V0dGluZ3NcIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhjb25maWd1cmF0aW9uLCBjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdLCBjb25maWd1cmF0aW9uW1wicGFydElkXCJdLCBleHRyYWN0UGFydChjb25maWd1cmF0aW9uW1wic3VibWlzc2lvbi5jb2RlXCJdIHx8IFwiXCIsIGNvbmZpZ3VyYXRpb25bXCJwYXJ0SWRcIl0pKTtcblxuICAgICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmlkXCJdKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLm5hbWVcIl0pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgeW91IGFyZSBhbiBPd25lciAoY2FuIG1vZGlmeSB0aGUgYXNzaWdubWVudCksIEdyYWRlciAoY2FuIHZpZXdcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXNzaWdubWVudHMnIGluZm9ybWF0aW9uKSBvciBTdHVkZW50IChjYW4gbm90IHNlZSBhbnkgaW5zdHJ1Y3RvciBzdHVmZikuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcm9sZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJ1c2VyLnJvbGVcIiwgXCJvd25lclwiKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBjb3Vyc2UgZm9yIHRoaXMgdXNlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmNvdXJzZV9pZFwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBhc3NpZ25tZW50IGdyb3VwIHRoYXQgdGhpcyB1c2VyIGlzIGluc2lkZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuZ3JvdXBfaWRcIl0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWdubWVudDoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoXCJTY3JhdGNoIENhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUoXCJXZWxjb21lIHRvIEJsb2NrUHkuIFRyeSBlZGl0aW5nIGFuZCBydW5uaW5nIHRoZSBjb2RlIGJlbG93LlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaHVtYW4tZnJpZW5kbHkgVVJMIHRvIHVzZSBhcyBhIHNob3J0Y3V0IGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybmluZyBtZXNzYWdlIGlmIG1hemVcbiAgICAgICAgICAgICAgICB0eXBlOiBrby5vYnNlcnZhYmxlKEFzc2lnbWVudFR5cGUuQkxPQ0tQWSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQ29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zdGFydGluZ19jb2RlXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uUnVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX3J1blwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9jaGFuZ2VcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgb25FdmFsOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2V2YWxcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShsb2FkQ29uY2F0ZW5hdGVkRmlsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzXCJdKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgZXh0cmFTdGFydGluZ0ZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGZvcmtlZElkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGZvcmtlZFZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgcmV2aWV3ZWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQucmV2aWV3ZWRcIl0pLFxuICAgICAgICAgICAgICAgIHB1YmxpYzoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5wdWJsaWNcIl0pLFxuICAgICAgICAgICAgICAgIGhpZGRlbjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5oaWRkZW5cIl0pLFxuICAgICAgICAgICAgICAgIGlwUmFuZ2VzOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmlwX3Jhbmdlc1wiXSksXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBrby5vYnNlcnZhYmxlKGV4dHJhY3RQYXJ0KGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0gfHwgXCJcIiwgY29uZmlndXJhdGlvbltcInBhcnRJZFwiXSkgfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgZXh0cmFGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgc2NvcmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgY29ycmVjdDoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudElkIGluZmVycmVkIGZyb20gYXNzaWdubWVudC5pZFxuICAgICAgICAgICAgICAgIC8vIGNvdXJzZUlkIGluZmVycmVkIGZyb20gdXNlci5jb3Vyc2VJZFxuICAgICAgICAgICAgICAgIC8vIHVzZXJJZCBpbmZlcnJlZCBmcm9tIHVzZXIuaWRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50VmVyc2lvbiBpbmZlcnJlZCBmcm9tIGFzc2lnbm1lbnQudmVyc2lvblxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShcIlN0YXJ0ZWRcIiksXG4gICAgICAgICAgICAgICAgZ3JhZGluZ1N0YXR1czoga28ub2JzZXJ2YWJsZShcIk5vdFJlYWR5XCIpLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IGtvLm9ic2VydmFibGUobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudGx5IHZpc2libGUgRmlsZSwgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgcHJlc2VudGVkIHdpdGggdGhlIGluc3RydWN0b3Igc2V0dGluZ3MgYW5kIGZpbGVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoga28ub2JzZXJ2YWJsZShcIlwiK3RoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkuaW5zdHJ1Y3RvclwiLCBcImZhbHNlXCIpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHByZXZlbnQgdGhlIHByaW50ZXIgZnJvbSBzaG93aW5nIHRoaW5nc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG11dGVQcmludGVyOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAoUHl0aG9uIFZpZXdzKSBUaGUgY3VycmVudCBlZGl0b3IgbW9kZS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7RGlzcGxheU1vZGVzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHB5dGhvbk1vZGU6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5weXRob24ubW9kZVwiLCBEaXNwbGF5TW9kZXMuVEVYVCkpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEhpc3RvcnkgbW9kZSBpcyBlbmdhZ2VkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGhpc3RvcnlNb2RlOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSBhdXRvLXNhdmluZyBjaGFuZ2VzIGluIFB5dGhvbiBlZGl0b3JcbiAgICAgICAgICAgICAgICAgKiBJZiBhbiBpbnRlZ2VyLCBzcGVjaWZpZXMgdGhlIGRlbGF5IHRoYXQgc2hvdWxkIGJlIHVzZWQgKG1pY3Jvc2Vjb25kcykuXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBuZXZlciBvbiBpbiBub24tUHl0aG9uIGVkaXRvcnMuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x8aW50fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGF1dG9TYXZlOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjb25zb2xlIGlzIGZ1bGwgd2lkdGggYW5kIGZlZWRiYWNrIGlzIGhpZGRlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJpZ0NvbnNvbGU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAgICAgKiAgICBJZiBudWxsLCB0aGVuIGxldCB0aGUgaGVpZ2h0IHJlbWFpbiB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICAgKiAgICBJZiBhIG51bWJlciwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnNvbGVIZWlnaHQ6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hpY2ggcGFuZWwgdG8gc2hvdyBpbiB0aGUgc2Vjb25kIHJvdydzIHNlY29uZCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7U2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlY29uZFJvd1NlY29uZFBhbmVsOiBrby5vYnNlcnZhYmxlKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5GRUVEQkFDSyksXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBiZSB0cmFjaW5nIHRoZSBjb2RlIHJpZ2h0IG5vd1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRyYWNlRXhlY3V0aW9uOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbGlzdCBvZiBwcm9taXNlcyB0byBzdGlsbCByZXNvbHZlIHdoaWxlIGxvYWRpbmcgZGF0YXNldHNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXk8UHJvbWlzZT59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbG9hZGluZ0RhdGFzZXRzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSB0ZW1wb3JhcnkgY2hhbmdlZCB2YWx1ZSBvZiB0aGUgaW5zdHJ1Y3Rpb25zIGhhdmUgYmVlbiBjaGFuZ2VkIGZyb20gd2hhdCBpcyBpbiB0aGUgYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNoYW5nZWRJbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQSBob2xkZXIgZm9yIHRoZSB0aW1lciB0byB0cmlnZ2VyIG9uLWNoYW5nZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0cmlnZ2VyT25DaGFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB0aGUgY3VycmVudCBmZWVkYmFjayBhbmQgb3V0cHV0IGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgICogVGhpcyB3b3VsZCBiZSBmYWxzZSBpZiB0aGVyZSBpcyBubyBmZWVkYmFjay9vdXRwdXQgKGkuZS4sIGNvZGUgaGFzIG5vdCBiZWVuIHJ1biksXG4gICAgICAgICAgICAgICAgICogb3IgaWYgdGhlIHVzZXIgaGFzIG1vZGlmaWVkIHRoZSBzdWJtaXNzaW9uIGFmdGVyIHRoZSBsYXN0IHJ1biAoZS5nLiwgYnkgZWRpdGluZ1xuICAgICAgICAgICAgICAgICAqIHRoZSB0ZXh0KS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXJ0eVN1Ym1pc3Npb246IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIFdoZXRoZXIgb3Igbm90IHRvIG1ha2UgdGhlIEJsb2NrUHkgZWxlbWVudCBpbiBGVUxMIFNDUkVFTiBtb2RlLiBTYWRseSwgbm90IGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAgKiAgd2l0aGluIHRoZSB3aW5kb3csIGJ1dCBGVUxMIFNDUkVFTi4gVmVyeSBhZ2dyZXNzaXZlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZXItc3VwcGxpZWQgcGFzc2NvZGUgdG8gY29tcGFyZSBvbiB0aGUgc2VydmVyIGFnYWluc3QgdGhlIGN1cnJlbnQgcGFzc2NvZGUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGFzc2NvZGU6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gY2xlYXIgb3V0IGlucHV0cyBhZnRlciBhIHJ1bi9vbl9ydW4gY3ljbGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjbGVhcklucHV0czoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBpbWFnZXMgc2hvdWxkIGJlIHJlbmRlcmVkICh0cnVlKSwgb3IganVzdCBzdGF5IGFzIHRleHQgY29kZSAoZmFsc2UpLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbmRlckltYWdlczoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICBlZGl0b3JWZXJzaW9uOiBFRElUT1JfVkVSU0lPTixcbiAgICAgICAgICAgICAgICByZWFkT25seToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJkaXNwbGF5LnJlYWRfb25seVwiLCBcImZhbHNlXCIpLnRvU3RyaW5nKCk9PT1cInRydWVcIiksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXBsb2FkZWQgZmlsZXMgYXJlIG9uZXMgdGhhdCBoYXZlIGJlZW4gbGlzdGVkIGJ5IHRoZSByZW1vdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cGxvYWRlZEZpbGVzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJhY2t1cCBjb3B5IG9mIHRoZSBsYXRlc3Qga25vd24gZnVsbCBjb2RlIGZvciB0aGUgU3VibWlzc2lvbi4gVGhpcyBpcyByZWxldmFudCBpZiB0aGVyZSB3YXMgYVxuICAgICAgICAgICAgICAgICAqIFBhcnRJRCBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgdGhlIHN1Ym1pc3Npb24uY29kZSBpbiB0aGUgbW9kZWwgaXMgb25seSBzaG93aW5nIHdoYXQgd2Uga25vd1xuICAgICAgICAgICAgICAgICAqIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYmFja3VwU3VibWlzc2lvbkNvZGU6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInN1Ym1pc3Npb24uY29kZVwiXSB8fCBcIlwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRIaXN0b3J5OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZERhdGFzZXQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2dFdmVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2U6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVJbWFnZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsaXN0VXBsb2FkZWRGaWxlczoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgZG93bmxvYWRGaWxlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBsb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBsb2FkRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBvbkV4ZWN1dGlvbjoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIHJlcG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgT3V0cHV0IG9iamVjdHNcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBpbnB1dHRlZCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIGEgc3R1ZGVudCBydW5cbiAgICAgICAgICAgICAgICBzdHVkZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cjogdGhlIGZpbGVuYW1lIHRoYXQgd2FzIGxhc3QgZXhlY3V0ZWQgYW5kIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZToga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2Ygc2ltcGxlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlRGF0YToga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2VTdGVwOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWwgZXhlY3V0aW9uIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbHM6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN5c21vZHVsZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBmZWVkYmFjayBmcm9tIHRoZSBpbnN0cnVjdG9yIHJ1blxuICAgICAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ciAobWFya2Rvd24pXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJSZWFkeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc0Vycm9yOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc1VuY292ZXJlZDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRnVuY3Rpb25zIHRvIGZpcmUgd2hlbiBjZXJ0YWluIGV2ZW50cyBvY2N1clxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogV2hlbiB0aGUgc3R1ZGVudCBnZXRzIGEgc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiY2FsbGJhY2suc3VjY2Vzc1wiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzZXJ2ZXIgaXMgY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlcnZlckNvbm5lY3RlZDoga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJzZXJ2ZXIuY29ubmVjdGVkXCIsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBibG9ja2x5UGF0aDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJibG9ja2x5LnBhdGhcIl0sXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudFBvaW50OiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImF0dGFjaG1lbnQucG9pbnRcIl0sXG4gICAgICAgICAgICAgICAgLy8gSlF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBNYXBzIGNvZGVzICgnbG9nX2V2ZW50JywgJ3NhdmVfY29kZScpIHRvIFVSTHNcbiAgICAgICAgICAgICAgICB1cmxzOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcInVybHNcIl0gfHwge30sXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVW5pcXVlIFBhcnQgSUQgdGhhdCBjYW4gZGlzdGluZ3Vpc2ggdGhpcyBlZGl0b3IgaW5zdGFuY2UncyByZWdpb24gb2YgdGhlIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgICogSXQncyBwb3NzaWJsZSB0aGF0IG90aGVyIGVkaXRvcnMgbWF5IGJlIGF0dGFjaGVkIHRvIGEgZGlmZmVyZW50IFBhcnQgb2YgdGhlIHNhbWUgYXNzaWdubW5ldCwgb24gdGhlXG4gICAgICAgICAgICAgICAgICogc2FtZSBwYWdlLlxuICAgICAgICAgICAgICAgICAqICoqL1xuICAgICAgICAgICAgICAgIHBhcnRJZDoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wicGFydElkXCJdIHx8IFwiXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGludGVyZmFjZVxuICAgICAqL1xuICAgIGluaXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIGxldCBjb25zdGFudHMgPSB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGxldCBndWkgPSBtYWtlSW50ZXJmYWNlKHRoaXMpO1xuICAgICAgICBjb25zdGFudHMuY29udGFpbmVyID0gJChjb25zdGFudHMuYXR0YWNobWVudFBvaW50KS5odG1sKCQoZ3VpKSk7XG4gICAgfTtcblxuICAgIGxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5sb2FkQXNzaWdubWVudChhc3NpZ25tZW50X2lkKTtcbiAgICB9XG5cbiAgICBsb2FkVGFncyh0YWdzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHRhZ3NcbiAgICB9XG5cbiAgICBsb2FkU2FtcGxlU3VibWlzc2lvbnMoc2FtcGxlcykge1xuICAgICAgICAvLyBBbHJlYWR5IGEgSlNPTiBsaXN0IHJlcHJlc2VudGluZyBzYW1wbGVzXG4gICAgfVxuXG4gICAgbG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlKGFzc2lnbm1lbnQuZXh0cmFfc3RhcnRpbmdfZmlsZXMsIHRoaXMubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICB9XG5cbiAgICBsb2FkU3VibWlzc2lvbihzdWJtaXNzaW9uLCBhc3NpZ25tZW50KSB7XG4gICAgICAgIGlmICghc3VibWlzc2lvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogU2NhcmllciBcIllvdSBhcmUgbm90IGxvZ2dlZCBpbiBtZXNzYWdlXCJcbiAgICAgICAgICAgIHRoaXMubG9hZE5vU3VibWlzc2lvbihhc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHN1Ym1pc3Npb25zJyBhc3NpZ25tZW50IHZlcnNpb24gYW5kIHRoZSBhc3NpZ25tZW50cycgdmVyc2lvbiBjb25mbGljdD9cbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmlkKHN1Ym1pc3Npb24uaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuYmFja3VwU3VibWlzc2lvbkNvZGUoc3VibWlzc2lvbi5jb2RlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoZXh0cmFjdFBhcnQoc3VibWlzc2lvbi5jb2RlLCB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24ucGFydElkKCkpIHx8IFwiXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWJtaXNzaW9uLmNvcnJlY3QpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc3VibWlzc2lvbi5zY29yZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5lbmRwb2ludChzdWJtaXNzaW9uLmVuZHBvaW50KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnVybChzdWJtaXNzaW9uLnVybCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi52ZXJzaW9uKHN1Ym1pc3Npb24udmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5ncmFkaW5nU3RhdHVzKHN1Ym1pc3Npb24uZ3JhZGluZ19zdGF0dXMgfHwgU3VibWlzc2lvblN0YXR1c2VzLlVOS05PV04pO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhzdWJtaXNzaW9uLnN1Ym1pc3Npb25fc3RhdHVzIHx8IFN1Ym1pc3Npb25TdGF0dXNlcy5VTktOT1dOKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLm93bmVySWQoc3VibWlzc2lvbi51c2VyX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC51c2VyLmNvdXJzZUlkKHN1Ym1pc3Npb24uY291cnNlX2lkKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoc3VibWlzc2lvbi5leHRyYV9maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRBc3NpZ25tZW50RGF0YV8oZGF0YSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGRhdGEpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLmRpc21vdW50RXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgd2FzU2VydmVyQ29ubmVjdGVkID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSBkYXRhLmFzc2lnbm1lbnQ7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pZChhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnZlcnNpb24oYXNzaWdubWVudC52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmNvdXJzZUlkKGFzc2lnbm1lbnQuY291cnNlX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZElkKGFzc2lnbm1lbnQuZm9ya2VkX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZFZlcnNpb24oYXNzaWdubWVudC5mb3JrZWRfdmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oYXNzaWdubWVudC5oaWRkZW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoYXNzaWdubWVudC5yZXZpZXdlZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wdWJsaWMoYXNzaWdubWVudC5wdWJsaWMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudHlwZShhc3NpZ25tZW50LnR5cGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudXJsKGFzc2lnbm1lbnQudXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnBvaW50cyhhc3NpZ25tZW50LnBvaW50cyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcyhhc3NpZ25tZW50LmlwX3Jhbmdlcyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoYXNzaWdubWVudC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQubmFtZShhc3NpZ25tZW50Lm5hbWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoYXNzaWdubWVudC5vbl9jaGFuZ2UgfHwgbnVsbCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50Lm9uX2NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShcIiFvbl9jaGFuZ2UucHlcIiwgYXNzaWdubWVudC5vbl9jaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoYXNzaWdubWVudC5vbl9ldmFsIHx8IG51bGwpO1xuICAgICAgICBpZiAoYXNzaWdubWVudC5vbl9ldmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKFwiIW9uX2V2YWwucHlcIiwgYXNzaWdubWVudC5vbl9ldmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oYXNzaWdubWVudC5vbl9ydW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vd25lcklkKGFzc2lnbm1lbnQub3duZXJfaWQpO1xuICAgICAgICB0aGlzLmxvYWRUYWdzKGFzc2lnbm1lbnQudGFncyk7XG4gICAgICAgIHRoaXMubG9hZFNhbXBsZVN1Ym1pc3Npb25zKGFzc2lnbm1lbnQuc2FtcGxlX3N1Ym1pc3Npb25zKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShhc3NpZ25tZW50LmV4dHJhX3N0YXJ0aW5nX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKTtcbiAgICAgICAgbG9hZEFzc2lnbm1lbnRTZXR0aW5ncyh0aGlzLm1vZGVsLCBhc3NpZ25tZW50LnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5sb2FkU3VibWlzc2lvbihkYXRhLnN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCh3YXNTZXJ2ZXJDb25uZWN0ZWQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuY29yZ2lzLmxvYWREYXRhc2V0cyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5yZWZyZXNoKCk7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgfVxuXG4gICAgaW5pdE1vZGVsTWV0aG9kcygpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBtb2RlbC51aSA9IHtcbiAgICAgICAgICAgIHNtYWxsTGF5b3V0OiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkpLFxuICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgIGlzR3JhZGVyOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51c2VyLnJvbGUoKSA9PT0gXCJvd25lclwiIHx8IG1vZGVsLnVzZXIucm9sZSgpID09PSBcImdyYWRlclwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uczoge1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuaW5zdHJ1Y3Rpb25zLmlzQ2hhbmdlZCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnV0aWxpdGllcy5tYXJrZG93bihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcmVzZXQ6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5SW50ZXJhY3RpdmUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dEZ1bGxzY3JlZW46IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAobW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCkpID8gXCJmYS1jb21wcmVzcy1hcnJvd3MtYWx0XCIgOiBcImZhLWV4cGFuZC1hcnJvd3MtYWx0XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNsaWNrRnVsbHNjcmVlbjogKCkgPT57XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbighbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZWRpdElucHV0czogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZGlhbG9nLkVESVRfSU5QVVRTKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b2dnbGVJbWFnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dEVkaXRvci5kaXNhYmxlSW1hZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuZW5hYmxlSW1hZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5yZW5kZXJJbWFnZXMoIW1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuTWFya1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuY2FuQ2xvc2UoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dE1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC51c2VyLmdyb3VwSWQoKSA/IFwiUHJvYmxlbSBjbG9zZWRcIiA6IFwiQXNzaWdubWVudCBjbG9zZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJlb3BlbiBmb3IgZWRpdGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpICYmIG1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3VibWl0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdCBlYXJseVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2xpY2tNYXJrU3VibWl0dGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiWW91IGNhbm5vdCByZW9wZW4gY2xvc2VkIGFzc2lnbm1lbnRzLiBDb250YWN0IGEgZ3JhZGVyIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvblN0YXR1cyhcImluUHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJTdWJtaXR0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fCBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cygpLnRvTG93ZXJDYXNlKCkgPT09IFwic3VibWl0dGVkXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBsZXRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG93UXVldWVkSW5wdXRzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZVF1ZXVlZElucHV0cygpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG93Q2xvY2s6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oYXNDbG9jaygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlY29uZFJvdzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOiBcImNvbC1tZC01XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZGVUcmFjZUJ1dHRvbjoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZVRyYWNlQnV0dG9uKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQWxsVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVNaWRkbGVQYW5lbCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0ZlZWRiYWNrVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc1RyYWNlVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbnNvbGVTaG93VmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlY29uZFJvdy5pc0ZlZWRiYWNrVmlzaWJsZSgpIHx8IG1vZGVsLnVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hMYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJWaWV3IFRyYWNlXCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhZHZhbmNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYW5lbCA9IG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0spO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYWtlV2lkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFuZWwgPSBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWwoY3VycmVudFBhbmVsKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdG9yZVBhbmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFuZWwgPSBtb2RlbC5kaXNwbGF5LnByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQYW5lbCgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKG9sZFBhbmVsKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFuZWwobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uc29sZToge1xuICAgICAgICAgICAgICAgIHNpemU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtNlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoaWRlRXZhbHVhdGU6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpIHx8ICFtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgIGJhZGdlOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcnVudGltZS1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtaW50ZXJuYWwtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc2VtYW50aWMtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmZWVkYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1mZWVkYmFjay1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcHJvYmxlbS1jb21wbGV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWluc3RydWN0aW9uc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vIGVycm9yc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vLWVycm9yc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUnVudGltZSBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN5bnRheCBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVkaXRvciBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW50ZXJuYWwgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWxnb3JpdGhtIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmVlZGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnN0cnVjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5jb3JyZWN0IEFuc3dlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29tcGxldGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJubyBlcnJvcnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlc2V0U2NvcmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5zY29yZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci51cGRhdGVTdWJtaXNzaW9uKG1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoKSwgbW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCksIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjZToge1xuICAgICAgICAgICAgICAgIGhhczoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRMaW5lOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5zZWNvbmRSb3dTZWNvbmRQYW5lbCgpICE9PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEgfHwgc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJhY2VEYXRhW3N0ZXAtMV0ubGluZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsaW5lOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEgfHwgc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gdHJhY2VcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQmVmb3JlIHJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IGxhc3RTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJGaW5pc2hlZCBydW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoeSBhcmUgdGhlc2UgbnVtYmVycyB3b25reT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkxpbmUgXCIrKHRyYWNlRGF0YVtzdGVwLTFdLmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYXN0OiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTdGFydGluZyBleGVjdXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbGFzdFN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRmluaXNoZWQgZXhlY3V0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkN1cnJlbnQgc3RlcDogXCIgKyBBU1RfREVTQ1JJUFRJT05TW3RyYWNlRGF0YVtzdGVwLTFdLmFzdF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKDApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFja3dhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gTWF0aC5tYXgoMCwgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAocHJldmlvdXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IE1hdGgubWluKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCksIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKG5leHQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBsYXN0U3RlcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VEYXRhW3N0ZXAgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlRGF0YVtzdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGVzOiB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB3aWR0aDoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNvbC1tZC0xMlwiIDogXCJjb2wtbWQtNlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoYXNDb250ZW50czogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjogcmV0dXJuIG1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFpbnN0cnVjdGlvbnMubWRcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2NoYW5nZS5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9ldmFsLnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9tb2NrX3VybHMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP2ltYWdlcy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj9pbWFnZXMuYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3ByZWZpeC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3N1ZmZpeC5weVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLnNvbWUoZmlsZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUoKSA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dG9vbGJveC5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj90b29sYm94LmJsb2NrcHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXRhZ3MuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC50YWdzKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5zYW1wbGVTdWJtaXNzaW9ucygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9tb2NrX3VybHMuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfcHJlZml4LnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9zdWZmaXgucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dGFncy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP3NldHRpbmdzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj9pbWFnZXMuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCwgXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/dG9vbGJveC5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vcm1hbFRvb2xib3ggPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmJsb2NrRWRpdG9yLlRPT0xCT1hFU1tcIm5vcm1hbFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxUb29sYm94ID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsVG9vbGJveCwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoLCBub3JtYWxUb29sYm94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zKFtTYW1wbGVTdWJtaXNzaW9uLkJsYW5rKCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9jaGFuZ2UucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmaXggZXh0cmFmaWxlcyBmb3IgaW5zdHJ1Y3RvciBhbmQgc3R1ZGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFvbl9ldmFsLnB5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5vbkV2YWwoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZURpYWxvZyhcImluc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0dWRlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlRGlhbG9nKFwic3R1ZGVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhcnRpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlRGlhbG9nKFwic3RhcnRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUocGF0aCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZGVsZXRlRmlsZShtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuYW1lOiAobmV3TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ucmVuYW1lRmlsZShtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCksIG5ld05hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0U3R1ZGVudENvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlZml4UHkgPSBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiIWFuc3dlcl9wcmVmaXgucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWZmaXhQeSA9IHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCIhYW5zd2VyX3N1ZmZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBzZWxmLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZml4UHkgJiYgcHJlZml4UHkuaGFuZGxlICYmIHByZWZpeFB5LmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gcHJlZml4UHkuaGFuZGxlKCkgKyBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWZmaXhQeSAmJiBzdWZmaXhQeS5oYW5kbGUgJiYgc3VmZml4UHkuaGFuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICsgc3VmZml4UHkuaGFuZGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHRyYVN0dWRlbnRGaWxlczogb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKSxcbiAgICAgICAgICAgICAgICBleHRyYUluc3RydWN0b3JGaWxlczogb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyksXG4gICAgICAgICAgICAgICAgZXh0cmFTdGFydGluZ0ZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyksXG4gICAgICAgICAgICAgICAgZGlzcGxheUZpbGVuYW1lOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJVUkwgRGF0YVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIj9pbWFnZXMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbWFnZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbnN3ZXIgUHJlZml4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiIWFuc3dlcl9zdWZmaXgucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQW5zd2VyIFN1ZmZpeFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIj90b29sYm94LmJsb2NrcHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVG9vbGJveFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCImXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVkaXRvcnM6IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBrby5wdXJlQ29tcHV0ZWQoICgpPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuZ2V0RWRpdG9yKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOiBcImNvbC1tZC03XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHZpZXc6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUVkaXRvcnMoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5SW50ZXJhY3RpdmUoKSkpID8gXCJOb25lXCIgOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPyBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKSA6IFwiTm9uZVwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuUmVzZXRcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uY29kZShtb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKCkubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gZmlsZS5maWxlbmFtZSgpLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW5TYXZlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmRpc3BsYXkuYXV0b1NhdmUoKSksXG4gICAgICAgICAgICAgICAgY2FuRGVsZXRlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKCFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVGaWxlcygpIHx8IG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKSAmJlxuICAgICAgICAgICAgICAgICAgICBVTkRFTEVUQUJMRV9GSUxFUy5pbmRleE9mKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSkgPT09IC0xKSxcbiAgICAgICAgICAgICAgICBjYW5SZW5hbWU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKCkgfHwgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIFVOUkVOQU1BQkxFX0ZJTEVTLmluZGV4T2YobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKSA9PT0gLTEpLFxuICAgICAgICAgICAgICAgIHVwbG9hZDogdXBsb2FkRmlsZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZEZpbGUuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBpbXBvcnREYXRhc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5jb3JnaXMub3BlbkRpYWxvZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHl0aG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2RlTWlycm9yID0gc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0RWRpdG9yLmNvZGVNaXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZU1pcnJvci5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjb2RlTWlycm9yLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVNb2RlOiAobmV3TW9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtVmlldy5DaGFuZ2VcIiwgXCJcIiwgXCJcIiwgbmV3TW9kZSwgbW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShuZXdNb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLm9sZFB5dGhvbk1vZGUgPSBuZXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc0hpc3RvcnlBdmFpbGFibGU6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRIaXN0b3J5XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgdHVybk9mZkhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnVwZGF0ZUVkaXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5zZXRSZWFkT25seShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHVybk9uSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9hZEhpc3RvcnkoKHJlc3BvbnNlKSA9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5sb2FkKHJlc3BvbnNlLmhpc3RvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnNldFJlYWRPbmx5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19ISVNUT1JZKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUhpc3RvcnlNb2RlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLmVkaXRvcnMucHl0aG9uLnR1cm5Pbkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhpc3Rvcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlVG9TdGFydCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXM6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVQcmV2aW91cygpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZU5leHQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RSZWNlbnQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVUb01vc3RSZWNlbnQoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZTogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkudXNlKCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbG9hZEltYWdlczogKCkgPT4gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiaW1hZ2VcIikucmVsb2FkSW1hZ2VzKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhdmU6ICgpID0+IHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIuc2F2ZUFzc2lnbm1lbnQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRFZGl0b3I6IChuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdG9yID0gc2VsZi5jb21wb25lbnRzLmVkaXRvcnMuYnlOYW1lKFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGVjdXRlOiB7XG4gICAgICAgICAgICAgICAgaXNSdW5uaW5nOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcnVuTGFiZWw6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFID8gXCJTdG9wXCIgOiBcIlJ1blwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBydW46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHlnYW1lTGliICE9PSBcInVuZGVmaW5lZFwiICYmIFB5Z2FtZUxpYi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHlnYW1lTGliLlN0b3BQeWdhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmRlbGF5ZWRSdW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcnVuUXVpZXRseUxhYmVsOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFID8gXCJTdG9wXCIgOiBcIlJ1biB3aXRob3V0IGZlZWRiYWNrXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJ1blF1aWV0bHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHlnYW1lTGliICE9PSBcInVuZGVmaW5lZFwiICYmIFB5Z2FtZUxpYi5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHlnYW1lTGliLlN0b3BQeWdhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmRlbGF5ZWRSdW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlOiAoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZW5naW5lLmV2YWx1YXRlKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IChlbmRwb2ludCA9PlxuICAgICAgICAgICAgICAgICAgICBcInNlcnZlci1zdGF0dXMtXCIgKyBtb2RlbC5zdGF0dXNbZW5kcG9pbnRdKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzRW5kcG9pbnRDb25uZWN0ZWQ6IChlbmRwb2ludCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5zZXJ2ZXJDb25uZWN0ZWQoKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLnVybHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLnVybHNbZW5kcG9pbnRdICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBjYXBpdGFsaXplKG1vZGVsLnN0YXR1cy5sb2FkQXNzaWdubWVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnNhdmVBc3NpZ25tZW50TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZEhpc3RvcnlNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2FkRmlsZU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnNhdmVGaWxlTWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZERhdGFzZXRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5sb2dFdmVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnNhdmVJbWFnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMudXBkYXRlU3VibWlzc2lvbk1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNNZXNzYWdlKCkgfHwgXCJcIilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZvcmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50OiAoZGF0YSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0IGZpbGVIYW5kbGVyID0gJChcIi5ibG9ja3B5LWZvcmNlLWxvYWQtYXNzaWdubWVudC1maWxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b24gPSAkKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbGVIYW5kbGVyLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkucGFyZW50KCkuZmFkZU91dCgxMDApLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdXNlciB0byB1cGxvYWQgYSBmaWxlIGNvbnRhaW5pbmcgYW4gYXNzaWdubWVudCBzdWJtaXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzID0gYXNzaWdubWVudEZvcmNlTG9hZEJ1dHRvblswXS5maWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXNzaWdubWVudFN1Ym1pc3Npb24gPSBKU09OLnBhcnNlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkQXNzaWdubWVudERhdGFfKGFzc2lnbm1lbnRTdWJtaXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5maWxlTmFtZSA9IGZpbGVzWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5yZWFkQXNUZXh0KGZpbGVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b24udmFsKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdWJtaXNzaW9uOiAoZGF0YSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvbihzZWxmLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5mYWRlT3V0KDEwMCkuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9vdGVyOiB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZToga28ucHVyZUNvbXB1dGVkKFxuICAgICAgICAgICAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLnVpLnNtYWxsTGF5b3V0KClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zKHNlbGYsIG1vZGVsKTtcbiAgICB9XG5cbiAgICB0dXJuT25IYWNrcygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRPRE9cIik7XG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvaW1hZ2UuanNcIl0gPSBpbWFnZU1vZHVsZS50b1N0cmluZygpO1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvd2Vha3JlZi5qc1wiXSA9IHdlYWtyZWZNb2R1bGUudG9TdHJpbmcoKTtcbiAgICAgICAgLy9Tay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL21hdHBsb3RsaWIvcHlwbG90L19faW5pdF9fLmpzXCJdID0gbWF0cGxvdGxpYk1vZHVsZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5cyB0aGUgS25vY2tvdXRKUyBiaW5kaW5ncyB0byB0aGUgbW9kZWwsIGluc3RhbnRpYXRpbmcgdGhlIHZhbHVlcyBpbnRvIHRoZVxuICAgICAqIEhUTUwuXG4gICAgICovXG4gICAgYXBwbHlNb2RlbCgpIHtcbiAgICAgICAga28uYXBwbHlCaW5kaW5ncyh0aGlzLm1vZGVsLCB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyWzBdKTtcbiAgICB9XG5cbiAgICBpbml0VXRpbGl0aWVzKCkge1xuICAgICAgICBsZXQgbWFpbiA9IHRoaXM7XG4gICAgICAgIHRoaXMudXRpbGl0aWVzID0ge1xuICAgICAgICAgICAgbWFya2Rvd246ICh0ZXh0KSA9PiB0ZXh0ID8gRWFzeU1ERS5wcm90b3R5cGUubWFya2Rvd24odGV4dCkgOiBcIjxwPjwvcD5cIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGluaXRDb21wb25lbnRzKCkge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lcjtcbiAgICAgICAgbGV0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzO1xuICAgICAgICAvLyBFYWNoIG9mIHRoZXNlIGNvbXBvbmVudHMgd2lsbCB0YWtlIHRoZSBCbG9ja1B5IGluc3RhbmNlLCBhbmQgcG9zc2libHkgYVxuICAgICAgICAvLyByZWZlcmVuY2UgdG8gdGhlIHJlbGV2YW50IEhUTUwgbG9jYXRpb24gd2hlcmUgaXQgd2lsbCBiZSBlbWJlZGRlZC5cbiAgICAgICAgY29tcG9uZW50cy5kaWFsb2cgPSBuZXcgQmxvY2tQeURpYWxvZyhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWRpYWxvZ1wiKSk7XG4gICAgICAgIGNvbXBvbmVudHMuZmVlZGJhY2sgPSBuZXcgQmxvY2tQeUZlZWRiYWNrKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2tcIikpO1xuICAgICAgICBjb21wb25lbnRzLnRyYWNlID0gbmV3IEJsb2NrUHlUcmFjZShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5jb25zb2xlID0gbmV3IEJsb2NrUHlDb25zb2xlKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktY29uc29sZVwiKSk7XG4gICAgICAgIGNvbXBvbmVudHMuZW5naW5lID0gbmV3IEJsb2NrUHlFbmdpbmUobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuZmlsZVN5c3RlbSA9IG5ldyBCbG9ja1B5RmlsZVN5c3RlbShtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5lZGl0b3JzID0gbmV3IEVkaXRvcnMobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1lZGl0b3JcIikpO1xuICAgICAgICAvLyBDb252ZW5pZW50IHNob3J0Y3V0IGRpcmVjdGx5IHRvIFB5dGhvbkVkaXRvclxuICAgICAgICBjb21wb25lbnRzLnB5dGhvbkVkaXRvciA9IHRoaXMuY29tcG9uZW50cy5lZGl0b3JzLmJ5TmFtZShcInB5dGhvblwiKTtcbiAgICAgICAgY29tcG9uZW50cy5zZXJ2ZXIgPSBuZXcgQmxvY2tQeVNlcnZlcihtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5jb3JnaXMgPSBuZXcgQmxvY2tQeUNvcmdpcyhtYWluKTtcbiAgICAgICAgY29tcG9uZW50cy5oaXN0b3J5ID0gbmV3IEJsb2NrUHlIaXN0b3J5KG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktaGlzdG9yeS10b29sYmFyXCIpKTtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLnNob3coKTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmhpZGUoKTtcbiAgICB9XG5cbiAgICBtYWtlRXh0cmFTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucy5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUluc3RydWN0aW9ucy5DaGFuZ2VcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCwgXCJpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb2NrID0gbnVsbDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgdXBkYXRlQ2xvY2sgPSAoKSA9PiBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LW1lbnUtY2xvY2tcIikudGV4dChnZXRDdXJyZW50VGltZSgpKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwudWkubWVudS5zaG93Q2xvY2soKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9jayA9IHNldEludGVydmFsKHVwZGF0ZUNsb2NrLCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWwudWkubWVudS5zaG93Q2xvY2suc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC51aS5tZW51LnNob3dDbG9jaygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9jayA9IHNldEludGVydmFsKHVwZGF0ZUNsb2NrLCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgcmVzZXRJbnRlcmZhY2UoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5lbmdpbmUucmVzZXQoKTtcbiAgICAgICAgLy8gRGlzYWJsZSBhbnkgYWx0ZXJuYXRpdmUgbG9nRW50cnkgZnVuY3Rpb25zIHdlIGhhdmUgYmVlbiBnaXZlblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmFsdExvZ0VudHJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXF1ZXN0UGFzc2NvZGUoKSB7XG4gICAgICAgIGxldCB1c2VyU3VwcGxpZWRQYXNzY29kZSA9IHByb21wdChcIlBsZWFzZSBlbnRlciB0aGUgcGFzc2NvZGUuXCIpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkucGFzc2NvZGUodXNlclN1cHBsaWVkUGFzc2NvZGUpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG5cbiAgICB9XG5cbn1cblxuIiwiaW1wb3J0IHtlbmNvZGVIVE1MfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBFdmFsdWF0ZSBidXR0b24gSFRNTCB0ZW1wbGF0ZVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgU1RBUlRfRVZBTF9IVE1MID0gYFxuPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1vdXRsaW5lIGZsb2F0LXJpZ2h0IGJsb2NrcHktYnRuLWV2YWxcIj5cbiAgICBFdmFsdWF0ZVxuPC9idXR0b24+YDtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciBhIG5ldyBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgTkVXX0NPTlNPTEVfTElORV9IVE1MID0gXCI8ZGl2PjwvZGl2PlwiO1xuXG4vKipcbiAqIEhUTUwgdGVtcGxhdGUgZm9yIHRoZSBlbnRpcmUgY29uc29sZSBhcmVhXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ09OU09MRV9IVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktcGFuZWwgYmxvY2tweS1jb25zb2xlJ1xuICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiQ29uc29sZVwiXG4gICAgICAgICAgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLmNvbnNvbGUuc2l6ZVwiPlxuICAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0IGJsb2NrcHktc2hvdy1mZWVkYmFjaydcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNlY29uZFJvdy5pc0NvbnNvbGVTaG93VmlzaWJsZSwgY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICA8c3Ryb25nPkNvbnNvbGU6PC9zdHJvbmc+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LXByaW50ZXIgYmxvY2tweS1wcmludGVyLWRlZmF1bHQnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgIDwvZGl2PmA7XG5cbi8qKlxuICogQWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBmb3IgYSBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQGVudW1cbiAqL1xuZXhwb3J0IGxldCBDb25zb2xlTGluZVR5cGUgPSB7XG4gICAgVEVYVDogXCJ0ZXh0XCIsXG4gICAgSFRNTDogXCJodG1sXCIsXG4gICAgUExPVDogXCJwbG90XCIsXG4gICAgSU1BR0U6IFwiaW1hZ2VcIixcbiAgICBQWUdBTUU6IFwicHlnYW1lXCIsXG4gICAgVFVSVExFOiBcInR1cnRsZVwiLFxuICAgIEVWQUw6IFwiZXZhbFwiLFxuICAgIFNUQVJUX0VWQUw6IFwic3RhcnRfZXZhbFwiLFxuICAgIFZBTFVFOiBcInZhbHVlXCIsXG4gICAgSU5QVVQ6IFwiaW5wdXRcIixcbiAgICBURVNUX0NBU0U6IFwidGVzdF9jYXNlXCJcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgdmVyc2lvbiBvZiBhIGxpbmUgaW4gdGhlIGNvbnNvbGUuIEFsbCBvdGhlciBjb25zb2xlIGxpbmVzXG4gKiBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuIENyaXRpY2FsbHksIHRoZXkgbmVlZCB0byBpbXBsZW1lbnQgYSByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmNsYXNzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgYmFjayB0byB0aGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlLlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge0Jsb2NrUHl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F0ZWdvcml6ZXMgd2hhdCBraW5kIG9mIGxpbmUgdGhpcyBpcyAodGV4dC9odG1sL3Bsb3QvZXRjLilcbiAgICAgICAgICogQHR5cGUge0NvbnNvbGVMaW5lVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0dWFsIGRhdGEgc3RvcmVkIG9uIHRoaXMgbGluZS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRhZGF0YSBhYm91dCB3aGVyZSB0aGUgbGluZSBvcmlnaW5hdGVkIGZyb20gaW4gdGhlIGNvZGUuXG4gICAgICAgICAqIEB0eXBlIHt7ZmlsZW5hbWU6IHN0cmluZywgbGluZTogbnVtYmVyLCBzdGVwOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB7XG4gICAgICAgICAgICBmaWxlbmFtZTogU2suY3VyckZpbGVuYW1lLFxuICAgICAgICAgICAgc3RlcDogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCxcbiAgICAgICAgICAgIGxpbmU6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIGNvbnRlbnQgc3RvcmVkIG9uIHRoaXMgbGluZSwgbWVhbnQgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICogdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEB0eXBlIHsqfGpRdWVyeS5mbi5pbml0fGpRdWVyeXxIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHRtbCA9ICQoXCI8ZGl2PjwvZGl2PlwiLCB7XG4gICAgICAgICAgICBcImNsYXNzXCI6ICBcImJsb2NrcHktcHJpbnRlci1vdXRwdXRcIixcbiAgICAgICAgICAgIFwiZGF0YS1jb250YWluZXJcIjogbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludCxcbiAgICAgICAgICAgIFwiZGF0YS10b2dnbGVcIjogXCJ0b29sdGlwXCIsXG4gICAgICAgICAgICBcImRhdGEtcGxhY2VtZW50XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJkYXRhLXN0ZXBcIjogdGhpcy5vcmlnaW4uc3RlcCxcbiAgICAgICAgICAgIFwidGl0bGVcIjogXCJTdGVwIFwiICsgdGhpcy5vcmlnaW4uc3RlcCArIFwiLCBMaW5lIFwiICsgdGhpcy5vcmlnaW4ubGluZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGluZSBzaG91bGQgYmUgdmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9ICFtYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTa3VscHQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zb2xlIGxpbmUncyBjb250ZW50LlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHRvU2t1bHB0KCkge1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeSh0aGlzLmNvbnRlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnNvbGUgbGluZSBieSBkZWxldGluZyBpdHMgSFRNTCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuaHRtbC5yZW1vdmUoKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVHVydGxlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIC8vIFRPRE86IENhcHR1cmUgdHVydGxlIGNvbW1hbmRzIGZvciB0cmFjaW5nIHB1cnBvc2VzXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuVFVSVExFKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXR1cnRsZS1vdXRwdXRcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sWzBdLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6IFwic21vb3RoXCIgfSk7XG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5odG1sLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgIC8vJCgnaHRtbCcpLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUHlnYW1lIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUFlHQU1FKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXB5Z2FtZS1vdXRwdXRcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW47XG4gICAgICAgIHRoaXMucHlnYW1lT2JqID0gcHlnYW1lT2JqO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgLy9Tay5tYWluX2NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDYW52YXNcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgd2hlcmUucHJlcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIC8vIFN0YXJ0cyBvZmYgYXMgYSBuby1vcFxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCA9ICgpID0+IHt9O1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuc2Vjb25kUm93LnJlc3RvcmVQYW5lbCgpO1xuICAgIH1cblxuICAgIGZpbmFsaXplKGNsZWFudXBGdW5jdGlvbiwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiBjbGVhbnVwRnVuY3Rpb24odGhpcy5weWdhbWVPYmosIGxpc3RlbmVycyk7XG4gICAgfVxuXG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW1hZ2UgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU1BR0UsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtaW1hZ2Utb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUGxvdCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5QTE9ULCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXBsb3Qtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVUZXh0IGV4dGVuZHMgQ29uc29sZUxpbmUge1xuXG4gICAgYWRkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudCArIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGlmICghZW5jb2RlZFRleHQgfHwgZW5jb2RlZFRleHQudHJpbSgpLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFRleHQgPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVWYWx1ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlZBTFVFLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IGVuY29kZWRUZXh0ID0gZW5jb2RlSFRNTCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxjb2RlPjwvY29kZT5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVJbnB1dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5JTlBVVCwgcHJvbXB0TWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBJbnB1dCBib3ggZm9yIHJlY2VpdmluZyBpbnB1dCgpIGZyb20gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFuaW5nXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIElucHV0IGZvcm1cbiAgICAgICAgICAgIGxldCBpbnB1dEZvcm0gPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIC8+XCIpO1xuICAgICAgICAgICAgLy8gRW50ZXIgYnV0dG9uXG4gICAgICAgICAgICBsZXQgaW5wdXRCdG4gPSAkKFwiPGJ1dHRvbj48L2J1dHRvbj5cIiwge1wiaHRtbFwiOiBcIkVudGVyXCJ9KTtcbiAgICAgICAgICAgIC8vIEdyb3VwIGZvcm0gYW5kIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0R3JvdXAgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1wiY2xhc3NcIjogXCJibG9ja3B5LWNvbnNvbGUtaW5wdXRcIn0pO1xuICAgICAgICAgICAgaW5wdXRHcm91cC5hcHBlbmQoaW5wdXRGb3JtKTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0QnRuKTtcbiAgICAgICAgICAgIC8vIFByb21wdCBib3gsIG5ldyBsaW5lLCBpbnB1dCBncm91cFxuICAgICAgICAgICAgbGV0IGlucHV0Qm94ID0gJChcIjxkaXY+PC9kaXY+XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudCAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRNc2cgPSAkKFwiPHNhbXA+PC9zYW1wPlwiLCAge1wiaHRtbFwiOiBlbmNvZGVkVGV4dH0pO1xuICAgICAgICAgICAgICAgIGlucHV0Qm94LmFwcGVuZChpbnB1dE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoJChcIjxicj5cIikpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChpbnB1dEdyb3VwKTtcbiAgICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChpbnB1dEJveCk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgaW50ZXJhY3RpdmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VJbnRlcmFjdGl2ZShpbnB1dEZvcm0sIGlucHV0QnRuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgbWFrZUludGVyYWN0aXZlKGlucHV0LCBidXR0b24pIHtcbiAgICAgICAgbGV0IHJlc29sdmVPbkNsaWNrO1xuICAgICAgICBsZXQgc3VibWl0dGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICBsZXQgc3VibWl0Rm9ybSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB1c2VySW5wdXR0ZWRWYWx1ZSA9IGlucHV0LnZhbCgpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5wdXNoKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHJlc29sdmVPbkNsaWNrKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIGlucHV0LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1dHRvbi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9O1xuICAgICAgICBidXR0b24uY2xpY2soc3VibWl0Rm9ybSk7XG4gICAgICAgIGlucHV0LmtleXVwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgIHN1Ym1pdEZvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0SW5kZXgsIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5sZW5ndGgpO1xuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB1c2VySW5wdXR0ZWRWYWx1ZSA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIGlucHV0LnZhbCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VibWl0dGVkUHJvbWlzZTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lRXZhbHVhdGUgZXh0ZW5kcyBDb25zb2xlTGluZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIFwiRXZhbHVhdGU6XCIpO1xuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVTdGFydEV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlNUQVJUX0VWQUwpO1xuICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKCQoU1RBUlRfRVZBTF9IVE1MKSk7XG4gICAgICAgIHRoaXMuaHRtbC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZXhlY3V0ZS5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlDb25zb2xlIHtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBmb3IgbWFuYWdpbmcgdGhlIGNvbnNvbGUsIHdpdGggZmVhdHVyZXMgZm9yIHRoaW5ncyBsaWtlIHByaW50aW5nLCBwbG90dGluZywgZXZhbGluZywgaW5wdXRpbmcuXG4gICAgICogVGhlIFwicHJpbnRlclwiIGlzIHRoZSByZWdpb24gd2hlcmUgd2UgcHV0IHRoaW5ncywgYXMgb3Bwb3NlZCB0byB0aGUgY29uc29sZSBhcyBhIHdob2xlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5wcmludGVyVGFnID0gdGFnLmZpbmQoXCIuYmxvY2tweS1wcmludGVyXCIpO1xuXG4gICAgICAgIHRoaXMuTUlOSU1VTV9XSURUSCA9IDIwMDtcbiAgICAgICAgdGhpcy5NSU5JTVVNX0hFSUdIVCA9IDIwMDtcbiAgICAgICAgdGhpcy5ERUZBVUxUX0hFSUdIVCA9IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKTsgLy8gTGV0IENTUyBkZWZpbmUgdGhpc1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5ERUZBVUxUX0hFSUdIVCk7XG5cbiAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dDtcbiAgICAgICAgLy90aGlzLmlucHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gVE9ETzogSWYgdGhlIHVzZXIgbW9kaWZpZXMgYSBmaWxlLCB0aGVuIG1ha2UgdGhlIGNvbnNvbGUgbG9vayBmYWRlZCBhIGxpdHRsZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgc3RhdHVzIG9mIHRoZSBwcmludGVyLCBpbmNsdWRpbmcgcmVtb3ZpbmcgYW55IHRleHQgaW4gaXQgYW5kXG4gICAgICogZml4aW5nIGl0cyBzaXplLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm91dHB1dC5yZW1vdmVBbGwoKTtcblxuICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcuZW1wdHkoKTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgd2UnbGwgcmVzZXQgaXRcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQodGhpcy5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHVydGxlTGluZSA9IG51bGw7XG4gICAgICAgIFNrLlR1cnRsZUdyYXBoaWNzID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFR1cnRsZUxpbmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICBhc3NldHM6IHRoaXMubG9hZEFzc2V0LmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnB5Z2FtZUxpbmUgPSBudWxsO1xuICAgIH07XG5cbiAgICBsb2FkQXNzZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBnZXRUdXJ0bGVMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy50dXJ0bGVMaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBuZXcgQ29uc29sZUxpbmVUdXJ0bGUodGhpcy5tYWluKTtcbiAgICAgICAgICAgIHRoaXMudHVydGxlTGluZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIGRvIHNvXG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KCkgPT09IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UHJpbnRlckRpbWVuc2lvbiA9IHRoaXMucHJpbnRlclRhZy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoY3VycmVudFByaW50ZXJEaW1lbnNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIFNrLlR1cnRsZUdyYXBoaWNzLmhlaWdodCA9IGN1cnJlbnRQcmludGVyRGltZW5zaW9uLTQwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR1cnRsZUxpbmUuaHRtbFswXTtcbiAgICB9XG5cbiAgICBoYW5kbGVQeWdhbWVSZXNpemUobmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCBhbmQgdGhlIG5ld0hlaWdodCBpcyBiaWdnZXIgdGhhbiBkZWZhdWx0LCB3ZSdsbCBjaGFuZ2UgaXRcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkgJiZcbiAgICAgICAgICAgIG5ld0hlaWdodCA+IHRoaXMuREVGQVVMVF9IRUlHSFQpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoMzArbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBweWdhbWUgd2luZG93IGlzIHdpZGVyIHRoYW4gdGhlIGNvbnNvbGUsIHdlJ2xsIGV4cGFuZCB0ZW1wb3JhcmlseS5cbiAgICAgICAgaWYgKG5ld1dpZHRoID4gdGhpcy5wcmludGVyVGFnLndpZHRoKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5zZWNvbmRSb3cubWFrZVdpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmlzaFR1cnRsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zYXZlVHVydGxlT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR1cnRsZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50dXJ0bGVMaW5lLmh0bWwuZmluZChcImNhbnZhc1wiKS5sYXN0KClbMF07XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlSW1hZ2UoXCJ0dXJ0bGVfb3V0cHV0XCIsIGRhdGFVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5weWdhbWVMaW5lLmNhbnZhcztcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVJbWFnZShcInR1cnRsZV9vdXRwdXRcIiwgZGF0YVVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgaWYgdGhlcmUgYXJlIG5vIHR1cnRsZXMgdG8gc2F2ZT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHR1cnRsZXMgc2hvdWxkIGJlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHdpZHRoXG4gICAgbmV3VHVydGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuTUlOSU1VTV9XSURUSCwgdGhpcy5wcmludGVyVGFnLndpZHRoKCktNDApO1xuICAgIH1cblxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuTUlOSU1VTV9IRUlHSFQsIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSs0MCk7XG4gICAgfVxuXG4gICAgaXNNdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBlYWNoIHByaW50ZWQgZWxlbWVudCBpbiB0aGUgcHJpbnRlciBhbmQgbWFrZXMgaXQgaGlkZGVuXG4gICAgICogb3IgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIHdoYXQgc3RlcCB3ZSdyZSBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwIC0gVGhlIGN1cnJlbnQgc3RlcCBvZiB0aGUgZXhlY3V0ZWQgcHJvZ3JhbSB0aGF0IHdlJ3JlIG9uOyBlYWNoIGVsZW1lbnQgaW4gdGhlIHByaW50ZXIgbXVzdCBiZSBtYXJrZWQgd2l0aCBhIFwiZGF0YS1zdGVwXCIgcHJvcGVydHkgdG8gcmVzb2x2ZSB0aGlzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlIC0gRGVwcmVjYXRlZCwgbm90IHN1cmUgd2hhdCB0aGlzIGV2ZW4gZG9lcy5cbiAgICAgKi9cbiAgICBzdGVwUHJpbnRlcihzdGVwLCBwYWdlKSB7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlci1vdXRwdXRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmF0dHIoXCJkYXRhLXN0ZXBcIikgPD0gc3RlcCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByaW50IGEgbGluZSB0byB0aGUgb24tc2NyZWVuIHByaW50ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVUZXh0IC0gQSBsaW5lIG9mIHRleHQgdG8gYmUgcHJpbnRlZCBvdXQuXG4gICAgICovXG4gICAgcHJpbnQobGluZVRleHQpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBtZWFucyBkbyBub3RoaW5nLlxuICAgICAgICAvLyBwcmludChcIlwiLCBlbmQ9XCJcIilcbiAgICAgICAgaWYgKCFsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAobGluZVRleHQuY2hhckF0KGxpbmVUZXh0Lmxlbmd0aC0xKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGxpdExpbmVzID0gbGluZVRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGlmICh0aGlzLmxpbmVCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVRleHQodGhpcy5tYWluLCBDb25zb2xlTGluZVR5cGUuVEVYVCwgc3BsaXRMaW5lc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIuYWRkQ29udGVudChzcGxpdExpbmVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTE7IGkgPCBzcGxpdExpbmVzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGhpcy5saW5lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVRleHQodGhpcy5tYWluLCBDb25zb2xlTGluZVR5cGUuVEVYVCwgc3BsaXRMaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRoaXMubGluZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcGxvdChwbG90cykge1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVQbG90KHRoaXMubWFpbiwgcGxvdHMpO1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3RCdWZmZXI7XG4gICAgfVxuXG4gICAgcHlnYW1lKHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaikge1xuICAgICAgICBpZiAodGhpcy5weWdhbWVMaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB5Z2FtZUxpbmUgPSBuZXcgQ29uc29sZUxpbmVQeWdhbWUodGhpcy5tYWluLCBzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopO1xuICAgICAgICAgICAgdGhpcy5weWdhbWVMaW5lLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB5Z2FtZUxpbmU7XG4gICAgfVxuXG4gICAgcHJpbnRQSUxJbWFnZShpbWFnZURhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJURVNUXCIsIGltYWdlRGF0YS5pbWFnZSk7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbWFnZSh0aGlzLm1haW4sIGltYWdlRGF0YS5pbWFnZSk7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlQnVmZmVyO1xuICAgIH1cblxuICAgIHByaW50VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IHByaW50ZWRWYWx1ZSA9IG5ldyBDb25zb2xlTGluZVZhbHVlKHRoaXMubWFpbiwgdmFsdWUpO1xuICAgICAgICBwcmludGVkVmFsdWUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiBwcmludGVkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgUHJvbWlzZSBmcm9tIHRoZSBJbnB1dCBib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvbXB0TWVzc2FnZSAtIE1lc3NhZ2UgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUlucHV0KHRoaXMubWFpbiwgcHJvbXB0TWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH07XG5cblxuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLmlucHV0QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lRXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgfVxuXG4gICAgYmVnaW5FdmFsKCkge1xuICAgICAgICBsZXQgc3RhcnRFdmFsdWF0aW9uID0gbmV3IENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSh0aGlzLm1haW4pO1xuICAgICAgICByZXR1cm4gc3RhcnRFdmFsdWF0aW9uLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuY29uZGl0aW9uYWxseSBzY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93LlxuICAgICAqXG4gICAgICovXG4gICAgc2Nyb2xsVG9Cb3R0b20oKSB7XG4gICAgICAgIHRoaXMudGFnLmFuaW1hdGUoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiB0aGlzLnRhZy5wcm9wKFwic2Nyb2xsSGVpZ2h0XCIpIC0gdGhpcy50YWcucHJvcChcImNsaWVudEhlaWdodFwiKVxuICAgICAgICB9LCA1MDApO1xuICAgIH07XG5cbn0iLCJpbXBvcnQge3NsdWd9IGZyb20gXCIuL3V0aWxpdGllc1wiO1xuXG4vLyBUT0RPOiBlZGl0b3IuYm0uYmxvY2tFZGl0b3IuZXh0cmFUb29sc1tdXG5cbmV4cG9ydCBsZXQgX0lNUE9SVEVEX0RBVEFTRVRTID0ge307XG5leHBvcnQgbGV0IF9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUyA9IHt9O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsaXN0aWMgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCB0cmFuc2Zvcm1cbiAqIGEgZ2l2ZW4gYnV0dG9uIGludG8gYSBcIkxvYWRlZFwiIHN0YXRlIChkaXNhYmxlZCwgcHJlc3NlZCBzdGF0ZSwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnRuIC0gQW4gSFRNTCBlbGVtZW50IHRvIGNoYW5nZSB0aGUgdGV4dCBvZi5cbiAqL1xubGV0IHNldEJ1dHRvbkxvYWRlZCA9IGZ1bmN0aW9uIChidG4pIHtcbiAgICBidG4uYWRkQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgICAgLmFkZENsYXNzKFwiYnRuLXN1Y2Nlc3NcIilcbiAgICAgICAgLnJlbW92ZUNsYXNzKFwiYnRuLXByaW1hcnlcIilcbiAgICAgICAgLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAudGV4dChcIkxvYWRlZFwiKVxuICAgICAgICAuYXR0cihcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XG59O1xuXG5cbi8qKlxuICogTW9kdWxlIHRoYXQgY29ubmVjdHMgdG8gdGhlIENPUkdJUyBkYXRhc2V0cyBhbmQgbWFuYWdlcyBpbnRlcmFjdGlvbnNcbiAqIHdpdGggdGhlbS4gVGhpcyBpbmNsdWRlcyBsb2FkaW5nIGluIGRhdGFzZXRzIGF0IGxhdW5jaCBhbmQgb24tdGhlLWZseS5cbiAqIE5vdGUgdGhhdCB0aGlzIGhhcyBubyBwcmVzZW5jZSBvbiBzY3JlZW4sIHNvIGl0IGRvZXMgbm90IGhhdmUgYSB0YWcuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUNvcmdpc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeUNvcmdpcyhtYWluKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcblxuICAgIHRoaXMubG9hZGVkRGF0YXNldHMgPSBbXTtcbiAgICB0aGlzLmxvYWREYXRhc2V0cygpO1xufVxuXG5CbG9ja1B5Q29yZ2lzLnByb3RvdHlwZS5sb2FkRGF0YXNldHMgPSBmdW5jdGlvbiAoc2lsZW50bHkpIHtcbiAgICAvLyBMb2FkIGluIGVhY2ggdGhlIGRhdGFzZXRzXG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsLFxuICAgICAgICBlZGl0b3IgPSB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IsXG4gICAgICAgIHNlcnZlciA9IHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlcjtcbiAgICBsZXQgaW1wb3J0cyA9IFtdO1xuICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGF0YXNldHMoKS5zcGxpdChcIixcIikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBpZiAobmFtZSAmJiAhKG5hbWUgaW4gQmxvY2tNaXJyb3JCbG9ja0VkaXRvci5FWFRSQV9UT09MUykpIHtcbiAgICAgICAgICAgIGltcG9ydHMucHVzaC5hcHBseShpbXBvcnRzLCB0aGlzLmltcG9ydERhdGFzZXQoc2x1ZyhuYW1lKSwgbmFtZSwgc2lsZW50bHkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2hlbiBkYXRhc2V0cyBhcmUgbG9hZGVkLCB1cGRhdGUgdGhlIHRvb2xib3guXG4gICAgJC53aGVuLmFwcGx5KCQsIGltcG9ydHMpLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVFJJR0dFUkVEXCIpO1xuICAgICAgICBlZGl0b3IuYm0uZm9yY2VCbG9ja1JlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmVyLmZpbmFsaXplU3Vic2NyaXB0aW9ucygpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGUgZGVmaW5pdGlvbnMgZm9yIGEgZGF0YXNldCBpbnRvIHRoZSBlbnZpcm9ubWVudCwgaW5jbHVkaW5nXG4gKiB0aGUgZGF0YXNldCAoYXMgYSBKUyBmaWxlKSwgdGhlIHNrdWxwdCBiaW5kaW5ncywgYW5kIHRoZSBibG9ja2x5XG4gKiBiaW5kaW5ncy4gVGhpcyByZXF1aXJlcyBhY2Nlc3MgdG8gYSBDT1JHSVMgc2VydmVyLCBhbmQgb2NjdXJzXG4gKiBhc3luY2hyb25vdXNseS4gVGhlIHJlcXVlc3RzIGFyZSBmaXJlZCBhbmQgdGhlaXIgZGVmZXJyZWQgb2JqZWN0c1xuICogYXJlIHJldHVybmVkIC0gY2FsbGVycyBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gcGVyZm9ybSBhbiBhY3Rpb25cbiAqIG9uIGNvbXBsZXRpb24gb2YgdGhlIGltcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2x1ZyAtIFRoZSBVUkwgc2FmZSB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHVzZXItZnJpZW5kbHkgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lLlxuICogQHJldHVybnMge0FycmF5LjxEZWZlcnJlZD59IC0gUmV0dXJucyB0aGUgYXN5bmMgcmVxdWVzdHMgYXMgZGVmZXJyZWQgb2JqZWN0cy5cbiAqL1xuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUuaW1wb3J0RGF0YXNldCA9IGZ1bmN0aW9uIChzbHVnLCBuYW1lKSB7XG4gICAgbGV0IHVybF9yZXRyaWV2YWxzID0gW107XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cyArIFwiYmxvY2tweS9cIiArIHNsdWcgKyBcIi9cIiArIHNsdWc7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5wdXNoKG5hbWUpO1xuICAgICAgICAvLyBBY3R1YWxseSBnZXQgZGF0YVxuICAgICAgICBsZXQgZ2V0RGF0YXNldCA9ICQuZ2V0U2NyaXB0KHJvb3QgKyBcIl9kYXRhc2V0LmpzXCIpO1xuICAgICAgICAvLyBMb2FkIGdldENvbXBsZXRlIHNpbGVudGx5IGluIHRoZSBiYWNrZ3JvdW5kIGJlY2F1c2UgaXRzIGJpZyA6KFxuICAgICAgICBsZXQgZ2V0Q29tcGxldGUgPSAkLmdldFNjcmlwdChyb290ICsgXCJfY29tcGxldGUuanNcIik7XG4gICAgICAgIGxldCBnZXRTa3VscHQgPSAkLmdldChyb290ICsgXCJfc2t1bHB0LmpzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtcInNyYy9saWIvXCIgKyBzbHVnICsgXCIvX19pbml0X18uanNcIl0gPSBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGdldEJsb2NrbHkgPSAkLmdldFNjcmlwdChyb290ICsgXCJfYmxvY2tseS5qc1wiKTtcbiAgICAgICAgLy8gT24gY29tcGxldGlvbiwgdXBkYXRlIG1lbnVzLlxuICAgICAgICAkLndoZW4oZ2V0RGF0YXNldCwgZ2V0U2t1bHB0LCBnZXRCbG9ja2x5KS5kb25lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkRGF0YXNldHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0VG9CbG9ja3MuaGlkZGVuSW1wb3J0cy5wdXNoKHNsdWcpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubG9hZGluZ0RhdGFzZXRzLnJlbW92ZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVybF9yZXRyaWV2YWxzLnB1c2goZ2V0RGF0YXNldCwgZ2V0U2t1bHB0LCBnZXRCbG9ja2x5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVybF9yZXRyaWV2YWxzO1xufTtcblxuLyoqXG4gKiBPcGVucyBhIGRpYWxvZyBib3ggdG8gcHJlc2VudCB0aGUgdXNlciB3aXRoIHRoZSBkYXRhc2V0cyBhdmFpbGFibGVcbiAqIHRocm91Z2ggdGhlIENPUkdJUyBzZXJ2ZXIuIFRoaXMgcmVxdWlyZXMgYSBjYWxsLCBzbyB0aGlzIG1ldGhvZFxuICogY29tcGxldGVzIGFzeW5jaHJvbm91c2x5LiBUaGUgZGlhbG9nIGlzIGNvbXBvc2VkIG9mIGEgdGFibGUgd2l0aFxuICogYnV0dG9ucyB0byBsb2FkIHRoZSBkYXRhc2V0cyAoTW9yZSB0aGFuIG9uZSBkYXRhc2V0IGNhbiBiZSBsb2FkZWRcbiAqIGZyb20gd2l0aGluIHRoZSBkaWFsb2cgYXQgYSB0aW1lKS5cbiAqL1xuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwiaW1wb3J0RGF0YXNldHNcIikpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzLmltcG9ydERhdGFzZXRzO1xuICAgICAgICAkLmdldEpTT04ocm9vdCArIFwiaW5kZXguanNvblwiLCAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2UgdXAgdGhlIEJvZHlcbiAgICAgICAgICAgIGxldCBkYXRhc2V0cyA9IGRhdGEuYmxvY2tweTtcbiAgICAgICAgICAgIGxldCBkb2N1bWVudGF0aW9uID0gcm9vdCtcImJsb2NrcHkvaW5kZXguaHRtbFwiO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJChgPHA+RG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQgPGEgaHJlZj0nJHtkb2N1bWVudGF0aW9ufScgdGFyZ2V0PV9ibGFuaz51cmw8L2E+PC9wPmApO1xuICAgICAgICAgICAgbGV0IGJvZHkgPSAkKFwiPHRhYmxlPjwvdGFibGU+XCIsIHtcImNsYXNzXCI6IFwidGFibGUgdGFibGUtYm9yZGVyZWQgdGFibGUtc20gdGFibGUtc3RyaXBlZFwifSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhc2V0cykuc29ydCgpLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzbHVnZ2VkTmFtZSA9IHNsdWcoZGF0YXNldHNbbmFtZV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGJ0biA9ICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgZGF0YS10b2dnbGU9XCJidXR0b25cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiPkxvYWQ8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICBsZXQgaW1nU3JjID0gcm9vdCtcIi4uL2ltYWdlcy9kYXRhc2V0cy9cIituYW1lK1wiLWljb24ucG5nXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkRGF0YXNldHMuaW5kZXhPZihzbHVnZ2VkTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRCdXR0b25Mb2FkZWQoYnRuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidG4uY2xpY2soICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0RGF0YXNldChzbHVnZ2VkTmFtZSwgXCJEYXRhIC0gXCIgKyBkYXRhc2V0c1tuYW1lXS50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCdXR0b25Mb2FkZWQoYnRuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vbGV0IGltZyA9IGA8aW1nIHNyYz0nJHtpbWdTcmN9JyBjbGFzcz1cImNvcmdpcy1pY29uXCI+YDtcbiAgICAgICAgICAgICAgICAkKFwiPHRyPjwvdHI+XCIpXG4gICAgICAgICAgICAgICAgICAgIC8vLmFwcGVuZCgkKFwiPHRkPlwiICsgaW1nICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+XCIgKyBkYXRhc2V0c1tuYW1lXS5vdmVydmlldyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD48L3RkPlwiKS5hcHBlbmQoYnRuKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGJvZHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZFRvKHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIFNob3cgdGhlIGFjdHVhbCBkaWFsb2dcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5zaG93KFwiSW1wb3J0IERhdGFzZXRzXCIsIHN0YXJ0LCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTY2NDY0ODYyMDUzNFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9hY2JhcnQvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNjY0NjQ4NjIwNTE2XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL2FjYmFydC9Qcm9qZWN0cy9ibG9ja3B5LWVkdS9ibG9ja3B5L25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi4uL1wiLFwiaG1yXCI6dHJ1ZSxcImxvY2Fsc1wiOmZhbHNlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIG1vZHVsZS5ob3QuYWNjZXB0KHVuZGVmaW5lZCwgY3NzUmVsb2FkKTtcbiAgICB9XG4gICIsIi8vIFRPRE86IER5YW5taWNhbGx5IHBvcHVsYXRlIGFyaWEtbGFiZWxsZWRieSBpbiB0aGlzIGFuZCBvdGhlciBwbGFjZXNcblxuZXhwb3J0IGxldCBESUFMT0dfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LWRpYWxvZyBtb2RhbCBoaWRkZW4nXG4gICAgICAgICByb2xlPVwiZGlhbG9nXCJcbiAgICAgICAgIGFyaWEtbGFiZWw9J0RpYWxvZydcbiAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1kaWFsb2cgbW9kYWwtbGcnIHJvbGU9XCJkb2N1bWVudFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtY29udGVudCcgcm9sZT0ncmVnaW9uJyBhcmlhLWxhYmVsPSdEaWFsb2cgY29udGVudCc+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtaGVhZGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPSdtb2RhbC10aXRsZSc+RHluYW1pYyBDb250ZW50PC9oND5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdjbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCcgYXJpYS1oaWRkZW49J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtYm9keScgc3R5bGU9J21heC13aWR0aDoxMDAlOyBtYXgtaGVpZ2h0OjQwMHB4Jz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1mb290ZXInPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUgbW9kYWwtY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPkNsb3NlPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1zdWNjZXNzIG1vZGFsLW9rYXknIGRhdGEtZGlzbWlzcz0nbW9kYWwnPk9rYXk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gICAgXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5gO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBvYmplY3QgZm9yIHF1aWNrbHkgYW5kIGNvbnZlbmllbnRseSBnZW5lcmF0aW5nIGRpYWxvZyBib3hlcy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoaXMgZG9lc24ndCBkeW5hbWljYWxseSBjcmVhdGUgbmV3IGJveGVzOyBpdCByZXVzZXMgdGhlIHNhbWUgb25lXG4gKiBvdmVyIGFuZCBvdmVyIGFnYWluLiBJdCB0dXJucyBvdXQgZHluYW1pY2FsbHkgZ2VuZXJhdGluZyBuZXcgZGlhbG9nIGJveGVzXG4gKiBpcyBhIHBhaW4hIFNvIHdlIGNhbid0IHN0YWNrIHRoZW0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeURpYWxvZ31cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5RGlhbG9nKG1haW4sIHRhZykge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICB0aGlzLnRpdGxlVGFnID0gdGFnLmZpbmQoXCIubW9kYWwtdGl0bGVcIik7XG4gICAgdGhpcy5ib2R5VGFnID0gdGFnLmZpbmQoXCIubW9kYWwtYm9keVwiKTtcbiAgICB0aGlzLmZvb3RlclRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLWZvb3RlclwiKTtcbiAgICB0aGlzLm9rYXlCdXR0b24gPSB0YWcuZmluZChcIi5tb2RhbC1va2F5XCIpO1xuICAgIHRoaXMuY2xvc2VCdXR0b24gPSB0YWcuZmluZChcIi5tb2RhbC1jbG9zZVwiKTtcblxuICAgIHRoaXMueWVzID0gKCkgPT4ge307XG4gICAgdGhpcy5ubyA9ICgpID0+IHt9O1xuICAgIHRoaXMub2theUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMueWVzKCk7XG4gICAgICAgIHRoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ubygpO1xuICAgICAgICAvL3RoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbiAgICB9KTtcbn1cblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBleHRlcm5hbGx5IGF2YWlsYWJsZSBmdW5jdGlvbiBmb3IgcG9wcGluZyB1cCBhIGRpYWxvZ1xuICogbWVzc2FnZS4gVGhpcyBtZW51IHdpbGwgYmUgZHJhZ2dhYmxlIGJ5IGl0cyB0aXRsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIG1lc3NhZ2UgZGlhbG9nLiBDYW4gaGF2ZSBIVE1MLlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbWVzc2FnZSBkaWFsb2cuIENhbiBoYXZlIEhUTUwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmNsb3NlIC0gQSBmdW5jdGlvbiB0byBiZSBydW4gd2hlbiB0aGUgdXNlciBjbG9zZXMgdGhlIGRpYWxvZy5cbiAqL1xuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICh0aXRsZSwgYm9keSwgb25jbG9zZSkge1xuICAgIHRoaXMudGl0bGVUYWcuaHRtbCh0aXRsZSk7XG4gICAgdGhpcy5ib2R5VGFnLmh0bWwoYm9keSk7XG4gICAgdGhpcy50YWcubW9kYWwoXCJzaG93XCIpO1xuICAgIHRoaXMub2theUJ1dHRvbi5oaWRlKCk7XG4gICAgdGhpcy50YWcuZHJhZ2dhYmxlKHtcbiAgICAgICAgXCJoYW5kbGVcIjogXCIubW9kYWwtdGl0bGVcIlxuICAgIH0pO1xuXG4gICAgdGhpcy50YWcub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG9uY2xvc2UgIT09IHVuZGVmaW5lZCAmJiBvbmNsb3NlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiAodGl0bGUsIGJvZHksIHllcywgbm8sIHllc1RleHQpIHtcbiAgICBpZiAoeWVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHllc1RleHQgPSBcIk9rYXlcIjtcbiAgICB9XG4gICAgdGhpcy5zaG93KHRpdGxlLCBib2R5LCBubyk7XG4gICAgdGhpcy55ZXMgPSB5ZXM7XG4gICAgdGhpcy5ubyA9IG5vO1xuICAgIHRoaXMub2theUJ1dHRvbi5zaG93KCkuaHRtbCh5ZXNUZXh0KTtcbiAgICAvLyBUT0RPOiBhZGQgb2theSBidXR0b24gYW5kIGNhbmNlbCBidXR0b25cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkFTU0lHTk1FTlRfVkVSU0lPTl9DSEFOR0VEID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29uZmlybShcIkFzc2lnbm1lbnQgQ2hhbmdlZFwiLCBcIllvdXIgaW5zdHJ1Y3RvciBoYXMgbWFkZSBjaGFuZ2VzIHRvIHRoaXMgYXNzaWdubWVudC4gV291bGQgeW91IGxpa2UgdG8gcmVsb2FkPyBBbGwgeW91ciB3b3JrIGhhcyBiZWVuIHNhdmVkLlwiLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgQXNzaWdubWVudFwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBhc3NpZ25tZW50Ljxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgTGlzdGluZyBVcGxvYWRlZCBGaWxlc1wiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsaXN0aW5nIHRoZSB1cGxvYWRlZCBmaWxlcy48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9VUExPQURJTkdfRklMRSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBVcGxvYWRlZCBGaWxlXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwbG9hZGluZyB0aGUgZmlsZS48YnI+XG5QbGVhc2UgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfU0FWSU5HX0FTU0lHTk1ORU5UID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFNhdmluZyBBc3NpZ25tZW50XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHNhdmluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9TSE9XX1NUVURFTlRfRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLnNob3coXCJPcmlnaW5hbCBFcnJvclwiLCBgV2hlbiBJIHJhbiB5b3VyIGNvZGUsIEkgZW5jb3VudGVyZWQgYW4gZXJyb3I6XFxuXFxuPGRpdiBjbGFzcz1cImJsb2NrcHktZGlhbG9nLXN0dWRlbnQtZXJyb3ItbWVzc2FnZVwiPiR7ZXJyb3J9PC9kaXY+YCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5QT1NJVElWRV9GRUVEQkFDS19GVUxMID0gZnVuY3Rpb24gKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KHRpdGxlLCBtZXNzYWdlKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLlNDUkVFTlNIT1RfQkxPQ0tTID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE9cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFVwZGF0aW5nIFN1Ym1pc3Npb24gU3RhdHVzXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIHlvdXIgc3VibWlzc2lvbiBzdGF0dXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19ISVNUT1JZID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgSGlzdG9yeVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHlvdXIgaGlzdG9yeS48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5PRkZFUl9GT1JLID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzZXR1cFVybCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwO1xuICAgIHNldHVwVXJsID0gc2V0dXBVcmwgPyBgICg8YSBocmVmPVwiJHtzZXR1cFVybH1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5Ib3cgZG8gSSBkbyB0aGF0PzwvYT4pYCA6IFwiXCI7XG4gICAgdGhpcy5zaG93KFwiQXNzaWdubWVudCBOb3QgT3duZWQ7IEZvcms/XCIsIGBcbiAgICA8ZGl2IGNsYXNzPVwibWItNFwiPlxuICAgICAgICBJdCBsb29rcyBsaWtlIHlvdSB3YW50IHRvIGVkaXQgdGhpcyBhc3NpZ25tZW50LCBidXQgeW91IGFyZSBub3QgYW4gaW5zdHJ1Y3RvclxuICAgIG9yIGRlc2lnbmVyIGluIHRoZSBjb3Vyc2UgdGhhdCBvd25zIGl0IChcIkNvdXJzZSBOYW1lXCIpLiBXb3VsZCB5b3UgbGlrZSB0byBmb3JrXG4gICAgdGhpcyBhc3NpZ25tZW50IChvciBpdHMgZW50aXJlIGdyb3VwKSBzbyB0aGF0IHlvdSBjYW4gc2F2ZSB5b3VyIG1vZGlmaWNhdGlvbnM/XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgUmVtZW1iZXIgdG8gdXBkYXRlIHRoZSBMYXVuY2ggVVJMIGluIHRoZSBhc3NpZ25tZW50cycgc2V0dGluZ3Mgb24gQ2FudmFzISR7c2V0dXBVcmx9XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUnPkZvcmsgZW50aXJlIGFzc2lnbm1lbnQgZ3JvdXA8L2J1dHRvbj48L2Rpdj5cbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSc+Rm9yayBqdXN0IHRoaXMgYXNzaWdubWVudDwvYnV0dG9uPjwvZGl2PlxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLWRhbmdlcic+UmVzZXQgbXkgbG9jYWwgY2hhbmdlczwvYnV0dG9uPjwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICAgICAgICAgIG5hbWU9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+VHJhbnNmZXIgU3R1ZGVudCBTdWJtaXNzaW9ucyBmb3IgdGhpcyBjb3Vyc2U8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgPGxhYmVsIGNsYXNzPVwiZm9ybS10ZXh0XCIgZm9yPVwiYmxvY2tweS1jb3Vyc2UtaWRcIj5OZXcgb3duaW5nIGNvdXJzZSBpZDogPC9sYWJlbD5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImJsb2NrcHktY291cnNlLWlkXCIgdmFsdWU9XCIke3RoaXMubWFpbi5tb2RlbC51c2VyLmNvdXJzZUlkKCl9XCI+XG4gICAgPC9kaXY+XG4gICAgYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FRElUX0lOUFVUUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgaW5wdXRUZXh0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIik7XG4gICAgbGV0IGNsZWFySW5wdXRzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoKSA/IFwiXCIgOiBcImNoZWNrZWRcIjtcbiAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hlY2tlZCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIikucHJvcChcImNoZWNrZWRcIik7XG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktaW5wdXQtbGlzdFwiKS52YWwoKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoIWNoZWNrZWQpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KGlucHV0cyk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpcm0oXCJFZGl0IFJlbWVtYmVyZWQgSW5wdXRzXCIsIGBcblxuPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzIGZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICBuYW1lPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIiAke2NsZWFySW5wdXRzfT5cbjxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiPlJldXNlIGlucHV0cyBmb3IgbmV4dCBleGVjdXRpb248L2xhYmVsPlxuPC9kaXY+XG5cbjx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktaW5wdXQtbGlzdCBmb3JtLWNvbnRyb2xcIiByb3dzPVwiNFwiPiR7aW5wdXRUZXh0fTwvdGV4dGFyZWE+PGJyPlxuRWRpdCB0aGUgaW5wdXRzIGFib3ZlIHRvIHN0b3JlIGFuZCByZXVzZSB0aGVtIGFjcm9zcyBtdWx0aXBsZSBleGVjdXRpb25zLlxuRWFjaCBpbnB1dCBzaG91bGQgYmUgcHV0IG9uIGl0cyBvd24gbGluZS5cbllvdSBkbyBub3QgbmVlZCBxdW90ZXM7IHRoZSB0ZXh0IHdpbGwgYmUgZW50ZXJlZCBsaXRlcmFsbHkuXG4gXG5gLCB5ZXMsIHRoaXMubm8sIFwiU2F2ZVwiKTtcbiAgICAvLyBUT0RPOiBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgdGhlIGluZmluaXRlIHN0cmluZyB0byBrZWVwIGdpdmluZyB3aGVuIHRoZSBvdGhlcnMgcnVuIG91dFxufTsiLCJpbXBvcnQge0VkaXRvcnN9IGZyb20gXCIuLi9lZGl0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRGaWxlKG1vZGVsLCBldmVudCkge1xuICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoZSA9PlxuICAgICAgICBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS51cGxvYWRGaWxlKGUpXG4gICAgKTtcbiAgICBmaWxlUmVhZGVyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbHVnZ2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQge25hbWUsIGV4dGVuc2lvbiwgY29udGVudHMsIG1pbWV0eXBlfSA9IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpLmRvd25sb2FkRmlsZSgpO1xuICAgIC8vIE1ha2Ugc2FmZVxuICAgIG5hbWUgPSBzbHVnZ2lmeShuYW1lKTtcbiAgICBuYW1lID0gbmFtZSArIGV4dGVuc2lvbjtcbiAgICAvLyBNYWtlIHRoZSBkYXRhIGRvd25sb2FkIGFzIGEgZmlsZVxuICAgIGxldCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRzXSwge3R5cGU6IG1pbWV0eXBlfSk7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgfSBlbHNle1xuICAgICAgICBsZXQgdGVtcG9yYXJ5RG93bmxvYWRMaW5rID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuZG93bmxvYWQgPSBuYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0gPSBtYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcihcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICBvbkZpbGVEZWxldGVkKCkge1xuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIGZpbGUgaW5zdGVhZCBvZiBhIGRlZmF1bHQgZmlsZVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlVXBkYXRlZChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSB0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcih0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2tDdXJyZW50RmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLndhdGNoRmlsZSh0aGlzLmZpbGVuYW1lLCB7XG4gICAgICAgICAgICB1cGRhdGVkOiB0aGlzLm9uRmlsZVVwZGF0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRoaXMub25GaWxlRGVsZXRlZC5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG5ld0ZpbGVuYW1lO1xuICAgICAgICB0aGlzLmZpbGUgPSB0aGlzLmZpbGVTeXN0ZW0uZ2V0RmlsZShuZXdGaWxlbmFtZSk7XG4gICAgICAgIHRoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0ZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIHRoYXQgdGhlIG90aGVyIGVkaXRvciB3aWxsIGJlIHN3aXRjaGluZyB0b1xuICAgICAqIEBwYXJhbSBvbGRFZGl0b3JcbiAgICAgKiBAcGFyYW0gbmV3RWRpdG9yXG4gICAgICovXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZXZlbnQudGFyZ2V0LmZpbGVOYW1lO1xuICAgICAgICBsZXQgY29udGVudHMgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZEZpbGUoKSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLm5hbWUsXG4gICAgICAgICAgICBleHRlbnNpb246IGZpbGVuYW1lLnR5cGUsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5maWxlLmhhbmRsZSgpLFxuICAgICAgICAgICAgbWltZXR5cGU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH07XG4gICAgfVxufSIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCIuL3B5dGhvblwiO1xuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTID0gW1xuICAgIFtcInRvb2xib3hcIiwgXCJ0b29sYm94XCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIldoaWNoIHZlcnNpb24gb2YgdGhlIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlci5cIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVcIiwgXCJibG9ja3B5XCIsIFwidHlwZVwiLCBcIlRoZSB0eXBlIG9mIHF1ZXN0aW9uOyBCbG9ja1B5IHByb2dyYW1taW5nIHByb2JsZW1zIGFyZSB0aGUgZGVmYXVsdCwgYnV0IHdlIGFsc28gc3VwcG9ydCBzdGF0aWMgcmVhZGluZ3MsIHF1aXogcXVlc3Rpb25zLCBhbmQgYSBNYXplIGdhbWUuXCJdLFxuICAgIFtcInBhc3Njb2RlXCIsIFwicGFzc2NvZGVcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJBIHN0cmluZyB0aGF0IHRoZSB1c2VyIG11c3QgZW50ZXIgdG8gYWNjZXNzIHRoZSBwcm9ibGVtLiBJZiBibGFuaywgdGhlbiBubyBwYXNzY29kZSBpcyBwcm9tcHRlZC5cIl0sXG4gICAgLy9bXCJ0b29sYm94TGV2ZWxcIiwgXCJ0b29sYm94X2xldmVsXCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIklOQ09NUExFVEU6IFdoYXQgbGV2ZWwgb2YgdG9vbGJveCB0byBwcmVzZW50IHRvIHRoZSB1c2VyIChoaWRpbmcgYW5kIHNob3dpbmcgY2F0ZWdvcmllcykuXCJdLFxuICAgIFtcInN0YXJ0Vmlld1wiLCBcInN0YXJ0X3ZpZXdcIiwgRGlzcGxheU1vZGVzLlRFWFQsIERpc3BsYXlNb2RlcywgXCJUaGUgUHl0aG9uIGVkaXRvciBtb2RlIHRvIHN0YXJ0IGluIHdoZW4gdGhlIHN0dWRlbnQgc3RhcnRzIHRoZSBwcm9ibGVtLlwiXSxcbiAgICBbXCJkYXRhc2V0c1wiLCBcImRhdGFzZXRzXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiVGhlIGN1cnJlbnQgbGlzdCBvZiBkYXRhc2V0cyBhdmFpbGFibGUgb24gbG9hZCBhcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcuXCJdLFxuICAgIFtcImRpc2FibGVUaW1lb3V0XCIsIFwiZGlzYWJsZV90aW1lb3V0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNvZGUgaXMgYWxsb3dlZCB0byBydW4gd2l0aG91dCB0aW1lb3V0cyAocG90ZW50aWFsbHkgYWxsb3dpbmcgaW5maW5pdGUgbG9vcHMpLlwiXSxcbiAgICBbXCJwYXJ0SWRcIiwgXCJwYXJ0X2lkXCIsIFwiXCIsIFwic3RyaW5nXCIsIFwiVGhlIFBhcnQgSUQgb2YgYW4gQXNzaWdubWVudCB0aGF0IHRoaXMgZWRpdG9yIGlzIHJlc3BvbnNpYmxlIGZvci4gQXNzaWdubWVudHMgY2FuIGhhdmUgcmVnaW9ucyAoXFxcIlBhcnRzXFxcIikgdGhhdCBiZWhhdmUgaW5kZXBlbmRlbnRseSB0byB0aGUgdXNlciBidXQgYWxsIGNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgYXNzaWdubWVudCBvbiB0aGUgYmFja2VuZC4gQmxhbmsgY29ycmVzcG9uZHMgdG8gdGhlIGZ1bGwgZG9jdW1lbnQuIE5vdGUgdGhhdCBtb3N0IGFzc2lnbm1lbnQgc2V0dGluZ3Mgd2lsbCBhcHBseSBVTklWRVJTQUxMWSBhY3Jvc3MgYWxsIHBhcnRzLCBpbmNsdWRpbmcgdGhlIG9uX3J1bi5weSBhbmQgdGhlIG90aGVyIHNldHRpbmdzIG9uIHRoaXMgcGFnZS5cIl0sXG4gICAgW1wiaXNQYXJzb25zXCIsIFwiaXNfcGFyc29uc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGlzIGlzIGEgcGFyc29uJ3Mgc3R5bGUgcXVlc3Rpb24gKGp1bWJsZWQpLlwiXSxcbiAgICBbXCJzYXZlVHVydGxlT3V0cHV0XCIsIFwic2F2ZV90dXJ0bGVfb3V0cHV0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHR1cnRsZSAoYW5kIHB5Z2FtZSkgb3V0cHV0IGlzIHNhdmVkIHdoZW5ldmVyIHRoZSBwcm9ncmFtIHVzZXMgaXQuXCJdLFxuICAgIFtcImRpc2FibGVGZWVkYmFja1wiLCBcImRpc2FibGVfZmVlZGJhY2tcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gbm8gaW5zdHJ1Y3RvciBzY3JpcHRzIGFyZSBydW4gKGUuZy4sIG9uX3J1biBhbmQgb25fZXZhbCkuXCJdLFxuICAgIFtcImRpc2FibGVJbnN0cnVjdG9yUnVuXCIsIFwiZGlzYWJsZV9pbnN0cnVjdG9yX3J1blwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW5zdHJ1Y3RvciBvbl9ydW4gd2lsbCBub3QgYXV0b21hdGljYWxseSBydW4gdGhlIHN0dWRlbnRzJyBjb2RlLiBUaGlzIHN0aWxsIHJ1bnMgdGhlIHN0dWRlbnRzJyBjb2RlIG9uY2UgYmVmb3JlaGFuZCwgYnV0IHRoZSBvdXRwdXQvZGF0YSB3aWxsIG5vdCBiZSBhdmFpbGFibGUgdG8gdGhlIGluc3RydWN0b3IncyBvbl9ydW4ucHkgc2NyaXB0LlwiXSxcbiAgICBbXCJkaXNhYmxlU3R1ZGVudFJ1blwiLCBcImRpc2FibGVfc3R1ZGVudF9ydW5cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHJ1biBidXR0b24gbm8gbG9uZ2VyIHJ1biB0aGUgc3R1ZGVudHMnIGNvZGUuIFRoaXMgc3RpbGwgcnVucyB0aGUgaW5zdHJ1Y3RvcidzIGZlZWRiYWNrIG9uX3J1biBzY3JpcHQuXCJdLFxuICAgIFtcImRpc2FibGVUaWZhXCIsIFwiZGlzYWJsZV90aWZhXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIGRvIG5vdCBhdXRvbWF0aWNhbGx5IHJ1biBUaWZhICh3aGljaCBjYW4gYmUgc2xvdykuXCJdLFxuICAgIFtcImRpc2FibGVUcmFjZVwiLCBcImRpc2FibGVfdHJhY2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNvZGUgd2lsbCBub3QgaGF2ZSBpdHMgZXhlY3V0aW9uIHRyYWNlZCAobm8gdmFyaWFibGVzIHJlY29yZGVkLCBubyBjb3ZlcmFnZSB0cmFja2VkKS5cIl0sXG4gICAgW1wiZGlzYWJsZUVkaXRcIiwgXCJkaXNhYmxlX2VkaXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzJyBmaWxlIHdpbGwgbm90IGJlIGVkaXRhYmxlLlwiXSxcbiAgICBbXCJlbmFibGVJbWFnZXNcIiwgXCJjYW5faW1hZ2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdXNlcnMgY2FuIGNvcHkvcGFzdGUgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIHRleHQgZWRpdG9yLlwiXSxcbiAgICBbXCJlbmFibGVCbG9ja3NcIiwgXCJjYW5fYmxvY2tzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnQgY2FuIGVkaXQgdGhlIGJsb2NrIGludGVyZmFjZSAoaWYgbm90LCB0aGVuIGl0IGlzIHZpc2libGUgYnV0IG5vdCBlZGl0YWJsZSkuXCJdLFxuICAgIFtcImNhbkNsb3NlXCIsIFwiY2FuX2Nsb3NlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IHNob3VsZCBtYXJrIHRoZWlyIHN1Ym1pc3Npb24gY2xvc2VkIHdoZW4gdGhleSBhcmUgZG9uZS4gVGhlcmUgaXMgbm8gd2F5IHRvIGZvcmNlIGEgc3R1ZGVudCB0byBkbyBzby4gVW5saWtlIFJldmlld2VkLCB0aGlzIHN0aWxsIHN1Ym1pdHMgdGhlIGNvcnJlY3RuZXNzLlwiXSxcbiAgICBbXCJvbmx5SW50ZXJhY3RpdmVcIiwgXCJvbmx5X2ludGVyYWN0aXZlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGUgZWRpdG9ycyBhcmUgaGlkZGVuLCB0aGUgcHJvZ3JhbSBpcyBhdXRvbWF0aWNhbGx5IHJ1biwgYW5kIHRoZW4gdGhlIGNvbnNvbGUgZW50ZXJzIEV2YWwgbW9kZSAoaW50ZXJhY3RpdmUpLlwiXSxcbiAgICBbXCJvbmx5VXBsb2Fkc1wiLCBcIm9ubHlfdXBsb2Fkc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZGlyZWN0bHkgZWRpdGFibGUgKHRoZXkgd2lsbCBoYXZlIHRvIHVwbG9hZCBzdWJtaXNzaW9ucykuXCJdLFxuICAgIC8vIFdoYXQgbWVudXMvZmVlZGJhY2sgdG8gc2hvdyBhbmQgaGlkZVxuICAgIFtcImhpZGVTdWJtaXNzaW9uXCIsIFwiaGlkZV9zdWJtaXNzaW9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIHN1Ym1pc3Npb24ncyBjb2RlIG9yIGhpc3Rvcnkgb24gQ2FudmFzLlwiXSxcbiAgICBbXCJoaWRlRmlsZXNcIiwgXCJoaWRlX2ZpbGVzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgd2lsbCBub3Qgc2VlIHRoZSBWaWV3IEZpbGVzIHRvb2xiYXIuXCJdLFxuICAgIFtcImhpZGVRdWV1ZWRJbnB1dHNcIiwgXCJoaWRlX3F1ZXVlZF9pbnB1dHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNhbm5vdCBhY2Nlc3MgdGhlIHF1ZXVlZCBpbnB1dHMgYm94IChtYWtlcyByZXBlYXRlZCBkZWJ1Z2dpbmcgZWFzaWVyIGZvciB0aGUgaW5wdXQgZnVuY3Rpb24pLlwiXSxcbiAgICBbXCJoaWRlRWRpdG9yc1wiLCBcImhpZGVfZWRpdG9yc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhbGwgb2YgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZU1pZGRsZVBhbmVsXCIsIFwiaGlkZV9taWRkbGVfcGFuZWxcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGNvbnNvbGUgYW5kIGZlZWRiYWNrIGFyZWFzIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUFsbFwiLCBcImhpZGVfYWxsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCB0aGVuIHRoZSBlbnRpcmUgaW50ZXJmYWNlIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUV2YWx1YXRlXCIsIFwiaGlkZV9ldmFsdWF0ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgRXZhbHVhdGUgYnV0dG9uIGlzIG5vdCBzaG93biBvbiB0aGUgY29uc29sZS5cIl0sXG4gICAgW1wiaGlkZUltcG9ydERhdGFzZXRzQnV0dG9uXCIsIFwiaGlkZV9pbXBvcnRfZGF0YXNldHNfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNhbm5vdCBzZWUgdGhlIGltcG9ydCBkYXRhc2V0cyBidXR0b24uXCJdLFxuICAgIC8vIFRPRE86IEZpeCB0aGlzIG9uZSB0byBiZSBzZXR0YWJsZVxuICAgIFtcImhpZGVJbXBvcnRTdGF0ZW1lbnRzXCIsIFwiaGlkZV9pbXBvcnRfc3RhdGVtZW50c1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgY2VydGFpbiBraW5kcyBvZiBpbXBvcnQgc3RhdGVtZW50cyAobWF0cGxvdGxpYiwgdHVydGxlLCBkYXRhc2V0cykgYXJlIG5vdCBzaG93biBpbiB0aGUgYmxvY2sgaW50ZXJmYWNlLlwiXSxcbiAgICBbXCJoaWRlQ292ZXJhZ2VCdXR0b25cIiwgXCJoaWRlX2NvdmVyYWdlX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlIGNvdmVyYWdlIGJ1dHRvbiBpcyBub3Qgc2hvd24uXCJdLFxuICAgIFtcImhpZGVUcmFjZUJ1dHRvblwiLCBcImhpZGVfdHJhY2VfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBUcmFjZSBidXR0b24gaXMgbm90IHNob3duLlwiXSxcbiAgICBbXCJzbWFsbExheW91dFwiLCBcInNtYWxsX2xheW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW50ZXJmYWNlIGZpdHMgaW50byBhIHNtYWxsZXIgcmVnaW9uLlwiXSxcbiAgICBbXCJoYXNDbG9ja1wiLCBcImhhc19jbG9ja1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhIGNsb2NrIGlzIHNob3duIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyLlwiXSxcbl07XG5cbmV4cG9ydCBsZXQgQXNzaWdtZW50VHlwZSA9IHtcbiAgICBCTE9DS1BZOiBcImJsb2NrcHlcIixcbiAgICBNQVpFOiBcIm1hemVcIixcbiAgICBRVUlaOiBcInF1aXpcIixcbiAgICBSRUFESU5HOiBcInJlYWRpbmdcIlxufTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRhdGlvbihuYW1lKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgQVNTSUdOTUVOVF9TRVRUSU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQVNTSUdOTUVOVF9TRVRUSU5HU1tpXVswXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiRG9jdW1lbnRhdGlvbiBub3QgZm91bmQgZm9yIGZpZWxkXCI7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdGFydFZpZXdUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0VmlldygpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGFzc2lnbm1lbnQuc2V0dGluZ3Muc3RhcnRWaWV3LmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktc3RhcnQtdmlldy1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwgPSBBU1NJR05NRU5UX1NFVFRJTkdTXG4gICAgLy8gT25seSBoYW5kbGUgdGhlIHNpbXBsZSBib29sZWFucyB0aGlzIHdheVxuICAgIC5maWx0ZXIoKHNldHRpbmcpID0+IHNldHRpbmdbM10gPT09IFwiYm9vbFwiKVxuICAgIC5tYXAoKHNldHRpbmcpID0+IHtcbiAgICAgICAgbGV0IHByZXR0eU5hbWUgPSBzZXR0aW5nWzFdLnNwbGl0KFwiX1wiKS5tYXAod29yZD0+KHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrd29yZC5zbGljZSgxKSkpLmpvaW4oXCIgXCIpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtJHtzZXR0aW5nWzBdfVwiPiR7cHJldHR5TmFtZX08L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnNldHRpbmdzLiR7c2V0dGluZ1swXX1cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke3NldHRpbmdbNF19XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9KS5qb2luKFwiXFxuXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS12aWV3LXNldHRpbmdzXCI+XG4gICAgXG4gICAgPGZvcm0+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEyIG14LWF1dG9cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc3VjY2Vzc1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnNldHRpbmdzLnNhdmVcIj5TYXZlIGNoYW5nZXM8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+TmFtZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLW5hbWVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50Lm5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgc3R1ZGVudC1mYWNpbmcgbmFtZSBvZiB0aGUgYXNzaWdubWVudC4gQXNzaWdubWVudHMgd2l0aGluIGEgZ3JvdXAgYXJlIG9yZGVyZWQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgYnkgdGhlaXIgbmFtZSwgc28geW91IG1heSB3YW50IHRvIHVzZSBhIG5hbWluZyBzY2hlbWUgbGlrZSBcIiM0My41KSBXaGF0ZXZlclwiLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlVSTDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudXJsXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIGNvdXJzZS11bmlxdWUgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uc2lzdGVudGx5IHJlZmVyIHRvIHRoaXMgYXNzaWdubWVudC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIj5QdWJsaWM6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnB1YmxpY1wiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIG5vdCBwdWJsaWMsIHVzZXJzIG91dHNpZGUgb2YgdGhlIGNvdXJzZSB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGUgYXNzaWdubWVudCBpbiBjb3Vyc2UgbGlzdGluZ3MuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIj5IaWRkZW46PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LmhpZGRlblwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIGhpZGRlbiwgc3R1ZGVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlaXIgZ3JhZGUgd2hpbGUgd29ya2luZyBvbiB0aGUgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXJldmlld2VkXCI+UmV2aWV3ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGFzc2lnbm1lbnQucmV2aWV3ZWRcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiByZXZpZXdlZCwgdGhlIGFzc2lnbm1lbnQgbmVlZCB0byBiZSBjb21tZW50ZWQgdXBvbiBhbmQgcmVncmFkZWQgYnkgdGhlIHN0YWZmIGFmdGVyIHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UG9pbnRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wb2ludHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnBvaW50c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoaXMgYXNzaWdubWVudCBpcyB3b3J0aDsgZGVmYXVsdHMgdG8gMSBwb2ludC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlN0YXJ0aW5nIFZpZXc6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiQmxvY2tzXCIsIFwidGgtbGFyZ2VcIiwgRGlzcGxheU1vZGVzLkJMT0NLKX1cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tN1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInN0YXJ0Vmlld1wiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5JUCBSYW5nZXM6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LmlwUmFuZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIElQIEFkZHJlc3NlcyB0aGF0IHdpbGwgYmUgZXhwbGljaXRseSBhbGxvd2VkLiBJZiBibGFuayxcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgYWRkcmVzc2VzIGFyZSBhbGxvd2VkLiBJZiBhbiBhZGRyZXNzIHN0YXJ0cyB3aXRoIDxjb2RlPl48L2NvZGU+IHRoZW4gaXQgaXQgaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3RlZCwgYnV0IHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdHVybiB3aXRoIGEgPGNvZGU+ITwvY29kZT4uIEFkZHJlc3NlcyBjYW4gYWxzb1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIGEgYml0IG1hc2sgdG8gYWxsb3cgYSByYW5nZSBvZiBhZGRyZXNzZXMuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcGFzc2NvZGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5QYXNzY29kZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5wYXNzY29kZVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInBhc3Njb2RlXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJlbG9hZGVkIERhdGFzZXRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtZGF0YXNldHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwiZGF0YXNldHNcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtdG9vbGJveFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPkJsb2NrIFRvb2xib3g6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94XCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm5vcm1hbFwiPk5vcm1hbCBUb29sYm94PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN0XCI+Q1RAVlQgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdDJcIj5DVEBWVCBUb29sYm94IFYyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1pbmltYWxcIj5NaW5pbWFsIFNldDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJmdWxsXCI+QWxsIEJsb2Nrczwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdXN0b21cIj5DdXN0b208L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJ0b29sYm94XCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5Qcm9ibGVtIFR5cGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC50eXBlXCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJsb2NrcHlcIj5CbG9ja1B5PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1hemVcIj5NYXplPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInF1aXpcIj5RdWl6IFF1ZXN0aW9uPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJlYWRpbmdcIj5SZWFkaW5nPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidHlwZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1wYXJ0LWlkXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UGFydCBJRDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXBhcnQtaWRcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBjb25maWd1cmF0aW9uLnBhcnRJZFwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInBhcnRJZFwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgJHtBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MfVxuICAgIDwvZm9ybT5cbiAgICBcbiAgICA8L2Rpdj5cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdO1xuICAgICAgICBsZXQgdmFsdWUgPSBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKCk7XG4gICAgICAgIC8vIE9ubHkgc3RvcmUgdGhpcyBzZXR0aW5nIGlmIGl0cyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFxuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgc2V0dGluZ3Nbc2VydmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQXNzaWdubWVudFNldHRpbmdzKG1vZGVsLCBzZXR0aW5ncykge1xuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3MpO1xuICAgICAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdO1xuICAgICAgICAgICAgaWYgKHNlcnZlck5hbWUgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKHNldHRpbmdzW3NlcnZlck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN0YXJ0X3ZpZXcpIHtcbiAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShzZXR0aW5ncy5zdGFydF92aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdLFxuICAgICAgICAgICAgZmllbGRUeXBlID0gc2V0dGluZ1szXTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2NsaWVudE5hbWVdID0ga28ub2JzZXJ2YWJsZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbmZpZ1ZhbHVlID0gY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc2V0dGluZ3MuXCIrc2VydmVyTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRUeXBlID09PSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1ZhbHVlID0gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoY29uZmlnVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5cbmNsYXNzIEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vVE9ETzogdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIC8vIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcblxuICAgICAgICAvL1RPRE86IHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gdXBkYXRlXG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IudmFsdWUoKSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBVcGRhdGVcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgQXNzaWdubWVudFNldHRpbmdzID0ge1xuICAgIG5hbWU6IFwiQXNzaWdubWVudCBTZXR0aW5nc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcsXG4gICAgdGVtcGxhdGU6IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUxcbn07IiwiXHJcblxyXG5leHBvcnQgY29uc3QgZGVmYXVsdF9oZWFkZXIgPSBgXHJcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi10b29sYmFyIGNvbC1tZC0xMiBidG4tdG9vbGJhclwiXHJcbiAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiUHl0aG9uIFRvb2xiYXJcIj5cclxuICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIj5cclxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcclxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcclxuICAgICAgICAgICAgICAgIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxyXG4gICAgICAgICA8L2xhYmVsPlxyXG5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXHJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxyXG4gICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXHJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXHJcbiAgICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgXHJcbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcclxuICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiLFxyXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcclxuICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgPC9kaXY+XHJcbiA8L2Rpdj5cclxuYDtcclxuIiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSU1BR0VfRURJVE9SX0hUTUwgPSBgXHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8aDM+QXZhaWxhYmxlIEltYWdlczwvaDM+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbWFnZXMucmVsb2FkSW1hZ2VzXCI+UmVsb2FkIEF2YWlsYWJsZSBJbWFnZXM8L2J1dHRvbj5cclxuICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5LnVwbG9hZGVkRmlsZXMoKSAhPT0gbnVsbCAtLT5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6IE9iamVjdC5rZXlzKGRpc3BsYXkudXBsb2FkZWRGaWxlcygpKSwgYXM6ICdwbGFjZW1lbnQnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZyBkYXRhLWJpbmQ9XCJ0ZXh0OiAkZGF0YVwiPjwvc3Ryb25nPjpcclxuICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6ICRyb290LmRpc3BsYXkudXBsb2FkZWRGaWxlcygpW3BsYWNlbWVudF0sIGFzOiAnZmlsZW5hbWUnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGZpbGVuYW1lWzBdXCI+PC9zcGFuPjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgZGF0YS1iaW5kPVwiYXR0cjogeyBzcmM6IGZpbGVuYW1lWzFdLCBhbHQ6IGZpbGVuYW1lWzFdIH1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMzBweFwiIGhlaWdodD1cIjMwcHhcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSW1hZ2VFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcblxyXG4gICAgICAgIGxldCB1cGxvYWRlZEZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudXBsb2FkZWRGaWxlcygpO1xyXG4gICAgICAgIGlmICh1cGxvYWRlZEZpbGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkSW1hZ2VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTsqL1xyXG4gICAgfVxyXG5cclxuICAgIHJlbG9hZEltYWdlcygpIHtcclxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubGlzdFVwbG9hZGVkRmlsZXMoKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS51cGxvYWRlZEZpbGVzKHJlc3BvbnNlLmZpbGVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZ3MuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyhyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICAvKnRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSW1hZ2VFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkltYWdlXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/aW1hZ2VzLmJsb2NrcHlcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogSW1hZ2VFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IElNQUdFX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSlNPTl9FRElUT1JfSFRNTCA9IGBcclxuICAgICR7ZGVmYXVsdF9oZWFkZXJ9XHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1qc29uXCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSnNvbkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLWpzb25cIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEpzb25FZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkpTT05cIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5qc29uXCJdLFxyXG4gICAgY29uc3RydWN0b3I6IEpzb25FZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IEpTT05fRURJVE9SX0hUTUxcclxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBNQVJLRE9XTl9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLW1hcmtkb3duXCI+PC90ZXh0YXJlYT4gICAgXG5gO1xuXG5cbmNsYXNzIE1hcmtkb3duRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5tZGUgPSBuZXcgRWFzeU1ERSh7XG4gICAgICAgICAgICBlbGVtZW50OiB0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1tYXJrZG93blwiKVswXSxcbiAgICAgICAgICAgIGF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIG1pbkhlaWdodDogXCIzMDBweFwiLFxuICAgICAgICAgICAgLy9zY3JvbGxiYXJTdHlsZTogXCJuYXRpdmVcIixcbiAgICAgICAgICAgIC8vIFRPRE86IGltYWdlVXBsb2FkRnVuY3Rpb25cbiAgICAgICAgICAgIHJlbmRlcmluZ0NvbmZpZzoge1xuICAgICAgICAgICAgICAgIGNvZGVTeW50YXhIaWdobGlnaHRpbmc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5tZGUuY29kZW1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZGUudmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMubWRlLnZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiTWFya2Rvd25cIixcbiAgICBleHRlbnNpb25zOiBbXCIubWRcIl0sXG4gICAgY29uc3RydWN0b3I6IE1hcmtkb3duRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogTUFSS0RPV05fRURJVE9SX0hUTUxcbn07IiwiLyoqXG4gKiBUT0RPOiByZW5hbWUgZmlsZXMsIG1hbnVhbCBzYXZlLCB0YWdzLCBzYW1wbGVfc3VibWlzc2lvbnMsIG9uX2V2YWwsIG5vbi1idWlsdGluIGZpbGVzXG4gKiBUT0RPOiBpbXBvcnQgZGF0YSwgaGlzdG9yeSwgcnVuLCB1cmxfZGF0YSwgYXNzaWdubWVudF9zZXR0aW5ncywgcGFyc29uc19tb2RlXG4gKiBUT0RPOiBkZWxldGUgYmVjb21lcyBcImNsZWFyXCIgZm9yIGluc3RydWN0b3IgZmlsZXNcbiAqL1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyfVxuICovXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yLCBzbHVnZ2lmeX0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0hJU1RPUllfVE9PTEJBUl9IVE1MfSBmcm9tIFwiLi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9IGZyb20gXCIuLi9pbnRlcmZhY2VcIjtcblxuZXhwb3J0IGxldCBEaXNwbGF5TW9kZXMgPSB7XG4gICAgQkxPQ0s6IFwiYmxvY2tcIixcbiAgICBTUExJVDogXCJzcGxpdFwiLFxuICAgIFRFWFQ6IFwidGV4dFwiXG59O1xuXG5mdW5jdGlvbiBtYWtlVGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICcke21vZGV9J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZWRpdG9ycy5weXRob24udXBkYXRlTW9kZS5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LW1vZGUtc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5leHBvcnQgY29uc3QgUFlUSE9OX0VESVRPUl9IVE1MID0gYFxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLXRvb2xiYXIgY29sLW1kLTEyIGJ0bi10b29sYmFyXCJcbiAgICAgICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlB5dGhvbiBUb29sYmFyXCI+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSdW4gR3JvdXBcIj4gICAgICAgICBcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJsb2NrcHktcnVuIG5vdHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmV4ZWN1dGUucnVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeydibG9ja3B5LXJ1bi1ydW5uaW5nJzogdWkuZXhlY3V0ZS5pc1J1bm5pbmd9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtcGxheVwiPjwvc3Bhbj4gPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuZXhlY3V0ZS5ydW5MYWJlbFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC10b2dnbGUgbXItMlwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiPlxuICAgICAgICAgICAgPCEtLSBrbyBpZjogJHJvb3QuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVCbG9ja3MoKSAtLT5cbiAgICAgICAgICAgICR7bWFrZVRhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJTcGxpdFwiLCBcImNvbHVtbnNcIiwgRGlzcGxheU1vZGVzLlNQTElUKX1cbiAgICAgICAgICAgICR7bWFrZVRhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSZXNldCBHcm91cFwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnJlc2V0XCI+XG4gICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXN5bmNcIj48L3NwYW4+IFJlc2V0XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0ga28gaWY6ICFhc3NpZ25tZW50LnNldHRpbmdzLmhpZGVJbXBvcnREYXRhc2V0c0J1dHRvbigpICYmICF1aS5zbWFsbExheW91dCgpLS0+XG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSW1wb3J0IEdyb3VwXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmltcG9ydERhdGFzZXRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1jbG91ZC1kb3dubG9hZC1hbHRcIj48L3NwYW4+IEltcG9ydCBkYXRhc2V0c1xuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5zbWFsbExheW91dFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS11cGxvYWRcIj48L3NwYW4+IFVwbG9hZFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJibG9ja3B5LXRvb2xiYXItdXBsb2FkXCIgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuZWRpdG9ycy51cGxvYWR9XCI+XG4gICAgICAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSGlzdG9yeSBHcm91cFwiIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi50b2dnbGVIaXN0b3J5TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdWkuZWRpdG9ycy5weXRob24uaXNIaXN0b3J5QXZhaWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7IGFjdGl2ZTogZGlzcGxheS5oaXN0b3J5TW9kZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjogeyAnYXJpYS1wcmVzc2VkJzogZGlzcGxheS5oaXN0b3J5TW9kZSB9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtaGlzdG9yeVwiPjwvc3Bhbj4gSGlzdG9yeVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0gRnVsbHkgZnVuY3Rpb25hbCwgYnV0IGEgbGl0dGxlIHRvby4uIEludmFzaXZlIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkZ1bGxzY3JlZW4gR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICd0ZXh0J1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uZnVsbHNjcmVlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWV4cGFuZC1hcnJvd3MtYWx0XCI+PC9zcGFuPiBGdWxsc2NyZWVuXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIC0tPlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiU2F2ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblNhdmVcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXNhdmVcIj48L3NwYW4+IFNhdmVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuRGVsZXRlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L3NwYW4+IERlbGV0ZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBkcm9wZG93bi10b2dnbGUgZHJvcGRvd24tdG9nZ2xlLXNwbGl0XCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWVsbGlwc2lzLXZcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiPlRvZ2dsZSBFeHRyYSBGZWF0dXJlczwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPSdkcm9wZG93bi1pdGVtIGJsb2NrcHktdG9vbGJhci1ydW4tcXVpZXRseSBub3RyYW5zaXRpb24nIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZXhlY3V0ZS5ydW5RdWlldGx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7J2Jsb2NrcHktcnVuLXJ1bm5pbmcnOiB1aS5leGVjdXRlLmlzUnVubmluZ31cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWNvbW1lbnQtc2xhc2hcIj48L3NwYW4+IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLmV4ZWN1dGUucnVuUXVpZXRseUxhYmVsXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgPCEtLTxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSZW5hbWUgR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy5jYW5SZW5hbWVcIj5cbiAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1maWxlLXNpZ25hdHVyZVwiPjwvc3Bhbj4gUmVuYW1lXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj4tLT5cbiAgICAgICAgIFxuICAgIDwvZGl2PlxuICAgIFxuICAgICR7SElTVE9SWV9UT09MQkFSX0hUTUx9XG5cblxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi1ibG9ja21pcnJvclwiXG4gICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkubWVudS5pc1N1Ym1pdHRlZFwiPlxuICAgIDwvZGl2PlxuYDtcblxuXG5cbmZ1bmN0aW9uIGNvbnZlcnRJcHluYlRvUHl0aG9uKGNvZGUpIHtcbiAgICBsZXQgaXB5bmIgPSBKU09OLnBhcnNlKGNvZGUpO1xuICAgIGxldCBpc1VzYWJsZSA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwuY2VsbF90eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuc291cmNlLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhY2VsbC5zb3VyY2VbMF0uc3RhcnRzV2l0aChcIiVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5jZWxsX3R5cGUgPT09IFwibWFya2Rvd25cIiB8fFxuICAgICAgICAgICAgICAgIGNlbGwuY2VsbF90eXBlID09PSBcInJhd1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgbWFrZVB5dGhvbiA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwuY2VsbF90eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuc291cmNlLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2VsbC5jZWxsX3R5cGUgPT09IFwibWFya2Rvd25cIiB8fFxuICAgICAgICAgICAgY2VsbC5jZWxsX3R5cGUgPT09IFwicmF3XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIicnJ1wiK2NlbGwuc291cmNlLmpvaW4oXCJcXG5cIikrXCInJydcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGlweW5iLmNlbGxzLmZpbHRlcihpc1VzYWJsZSkubWFwKG1ha2VQeXRob24pLmpvaW4oXCJcXG5cIik7XG59XG5cbmNsYXNzIFB5dGhvbkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZy5maW5kKFwiLmJsb2NrcHktcHl0aG9uLWJsb2NrbWlycm9yXCIpKTtcbiAgICAgICAgQmxvY2tseS5zZXRQYXJlbnRDb250YWluZXIobWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lclswXSk7XG4gICAgICAgIHRoaXMuYm0gPSBuZXcgQmxvY2tNaXJyb3Ioe1xuICAgICAgICAgICAgXCJjb250YWluZXJcIjogdGhpcy50YWdbMF0sXG4gICAgICAgICAgICBcInJ1blwiOiBtYWluLmNvbXBvbmVudHMuZW5naW5lLnJ1bi5iaW5kKG1haW4uY29tcG9uZW50cy5lbmdpbmUpLFxuICAgICAgICAgICAgXCJza2lwU2t1bHB0XCI6IHRydWUsXG4gICAgICAgICAgICBcImJsb2NrbHlNZWRpYVBhdGhcIjogbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmJsb2NrbHlQYXRoLFxuICAgICAgICAgICAgXCJ0b29sYm94XCI6IG1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94KCksXG4gICAgICAgICAgICBcImltYWdlTW9kZVwiOiB0cnVlLFxuICAgICAgICAgICAgaW1hZ2VEb3dubG9hZEhvb2s6IChvbGRVcmwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVXJsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltYWdlVXBsb2FkSG9vazogKGJsb2IpID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHV1aWQgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXSkpLnN1YnN0cmluZygzMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VibWlzc2lvbklkID0gbWFpbi5tb2RlbC5zdWJtaXNzaW9uLmlkKCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW4uY29tcG9uZW50cy5zZXJ2ZXIudXBsb2FkRmlsZShcInN1Ym1pc3Npb25cIiwgc3VibWlzc2lvbklkLCBibG9iLm5hbWUsIGJsb2IsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShKU09OLnN0cmluZ2lmeShyZXNwb25zZS5lbmRwb2ludCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXNvbHZlKEpTT04uc3RyaW5naWZ5KG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzW1wiZG93bmxvYWRGaWxlXCJdICsgYD9wbGFjZW1lbnQ9c3VibWlzc2lvbiZkaXJlY3Rvcnk9JHtzdWJtaXNzaW9uSWR9JmZpbGVuYW1lPSR7YmxvYi5uYW1lfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIFByb21pc2UucmVzb2x2ZShcIkltYWdlKFwiK0pTT04uc3RyaW5naWZ5KFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpK1wiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04uc3RyaW5naWZ5KFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZUxpdGVyYWxIb29rOiAob2xkVXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gYEltYWdlKFwiJHtvbGRVcmx9XCIpYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiJHtvbGRVcmx9XCJgO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vJ2hlaWdodCc6ICcyMDAwcHgnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ha2VTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG5cbiAgICAgICAgdGhpcy5tYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG5cbiAgICBjb25maWd1cmVFeHRyYUJsb2NrbHkoKSB7XG4gICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3Iud29ya3NwYWNlLmNvbmZpZ3VyZUNvbnRleHRNZW51ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlNjcmVlbnNob3RcIixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlNDUkVFTlNIT1RfQkxPQ0tTXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIGxldCBvbGRGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBpZiAob2xkRmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFB5dGhvbk1vZGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKERpc3BsYXlNb2Rlcy5URVhUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUodGhpcy5vbGRQeXRob25Nb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50Qk1MaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm0uYWRkQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50Qk1MaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKG5ld0ZpbGVuYW1lICE9PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLmJtLmlzUGFyc29ucyA9ICgpID0+IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibS5pc1BhcnNvbnMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5pc1BhcnNvbnM7XG5cbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5saW5lc0Vycm9yLnN1YnNjcmliZSgobGluZXMpID0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLWVycm9yLWxpbmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGluZXNVbmNvdmVyZWQuc3Vic2NyaWJlKChsaW5lcykgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLXVuY292ZXJlZC1saW5lXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC51aS50cmFjZS5oaWdobGlnaHRlZExpbmUuc3Vic2NyaWJlKChsaW5lcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKFwiZWRpdG9yLXRyYWNlZC1saW5lXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm0uc2V0SGlnaGxpZ2h0ZWRMaW5lcyhsaW5lcywgXCJlZGl0b3ItdHJhY2VkLWxpbmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy90aGlzLmJtLmJsb2NrRWRpdG9yLndvcmtzcGFjZS5yZW5kZXIoKTtcbiAgICAgICAgLy90aGlzLmJtLnJlZnJlc2goKTtcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhpcyBkb2Vzbid0IGVuZCB1cCBsb29raW5nIHJpZ2h0IChnbyB0byBhIGRpZmZlcmVudCBlZGl0b3IsIGNvbWUgYmFjaywgYW5kIGl0J2xsIGJlIHNxdWlzaGVkKVxuICAgICAgICAvL3RoaXMuYm0ucmVmcmVzaCgpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYm0ucmVmcmVzaCgpLCAwKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgaWYgKG5ld0NvbnRlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50cyA9IHRoaXMuZmlsZS5oYW5kbGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBtYXR0ZXIsIGZpbGUgd2FzIGFscmVhZHkgc2h1dCBkb3duLlxuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdDb250ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UncmUgY2xvc2luZyB0aGlzIGZpbGVcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZGVsZXRlRmlsZUxvY2FsbHlfKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRDb2RlKG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYm0uY2xlYXJIaWdobGlnaHRlZExpbmVzKCk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuYm0uZ2V0Q29kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5ibS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRCTUxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTGluZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG5cbiAgICBjbGVhckxpbmVTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmJtLmNsZWFySGlnaGxpZ2h0ZWRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lRXJyb3JTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmJtLnNldE1vZGUodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZS5zdWJzY3JpYmUobW9kZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJtLnNldE1vZGUobW9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVCbG9ja3Muc3Vic2NyaWJlKGVuYWJsZWQgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRNb2RlKERpc3BsYXlNb2Rlcy5URVhUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRNb2RlKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94LnN1YnNjcmliZSh0aGlzLnJlbG9hZFRvb2xib3guYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmVuYWJsZUltYWdlcy5zdWJzY3JpYmUoaW1hZ2VNb2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0SW1hZ2VNb2RlKGltYWdlTW9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNtYWxsIExheW91dCBTdHVmZlxuICAgICAgICB0aGlzLm9sZEhlaWdodCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc21hbGxMYXlvdXQoKSkge1xuICAgICAgICAgICAgdGhpcy51c2VTbWFsbExheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5zbWFsbExheW91dC5zdWJzY3JpYmUodXNlU21hbGxMYXlvdXQgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZVNtYWxsTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VTbWFsbExheW91dCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9sZEhlaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi5oZWlnaHQgPSB0aGlzLm9sZEhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnRleHRFZGl0b3IucmVzaXplUmVzcG9uc2l2ZWx5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRIZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1c2VTbWFsbExheW91dCgpIHtcbiAgICAgICAgdGhpcy5ibS50ZXh0RWRpdG9yLnVwZGF0ZUd1dHRlcih7aW5kZW50U2lkZWJhcjogZmFsc2V9KTtcbiAgICAgICAgdGhpcy5vbGRIZWlnaHQgPSB0aGlzLmJtLmNvbmZpZ3VyYXRpb24uaGVpZ2h0O1xuICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24uaGVpZ2h0ID0gMzAwOyAvLyBUT0RPOiBQYXJhbWV0ZXJpemUgdGhpc1xuICAgICAgICB0aGlzLmJtLnRleHRFZGl0b3IucmVzaXplUmVzcG9uc2l2ZWx5KCk7XG4gICAgfVxuXG4gICAgcmVsb2FkVG9vbGJveCh0b29sYm94KSB7XG4gICAgICAgIGlmICh0b29sYm94ID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tVG9vbGJveCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj90b29sYm94LmJsb2NrcHlcIik7XG4gICAgICAgICAgICBpZiAoY3VzdG9tVG9vbGJveCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJveCA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IEpTT04ucGFyc2UoY3VzdG9tVG9vbGJveC5oYW5kbGUoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBUT0RPOiBJbXByb3ZlIGVycm9yIG1lc3NhZ2UgZm9yIGluc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJveCA9IFwibWluaW1hbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24udG9vbGJveCA9IHRvb2xib3g7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBpbnZhbGlkIHRvb2xib3ggYmV0dGVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuYm0uY29uZmlndXJhdGlvbi50b29sYm94ID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlUGVyQXNzaWdubWVudFN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWRPbmx5KHRoaXMuZGVjaWRlSWZOb3RFZGl0YWJsZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlVcGxvYWRzLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkT25seSh0aGlzLmRlY2lkZUlmTm90RWRpdGFibGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5wYXJ0SWQuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgcGFydCBpZCBjaGFuZ2luZyBhZnRlciBldmVyeXRoaW5nIGlzIGxvYWRlZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZWNpZGVJZk5vdEVkaXRhYmxlKCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgICAgIHJldHVybiBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkgfHwgKFxuICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5VXBsb2FkcygpICYmICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldFJlYWRPbmx5KGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IGlzUmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYm0uc2V0UmVhZE9ubHkoaXNSZWFkT25seSk7XG4gICAgfVxuXG4gICAgdXBsb2FkRmlsZShldmVudCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBldmVudC50YXJnZXQuZmlsZU5hbWU7XG4gICAgICAgIGxldCBjb2RlID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKFwiLmlweW5iXCIpKSB7XG4gICAgICAgICAgICBjb2RlID0gY29udmVydElweW5iVG9QeXRob24oY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLlVwbG9hZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5maWxlLmhhbmRsZShjb2RlKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZW5naW5lLnJ1bigpO1xuICAgICAgICAvLyBUT0RPOiBSdW4gY29kZVxuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN1cGVyLmRvd25sb2FkRmlsZSgpO1xuICAgICAgICBpZiAocmVzdWx0Lm5hbWUgPT09IFwiYW5zd2VyXCIgJiYgcmVzdWx0LmV4dGVuc2lvbiA9PT0gXCIucHlcIikge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBzbHVnZ2lmeSh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5uYW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5taW1ldHlwZSA9IFwidGV4dC94LXB5dGhvblwiO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuRG93bmxvYWRcIiwgXCJcIiwgXCJcIiwgXCJcIiwgcmVzdWx0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuXG5leHBvcnQgY29uc3QgUHl0aG9uRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiUHl0aG9uXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnB5XCIsIFwiLnJlYWRpbmdcIl0sXG4gICAgY29uc3RydWN0b3I6IFB5dGhvbkVkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFBZVEhPTl9FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBRVUlaX0VESVRPUl9IVE1MID0gYFxyXG4gICAgPGRpdj5cclxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXF1aXpcIj48L3RleHRhcmVhPlxyXG4gICAgPC9kaXY+XHJcbmA7XHJcblxyXG5jbGFzcyBRdWl6RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xyXG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcclxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcclxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFF1aXpFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIlF1aXpcIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5xdWl6XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFF1aXpFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFFVSVpfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIFBhbmVsIGZvciBlZGl0aW5nIHRoZSBzZXQgb2YgU2FtcGxlIFN1Ym1pc3Npb25zLlxuICogVGhlc2UgYXJlIG5vdCBwcm92aWRlZCBhdCBhbGwgdG8gc3R1ZGVudHMgd2l0aG91dCB0aGUgR3JhZGVyIHJvbGUuXG4gKi9cblxuaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5cbmV4cG9ydCBjb25zdCBTdWJtaXNzaW9uU3RhdHVzZXMgPSB7XG4gICAgVU5LTk9XTjogXCJ1bmtub3duXCIsXG4gICAgUEFTU0VEOiBcInBhc3NlZFwiLFxuICAgIEZBSUxFRDogXCJmYWlsZWRcIixcbiAgICBFUlJPUjogXCJlcnJvclwiLFxuICAgIFNLSVBQRUQ6IFwic2tpcHBlZFwiXG59O1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlU3VibWlzc2lvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBCbGFuayhjb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oXCJVbnRpdGxlZFwiKyhjb3VudCB8fCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pc3Npb25TdGF0dXNlcy5VTktOT1dOLCBcImE9MFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFNhbXBsZVN1Ym1pc3Npb24oZGF0YS5uYW1lLCBkYXRhLnN0YXR1cywgZGF0YS5jb2RlKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU0FNUExFX1NVQk1JU1NJT05TX0hUTUwgPSBgXG48ZGl2PlxuICAgIDxkaXYgZGF0YS1iaW5kPVwiZm9yZWFjaDoge2RhdGE6IGFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnN9XCJcbiAgICAgICAgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBuYW1lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3Itc2FtcGxlLXN1Ym1pc3Npb25zLWNvZGVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNvZGVNaXJyb3JJbnN0YW5jZTogY29kZVwiPjwvdGV4dGFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN0YXR1c1wiPjwvc3Bhbj4gICAgICAgIFxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDtcblxua28uYmluZGluZ0hhbmRsZXJzLmNvZGVNaXJyb3JJbnN0YW5jZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50XG4gICAgICAgIC8vIFNldCB1cCBhbnkgaW5pdGlhbCBzdGF0ZSwgZXZlbnQgaGFuZGxlcnMsIGV0Yy4gaGVyZVxuICAgICAgICBjb25zb2xlLmxvZyhcIklOSVRcIik7XG4gICAgICAgIGxldCBjbSA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNtLnNldFNpemUoXCIxMDAlXCIsIFwiMTAwcHhcIik7XG4gICAgICAgIHJldHVybiBjbTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGJpbmRpbmcgaXMgZmlyc3QgYXBwbGllZCB0byBhbiBlbGVtZW50LFxuICAgICAgICAvLyBhbmQgYWdhaW4gd2hlbmV2ZXIgYW55IG9ic2VydmFibGVzL2NvbXB1dGVkcyB0aGF0IGFyZSBhY2Nlc3NlZCBjaGFuZ2VcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBET00gZWxlbWVudCBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgdmFsdWVzIGhlcmUuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVVBEQVRFXCIpO1xuICAgIH1cbn07XG5cbmNsYXNzIFNhbXBsZVN1Ym1pc3Npb25zVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGJ1aWxkRWRpdG9yKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpIHtcblxuICAgIH1cblxuICAgIHJlYnVpbGRFZGl0b3JzKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlYnVpbGRpbmcgZWRpdG9yc1wiKTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vdGhpcy5yZWJ1aWxkRWRpdG9ycygpO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLGNtKSA9PiBjb25zb2xlLmxvZyhcIisrK1wiLCBjbS5Db2RlTWlycm9yKSkpO1xuICAgICAgICAgICAgdGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSwgY20pID0+IGNtLkNvZGVNaXJyb3IucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVGUkVTSFwiKTtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikubWFwKChpLCBjbSkgPT4gY20uQ29kZU1pcnJvci5yZWZyZXNoKCkpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvZGVNaXJyb3JzKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnNldFZhbHVlKG5ld0NvbnRlbnRzLmpvaW4oXCJcXG5cIikpKTtcbiAgICAgICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5lYWNoKCAoaSwgY20pID0+IGNtLnJlZnJlc2goKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvcnMubWFwKGNtID0+IGNtLmdldFZhbHVlKCkpKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvcnMgPSBbXTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3JzLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTYW1wbGVTdWJtaXNzaW9ucyA9IHtcbiAgICBuYW1lOiBcIlNhbXBsZSBTdWJtaXNzaW9uc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogU2FtcGxlU3VibWlzc2lvbnNWaWV3LFxuICAgIHRlbXBsYXRlOiBTQU1QTEVfU1VCTUlTU0lPTlNfSFRNTFxufTtcbiIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgVEFHU19FRElUT1JfSFRNTCA9IGBcbkNyZWF0ZSBuZXdcbkltcG9ydCBieSBuYW1lXG5GaW5kIGJ5IG93bmVyL2NvdXJzZS9raW5kXG5cblRhZ3M6XG4gICAgRGF0YTpcbiAgICAgICAgTmFtZVxuICAgICAgICBLaW5kXG4gICAgICAgIExldmVsXG4gICAgICAgIFZlcnNpb25cbiAgICAgICAgRGVzY3JpcHRpb25cbiAgICBDb250cm9sczpcbiAgICAgICAgRWRpdFxuICAgICAgICBSZW1vdmVcbiAgICAgICAgRGVsZXRlIFxuYDtcblxuY2xhc3MgVGFnc0VkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRhZ3NcIikpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRhZ3NFZGl0b3IgPSB7XG4gICAgbmFtZTogXCJUYWdzXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiIXRhZ3MuYmxvY2tweVwiXSxcbiAgICBjb25zdHJ1Y3RvcjogVGFnc0VkaXRvclZpZXcsXG4gICAgdGVtcGxhdGU6IFRBR1NfRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge2RlZmF1bHRfaGVhZGVyfSBmcm9tIFwiLi9kZWZhdWx0X2hlYWRlclwiO1xuXG5leHBvcnQgY29uc3QgVEVYVF9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDxkaXY+XG4gICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdGV4dFwiPjwvdGV4dGFyZWE+XG4gICAgPC9kaXY+XG5gO1xuXG5jbGFzcyBUZXh0RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdGV4dFwiKVswXSwge1xuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY29kZU1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5jb2RlTWlycm9yKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIG5ld0ZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpICYmICF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0RWRpdG9yID0ge1xuICAgIG5hbWU6IFwiVGV4dFwiLFxuICAgIGV4dGVuc2lvbnM6IFtcIi50eHRcIl0sXG4gICAgY29uc3RydWN0b3I6IFRleHRFZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBURVhUX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPT0xCT1hfRURJVE9SX0hUTUwgPSBgXHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIlxyXG4gICAgICAgICByb2xlPVwidG9vbGJhclwiIGFyaWEtbGFiZWw9XCJUb29sYm94IFRvb2xiYXJcIj5cclxuICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJTYXZlIEdyb3VwXCI+ICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLWVkaXRvci1qc29uLXNhdmVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1zYXZlXCI+PC9zcGFuPiBTYXZlXHJcbiAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiYmxvY2tweS1lZGl0b3ItdG9vbGJveFwiPjwvdGV4dGFyZWE+XHJcbiAgICA8L2Rpdj5cclxuYDtcclxuXHJcbmNsYXNzIFRvb2xib3hFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYSh0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10b29sYm94XCIpWzBdLCB7XHJcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcclxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxyXG4gICAgICAgICAgICB0YWJTaXplOiA0LFxyXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXHJcbiAgICAgICAgICAgIG1vZGU6IFwianNvblwiLFxyXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcclxuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCAhY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xyXG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLWpzb24tc2F2ZVwiKS5vbihcImNsaWNrXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94KCkgPT09IFwiY3VzdG9tXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5yZWxvYWRUb29sYm94KFwiY3VzdG9tXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcclxuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy50YWcuZmluZChcIi5idG4tZWRpdG9yLXRvb2xib3gtc2F2ZVwiKS5vZmYoXCJjbGlja1wiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUb29sYm94RWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJUb29sYm94XCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/dG9vbGJveC5ibG9ja3B5XCJdLFxyXG4gICAgY29uc3RydWN0b3I6IFRvb2xib3hFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IFRPT0xCT1hfRURJVE9SX0hUTUxcclxufTsiLCIvKipcbiAqIEVkaXRvcnMgYXJlIGluZmVycmVkIGZyb20gRmlsZW5hbWVzLlxuICpcbiAqIFRoZSBlZGl0b3IgaXMgYmFzZWQgb24gdGhlIGV4dGVuc2lvbjpcbiAqICAuYmxvY2tweTogU3BlY2lhbCBlZGl0b3IgKHdpbGwgYmUgY2hvc2VuIGJ5IGZpbGVuYW1lKVxuICogIC5weTogUHl0aG9uIEVkaXRvclxuICogIC5tZDogTWFya2Rvd24gRWRpdG9yXG4gKiAgLnR4dDogVGV4dCBFZGl0b3IgKGFsc28gdXNlZCBmb3Igb3RoZXIgdHlwZXMpXG4gKiAgLnBlbWw6IFBFTUwgRWRpdG9yXG4gKiAgLnBuZywgLmdpZiwgLmpwZWcsIC5qcGcsIC5ibXA6IEltYWdlIEVkaXRvclxuICogIC5qc29uOiBKU09OIEVkaXRvclxuICogIC55YW1sOiBZQU1MIEVkaXRvclxuICovXG5cbmltcG9ydCB7UHl0aG9uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcHl0aG9uXCI7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90ZXh0XCI7XG5pbXBvcnQge0Fzc2lnbWVudFR5cGUgYXMgQXNzaWdubWVudFR5cGUsIEFzc2lnbm1lbnRTZXR0aW5nc30gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcbmltcG9ydCB7VGFnc0VkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3RhZ3NcIjtcbmltcG9ydCB7TWFya2Rvd25FZGl0b3J9IGZyb20gXCIuL2VkaXRvci9tYXJrZG93blwiO1xuaW1wb3J0IHtTYW1wbGVTdWJtaXNzaW9uc30gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuaW1wb3J0IHtKc29uRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvanNvblwiO1xuaW1wb3J0IHtUb29sYm94RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdG9vbGJveFwiO1xuaW1wb3J0IHtRdWl6RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvcXVpelwiO1xuaW1wb3J0IHtJbWFnZUVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL2ltYWdlc1wiO1xuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgcG9zc2libGUgZWRpdG9ycyBhdmFpbGFibGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgRWRpdG9yc0VudW0gPSB7XG4gICAgU1VCTUlTU0lPTjogXCJzdWJtaXNzaW9uXCIsXG4gICAgQVNTSUdOTUVOVDogXCJhc3NpZ25tZW50XCIsXG4gICAgSU5TVFJVQ1RJT05TOiBcImluc3RydWN0aW9uc1wiLFxuICAgIE9OX1JVTjogXCJvbl9ydW5cIixcbiAgICBPTl9DSEFOR0U6IFwib25fY2hhbmdlXCIsXG4gICAgT05fRVZBTDogXCJvbl9ldmFsXCIsXG4gICAgU1RBUlRJTkdfQ09ERTogXCJzdGFydGluZ19jb2RlXCIsXG4gICAgU0FNUExFX1NVQk1JU1NJT05TOiBcInNhbXBsZV9zdWJtaXNzaW9uc1wiLFxuICAgIElOU1RSVUNUT1JfRklMRTogXCJpbnN0cnVjdG9yX2ZpbGVcIlxufTtcblxuY29uc3QgU1BFQ0lBTF9OQU1FU1BBQ0VTID0gW1wiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJFwiXTtcblxuY29uc3QgQVZBSUxBQkxFX0VESVRPUlMgPSBbXG4gICAgVGV4dEVkaXRvciwgUHl0aG9uRWRpdG9yLCBBc3NpZ25tZW50U2V0dGluZ3MsIFRhZ3NFZGl0b3IsIE1hcmtkb3duRWRpdG9yLFxuICAgIFNhbXBsZVN1Ym1pc3Npb25zLCBKc29uRWRpdG9yLCBUb29sYm94RWRpdG9yLCBRdWl6RWRpdG9yLCBJbWFnZUVkaXRvclxuXTtcblxuZXhwb3J0IGNvbnN0IEVESVRPUlNfSFRNTCA9IEFWQUlMQUJMRV9FRElUT1JTLm1hcChlZGl0b3IgPT4gYFxuPGRpdiBjbGFzcz1cImJsb2NrcHktcGFuZWwgYmxvY2tweS1lZGl0b3JcIiBcbiAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZWRpdG9ycy52aWV3KCkubmFtZSA9PT0gJyR7ZWRpdG9yLm5hbWV9JywgY2xhc3M6IHVpLmVkaXRvcnMud2lkdGhcIj5cbiAgICA8ZGl2PlxuICAgICR7ZWRpdG9yLnRlbXBsYXRlfVxuICAgIDwvZGl2PlxuPC9kaXY+XG5gXG4gICAgLypcbiAgICBgXG48IS0tIGtvIGlmOiB1aS5lZGl0b3JzLnZpZXcoKS5uYW1lID09PSAnJHtlZGl0b3IubmFtZX0nIC0tPlxuJHtlZGl0b3IudGVtcGxhdGV9XG48IS0tIC9rbyAtLT5gKi9cbikuam9pbihcIlxcblwiKTtcblxuZXhwb3J0IGNsYXNzIEVkaXRvcnMge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkXyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnNfID0ge307XG4gICAgICAgIHRoaXMuYnlOYW1lXyA9IHt9O1xuICAgICAgICBBVkFJTEFCTEVfRURJVE9SUy5mb3JFYWNoKGVkaXRvciA9PiB0aGlzLnJlZ2lzdGVyRWRpdG9yKGVkaXRvcikpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZS5zdWJzY3JpYmUodGhpcy5jaGFuZ2VFZGl0b3IsIHRoaXMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRWRpdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBkYXRhLmV4dGVuc2lvbnM7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBkYXRhLmNvbnN0cnVjdG9yKHRoaXMubWFpbiwgdGhpcy50YWcpO1xuICAgICAgICBpbnN0YW5jZS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRfLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmJ5TmFtZV9bZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCldID0gaW5zdGFuY2U7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uc19bZXh0ZW5zaW9uc1tpXV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5TmFtZV9bbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG5cbiAgICBjaGFuZ2VFZGl0b3IobmV3RmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IG9sZEVkaXRvciA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IG5ld0VkaXRvciA9IHRoaXMuZ2V0RWRpdG9yKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRFZGl0b3IuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ld0VkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZUZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gcGF0aC5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChTUEVDSUFMX05BTUVTUEFDRVMuaW5kZXhPZihzcGFjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGFjZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgIGxldCB0eXBlID0gcGF0aC5zdWJzdHIocGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICByZXR1cm4ge1wic3BhY2VcIjogc3BhY2UsIFwibmFtZVwiOiBuYW1lLCBcInR5cGVcIjogdHlwZX07XG4gICAgfVxuXG4gICAgZ2V0RWRpdG9yKHBhdGgpIHtcbiAgICAgICAgbGV0IHtzcGFjZSwgbmFtZSwgdHlwZX0gPSBFZGl0b3JzLnBhcnNlRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICh0eXBlID09PSBcIi5ibG9ja3B5XCIgJiYgcGF0aCBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1twYXRoXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNzaWdubWVudFR5cGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50eXBlKCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50VHlwZSAhPT0gQXNzaWdubWVudFR5cGUuQkxPQ0tQWSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiYW5zd2VyXCIgJiYgdHlwZSA9PT0gXCIucHlcIikge1xuICAgICAgICAgICAgICAgIGlmIChcIi5cIithc3NpZ25tZW50VHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW1wiLlwiK2Fzc2lnbm1lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gZWRpdG9yIHJlZ2lzdGVyZWQgZm9yIGFzc2lnbm1lbnQgdHlwZTpcIiwgYXNzaWdubWVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkX1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5leHRlbnNpb25zXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bdHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkX1swXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnR5cGUoKSwgc3BhY2UsIG5hbWUsIHR5cGUpO1xuICAgIH1cblxufSIsImltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuL3NlcnZlclwiO1xuaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9ydW5cIjtcbmltcG9ydCB7UnVuQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL3J1blwiO1xuaW1wb3J0IHtFdmFsQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL2V2YWxcIjtcbmltcG9ydCB7U2FtcGxlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL3NhbXBsZVwiO1xuaW1wb3J0IHtPbkNoYW5nZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9jaGFuZ2VcIjtcbmltcG9ydCB7T25FdmFsQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX2V2YWxcIjtcbmltcG9ydCB7T25TYW1wbGVDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fc2FtcGxlXCI7XG5cbi8qKlxuICogQW4gb2JqZWN0IGZvciBleGVjdXRpbmcgUHl0aG9uIGNvZGUgYW5kIHBhc3NpbmcgdGhlIHJlc3VsdHMgYWxvbmcgdG8gaW50ZXJlc3RlZCBjb21wb25lbnRzLlxuICpcbiAqIEludGVyZXN0aW5nIGNvbXBvbmVudHM6XG4gKiAgRXhlY3V0aW9uIEJ1ZmZlcjogUmVzcG9uc2libGUgZm9yIGNvbGxlY3RpbmcgdGhlIHRyYWNlIGR1cmluZyBwcm9ncmFtIGV4ZWN1dGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICBUaGlzIHByZXZlbnRzIEtub2Nrb3V0anMgZnJvbSB1cGRhdGluZyB0aGUgZWRpdG9yIGR1cmluZyBleGVjdXRpb24uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUVkaXRvcn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uTW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uO1xuXG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbnMgPSB7XG4gICAgICAgICAgICBydW46IG5ldyBSdW5Db25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgZXZhbDogbmV3IEV2YWxDb25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25SdW46IG5ldyBPblJ1bkNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvbkNoYW5nZTogbmV3IE9uQ2hhbmdlQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uRXZhbDogbmV3IE9uRXZhbENvbmZpZ3VyYXRpb24obWFpbilcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmVjb25maWd1cmUgc2t1bHB0IHNvIHdlIGNhbiBwYXJzZVxuICAgICAgICBTay5jb25maWd1cmUodGhpcy5jb25maWd1cmF0aW9ucy5ydW4uZ2V0U2t1bHB0T3B0aW9ucygpKTtcblxuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdHJhY2luZyB3aGlsZSB0aGUgcHJvZ3JhbSBpcyBleGVjdXRpbmdcbiAgICAgICAgdGhpcy5leGVjdXRpb25CdWZmZXIgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5hYmxlIGZ1bmN0aW9uIHRvIGJlIHJ1biB3aGVuIGV4ZWN1dGlvbiBoYXMgZnVsbHkgZW5kZWQsXG4gICAgICAgICAqIHdoZXRoZXIgaXQgc3VjY2VlZHMgb3IgZmFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRXhlY3V0aW9uQmVnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLm9uRXhlY3V0aW9uRW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCByZXBvcnRzXG4gICAgICovXG4gICAgcmVzZXRSZXBvcnRzKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5leGVjdXRpb25Nb2RlbC5yZXBvcnRzO1xuICAgICAgICByZXBvcnRbXCJ2ZXJpZmllclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcIm1vZGVsXCJdID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIH07XG5cbiAgICByZXNldFN0dWRlbnRNb2RlbCgpIHtcbiAgICAgICAgbGV0IHN0dWRlbnQgPSB0aGlzLmV4ZWN1dGlvbk1vZGVsLnN0dWRlbnQ7XG4gICAgICAgIHN0dWRlbnQuY2FsbHMgPSB7fTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50U3RlcChudWxsKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKDApO1xuICAgICAgICBzdHVkZW50Lmxhc3RTdGVwKDApO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRMaW5lKG51bGwpO1xuICAgICAgICBzdHVkZW50LmN1cnJlbnRUcmFjZURhdGEucmVtb3ZlQWxsKCk7XG4gICAgICAgIHN0dWRlbnQucmVzdWx0cyA9IG51bGw7XG4gICAgICAgIHN0dWRlbnQudHJhY2luZyA9IFtdO1xuICAgIH1cblxuICAgIHJlc2V0RXhlY3V0aW9uQnVmZmVyKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbkJ1ZmZlciA9IHtcbiAgICAgICAgICAgIFwidHJhY2VcIjogW10sXG4gICAgICAgICAgICBcInN0ZXBcIjogMCxcbiAgICAgICAgICAgIFwibGluZVwiOiAwLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGludGVyZmFjZSBhc3BlY3RzIG9mIHRoZSBwcmV2aW91cyBSdW4uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIC8vIFRPRE86IENsZWFyIG91dCBhbnkgY292ZXJhZ2UvdHJhY2UvZXJyb3IgaGlnaGxpZ2h0cyBpbiBlZGl0b3JzXG4gICAgICAgIC8vIFJlc2V0IGV4ZWN1dGlvbiBpbiBtb2RlbFxuICAgICAgICB0aGlzLnJlc2V0U3R1ZGVudE1vZGVsKCk7XG4gICAgICAgIC8vIEdldCByZXBvcnRzIHJlYWR5XG4gICAgICAgIHRoaXMucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgZXhlY3V0aW9uIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlc2V0RXhlY3V0aW9uQnVmZmVyKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgY29uc29sZSBvZiBwcmludGVkIHN0dWZmXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBvbGQgZmVlZGJhY2tcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2suY2xlYXIoKTtcbiAgICB9XG5cbiAgICBkZWxheWVkUnVuKGRpc2FibGVGZWVkYmFjaz1mYWxzZSkge1xuICAgICAgICAvL3RoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8kKFwiLmJsb2NrcHktcnVuXCIpLmFkZENsYXNzKFwiYmxvY2tweS1ydW4tcnVubmluZ1wiKTtcbiAgICAgICAgdGhpcy5ydW4oZGlzYWJsZUZlZWRiYWNrKTtcbiAgICAgICAgLy9zZXRUaW1lb3V0KHRoaXMucnVuLmJpbmQodGhpcyksIDEpO1xuICAgIH1cblxuICAgIHN0b3AoKSB7XG5cbiAgICB9XG5cbiAgICBydW4oZGlzYWJsZUZlZWRiYWNrPWZhbHNlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMucnVuLnVzZSh0aGlzKTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlRmVlZGJhY2soKSAmJiAhZGlzYWJsZUZlZWRiYWNrKSB7XG4gICAgICAgICAgICBleGVjdXRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVTZWNyZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUnVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5zaG93RXJyb3JzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvblJ1bigpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vblJ1bi51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5leGVjdXRpb25FbmRfLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIGxldCBldmFsdWF0aW9uSW5wdXQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmV2YWx1YXRlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2YWx1YXRpb25JbnB1dCk7XG4gICAgICAgIGV2YWx1YXRpb25JbnB1dC50aGVuKCh1c2VySW5wdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZXZhbC51c2UodGhpcywgdXNlcklucHV0KTtcbiAgICAgICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVGZWVkYmFjaygpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZVNlY3JldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5vbkV2YWwuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5zaG93RXJyb3JzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uRXZhbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vbkV2YWwudXNlKHRoaXMpO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZXZhbHVhdGUuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuY29uZmlndXJhdGlvbi5maW5hbGx5LmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSk7XG4gICAgfVxuXG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMub25DaGFuZ2UudXNlKHRoaXMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgcmV0dXJuIFNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlKCgpID0+XG4gICAgICAgICAgICBTay5pbXBvcnRNYWluV2l0aEJvZHkodGhpcy5jb25maWd1cmF0aW9uLmZpbGVuYW1lLCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uY29kZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3lzbW9kdWxlcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZWQgd2hlbmV2ZXIgdGhlIFB5dGhvbiBjb2RlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBvbl9jaGFuZ2UoKSB7XG4gICAgICAgIGxldCBGSUxFTkFNRSA9IFwib25fY2hhbmdlXCI7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGluc3RydWN0b3IgaGFzIG5vdCBkZWZpbmVkIGFueXRoaW5nXG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLnByb2dyYW1zW0ZJTEVOQU1FXSgpLnRyaW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3RhdHVzKFwiY2hhbmdpbmdcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlQ29kZSgpO1xuICAgICAgICAvLyBPbiBzdGVwIGRvZXMgbm90IHBlcmZvcm0gcGFyc2UgYW5hbHlzaXMgYnkgZGVmYXVsdCBvciBydW4gc3R1ZGVudCBjb2RlXG4gICAgICAgIGxldCBlbmdpbmUgPSB0aGlzO1xuICAgICAgICBsZXQgZmVlZGJhY2sgPSB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjaztcbiAgICAgICAgZW5naW5lLnJlc2V0UmVwb3J0cygpO1xuICAgICAgICBlbmdpbmUudmVyaWZ5Q29kZSgpO1xuICAgICAgICBlbmdpbmUudXBkYXRlUGFyc2UoKTtcbiAgICAgICAgZW5naW5lLnJ1bkluc3RydWN0b3JDb2RlKEZJTEVOQU1FLCB0cnVlLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdKSB7XG4gICAgICAgICAgICAgICAgLy8gU1VDQ0VTUywgU0NPUkUsIENBVEVHT1JZLCBMQUJFTCwgTUVTU0FHRSwgREFUQSwgSElERVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG9ubHkgc2hvdyB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXNcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgIShjYXRlZ29yeSA9PT0gXCJJbnN0cnVjdG9yXCIgJiYgbGFiZWwgPT09IFwiTm8gZXJyb3JzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhjYXRlZ29yeSwgbGFiZWwsIG1lc3NhZ2UsIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmdpbmUubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhtb2R1bGUuJGQpO1xuICAgICAgICAgICAgICAgIGVuZ2luZS5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdGF0dXMoXCJjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVuZ2luZS5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiZW5naW5lXCIsIFwib25fY2hhbmdlXCIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYXR0ZW1wdCB0byBjYWxsIHRoZSBkZWZpbmVkIG9uRXhlY3V0aW9uRW5kLFxuICAgICAqIGJ1dCB3aWxsIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm8gZnVuY3Rpb24gZGVmaW5lZC5cbiAgICAgKi9cbiAgICBleGVjdXRpb25FbmRfKCkge1xuICAgICAgICBpZiAodGhpcy5vbkV4ZWN1dGlvbkVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBleGVjdXRpb25CZWdpbl8oKSB7XG4gICAgICAgIGlmICh0aGlzLm9uRXhlY3V0aW9uQmVnaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25FeGVjdXRpb25CZWdpbigpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9NT0RVTEUgPSBcImxldCAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG1vZCl7IHJldHVybiBtb2Q7IH1cIjtcblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgaG9sZGluZyBzZXR0aW5ncyBvZiBhIHBhcnRpY3VsYXIgcnVuIGNvbmZpZ3VyYXRpb24uXG4gKiBUaGlzIGlzIHRoZSByb290IGNsYXNzIGZvciBhbGwgb3RoZXIgY29uZmlndXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3lzbW9kdWxlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIC8vIEFjY2VzcyBwb2ludCBmb3IgaW5zdHJ1Y3RvciBkYXRhXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBTay5jb25zb2xlID0gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZTtcbiAgICAgICAgU2sucXVldWVkSW5wdXQgPSBbXTtcbiAgICAgICAgU2suY29uZmlndXJlKHRoaXMuZ2V0U2t1bHB0T3B0aW9ucygpKTtcbiAgICAgICAgLy8gU2V0IG9wZW5GaWxlIGFzIG1lY2hhbmlzbSB0byByZWFkIGZpbGVzXG4gICAgICAgIFNrLmluQnJvd3NlciA9IHRoaXMub3BlbkZpbGUuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgcmVxdWVzdHNcbiAgICAgICAgU2sucmVxdWVzdHNHZXQgPSAodXJsLCBkYXRhLCB0aW1lb3V0KSA9PiB0aGlzLm9wZW5VUkwodXJsLCBkYXRhLCB0aW1lb3V0KTtcbiAgICAgICAgLy8gQ29uZmlndXJlIGEgXCJkbyB5b3Ugd2FudCB0byB3YWl0PyBwcm9tcHRcIlxuICAgICAgICBTay50aW1lb3V0SGFuZGxlciA9ICh0aW1lUGFzc2VkLCBleGVjTGltaXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJvbXB0TWVzc2FnZSA9IHRoaXMuZ2V0VGltZW91dFByb21wdCh0aW1lUGFzc2VkLzEwMDAgPiAzMCk7XG4gICAgICAgICAgICBsZXQgZGVsYXkgPSBwcm9tcHQocHJvbXB0TWVzc2FnZSwgU2suZXhlY0xpbWl0LzEwMDApO1xuICAgICAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsIHx8IGRlbGF5PT0wKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBTay5leGVjTGltaXQgKyBwYXJzZUludChkZWxheSwgMTApICogMTAwMDtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkgPyBJbmZpbml0eSA6IGRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9O1xuICAgICAgICAvLyBBdHRhY2ggYmVmb3JlQ2FsbFxuICAgICAgICBTay5iZWZvcmVDYWxsID0gdGhpcy5iZWZvcmVDYWxsLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFRpbWVvdXRQcm9tcHQobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgaWYgKGxvbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgcHJvZ3JhbSBoYXMgdGFrZW4gYSBSRUFMTFkgbG9uZyB0aW1lIHRvIHJ1biAoMzAgb3IgbW9yZSBzZWNvbmRzKS4gWW91IG1pZ2h0IHdhbnQgdG8gY2FuY2VsIGFuZCBjaGVjayB5b3VyIGNvZGUuIE9yLCB5b3UgY2FuIGFkZCBtb3JlIHNlY29uZHMgdG8gd2FpdCBiZWxvdy5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBwcm9ncmFtIGlzIHRha2luZyBhIHdoaWxlIHRvIHJ1bi4gSG93IG1hbnkgbW9yZSBzZWNvbmRzIHdvdWxkIHlvdSBsaWtlIHRvIHdhaXQ/XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTa3VscHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19mdXR1cmVfXzogU2sucHl0aG9uMyxcbiAgICAgICAgICAgIC8vIGltcG9ydFxuICAgICAgICAgICAgcmVhZDogdGhpcy5pbXBvcnRGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBvcGVuXG4gICAgICAgICAgICAvL2ZpbGVvcGVuOiB0aGlzLm9wZW5GaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBmaWxlLndyaXRlXG4gICAgICAgICAgICBmaWxld3JpdGU6IHRoaXMud3JpdGVGaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBwcmludFxuICAgICAgICAgICAgb3V0cHV0OiB0aGlzLnByaW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBpbnB1dFxuICAgICAgICAgICAgaW5wdXRmdW46IHRoaXMuaW5wdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGlucHV0ZnVuVGFrZXNQcm9tcHQ6IHRydWUsXG4gICAgICAgICAgICAvLyBNZWRpYSBJbWFnZSBQcm94eSBVUkxcbiAgICAgICAgICAgIGltYWdlUHJveHk6IHRoaXMuZ2V0SW1hZ2VQcm94eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIHNldCBieSB0aGUgc3lzdGVtIHNvIHdlIGNhbiB1c2Ugb3VyIG93biBzZXJ2ZXJzIGluIHByYWN0aWNlXG4gICAgICAgICAgICBlbW9qaVByb3h5OiAocGFydCkgPT4gYGh0dHBzOi8vdHdlbW9qaS5tYXhjZG4uY29tL3YvMTMuMS4wL3N2Zy8ke3BhcnQudG9Mb3dlckNhc2UoKX0uc3ZnYCxcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIGtlZXAgdGhlIGdsb2JhbHNcbiAgICAgICAgICAgIHJldGFpbkdsb2JhbHM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFjY2VzcyBTa3VscHQgYnVpbHQtaW5zLiBUaGlzIGlzIHByZXR0eSBnZW5lcmljLCB0YWtlblxuICAgICAqIGFsbW9zdCBkaXJlY3RseSBmcm9tIHRoZSBTa3VscHQgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBweXRob24gZmlsZW5hbWUgKGUuZy4sIFwib3NcIiBvciBcInBwcmludFwiKSB0aGF0IHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIG9mIHRoZSBmaWxlICh3ZWlyZCwgcmlnaHQ/KVxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpc24ndCBmb3VuZC5cbiAgICAgKi9cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG5cbiAgICBvcGVuVVJMKHVybCwgZGF0YSwgdGltZW91dCkge1xuICAgICAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBtb2NrVXJsRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgaWYgKG1vY2tVcmxEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFVSTCBEYXRhIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9ja1VybERhdGEgPSBKU09OLnBhcnNlKG1vY2tVcmxEYXRhLmhhbmRsZSgpKTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gbW9ja1VybERhdGEpIHtcbiAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YS5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2NrVXJsRGF0YVtmaWxlbmFtZV0ubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ja1VybERhdGFbZmlsZW5hbWVdW2ldID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ucmVhZEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmaWxlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWplY3QobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogXCIrdXJsK1wiIHdhcyBub3QgbWFkZSBhdmFpbGFibGUgZm9yIHRoaXMgYXNzaWdubWVudFwiKSk7XG4gICAgICAgIC8vfSk7XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIHdyaXRlRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaW5wdXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaW1wbGVtZW50ZWQgbWV0aG9kIVwiKTtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIGNsZWFySW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5jbGVhcklucHV0cygpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlucHV0TW9ja0Z1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2sucXVldWVkSW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gU2sucXVldWVkSW5wdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXRJbWFnZVByb3h5KHVybCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgc3RlcCgpIHtcblxuICAgIH1cblxuICAgIGxhc3RTdGVwKCkge1xuXG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0IHN1Y2Nlc3MgZXhlY3V0aW9uXCIpO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3QgZmFpbHVyZSBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmluYWxseShyZXN1bHQpIHtcbiAgICAgICAgLy8gRm9yY2UgUHlnYW1lIHRvIHN0b3AgdHJhcHBpbmcga2V5Ym9hcmQgZXZlbnRzXG4gICAgICAgIGlmICh0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnB5Z2FtZUxpbmUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHVtbXlPdXRTYW5kYm94KCkge1xuICAgICAgICAvL1NrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC9zYW5kYm94LnB5XCJdID0gXCJjbGFzcyBTYW5kYm94OiBwYXNzXFxuZGVmIHJ1bigpOiBwYXNzXFxuZGVmIHJlc2V0KCk6IHBhc3NcXG5cIjtcbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUUkFDS0lORyBDQUxMXCIsIGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGZhc3RjYWxsIHRvbz8gQ2hlY2sgaG93IHRoYXQgd29ya3MgaW4gU2t1bHB0IHNpZGVcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICBpZiAoIShcImNhbGxzXCIgaW4gc3R1ZGVudE1vZGVsKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZnVuY3Rpb25OYW1lIGluIHN0dWRlbnRNb2RlbC5jYWxscykpIHtcbiAgICAgICAgICAgIHN0dWRlbnRNb2RlbC5jYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgLy8gR2V0IGFjdHVhbCBwYXJhbWV0ZXIgbmFtZXMhIVxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBwb3NhcmdzLmxlbmd0aDsgaSs9IDEpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1wiK2ldID0gcG9zYXJnc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa3dhcmdzICYmIGt3YXJnc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW1wiX19BUkdTXCJdID0ga3dhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0tXQVJHU1wiXSA9IGt3YXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGFyZ3MpO1xuICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHNbZnVuY3Rpb25OYW1lXS5wdXNoKGFyZ3MpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtCbG9ja1B5VHJhY2V9IGZyb20gXCIuLi90cmFjZVwiO1xuXG5leHBvcnQgY2xhc3MgRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSwgY29kZSkge1xuICAgICAgICAvLyBUT0RPOiBmaXggdG8gYmUgY3VycmVudGx5IGFkZGVkIGxpbmVcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5tZXNzYWdlKFwiUnVubmluZy4uLlwiKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiXyA9IFwiICsgY29kZTtcbiAgICAgICAgU2suYWZ0ZXJTaW5nbGVFeGVjdXRpb24gPSBudWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gdHJ1ZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLkFkZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIHRoaXMuY29kZSwgXCJldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWNjZXNzKG1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1FdmFsdWF0ZS5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludFZhbHVlKFNrLmZmaS5yZW1hcFRvSnMobW9kdWxlLiRkLl8uJHIoKSkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy90aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFdmFsIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJldmFsdWF0aW9uXCI6IHRoaXMuY29kZSxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQge0NvbmZpZ3VyYXRpb24sIEVNUFRZX01PRFVMRX0gZnJvbSBcIi4vY29uZmlndXJhdGlvbnMuanNcIjtcbmltcG9ydCB7JHNrX21vZF9pbnN0cnVjdG9yfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3JcIjtcbmltcG9ydCB7JHNrX21vZF9jb3ZlcmFnZX0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL2NvdmVyYWdlXCI7XG5pbXBvcnQgeyRwZWRhbF90cmFjZXJ9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9wZWRhbF90cmFjZXJcIjtcbmltcG9ydCB7Y2hvbXBTcGVjaWFsRmlsZX0gZnJvbSBcIi4uL2ZpbGVzXCI7XG5cbmNvbnN0IFVUSUxJVFlfTU9EVUxFX0NPREUgPSBcInZhciAkYnVpbHRpbm1vZHVsZSA9IFwiICsgJHNrX21vZF9pbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG5jb25zdCBDT1ZFUkFHRV9NT0RVTEVfQ09ERSA9ICRza19tb2RfY292ZXJhZ2U7XG5cbmV4cG9ydCBjbGFzcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIEluc3RydWN0b3JzIGdldCA0IHNlY29uZHNcbiAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogNzAwMDtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgLy8gU3RlcHBlciEgRXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc3RhdGVtZW50LlxuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IG51bGw7IC8vIDEwICoxMDAwXG4gICAgICAgIC8vIE11dGUgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5tdXRlUHJpbnRlcih0cnVlKTtcbiAgICAgICAgLy8gRGlzYWJsZSBpbnB1dCBib3hcbiAgICAgICAgU2sucXVldWVkSW5wdXQgPSBbXTtcbiAgICAgICAgLy8gVE9ETyBTay5pbnB1dGZ1biA9IEJsb2NrUHlFbmdpbmUuaW5wdXRNb2NrRnVuY3Rpb247XG4gICAgICAgIC8vIFRPRE86IEFsbG93IGlucHV0IGZ1bmN0aW9uIHRvIGRpc2FibGUgdGhlIHRpbWVyLCBzb21laG93XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJlZm9yZUNhbGwgY2hlY2tlciB1bmxlc3Mgc3BlY2lmaWNhbGx5IHJlcXVlc3RlZFxuICAgICAgICBTay5iZWZvcmVDYWxsQmFja3VwID0gU2suYmVmb3JlQ2FsbDtcbiAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIC8vIEVuYWJsZSB1dGlsaXR5IG1vZGVcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gVVRJTElUWV9NT0RVTEVfQ09ERTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9jb3ZlcmFnZS5weVwiXSA9IENPVkVSQUdFX01PRFVMRV9DT0RFO1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIG5lZWRzIHRvIGJlIG9wdGltaXplZFxuICAgICAgICAvL2NvbnN0IFBFREFMX1RSQUNFUl9NT0RVTEVfQ09ERSA9IFNrLmNvbXBpbGUoJHBlZGFsX3RyYWNlciwgXCJ0cmFjZXIucHlcIiwgXCJleGVjXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3RyYWNlci5weVwiXSA9ICRwZWRhbF90cmFjZXI7XG4gICAgICAgIGRlbGV0ZSBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLmpzXCJdO1xuICAgICAgICAvLyBUT0RPOiBNb2NrIFBlZGFsJ3MgdHJhY2VyIG1vZHVsZSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2ZXJzaW9uXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcIi4vX2luc3RydWN0b3IvX19pbml0X18uanNcIl0gPSBFTVBUWV9NT0RVTEU7XG4gICAgICAgIC8vIFJldXNlIGFueSBleGlzdGluZyBzeXNtb2R1bGVzIHRoYXQgd2UgcHJldmlvdXNseSBmb3VuZCwgYnV0IG5vdCBfX21haW5fXyBtb2R1bGVzXG4gICAgICAgIHRoaXMuc3lzbW9kdWxlcyA9IHRoaXMuY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCk7XG4gICAgICAgIC8vIEhvcnJpZmljIGhhY2ssIHRvIHByZXZlbnQgVGlmYSBmcm9tIGNhY2hpbmcgYSBiYWQgdmVyc2lvbiBvZiB0aGUgc3R1ZGVudHMnIGltcG9ydFxuICAgICAgICBTay5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMgPSB0aGlzLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpbnQodmFsdWUpIHtcbiAgICAgICAgc3VwZXIucHJpbnQodmFsdWUpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJQcmludGVkOlwiLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCkge1xuICAgICAgICBsZXQgc3lzbW9kdWxlcyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIF9fbWFpbl9fIG1vZHVsZXNcbiAgICAgICAgaWYgKHN5c21vZHVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgb2YgdGhpcy5nZXRBbGxGaWxlbmFtZXMoKSkge1xuICAgICAgICAgICAgICAgIGxldCBza0ZpbGVuYW1lID0gbmV3IFNrLmJ1aWx0aW4uc3RyKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAvKmlmIChzeXNtb2R1bGVzLnF1aWNrJGxvb2t1cChza0ZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzeXNtb2R1bGVzLnBvcCRpdGVtKHNrRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICAgIHN5c21vZHVsZXMucG9wJGl0ZW0oc2tGaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5c21vZHVsZXM7XG4gICAgfVxuXG4gICAgZ2V0QWxsU3R1ZGVudEZpbGVzKCkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHtcbiAgICAgICAgICAgIFwiYW5zd2VyLnB5XCI6IHRoaXMubWFpbi5tb2RlbC51aS5maWxlcy5nZXRTdHVkZW50Q29kZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNraXAgc3BlY2lhbCBpbnN0cnVjdG9yIGZpbGVzXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGlmICghKFwiIV4kI1wiLmluY2x1ZGVzKGZpbGUuZmlsZW5hbWUoKVswXSkpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXNbZmlsZS5maWxlbmFtZSgpXSA9IGNob21wU3BlY2lhbEZpbGUoZmlsZS5jb250ZW50cygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluY2x1ZGUgbm9ybWFsIHN0dWRlbnQgZXh0cmEgZmlsZXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlLmZpbGVuYW1lKCldID0gZmlsZS5jb250ZW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH1cblxuICAgIGdldEFsbEZpbGVuYW1lcygpIHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW4oZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lID0gY2hvbXBTcGVjaWFsRmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoXCIucHlcIikpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJfX21haW5fX1wiLFxuICAgICAgICAgICAgXCJfaW5zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgLi4udGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5tYXAoZmlsZSA9PiBcIl9pbnN0cnVjdG9yLlwiICsgY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgICAgICAuLi50aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKCkubWFwKGZpbGUgPT4gY2xlYW4oZmlsZS5maWxlbmFtZSgpKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaGFzIHRha2VuIGEgUkVBTExZIGxvbmcgdGltZSB0byBjaGVjayB5b3VyIGNvZGUgKDMwIG9yIG1vcmUgc2Vjb25kcykuIFlvdSBtaWdodCB3YW50IHRvIGNhbmNlbCBhbmQgY2hlY2sgeW91ciBjb2RlIChvciBnZXQgaGVscCBmcm9tIGFuIGluc3RydWN0b3IpLiBPciwgeW91IGNhbiBhZGQgbW9yZSBzZWNvbmRzIHRvIHdhaXQgYmVsb3cuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgaW5zdHJ1Y3RvciBjb2RlIGlzIHRha2luZyBhIGxpdHRsZSB3aGlsZSB0byBjaGVjayB5b3VyIGNvZGU7IGl0IG1pZ2h0IGp1c3QgbmVlZCBhIGxpdHRsZSBtb3JlIHRpbWUuIEhvdyBtYW55IG1vcmUgc2Vjb25kcyB3b3VsZCB5b3UgbGlrZSB0byB3YWl0P1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5zZWFyY2hGb3JGaWxlKGZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiK2ZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiLi9hbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgPT09IFwiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfTU9EVUxFO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiAnXCIrZmlsZW5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgLy9yZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICBjb25zb2xlLmxvZyhcIj4+PlwiLCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCksIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpIDwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBuZXh0SW5wdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KClbaW5wdXRJbmRleF07XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBcHBsZVBpZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8qcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKFNrLnF1ZXVlZElucHV0LnBvcCgpKTtcbiAgICAgICAgfSk7Ki9cbiAgICB9XG5cbiAgICBiZWZvcmVDYWxsKGZ1bmN0aW9uTmFtZSwgcG9zYXJncywga3dhcmdzKSB7XG4gICAgICAgIGxldCBzdHVkZW50TW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudDtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkhFWSBJTlNUUlVDVE9SIENBTExcIiwgZnVuY3Rpb25OYW1lLCBzdHVkZW50TW9kZWwudHJhY2luZyk7XG4gICAgICAgIGlmIChzdHVkZW50TW9kZWwudHJhY2luZyAmJiBzdHVkZW50TW9kZWwudHJhY2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1cGVyLmJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuXG5leHBvcnQgY2xhc3MgT25DaGFuZ2VDb25maWd1cmF0aW9uIGV4dGVuZHMgSW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcIm9uX2NoYW5nZS5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSgpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS50cmlnZ2VyT25DaGFuZ2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0iLCJpbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge2ZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0LCBJTlNUUlVDVE9SX01BUktFUiwgTkVXX0xJTkVfUkVHRVh9IGZyb20gXCIuL29uX3J1blwiO1xuaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50Q29kZSwgaW5zdHJ1Y3RvckNvZGUsIHF1aWNrLCBpc1NhZmUpIHtcbiAgICBsZXQgc2FmZUNvZGUgPSBKU09OLnN0cmluZ2lmeShzdHVkZW50Q29kZSk7XG5cbiAgICByZXR1cm4gYFxuZnJvbSB1dGlsaXR5IGltcG9ydCAqXG5cbiMgTG9hZCBpbiBzb21lIGNvbW1vbmx5IHVzZWQgdG9vbHNcbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuZnJvbSBwZWRhbC5zYW5kYm94LmNvbW1hbmRzIGltcG9ydCAqXG5mcm9tIHBlZGFsLmNvcmUuY29tbWFuZHMgaW1wb3J0ICpcblxuIyBCYWNrdXAgdGhlIGZlZWRiYWNrXG5vbl9ydW5fZmVlZGJhY2sgPSBbXVxuZm9yIGZlZWRiYWNrIGluIE1BSU5fUkVQT1JULmZlZWRiYWNrOlxuICAgIG9uX3J1bl9mZWVkYmFjay5hcHBlbmQoZmVlZGJhY2spXG5NQUlOX1JFUE9SVC5mZWVkYmFjay5jbGVhcigpXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIEFkZCBpbiBldmFsdWF0ZWQgc3R1ZmYgZnJvbSBsYXN0IHRpbWVcbnN0dWRlbnQgPSBnZXRfc2FuZGJveCgpXG4jIFRPRE86IFdoYXQgYWJvdXQgbmV3IGlucHV0cyBzaW5jZSB3ZSBsYXN0IHJhbi9ldmFsZWQ/XG4jIE1BSU5fUkVQT1JULnN1Ym1pc3Npb24uZmlsZXNbJ2V2YWx1YXRpb24nXSA9ICR7c2FmZUNvZGV9XG5ldmFsdWF0ZSgke3NhZmVDb2RlfVsnZXZhbHVhdGlvbiddKVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uRXZhbENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiX2luc3RydWN0b3Iub25fZXZhbFwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSB8fCBcIlwiO1xuXG4gICAgICAgIGxldCBkaXNhYmxlVGlmYSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaWZhKCk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQuZXZhbHVhdGlvbiB8fCBcIk5vbmVcIjtcbiAgICAgICAgbGV0IHN0dWRlbnRGaWxlcyA9IHRoaXMuZ2V0QWxsU3R1ZGVudEZpbGVzKCk7XG4gICAgICAgIHN0dWRlbnRGaWxlc1tcImV2YWx1YXRpb25cIl0gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudC5ldmFsdWF0aW9uIHx8IFwiTm9uZVwiO1xuICAgICAgICB0aGlzLmR1bW15T3V0U2FuZGJveCgpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3RvckNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIGxldCBpc1NhZmUgPSAhcmVwb3J0W1wicGFyc2VyXCJdLmVtcHR5ICYmIHJlcG9ydFtcInZlcmlmaWVyXCJdLnN1Y2Nlc3M7XG4gICAgICAgIGluc3RydWN0b3JDb2RlID0gV1JBUF9JTlNUUlVDVE9SX0NPREUoc3R1ZGVudEZpbGVzLCBpbnN0cnVjdG9yQ29kZSwgZGlzYWJsZVRpZmEsIGlzU2FmZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4+XCIsIGluc3RydWN0b3JDb2RlKTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBmaW5kQWN0dWFsSW5zdHJ1Y3Rvck9mZnNldChpbnN0cnVjdG9yQ29kZSk7IC8vaW5zdHJ1Y3RvckNvZGUuc3BsaXQoTkVXX0xJTkVfUkVHRVgpLmxlbmd0aDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ldmFsLnB5XCIsXG4gICAgICAgICAgICBcImNvZGVcIjogaW5zdHJ1Y3RvckNvZGUsXG4gICAgICAgICAgICBcImxpbmVPZmZzZXRcIjogbGluZU9mZnNldFxuICAgICAgICAgICAgLy8nY29tcGxldGUnOiBmYWxzZSAvLyBBY3R1YWxseSwgbGV0J3MgdXNlIHVuZGVmaW5lZCBmb3Igbm93LlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvZGUgPSBpbnN0cnVjdG9yQ29kZTtcblxuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcblxuICAgICAgICAvL1NrLnJldGFpbkdsb2JhbHMgPSBmYWxzZTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5nbG9iYWxzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT25FdmFsIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZSk7XG4gICAgICAgIGxldCByZXN1bHRzID0gbW9kdWxlLiRkLm9uX2V2YWwuJGQ7XG4gICAgICAgIGNvbnNvbGUubG9nKG1vZHVsZS4kZCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRGZWVkYmFjayhyZXN1bHRzKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICBsZXQgc3VjY2VzcyA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TVUNDRVNTKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdChzdWNjZXNzIHx8IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSk7XG4gICAgICAgIC8vIENhbm5vdCBleGNlZWQgMSBwb2ludCwgY2Fubm90IGdvIGJlbG93IDAgcG9pbnRzXG4gICAgICAgIGxldCBzY29yZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5TQ09SRSk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKE1hdGgubWF4KG9sZFNjb3JlLCBzY29yZSkpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPbkV2YWwgZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIkdyYWNlZnVsRXhpdFwiKSB7XG4gICAgICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImNvZGVcIl0pO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IGZhbHNlO1xuICAgICAgICAgICAgLy9yZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiZXJyb3JcIl0gPSBlcnJvcjtcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImxpbmVfb2Zmc2V0XCJdID0gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IGFmdGVyKGVycm9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHtpbmRlbnR9IGZyb20gXCIuLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdG9yQ29kZS5pbmRleE9mKElOU1RSVUNUT1JfTUFSS0VSKTtcbiAgICBjb25zdCBiZWZvcmUgPSBpbnN0cnVjdG9yQ29kZS5zbGljZSgwLCBpbmRleCk7XG4gICAgY29uc3QgbWF0Y2ggPSBiZWZvcmUubWF0Y2goTkVXX0xJTkVfUkVHRVgpO1xuICAgIHJldHVybiBtYXRjaCA/ICgxK21hdGNoLmxlbmd0aCkgOiAwO1xufVxuXG5leHBvcnQgY29uc3QgSU5TVFJVQ1RPUl9NQVJLRVIgPSBcIiMjI1J1biB0aGUgYWN0dWFsIGluc3RydWN0b3IgY29kZSMjI1wiO1xuZXhwb3J0IGNvbnN0IE5FV19MSU5FX1JFR0VYID0gL1xcbi9nO1xuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBXUkFQX0lOU1RSVUNUT1JfQ09ERSA9IGZ1bmN0aW9uIChzdHVkZW50RmlsZXMsIGluc3RydWN0b3JDb2RlLCBxdWljaywgaXNTYWZlKSB7XG4gICAgbGV0IHNhZmVDb2RlID0gSlNPTi5zdHJpbmdpZnkoc3R1ZGVudEZpbGVzKTtcbiAgICBsZXQgc2tpcF90aWZhID0gcXVpY2sgPyBcIlRydWVcIjogXCJGYWxzZVwiO1xuXG4gICAgLy8gVE9ETzogQWRkIGluIFNrLnF1ZXVlZElucHV0IHRvIGJlIHBhc3NlZCBpblxuXG4gICAgcmV0dXJuIGBcbiMgU3VwcG9ydCBvdXIgc3lzbW9kdWxlcyBoYWNrIGJ5IGNsZWFyaW5nIG91dCBhbnkgbGluZ2VyaW5nIG9sZCBkYXRhXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuTUFJTl9SRVBPUlQuY2xlYXIoKVxuXG5mcm9tIGJha2VyeSBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBTZXQgdGhlIHNlZWQgdG8gdGhlIHN1Ym1pc3Npb24gSUQgYnkgZGVmYXVsdD9cbmZyb20gcGVkYWwucXVlc3Rpb25zIGltcG9ydCBzZXRfc2VlZFxuc2V0X3NlZWQoc3RyKGdldF9tb2RlbF9pbmZvKFwic3VibWlzc2lvbi5pZFwiKSkpXG5cbiMgSW5pdGlhbGl6ZSB0aGUgQmxvY2tQeSBlbnZpcm9ubWVudFxucGVkYWwgPSBzZXR1cF9lbnZpcm9ubWVudChza2lwX3RpZmE9JHtza2lwX3RpZmF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3J1bj1za2lwX3J1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzPWlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9maWxlPSdhbnN3ZXIucHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcz0ke3NhZmVDb2RlfSlcbnN0dWRlbnQgPSBwZWRhbC5maWVsZHNbJ3N0dWRlbnQnXVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ydW5cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuICAgICAgICAvLyBQdXQgdGhlIGlucHV0IGluZGV4IGJhY2sgdG8gdGhlIGZyb250LCBzbyB3ZSBjYW4gcmVwbGF5IGlucHV0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMSk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICBsZXQgc3R1ZGVudEZpbGVzID0gdGhpcy5nZXRBbGxTdHVkZW50RmlsZXMoKTtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKTsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICAvL2xpbmVPZmZzZXQgPSAwOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGggLSBsaW5lT2Zmc2V0IC0gNDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIC8vIFRPRE8gTG9nZ2luZyEhISFcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk9uUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtb2R1bGUuJGQub25fcnVuLiRkO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgob2xkU2NvcmUsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc2NvcmUpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk9uUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufVxuXG5cbi8qXG4jIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG9sZCBpbnN0cnVjdG9yIGNvZGUsIGxlYXZpbmcgaXQgaGVyZSBmb3Igbm93LlxuXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbk1BSU5fUkVQT1JULmNsZWFyKClcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgY29udGV4dHVhbGl6ZV9yZXBvcnRcbmNvbnRleHR1YWxpemVfcmVwb3J0KCR7c2FmZUNvZGV9LCBcImFuc3dlci5weVwiKVxuJHt0aWZhQW5hbHlzaXN9XG5mcm9tIHBlZGFsLnNhbmRib3guc2FuZGJveCBpbXBvcnQgU2FuZGJveFxuZnJvbSBwZWRhbC5zYW5kYm94IGltcG9ydCBjb21wYXRpYmlsaXR5XG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcbnN0dWRlbnQgPSBNQUlOX1JFUE9SVFsnc2FuZGJveCddWydydW4nXSA9IFNhbmRib3goKVxuc3R1ZGVudC5yZXBvcnRfZXhjZXB0aW9uc19tb2RlID0gVHJ1ZVxubG9nKGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbnN0dWRlbnQuc2V0X2lucHV0KGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbmlmIG5vdCBnZXRfbW9kZWxfaW5mbygnYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlSW5zdHJ1Y3RvclJ1bicpOlxuICAgIGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnQocmFpc2VfZXhjZXB0aW9ucz1GYWxzZSlcbiNsb2coc3R1ZGVudC5kYXRhKVxuI3N0dWRlbnQgPSBnZXRfc3R1ZGVudF9kYXRhKClcbiNlcnJvciwgcG9zaXRpb24gPSBnZXRfc3R1ZGVudF9lcnJvcigpXG4jY29tcGF0aWJpbGl0eS5yYWlzZV9leGNlcHRpb24oZXJyb3IsIHBvc2l0aW9uKVxucnVuX3N0dWRlbnQgPSBjb21wYXRpYmlsaXR5LnJ1bl9zdHVkZW50XG5yZXNldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LnJlc2V0X291dHB1dFxucXVldWVfaW5wdXQgPSBjb21wYXRpYmlsaXR5LnF1ZXVlX2lucHV0XG5nZXRfb3V0cHV0ID0gY29tcGF0aWJpbGl0eS5nZXRfb3V0cHV0XG5nZXRfcGxvdHMgPSBjb21wYXRpYmlsaXR5LmdldF9wbG90c1xuY29tcGF0aWJpbGl0eS50cmFjZV9saW5lcyA9IHRyYWNlX2xpbmVzXG5mcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbnF1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuIyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgZm9yIHRoaXMgaGFjayFcbmRlZiBjYXB0dXJlX291dHB1dChmdW5jLCAqYXJncyk6XG4gICByZXNldF9vdXRwdXQoKVxuICAgc3R1ZGVudC5jYWxsKGZ1bmMuX19uYW1lX18sICphcmdzKVxuICAgcmV0dXJuIGdldF9vdXRwdXQoKVxuY29tcGF0aWJpbGl0eS5jYXB0dXJlX291dHB1dCA9IGNhcHR1cmVfb3V0cHV0XG5cbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuJHtpbnN0cnVjdG9yQ29kZX1cbmZyb20gcGVkYWwucmVzb2x2ZXJzIGltcG9ydCBzaW1wbGVcbmZpbmFsID0gc2ltcGxlLnJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuICovIiwiaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL29uX3J1blwiO1xuXG5leHBvcnQgY2xhc3MgT25TYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgT25SdW5Db25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9ydW4ucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuXG5leHBvcnQgY2xhc3MgUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVTdHVkZW50UnVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlRmlsZShcImFuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCksIG51bGwpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuY29kZSk7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIGVuZ2luZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnNlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1widmVyaWZpZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogQm9vbGVhbih0aGlzLmNvZGUudHJpbSgpKSxcbiAgICAgICAgICAgIFwiY29kZVwiOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIFNrLmVudmlyb24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgU2suZW52aXJvbiA9IG5ldyBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmludGVyVGFnID0gdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5wcmludGVyVGFnLFxuICAgICAgICAgICAgd2lkdGggPSBwcmludGVyVGFnLndpZHRoKCktNTAsXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgzMDAsIHByaW50ZXJUYWcuaGVpZ2h0KCktNTApO1xuICAgICAgICBTay5lbnZpcm9uLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cihcIkRFU0lHTkVSX1dJTkRPV19XSURUSFwiKSwgbmV3IFNrLmJ1aWx0aW4uaW50Xyh3aWR0aCkpO1xuICAgICAgICBTay5lbnZpcm9uLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cihcIkRFU0lHTkVSX1dJTkRPV19IRUlHSFRcIiksIG5ldyBTay5idWlsdGluLmludF8oaGVpZ2h0KSk7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY2xlYXJJbnB1dCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgXCJpbnB1dHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIiksXG4gICAgICAgICAgICBcIm91dHB1dHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQoKS5tYXAobGluZSA9PiBsaW5lLmNvbnRlbnQpLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlJ1bi5Qcm9ncmFtXCIsIFwiXCIsIFwiXCIsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5maW5pc2hUdXJ0bGVzKCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuZ2xvYmFscyhTay5nbG9iYWxzKTtcbiAgICAgICAgU2suZ2xvYmFscyA9IHt9O1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQucmVzdWx0cyA9IG1vZHVsZTtcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRXZhbHVhdGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5iZWdpbkV2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGVwKG1vZHVsZS4kZCwgbW9kdWxlLiRkLC0xLCAwLCBmaWxlbmFtZSArIFwiLnB5XCIpO1xuICAgICAgICAgICAgdGhpcy5sYXN0U3RlcCgpO1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInRyYWNlXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZSxcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVhbExpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5maWx0ZXIoeCA9PiAheC5pc0RvY3N0cmluZykubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlc3VsdHNcIjogbW9kdWxlLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ub3V0cHV0LFxuICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICBcImNhbGxzXCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jYWxscyxcbiAgICAgICAgICAgICAgICBcInRyYWNpbmdcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJ1biBmYWlsdXJlXCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAocmVwb3J0LnBhcnNlci5zdWNjZXNzICYmIHJlcG9ydC52ZXJpZmllci5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlLkVycm9yXCIsIFwiXCIsIFwiXCIsIGVycm9yLnRvU3RyaW5nKCksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJQcm9ncmFtRXJyb3JPdXRwdXRcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlYWxMaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UuZmlsdGVyKHggPT4gIXguaXNEb2NzdHJpbmcpLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7U3R1ZGVudENvbmZpZ3VyYXRpb259IGZyb20gXCIuL3N0dWRlbnRcIjtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBTdHVkZW50Q29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gVE9ETzogRml4IHRvIGJlIHRoZSBjdXJyZW50IHNhbXBsZSBzdWJtaXNzaW9uXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlci5weVwiO1xuICAgICAgICB0aGlzLmNvZGUgPSBcInByaW50KCdOb3QgcmVhZHkgeWV0IScpXCI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7Q29uZmlndXJhdGlvbiwgRU1QVFlfTU9EVUxFfSBmcm9tIFwiLi9jb25maWd1cmF0aW9uc1wiO1xuXG5leHBvcnQgY2xhc3MgU3R1ZGVudENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBMaW1pdCBleGVjdXRpb24gdG8gNCBzZWNvbmRzXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IHRoaXMubWFpbi5tb2RlbC5zZXR0aW5ncztcbiAgICAgICAgU2suZXhlY0xpbWl0RnVuY3Rpb24gPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogNTAwMDtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgLy8gU3RlcHBlciEgRXhlY3V0ZWQgYWZ0ZXIgZXZlcnkgc3RhdGVtZW50LlxuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IHRoaXMuc3RlcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFVubXV0ZSBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKGZhbHNlKTtcblxuICAgICAgICAvLyBGdW5jdGlvbiB0byBjYWxsIGFmdGVyIGVhY2ggc3RlcFxuICAgICAgICAvLyBhZnRlclNpbmdsZUV4ZWN1dGlvblxuXG4gICAgICAgIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvdXRpbGl0eS9fX2luaXRfXy5qc1wiXSA9IEVNUFRZX01PRFVMRTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvcGVuRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGZpbGVuYW1lLCBmb3VuZCk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoU2suYnVpbHRpbkZpbGVzICYmIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT1NFcnJvcihcIkZpbGUgbm90IGZvdW5kOiBcIiArIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZC5jb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW1wb3J0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZvcmJpZGRlbihmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IFwiRmlsZSBub3QgYWNjZXNzaWJsZTogJ1wiICsgZmlsZW5hbWUgKyBcIidcIjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL2Fuc3dlci5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiQnVpbHQtaW4gbW9kdWxlcyBub3QgYWNjZXNzaWJsZS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6ICdcIitmaWxlbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dChwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmlucHV0KHByb21wdE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlzRm9yYmlkZGVuKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwic3JjL2xpYi91dGlsaXR5L1wiKSB8fFxuICAgICAgICAgICAgZmlsZW5hbWUuc3RhcnRzV2l0aChcInNyYy9saWIvcGVkYWwvXCIpIHx8XG4gICAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwiLi9faW5zdHJ1Y3Rvci9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXCJTdGVwc1wiIHRoZSBleGVjdXRpb24gb2YgdGhlIGNvZGUsIG1lYW50IHRvIGJlIHVzZWQgYXMgYSBjYWxsYmFjayB0byB0aGUgU2t1bHB0XG4gICAgICogZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2xvYmFscyAtIEhhc2ggdGhhdCBtYXBzIHRoZSBuYW1lcyBvZiBnbG9iYWwgdmFyaWFibGVzIChTdHJpbmdzKSB0byB0aGVpciBTa3VscHQgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FscyAtIEhhc2ggdGhhdCBtYXBzIHRoZSBuYW1lcyBvZiBsb2NhbCB2YXJpYWJsZXMgKFN0cmluZ3MpIHRvIHRoZWlyIFNrdWxwdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZU51bWJlciAtIFRoZSBjb3JyZXNwb25kaW5nIGxpbmUgbnVtYmVyIGluIHRoZSBzb3VyY2UgY29kZSB0aGF0IGlzIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5OdW1iZXIgLSBUaGUgY29ycmVzcG9uZGluZyBjb2x1bW4gbnVtYmVyIGluIHRoZSBzb3VyY2UgY29kZSB0aGF0IGlzIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGluayBvZiBpdCBhcyB0aGUgXCJYXCIgcG9zaXRpb24gdG8gdGhlIGxpbmVOdW1iZXIncyBcIllcIiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHl0aG9uIGZpbGUgYmVpbmcgZXhlY3V0ZWQgKGUuZy4sIFwiX19tYWluX18ucHlcIikuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0RvY3N0cmluZyAtIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYW4gYWN0dWFsIGxpbmUgb3IgYSBkb2NzdHJpbmcuXG4gICAgICovXG4gICAgc3RlcChnbG9iYWxzLCBsb2NhbHMsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlciwgZmlsZW5hbWUsIGlzRG9jc3RyaW5nLCBhc3ROYW1lKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgLyppZiAoZXhlY1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhlY1N0YWNrLm1hcCgoW24sIG9dKSA9PiBbbiwgey4uLm99XSkpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcDtcbiAgICAgICAgICAgIGdsb2JhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMoey4uLmdsb2JhbHMsIC4uLmxvY2Fsc30pO1xuICAgICAgICAgICAgLy8gVE9ETzogVHJhY2UgbG9jYWwgdmFyaWFibGVzIHByb3Blcmx5XG4gICAgICAgICAgICAvL2xldCBsb2NhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMobG9jYWxzKTtcbiAgICAgICAgICAgIC8vT2JqZWN0LmFzc2lnbihnbG9iYWxzLCBsb2NhbHMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic3RlcFwiOiBjdXJyZW50U3RlcCxcbiAgICAgICAgICAgICAgICBcImZpbGVuYW1lXCI6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIC8vJ2Jsb2NrJzogaGlnaGxpZ2h0TWFwW2xpbmVOdW1iZXItMV0sXG4gICAgICAgICAgICAgICAgXCJsaW5lXCI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiBnbG9iYWxzLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgXCJtb2R1bGVzXCI6IGdsb2JhbHMubW9kdWxlcyxcbiAgICAgICAgICAgICAgICBcImlzRG9jc3RyaW5nXCI6IGlzRG9jc3RyaW5nLFxuICAgICAgICAgICAgICAgIFwiYXN0XCI6IGFzdE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXAgPSBjdXJyZW50U3RlcCArIDE7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBTa3VscHQgZXhlY3V0aW9uIHRvIHRlcm1pbmF0ZSB0aGUgZXhlY3V0aW9uQnVmZmVyXG4gICAgICogYW5kIGhhbmQgaXQgb2ZmIHRvIHRoZSBleGVjdXRpb24gdHJhY2UgaW4gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGxhc3RTdGVwKCkge1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlRGF0YSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0TGluZSh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIubGluZSk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgIH07XG5cbiAgICBnZXRMaW5lcyhhc3QpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWRMaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHZpc2l0Qm9keSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5saW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRMaW5lcy5hZGQobm9kZS5saW5lbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYm9keS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm9yZWxzZSkge1xuICAgICAgICAgICAgICAgIG5vZGUub3JlbHNlLmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuZmluYWxib2R5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maW5hbGJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZpc2l0Qm9keShhc3QpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpdGVkTGluZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZSBwYXJzZSBpbmZvcm1hdGlvbiBpcyB1cC10by1kYXRlXG4gICAgICovXG4gICAgdXBkYXRlUGFyc2UoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIC8vIEhvbGQgYWxsIHRoZSBhY3R1YWxseSBkaXNjb3ZlcmVkIGxpbmVzIGZyb20gdGhlIHBhcnNlXG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAvLyBBdHRlbXB0IGEgcGFyc2VcbiAgICAgICAgbGV0IGFzdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwYXJzZSA9IFNrLnBhcnNlKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICBhc3QgPSBTay5hc3RGcm9tUGFyc2UocGFyc2UuY3N0LCB0aGlzLmZpbGVuYW1lLCBwYXJzZS5mbGFncyk7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuZ2V0TGluZXMoYXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlcG9ydCB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImVtcHR5XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5maWxlbmFtZSwgdGhpcy5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWNjZXNzZnVsIHBhcnNlXG4gICAgICAgIHJlcG9ydFtcInBhcnNlclwiXSA9IHtcbiAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJhc3RcIjogYXN0LFxuICAgICAgICAgICAgXCJlbXB0eVwiOiBhc3QuYm9keS5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBcImxpbmVzXCI6IGxpbmVzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNob3dFcnJvcnMoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnRbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLmNsZWFyKFwiRXhlY3V0aW9uIGZpbmlzaGVkLiBObyBlcnJvcnMgdG8gcmVwb3J0LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRSdW5FcnJvcihyZXBvcnQuc3R1ZGVudC5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm92aWRlU2VjcmV0RXJyb3IoKSB7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmZWVkYmFjayA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrO1xuICAgICAgICBpZiAoIXJlcG9ydFtcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGVycm9yQnV0dG9uID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1zdHVkZW50LWVycm9yXCIpO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBmZWVkYmFjay5wcmVzZW50UnVuRXJyb3IocmVwb3J0LnN0dWRlbnQuZXJyb3IsIHRydWUpO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uYXR0cihcInRpdGxlXCIsIFwiQ2xpY2sgdG8gc2VlIE9yaWdpbmFsIEVycm9yXCIpO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24udG9vbHRpcCh7XCJ0cmlnZ2VyXCI6IFwiaG92ZXJcIiwgXCJjb250YWluZXJcIjogdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uYXR0YWNobWVudFBvaW50fSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5jbGljaygoKSA9PiB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfU0hPV19TVFVERU5UX0VSUk9SKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgbGV0IEZFRURCQUNLX0hUTUwgPSBgXG5cbjxzcGFuIGNsYXNzPSdibG9ja3B5LWZsb2F0aW5nLWZlZWRiYWNrIHRleHQtbXV0ZWQtbGVzcyBwdWxsLXJpZ2h0IHBvc2l0aW9uLXN0aWNreSBzdGlja3ktdG9wJ1xuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiBhcmlhLWxhYmVsPVwiTmV3IEZlZWRiYWNrIEFsZXJ0XCI+XG4gICAgTmV3IGZlZWRiYWNrICZ1YXJyO1xuPC9zcGFuPlxuXG48ZGl2IGNsYXNzPSdibG9ja3B5LWZlZWRiYWNrIGJsb2NrcHktcGFuZWwnXG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIkZlZWRiYWNrXCJcbiAgICAgICAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGFzczogdWkuY29uc29sZS5zaXplXCI+XG5cbiAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICA8IS0tIGtvIGlmbm90OiB1aS5zZWNvbmRSb3cuaGlkZVRyYWNlQnV0dG9uIC0tPlxuICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0J1xuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuc2Vjb25kUm93LnN3aXRjaExhYmVsXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDwhLS0gUG9zaXRpdmUgRmVlZGJhY2sgUmVnaW9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlIGZsb2F0LXJpZ2h0XCI+XG4gICAgICAgIFxuICAgIFxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBBY3R1YWwgRmVlZGJhY2sgUmVnaW9uIC0tPiAgICBcbiAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nPkZlZWRiYWNrOiA8L3N0cm9uZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9J2JhZGdlIGJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnkgZmVlZGJhY2stYmFkZ2UnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHVpLmZlZWRiYWNrLmJhZGdlLFxuICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5mZWVkYmFjay5jYXRlZ29yeVwiPkZlZWRiYWNrIEtpbmQ8L3NwYW4+XG4gICAgICAgIDxzbWFsbCBkYXRhLWJpbmQ9XCJ0ZXh0OiAoMTAwKnN1Ym1pc3Npb24uc2NvcmUoKSkrJyUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBkaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBleGVjdXRpb24uZmVlZGJhY2subGFiZWwoKVwiXG4gICAgICAgICAgICBjbGFzcz1cInRleHQtbXV0ZWRcIj48L3NtYWxsPlxuICAgICAgICA8c21hbGwgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZlZWRiYWNrLnJlc2V0U2NvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbCgpICYmIHN1Ym1pc3Npb24uc2NvcmUoKSA+IDBcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0ZXh0LW11dGVkXCIgc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXJcIj48dT4ocmVzZXQpPC91Pjwvc21hbGw+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZyBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stbGFiZWxcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidGV4dDogZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsXCI+PC9zdHJvbmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLW1lc3NhZ2VcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PiAgICAgICAgICAgIFxuYDtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlGZWVkYmFjayB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoZSBmZWVkYmFjayBhcmVhLCB3aGVyZSB1c2VycyBhcmUgdG9sZCB0aGUgc3RhdGUgb2YgdGhlaXJcbiAgICAgKiBwcm9ncmFtJ3MgZXhlY3V0aW9uIGFuZCBnaXZlbiBndWlkYW5jZS4gQWxzbyBtYW5hZ2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgVHJhY2UgVGFibGUuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdGhpcyB7QmxvY2tQeUZlZWRiYWNrfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrO1xuXG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnlcIik7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbGFiZWxcIik7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLnBvc2l0aXZlID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlXCIpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZXkgY2hhbmdlIHRoZSBzdHVkZW50IGV4dHJhIGZpbGVzLCBhbHNvIHVwZGF0ZSB0aGUgZGlydHkgZmxhZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24odHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgc2NyZWVuICh0YWtlcyAxIHNlY29uZCkgdG8gbWFrZSB0aGUgRmVlZGJhY2sgYXJlYSB2aXNpYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICAkKFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcub2Zmc2V0KCkudG9wXG4gICAgICAgIH0sIDcwMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZlZWRiYWNrIGFyZWEgaXMgY3VycmVudGx5IHZpc2libGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZlZWRiYWNrVmlzaWJsZSgpIHtcbiAgICAgICAgbGV0IHZpc2liaWxpdHlCdWZmZXIgPSAxMDA7XG4gICAgICAgIGxldCB0b3BPZkVsZW1lbnQgPSB0aGlzLnRhZy5vZmZzZXQoKS50b3A7XG4gICAgICAgIC8vbGV0IGJvdHRvbU9mRWxlbWVudCA9IHRoaXMudGFnLm9mZnNldCgpLnRvcCArIHRoaXMudGFnLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGxldCBib3R0b21PZkVsZW1lbnQgPSB0b3BPZkVsZW1lbnQgKyB2aXNpYmlsaXR5QnVmZmVyO1xuICAgICAgICBsZXQgYm90dG9tT2ZTY3JlZW4gPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAkKHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICAgIGxldCB0b3BPZlNjcmVlbiA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgLy9ib3R0b21fb2ZfZWxlbWVudCAtPSA0MDsgLy8gVXNlciBmcmllbmRseSBwYWRkaW5nXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodG9wT2ZFbGVtZW50IDwgYm90dG9tT2ZTY3JlZW4pICYmXG4gICAgICAgICAgICAodG9wT2ZTY3JlZW4gPCBib3R0b21PZkVsZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFueSBvdXRwdXQgY3VycmVudGx5IGluIHRoZSBmZWVkYmFjayBhcmVhLiBBbHNvIHJlc2V0cyB0aGUgcHJpbnRlciBhbmRcbiAgICAgKiBhbnkgaGlnaGxpZ2h0ZWQgbGluZXMgaW4gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBjbGVhcihtZXNzYWdlPVwiUmVhZHlcIikge1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KG51bGwpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobnVsbCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5oaWRkZW4oZmFsc2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmNsZWFyUG9zaXRpdmVGZWVkYmFjaygpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZmluZEZpcnN0RXJyb3JMaW5lKGZlZWRiYWNrRGF0YSkge1xuICAgICAgICBpZiAoZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cCkge1xuICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gZmVlZGJhY2tEYXRhLnF1aWNrJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJsb2NhdGlvblwiKSk7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGxvY2F0aW9uLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwibGluZVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKmZvciAobGV0IGkgPSBmZWVkYmFja0RhdGEubGVuZ3RoLTE7IGkgPj0gMDsgaS09IDEpIHtcbiAgICAgICAgICAgIGlmIChcInBvc2l0aW9uXCIgaW4gZmVlZGJhY2tEYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlZWRiYWNrRGF0YVtpXS5wb3NpdGlvbi5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsOyovXG4gICAgfTtcblxuICAgIHVwZGF0ZVJlZ3VsYXJGZWVkYmFjaygpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG1vZGVsIHdpdGggdGhlc2UgbmV3IGV4ZWN1dGlvbiByZXN1bHRzXG4gICAgICogQHBhcmFtIGV4ZWN1dGlvblJlc3VsdHNcbiAgICAgKi9cbiAgICB1cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKSB7XG4gICAgICAgIC8vIFBhcnNlIG91dCBkYXRhXG4gICAgICAgIGxldCBtZXNzYWdlID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLk1FU1NBR0UpO1xuICAgICAgICBsZXQgY2F0ZWdvcnkgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuQ0FURUdPUlkpO1xuICAgICAgICBsZXQgbGFiZWwgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuTEFCRUwpO1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5ISURFKTtcbiAgICAgICAgbGV0IGRhdGEgPSBleGVjdXRpb25SZXN1bHRzLkRBVEE7XG4gICAgICAgIGxldCBwb3NpdGl2ZXMgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuUE9TSVRJVkUpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIGJhc2VkIG9uIGFzc2lnbm1lbnRzJyBzZXR0aW5nc1xuICAgICAgICBsZXQgaGlkZVNjb3JlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCk7XG4gICAgICAgIGlmIChoaWRlU2NvcmUgJiYgY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBjYXRlZ29yeSA9IFwibm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBsYWJlbCA9IFwiTm8gZXJyb3JzXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJObyBlcnJvcnMgcmVwb3J0ZWQuXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1hcCB0byBleHBlY3RlZCBCbG9ja1B5IGxhYmVsc1xuICAgICAgICBpZiAoY2F0ZWdvcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnN0cnVjdG9yXCIgJiYgbGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gXCJleHBsYWluXCIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCJJbnN0cnVjdG9yIEZlZWRiYWNrXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBwcmVzZW50IGEgbGFjayBvZiBlcnJvciBhcyBiZWluZyBpbmNvcnJlY3RcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikge1xuICAgICAgICAgICAgY2F0ZWdvcnkgPSBcIm5vIGVycm9yc1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGFjY29yZGluZ2x5XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1haW4udXRpbGl0aWVzLm1hcmtkb3duKG1lc3NhZ2UpLnJlcGxhY2UoLzxwcmU+XFxuL2csIFwiPHByZT5cXG5cXG5cIik7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkoY2F0ZWdvcnkpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGFiZWwobGFiZWwpO1xuICAgICAgICAvL2xldCBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZS5maW5kKFwicHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vfSwgNDAwKTtcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0cmFja2luZyBzdHVkZW50IGZpbGUsIGxldCdzIHRyYWNrIHRoZSBpbnN0cnVjdG9yIGZpbGVcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiSW50ZXJ2ZW50aW9uXCIsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgXCJhbnN3ZXIucHlcIik7XG5cbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFueSBwcmV2aW91c2x5IGhpZ2hsaWdodGVkIGxpbmVzXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciBvbiBhIGxpbmUgYW5kIHJlcG9ydCB0aGF0XG4gICAgICAgIGxldCBsaW5lID0gQmxvY2tQeUZlZWRiYWNrLmZpbmRGaXJzdEVycm9yTGluZShkYXRhKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lICE9PSBudWxsICYmIGxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucHVzaChsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmVydCB0aGUgc2V0IG9mIHRyYWNlZCBsaW5lc1xuICAgICAgICBsZXQgc3R1ZGVudFJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChzdHVkZW50UmVwb3J0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCB1bmNvdmVyZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnBhcnNlci5saW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWRlbnRSZXBvcnQubGluZXMuaW5kZXhPZihsaW5lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5jb3ZlcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZCh1bmNvdmVyZWRMaW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9zaXRpdmVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aXZlRGF0YSA9IHBvc2l0aXZlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkUG9zaXRpdmVGZWVkYmFjayhwb3NpdGl2ZURhdGEubWVzc2FnZSwgXCJzdGFyXCIsIFwiZ3JlZW5cIiwgKCkgPT4gdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwocG9zaXRpdmVEYXRhLnRpdGxlLCBwb3NpdGl2ZURhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJQb3NpdGl2ZUZlZWRiYWNrKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktc3R1ZGVudC1lcnJvclwiKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgYWRkUG9zaXRpdmVGZWVkYmFjayh0ZXh0LCBpY29uLCBjb2xvciwgb25jbGljaywgdG9FbmQpIHtcbiAgICAgICAgbGV0IHBvc2l0aXZlID0gJChcIjxzcGFuPjwvc3Bhbj5cIik7XG4gICAgICAgIHBvc2l0aXZlLmFkZENsYXNzKFwiYmxvY2tweS1mZWVkYmFjay1wb3NpdGl2ZS1pY29uIGZhcyBmYS1cIitpY29uKTtcbiAgICAgICAgcG9zaXRpdmUuY3NzKFwiY29sb3JcIiwgY29sb3IpO1xuICAgICAgICBwb3NpdGl2ZS5hdHRyKFwidGl0bGVcIiwgdGV4dCk7XG4gICAgICAgIGlmICh0b0VuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5hcHBlbmQocG9zaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZS5wcmVwZW5kKHBvc2l0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGl2ZS50b29sdGlwKHtcInRyaWdnZXJcIjogXCJob3ZlclwiLCBcImNvbnRhaW5lclwiOiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnR9KTtcbiAgICAgICAgaWYgKG9uY2xpY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpdmUuY2xpY2sob25jbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpdmUuaG92ZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GZWVkYmFja1wiLCBcInBvc2l0aXZlXCIsIFwiaG92ZXJcIiwgdGV4dCwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXNlbnQgYW55IGFjY3VtdWxhdGVkIGZlZWRiYWNrXG4gICAgICovXG4gICAgcHJlc2VudEZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGZWVkYmFjayhleGVjdXRpb25SZXN1bHRzKTtcblxuICAgICAgICAvLyBUT0RPOiBMb2dnaW5nXG4gICAgICAgIC8vdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiZmVlZGJhY2tcIiwgY2F0ZWdvcnkrXCJ8XCIrbGFiZWwsIG1lc3NhZ2UpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5RmVlZGJhY2tVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgbm90aWZ5RmVlZGJhY2tVcGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0ZlZWRiYWNrVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmxvYXRpbmctZmVlZGJhY2tcIikuc2hvdygpLmZhZGVPdXQoNzAwMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRTY3JvbGxJbnRvVmlldygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNob3VsZFNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubWFpbi5tb2RlbC51aS5zbWFsbExheW91dCgpO1xuICAgIH1cblxuICAgIHByZXNlbnRSdW5FcnJvcihlcnJvciwganVzdF9yZXR1cm4pIHtcbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGp1c3RfcmV0dXJuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UsIGxhYmVsLCBjYXRlZ29yeSwgbGluZW5vO1xuICAgICAgICBsYWJlbCA9IGVycm9yLnRwJG5hbWU7XG4gICAgICAgIGNhdGVnb3J5ID0gXCJydW50aW1lXCI7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvcik7XG5cbiAgICAgICAgaWYgKGp1c3RfcmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmNhdGVnb3J5KGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxhYmVsKGxhYmVsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCAmJiBsaW5lbm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnB1c2gobGluZW5vKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWxkVHJhY2ViYWNrKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgIHJldHVybiBlcnJvci50cmFjZWJhY2subWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lbm8gPSBmcmFtZS5saW5lbm87XG4gICAgICAgICAgICBpZiAoZnJhbWUuZmlsZW5hbWUuc2xpY2UoMCwgLTMpID09PSBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgbGluZW5vIC09IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5pbnN0cnVjdG9yLmxpbmVPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlsZSA9IGBGaWxlIDxjb2RlIGNsYXNzPVwiZmlsZW5hbWVcIj5cIiR7ZnJhbWUuZmlsZW5hbWV9XCI8L2NvZGU+LCBgO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBgb24gbGluZSA8Y29kZSBjbGFzcz1cImxpbmVub1wiPiR7bGluZW5vfTwvY29kZT4sIGA7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSAoZnJhbWUuc2NvcGUgIT09IFwiPG1vZHVsZT5cIiAmJlxuICAgICAgICAgICAgZnJhbWUuc2NvcGUgIT09IHVuZGVmaW5lZCkgPyBgaW4gc2NvcGUgJHtmcmFtZS5zY29wZX1gIDogXCJcIjtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGZyYW1lLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gYFxcbjxwcmU+PGNvZGU+JHtmcmFtZS5zb3VyY2V9PC9jb2RlPjwvcHJlPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZSArIGxpbmUgKyBzY29wZSArIHNvdXJjZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udmVydFNrdWxwdEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkLCBpc0luc3RydWN0b3IpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBlcnJvci50cCRuYW1lO1xuICAgICAgICBsZXQgYXJncyA9IFNrLmZmaS5yZW1hcFRvSnMoZXJyb3IuYXJncyk7XG4gICAgICAgIGxldCB0b3AgPSBgJHtuYW1lfTogJHthcmdzWzBdfVxcbjxicj5cXG48YnI+YDtcbiAgICAgICAgbGV0IHRyYWNlYmFjayA9IFwiXCI7XG4gICAgICAgIGlmIChuYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuZXJyICYmIGVycm9yLmVyci50cmFjZWJhY2sgJiYgZXJyb3IuZXJyLnRyYWNlYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxGcmFtZXMgPSB0aGlzLmJ1aWxkVHJhY2ViYWNrKGVycm9yLmVyciwgZmlsZW5hbWVFeGVjdXRlZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW1wiVHJhY2ViYWNrOlwiXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRnJhbWVzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsRnJhbWVzLnNsaWNlKDAsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLi4uIEhpZGluZyAke2FsbEZyYW1lcy5sZW5ndGggLSAzfSBvdGhlciBzdGFjayBmcmFtZXMgLi4uLGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFsbEZyYW1lcy5zbGljZSgtMywgLTIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5hbGxGcmFtZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFjZWJhY2sgPSByZXN1bHQuam9pbihcIlxcbjxicj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gXCJFcnJvciBpbiBpbnN0cnVjdG9yIGZlZWRiYWNrLiBQbGVhc2Ugc2hvdyB0aGUgZm9sbG93aW5nIHRvIGFuIGluc3RydWN0b3I6PGJyPlxcblwiK3RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci50cmFjZWJhY2sgJiYgZXJyb3IudHJhY2ViYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRyYWNlYmFjayA9IFwiVHJhY2ViYWNrOjxicj5cXG5cIiArIHRoaXMuYnVpbGRUcmFjZWJhY2soZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpLmpvaW4oXCJcXG48YnI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3ArXCJcXG5cIit0cmFjZWJhY2s7XG4gICAgfVxuXG4gICAgcHJlc2VudEludGVybmFsRXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQpIHtcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoXCJydW50aW1lXCIpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbChcIlRpbWVvdXQgRXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KFwiaW50ZXJuYWxcIik7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsKFwiSW50ZXJuYWwgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLmNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeUZlZWRiYWNrVXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1TeXN0ZW0uRXJyb3JcIiwgXCJpbnRlcm5hbFwiLCBcIkludGVybmFsIEVycm9yXCIsIG1lc3NhZ2UsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQge2ZpcnN0RGVmaW5lZFZhbHVlfSBmcm9tIFwidXRpbGl0aWVzLmpzXCI7XG5cbi8vICR7bWFrZVRhYihcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIlVSTCBEYXRhXCIsIHRydWUpfVxuXG5jb25zdCBtYWtlVGFiID0gZnVuY3Rpb24oZmlsZW5hbWUsIGZyaWVuZGx5TmFtZSwgaGlkZUlmRW1wdHksIG5vdEluc3RydWN0b3IpIHtcbiAgICBpZiAoZnJpZW5kbHlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJpZW5kbHlOYW1lID0gZmlsZW5hbWU7XG4gICAgfVxuICAgIGxldCBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJcIjtcbiAgICBsZXQgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwidHJ1ZVwiO1xuICAgIGlmICghbm90SW5zdHJ1Y3Rvcikge1xuICAgICAgICBpbnN0cnVjdG9yRmlsZUNsYXNzID0gXCJibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiO1xuICAgICAgICBoaWRlSWZOb3RJbnN0cnVjdG9yID0gXCJkaXNwbGF5Lmluc3RydWN0b3IoKVwiO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtICR7aW5zdHJ1Y3RvckZpbGVDbGFzc31cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5maWxlbmFtZSgpID09PSAnJHtmaWxlbmFtZX0nfSxcbiAgICAgICAgICAgICAgICBjbGljazogZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCAnJHtmaWxlbmFtZX0nKSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAoISR7aGlkZUlmRW1wdHl9IHx8IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCcke2ZpbGVuYW1lfScpKSAmJiAke2hpZGVJZk5vdEluc3RydWN0b3J9XCI+XG4gICAgICAgICAgICAke2ZyaWVuZGx5TmFtZX08L2E+XG4gICAgPC9saT5gO1xufTtcblxuZXhwb3J0IGxldCBGSUxFU19IVE1MID0gYFxuPGRpdiBjbGFzcz1cImJsb2NrcHktcGFuZWwgYmxvY2tweS1maWxlc1wiXG4gICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuZmlsZXMudmlzaWJsZSwgY2xhc3M6IHVpLmZpbGVzLndpZHRoXCI+XG48dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIiByb2xlPVwidGFibGlzdFwiPlxuXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgPHN0cm9uZz5WaWV3OiA8L3N0cm9uZz5cbiAgICA8L2xpPlxuXG4gICAgJHttYWtlVGFiKFwiYW5zd2VyLnB5XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiSW5zdHJ1Y3Rpb25zXCIpfVxuICAgICR7bWFrZVRhYihcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIiwgXCJTZXR0aW5nc1wiKX1cbiAgICAke21ha2VUYWIoXCJec3RhcnRpbmdfY29kZS5weVwiLCBcIlN0YXJ0aW5nIENvZGVcIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX3J1bi5weVwiLCBcIk9uIFJ1blwiKX1cbiAgICAke21ha2VUYWIoXCIhb25fY2hhbmdlLnB5XCIsIFwiT24gQ2hhbmdlXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ldmFsLnB5XCIsIFwiT24gRXZhbFwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIiwgXCJTYW1wbGUgU3VibWlzc2lvbnNcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXRhZ3MuYmxvY2tweVwiLCBcIlRhZ3NcIiwgdHJ1ZSl9XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHsnYmxvY2tweS1maWxlLWluc3RydWN0b3InOiAhZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmaWxlbmFtZSgpLnN0YXJ0c1dpdGgoJyYnKSB8fCAkcm9vdC5kaXNwbGF5Lmluc3RydWN0b3IoKSBcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lZGl0YWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgPCEtLSBrbyBmb3JlYWNoOiBhc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKClcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogJHJvb3QuZGlzcGxheS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaWxlbmFtZVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBrbyBmb3JlYWNoOiBzdWJtaXNzaW9uLmV4dHJhRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJHJvb3QudWkuZmlsZXMuZGlzcGxheUZpbGVuYW1lKGZpbGVuYW1lKCkpXCI+XG4gICAgICAgICAgICA8L2E+ICAgICAgICBcbiAgICAgICAgPC9saT5cbiAgICA8IS0tIC9rbyAtLT5cbiAgXG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gZHJvcGRvd25cIj5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiBocmVmPVwiI1wiIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIlxuICAgICAgICAgcm9sZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+QWRkIE5ldzwvYT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz9tb2NrX3VybHMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnP21vY2tfdXJscy5ibG9ja3B5JylcIj5VUkwgRGF0YTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/aW1hZ2VzLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz9pbWFnZXMuYmxvY2tweScpXCI+SW1hZ2VzPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJz90b29sYm94LmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz90b29sYm94LmJsb2NrcHknKVwiPlRvb2xib3g8L2E+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchdGFncy5ibG9ja3B5JylcIj5UYWdzPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5JylcIj5TYW1wbGUgU3VibWlzc2lvbnM8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogYXNzaWdubWVudC5vbkNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9jaGFuZ2UucHknKVwiPk9uIENoYW5nZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25FdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnIW9uX2V2YWwucHknKVwiPk9uIEV2YWw8L2E+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9wcmVmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfcHJlZml4LnB5JylcIj5BbnN3ZXIgUHJlZml4PC9hPlxuICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIWFuc3dlcl9zdWZmaXgucHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFhbnN3ZXJfc3VmZml4LnB5JylcIj5BbnN3ZXIgU3VmZml4PC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdzdGFydGluZycpXCI+U3RhcnRpbmcgRmlsZTwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICdpbnN0cnVjdG9yJylcIj5JbnN0cnVjdG9yIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3R1ZGVudCcpXCI+U3R1ZGVudCBGaWxlPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2xpPlxuICBcbjwvdWw+XG48L2Rpdj5cbmA7XG5cbmNvbnN0IE5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwgPSBgXG48Zm9ybT5cbjxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgIDwhLS0gRmlsZW5hbWUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiPkZpbGVuYW1lOjwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBGaWxldHlwZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIj5GaWxldHlwZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+PC9zcGFuPiAgICBcbiAgICA8L2Rpdj5cbiAgICA8IS0tIEluYWNjZXNzaWJsZSB0byBzdHVkZW50PyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodCBtdC0yXCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+TmFtZXNwYWNlOiA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNFwiPlxuICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1uYW1lc3BhY2VcIlxuICAgICAgICAgICAgaWQ9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiIVwiPkNvbXBsZXRlbHkgaW5hY2Nlc3NpYmxlPC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiP1wiPkhpZGRlbiBmcm9tIHN0dWRlbnQsIGFjY2Vzc2libGUgcHJvZ3JhbWF0aWNhbGx5PC9vcHRpb24+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJlwiPlZpc2libGUgdG8gc3R1ZGVudCwgYnV0IG5vdCBlZGl0YWJsZTwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPC9mb3JtPlxuYDtcblxuLyoqXG4gKiBGaWxlbmFtZXMgbGl2ZSBpbiBvbmUgb2YgZml2ZSBwb3NzaWJsZSBuYW1lc3BhY2VzOlxuICogIEluc3RydWN0b3IgKCEpOiBJbnZpc2libGUgdG8gdGhlIHN0dWRlbnQgdW5kZXIgYWxsIGNpcmN1bXN0YW5jZXNcbiAqICBTdGFydCBTcGFjZSAoXik6IFVzZWQgdG8gcmVzZXQgdGhlIHN0dWRlbnQgbmFtZXNwYWNlXG4gKiAgU3R1ZGVudCBTcGFjZSAoKTogVmlzaWJsZSB0byB0aGUgc3R1ZGVudCB3aGVuIGRpc3BsYXkuaGlkZUZpbGVzIGlzIG5vdCB0cnVlLCBhYmxlIHRvIGJlIGVkaXRlZFxuICogIEhpZGRlbiBTcGFjZSAoPyk6IE5vdCBkaXJlY3RseSB2aXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgYWNjZXNzaWJsZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiAgUmVhZC1vbmx5IFNwYWNlICgmKTogQW4gaW5zdHJ1Y3RvciBmaWxlIHR5cGUgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGlzIHVuZWRpdGFibGUgYnkgdGhlbVxuICogIFNlY3JldCBTcGFjZSAoJCk6IE5vdCB2aXNpYmxlIGZyb20gdGhlIG1lbnUgYXQgYWxsLCBzb21lIG90aGVyIG1lY2hhbmlzbSBjb250cm9scyBpdFxuICogIEdlbmVyYXRlZCBTcGFjZSAoKik6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBkZXN0cm95ZWQgYWZ0ZXIgRW5naW5lLkNsZWFyLiBDYW4gc2hhZG93IGFuIGFjdHVhbCBmaWxlLlxuICogIENvbmNhdGVuYXRlZCBTcGFjZSAoIyk6IFVzZWQgd2hlbiBidW5kbGluZyBhIHNwYWNlIGZvciB0aGUgc2VydmVyLlxuICovXG5cbmV4cG9ydCBsZXQgU1RBUlRJTkdfRklMRVMgPSBbXG4gICAgLy8gU3VibWlzc2lvblxuICAgIFwiYW5zd2VyLnB5XCIsXG4gICAgLy8gSW5zdHJ1Y3RvciBmaWxlc1xuICAgIFwiIWluc3RydWN0aW9ucy5tZFwiLFxuICAgIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiLFxuICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIixcbiAgICBcIiFvbl9ydW4ucHlcIixcbiAgICBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG5dO1xuXG5leHBvcnQgY29uc3QgQkFTSUNfTkVXX0ZJTEVTID0gW1xuICAgIFwiIW9uX2NoYW5nZS5weVwiLFxuICAgIFwiIW9uX2V2YWwucHlcIixcbiAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLFxuICAgIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgIFwiIXRhZ3MuYmxvY2tweVwiLFxuICAgIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsXG4gICAgXCIhYW5zd2VyX3ByZWZpeC5weVwiLFxuICAgIFwiIWFuc3dlcl9zdWZmaXgucHlcIlxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNob21wU3BlY2lhbEZpbGUoZmlsZW5hbWUpIHtcbiAgICBpZiAoXCIhXj8mJCojXCIuaW5jbHVkZXMoZmlsZW5hbWVbMF0pKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZS5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxufVxuXG5jb25zdCBJTlNUUlVDVE9SX0RJUkVDVE9SWSA9IFwiX2luc3RydWN0b3IvXCI7XG5jb25zdCBTVFVERU5UX0RJUkVDVE9SWSA9IFwiX3N0dWRlbnQvXCI7XG5cbmNvbnN0IFNlYXJjaE1vZGVzID0ge1xuICAgIEVWRVJZV0hFUkU6IFwiRVZFUllXSEVSRVwiLFxuICAgIFNUQVJUX1dJVEhfSU5TVFJVQ1RPUjogXCJTVEFSVF9XSVRIX0lOU1RSVUNUT1JcIixcbiAgICBPTkxZX1NUVURFTlRfRklMRVM6IFwiT05MWV9TVFVERU5UX0ZJTEVTXCJcbn07XG5cbmNvbnN0IERFTEVUQUJMRV9TSU1QTEVfRklMRVMgPSBbXCIhb25fY2hhbmdlLnB5XCIsIFwiIW9uX2V2YWwucHlcIl07XG5cbmV4cG9ydCBjb25zdCBVTkRFTEVUQUJMRV9GSUxFUyA9IFtcImFuc3dlci5weVwiLCBcIiFpbnN0cnVjdGlvbnMubWRcIiwgXCIhYXNzaWdubWVudF9zZXR0aW5ncy5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCIhb25fcnVuLnB5XCIsIFwiJHNldHRpbmdzLmJsb2NrcHlcIl07XG5cbmV4cG9ydCBjb25zdCBVTlJFTkFNQUJMRV9GSUxFUyA9IFtcImFuc3dlci5weVwiLCBcIiFpbnN0cnVjdGlvbnMubWRcIiwgXCIhYXNzaWdubWVudF9zZXR0aW5ncy5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCIhb25fcnVuLnB5XCIsIFwiJHNldHRpbmdzLmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFvbl9jaGFuZ2UucHlcIiwgXCIhb25fZXZhbC5weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiP21vY2tfdXJscy5ibG9ja3B5XCIsIFwiP3Rvb2xib3guYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIXRhZ3MuYmxvY2tweVwiLCBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIWFuc3dlcl9wcmVmaXgucHlcIiwgXCIhYW5zd2VyX3N1ZmZpeC5weVwiXTtcblxuY2xhc3MgQmxvY2tQeUZpbGUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cyB8fCBcIlwiO1xuICAgICAgICB0aGlzLm93bmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIHtcImZpbGVuYW1lXCI6IGtvLm9ic2VydmFibGUoZmlsZW5hbWUpLCBjb250ZW50czoga28ub2JzZXJ2YWJsZShjb250ZW50cyB8fCBcIlwiKX07XG59XG5cbmZ1bmN0aW9uIG1ha2VNb2NrTW9kZWxGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgIHJldHVybiB7IGZpbGVuYW1lOiAoKSA9PiBmaWxlbmFtZSwgY29udGVudHM6ICgpID0+IGNvbnRlbnRzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ29uY2F0ZW5hdGVkRmlsZShjb25jYXRlbmF0ZWRGaWxlLCBtb2RlbEZpbGVMaXN0KSB7XG4gICAgaWYgKGNvbmNhdGVuYXRlZEZpbGUpIHtcbiAgICAgICAgbGV0IGZpbGVzID0gSlNPTi5wYXJzZShjb25jYXRlbmF0ZWRGaWxlKTtcbiAgICAgICAgbGV0IG1vZGVsRmlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gZmlsZXMpIHtcbiAgICAgICAgICAgIGlmIChmaWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtb2RlbEZpbGVzLnB1c2gobWFrZU1vZGVsRmlsZShmaWxlbmFtZSwgZmlsZXNbZmlsZW5hbWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9maWxlcyA9IGZpbGVzLm1hcChmaWxlID0+IG1ha2VNb2RlbEZpbGUoZmlsZS5maWxlbmFtZSwgZmlsZS5jb250ZW50cykpO1xuICAgICAgICBpZiAobW9kZWxGaWxlTGlzdCkge1xuICAgICAgICAgICAgbW9kZWxGaWxlTGlzdChtb2RlbEZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbEZpbGVzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsRmlsZUxpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsZUxpc3QoW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1vZGVsRmlsZUxpc3QoKS5tYXAoZmlsZSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5maWxlbmFtZSgpLFxuICAgICAgICAgICAgY29udGVudHM6IGZpbGUuY29udGVudHMoKVxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsRmlsZUxpc3QpIHtcbiAgICByZXR1cm4ga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBtb2RlbEZpbGVMaXN0KCkuZm9yRWFjaChmaWxlID0+XG4gICAgICAgICAgICByZXN1bHRbZmlsZS5maWxlbmFtZSgpXSA9IGZpbGUuY29udGVudHMoKSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGRhdGFiYXNlIGxvZ2ljXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja1B5RmlsZVN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVzXyA9IHt9O1xuICAgICAgICB0aGlzLm1vdW50RmlsZXMoKTtcblxuICAgICAgICB0aGlzLndhdGNoTW9kZWwoKTtcbiAgICAgICAgdGhpcy53YXRjaGVzXyA9IHt9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiKSwgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpLCBtYWluLCB0aGlzKVxuICAgICAgICBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1maWxlLWluc3RydWN0b3JcIikudG9nZ2xlKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3Iuc3Vic2NyaWJlKCh2aXNpYmxpdHkpPT4ge1xuICAgICAgICAgICAgbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIpLnRvZ2dsZSh2aXNpYmxpdHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB3YXRjaEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKGZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHN0b3BXYXRjaGluZ0ZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIHdhdGNoTW9kZWwoKSB7XG4gICAgICAgIGxldCBmaWxlc3lzdGVtID0gdGhpcztcbiAgICAgICAgW3RoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMsXG4gICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlc10uZm9yRWFjaChmaWxlQXJyYXkgPT5cbiAgICAgICAgICAgIGZpbGVBcnJheS5zdWJzY3JpYmUoZnVuY3Rpb24oY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4gc2Vjb25kLnN0YXR1cy5sb2NhbGVDb21wYXJlKGZpcnN0LnN0YXR1cykpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RlbEZpbGUgPSBjaGFuZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgbmV3IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzeXN0ZW0ubmV3RmlsZShtb2RlbEZpbGUuZmlsZW5hbWUoKSwgbW9kZWxGaWxlLmNvbnRlbnRzKCksIG1vZGVsRmlsZS5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5ub3RpZnlXYXRjaGVzKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2Uuc3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBmaWxlc3lzdGVtLmRlbGV0ZUZpbGVMb2NhbGx5Xyhtb2RlbEZpbGUuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzeXN0ZW0ubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IG1vZGVsRmlsZS5maWxlbmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzeXN0ZW0ubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLCBcImFycmF5Q2hhbmdlXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gYW5zd2VyLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZmlyc3QgZWxlbWVudCBvZiBzdWJtaXNzaW9uLmNvZGUpXG4gICAgLy8gIW9uX3J1bi5weSwgIW9uX2NoYW5nZS5weSwgIW9uX2V2YWwucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZWxldmFudCBhc3NpZ25tZW50Ljx3aGF0ZXZlcj5cbiAgICAvLyBec3RhcnRpbmdfY29kZS5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGZpcnN0IGVsZW1lbnQgb2YgYXNzaWdubWVudC5zdGFydGluZ0NvZGVcbiAgICAvLyBed2hhdGV2ZXJcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZXN0IG9mIHRoZSBlbGVtZW50cyBvZiBhc3NpZ25tZW50LnN0YXJ0aW5nQ29kZVxuICAgIC8vICF3aGF0ZXZlciBvciA/d2hhdGV2ZXJcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBlbGVtZW50cyBvZiBhc3NpZ25tZW50LmV4dHJhRmlsZXNcbiAgICAvLyBPdGhlcndpc2U6XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gcmVzdCBvZiB0aGUgZWxlbWVudHMgb2Ygc3VibWlzc2lvbi5jb2RlXG4gICAgLyoqXG4gICAgICogTmV3IHNwZWNpYWwgZmlsZXMgbmVlZCB0byBiZSByZWdpc3RlcmVkIGhlcmVcbiAgICAgKiBAcGFyYW0gZmlsZSB7QmxvY2tQeUZpbGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvYnNlcnZlRmlsZV8oZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX3J1bi5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uUnVuO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX2NoYW5nZS5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIW9uX2V2YWwucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiXnN0YXJ0aW5nX2NvZGUucHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCI/bW9ja191cmxzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYW5zd2VyX3ByZWZpeC5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhdGFncy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudGFncztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiJHNldHRpbmdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuZGlzcGxheTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJeXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIiFcIikgfHxcbiAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCI/XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW5BcnJheV8oZmlsZSwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvYnNlcnZlSW5BcnJheV8oZmlsZSwgYXJyYXkpIHtcbiAgICAgICAgZmlsZS5vd25lciA9IGFycmF5O1xuICAgICAgICBsZXQgY29kZUJ1bmRsZSA9IGZpbGUub3duZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY29kZUJ1bmRsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVCdW5kbGVbaV0uZmlsZW5hbWUoKSA9PT0gZmlsZS5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gY29kZUJ1bmRsZVtpXS5jb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZS5oYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBuZXdGaWxlID0gbWFrZU1vZGVsRmlsZShmaWxlLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gbmV3RmlsZS5jb250ZW50cztcbiAgICAgICAgICAgIGFycmF5LnB1c2gobmV3RmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudEZpbGVzKCkge1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIl5zdGFydGluZ19jb2RlLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhb25fcnVuLnB5XCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB0aGlzLm5ld0ZpbGUoXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIpO1xuICAgIH1cblxuICAgIGRpc21vdW50RXh0cmFGaWxlcygpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmZpbGVzXykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFVOREVMRVRBQkxFX0ZJTEVTLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2F0Y2hlc19bbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN1Ym1pc3Npb24uY29kZVRPRE86IFNob3VsZG4ndCB3ZSBub3RpZnkgdGhlIFVJIHRoYXQgdGhlIGZpbGUgd2FzIGRlbGV0ZWQ/XG4gICAgfVxuXG4gICAgbmV3RmlsZShmaWxlbmFtZSwgY29udGVudHMsIG1vZGVsRmlsZSkge1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gdGhpcy5maWxlc18pIHtcbiAgICAgICAgICAgIC8vIEZpbGUgYWxyZWFkeSBleGlzdHMhIEp1c3QgdXBkYXRlIGl0cyBoYW5kbGVcbiAgICAgICAgICAgIGxldCBleGlzdGluZ0ZpbGUgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgICAgICBpZiAobW9kZWxGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVGaWxlXyhleGlzdGluZ0ZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0ZpbGUuaGFuZGxlID0gbW9kZWxGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpc3RpbmdGaWxlLmhhbmRsZShjb250ZW50cyB8fCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaWxlIGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICBsZXQgbmV3RmlsZSA9IG5ldyBCbG9ja1B5RmlsZSh0aGlzLm1haW4sIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXSA9IG5ld0ZpbGU7XG4gICAgICAgICAgICBpZiAobW9kZWxGaWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVGaWxlXyhuZXdGaWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZS5oYW5kbGUgPSBtb2RlbEZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0ZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdGaWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5oYW5kbGUoY29udGVudHMpO1xuICAgIH1cblxuICAgIHJlYWRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzX1tmaWxlbmFtZV0uaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgZ2V0RmlsZShmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58b2JqZWN0fSBUaGUgaW5mbyBhYm91dCB0aGUgZmlsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGRlbGV0ZWRcbiAgICAgKi9cbiAgICBkZWxldGVGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmIChERUxFVEFCTEVfU0lNUExFX0ZJTEVTLmluZGV4T2YoZmlsZW5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmRlbGV0ZUZpbGVMb2NhbGx5XyhmaWxlbmFtZSk7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjayB0byBldmVudHVhbGx5IGNhbGwgZGVsZXRlRmlsZUxvY2FsbHlfXG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIucmVtb3ZlKG1vZGVsRmlsZSA9PiBtb2RlbEZpbGUuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZUxvY2FsbHlfKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5maWxlc19bZmlsZW5hbWVdO1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay5kZWxldGVkKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cblxuICAgIHJlbmFtZUZpbGUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgICBpZiAoVU5SRU5BTUFCTEVfRklMRVMuaW5kZXhPZihzb3VyY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjayB0byBldmVudHVhbGx5IGNhbGwgZGVsZXRlRmlsZUxvY2FsbHlfXG4gICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV0ub3duZXIucmVtb3ZlKG1vZGVsRmlsZSA9PiBtb2RlbEZpbGUuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm90aWZ5V2F0Y2hlcyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lIGluIHRoaXMud2F0Y2hlc18pIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZS5maWxlbmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay51cGRhdGVkKGZpbGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGUobmFtZSwgc3R1ZGVudFNlYXJjaCkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiBUaGlzIGlzIGNhbGxlZCBxdWl0ZSBhIGJpdCBieSB0aGUgSW1wb3J0IG1lY2hhbmlzbSwgbWlnaHQgbmVlZFxuICAgICAgICAgICAgICB0byBvcHRpbWl6ZSBpdCBzb21lIG1vcmUuIERvIHRpbWluZyB0ZXN0cy5cblxuICAgICAgICBmaWxlcy4qXG4gICAgICAgIF9pbnN0cnVjdG9yL2ZpbGVzLipcbiAgICAgICAgX3N0dWRlbnQvZmlsZXMuKlxuXG4gICAgICAgIElmIGEgc3R1ZGVudCBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgdGhlIFwiP1wiLCBcIiZcIiwgXCIqXCIsIFwiXCIgbmFtZXNwYWNlc1xuICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgIElmIGFuIGluc3RydWN0b3Igc2VhcmNoZXMgZm9yIGEgZmlsZSwgaXQgY2hlY2tzIFwiIVwiLCBcIl5cIiwgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBUbyBleHBsaWNpdGx5IHNlYXJjaCBpbnN0cnVjdG9yIG5hbWVzcGFjZXMgZmlyc3RcbiAgICAgICAgICAgICAgICBpbXBvcnQgX2luc3RydWN0b3IuaGVscGVyID0+IFwiLi9pbnN0cnVjdG9yL2hlbHBlci5weVwiXG4gICAgICAgICAgICAgICAgb3BlbihcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIikgPT4gXCJfaW5zdHJ1Y3Rvci9leHRlcm5hbC5qc29uXCJcbiAgICAgICAgICAgIHRvIGFsbG93IHN0dWRlbnQgZmlsZXMgdG8gb3ZlcnJpZGU6XG4gICAgICAgICAgICAgICAgaW1wb3J0IGhlbHBlciA9PiBcIi4vaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiZXh0ZXJuYWwuanNvblwiKSA9PiBcImV4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gb25seSBjaGVjayBzdHVkZW50IGZpbGVzLCBwcmVwZW5kIHdpdGggX3N0dWRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIENob3Agb2ZmIHN0YXJ0aW5nIFwiLi9cIlxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRTtcbiAgICAgICAgLy8gU2hvdWxkIHRoZSBzZWFyY2ggYmUgc3RhcnQgd2l0aCBpbnN0cnVjdG9yIHNpZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoSU5TVFJVQ1RPUl9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShJTlNUUlVDVE9SX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBsaW1pdGVkIHRvIHRoZSBzdHVkZW50IG1vZGU/XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoU1RVREVOVF9ESVJFQ1RPUlkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZShTVFVERU5UX0RJUkVDVE9SWS5sZW5ndGgpO1xuICAgICAgICAgICAgc2VhcmNoTW9kZSA9IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUztcbiAgICAgICAgfSBlbHNlIGlmIChzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBpbnN0cnVjdG9yIHZlcnNpb25zXG4gICAgICAgIGxldCBleHRyYVN0dWRlbnRGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhSW5zdHJ1Y3RvckZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKTtcbiAgICAgICAgbGV0IGV4dHJhU3RhcnRpbmdGaWxlcyA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcygpO1xuICAgICAgICAvLyBDaGVjayBzcGVjaWFsIGZpbGVzIChUT0RPOiBob3cgd291bGQgYW4gaW5zdHJ1Y3RvciBhY2Nlc3MgXCIuL19pbnN0cnVjdG9yL2Fuc3dlci5weVwiP1xuICAgICAgICBsZXQgc3BlY2lhbEZpbGUgPSB0aGlzLnNlYXJjaEZvclNwZWNpYWxGaWxlc18obmFtZSwgc2VhcmNoTW9kZSk7XG4gICAgICAgIGlmIChzcGVjaWFsRmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lhbEZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgbG9va2luZyB0aHJvdWdoIHBvc3NpYmxlIGZpbGVzXG4gICAgICAgIGxldCBzdHVkZW50VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIG5hbWUpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdHVkZW50RmlsZXMsIFwiKlwiK25hbWUpO1xuICAgICAgICBsZXQgZGVmYXVsdFZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiZcIituYW1lKTtcbiAgICAgICAgbGV0IGhpZGRlblZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIj9cIituYW1lKTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGhpZGRlblZlcnNpb24sIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc3RydWN0b3JWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYUluc3RydWN0b3JGaWxlcywgXCIhXCIrbmFtZSk7XG4gICAgICAgIGxldCBzdGFydGluZ1ZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhU3RhcnRpbmdGaWxlcywgXCJeXCIrbmFtZSk7XG4gICAgICAgIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5TVEFSVF9XSVRIX0lOU1RSVUNUT1IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdERlZmluZWRWYWx1ZShpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuRVZFUllXSEVSRSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGRlZmF1bHRWZXJzaW9uLCBzdHVkZW50VmVyc2lvbiwgZ2VuZXJhdGVkVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdG9yVmVyc2lvbiwgaGlkZGVuVmVyc2lvbiwgc3RhcnRpbmdWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlYXJjaEZvckZpbGVJbkxpc3RfKG1vZGVsTGlzdCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbW9kZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZWxMaXN0W2ldLmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNlYXJjaEZvclNwZWNpYWxGaWxlc18oZmlsZW5hbWUsIHNlYXJjaE1vZGUpIHtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLk9OTFlfU1RVREVOVF9GSUxFUykge1xuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3IvYW5zd2VyLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnN3ZXIucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9ydW4ucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fY2hhbmdlLnB5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VNb2NrTW9kZWxGaWxlKFwiX2luc3RydWN0b3Ivb25fY2hhbmdlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9ldmFsLm1kXCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnMubWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9pbnN0cnVjdGlvbnMubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaW5zdHJ1Y3Rpb25zKCkpO1xuICAgICAgICAgICAgY2FzZSBcInN0YXJ0aW5nX2NvZGUucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9zdGFydGluZ19jb2RlLnB5XCIsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5ld0ZpbGVEaWFsb2coa2luZCkge1xuICAgICAgICBsZXQgYm9keSA9ICQoTkVXX0lOU1RSVUNUT1JfRklMRV9ESUFMT0dfSFRNTCk7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIik7XG4gICAgICAgIGxldCBmaWxldHlwZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZXR5cGVcIik7XG4gICAgICAgIGxldCBuYW1lc3BhY2UgPSBib2R5LmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiKTtcbiAgICAgICAgbGV0IGV4dGVuc2lvblJlZ2V4ID0gLyg/OlxcLihbXi5dKykpPyQvO1xuICAgICAgICBmaWxlbmFtZS5vbihcImlucHV0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbnNpb25SZWdleC5leGVjKGZpbGVuYW1lLnZhbCgpKVsxXTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJObyBleHRlbnNpb25cIiA6IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3JGcm9tRXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgICAgICAgICBmaWxldHlwZS50ZXh0KGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJpbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBuYW1lc3BhY2UudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwic3RhcnRpbmdcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUudmFsKCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHByZWZpeCtmaWxlbmFtZS52YWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0ZpbGUoZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBib2R5LnN1Ym1pdCgoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgeWVzKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jb25maXJtKFwiTWFrZSBOZXcgRmlsZVwiLCBib2R5LCB5ZXMsICgpPT57fSwgXCJBZGRcIik7XG4gICAgfVxufSIsIi8vVE9ETzogTW92ZSBnZXQgbGluayBkb3duIHRvIGZvb3RlciwgcmVtb3ZlIHZlcnRpY2FsIGJhciBmcm9tIHF1aWNrLW1lbnVcbmV4cG9ydCBsZXQgRk9PVEVSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiY29sLW1kLTEyIGJsb2NrcHktcGFuZWwgYmxvY2tweS1zdGF0dXNcIj5cbiAgICA8ZGl2PlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkQXNzaWdubWVudCcpXCI+TG9hZCBBc3NpZ25tZW50XG4gICAgICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5Lmluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgY2xhc3M9XCJibG9ja3B5LWZvcmNlLWxvYWQtYXNzaWdubWVudC1maWxlIGJsb2NrcHktaGlkZGVuLWZpbGVcIlxuICAgICAgICAgICAgYWNjZXB0PVwiYXBwbGljYXRpb24vSlNPTlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuc2VydmVyLmZvcmNlLmxvYWRBc3NpZ25tZW50fVwiPlxuICAgICAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwvbGFiZWw+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdzYXZlQXNzaWdubWVudCcpXCI+U2F2ZSBBc3NpZ25tZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9hZEZpbGUnKVwiPkxvYWQgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVGaWxlJylcIj5TYXZlIEZpbGU8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRGF0YXNldCcpXCI+TG9hZCBEYXRhc2V0PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnbG9nRXZlbnQnKVwiPkxvZyBFdmVudDwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3VwZGF0ZVN1Ym1pc3Npb24nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuc2VydmVyLmZvcmNlLnVwZGF0ZVN1Ym1pc3Npb25cIj5VcGRhdGUgU3VibWlzc2lvbjwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ29uRXhlY3V0aW9uJylcIj5FeGVjdXRpb248L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZXJ2ZXIubWVzc2FnZXNcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHNwYW4+VXNlcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5pZFwiPjwvc3Bhbj4gKDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIubmFtZVwiPjwvc3Bhbj4sIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVzZXIucm9sZVwiPjwvc3Bhbj4pPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuPkNvdXJzZTogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5jb3Vyc2VJZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Hcm91cDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5ncm91cElkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkFzc2lnbm1lbnQ6IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQuaWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudCBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBhc3NpZ25tZW50LnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbjogXG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLmlkXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIChPd25lciBJRDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkKClcIj48L3NwYW4+KVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+U3VibWlzc2lvbiBWZXJzaW9uOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLnZlcnNpb25cIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+RWRpdG9yIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGRpc3BsYXkuZWRpdG9yVmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7IiwiLy8gVE9ETzogU2hvdWxkIGRpc2FibGUgYnV0dG9ucyBpZiB3ZSBjYW4ndCBhY3RpdmF0ZSB0aGVtLlxuXG5leHBvcnQgY29uc3QgSElTVE9SWV9UT09MQkFSX0hUTUwgPSBgXG48ZGl2IGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXRvb2xiYXIgY29sLW1kLTEyXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5oaXN0b3J5TW9kZVwiPlxuXG4gICAgPGZvcm0gY2xhc3M9XCJmb3JtLWlubGluZVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYmxvY2tweS1oaXN0b3J5LXN0YXJ0IGJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3Rvcnkuc3RhcnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1iYWNrd2FyZCc+PC9zcGFuPiBTdGFydFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgbXItMlwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkucHJldmlvdXNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj4gUHJldmlvdXNcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxzZWxlY3QgY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3IgZm9ybS1jb250cm9sIGN1c3RvbS1zZWxlY3QgbXItMlwiIGFyaWEtdGl0bGU9XCJIaXN0b3J5IFNlbGVjdG9yXCI+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS51c2VcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZmlsZS1pbXBvcnQnPjwvc3Bhbj4gVXNlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5uZXh0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj4gTmV4dFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm1vc3RSZWNlbnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtc3RlcC1mb3J3YXJkJz48L3NwYW4+IE1vc3QgUmVjZW50XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZm9ybT5cbjwvZGl2PlxuYDtcblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGRpc3BsYXlpbmcgdGhlIHVzZXIncyBjb2RpbmcgbG9ncyAodGhlaXIgaGlzdG9yeSkuXG4gKiBBIGxpZ2h0d2VpZ2h0IGNvbXBvbmVudCwgaXRzIG9ubHkgam9iIGlzIHRvIG9wZW4gYSBkaWFsb2cuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUhpc3Rvcnl9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHlIaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGxvYWQoaGlzdG9yeSkge1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICB0aGlzLmVkaXRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICQoXCIuYmxvY2tweS1oaXN0b3J5LXNlbGVjdG9yXCIpLmVtcHR5KCk7XG4gICAgICAgIGxldCBlZGl0SWQgPSAwO1xuICAgICAgICBoaXN0b3J5XG4gICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gKFxuICAgICAgICAgICAgICAgICFlbnRyeS5maWxlX3BhdGguc3RhcnRzV2l0aChcIl9pbnN0cnVjdG9yLlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkNvbXBpbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5ldmVudF90eXBlICE9PSBcIkludGVydmVudGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJYLVN1Ym1pc3Npb24uTE1TXCIpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldmVudF90eXBlID0gUkVNQVBfRVZFTlRfVFlQRVNbZW50cnkuZXZlbnRfdHlwZV0gfHwgZW50cnkuZXZlbnRfdHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGlzcGxheWVkID0gcHJldHR5UHJpbnREYXRlVGltZShlbnRyeS5jbGllbnRfdGltZXN0YW1wKSArXCIgLSBcIitldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlID0gKGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiRmlsZS5FZGl0XCIpO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb24gPSAkKFwiPG9wdGlvbj48L29wdGlvbj5cIiwge3RleHQ6IGRpc3BsYXllZCwgZGlzYWJsZWQ6IGRpc2FibGV9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VkaXRFdmVudChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmF0dHIoXCJ2YWx1ZVwiLCBlZGl0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRFdmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRJZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmFwcGVuZChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGVkaXRJZC0xKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IuY2hhbmdlKChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vdmVUb1N0YXJ0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCgwKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlUHJldmlvdXMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWF4KDAsIGN1cnJlbnRJZC0xKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKE1hdGgubWluKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSwgY3VycmVudElkKzEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlVG9Nb3N0UmVjZW50KCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnZhbCh0aGlzLmVkaXRFdmVudHMubGVuZ3RoLTEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVkaXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uc2V0Q29kZSh0aGlzLmVkaXRFdmVudHNbY3VycmVudElkXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SWQgPSBwYXJzZUludCh0aGlzLnNlbGVjdG9yLnZhbCgpLCAxMCk7XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuZmlsZS5oYW5kbGUoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VkaXRFdmVudChlbnRyeSkge1xuICAgICAgICByZXR1cm4gKChlbnRyeS5ldmVudF90eXBlID09PSBcIkZpbGUuRWRpdFwiIHx8XG4gICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5DcmVhdGVcIikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZSgpID09PSBlbnRyeS5maWxlX3BhdGgpO1xuICAgIH1cblxufVxuXG5jb25zdCBSRU1BUF9FVkVOVF9UWVBFUyA9IHtcbiAgICBcIlNlc3Npb24uU3RhcnRcIjogXCJCZWdhbiBzZXNzaW9uXCIsXG4gICAgXCJYLUlQLkNoYW5nZVwiOiBcIkNoYW5nZWQgSVAgYWRkcmVzc1wiLFxuICAgIFwiRmlsZS5FZGl0XCI6IFwiRWRpdGVkIGNvZGVcIixcbiAgICBcIkZpbGUuQ3JlYXRlXCI6IFwiU3RhcnRlZCBhc3NpZ25tZW50XCIsXG4gICAgXCJSdW4uUHJvZ3JhbVwiOiBcIlJhbiBwcm9ncmFtXCIsXG4gICAgXCJDb21waWxlLkVycm9yXCI6IFwiU3ludGF4IGVycm9yXCIsXG4gICAgXCJYLVN1Ym1pc3Npb24uTE1TXCI6IFwiVXBkYXRlZCBncmFkZVwiXG59O1xuXG5jb25zdCBtb250aE5hbWVzID0gW1xuICAgIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsXG4gICAgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLFxuICAgIFwiQXVnXCIsIFwiU2VwdFwiLCBcIk9jdFwiLFxuICAgIFwiTm92XCIsIFwiRGVjXCJcbl07XG5jb25zdCB3ZWVrRGF5cyA9IFtcbiAgICBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLFxuICAgIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsXG4gICAgXCJTYXRcIlxuXTtcblxuZnVuY3Rpb24gaXNTYW1lRGF5KGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QuZ2V0RGF0ZSgpID09PSBzZWNvbmQuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGZpcnN0LmdldE1vbnRoKCkgPT09IHNlY29uZC5nZXRNb250aCgpICYmXG4gICAgICAgIGZpcnN0LmdldEZ1bGxZZWFyKCkgPT09IHNlY29uZC5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBhIGRhdGUvdGltZSBzdHJpbmcgYW5kIHJld3JpdGUgaXQgYXMgc29tZXRoaW5nXG4gKiBtb3JlIGh1bWFuIHJlYWRhYmxlLlxuICogQHBhcmFtIHtTdHJpbmd9IHRpbWVTdHJpbmcgLSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgKFwiWVlZWU1NREQgSEhNTVNTXCIpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgaHVtYW4tcmVhZGFibGUgdGltZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByZXR0eVByaW50RGF0ZVRpbWUodGltZVN0cmluZykge1xuICAgIC8qbGV0IHllYXIgPSB0aW1lU3RyaW5nLnNsaWNlKDAsIDQpLFxuICAgICAgICBtb250aCA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoNCwgNiksIDEwKS0xLFxuICAgICAgICBkYXkgPSB0aW1lU3RyaW5nLnNsaWNlKDYsIDgpLFxuICAgICAgICBob3VyID0gdGltZVN0cmluZy5zbGljZSg5LCAxMSksXG4gICAgICAgIG1pbnV0ZXMgPSB0aW1lU3RyaW5nLnNsaWNlKDExLCAxMyksXG4gICAgICAgIHNlY29uZHMgPSB0aW1lU3RyaW5nLnNsaWNlKDEzLCAxNSk7Ki9cbiAgICAvLyBUT0RPOiBIYW5kbGUgdGltZXpvbmVzIGNvcnJlY3RseVxuICAgIGlmICh0aW1lU3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5kZWZpbmVkIFRpbWVcIjtcbiAgICB9XG4gICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHBhc3QgPSBuZXcgRGF0ZShwYXJzZUludCh0aW1lU3RyaW5nLCAxMCkpO1xuICAgIGlmIChpc1NhbWVEYXkobm93LCBwYXN0KSkge1xuICAgICAgICByZXR1cm4gXCJUb2RheSBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXlTdHIgPSB3ZWVrRGF5c1twYXN0LmdldERheSgpXTtcbiAgICAgICAgbGV0IG1vbnRoU3RyID0gbW9udGhOYW1lc1twYXN0LmdldE1vbnRoKCldO1xuICAgICAgICBsZXQgZGF0ZSA9IGRheVN0ciArIFwiLCBcIiArIG1vbnRoU3RyICsgXCIgXCIgKyBwYXN0LmdldERhdGUoKTtcbiAgICAgICAgaWYgKG5vdy5nZXRGdWxsWWVhcigpID09PSBwYXN0LmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlICsgXCIsIFwiK3Bhc3QuZ2V0RnVsbFllYXIoKSArIFwiIGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBPcGVucyB0aGUgaGlzdG9yeSBkaWFsb2cgYm94LiBUaGlzIHJlcXVpcmVzIGEgdHJpcCB0byB0aGUgc2VydmVyIGFuZFxuICogb2NjdXJzIGFzeW5jaHJvbm91c2x5LiBUaGUgdXNlcnMnIGNvZGUgaXMgc2hvd24gaW4gcHJlZm9ybWF0dGVkIHRleHRcbiAqIHRhZ3MgKG5vIGNvZGUgaGlnaGxpZ2h0aW5nIGN1cnJlbnRseSkgYWxvbmcgd2l0aCB0aGUgdGltZXN0YW1wLlxuICovXG5CbG9ja1B5SGlzdG9yeS5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFsb2cgPSB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2c7XG4gICAgdmFyIGJvZHkgPSBcIjxwcmU+YSA9IDA8L3ByZT5cIjtcbiAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIuZ2V0SGlzdG9yeShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBib2R5ID0gZGF0YS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChjb21wbGV0ZSwgZWxlbSkgeyBcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZV9zdHIgPSBwcmV0dHlQcmludERhdGVUaW1lKGVsZW0udGltZSk7XG4gICAgICAgICAgICB2YXIgbmV3X2xpbmUgPSBcIjxiPlwiK2NvbXBsZXRlX3N0citcIjwvYj48YnI+PHByZT5cIitlbGVtLmNvZGUrXCI8L3ByZT5cIjtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZStcIlxcblwiK25ld19saW5lO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgZGlhbG9nLnNob3coXCJXb3JrIEhpc3RvcnlcIiwgYm9keSwgZnVuY3Rpb24oKSB7fSk7XG4gICAgfSk7XG59OyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBtYWluIEhUTUwgb2YgQmxvY2tQeSBpbnRlcmZhY2UsIGFuZCBoZWxwZXIgZnVuY3Rpb25zLlxuICogQ29tYmluZXMgYSBsb3Qgb2YgSFRNTCBmcm9tIGNvbXBvbmVudHMuXG4gKlxuICogSGVyZSdzIHRoZSBsYXlvdXQ6XG4gKiAgUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudVxuICogIFJvdyAyOiBDb25zb2xlIGFuZCBGZWVkYmFja1xuICogIFJvdyAzOiBGaWxlIE5hdmlnYXRpb25cbiAqICBSb3cgNDogVmlldyBSb3dcbiAqICBSb3cgNTogRm9vdGVyIFJvd1xuICovXG5cbmltcG9ydCB7VFJBQ0VfSFRNTH0gZnJvbSBcInRyYWNlLmpzXCI7XG5pbXBvcnQge0RJQUxPR19IVE1MfSBmcm9tIFwiZGlhbG9nLmpzXCI7XG5pbXBvcnQge0ZFRURCQUNLX0hUTUx9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtGSUxFU19IVE1MfSBmcm9tIFwiZmlsZXMuanNcIjtcbmltcG9ydCB7Rk9PVEVSX0hUTUx9IGZyb20gXCJmb290ZXIuanNcIjtcbmltcG9ydCB7RURJVE9SU19IVE1MfSBmcm9tIFwiZWRpdG9ycy5qc1wiO1xuaW1wb3J0IHtDT05TT0xFX0hUTUx9IGZyb20gXCJjb25zb2xlLmpzXCI7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBsYXlvdXQgb3B0aW9ucyBvZiB0aGUgcGFuZXMgaW4gdGhlIHNlY29uZCByb3cgb2YgdGhlIGxheW91dC5cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBsZXQgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zID0ge1xuICAgIEZFRURCQUNLOiBcImZlZWRiYWNrXCIsXG4gICAgVFJBQ0U6IFwidHJhY2VcIixcbiAgICBOT05FOiBcIm5vbmVcIlxufTtcblxuLyoqXG4gKiBTZXR1cCBhbnkgYWRkaXRpb25hbCBLbm9ja291dCBzdWJzY3JpcHRpb25zIHRvIGZpcmUgb24gaW50ZXJmYWNlIGNoYW5nZXMuXG4gKiBAcGFyYW0gc2VsZlxuICogQHBhcmFtIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXh0cmFJbnRlcmZhY2VTdWJzY3JpcHRpb25zKHNlbGYsIG1vZGVsKSB7XG4gICAgLy8gSGlnaGxpZ2h0IE1hcmtkb3duIHdoZW4gaW5zdHJ1Y3Rpb25zIHVwZGF0ZVxuICAgIGxldCBoaWdobGlnaHRUaW1lb3V0ID0gbnVsbDtcbiAgICBtb2RlbC51aS5pbnN0cnVjdGlvbnMuY3VycmVudC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhpZ2hsaWdodFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1pbnN0cnVjdGlvbnMgcHJlIGNvZGVcIikubWFwKCAoaSwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGxqcy5oaWdobGlnaHRCbG9jayhibG9jayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNDAwKTtcbiAgICB9KTtcbiAgICAvLyBQcm92aWRlIEZ1bGxzY3JlZW4gc3VwcG9ydFxuICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbi5zdWJzY3JpYmUoKGlzRnVsbHNjcmVlbikgPT4ge1xuICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uUmVxdWVzdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgLy8gTk9URTogbmF2aWdhdGlvblVJIGNvdWxkIGFsbG93IHVzIHRvIGZvcmNlIGNvbnRyb2xzIHRvIHNob3dcbiAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLnBhcmVudCgpWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXJyb3JcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsICBcIlwiKTtcbiAgICAgICAgICAgICAgICBhbGVydChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5TdWNjZXNzXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuY3NzKFwib3ZlcmZsb3cteVwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLkV4aXRcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVsbHNjcmVlbi50b1N0cmluZygpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LmZ1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8gVE9ETzogR2V0IHNoYXJlYWJsZSBsaW5rIGJ1dHRvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludGVyZmFjZShtYWluKSB7XG4gICAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9J2Jsb2NrcHktY29udGVudCBjb250YWluZXItZmx1aWQnPlxuXG4gICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgJHtESUFMT0dfSFRNTH1cbiAgICBcbiAgICA8IS0tIEhpZGRlbiBDYXB0dXJlIENhbnZhcyAtLT5cbiAgICA8Y2FudmFzIGlkPSdjYXB0dXJlLWNhbnZhcycgY2xhc3M9J2Qtbm9uZScgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2FudmFzPlxuICAgIFxuICAgIDwhLS0gUm93IDE6IEhlYWRlciBhbmQgUXVpY2sgTWVudSAtLT5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXQoKVwiPlxuICAgICAgICAgXG4gICAgICAgICA8IS0tIERlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTkgYmxvY2tweS1wYW5lbCBibG9ja3B5LWhlYWRlcidcbiAgICAgICAgICAgICAgIHJvbGU9J2hlYWRpbmcnIGFyaWEtbGFiZWw9J0Fzc2lnbm1lbnQgRGVzY3JpcHRpb24nPlxuICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIEFzc2lnbm1lbnQgTmFtZSAtLT5cbiAgICAgICAgICAgIDxzcGFuIHJvbGU9J2hlYWRpbmcnIGFyaWEtbGV2ZWw9JzEnXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrcHktbmFtZVwiPlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+QmxvY2tQeTogPC9zdHJvbmc+IFxuICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogYXNzaWdubWVudC5uYW1lJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gUmVzZXQgSW5zdHJ1Y3Rpb25zIEJ1dHRvbiAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWluc3RydWN0aW9ucy1yZXNldFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkuaW5zdHJ1Y3Rpb25zLmlzQ2hhbmdlZFwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwiZmxvYXQtcmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuaW5zdHJ1Y3Rpb25zLnJlc2V0XCJcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgICAgICBSZXNldCBpbnN0cnVjdGlvbnM8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBJbnN0cnVjdGlvbnMgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LWluc3RydWN0aW9ucydcbiAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogdWkuaW5zdHJ1Y3Rpb25zLmN1cnJlbnRcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9J2NvbC1tZC0zIGJsb2NrcHktcGFuZWwgYmxvY2tweS1xdWljay1tZW51J1xuICAgICAgICAgICAgIHJvbGU9J21lbnViYXInIGFyaWEtbGFiZWw9J1F1aWNrIE1lbnUnIHRpdGxlPVwiUXVpY2sgTWVudVwiPlxuICAgICAgICAgICAgPCEtLSBHZXQgU2hhcmVhYmxlIExpbmsgLS0+XG4gICAgICAgICAgICA8IS0tPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCI+XG4gICAgICAgICAgICAgICAgR2V0IHNoYXJlYWJsZSBsaW5rPC9idXR0b24+LS0+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5tZW51LmlzU3VibWl0dGVkXCI+XG4gICAgICAgICAgICAgICAgWW91ciBzdWJtaXNzaW9uIGlzIHJlYWR5IHRvIGJlIHJldmlld2VkITwvc3Bhbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkubWVudS5jYW5NYXJrU3VibWl0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdWkubWVudS50ZXh0TWFya1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5tZW51LmNsaWNrTWFya1N1Ym1pdHRlZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBWaWV3IGFzIGluc3RydWN0b3IgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLnJvbGUuaXNHcmFkZXJcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJcIiBpZD1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkuaW5zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LWFzLWluc3RydWN0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAgVmlldyBhcyBpbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBSZWFkb25seSBtb2RlIGZvciBzcHlpbmcgLS0+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtYmluZD1cImlmOiBzdWJtaXNzaW9uLm93bmVySWQoKSAhPSB1c2VyLmlkKClcIj5cbiAgICAgICAgICAgICAgICBPd25lcjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogc3VibWlzc2lvbi5vd25lcklkXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cImJsb2NrcHktcmVhZC1vbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkucmVhZE9ubHlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktcmVhZC1vbmx5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkb25seT9cbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gRnVsbHNjcmVlbiBidXR0b24gLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5tZW51LmNsaWNrRnVsbHNjcmVlblwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJGdWxsIFNjcmVlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMnIGRhdGEtYmluZD1cImNsYXNzOiB1aS5tZW51LnRleHRGdWxsc2NyZWVuXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIEVkaXQgUXVldWVkIElucHV0cyAtLT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUuZWRpdElucHV0cywgdmlzaWJsZTogdWkubWVudS5zaG93UXVldWVkSW5wdXRzXCIgdGl0bGU9XCJFZGl0IElucHV0c1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtbGlzdC1hbHQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPCEtLSBUb2dnbGUgSW1hZ2UgUmVuZGVyaW5nIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUudG9nZ2xlSW1hZ2VzXCIgdGl0bGU9XCJUb2dnbGUgSW1hZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtaW1hZ2VzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFBpbmsgQnVnIGZvciBhY3R1YWwgZXJyb3JzIC0tPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9ja3B5LXN0dWRlbnQtZXJyb3IgZmFzIGZhLWJ1Z1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cImhpZGRlbjogdWkubWVudS5zaG93Q2xvY2tcIiBjbGFzcz1cImJsb2NrcHktbWVudS1jbG9ja1wiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8IS0tIGtvIGlmOiB1aS5zbWFsbExheW91dCgpIC0tPlxuICAgIDwhLS0gU21hbGwgbGF5b3V0IFZpZXcgYXMgaW5zdHJ1Y3RvciAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiXG4gICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5yb2xlLmlzR3JhZGVyXCI+XG4gICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIlwiIGlkPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGRpc3BsYXkuaW5zdHJ1Y3RvclwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICBWaWV3IGFzIGluc3RydWN0b3JcbiAgICAgICAgPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIGtvIGlmOiB1aS5maWxlcy52aXNpYmxlKCkgLS0+XG4gICAgJHtGSUxFU19IVE1MfVxuICAgIDwhLS0gL2tvIC0tPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDxkaXYgY2xhc3M9J3Jvdyc+XG4gICAgPCEtLSBSb3cgMjogQ29uc29sZSBhbmQgRmVlZGJhY2sgLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuc2Vjb25kUm93LmlzQWxsVmlzaWJsZSAtLT5cbiAgICA8ZGl2IGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZWNvbmRSb3cud2lkdGhcIj5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICA8IS0tIENvbnNvbGUgLS0+XG4gICAgICAgICR7Q09OU09MRV9IVE1MfVxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwhLS0gVHJhY2UgLS0+XG4gICAgICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSAtLT5cbiAgICAgICAgJHtUUkFDRV9IVE1MfVxuICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSgpICYmICF1aS5zbWFsbExheW91dCgpIC0tPlxuICAgICR7RklMRVNfSFRNTH1cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyA0OiBWaWV3IFJvdyAtLT5cbiAgICAke0VESVRPUlNfSFRNTH1cbiAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICBcbiAgICA8IS0tIFJvdyA1OiBGb290ZXIgUm93IC0tPiAgICBcbiAgICA8IS0tIGtvIGlmOiB1aS5mb290ZXIudmlzaWJsZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICR7Rk9PVEVSX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG48L2Rpdj5cbiAgICBgO1xufSIsImltcG9ydCB7TG9jYWxTdG9yYWdlV3JhcHBlcn0gZnJvbSBcIi4vc3RvcmFnZVwiO1xuaW1wb3J0IHtsb2FkQXNzaWdubWVudFNldHRpbmdzLCBzYXZlQXNzaWdubWVudFNldHRpbmdzfSBmcm9tIFwiLi9lZGl0b3IvYXNzaWdubWVudF9zZXR0aW5nc1wiO1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgbGV0IFN0YXR1c1N0YXRlID0ge1xuICAgIFJFQURZOiBcInJlYWR5XCIsXG4gICAgQUNUSVZFOiBcImFjdGl2ZVwiLFxuICAgIFJFVFJZSU5HOiBcInJldHJ5aW5nXCIsXG4gICAgRkFJTEVEOiBcImZhaWxlZFwiLFxuICAgIE9GRkxJTkU6IFwib2ZmbGluZVwiXG59O1xuXG4vKipcbiAqIE9iamVjdCBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBleHRlcm5hbCBzZXJ2ZXJzLiBUaGlzIGluY2x1ZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG4gKiBzYXZpbmcgYW5kIGxvYWRpbmcgZmlsZXMsIGxvZ2dpbmcgZXZlbnRzLCBzYXZpbmcgY29tcGxldGlvbnMsIGFuZCByZXRyaWV2aW5nIGhpc3RvcnkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeVNlcnZlcn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeVNlcnZlcihtYWluKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcblxuICAgIC8vIFNhdmUgVVJMcyBsb2NhbGx5IGZvciBxdWlja2VyIGFjY2Vzc1xuICAgIHRoaXMudXJscyA9IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzO1xuXG4gICAgLy8gQWRkIHRoZSBMb2NhbFN0b3JhZ2UgY29ubmVjdGlvblxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKFwiQkxPQ0tQWVwiKTtcblxuICAgIC8vIEZhdWx0UmVzaXN0YW50Q2FjaGVcbiAgICB0aGlzLnF1ZXVlID0ge1xuICAgICAgICBcImxvZ0V2ZW50XCI6IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldERlZmF1bHQoXCJsb2dFdmVudFwiLCBcIltdXCIpKSxcbiAgICAgICAgXCJ1cGRhdGVTdWJtaXNzaW9uXCI6IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldERlZmF1bHQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFwiW11cIikpXG4gICAgfTtcbiAgICB0aGlzLk1BWF9RVUVVRV9TSVpFID0ge1xuICAgICAgICBcImxvZ0V2ZW50XCI6IDIwMCxcbiAgICAgICAgXCJ1cGRhdGVTdWJtaXNzaW9uXCI6IDUwXG4gICAgfTtcblxuICAgIHRoaXMuVElNRVJfREVMQVkgPSAxMDAwO1xuICAgIHRoaXMuRkFJTF9ERUxBWSA9IDIwMDA7XG5cbiAgICB0aGlzLnRpbWVycyA9IHt9O1xuXG4gICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgPSAwO1xuXG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMgPSBbXTtcbiAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB0aGlzLmNoZWNrQ2FjaGVzKCk7XG5cbiAgICB0aGlzLmFsdExvZ0VudHJ5ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgSVAgYWRkcmVzcyBoYXMgY2hhbmdlZCwgbG9nZ2luZyBhbiBldmVudCBpZiB0aGF0IG9jY3Vycy5cbiAqIEBwYXJhbSByZXNwb25zZVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jaGVja0lQID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJJUFwiKSkge1xuICAgICAgICAgICAgbGV0IG9sZElQID0gdGhpcy5zdG9yYWdlLmdldChcIklQXCIpO1xuICAgICAgICAgICAgaWYgKG9sZElQICE9PSByZXNwb25zZS5pcCkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBcIm9sZFwiOiBvbGRJUCxcbiAgICAgICAgICAgICAgICAgICAgXCJuZXdcIjogcmVzcG9uc2UuaXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbHRMb2dFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsdExvZ0VudHJ5KFwiWC1JUC5DaGFuZ2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nRXZlbnQoXCJYLUlQLkNoYW5nZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXCJJUFwiLCByZXNwb25zZS5pcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFwiSVBcIiwgcmVzcG9uc2UuaXApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZXJlIGhhdmUgYmVlbiBwcmV2aW91cyBmYWlsdXJlcyBjYWNoZWQsIGFuZCBpZiBzbyByZXRyaWVzIHRoZW0uXG4gKiBUT0RPOiB1cGRhdGVcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY2hlY2tDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVBc3NpZ25tZW50XCIpKTtcbiAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIFwiYXNzaWdubWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzYXZlQXNzaWdubWVudFwiLCB0aGlzLlRJTUVSX0RFTEFZKTtcbiAgICB9XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMuZm9yRWFjaCgoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5oYXMoXCJzYXZlRmlsZVwiICsgZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldChcInNhdmVGaWxlXCIgKyBmaWxlbmFtZSkpO1xuICAgICAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIHRoaXMuVElNRVJfREVMQVkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHNlcnZlciA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5xdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uIHB1c2hBbnlRdWV1ZWQocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlci5xdWV1ZVtlbmRwb2ludF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShzZXJ2ZXIucXVldWVbZW5kcG9pbnRdLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHNlcnZlci51cmxzW2VuZHBvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIDEwMDAsIHB1c2hBbnlRdWV1ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoe1wic3VjY2Vzc1wiOiB0cnVlfSk7XG4gICAgfSk7XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG1vZGVsLCBmaWxlbmFtZSkge1xuICAgIG1vZGVsLnN1YnNjcmliZSgoY29udGVudHMpID0+XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmF1dG9TYXZlKCkgPyB0aGlzLnNhdmVGaWxlKGZpbGVuYW1lLCBjb250ZW50cykgOiBmYWxzZSwgdGhpcyk7XG4gICAgdGhpcy5jYWNoZWRGaWxlbmFtZXMucHVzaChmaWxlbmFtZSk7XG59O1xuXG4vKipcbiAqIFRPRE86IGZpeFxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuc3VibWlzc2lvbi5jb2RlLCBcImFuc3dlci5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vblJ1biwgXCIhb25fcnVuLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCwgXCIhb25fZXZhbC5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vbkNoYW5nZSwgXCIhb25fY2hhbmdlLnB5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucywgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZSwgXCJec3RhcnRpbmdfY29kZS5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdHVkZW50RmlsZXMsIFwiI2V4dHJhX3N0dWRlbnRfZmlsZXMuYmxvY2tweVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFTdGFydGluZ0ZpbGVzLCBcIiNleHRyYV9zdGFydGluZ19maWxlcy5ibG9ja3B5XCIpO1xuICAgIHRoaXMuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbihtb2RlbC51aS5maWxlcy5leHRyYUluc3RydWN0b3JGaWxlcywgXCIjZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcy5ibG9ja3B5XCIpO1xufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRMb2dzID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lm9uYmx1ciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2dFdmVudChcIlNlc3Npb24uRW5kXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgd2luZG93Lm9uZm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJTZXNzaW9uLlN0YXJ0XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gYmVhY29uP1xufTtcblxuLyoqXG4gKlxuICogU29tZSBzdWJzY3JpcHRpb25zIGhhdmUgdG8gaGFwcGVuIGFmdGVyIG90aGVyIHRoaW5ncyBoYXZlIGJlZW4gbG9hZGVkLlxuICogUmlnaHQgbm93IHRoaXMgaXMganVzdCBhZnRlciBDT1JHSVMgbGlicmFyaWVzIGhhdmUgYmVlbiBsb2FkZWQsIGJ1dCBtYXliZVxuICogd2UnbGwgYWRkIG1vcmUgbGF0ZXIgYW5kIHRoaXMgd2lsbCBuZWVkIHRvIGJlIHJlZmFjdG9yZWQuXG4gKlxuICogVE9ETzogZml4XG4gKlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5maW5hbGl6ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy90aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kYXRhc2V0cy5zdWJzY3JpYmUodGhpcy5zYXZlQXNzaWdubWVudC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBwYXlsb2FkIGZvciBhbnkgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgQVBJXG4gKiBAcmV0dXJucyB7e2Fzc2lnbm1lbnRfaWQ6ICosIGNvdXJzZV9pZDogKiwgZ3JvdXBfaWQ6ICosIHVzZXJfaWQ6ICosIHRpbWV6b25lOiAqLCB2ZXJzaW9uOiAqLCB0aW1lc3RhbXA6ICp9fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5jcmVhdGVTZXJ2ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBhc3NpZ25tZW50ID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQ7XG4gICAgbGV0IHVzZXIgPSB0aGlzLm1haW4ubW9kZWwudXNlcjtcbiAgICBsZXQgc3VibWlzc2lvbiA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uO1xuICAgIGxldCBkaXNwbGF5ID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXk7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uO1xuICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBub3cuZ2V0VGltZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXNzaWdubWVudF9pZFwiOiBhc3NpZ25tZW50LmlkKCksXG4gICAgICAgIFwiYXNzaWdubWVudF9ncm91cF9pZFwiOiB1c2VyLmdyb3VwSWQoKSxcbiAgICAgICAgXCJjb3Vyc2VfaWRcIjogdXNlci5jb3Vyc2VJZCgpLFxuICAgICAgICBcInN1Ym1pc3Npb25faWRcIjogc3VibWlzc2lvbi5pZCgpLFxuICAgICAgICBcInVzZXJfaWRcIjogdXNlci5pZCgpLFxuICAgICAgICBcInZlcnNpb25cIjogYXNzaWdubWVudC52ZXJzaW9uKCksXG4gICAgICAgIFwidGltZXN0YW1wXCI6IG1pY3Jvc2Vjb25kcyxcbiAgICAgICAgXCJ0aW1lem9uZVwiOiBub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgXCJwYXNzY29kZVwiOiBkaXNwbGF5LnBhc3Njb2RlKCksXG4gICAgICAgIFwicGFydF9pZFwiOiBjb25maWd1cmF0aW9uLnBhcnRJZCgpXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdHVzIGFuZCBtZXNzYWdlIGZvciB0aGUgcmVsZXZhbnQgZW5kcG9pbnQuXG4gKiBAcGFyYW0gZW5kcG9pbnQge3N0cmluZ30gb25lIG9mIHRoZSBVUkwgZW5kcG9pbnRzXG4gKiBAcGFyYW0gc3RhdHVzIHtTdGF0dXNTdGF0ZX1cbiAqIEBwYXJhbSBtZXNzYWdlIHtzdHJpbmc/fVxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIHN0YXR1cywgbWVzc2FnZSkge1xuICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXNbZW5kcG9pbnRdKHN0YXR1cyk7XG4gICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludCArIFwiTWVzc2FnZVwiXShtZXNzYWdlIHx8IFwiXCIpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGFuIG92ZXJsYXkgb24gdGhlIHNjcmVlbiB0aGF0IGJsb2NrcyBvcGVyYXRpb24gdW50aWwgdGhlIHN5c3RlbSBpcyByZWFkeS5cbiAqIFRoZSBvdmVybGF5IGdldHMgcHJvZ3Jlc3NpdmVseSBkYXJrZXIgdG8gaW5kaWNhdGUgcmVwZWF0ZWQgZmFpbHVyZXMuXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNob3dPdmVybGF5ID0gZnVuY3Rpb24gKGF0dGVtcHQpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgKz0gMTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJibG9ja3B5LW92ZXJsYXlcIikubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9ICQoJzxkaXYgY2xhc3M9XCJibG9ja3B5LW92ZXJsYXlcIj4gPC9kaXY+Jyk7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gICAgc3dpdGNoIChhdHRlbXB0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzk4OFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiM2NTVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjMzMzXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImJsYWNrXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVbmRvIGEgbGV2ZWwgb2Ygb3ZlcmxheTsgaWYgdGhpcyB3YXMgdGhlIGxhc3QgbGV2ZWwsIHJlbW92ZXMgaXQgZnJvbSB0aGUgc2NyZWVuLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5oaWRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJsb2NraW5nQXR0ZW1wdHMgLT0gMTtcbiAgICBpZiAodGhpcy5ibG9ja2luZ0F0dGVtcHRzIDw9IDApIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9lbnF1ZXVlRGF0YSA9IGZ1bmN0aW9uIChjYWNoZSwgZGF0YSkge1xuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIG5vdCBvdmVyZmlsbGVkIHRoZSBxdWV1ZVxuICAgIGxldCBsZW5ndGggPSB0aGlzLnF1ZXVlW2NhY2hlXS5sZW5ndGg7XG4gICAgbGV0IG1heCA9IHRoaXMuTUFYX1FVRVVFX1NJWkVbY2FjaGVdO1xuICAgIGlmIChsZW5ndGggPiBtYXgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtjYWNoZV0gPSB0aGlzLnF1ZXVlW2NhY2hlXS5zbGljZShsZW5ndGggLSBtYXgsIG1heCk7XG4gICAgfVxuICAgIC8vIE9ubHkgYWRkIHRoZSBlbGVtZW50IGlmIGl0J3MgbmV3XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHRoaXMucXVldWVbY2FjaGVdLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnB1c2goa2V5KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldChjYWNoZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5xdWV1ZVtjYWNoZV0pKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fZGVxdWV1ZURhdGEgPSBmdW5jdGlvbiAoY2FjaGUsIGRhdGEpIHtcbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5xdWV1ZVtjYWNoZV0uaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMucXVldWVbY2FjaGVdLnNwbGljZShpbmRleCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KHRoaXMucXVldWVbY2FjaGVdKSk7XG4gICAgfVxufTtcblxuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGVuZHBvaW50LCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICBsZXQgcG9zdFJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgcG9zdFxuICAgICAgICB0aGlzLl9lbnF1ZXVlRGF0YShlbmRwb2ludCwgZGF0YSk7XG4gICAgICAgICQucG9zdCh0aGlzLnVybHNbZW5kcG9pbnRdLCBkYXRhKVxuICAgICAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZURhdGEoZW5kcG9pbnQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICBwb3N0UmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQocG9zdFJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBBSkFYIHJlcXVlc3QgdGhhdCwgdXBvbiBmYWlsdXJlLCB3aWxsIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHdhcyB0aGVcbiAqIGxhdGVzdCBhdHRlbXB0IGZvciB0aGlzIGBjYWNoZWAgbWFya2VyLiBJZiBzbywgaXQgd2lsbCBhdHRlbXB0IGFnYWluIHVudGlsXG4gKiBzdWNjZXNzZnVsOyBvdGhlcndpc2UsIGl0IGdpdmVzIHVwIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIEFKQVgtcmVhZHkgZGF0YSB0byBiZSBwb3N0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgdGltZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludCAtIFRoZSB1bmlxdWUgbmFtZSBnaXZlbiB0byB0aGUgcmVsZXZhbnQgY2FjaGUgZW50cnlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXkgLSBUaGUgY3VycmVudCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gdHJ5aW5nIHRoZSByZXF1ZXN0IGFnYWluLlxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdExhdGVzdFJldHJ5ID0gZnVuY3Rpb24gKGRhdGEsIGZpbGVuYW1lLCBlbmRwb2ludCwgZGVsYXksIGZhaWx1cmVGdW5jdGlvbiwgZG9uZUZ1bmN0aW9uKSB7XG4gICAgbGV0IGNhY2hlID0gZW5kcG9pbnQgKyBmaWxlbmFtZTtcbiAgICBsZXQgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoY2FjaGUsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgJC5wb3N0KHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGEpXG4gICAgICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgY2xlYXIgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUoY2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb25uZWN0ZWQgYnV0IGZhaWxlZCwgZG9uJ3QgdHJ5IGFnYWluIGJ1dCBsZXQgdGhlIHVzZXIga25vdyB3aHkuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUZ1bmN0aW9uKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbCgoZXJyb3IsIHRleHRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2VydmVyIHJlcXVlc3QgaXMgdGhlIGxhdGVzdCBvbmUsIHRoZW4gbGV0J3MgdHJ5IGl0IGFnYWluIGluIGEgYml0XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFRpbWUgPSB0aGlzLnN0b3JhZ2UuZ2V0VGltZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIGVuZHBvaW50LCBkZWxheSArIHRoaXMuRkFJTF9ERUxBWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGRvbmVGdW5jdGlvbik7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbY2FjaGVdKTtcbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVyc1tjYWNoZV0gPSBzZXRUaW1lb3V0KHJlcXVlc3QsIGRlbGF5KTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5fcG9zdEJsb2NraW5nID0gZnVuY3Rpb24gKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cywgc3VjY2VzcywgZmFpbHVyZSwgZXh0cmFTZXR0aW5ncz17fSkge1xuICAgIHRoaXMuc2hvd092ZXJsYXkoYXR0ZW1wdHMpO1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgdXJsOiB0aGlzLnVybHNbZW5kcG9pbnRdLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAuLi5leHRyYVNldHRpbmdzXG4gICAgfSlcbiAgICAgICAgLmRvbmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSVAocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAuZmFpbCgoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZShlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhlbmRwb2ludCwgU3RhdHVzU3RhdGUuUkVUUllJTkcsIHRleHRTdGF0dXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhlbmRwb2ludCwgZGF0YSwgYXR0ZW1wdHMgLSAxLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLkZBSUxfREVMQVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoYXNzaWdubWVudF9pZCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiYXNzaWdubWVudF9pZFwiXSA9IGFzc2lnbm1lbnRfaWQ7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxvYWRBc3NpZ25tZW50XCIsIGRhdGEsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4ubG9hZEFzc2lnbm1lbnREYXRhXyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVChyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfQVNTSUdOTU5FTlQodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVBc3NpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlQXNzaWdubWVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiaGlkZGVuXCJdID0gbW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKTtcbiAgICAgICAgZGF0YVtcInJldmlld2VkXCJdID0gbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpO1xuICAgICAgICBkYXRhW1wicHVibGljXCJdID0gbW9kZWwuYXNzaWdubWVudC5wdWJsaWMoKTtcbiAgICAgICAgZGF0YVtcInVybFwiXSA9IG1vZGVsLmFzc2lnbm1lbnQudXJsKCk7XG4gICAgICAgIGRhdGFbXCJwb2ludHNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnBvaW50cygpO1xuICAgICAgICBkYXRhW1wiaXBfcmFuZ2VzXCJdID0gbW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcygpO1xuICAgICAgICBkYXRhW1wibmFtZVwiXSA9IG1vZGVsLmFzc2lnbm1lbnQubmFtZSgpO1xuICAgICAgICBkYXRhW1wic2V0dGluZ3NcIl0gPSBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKTtcblxuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJzYXZlQXNzaWdubWVudFwiLCBkYXRhLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFBvc3NpYmxlRm9yay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKFNhdmUgQXNzaWdubWVudClcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEhpc3RvcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsb2FkSGlzdG9yeVwiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxpc3RVcGxvYWRlZEZpbGVzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxpc3RVcGxvYWRlZEZpbGVzXCIpKSB7XG4gICAgICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibGlzdFVwbG9hZGVkRmlsZXNcIiwgZGF0YSwgMiwgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnVwbG9hZEZpbGUgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBkaXJlY3RvcnksIGZpbGVuYW1lLCBjb250ZW50cywgY2FsbGJhY2spIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBsb2FkRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wicGxhY2VtZW50XCJdID0gcGxhY2VtZW50O1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvbnRlbnRzXCJdID0gY29udGVudHM7XG4gICAgICAgIGxldCBmZCA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoZCxlKSA9PiAoZC5hcHBlbmQoLi4uZSksIGQpLCBuZXcgRm9ybURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGxvYWRGaWxlXCIsIGZkLCAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBMT0FESU5HX0ZJTEUodGV4dFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtwcm9jZXNzRGF0YTogZmFsc2UsIGNvbnRlbnRUeXBlOiBmYWxzZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoVXBsb2FkIEZpbGUpXCIpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmxvZ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50X3R5cGUsIGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgZmlsZV9wYXRoKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9nRXZlbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcImV2ZW50X3R5cGVcIl0gPSBldmVudF90eXBlO1xuICAgICAgICBkYXRhW1wiY2F0ZWdvcnlcIl0gPSBjYXRlZ29yeTtcbiAgICAgICAgZGF0YVtcImxhYmVsXCJdID0gbGFiZWw7XG4gICAgICAgIGRhdGFbXCJtZXNzYWdlXCJdID0gbWVzc2FnZTtcbiAgICAgICAgZGF0YVtcImZpbGVfcGF0aFwiXSA9IGZpbGVfcGF0aDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2dFdmVudFwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdFJldHJ5KGRhdGEsIFwibG9nRXZlbnRcIiwgMCwgKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNhdmVJbWFnZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGltYWdlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVJbWFnZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZGlyZWN0b3J5XCJdID0gZGlyZWN0b3J5O1xuICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcInR1cnRsZV9vdXRwdXRcIiwgXCJzYXZlSW1hZ2VcIiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlSW1hZ2VcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvblN0YXR1cyA9IGZ1bmN0aW9uKG5ld1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5yZWFkT25seSgpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwidXBkYXRlU3VibWlzc2lvblN0YXR1c1wiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wic3RhdHVzXCJdID0gbmV3U3RhdHVzO1xuICAgICAgICBsZXQgcG9zdFN0YXR1c0NoYW5nZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIGRhdGEsIDIsIHBvc3RTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfVVBEQVRJTkdfU1VCTUlTU0lPTl9TVEFUVVMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBsb2FkIGZpbGVzIGFuZCB3ZWIgcmVzb3VyY2VzLlxuICpcbiAqIERFUFJFQ0FURURcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHR5cGUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRfZmlsZVwiKSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcInR5cGVcIl0gPSB0eXBlO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcodGhpcy51cmxzLmxvYWRfZmlsZSwgZGF0YSwgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5GQUlMRUQsIHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKFwiU2VydmVyIGZhaWx1cmUhIFJlcG9ydCB0byBpbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhcIk5vIGZpbGUgc2VydmVyIGF2YWlsYWJsZS5cIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSwgXCJTZXJ2ZXIgaXMgbm90IGNvbm5lY3RlZCEgKExvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNvbnRlbnRzLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGF5ID0gdGhpcy5USU1FUl9ERUxBWTtcbiAgICB9XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJzYXZlRmlsZVwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZmlsZW5hbWVcIl0gPSBmaWxlbmFtZTtcbiAgICAgICAgZGF0YVtcImNvZGVcIl0gPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIGZpbGVuYW1lLCBcInNhdmVGaWxlXCIsIGRlbGF5LCB0aGlzLnN0YXJ0UG9zc2libGVGb3JrLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnN0YXJ0UG9zc2libGVGb3JrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmZvcmthYmxlKSB7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5PRkZFUl9GT1JLKCk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBkYXRlU3VibWlzc2lvbiA9IGZ1bmN0aW9uIChzY29yZSwgY29ycmVjdCwgaGlkZGVuT3ZlcnJpZGUsIGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYWxsYmFjayA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzO1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzY29yZVwiXSA9IHNjb3JlO1xuICAgICAgICBkYXRhW1wiY29ycmVjdFwiXSA9IGNvcnJlY3Q7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5fb3ZlcnJpZGVcIl0gPSBoaWRkZW5PdmVycmlkZTtcbiAgICAgICAgZGF0YVtcImZvcmNlX3VwZGF0ZVwiXSA9IGZvcmNlVXBkYXRlO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuZ2V0UG5nRnJvbUJsb2NrcygocG5nRGF0YSwgaW1nKSA9PiB7XG4gICAgICAgICAgICBkYXRhW1wiaW1hZ2VcIl0gPSBwbmdEYXRhO1xuICAgICAgICAgICAgaWYgKGltZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBpbWcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoaWRkZW5PdmVycmlkZSAmJiBjb3JyZWN0ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhW1wiYXNzaWdubWVudF9pZFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJleHBvcnQgY29uc3QgJHNrX21vZF9jb3ZlcmFnZSA9IGBcblwiXCJcIlxuSGlkZW91cyBmaWxsLWluIHJlcGxhY2VtZW50IGZvciBDb3ZlcmFnZSwgbGV2ZXJhZ2luZyBzb21lIG1hZ2ljIGZyb20gdGhlXG5VdGlsaXR5IGZ1bmN0aW9uLiBUaGUgZGF0YSB0aGlzIHJldHVybnMgaXMgZmFsc2UgLSBpdCBkb2Vzbid0IGFjdHVhbGx5XG5kZXNjcmliZSB0aGUgbWlzc2luZyBsaW5lcyBhbmQgYWxsIGxpbmVzOyBpdCBqdXN0IGRlc2NyaWJlcyB0aGUgdHJhY2VkIGxpbmVzLlxuQnV0IHNpbmNlIFBlZGFsIGRvZXNuJ3QgbmVlZCB0aGUgb3RoZXIgdHdvLCBpdCB3b3JrcyBvdXQgZmluZSB3aGVuIHlvdSBkbzpcblxuc3RhdGVtZW50cyAtIG1pc3NpbmdcblwiXCJcIlxuXG5pbXBvcnQgdXRpbGl0eVxuXG5jbGFzcyBDb3ZlcmFnZTpcbiAgICBkZWYgc3RhcnQoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzdG9wKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgc2F2ZShzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIF9hbmFseXplKHNlbGYsIGZpbGVuYW1lOiBzdHIpOlxuICAgICAgICBsaW5lcyA9IHNldCh1dGlsaXR5LnRyYWNlX2xpbmVzKCkpXG4gICAgICAgICMgbGluZXMgd2lsbCBiZSB0aGUgbGluZXMgdGhhdCB3ZXJlIGFjdHVhbGx5IGV4ZWN1dGVkXG4gICAgICAgIHJldHVybiBBbmFseXNpcyhOb25lLCBsZW4obGluZXMpLCBOb25lLCBzZXQoKSwgbGluZXMpXG5cblxuY2xhc3MgTnVtYmVyczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpOlxuICAgICAgICBzZWxmLm5fbWlzc2luZyA9IG5fbWlzc2luZ1xuICAgICAgICBzZWxmLm5fc3RhdGVtZW50cyA9IG5fc3RhdGVtZW50c1xuICAgICAgICBzZWxmLnBjX2NvdmVyZWQgPSBwY19jb3ZlcmVkXG5cblxuY2xhc3MgQW5hbHlzaXM6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5fbWlzc2luZywgbl9zdGF0ZW1lbnRzLCBwY19jb3ZlcmVkLCBtaXNzaW5nLCBzdGF0ZW1lbnRzKTpcbiAgICAgICAgc2VsZi5taXNzaW5nID0gbWlzc2luZ1xuICAgICAgICBzZWxmLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYubnVtYmVycyA9IE51bWJlcnMobl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQpXG5cblxuY2xhc3MgcHl0aG9uOlxuICAgIGRlZiBnZXRfcHl0aG9uX3NvdXJjZShzZWxmKTpcbiAgICAgICAgcmV0dXJuIE5vbmVcbmA7IiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbW9kLCBzYW1wbGVXcmFwcGVyO1xuICAgIG1vZCA9IHtfX25hbWVfXzogXCJpbWFnZVwifTtcblxuICAgIGlmICghU2suUElMKSB7XG4gICAgICAgIFNrLlBJTCA9IHthc3NldHM6IHt9fTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50UHJvbWlzZSBpcyBhIHdvcmthcm91bmQgdG8gYWxsb3cgdXNhZ2Ugb2YgdGhlIGNsZWFuIHByb21pc2Utc3R5bGVcbiAgICAvLyB0aGVuL2NhdGNoIHN5bnRheCBidXQgdG8gaW5zdGFudGx5IGNhbGwgcmVzb2x2ZSB0aGUgdGhlbi9jYXRjaCBjaGFpbiBzbyB3ZVxuICAgIC8vIGNhbiBhdm9pZCBjcmVhdGluZyBTdXNwZW5zaW9ucyBpbiB1bm5lY2Vzc2FyeSBjYXNlcy4gIFRoaXMgaXMgZGVzaXJhYmxlXG4gICAgLy8gYmVjYXVzZSBTdXNwZW5zaW9ucyBoYXZlIGEgZmFpcmx5IGxhcmdlIG5lZ2F0aXZlIGltcGFjdCBvbiBvdmVyYWxsXG4gICAgLy8gcGVyZm9ybWFuY2UuICBUaGVzZSAnaW5zdGFudCBwcm9taXNlcycgY29tZSBpbnRvIHBsYXkgd2hlbiBhIHRyYWNlcigpXG4gICAgLy8gY2FsbCBpcyBtYWRlIHdpdGggYSB2YWx1ZSBvdGhlciB0aGFuIDEuICBXaGVuIHRyYWNlciBpcyAwIG9yIGdyZWF0ZXIgdGhhbiAxXG4gICAgLy8gLCB3ZSBjYW4gYnlwYXNzIHRoZSBjcmVhdGlvbiBvZiBhIFN1c3BlbnNpb24gYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgbGluZSBvZlxuICAgIC8vIGNvZGUgaW1tZWRpYXRlbHkgaWYgdGhlIGN1cnJlbnQgbGluZSBpcyBub3QgZ29pbmcgdG8gaW52b2x2ZSBhIHNjcmVlblxuICAgIC8vIHVwZGF0ZS4gV2UgZGV0ZXJtaW5lIGlmIGEgcmVhbCBwcm9taXNlIG9yIEluc3RhbnRQcm9taXNlIGlzIG5lY2Vzc2FyeSBieVxuICAgIC8vIGNoZWNraW5nIEZyYW1lTWFuYWdlci53aWxsUmVuZGVyTmV4dCgpXG4gICAgZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlcnI7XG4gICAgfVxuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdFJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlID8gdGhpcy5sYXN0UmVzdWx0IDogdGhpcztcbiAgICB9O1xuXG4gICAgSW5zdGFudFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IGNiKHRoaXMubGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgYnVpbGRJbWFnZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEFzc2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKFNrLlBJTC5hc3NldHNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFNrLlBJTC5hc3NldHNbbmFtZV07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShTay5QSUwuYXNzZXRzW25hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU2suUElMLmFzc2V0c1tuYW1lXSA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXNzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgIC8vIG9wZW4oZmlsZW5hbWUpIG9yIG9wZW4odXJsKVxuICAgICAgICAvLyBzaG93KClcblxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZmlsZV9vcl91cmwpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImZpbGVfb3JfdXJsXCIsIFwic3RyaW5nXCIsIFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZmlsZV9vcl91cmwpKTtcbiAgICAgICAgICAgIHNlbGYuZmlsZV9vcl91cmwgPSBmaWxlX29yX3VybDtcbiAgICAgICAgICAgIC8vIFRPRE86IENoYW5nZSB0byBzdXNwZW5zaW9uXG4gICAgICAgICAgICB2YXIgaW1hZ2VQcm9taXNlID0gZ2V0QXNzZXQoU2suZmZpLnJlbWFwVG9KcyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgdmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpO1xuICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgICAgIHN1c3AucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1c3AuZGF0YVtcImVycm9yXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihzdXNwLmRhdGFbXCJlcnJvclwiXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3VzcC5kYXRhW1wiZXJyb3JcIl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gc2VsZi5pbWFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3VzcC5kYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2sucHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IGltYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy53aWR0aCA9IHNlbGYuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmhlaWdodCA9IHNlbGYuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKHNlbGYuaW1hZ2UsIDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5waXhlbHMgPSBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNlbGYuaW1hZ2Uud2lkdGgsIHNlbGYuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc3VzcDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5zaG93ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBpZiAoU2suY29uc29sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTmFtZUVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIGRyYXdpbmcgYXJlYS4gU2suY29uc29sZSBpcyB1bmRlZmluZWQhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29uc29sZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHNlbGYuaW1hZ2UsXG4gICAgICAgICAgICAgICAgZmlsZV9vcl91cmw6IHNlbGYuZmlsZV9vcl91cmxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNrLmNvbnNvbGUucHJpbnRQSUxJbWFnZShjb25zb2xlRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZmxpcCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgtMSlcIjtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtb2QuSW1hZ2UgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgaW1hZ2UsIFwiSW1hZ2VcIiwgW10pO1xuXG4gICAgcmV0dXJuIG1vZDtcbn07IiwiZXhwb3J0IGNvbnN0ICRwZWRhbF90cmFjZXIgPSBgXHJcblxyXG5cIlwiXCJcclxuV3JhcHMgdGhlIHRyYWNlciBtb2R1bGUgaW4gUGVkYWxcclxuXCJcIlwiXHJcblxyXG5pbXBvcnQgb3NcclxuaW1wb3J0IHV0aWxpdHlcclxuICAgICAgICBcclxuY2xhc3MgU2FuZGJveEJhc2ljVHJhY2VyOlxyXG4gICAgXCJcIlwiXHJcblxyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgc2VsZi5maWxlbmFtZSA9IFwic3R1ZGVudC5weVwiXHJcbiAgICAgICAgc2VsZi5jb2RlID0gTm9uZVxyXG5cclxuICAgIGRlZiBhc19maWxlbmFtZShzZWxmLCBmaWxlbmFtZSwgY29kZSk6XHJcbiAgICAgICAgaWYgb3MucGF0aC5pc2FicyhmaWxlbmFtZSk6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBmaWxlbmFtZVxyXG4gICAgICAgIGVsc2U6XHJcbiAgICAgICAgICAgIHNlbGYuZmlsZW5hbWUgPSBvcy5wYXRoLmFic3BhdGgoZmlsZW5hbWUpXHJcbiAgICAgICAgc2VsZi5jb2RlID0gY29kZVxyXG4gICAgICAgIHJldHVybiBzZWxmXHJcblxyXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcclxuICAgICAgICBwYXNzXHJcblxyXG4gICAgZGVmIF9fZXhpdF9fKHNlbGYsIGV4Y190eXBlLCBleGNfdmFsLCB0cmFjZWJhY2spOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbmNsYXNzIFNhbmRib3hOYXRpdmVUcmFjZXIoU2FuZGJveEJhc2ljVHJhY2VyKTpcclxuICAgIFwiXCJcIlxyXG4gICAgVHJhY2tzIGxpbmVzIGNvdmVyZWQgYW5kIGZ1bmN0aW9uIGNhbGxzLiBQb3NzaWJseSBvdGhlciB0aGluZ3M/IFdlIGNvdWxkIHRyYWNrIHZhcmlhYmxlcywgaWYgdGhhdFxyXG4gICAgd2FzIHNvbWV0aGluZyBwZW9wbGUgd2FudGVkLlxyXG5cclxuICAgIFRPRE86IEhhbmRsZSBtdWx0aXBsZSBzdWJtaXNzaW9uIGZpbGVzP1xyXG4gICAgXCJcIlwiXHJcbiAgICBkZWYgX19pbml0X18oc2VsZik6XHJcbiAgICAgICAgc3VwZXIoKS5fX2luaXRfXygpXHJcbiAgICAgICAgI3NlbGYuY2FsbHMgPSB1dGlsaXR5LnRyYWNlX2NhbGxzKClcclxuICAgICAgICBzZWxmLmxpbmVzID0gdXRpbGl0eS50cmFjZV9saW5lcygpXHJcbiAgICAgICAgc2VsZi5zdGVwX2luZGV4ID0gbGVuKHV0aWxpdHkudHJhY2VfbGluZXMoKSlcclxuICAgIFxyXG4gICAgZGVmIGdldF9jYWxscyhzZWxmKTpcclxuICAgICAgICByZXR1cm4gdXRpbGl0eS50cmFjZV9jYWxscygpXHJcbiAgICBcclxuICAgIGNhbGxzID0gcHJvcGVydHkoZ2V0X2NhbGxzKVxyXG4gICAgXHJcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxyXG4gICAgICAgIHV0aWxpdHkuc3RhcnRfdHJhY2Uoc2VsZilcclxuXHJcbiAgICBkZWYgX19leGl0X18oc2VsZiwgZXhjX3R5cGUsIGV4Y192YWwsIHRyYWNlYmFjayk6XHJcbiAgICAgICAgdXRpbGl0eS5zdG9wX3RyYWNlKHNlbGYpXHJcblxyXG5UUkFDRVJfU1RZTEVTID0ge1xyXG4gICAgJ25vbmUnOiBTYW5kYm94QmFzaWNUcmFjZXIsXHJcbiAgICAnbmF0aXZlJzogU2FuZGJveE5hdGl2ZVRyYWNlclxyXG59XHJcblxyXG5gOyIsIi8qKlxuICogU2t1bHB0IE1vZHVsZSBmb3IgaG9sZGluZyB0aGUgSW5zdHJ1Y3RvciBBUEkuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgbG9hZGVkIGluIGJ5IGdldHRpbmcgdGhlIGZ1bmN0aW9ucycgc291cmNlIGNvZGUgZnJvbSB0b1N0cmluZy5cbiAqIElzbid0IHRoYXQgY3Jhenk/XG4gKlxuICpcbiAqL1xuZXhwb3J0IGxldCAkc2tfbW9kX2luc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBNYWluIG1vZHVsZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIGF0IHRoZSBlbmQuXG4gICAgbGV0IG1vZCA9IHt9O1xuICAgIGxldCBub25lID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIFxuICAgIGxldCBwcmlvciA9IG51bGw7XG4gICAgbW9kLnRpbWVpdCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwidGltZWl0XCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBkaWZmZXJlbmNlO1xuICAgICAgICBpZiAocHJpb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IERhdGUubm93KCkgLSBwcmlvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhTay5mZmkucmVtYXBUb0pzKG5hbWUpLCBkaWZmZXJlbmNlLzEwMDApO1xuICAgICAgICBwcmlvciA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBmZWVkYmFjayB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9sb2cgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygoWy4uLmFyZ3VtZW50c10pLm1hcChTay5mZmkucmVtYXBUb0pzKSk7XG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9ncyBkZWJ1ZyB0byBqYXZhc2NyaXB0IGNvbnNvbGVcbiAgICAgKi9cbiAgICBtb2QuY29uc29sZV9kZWJ1ZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNvdmVydHMgdGhlIG91dHB1dCBpbiB0aGUgc3R1ZGVudCByZXBvcnQgdG8gYSBweXRob24gXG4gICAgICogbGlzdCBhbmQgcmV0dXJucyBpdC5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X291dHB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfb3V0cHV0XCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS50b1NrdWxwdCgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJlc2V0cyB0aGUgb3V0cHV0LCBwYXJ0aWN1bGFybHkgdXNlZnVsIGlmIHRoZSBzdHVkZW50XG4gICAgICogY29kZSBpcyBnb2luZyB0byBiZSByZXJ1bi5cbiAgICAgKi9cbiAgICBtb2QucmVzZXRfb3V0cHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInJlc2V0X291dHB1dFwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ub3V0cHV0LnJlbW92ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgfSk7XG4gICAgXG4gICAgLyptb2QucXVldWVfaW5wdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicXVldWVfaW5wdXRcIiwgYXJndW1lbnRzLCAxLCBJbmZpbml0eSk7XG4gICAgICAgIGxldCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gYXJncy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGFyZ3NbaV07XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiaW5wdXRcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhpbnB1dCkpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaChTay5mZmkucmVtYXBUb0pzKGlucHV0KSk7XG4gICAgICAgIH1cbiAgICB9KTsqL1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9wcm9ncmFtID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wcm9ncmFtXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJ2ZXJpZmllclwiXS5jb2RlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGluc3RydWN0b3JzIHRvIGdldCB0aGUgc3R1ZGVudHMnIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgKiovXG4gICAgbW9kLmdldF9ldmFsdWF0aW9uID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9ldmFsdWF0aW9uXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmV2YWx1YXRpb24gfHwgXCJcIik7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnRyYWNlX2xpbmVzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnJlYWxMaW5lcztcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KGxpbmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kLnRyYWNlX2NhbGxzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIi0tXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNIRUNLSU5HIENBTExTXCIsIFNrLmV4ZWN1dGlvblJlcG9ydHNbJ3N0dWRlbnQnXS5zdWNjZXNzKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBjYWxscyA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmNhbGxzO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KFtdKTtcbiAgICB9KTtcblxuICAgIG1vZC5zdGFydF90cmFjZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIGlmIChTay5iZWZvcmVDYWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBTay5iZWZvcmVDYWxsID0gU2suYmVmb3JlQ2FsbEJhY2t1cDtcbiAgICAgICAgfVxuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLnB1c2godHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVEFSVC9FTkRcIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgIH0pO1xuXG4gICAgbW9kLnN0b3BfdHJhY2UgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RPUC9CRUdJTlwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcucG9wKCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS50cmFjaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgU2suYmVmb3JlQ2FsbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUT1AvRU5EXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG1vZC5nZXRfc3R1ZGVudF9lcnJvciA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtub25lLCBub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvcixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLnRyYWNlYmFjayAmJiBlcnJvci50cmFjZWJhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uW1wibGluZVwiXSA9IGVycm9yLnRyYWNlYmFja1swXS5saW5lbm87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uID0gU2suZmZpLnJlbWFwVG9QeShwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Vycm9yLCBwb3NpdGlvbl0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcbiAgICBtb2QuaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImhhZF9leGVjdXRpb25fdGltZV9lcnJvclwiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICByZXR1cm4gIVNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MgJiYgXG4gICAgICAgICAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXJyb3IgJiZcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvci50cCRuYW1lID09PSBcIlRpbWVMaW1pdEVycm9yXCI7XG4gICAgfSk7XG4gICAgXG4gICAgbGV0IGJhY2t1cFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgbW9kLmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGJhY2t1cFRpbWUgPSBTay5leGVjTGltaXQ7XG4gICAgICAgIGlmIChTay5leGVjTGltaXRGdW5jdGlvbikge1xuICAgICAgICAgICAgU2suZXhlY0xpbWl0ID0gU2suZXhlY0xpbWl0RnVuY3Rpb24oKTtcbiAgICAgICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtb2QudW5saW1pdF9leGVjdXRpb25fdGltZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ1bmxpbWl0X2V4ZWN1dGlvbl90aW1lXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmV4ZWNMaW1pdCA9IGJhY2t1cFRpbWU7XG4gICAgICAgIFNrLmV4ZWNTdGFydCA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgbW9kLnN1cHByZXNzX3Njcm9sbGluZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJzdXBwcmVzc19zY3JvbGxpbmdcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0cy5pbnN0cnVjdG9yLnNjcm9sbGluZyA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBcbiAgICAvKlxuICAgIGRlZiBoaXN0KHNlbGYsIGRhdGEsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0hpc3RvZ3JhbScsICd2YWx1ZXMnOiBkYXRhLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHBsb3Qoc2VsZiwgeHMsIHlzPU5vbmUsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIGlmIHlzID09IE5vbmU6XG4gICAgICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdMaW5lJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd4JzogcmFuZ2UobGVuKHhzKSksICd5JzogeHMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgZGVmIHNjYXR0ZXIoc2VsZiwgeHMsIHlzLCAqKmt3YXJncyk6XG4gICAgICAgIGxhYmVsID0ga3dhcmdzLmdldCgnbGFiZWwnLCBOb25lKVxuICAgICAgICBzZWxmLmFjdGl2ZV9wbG90WydkYXRhJ10uYXBwZW5kKHsndHlwZSc6ICdTY2F0dGVyJywgJ3gnOiB4cywgJ3knOiB5cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICovXG4gICAgbW9kLmdldF9wbG90cyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfcGxvdHNcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXRzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl1bXCJvdXRwdXRcIl0oKTtcbiAgICAgICAgICAgIG91dHB1dHMgPSBvdXRwdXRzLmZpbHRlcihmdW5jdGlvbihvdXRwdXQpIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50eXBlID09PSBcInBsb3RcIjtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihncmFwaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XCJkYXRhXCI6IGdyYXBoLmNvbnRlbnQubWFwKGZ1bmN0aW9uKHBsb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Bsb3QgPSB7IFwidHlwZVwiOiBwbG90LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCI6IFwiXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsb3QudHlwZSA9PT0gXCJsaW5lXCIgfHwgcGxvdC50eXBlID09PSBcInNjYXR0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGxvdFtcInhcIl0gPSBwbG90LmRhdGEubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYueDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieVwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi55OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbG90LnR5cGUgPT09IFwiaGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1widmFsdWVzXCJdID0gcGxvdC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdQbG90O1xuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBcInhsYWJlbFwiOiBcIlwiLCBcInlsYWJlbFwiOiBcIlwiLCBcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiXCIsIFwibGVnZW5kXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkob3V0cHV0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIC8vIFByb3ZpZGVzIGBzdHVkZW50YCBhcyBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIGRhdGEgdGhhdCB0aGUgc3R1ZGVudCBkZWNsYXJlZC5cbiAgICBtb2QuU3R1ZGVudERhdGEgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgZnVuY3Rpb24oJGdibCwgJGxvYykge1xuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICAvL3NlbGYuZGF0YSA9IFNrLmJ1aWx0aW4uZGljdCgpO1xuICAgICAgICAgICAgbGV0IG5ld0RpY3QgPSBuZXcgU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBTay5hYnN0ci5zYXR0cihzZWxmLCBuZXcgU2suYnVpbHRpbi5zdHIoXCJkYXRhXCIpLCBuZXdEaWN0LCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYubW9kdWxlID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ucmVzdWx0cztcbiAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBzZWxmLm1vZHVsZS4kZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLmFic3RyLm9iamVjdFNldEl0ZW0obmV3RGljdCwgU2suZmZpLnJlbWFwVG9QeShTay51bmZpeFJlc2VydmVkKGtleSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FsbF9mID0gZnVuY3Rpb24oa3dhKSB7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFwiY2FsbFwiLCBhcmd1bWVudHMubGVuZ3RoLCAxLCBJbmZpbml0eSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIga3dhcmdzID0gbmV3IFNrLmJ1aWx0aW5zLmRpY3Qoa3dhKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSBhcmdzWzBdO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgyKTtcblxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGt3YXJncy5tcCRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKFwiaW5wdXRzXCIpKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlucHV0cyA9IFNrLmZmaS5yZW1hcFRvSnMoaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi50cCRnZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIikpO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uT2JqZWN0ID0gZGF0YS5tcCRsb29rdXAoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbk9iamVjdC50cCRjYWxsKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbF9mLmNvX2t3YXJncyA9IHRydWU7XG4gICAgICAgIC8vY2FsbF9mLmNvX3Zhcm5hbWVzID0gW1wic2VsZlwiLCBcImZ1bmN0aW9uXCJdO1xuICAgICAgICBjYWxsX2YuY29fbmFtZT0gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiY2FsbFwiKTtcbiAgICAgICAgJGxvY1tcImNhbGxfJHJuJFwiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoY2FsbF9mKTtcblxuICAgICAgICAkbG9jW1wiX19yZXByX19cIl0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRsb2MuZ2V0X25hbWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfbmFtZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQocHJvcGVydHkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgJGxvYy5nZXRfdmFsdWVzX2J5X3R5cGUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIHR5cGUsIGV4Y2x1ZGVfYnVpbHRpbnMpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfdmFsdWVzX2J5X3R5cGVcIiwgYXJndW1lbnRzLCAyLCAzKTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlX2J1aWx0aW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImV4Y2x1ZGVfYnVpbHRpbnNcIiwgXCJib29sZWFuXCIsIFNrLmJ1aWx0aW4uY2hlY2tCb29sKGV4Y2x1ZGVfYnVpbHRpbnMpKTtcbiAgICAgICAgICAgICAgICBleGNsdWRlX2J1aWx0aW5zID0gU2suZmZpLnJlbWFwVG9KcyhleGNsdWRlX2J1aWx0aW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHNlbGYubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGVbcHJvcGVydHldLnRwJG5hbWUgPT09IHR5cGUudHAkbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgJiYgcHJvcGVydHkuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSwgXCJTdHVkZW50RGF0YVwiKTtcbiAgICBtb2Quc3R1ZGVudCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQobW9kLlN0dWRlbnREYXRhKTtcbiAgICBcbiAgICBtb2QuZ2V0X3N0dWRlbnRfZGF0YSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9kYXRhXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiBtb2Quc3R1ZGVudDtcbiAgICB9KTtcblxuICAgIG1vZC5zZXRfaW5zdHJ1Y3Rpb25zID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihuZXdJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInNldF9pbnN0cnVjdGlvbnNcIiwgYXJndW1lbnRzLCAxLCAyKTtcbiAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gU2suZmZpLnJlbWFwVG9KcyhuZXdJbnN0cnVjdGlvbnMpO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wibW9kZWxcIl0uZGlzcGxheS5jaGFuZ2VkSW5zdHJ1Y3Rpb25zKG5ld0luc3RydWN0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBtb2QuZ2V0X21vZGVsX2luZm8gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9tb2RlbF9pbmZvXCIsIGFyZ3VtZW50cywgMSwgMSk7XG4gICAgICAgIGxldCBtb2RlbCA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXTtcbiAgICAgICAga2V5cyA9IFNrLmZmaS5yZW1hcFRvSnMoa2V5cykuc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KG1vZGVsKCkpO1xuICAgIH0pO1xuXG4gICAgbW9kLmNsZWFyX2V4aXN0aW5nX3N0dWRlbnRfaW1wb3J0cyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJnZXRfc3R1ZGVudF9kYXRhXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIFNrLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cygpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBtb2Q7XG59O1xuIiwiZXhwb3J0IHZhciAkYnVpbHRpbm1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciBtb2QsIHNhbXBsZVdyYXBwZXI7XHJcbiAgICBtb2QgPSB7X19uYW1lX186IFwid2Vha3JlZlwifTtcclxuXHJcbiAgICAvKm1vZC5XZWFrU2V0ID0gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIndlYWtyZWYuV2Vha1NldFwiLCB7XHJcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFdlYWtTZXQoKVxyXG4gICAgfSk7Ki9cclxuXHJcbiAgICB2YXIgV2Vha1NldCA9IGZ1bmN0aW9uKCRnYmwsICRsb2MpIHtcclxuICAgICAgICAkbG9jLl9faW5pdF9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZiwgZGF0YSkge1xyXG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiX19pbml0X19cIiwgYXJndW1lbnRzLCAyLCAyKTtcclxuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrVHlwZShcImRhdGFcIiwgXCJpdGVyYWJsZVwiLCBTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZGF0YSkpO1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGl0ZXIgPSBTay5hYnN0ci5pdGVyKGRhdGEpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IFNrLmFic3RyLml0ZXJuZXh0KGl0ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YS5wdXNoKG5ldyBXZWFrUmVmKG5leHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJGxvYy5fX2l0ZXJfXyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3T2ZEYXRhID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHNlbGYuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNlbGYuZGF0YVtpXS5kZXJlZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdPZkRhdGEucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSB2aWV3T2ZEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gU2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi5saXN0KHZpZXdPZkRhdGEpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyokbG9jLm5leHQkID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiAoc2VsZikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi50cCRpdGVyKCk7XHJcbiAgICAgICAgfSk7Ki9cclxuXHJcbiAgICAgICAgJGxvYy5hZGQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYsIGl0ZW0pIHtcclxuICAgICAgICAgICAgc2VsZi5kYXRhLnB1c2gobmV3IFdlYWtSZWYoaXRlbSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIG1vZC5XZWFrU2V0ID0gU2subWlzY2V2YWwuYnVpbGRDbGFzcyhtb2QsIFdlYWtTZXQsIFwiV2Vha1NldFwiLCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIG1vZDtcclxufTsiLCJsZXQgTE9DQUxfU1RPUkFHRV9SRUY7XG50cnkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGID0gbG9jYWxTdG9yYWdlO1xuICAgIGxldCBtb2QgPSBcIkJMT0NLUFlfTE9DQUxTVE9SQUdFX1RFU1RcIjtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKG1vZCk7XG59IGNhdGNoKGUpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRiA9IHtcbiAgICAgICAgX2RhdGEgICAgICAgOiB7fSxcbiAgICAgICAgc2V0SXRlbSAgICAgOiBmdW5jdGlvbihpZCwgdmFsKSB7IHJldHVybiB0aGlzLl9kYXRhW2lkXSA9IFN0cmluZyh2YWwpOyB9LFxuICAgICAgICBnZXRJdGVtICAgICA6IGZ1bmN0aW9uKGlkKSB7IHJldHVybiB0aGlzLl9kYXRhLmhhc093blByb3BlcnR5KGlkKSA/IHRoaXMuX2RhdGFbaWRdIDogbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlSXRlbSAgOiBmdW5jdGlvbihpZCkgeyByZXR1cm4gZGVsZXRlIHRoaXMuX2RhdGFbaWRdOyB9LFxuICAgICAgICBjbGVhciAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YSA9IHt9OyB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgb2JqZWN0IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBMb2NhbFN0b3JhZ2UuIFRoZSBMb2NhbFN0b3JhZ2VcbiAqIGJyb3dzZXIgQVBJIGFsbG93cyBmb3Igb2ZmbGluZSBzdG9yYWdlLiBUaGF0IEFQSSBpcyB2ZXJ5IHVuc29waGlzdGljYXRlZCxcbiAqIGFuZCBpcyBlc3NlbnRpYWxseSBhIGxhbWUga2V5LXZhbHVlIHN0b3JlLiBUaGlzIG9iamVjdCBzaXRzIG9uIHRvcFxuICogYW5kIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHVzZWZ1bCB1dGlsaXRpZXMsIGluY2x1ZGluZyBydWRpbWVudGFyeWNhY2hlXG4gKiBjYWNoZSBleHBpcmF0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0xvY2FsU3RvcmFnZVdyYXBwZXJ9XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gQSBuYW1lc3BhY2UgdG8gdXNlIGluIGdyb3VwaW5nIGFjY2VzcyB0byBsb2NhbHN0b3JhZ2UuIFRoaXMga2VlcHMgYWNjZXNzIGNsZWFuIGFuZCBvcmdhbml6ZWQsIHdoaWxlIGFsc28gbWFraW5nIGl0IHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgTG9jYWxTdG9yYWdlIGNvbm5lY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gTG9jYWxTdG9yYWdlV3JhcHBlcihuYW1lc3BhY2UpIHtcbiAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbn1cbi8qKlxuICogQSBtZXRob2QgZm9yIGFkZGluZyBhIGtleS92YWx1ZSBwYWlyIHRvIExvY2FsU3RvcmFnZS5cbiAqIE5vdGUgdGhhdCBib3RoIHBhcmFtZXRlcnMgbXVzdCBiZSBzdHJpbmdzIChKU09OLnN0cmluZ2lmeSBpcyB5b3VyIGZyaWVuZCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUuXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnNldCA9ICBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIiwgdmFsdWUpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiLCAkLm5vdygpKTtcbn07XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIHJlbW92aW5nIGEga2V5IGZyb20gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJlbW92ZS5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIik7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYucmVtb3ZlSXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdGltZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdGltZSBmb3IuXG4gKiBAcmV0dXJucyB7SW50ZWdlcn0gLSBUaGUgdGltZXN0YW1wIChsb2NhbCBlcG9jaCkgd2hlbiB0aGUga2V5IHdhcyBsYXN0IHNldC5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBwYXJzZUludChMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIikpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmV0cmlldmluZyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gKiBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQgaW5zdGVhZC5cbiAqIFRoaXMgZGVmYXVsdCB3aWxsIGJlIHNldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZS4gTXVzdCBiZSBhIHN0cmluZy5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSB0ZXN0IGZvciB3aGV0aGVyIHRoZSBnaXZlbiBrZXkgaXMgaW4gTG9jYWxTdG9yYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHRlc3QgZXhpc3RlbmNlIGZvci5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3ZhbHVlXCIpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBBIHRlc3QgZm9yIHdoZXRoZXIgdGhlIHNlcnZlciBoYXMgdGhlIG5ld2VyIHZlcnNpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGFzc3VtZXMgdGhhdCB0aGUgc2VydmVyIHRyaXAgdGFrZXMgYWJvdXQgNSBzZWNvbmRzLiBUaGlzIG1ldGhvZFxuICogaXMgbGFyZ2VseSBkZXByZWNhdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzZXJ2ZXJfdGltZSAtIFRoZSBzZXJ2ZXIncyB0aW1lIGFzIGFuIGVwb2NoIChpbiBtaWxsaXNlY29uZHMpXG4gKi9cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmlzX25ldyA9IGZ1bmN0aW9uKGtleSwgc2VydmVyX3RpbWUpIHtcbiAgICB2YXIgc3RvcmVkX3RpbWUgPSBMT0NBTF9TVE9SQUdFX1JFRi5nZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIik7XG4gICAgcmV0dXJuIChzZXJ2ZXJfdGltZSA+PSBzdG9yZWRfdGltZSs1MDAwKTtcbn07XG4iLCJleHBvcnQgY29uc3QgVFJBQ0VfSFRNTCA9IGBcblxuPGRpdiBjbGFzcz1cImJsb2NrcHktdHJhY2UgY29sLW1kLTYgYmxvY2tweS1wYW5lbFwiXG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCIgYXJpYS1sYWJlbD1cIlRyYWNlXCI+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImNsZWFyZml4XCI+XG4gICAgICAgIDxzdHJvbmc+VHJhY2U6IDwvc3Ryb25nPlxuICAgICAgICBcbiAgICAgICAgPCEtLSBGZWVkYmFjay9UcmFjZSBWaXNpYmlsaXR5IENvbnRyb2wgLS0+XG4gICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJ1xuICAgICAgICAgICAgICAgIGNsYXNzPSdidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBmbG9hdC1yaWdodCBibG9ja3B5LWhpZGUtdHJhY2UnXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+IEhpZGUgVHJhY2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgbWItMyBibG9ja3B5LXRyYWNlLWNvbnRyb2xzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZpcnN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuYmFja3dhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWJhY2t3YXJkJz48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiPlN0ZXA6PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgLyA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmZvcndhcmRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5sYXN0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWZvcndhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiB1aS50cmFjZS5saW5lJz48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxwIGRhdGEtYmluZD1cInRleHQ6IHVpLnRyYWNlLmFzdFwiPjwvcD5cbiAgICA8cD5WYXJpYWJsZXMgYWZ0ZXIgdGhpcyBzdGVwOjwvcD5cbiAgICA8dGFibGUgY2xhc3M9J3RhYmxlIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWQgdGFibGUtaG92ZXInPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICA8dHI+PHRoPk5hbWU8L3RoPjx0aD5UeXBlPC90aD48dGg+VmFsdWU8L3RoPjwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keSBkYXRhLWJpbmQ9XCJmb3JlYWNoOiB1aS50cmFjZS5kYXRhKCkucHJvcGVydGllc1wiPlxuICAgICAgICAgICAgPHRyIGRhdGEtYmluZD1cInZpc2libGU6IG5hbWUgIT0gJ19fZmlsZV9fJyAmJiBuYW1lICE9ICdfX3BhdGhfXydcIj5cbiAgICAgICAgICAgICAgICA8dGQgZGF0YS1iaW5kPVwidGV4dDogbmFtZVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZD1cInRleHQ6IHR5cGVcIj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgPGNvZGUgZGF0YS1iaW5kPVwidGV4dDogdmFsdWVcIj48L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0ga28gaWY6IHR5cGUgPT0gXCJMaXN0XCIgLS0+XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiXCIgZGF0YS1iaW5kPVwiY2xpY2s6IC8vJHJvb3Qudmlld0V4YWN0VmFsdWUodHlwZSwgZXhhY3RfdmFsdWUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdnbHlwaGljb24gZ2x5cGhpY29uLW5ldy13aW5kb3cnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICA8L3RhYmxlPlxuICAgIFxuPC9kaXY+XG5gO1xuXG5leHBvcnQgY29uc3QgQVNUX0RFU0NSSVBUSU9OUyA9IHtcbiAgICBcIkFkZFwiOiBcIkFuIGFkZGl0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJBbmRcIjogXCJBIGJvb2xlYW4gQU5EIG9wZXJhdG9yXCIsXG4gICAgXCJBbm5Bc3NpZ25cIjogXCJBbiBhbm5vdGF0ZWQgYXNzaWdubWVudFwiLFxuICAgIFwiQXNzZXJ0XCI6IFwiQW4gYXNzZXJ0IHN0YXRlbWVudFwiLFxuICAgIFwiQXNzaWduXCI6IFwiQW4gYXNzaWdubWVudCBzdGF0ZW1lbnRcIixcbiAgICBcIkFzeW5jRm9yXCI6IFwiQW4gYXN5Y2hyb25vdXMgZm9yIGxvb3BcIixcbiAgICBcIkFzeW5jRnVuY3Rpb25EZWZcIjogXCJBbiBhc3ljaHJvbm91cyBmdW5jdGlvbiBkZWZpbml0aW9uXCIsXG4gICAgXCJBc3luY1dpdGhcIjogXCJBbiBhc3ljaHJvbm91cyB3aXRoIHN0YXRlbWVudFwiLFxuICAgIFwiQXR0cmlidXRlXCI6IFwiQW4gYXR0cmlidXRlIGxvb2t1cCAoYWNjZXNzIGEgZmllbGQpXCIsXG4gICAgXCJBdWdBc3NpZ25cIjogXCJBbiBhdWdtZW50ZWQgYXNzaWdubWVudFwiLFxuICAgIFwiQXVnTG9hZFwiOiBcIkFuIGF1Z21lbnRlZCBsb2FkXCIsXG4gICAgXCJBdWdTdG9yZVwiOiBcIkFuIGF1Z21lbnRlZCBzdG9yZVwiLFxuICAgIFwiQXdhaXRcIjogXCJBbiBhd2FpdCBzdGF0ZW1lbnRcIixcbiAgICBcIkJpbk9wXCI6IFwiQSBiaW5hcnkgb3BlcmF0b3JcIixcbiAgICBcIkJpdEFuZFwiOiBcIkEgYml0d2lzZSBBTkQgb3BlcmF0b3JcIixcbiAgICBcIkJpdE9yXCI6IFwiQSBiaXR3aXNlIE9SIG9wZXJhdG9yXCIsXG4gICAgXCJCaXRYb3JcIjogXCJBIGJpdHdpc2UgWE9SIG9wZXJhdG9yXCIsXG4gICAgXCJCb29sT3BcIjogXCJBIGJvb2xlYW4gb3BlcmF0b3JcIixcbiAgICBcIkJyZWFrXCI6IFwiQSBicmVhayBzdGF0ZW1lbnRcIixcbiAgICBcIkJ5dGVzXCI6IFwiQSBsaXRlcmFsIGJ5dGVzIHN0cmluZ1wiLFxuICAgIFwiQ2FsbFwiOiBcIkEgZnVuY3Rpb24gY2FsbFwiLFxuICAgIFwiQ2xhc3NEZWZcIjogXCJBIGNsYXNzIGRlZmluaXRpb25cIixcbiAgICBcIkNvbXBhcmVcIjogXCJBIGJvb2xlYW4gY29tcGFyaXNvblwiLFxuICAgIFwiQ29uc3RhbnRcIjogXCJBIGxpdGVyYWwgdmFsdWVcIixcbiAgICBcIkNvbnRpbnVlXCI6IFwiQSBjb250aW51ZSBzdGF0ZW1lbnRcIixcbiAgICBcIkRlbFwiOiBcIkEgZGVsZXRlIHN0YXRlbWVudFwiLFxuICAgIFwiRGVsZXRlXCI6IFwiQSBkZWxldGlvblwiLFxuICAgIFwiRGljdFwiOiBcIkEgZGljdGlvbmFyeSBsaXRlcmFsXCIsXG4gICAgXCJEaWN0Q29tcFwiOiBcIkEgZGljdGlvbmFyeSBjb21wcmVoZW5zaW9uXCIsXG4gICAgXCJEaXZcIjogXCJBIGRpdmlzaW9uIG9wZXJhdG9yXCIsXG4gICAgXCJFbGxpcHNpc1wiOiBcIkFuIGVsbGlwc2lzXCIsXG4gICAgXCJFcVwiOiBcIkFuIGVxdWFsaXR5IGNvbXBhcmlzb24gb3BlcmF0b3JcIixcbiAgICBcIkV4Y2VwdEhhbmRsZXJcIjogXCJBbiBleGNlcHQgaGFuZGxlclwiLFxuICAgIFwiRXhwclwiOiBcIkFuIGV4cHJlc3Npb24gdXNlZCBhcyBhIHN0YXRlbWVudFwiLFxuICAgIFwiRXhwcmVzc2lvblwiOiBcIkFuIGV2YWx1YXRlZCBleHByZXNzaW9uXCIsXG4gICAgXCJFeHRTbGljZVwiOiBcIkEgbXVsdGktZGltZW5zaW9uYWwgc2xpY2VcIixcbiAgICBcIkZsb29yRGl2XCI6IFwiQW4gaW50ZWdlciBkaXZpc2lvbiBvcGVyYXRvclwiLFxuICAgIFwiRm9yXCI6IFwiQSBGT1IgbG9vcFwiLFxuICAgIFwiRm9ybWF0dGVkVmFsdWVcIjogXCJBIGZvcm1hdHRlZCB2YWx1ZSBpbiBhbiBmLXN0cmluZ1wiLFxuICAgIFwiRnVuY3Rpb25EZWZcIjogXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cIixcbiAgICBcIkdlbmVyYXRvckV4cFwiOiBcIkEgZ2VuZXJhdG9yIGV4cHJlc3Npb25cIixcbiAgICBcIkdsb2JhbFwiOiBcIkEgZ2xvYmFsIHN0YXRlbWVudFwiLFxuICAgIFwiR3RcIjogXCJBIGdyZWF0ZXIgdGhhbiBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJHdEVcIjogXCJBIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJJZlwiOiBcIkFuIElGIHN0YXRlbWVudFwiLFxuICAgIFwiSWZFeHBcIjogXCJBbiBJRiBleHByZXNzaW9uXCIsXG4gICAgXCJJbXBvcnRcIjogXCJBbiBpbXBvcnQgc3RhdGVtZW50XCIsXG4gICAgXCJJbXBvcnRGcm9tXCI6IFwiQW4gaW1wb3J0L2Zyb20gc3RhdGVtZW50XCIsXG4gICAgXCJJblwiOiBcIkFuIElOIG9wZXJhdG9yXCIsXG4gICAgXCJJbmRleFwiOiBcIkFuIGluZGV4XCIsXG4gICAgXCJJbnRlcmFjdGl2ZVwiOiBcIkFuIGludGVyYWN0aXZlIGV4cHJlc3Npb25cIixcbiAgICBcIkludmVydFwiOiBcIkFuIGludmVydCBvcGVyYXRvclwiLFxuICAgIFwiSXNcIjogXCJBbiBJUyBvcGVyYXRvclwiLFxuICAgIFwiSXNOb3RcIjogXCJBbiBJUyBOT1Qgb3BlcmF0b3JcIixcbiAgICBcIkpvaW5lZFN0clwiOiBcIkFuIGYtc3RyaW5nXCIsXG4gICAgXCJMU2hpZnRcIjogXCJBIGxlZnQgc2hpZnQgb3BlcmF0b3JcIixcbiAgICBcIkxhbWJkYVwiOiBcIkEgbGFtYmRhIGV4cHJlc3Npb25cIixcbiAgICBcIkxpc3RcIjogXCJBIGxpc3QgbGl0ZXJhbFwiLFxuICAgIFwiTGlzdENvbXBcIjogXCJBIGxpc3QgY29tcHJlaGVuc2lvblwiLFxuICAgIFwiTG9hZFwiOiBcIkEgbG9hZFwiLFxuICAgIFwiTHRcIjogXCJBIGxlc3MgdGhhbiBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJMdEVcIjogXCJBIGxlc3MgdGhhbiBvciBlcXVhbCB0byBjb21wYXJpc29uIG9wZXJhdG9yXCIsXG4gICAgXCJNYXRNdWx0XCI6IFwiQSBtYXRyaXggbXVsdGlwbGljYXRpb24gb3BlcmF0b3JcIixcbiAgICBcIk1vZFwiOiBcIkEgbW9kdWxvIG9wZXJhdG9yXCIsXG4gICAgXCJNb2R1bGVcIjogXCJBIG1vZHVsZVwiLFxuICAgIFwiTXVsdFwiOiBcIkEgbXVsdGlwbGljYXRpb24gb3BlcmF0b3JcIixcbiAgICBcIk5hbWVcIjogXCJBIG5hbWVcIixcbiAgICBcIk5hbWVDb25zdGFudFwiOiBcIkEgbmFtZSBjb25zdGFudFwiLFxuICAgIFwiTm9ubG9jYWxcIjogXCJBIG5vbmxvY2FsIHN0YXRlbWVudFwiLFxuICAgIFwiTm90XCI6IFwiQSBub3Qgb3BlcmF0b3JcIixcbiAgICBcIk5vdEVxXCI6IFwiQSBub3QgZXF1YWwgdG8gY29tcGFyaXNvbiBvcGVyYXRvclwiLFxuICAgIFwiTm90SW5cIjogXCJBIE5PVCBJTiBvcGVyYXRvclwiLFxuICAgIFwiTnVtXCI6IFwiQSBudW1lcmljIGxpdGVyYWxcIixcbiAgICBcIk9yXCI6IFwiQSBib29sZWFuIE9SIG9wZXJhdG9yXCIsXG4gICAgXCJQYXJhbVwiOiBcIkEgcGFyYW1ldGVyXCIsXG4gICAgXCJQYXNzXCI6IFwiQSBwYXNzIHN0YXRlbWVudFwiLFxuICAgIFwiUG93XCI6IFwiQSBwb3dlciBvcGVyYXRvclwiLFxuICAgIFwiUlNoaWZ0XCI6IFwiQSByaWdodCBzaGlmdCBvcGVyYXRvclwiLFxuICAgIFwiUmFpc2VcIjogXCJBIHJhaXNlIHN0YXRlbWVudFwiLFxuICAgIFwiUmV0dXJuXCI6IFwiQSByZXR1cm4gc3RhdGVtZW50XCIsXG4gICAgXCJTZXRcIjogXCJBIHNldCBsaXRlcmFsXCIsXG4gICAgXCJTZXRDb21wXCI6IFwiQSBzZXQgY29tcHJlaGVuc2lvblwiLFxuICAgIFwiU2xpY2VcIjogXCJBIHNsaWNlXCIsXG4gICAgXCJTdGFycmVkXCI6IFwiQSBzdGFycmVkIGFyZ3VtZW50XCIsXG4gICAgXCJTdG9yZVwiOiBcIkEgc3RvcmVcIixcbiAgICBcIlN0clwiOiBcIkEgc3RyaW5nIGxpdGVyYWxcIixcbiAgICBcIlN1YlwiOiBcIkEgc3VidHJhY3Rpb24gb3BlcmF0b3JcIixcbiAgICBcIlN1YnNjcmlwdFwiOiBcIkEgc3Vic2NyaXB0XCIsXG4gICAgXCJTdWl0ZVwiOiBcIkEgc3VpdGVcIixcbiAgICBcIlRyeVwiOiBcIkEgdHJ5IHN0YXRlbWVudFwiLFxuICAgIFwiVHVwbGVcIjogXCJBIHR1cGxlIGxpdGVyYWxcIixcbiAgICBcIlR5cGVJZ25vcmVcIjogXCIgYSB0eXBlIGlnbm9yZVwiLFxuICAgIFwiVUFkZFwiOiBcIkEgdW5hcnkgYWRkaXRpb24gb3BlcmF0b3JcIixcbiAgICBcIlVTdWJcIjogXCJBIHVuYXJ5IHN1YnRyYWN0aW9uIG9wZXJhdG9yXCIsXG4gICAgXCJVbmFyeU9wXCI6IFwiQSB1bmFyeSBvcGVyYXRvclwiLFxuICAgIFwiV2hpbGVcIjogXCJBIHdoaWxlIGxvb3BcIixcbiAgICBcIldpdGhcIjogXCJBIHdpdGggc3RhdGVtZW50XCIsXG4gICAgXCJZaWVsZFwiOiBcIkEgeWllbGQgc3RhdGVtZW50XCIsXG4gICAgXCJZaWVsZEZyb21cIjogXCJBIHlpZWxkL2Zyb20gc3RhdGVtZW50XCJcbn07XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1B5VHJhY2Uge1xuXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuXG4gICAgICAgIHRoaXMuSUdOT1JFRF9HTE9CQUxTID0gW1wiX19uYW1lX19cIiwgXCJfX2RvY19fXCIsIFwiX19wYWNrYWdlX19cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc21ldGhvZFwiLCBcInByb3BlcnR5XCIsIFwic3RhdGljbWV0aG9kXCIsIFwiJGZyZWVcIiwgXCIkY2VsbFwiXTtcblxuICAgICAgICAvLyB0aGlzLnRyYWNlLmNsaWNrKHRoaXMuYnVpbGRUcmFjZVRhYmxlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN1bWUgYSBzZXQgb2YgdmFyaWFibGVzIHRyYWNlZCBmcm9tIHRoZSBleGVjdXRpb24gYW5kIHBhcnNlIG91dCBhbnlcbiAgICAgKiBnbG9iYWwgdmFyaWFibGVzIGFuZCBtb2R1bGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhcmlhYmxlcyAtIGEgbWFwcGluZyBvZiB2YXJpYWJsZSBuYW1lcyB0byB0aGVpciBTa3VwdCB2YWx1ZS5cbiAgICAgKi9cbiAgICBwYXJzZUdsb2JhbHModmFyaWFibGVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG1vZHVsZXMgPSBbXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh2YXJpYWJsZXMpO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnRyYWNlRXhlY3V0aW9uKCkpIHtcbiAgICAgICAgICAgIC8qaWYgKFwiJGNlbGxcIiBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB7Li4udmFyaWFibGVzLCAuLi52YXJpYWJsZXMuJGNlbGx9O1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAvKmlmIChcIiRmcmVlXCIgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzID0gey4uLnZhcmlhYmxlcywgLi4udmFyaWFibGVzLiRmcmVlfTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFyaWFibGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5JR05PUkVEX0dMT0JBTFMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKFwiXyRydyRcIiwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiXyRybiRcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBCbG9ja1B5VHJhY2UucGFyc2VWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHtcIm5hbWVcIjogcHJvcGVydHksIFwidHlwZVwiOiBcIlVua25vd25cIiwgXCJ2YWx1ZVwiOiB2YWx1ZS50b1N0cmluZygpfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBTay5idWlsdGluLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlcy5wdXNoKHZhbHVlLiRkLl9fbmFtZV9fLnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XCJwcm9wZXJ0aWVzXCI6IHJlc3VsdCwgXCJtb2R1bGVzXCI6IG1vZHVsZXN9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgU2t1bHB0IHZhbHVlIGludG8gYSBtb3JlIGVhc2lseSBwcmludGFibGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIHNrdWxwdCB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSwgZnVsbExlbmd0aCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiVW5rbm93blwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJVbmRlZmluZWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZGF0YWNsYXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRGVjb3JhdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIjxkYXRhY2xhc3MgZGVjb3JhdG9yPlwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZnVuYzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmZ1bmNfY29kZS5jb192YXJuYW1lcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBQYXJhbWV0ZXJzOiBcIit2YWx1ZS5mdW5jX2NvZGUuY29fdmFybmFtZXMuam9pbihcIiwgXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBObyBwYXJhbWV0ZXJzXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5tb2R1bGU6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnN0cjpcbiAgICAgICAgICAgICAgICBpZiAoZnVsbExlbmd0aCB8fCB2YWx1ZS52Lmxlbmd0aCA8PSAzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIltcIit2YWx1ZS5zcSRsZW5ndGgoKStcIiBjaGFyYWN0ZXJzIG5vdCBzaG93bl1cIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5ub25lOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJOb25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJOb25lXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmJvb2w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5tYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRcIiA9PT0gdmFsdWUuc2tUeXBlID8gXCJJbnRlZ2VyXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmludF86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZsb2F0XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnR1cGxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJUdXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubGlzdDpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudi5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJbLi4uIFwiK3ZhbHVlLnYubGVuZ3RoK1wiIGVsZW1lbnRzIC4uLl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZGljdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHZhbHVlICUgMSA9PT0gMCA/IFwiSW50ZWdlclwiIDogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiAodmFsdWUgPyBcIlRydWVcIjogXCJGYWxzZVwiKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUudHAkbmFtZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiB2YWx1ZS50cCRuYW1lLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbn1cblxuLy8gVE9ETzogdmlld0V4YWN0VmFsdWUiLCIvKipcbiAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxpc3QuXG4gKiBAcGFyYW0ge2FueXRoaW5nfSBuZWVkbGUgLSBUaGUgZWxlbWVudCB0byBsb29rIGZvci5cbiAqIEBwYXJhbSB7QXJyYXl9IGhheXN0YWNrIC0gVGhlIGxpc3QgdG8gc2VhcmNoLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBleGlzdHNcbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWlucyhuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+IC0xO1xufVxuXG4vKipcbiAqIFJlbW92ZSBkdXBsaWNhdGUgdmFsdWVzIGZyb20gYW4gYXJyYXksIHByZXNlcnZpbmcgb3JkZXIuXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5LCBzbyBpcyBub24tZGVzdHJ1Y3RpdmUuXG4gKiBDb3VydGVzeTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1ODQzNzAvaG93LXRvLW1lcmdlLXR3by1hcnJheXMtaW4tamF2YXNjcmlwdC1hbmQtZGUtZHVwbGljYXRlLWl0ZW1zXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gdW5pcXVpZnkuIEVsZW1lbnRzIGNvbXBhcmVkIHdpdGggPT09LlxuICovXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShhcnJheSkge1xuICAgIHZhciBhID0gYXJyYXkuY29uY2F0KCk7XG4gICAgZm9yKHZhciBpPTA7IGk8YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBmb3IodmFyIGo9aSsxOyBqPGEubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmKGFbaV0gPT09IGFbal0pIHthLnNwbGljZShqLS0sIDEpO31cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBleHRlbmRpbmcgYW4gYXJyYXkgYmFzZWRcbiAqIG9uIGFuIFwiYWRkQXJyYXlcIiBhbmQgXCJyZW1vdmVBcnJheVwiLiBBbnkgZWxlbWVudFxuICogZm91bmQgaW4gcmVtb3ZlQXJyYXkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBmaXJzdCBhcnJheVxuICogYW5kIGFsbCB0aGUgZWxlbWVudHMgb2YgYWRkQXJyYXkgYXJlIGFkZGVkLlxuICogQW55IGR1cGxpY2F0ZSBpdGVtcyBhcmUgcmVtb3ZlZC5cbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXksIHNvIGlzIG5vbi1kZXN0cnVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byBtYW5pcHVsYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhZGRBcnJheSAtIHRoZSBlbGVtZW50cyB0byBhZGQgdG8gdGhlIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVBcnJheSAtIHRoZSBlbGVtZW50cyB0byByZW1vdmUgZnJvbSB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbW9kaWZpZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZXhwYW5kQXJyYXkoYXJyYXksIGFkZEFycmF5LCByZW1vdmVBcnJheSkge1xuICAgIHZhciBjb3B5QXJyYXkgPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlQXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTE7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5VW5pcXVlKGNvcHlBcnJheS5jb25jYXQoYWRkQXJyYXkpKTtcbn1cblxuLyoqXG4gKiBEZWVwbHkgY2xvbmVzIGEgbm9kZVxuICogQHBhcmFtIHtOb2RlfSBub2RlIEEgbm9kZSB0byBjbG9uZVxuICogQHJldHVybiB7Tm9kZX0gQSBjbG9uZSBvZiB0aGUgZ2l2ZW4gbm9kZSBhbmQgYWxsIGl0cyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSkge1xuICAgIC8vIElmIHRoZSBub2RlIGlzIGEgdGV4dCBub2RlLCB0aGVuIHJlLWNyZWF0ZSBpdCByYXRoZXIgdGhhbiBjbG9uZSBpdFxuICAgIHZhciBjbG9uZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUubm9kZVZhbHVlKSA6IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiBcbiAgICAvLyBSZWN1cnNlICAgICBcbiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUoY2hpbGQpIHtcbiAgICAgICAgY2xvbmUuYXBwZW5kQ2hpbGQoY2xvbmVOb2RlKGNoaWxkKSk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgICBcbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbi8qKlxuICogSW5kZW50cyB0aGUgZ2l2ZW4gc3RyaW5nIGJ5IDQgc3BhY2VzLiBUaGlzIGNvcnJlY3RseSBoYW5kbGVzIG11bHRpLWxpbmUgc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBiZSBtYW5pcHVsYXRlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgd2l0aCBmb3VyIHNwYWNlcyBhZGRlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgbmV3IGxpbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRlbnQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKD89LikvZ20sIFwiICAgIFwiKTtcbn1cblxuLyoqXG4gKiBUdXJucyBzcGFjZXMgaW50byB1bmRlcnNjb3JlcyBpbiB0aGUgc3RyaW5nLCBtYWtlcyBpdCBsb3dlcmNhc2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdGhlIHN0cmluZyB0byBiZSBtYW5pcHVsYXRlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsdWcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMvZywgXCJfXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGJlIGNhcGl0YWxpemVkLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gW2BtaW5gLCBgbWF4YF0uXG4gKiBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbG93ZXN0IHBvc3NpYmxlIGludGVnZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIGhpZ2hlc3QgcG9zc2libGUgaW50ZWdlciAoaW5jbHVzaXZlKS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludGVnZXIobWluLG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKG1heC1taW4rMSkrbWluKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIHNvbWUgdGV4dCBzbyB0aGF0IGl0IGNhbiBiZSBzYWZlbHkgd3JpdHRlbiBpbnRvIGFuIEhUTUwgYm94LlxuICogVGhpcyBpbmNsdWRlcyByZXBsYWNpbmcgc3BlY2lhbCBIVE1MIGNoYXJhY3RlcnMgKCYsIDwsID4sIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgdGV4dCB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBIVE1MLXNhZmUgdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUhUTUwoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAgICAgLnJlcGxhY2UoLycvZywgXCImYXBvcztcIik7XG59XG5cbi8qKlxuICogU2h1ZmZsZSB0aGUgYmxvY2tzIGluIHRoZSB3b3Jrc3BhY2VcbiAqL1xuaWYgKHR5cGVvZiBCbG9ja2x5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgQmxvY2tseS5Xb3Jrc3BhY2VTdmcucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLmdldE1ldHJpY3MoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gbWV0cmljcy52aWV3V2lkdGggLyAyLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbWV0cmljcy52aWV3SGVpZ2h0O1xuICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5nZXRUb3BCbG9ja3MoZmFsc2UpO1xuICAgICAgICB2YXIgeSA9IDUsIHggPSAwLFxuICAgICAgICAgICAgbWF4aW1hbF9pbmNyZWFzZSA9IGhlaWdodC9ibG9ja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAvLyBHZXQgYSBibG9ja1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gYmxvY2tzW2ldO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBibG9jay5nZXRSZWxhdGl2ZVRvU3VyZmFjZVhZKCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSAtcHJvcGVydGllcy54K3JhbmRvbUludGVnZXIoMTAsIHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLm1vdmVCeSh4LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAtcHJvcGVydGllcy55K3kpO1xuICAgICAgICAgICAgeSA9IHkgKyByYW5kb21JbnRlZ2VyKDUsIG1heGltYWxfaW5jcmVhc2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBNb3ZlIGVsZW1lbnRzIGZyb20gb25lIGFycmF5IHRvIGFub3RoZXIgYmFzZWQgb24gYSBjb25kaXRpb25hbCBjaGVjay5cbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxODg3OTY3L2phdmFzY3JpcHQtbW92ZS1vYmplY3RzLWZyb20tb25lLWFycmF5LXRvLWFub3RoZXItYmVzdC1hcHByb2FjaFxuICovXG5mdW5jdGlvbiBtb3ZlRWxlbWVudHMoc291cmNlLCB0YXJnZXQsIG1vdmVDaGVjaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc291cmNlW2ldO1xuICAgICAgICBpZiAobW92ZUNoZWNrKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBzb3VyY2Uuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9IFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZSgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIG9uZSBvZiB0aGUgU2suYnVpbHRpbiBvYmplY3RzXG4gKiBUT0RPOiBtYWtlIHRoaXMgc28gd2UgZG9uJ3QgaGF2ZSB0byBleHBsaWNpdGx5IHB1dCBvdXQgZXZlcnkgb3B0aW9uXG4gKiAgICAgICAgICBvbmUgcG9zc2libGUgdGhpbmcgd2UgY291bGQgZG8gaXMgZ2V0IGEgc3RyaW5nIHZlcnNpb24gb2YgdGhlIFxuICogICAgICAgICAgb2YgdGhlIGNvbnN0cnVjdG9yIGFuZCBsb29rIGZvciB0aGUgc3Vic3RyaW5nIFwicmV0dXJuIG5ldyBTay5idWlsdGluXCJcbiAqICAgICAgICAgIEJ1dCBJIGRvbid0IGtub3cgaG93IHJlbGlhYmxlIHRoYXQgaXMuICBSYXRoZXIsIGl0J3Mga2luZCBvZiBoYWNraXNoLlxuICogICAgICAgICAgU2hvdWxkIHRlaG9yZXRpY2FsbHkgYmVsb25nIGluIFNrLmZmaVxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gYmUgZXhhbWluZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBvbmUgb2YgdGhlIFNrLmJ1aWx0aW4gdHlwZXNcbioqL1xuZnVuY3Rpb24gaXNTa0J1aWx0aW4ob2JqKXtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubGlzdCkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmJvb2wpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XykgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpO1xuICAgIC8vdmFyIGNvbnNfc3RyID0gb2JqLmNvbnN0cnVjdG9yICsgXCJcIjtcbiAgICAvL3JldHVybiBjb25zX3N0ci5pbmRleE9mKFwicmV0dXJuIG5ldyBTay5idWlsdGluXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gaXNBc3ROb2RlKG9iail7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiBcIl9hc3RuYW1lXCIgaW4gb2JqO1xufVxuXG5jb25zdCBERUZBVUxUX1NFQ1RJT05fUEFUVEVSTiA9IC9eKCMjIyMjIFBhcnQgKC4rKSkkL2dtO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBnaXZlbiBQYXJ0IElEIHVzaW5nIHRoZSBwYXR0ZXJuIGAjIyMjIFBhcnQgd2hhdGV2ZXJgIChvbiBpdHMgb3duIHNlcGFyYXRlIGxpbmUpLiBJZiB0aGUgcGF0dGVyblxuICogaXMgbm90IGZvdW5kLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuIElmIG5vIHBhdHRlcm4gaXMgZ2l2ZW4gKGVtcHR5IHN0cmluZyBvciBudWxsKSwgdGhlbiB0aGUgb3JpZ2luYWwgdGV4dFxuICogaXMgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxuICogQHBhcmFtIHRleHRcbiAqIEBwYXJhbSBwYXJ0SWRcbiAqIEByZXR1cm5zIHtudWxsfCp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFydCh0ZXh0LCBwYXJ0SWQpIHtcbiAgICBpZiAocGFydElkID09PSBcIlwiIHx8IHBhcnRJZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoREVGQVVMVF9TRUNUSU9OX1BBVFRFUk4pO1xuICAgIGZvciAobGV0IGk9MjsgaSA8IHBhcnRzLmxlbmd0aDsgaSs9Mykge1xuICAgICAgICAvKiAvLyBVbm5lY2Vzc2FyeSBhc3NlcnRpb24sIGJ1dCBub3QgYmFkIHRvIHRoaW5rIGFib3V0XG4gICAgICAgIGlmICghcGFydHNbaS0xXS5zdGFydHNXaXRoKFwiIyMjIyBQYXJ0IFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJFcnJvcjogcGFydCBmb3JtYXQgaXMgYnJva2VuIVwiO1xuICAgICAgICB9Ki9cbiAgICAgICAgaWYgKHBhcnRzW2ldID09PSBwYXJ0SWQpIHtcbiAgICAgICAgICAgIGxldCBib2R5ID0gcGFydHNbaSsxXTtcbiAgICAgICAgICAgIGlmIChib2R5ICYmIGJvZHlbMF0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSBwYXJ0cy5sZW5ndGggLSAzICYmIGJvZHkgJiYgYm9keS5zbGljZSgtMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBTaG91bGQgdGhlb3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpLCBidXQgSSBwdXQgaXQgaGVyZSBpbnN0ZWFkIHRvIG5vdCBtZXNzIHVwIHRoZSBza3VscHQgZmlsZXNcbiAqIGxpa2UgdGhlIG5vcm1hbCBTay5mZmkucmVtYXBUb1B5LCBpdCBkb2Vzbid0IHdvcmsgZm9yIGZ1bmN0aW9ucyBvciBtb3JlIGNvbXBsZXggb2JqZWN0cywgYnV0IGl0IGhhbmRsZXNcbiAqIGNhc2VzIHdoZXJlIHRoZSB0eXBlcyBpbiBvYmogYXJlIGEgbWl4IG9mIHB5dGhvbiBTSU1QTEUgb2JqZWN0cyBhbmQgU0lNUExFIG5vcm1hbCBqYXZhc2NyaXB0IG9iamVjdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7U2suYnVpbHRpbi4/Pz99IC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBweXRob24gb2JqZWN0LCBkcm9wcGluZyBhbGwgZnVuY3Rpb25zIGFuZCB0aGluZ3MgaXQgY2FuJ3QgY29udmVydFxuKiovXG5mdW5jdGlvbiBtaXhlZFJlbWFwVG9QeShvYmope1xuICAgIHZhciBrO1xuICAgIHZhciBrdnM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFycjtcbiAgICAvL0BUT0RPOiBzaG91bGQgdGhlb3JldGljYWxseSBjaGVjayBpZiB0aGUgb2JqZWN0IGlzIGEgcHlob24gZGljdCBvciBhcnJheSB3aXRoIGpzIG9iamVjdHNcbiAgICBpZiAoaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFscmVhZHkgcHl0aG9uIHJlYWR5XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIC8vb2JqZWN0IGlzIGFjdHVhbGx5IGEgamF2YXNjcmlwdCBhcnJheVxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy9mb3IgZWFjaCBvYmplY3QsIGNvbnZlcnQgaXQgdG8gYSBweXRob24gb2JqZWN0IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICB2YXIgc3VidmFsID0gb2JqW2ldO1xuICAgICAgICAgICAgaWYoIWlzU2tCdWlsdGluKHN1YnZhbCkpe1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKG1peGVkUmVtYXBUb1B5KHN1YnZhbCkpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc3VidmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChhcnIpO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7Ly9udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZighaXNTa0J1aWx0aW4ob2JqKSl7XG4gICAgICAgICAgICAvL2Fzc3VtaW5nIGl0J3MgYSBzdGFuZGFyZCBkaWN0aW9uYXJ5XG4gICAgICAgICAgICBrdnMgPSBbXTsvL1NrLmJ1aWx0aW4uZGljdCB1c2VzIGFuIGFycmF5IG9mIGtleS12YWx1ZSxrZXktdmFsdWUuLi5cbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIGtleSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShrKSk7XG4gICAgICAgICAgICAgICAgLy9jb3ZlcnQgY29ycmVzcG9uZGluZyB2YWx1ZSBpZiBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgICAgICBrdnMucHVzaChtaXhlZFJlbWFwVG9QeShvYmpba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY3JlYXRlIHRoZSBuZXcgZGljdGlvbmFyeVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3Qoa3ZzKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQob2JqKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKG9iaik7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iai5uYW1lKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCkge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgaCA9IE1hdGguZmxvb3IodG9kYXkuZ2V0SG91cnMoKSUxMik7XG4gICAgbGV0IG0gPSB0b2RheS5nZXRNaW51dGVzKCk7XG4gICAgLy9sZXQgcyA9IHRvZGF5LmdldFNlY29uZHMoKTtcbiAgICBpZiAobSA8IDEwKSB7bSA9IFwiMFwiICsgbTt9XG4gICAgLy9pZiAocyA8IDEwKSB7cyA9IFwiMFwiICsgczt9XG4gICAgbGV0IHAgPSBcImFtXCI7XG4gICAgaWYgKHRvZGF5LmdldEhvdXJzKCk+PTEyKSB7XG4gICAgICAgIHAgPSBcInBtXCI7XG4gICAgfVxuICAgIHJldHVybiBgJHtofToke219JHtwfWA7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fOyJdLCJzb3VyY2VSb290IjoiIn0=