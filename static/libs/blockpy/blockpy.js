(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"), require("ko"));
	else if(typeof define === 'function' && define.amd)
		define("blockpy", ["jQuery", "ko"], factory);
	else if(typeof exports === 'object')
		exports["blockpy"] = factory(require("jQuery"), require("ko"));
	else
		root["blockpy"] = factory(root["jQuery"], root["ko"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_jquery__, __WEBPACK_EXTERNAL_MODULE_knockout__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/blockpy.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/blockpy.js":
/*!************************!*\
  !*** ./src/blockpy.js ***!
  \************************/
/*! exports provided: _IMPORTED_COMPLETE_DATASETS, _IMPORTED_DATASETS, BlockPy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPy", function() { return BlockPy; });
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/blockpy.css */ "./src/css/blockpy.css");
/* harmony import */ var _css_blockpy_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_blockpy_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/bootstrap_retheme.css */ "./src/css/bootstrap_retheme.css");
/* harmony import */ var _css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_bootstrap_retheme_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! skulpt_modules/image */ "./src/skulpt_modules/image.js");
/* harmony import */ var skulpt_modules_weakref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! skulpt_modules/weakref */ "./src/skulpt_modules/weakref.js");
/* harmony import */ var storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! storage.js */ "./src/storage.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var editor_python_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! editor/python.js */ "./src/editor/python.js");
/* harmony import */ var server_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! server.js */ "./src/server.js");
/* harmony import */ var interface_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! interface.js */ "./src/interface.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./files */ "./src/files.js");
/* harmony import */ var _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./editor/abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var engine_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! engine.js */ "./src/engine.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./trace */ "./src/trace.js");
/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./console */ "./src/console.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dialog */ "./src/dialog.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _corgis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./corgis */ "./src/corgis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_COMPLETE_DATASETS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _corgis__WEBPACK_IMPORTED_MODULE_18__["_IMPORTED_DATASETS"]; });

/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./history */ "./src/history.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @fileoverview Starting point of the BlockPy application, containing the main
 * BlockPy class.
 */




 //import {$builtinmodule as matplotlibModule} from "skulpt_modules/matplotlib2";





















var EDITOR_VERSION = "5.1.2";
/**
 * Major entry point for creating a BlockPy instance.
 * Two most important fields are `model` and `components`.
 * The `model` holds all the data about the interface.
 * The `components` are references to the disparate parts of BlockPy.
 *
 * Most of this classes definition is just initializing the model and updating
 * it on an assignment switch.
 */

var BlockPy = /*#__PURE__*/function () {
  /**
   * @param {Object} configuration - User level settings (e.g., what editor mode, whether to mute semantic errors, etc.)
   * @param {Object} assignment - Assignment level settings (data about the loaded assignment, user, submission, etc.)
   * @param {Object} submission - Includes the source code of any programs to be loaded
   */
  function BlockPy(configuration, assignment, submission) {
    _classCallCheck(this, BlockPy);

    this.initModel(configuration);

    if (assignment !== undefined) {
      this.setAssignment(configuration, assignment, submission);
    }

    this.initMain();
  }
  /**
   * Initializes the BlockPy object by initializing its interface,
   * model, and components.
   *
   */


  _createClass(BlockPy, [{
    key: "initMain",
    value: function initMain() {
      this.initUtilities();
      this.initModelMethods();
      this.turnOnHacks();
      this.initInterface();
      this.applyModel();
      this.initComponents();
      this.makeExtraSubscriptions();
      this.start();
    }
  }, {
    key: "getSetting",

    /**
     * Retrieves a default value or
     * @param {string} key - the key to look up a value for
     * @param {Object} defaultValue - if the key is not found anywhere, use this value
     */
    value: function getSetting(key, defaultValue) {
      if (key in this.initialConfiguration_) {
        return this.initialConfiguration_[key];
      } else if (this.localSettings_.has(key)) {
        return this.localSettings_.get(key);
      } else {
        return defaultValue;
      }
    }
    /**
     * Initializes the model to its defaults.
     *
     * Categories:
     *   * user: values for the current user (stored to server)
     *   * assignment: values for the current assignment (stored to server)
     *   * submission: values for the current submission (stored to server)
     *   * display: flags related to current visibility (stored to localSettings)
     *   * status: messages related to current status (not stored)
     *   * execution: values related to last run (not stored)
     *   * configuration: constant values related to setup (not stored)
     */

  }, {
    key: "initModel",
    value: function initModel(configuration) {
      // Connect to local storage
      this.localSettings_ = new storage_js__WEBPACK_IMPORTED_MODULE_5__["LocalStorageWrapper"]("localSettings");
      this.initialConfiguration_ = configuration;
      this.model = {
        user: {
          id: ko.observable(configuration["user.id"]),
          name: ko.observable(configuration["user.name"]),

          /**
           * Whether you are an Owner (can modify the assignment), Grader (can view
           * the assignments' information) or Student (can not see any instructor stuff).
           * @type {bool}
           */
          role: ko.observable(this.getSetting("user.role", "owner")),

          /**
           * Current course for this user
           */
          courseId: ko.observable(configuration["user.course_id"]),

          /**
           * Current assignment group that this user is inside
           */
          groupId: ko.observable(configuration["user.group_id"])
        },
        assignment: {
          id: ko.observable(null),
          name: ko.observable("Scratch Canvas"),
          instructions: ko.observable("Welcome to BlockPy. Try editing and running the code below."),

          /**
           * The human-friendly URL to use as a shortcut for this assignment
           */
          url: ko.observable(""),
          // TODO: warning message if maze
          type: ko.observable(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["AssigmentType"].BLOCKPY),
          points: ko.observable(null),
          startingCode: ko.observable(configuration["assignment.starting_code"] || ""),
          onRun: ko.observable(configuration["assignment.on_run"] || ""),
          onChange: ko.observable(configuration["assignment.on_change"] || null),
          onEval: ko.observable(configuration["assignment.on_eval"] || null),
          extraInstructorFiles: ko.observableArray(Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(configuration["assignment.extra_instructor_files"]) || []),
          extraStartingFiles: ko.observableArray([]),
          forkedId: ko.observable(null),
          forkedVersion: ko.observable(null),
          ownerId: ko.observable(null),
          courseId: ko.observable(null),
          version: ko.observable(null),
          tags: ko.observableArray([]),
          sampleSubmissions: ko.observableArray([]),
          reviewed: ko.observable(configuration["assignment.reviewed"]),
          "public": ko.observable(configuration["assignment.public"]),
          hidden: ko.observable(configuration["assignment.hidden"]),
          ipRanges: ko.observable(configuration["assignment.ip_ranges"]),
          settings: Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["makeAssignmentSettingsModel"])(configuration)
        },
        submission: {
          id: ko.observable(null),
          code: ko.observable(configuration["submission.code"] || ""),
          extraFiles: ko.observableArray([]),
          url: ko.observable(""),
          endpoint: ko.observable(""),
          score: ko.observable(0),
          correct: ko.observable(false),
          // assignmentId inferred from assignment.id
          // courseId inferred from user.courseId
          // userId inferred from user.id
          // assignmentVersion inferred from assignment.version
          version: ko.observable(0),
          submissionStatus: ko.observable("Started"),
          gradingStatus: ko.observable("NotReady"),
          ownerId: ko.observable(null)
        },
        display: {
          /**
           * Currently visible File, if applicable
           * @type {String}
           */
          filename: ko.observable(null),

          /**
           * Whether or not to be presented with the instructor settings and files
           * @type {bool}
           */
          instructor: ko.observable("" + this.getSetting("display.instructor", "false") === "true"),

          /**
           * Whether or not to prevent the printer from showing things
           */
          mutePrinter: ko.observable(false),

          /**
           * (Python Views) The current editor mode.
           * @type {DisplayModes}
           */
          pythonMode: ko.observable(this.getSetting("display.python.mode", editor_python_js__WEBPACK_IMPORTED_MODULE_7__["DisplayModes"].SPLIT)),

          /**
           * Whether or not History mode is engaged.
           * @type {bool}
           */
          historyMode: ko.observable(false),

          /**
           * Whether or not to be auto-saving changes in Python editor
           * If an integer, specifies the delay that should be used (microseconds).
           * This is never on in non-Python editors.
           * @type {bool|int}
           */
          autoSave: ko.observable(true),

          /**
           * Whether or not the console is full width and feedback is hidden
           */
          bigConsole: ko.observable(false),

          /**
           * The height to use for the console.
           *    If null, then let the height remain unchanged
           *    If a number, then the
           */
          previousConsoleHeight: ko.observable(null),
          currentConsoleHeight: ko.observable(null),

          /**
           * Which panel to show in the second row's second column
           * @type {SecondRowSecondPanelOptions}
           */
          secondRowSecondPanel: ko.observable(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK),
          previousSecondRowSecondPanel: ko.observable(null),

          /**
           * Whether or not to be tracing the code right now
           */
          traceExecution: ko.observable(false),

          /**
           * The list of promises to still resolve while loading datasets
           * @type {Array<Promise>}
           */
          loadingDatasets: ko.observableArray([]),

          /**
           * The temporary changed value of the instructions have been changed from what is in the assignment
           */
          changedInstructions: ko.observable(null),

          /**
           * A holder for the timer to trigger on-changes
           */
          triggerOnChange: null,

          /**
           * Whether the current feedback and output corresponds to the current submission.
           * This would be false if there is no feedback/output (i.e., code has not been run),
           * or if the user has modified the submission after the last run (e.g., by editing
           * the text).
           */
          dirtySubmission: ko.observable(true),

          /**
           *  Whether or not to make the BlockPy element in FULL SCREEN mode. Sadly, not fullscreen
           *  within the window, but FULL SCREEN. Very aggressive.
           */
          fullscreen: ko.observable(false),

          /**
           * User-supplied passcode to compare on the server against the current passcode.
           */
          passcode: ko.observable(""),

          /**
           * Whether or not to clear out inputs after a run/on_run cycle
           */
          clearInputs: ko.observable(true),

          /**
           * Whether or not images should be rendered (true), or just stay as text code (false).
           */
          renderImages: ko.observable(true),
          editorVersion: EDITOR_VERSION,
          readOnly: ko.observable(this.getSetting("display.read_only", "false").toString() === "true"),

          /**
           * Uploaded files are ones that have been listed by the remote
           */
          uploadedFiles: ko.observable(null)
        },
        status: {
          // @type {ServerStatus}
          loadAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          loadHistory: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadHistoryMessage: ko.observable(""),
          // @type {ServerStatus}
          loadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          loadDataset: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          loadDatasetMessage: ko.observable(""),
          // @type {ServerStatus}
          logEvent: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          logEventMessage: ko.observable(""),
          // @type {ServerStatus}
          saveImage: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveImageMessage: ko.observable(""),
          // @type {ServerStatus}
          saveFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveFileMessage: ko.observable(""),
          // @type {ServerStatus}
          saveAssignment: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          saveAssignmentMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmission: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionMessage: ko.observable(""),
          // @type {ServerStatus}
          updateSubmissionStatus: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          updateSubmissionStatusMessage: ko.observable(""),
          // @type {ServerStatus}
          listUploadedFiles: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          listUploadedFilesMessage: ko.observable(""),
          // @type {ServerStatus}
          downloadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          downloadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          uploadFile: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY),
          uploadFileMessage: ko.observable(""),
          // @type {ServerStatus}
          onExecution: ko.observable(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY)
        },
        execution: {
          // Information about in-progress executions
          reports: {},
          // list of Output objects
          output: ko.observableArray([]),
          // List of inputted strings
          input: ko.observableArray([]),
          inputIndex: ko.observable(0),
          // Information related to a student run
          student: {
            // str: the filename that was last executed and is associated with these results
            filename: ko.observable(null),
            // integer
            currentStep: ko.observable(null),
            // integer
            lastStep: ko.observable(null),
            // integer
            currentLine: ko.observable(null),
            lastLine: ko.observable(0),
            // array of simple objects
            currentTraceData: ko.observableArray([]),
            // integer
            currentTraceStep: ko.observable(0),
            // Actual execution results
            results: null,
            globals: ko.observable(null),
            calls: {}
          },
          instructor: {
            globals: null,
            sysmodules: undefined
          },
          // Information related to feedback from the instructor run
          feedback: {
            // str (markdown)
            message: ko.observable("Ready"),
            category: ko.observable(null),
            label: ko.observable(null),
            hidden: ko.observable(false),
            linesError: ko.observableArray([]),
            linesUncovered: ko.observableArray([]),
            // The results of the last execution
            results: null
          }
        },
        configuration: {
          /**
           * Functions to fire when certain events occur
           */
          callbacks: {
            /**
             * When the student gets a success
             */
            "success": this.initialConfiguration_["callback.success"]
          },

          /**
           * Whether or not the server is connected.
           * @type {bool}
           */
          serverConnected: ko.observable(this.getSetting("server.connected", true)),
          // string
          blocklyPath: this.initialConfiguration_["blockly.path"],
          // string
          attachmentPoint: this.initialConfiguration_["attachment.point"],
          // JQuery object
          container: null,
          // Maps codes ('log_event', 'save_code') to URLs
          urls: this.initialConfiguration_["urls"] || {}
        }
      };
    }
  }, {
    key: "initInterface",

    /**
     * Creates the interface
     */
    value: function initInterface() {
      var constants = this.model.configuration;
      var gui = Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeInterface"])(this);
      constants.container = jquery__WEBPACK_IMPORTED_MODULE_2___default()(constants.attachmentPoint).html(jquery__WEBPACK_IMPORTED_MODULE_2___default()(gui));
    }
  }, {
    key: "loadAssignment",
    value: function loadAssignment(assignment_id) {
      this.components.server.loadAssignment(assignment_id);
    }
  }, {
    key: "loadTags",
    value: function loadTags(tags) {// Already a JSON list representing tags
    }
  }, {
    key: "loadSampleSubmissions",
    value: function loadSampleSubmissions(samples) {// Already a JSON list representing samples
    }
  }, {
    key: "loadNoSubmission",
    value: function loadNoSubmission(assignment) {
      this.model.submission.code(assignment.starting_code);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadSubmission",
    value: function loadSubmission(submission, assignment) {
      if (!submission) {
        // TODO: Scarier "You are not logged in message"
        this.loadNoSubmission(assignment);
        return false;
      } // TODO: What if submissions' assignment version and the assignments' version conflict?


      this.model.submission.id(submission.id);
      this.model.submission.code(submission.code);
      this.model.submission.correct(submission.correct);
      this.model.submission.score(submission.score);
      this.model.submission.endpoint(submission.endpoint);
      this.model.submission.url(submission.url);
      this.model.submission.version(submission.version);
      this.model.submission.gradingStatus(submission.grading_status);
      this.model.submission.submissionStatus(submission.submission_status);
      this.model.submission.ownerId(submission.user_id);
      this.model.user.courseId(submission.course_id);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(submission.extra_files, this.model.submission.extraFiles);
    }
  }, {
    key: "loadAssignmentData_",
    value: function loadAssignmentData_(data) {
      console.log(data);
      this.resetInterface();
      this.components.fileSystem.dismountExtraFiles();
      var wasServerConnected = this.model.configuration.serverConnected();
      this.model.configuration.serverConnected(false);
      var assignment = data.assignment;
      this.model.assignment.id(assignment.id);
      this.model.assignment.version(assignment.version);
      this.model.assignment.courseId(assignment.course_id);
      this.model.assignment.forkedId(assignment.forked_id);
      this.model.assignment.forkedVersion(assignment.forked_version);
      this.model.assignment.hidden(assignment.hidden);
      this.model.assignment.reviewed(assignment.reviewed);
      this.model.assignment["public"](assignment["public"]);
      this.model.assignment.type(assignment.type);
      this.model.assignment.url(assignment.url);
      this.model.assignment.points(assignment.points);
      this.model.assignment.ipRanges(assignment.ip_ranges);
      this.model.assignment.instructions(assignment.instructions);
      this.model.assignment.name(assignment.name);
      this.model.assignment.onChange(assignment.on_change || null);

      if (assignment.on_change) {
        this.components.fileSystem.newFile("!on_change.py", assignment.on_change);
      }

      this.model.assignment.onEval(assignment.on_eval || null);

      if (assignment.on_eval) {
        this.components.fileSystem.newFile("!on_eval.py", assignment.on_eval);
      }

      this.model.assignment.onRun(assignment.on_run);
      this.model.assignment.startingCode(assignment.starting_code);
      this.model.assignment.ownerId(assignment.owner_id);
      this.loadTags(assignment.tags);
      this.loadSampleSubmissions(assignment.sample_submissions);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_instructor_files, this.model.assignment.extraInstructorFiles);
      Object(_files__WEBPACK_IMPORTED_MODULE_10__["loadConcatenatedFile"])(assignment.extra_starting_files, this.model.assignment.extraStartingFiles);
      Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_17__["loadAssignmentSettings"])(this.model, assignment.settings);
      this.loadSubmission(data.submission, assignment);
      this.model.display.dirtySubmission(true);
      this.model.display.changedInstructions(null);
      this.model.configuration.serverConnected(wasServerConnected);
      this.components.corgis.loadDatasets(true);
      this.components.pythonEditor.bm.refresh();
      this.components.server.setStatus("saveFile", server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
    }
  }, {
    key: "initModelMethods",
    value: function initModelMethods() {
      var _this = this;

      var self = this;
      var model = this.model;
      model.ui = {
        smallLayout: ko.pureComputed(function () {
          return !model.display.instructor() && model.assignment.settings.smallLayout();
        }),
        role: {
          isGrader: ko.pureComputed(function () {
            return model.user.role() === "owner" || model.user.role() === "grader";
          })
        },
        instructions: {
          isChanged: ko.pureComputed(function () {
            return model.display.changedInstructions() !== null;
          }),
          current: ko.pureComputed(function () {
            return model.ui.instructions.isChanged() ? self.utilities.markdown(model.display.changedInstructions()) : self.utilities.markdown(model.assignment.instructions());
          }),
          reset: function reset() {
            return model.display.changedInstructions(null);
          }
        },
        menu: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.onlyInteractive();
          }),
          textFullscreen: ko.pureComputed(function () {
            return model.display.fullscreen() ? "fa-compress-arrows-alt" : "fa-expand-arrows-alt";
          }),
          clickFullscreen: function clickFullscreen() {
            model.display.fullscreen(!model.display.fullscreen());
          },
          editInputs: function editInputs() {
            _this.components.dialog.EDIT_INPUTS();
          },
          toggleImages: function toggleImages() {
            if (model.display.renderImages()) {
              self.components.pythonEditor.bm.textEditor.disableImages();
            } else {
              self.components.pythonEditor.bm.textEditor.enableImages();
            }

            model.display.renderImages(!model.display.renderImages());
          },
          canMarkSubmitted: ko.pureComputed(function () {
            return model.assignment.hidden() || model.assignment.reviewed() || model.assignment.settings.canClose();
          }),
          textMarkSubmitted: ko.pureComputed(function () {
            if (model.ui.menu.isCompleted()) {
              return model.user.groupId() ? "Problem closed" : "Assignment closed";
            } else if (model.ui.menu.isSubmitted()) {
              return "Reopen for editing";
            } else if (model.display.dirtySubmission()) {
              return "Run";
            } else {
              if (!model.assignment.hidden() && model.submission.correct()) {
                return "Submit";
              } else {
                return "Submit early";
              }
            }
          }),
          clickMarkSubmitted: function clickMarkSubmitted() {
            if (model.ui.menu.isCompleted()) {
              alert("You cannot reopen closed assignments. Contact a grader!");
            } else if (model.ui.menu.isSubmitted()) {
              self.components.server.updateSubmissionStatus("inProgress");
            } else if (model.display.dirtySubmission()) {
              self.components.engine.delayedRun();
            } else {
              self.components.server.updateSubmissionStatus("Submitted");
            }
          },
          isSubmitted: ko.pureComputed(function () {
            return (model.assignment.reviewed() || model.assignment.settings.canClose()) && model.submission.submissionStatus().toLowerCase() === "submitted";
          }),
          isCompleted: ko.pureComputed(function () {
            return model.submission.submissionStatus().toLowerCase() === "completed";
          }),
          showQueuedInputs: ko.pureComputed(function () {
            return !model.assignment.settings.hideQueuedInputs();
          })
        },
        secondRow: {
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-5";
          }),
          hideTraceButton: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.hideTraceButton();
          }),
          isAllVisible: ko.pureComputed(function () {
            return !model.assignment.settings.hideMiddlePanel();
          }),
          isFeedbackVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK;
          }),
          isTraceVisible: ko.pureComputed(function () {
            return model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE;
          }),
          isConsoleShowVisible: ko.pureComputed(function () {
            return model.ui.secondRow.isFeedbackVisible() || model.ui.secondRow.isTraceVisible();
          }),
          switchLabel: ko.pureComputed(function () {
            return model.execution.student.lastStep() !== null ? "View Trace" : "";
          }),
          advanceState: function advanceState() {
            var currentPanel = model.display.secondRowSecondPanel;

            if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].FEEDBACK);
            } else if (currentPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            } else if (model.execution.student.lastStep() !== null) {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE);
            } else {
              currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
            }
          },
          makeWide: function makeWide() {
            var currentPanel = model.display.secondRowSecondPanel;
            model.display.previousSecondRowSecondPanel(currentPanel());
            currentPanel(interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE);
          },
          restorePanel: function restorePanel() {
            var oldPanel = model.display.previousSecondRowSecondPanel;

            if (oldPanel() !== null) {
              model.display.secondRowSecondPanel(oldPanel());
              oldPanel(null);
            }
          }
        },
        console: {
          size: ko.pureComputed(function () {
            return !model.display.instructor() && model.assignment.settings.smallLayout() || model.display.secondRowSecondPanel() === interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].NONE ? "col-md-12" : "col-md-6";
          }),
          hideEvaluate: ko.pureComputed(function () {
            return model.assignment.settings.hideEvaluate() || !model.execution.student.globals() || model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          })
        },
        feedback: {
          badge: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "label-none";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "label-none";

              case "runtime":
                return "label-runtime-error";

              case "syntax":
                return "label-syntax-error";

              case "editor":
                return "label-syntax-error";

              case "internal":
                return "label-internal-error";

              case "semantic":
              case "analyzer":
                return "label-semantic-error";

              case "feedback":
              case "instructor":
                return "label-feedback-error";

              case "complete":
                return "label-problem-complete";

              case "instructions":
                return "label-instructions";

              case "no errors":
                return "label-no-errors";
            }
          }),
          category: ko.pureComputed(function () {
            if (model.execution.feedback.category() === null) {
              return "";
            }

            switch (model.execution.feedback.category().toLowerCase()) {
              default:
              case "none":
                return "";

              case "runtime":
                return "Runtime Error";

              case "syntax":
                return "Syntax Error";

              case "editor":
                return "Editor Error";

              case "internal":
                return "Internal Error";

              case "semantic":
              case "analyzer":
                return "Algorithm Error";

              case "feedback":
              case "instructions":
                return "Instructions";

              case "instructor":
                return "Incorrect Answer";

              case "complete":
                return "Complete";

              case "no errors":
                return "No errors";
            }
          })
        },
        trace: {
          has: ko.pureComputed(function () {
            return model.execution.student.currentTraceData() !== null;
          }),
          highlightedLine: ko.pureComputed(function () {
            if (model.display.secondRowSecondPanel() !== interface_js__WEBPACK_IMPORTED_MODULE_9__["SecondRowSecondPanelOptions"].TRACE) {
              return [];
            }

            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return [];
            } else if (step === 0) {
              return [];
            } else {
              return [traceData[step - 1].line];
            }
          }),
          line: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData || step === null) {
              return "No trace";
            }

            if (step === 0) {
              return "Before run";
            } else if (step === lastStep) {
              return "Finished run";
            } else {
              // TODO: why are these numbers wonky?
              return "Line " + traceData[step - 1].line;
            }
          }),
          first: function first() {
            model.execution.student.currentTraceStep(0);
          },
          backward: function backward() {
            var previous = Math.max(0, model.execution.student.currentTraceStep() - 1);
            model.execution.student.currentTraceStep(previous);
          },
          forward: function forward() {
            var next = Math.min(model.execution.student.lastStep(), model.execution.student.currentTraceStep() + 1);
            model.execution.student.currentTraceStep(next);
          },
          last: function last() {
            model.execution.student.currentTraceStep(model.execution.student.lastStep());
          },
          data: ko.pureComputed(function () {
            var step = model.execution.student.currentTraceStep();
            var lastStep = model.execution.student.lastStep();
            var traceData = model.execution.student.currentTraceData();

            if (!traceData) {
              return [];
            }

            switch (step) {
              case 0:
                return [];

              case lastStep:
                return traceData[step - 1];

              default:
                return traceData[step];
            }
          })
        },
        files: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.hideFiles();
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-6";
          }),
          hasContents: function hasContents(path) {
            switch (path) {
              case "answer.py":
                return model.submission.code();

              case "!instructions.md":
                return model.assignment.instructions();

              case "!on_change.py":
                return model.assignment.onChange() !== null;

              case "!on_eval.py":
                return model.assignment.onEval() !== null;

              case "?mock_urls.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?mock_urls.blockpy";
                });

              case "?images.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?images.blockpy";
                });

              case "!answer_prefix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_prefix.py";
                });

              case "!answer_suffix.py":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "!answer_suffix.py";
                });

              case "?toolbox.blockpy":
                return model.assignment.extraInstructorFiles().some(function (file) {
                  return file.filename() === "?toolbox.blockpy";
                });

              case "!tags.blockpy":
                return model.assignment.tags().length;

              case "!sample_submissions.blockpy":
                return model.assignment.sampleSubmissions().length;

              default:
                return false;
            }
          },
          add: function add(path) {
            switch (path) {
              case "?mock_urls.blockpy":
              case "!answer_prefix.py":
              case "!answer_suffix.py":
              case "?tags.blockpy":
              case "?settings.blockpy":
                self.components.fileSystem.newFile(path);
                break;

              case "?images.blockpy":
                self.components.fileSystem.newFile(path, "{}");
                break;

              case "?toolbox.blockpy":
                var normalToolbox = self.components.pythonEditor.bm.blockEditor.TOOLBOXES["normal"];
                normalToolbox = JSON.stringify(normalToolbox, null, 2);
                self.components.fileSystem.newFile(path, normalToolbox);
                break;

              case "!sample_submissions.blockpy":
                model.assignment.sampleSubmissions([_editor_sample_submissions__WEBPACK_IMPORTED_MODULE_21__["SampleSubmission"].Blank()]);
                self.components.fileSystem.newFile(path);
                break;

              case "!on_change.py":
                model.assignment.onChange("");
                self.components.fileSystem.newFile(path);
                break;
              // TODO fix extrafiles for instructor and student

              case "!on_eval.py":
                model.assignment.onEval("");
                self.components.fileSystem.newFile(path);
                break;

              case "instructor":
                self.components.fileSystem.newFileDialog("instructor");
                return;

              case "student":
                self.components.fileSystem.newFileDialog("student");
                return;

              case "starting":
                self.components.fileSystem.newFileDialog("starting");
                return;

              default:
            }

            model.display.filename(path);
          },
          "delete": function _delete() {
            return self.components.fileSystem.deleteFile(model.display.filename());
          },
          rename: function rename(newName) {
            return self.components.fileSystem.renameFile(model.display.filename(), newName);
          },
          getStudentCode: function getStudentCode() {
            var prefixPy = self.components.fileSystem.getFile("!answer_prefix.py");
            var suffixPy = self.components.fileSystem.getFile("!answer_suffix.py");
            var code = self.model.submission.code();

            if (prefixPy && prefixPy.handle && prefixPy.handle()) {
              code = prefixPy.handle() + code;
            }

            if (suffixPy && suffixPy.handle && suffixPy.handle()) {
              code = code + suffixPy.handle();
            }

            return code;
          },
          extraStudentFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.submission.extraFiles),
          extraInstructorFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraInstructorFiles),
          extraStartingFiles: Object(_files__WEBPACK_IMPORTED_MODULE_10__["observeConcatenatedFile"])(model.assignment.extraStartingFiles),
          displayFilename: function displayFilename(path) {
            if (path === "?mock_urls.blockpy") {
              return "URL Data";
            }

            if (path === "?images.blockpy") {
              return "Images";
            }

            if (path === "!answer_prefix.py") {
              return "Answer Prefix";
            }

            if (path === "!answer_suffix.py") {
              return "Answer Suffix";
            }

            if (path === "?toolbox.blockpy") {
              return "Toolbox";
            }

            if (path.startsWith("&")) {
              return path.slice(1);
            }

            return path;
          }
        },
        editors: {
          current: ko.pureComputed(function () {
            return self.components.editors.getEditor(model.display.filename());
          }),
          width: ko.pureComputed(function () {
            return model.display.instructor() || !model.assignment.settings.smallLayout() ? "col-md-12" : "col-md-7";
          }),
          view: ko.pureComputed(function () {
            return !model.display.instructor() && (model.assignment.settings.hideEditors() || model.assignment.settings.onlyInteractive()) ? "None" : model.display.filename() ? model.ui.editors.current() : "None";
          }),
          reset: function reset() {
            self.components.server.logEvent("X-File.Reset", "", "", "", "answer.py");
            model.submission.code(model.assignment.startingCode());
            model.submission.extraFiles(model.assignment.extraStartingFiles().map(function (file) {
              var filename = file.filename().substr(1);
              return Object(_files__WEBPACK_IMPORTED_MODULE_10__["makeModelFile"])(filename, file.contents());
            }));
          },
          canSave: ko.pureComputed(function () {
            return !model.display.autoSave();
          }),
          canDelete: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNDELETABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          canRename: ko.pureComputed(function () {
            return (!model.assignment.settings.hideFiles() || model.display.instructor()) && _files__WEBPACK_IMPORTED_MODULE_10__["UNRENAMABLE_FILES"].indexOf(model.display.filename()) === -1;
          }),
          upload: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["uploadFile"].bind(self),
          download: _editor_abstract_editor__WEBPACK_IMPORTED_MODULE_11__["downloadFile"].bind(self),
          importDataset: function importDataset() {
            self.components.corgis.openDialog();
          },
          python: {
            fullscreen: function fullscreen() {
              var codeMirror = self.components.pythonEditor.bm.textEditor.codeMirror;
              return codeMirror.setOption("fullScreen", !codeMirror.getOption("fullScreen"));
            },
            updateMode: function updateMode(newMode) {
              self.components.server.logEvent("X-View.Change", "", "", newMode, model.display.filename());
              model.display.pythonMode(newMode);

              if (model.display.filename() === "answer.py") {
                self.components.pythonEditor.oldPythonMode = newMode;
              }
            },
            isHistoryAvailable: ko.pureComputed(function () {
              return model.ui.server.isEndpointConnected("loadHistory");
            }),
            turnOffHistoryMode: function turnOffHistoryMode() {
              self.components.pythonEditor.updateEditor();
              self.components.pythonEditor.setReadOnly(false);
              model.display.historyMode(false);
            },
            turnOnHistoryMode: function turnOnHistoryMode() {
              self.components.server.loadHistory(function (response) {
                if (response.success) {
                  self.components.history.load(response.history);
                  model.display.historyMode(true);
                  self.components.pythonEditor.setReadOnly(true);
                } else {
                  self.components.dialog.ERROR_LOADING_HISTORY();
                }
              });
            },
            toggleHistoryMode: function toggleHistoryMode() {
              if (model.display.historyMode()) {
                model.ui.editors.python.turnOffHistoryMode();
              } else {
                model.ui.editors.python.turnOnHistoryMode();
              }
            },
            history: {
              start: function start() {
                self.components.history.moveToStart();
              },
              previous: function previous() {
                self.components.history.movePrevious();
              },
              next: function next() {
                self.components.history.moveNext();
              },
              mostRecent: function mostRecent() {
                self.components.history.moveToMostRecent();
              },
              use: function use() {
                self.components.history.use();
              }
            }
          },
          images: {
            reloadImages: function reloadImages() {
              return self.components.editors.byName("image").reloadImages();
            }
          },
          settings: {
            save: function save() {
              return self.components.server.saveAssignment();
            }
          },
          sampleSubmissions: {
            buildEditor: function buildEditor(newDOM, index, newElement) {
              var editor = self.components.editors.byName("Sample Submissions");
              editor.buildEditor(newDOM, index, newElement);
            }
          }
        },
        execute: {
          isRunning: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE;
          }),
          runLabel: ko.pureComputed(function () {
            return model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE ? "Stop" : "Run";
          }),
          run: function run() {
            if (model.status.onExecution() === server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].ACTIVE) {
              if (typeof PygameLib !== "undefined" && PygameLib.running) {
                PygameLib.StopPygame();
              }

              model.status.onExecution(server_js__WEBPACK_IMPORTED_MODULE_8__["StatusState"].READY);
            } else {
              self.components.engine.delayedRun();
            }
          },
          evaluate: function evaluate() {
            return self.components.engine.evaluate();
          }
        },
        server: {
          status: function status(endpoint) {
            return "server-status-" + model.status[endpoint]();
          },
          isEndpointConnected: function isEndpointConnected(endpoint) {
            return model.configuration.serverConnected() && model.configuration.urls !== undefined && model.configuration.urls[endpoint] !== undefined;
          },
          messages: ko.pureComputed(function () {
            return Object(_utilities__WEBPACK_IMPORTED_MODULE_20__["capitalize"])(model.status.loadAssignmentMessage() || model.status.saveAssignmentMessage() || model.status.loadHistoryMessage() || model.status.loadFileMessage() || model.status.saveFileMessage() || model.status.loadDatasetMessage() || model.status.logEventMessage() || model.status.saveImage() || model.status.updateSubmissionMessage() || model.status.updateSubmissionStatusMessage() || "");
          }),
          force: {
            loadAssignment: function loadAssignment(data, event) {
              //let fileHandler = $(".blockpy-force-load-assignment-file");
              var assignmentForceLoadButton = jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target); //fileHandler.click();

              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).parent().fadeOut(100).fadeIn(100); // Allow user to upload a file containing an assignment submission

              var fr = new FileReader();
              var files = assignmentForceLoadButton[0].files;

              fr.onload = function (e) {
                var assignmentSubmission = JSON.parse(e.target.result);
                self.loadAssignmentData_(assignmentSubmission);
              };

              fr.fileName = files[0].name;
              fr.readAsText(files[0]);
              assignmentForceLoadButton.val("");
            },
            updateSubmission: function updateSubmission(data, event) {
              console.log(event);
              self.components.server.updateSubmission(self.model.submission.score(), self.model.submission.correct(), false, true);
              jquery__WEBPACK_IMPORTED_MODULE_2___default()(event.target).fadeOut(100).fadeIn(100);
            }
          }
        },
        footer: {
          visible: ko.pureComputed(function () {
            return model.display.instructor() || !model.ui.smallLayout();
          })
        }
      };
      Object(interface_js__WEBPACK_IMPORTED_MODULE_9__["makeExtraInterfaceSubscriptions"])(self, model);
    }
  }, {
    key: "turnOnHacks",
    value: function turnOnHacks() {
      //console.log("TODO");
      Sk.builtinFiles.files["src/lib/image.js"] = skulpt_modules_image__WEBPACK_IMPORTED_MODULE_3__["$builtinmodule"].toString(); //Sk.builtinFiles.files["src/lib/weakref.js"] = weakrefModule.toString();
      //Sk.builtinFiles.files["src/lib/matplotlib/pyplot/__init__.js"] = matplotlibModule.toString();
    }
    /**
     * Applys the KnockoutJS bindings to the model, instantiating the values into the
     * HTML.
     */

  }, {
    key: "applyModel",
    value: function applyModel() {
      ko.applyBindings(this.model, this.model.configuration.container[0]);
    }
  }, {
    key: "initUtilities",
    value: function initUtilities() {
      var main = this;
      this.utilities = {
        markdown: function markdown(text) {
          return text ? EasyMDE.prototype.markdown(text) : "<p></p>";
        }
      };
    }
  }, {
    key: "initComponents",
    value: function initComponents() {
      var container = this.model.configuration.container;
      var components = this.components = {};
      var main = this; // Each of these components will take the BlockPy instance, and possibly a
      // reference to the relevant HTML location where it will be embedded.

      components.dialog = new _dialog__WEBPACK_IMPORTED_MODULE_16__["BlockPyDialog"](main, container.find(".blockpy-dialog"));
      components.feedback = new feedback_js__WEBPACK_IMPORTED_MODULE_15__["BlockPyFeedback"](main, container.find(".blockpy-feedback"));
      components.trace = new _trace__WEBPACK_IMPORTED_MODULE_13__["BlockPyTrace"](main);
      components.console = new _console__WEBPACK_IMPORTED_MODULE_14__["BlockPyConsole"](main, container.find(".blockpy-console"));
      components.engine = new engine_js__WEBPACK_IMPORTED_MODULE_12__["BlockPyEngine"](main);
      components.fileSystem = new _files__WEBPACK_IMPORTED_MODULE_10__["BlockPyFileSystem"](main);
      components.editors = new editors_js__WEBPACK_IMPORTED_MODULE_6__["Editors"](main, container.find(".blockpy-editor")); // Convenient shortcut directly to PythonEditor

      components.pythonEditor = this.components.editors.byName("python");
      components.server = new server_js__WEBPACK_IMPORTED_MODULE_8__["BlockPyServer"](main);
      components.corgis = new _corgis__WEBPACK_IMPORTED_MODULE_18__["BlockPyCorgis"](main);
      components.history = new _history__WEBPACK_IMPORTED_MODULE_19__["BlockPyHistory"](main, container.find(".blockpy-history-toolbar"));
    }
  }, {
    key: "show",
    value: function show() {
      this.model.configuration.container.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.model.configuration.container.hide();
    }
  }, {
    key: "makeExtraSubscriptions",
    value: function makeExtraSubscriptions() {
      var _this2 = this;

      this.model.display.changedInstructions.subscribe(function (changed) {
        _this2.components.server.logEvent("X-Instructions.Change", "", "", changed, "instructions.md");
      });
    }
  }, {
    key: "start",
    value: function start() {
      this.model.display.filename("answer.py");
    }
  }, {
    key: "resetInterface",
    value: function resetInterface() {
      this.components.engine.reset(); // Disable any alternative logEntry functions we have been given

      this.components.server.altLogEntry = null;
    }
  }, {
    key: "requestPasscode",
    value: function requestPasscode() {
      var userSuppliedPasscode = prompt("Please enter the passcode.");
      this.model.display.passcode(userSuppliedPasscode);
    }
  }]);

  return BlockPy;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/console.js":
/*!************************!*\
  !*** ./src/console.js ***!
  \************************/
/*! exports provided: CONSOLE_HTML, ConsoleLineType, BlockPyConsole */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSOLE_HTML", function() { return CONSOLE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleLineType", function() { return ConsoleLineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyConsole", function() { return BlockPyConsole; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Evaluate button HTML template
 * @type {string}
 */

var START_EVAL_HTML = "\n<button type=\"button\" class=\"btn btn-sm btn-outline float-right blockpy-btn-eval\">\n    Evaluate\n</button>";
/**
 * HTML template for a new line in the console.
 * @type {string}
 */

var NEW_CONSOLE_LINE_HTML = "<div></div>";
/**
 * HTML template for the entire console area
 * @type {string}
 */

var CONSOLE_HTML = "\n    <div class='blockpy-panel blockpy-console'\n          role=\"region\" aria-label=\"Console\"\n          data-bind=\"class: ui.console.size\">\n          \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-show-feedback'\n                data-bind=\"hidden: ui.secondRow.isConsoleShowVisible, click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span>\n        </button>\n          \n        <strong>Console:</strong>\n        \n        <div class='blockpy-printer blockpy-printer-default'>\n        </div>\n        \n     </div>";
/**
 * All the possible types for a line in the console.
 * @enum
 */

var ConsoleLineType = {
  TEXT: "text",
  HTML: "html",
  PLOT: "plot",
  IMAGE: "image",
  PYGAME: "pygame",
  TURTLE: "turtle",
  EVAL: "eval",
  START_EVAL: "start_eval",
  VALUE: "value",
  INPUT: "input",
  TEST_CASE: "test_case"
};
/**
 * Abstract version of a line in the console. All other console lines
 * should extend this class. Critically, they need to implement a render function.
 */

var ConsoleLine = /*#__PURE__*/function () {
  function ConsoleLine(main, type, content) {
    _classCallCheck(this, ConsoleLine);

    /**
     * Reference back to the main BlockPy instance.
     * @const
     * @type {BlockPy}
     */
    this.main = main;
    /**
     * Categorizes what kind of line this is (text/html/plot/etc.)
     * @type {ConsoleLineType}
     */

    this.type = type;
    /**
     * The actual data stored on this line.
     * @type {string}
     */

    this.content = content;
    /**
     * Metadata about where the line originated from in the code.
     * @type {{filename: string, line: number, step: number}}
     */

    this.origin = {
      filename: Sk.currFilename,
      step: main.components.engine.executionBuffer.step,
      line: main.components.engine.executionBuffer.line
    };
    /**
     * The HTML content stored on this line, meant to be rendered
     * to the user.
     * @type {*|jQuery.fn.init|jQuery|HTMLElement}
     */

    this.html = $("<div></div>", {
      "class": "blockpy-printer-output",
      "data-container": main.model.configuration.attachmentPoint,
      "data-toggle": "tooltip",
      "data-placement": "auto",
      "data-step": this.origin.step,
      "title": "Step " + this.origin.step + ", Line " + this.origin.line
    });
    /**
     * Whether or not this line should be visible
     * @type {boolean}
     */

    this.visible = !main.model.display.mutePrinter();
    /**
     *
     * @type {number}
     */

    this.index = 0;
  }
  /**
   * Create a Skulpt representation of this console line's content.
   * @returns {*}
   */


  _createClass(ConsoleLine, [{
    key: "toSkulpt",
    value: function toSkulpt() {
      return Sk.ffi.remapToPy(this.content);
    }
    /**
     * Remove this console line by deleting its HTML representation.
     */

  }, {
    key: "delete",
    value: function _delete() {
      this.html.remove();
    }
  }]);

  return ConsoleLine;
}();

var ConsoleLineTurtle = /*#__PURE__*/function (_ConsoleLine) {
  _inherits(ConsoleLineTurtle, _ConsoleLine);

  var _super = _createSuper(ConsoleLineTurtle);

  // TODO: Capture turtle commands for tracing purposes
  function ConsoleLineTurtle(main) {
    var _this;

    _classCallCheck(this, ConsoleLineTurtle);

    _this = _super.call(this, main, ConsoleLineType.TURTLE);

    _this.html.addClass("blockpy-console-turtle-output");

    return _this;
  }

  _createClass(ConsoleLineTurtle, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.prepend(this.html); //this.html[0].scrollIntoView({ behavior: "smooth" });

        var top = this.html.offset().top; //$('html').scrollTop(top);

        $("html").scrollTop(top); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineTurtle;
}(ConsoleLine);

var ConsoleLinePygame = /*#__PURE__*/function (_ConsoleLine2) {
  _inherits(ConsoleLinePygame, _ConsoleLine2);

  var _super2 = _createSuper(ConsoleLinePygame);

  function ConsoleLinePygame(main, size, fullscreen, pygameObj) {
    var _this2;

    _classCallCheck(this, ConsoleLinePygame);

    _this2 = _super2.call(this, main, ConsoleLineType.PYGAME);

    _this2.html.addClass("blockpy-console-pygame-output");

    _this2.size = size;
    _this2.fullscreen = fullscreen;
    _this2.pygameObj = pygameObj;
    _this2.initialized = false;
    _this2.canvas = document.createElement("canvas"); //Sk.main_canvas = document.getElementById("myCanvas");

    return _this2;
  }

  _createClass(ConsoleLinePygame, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        this.html.append(this.canvas);
        where.prepend(this.html);
        var top = this.html.offset().top;
        $("html").scrollTop(top);
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {// Starts off as a no-op
    }
  }, {
    key: "stop",
    value: function stop() {
      this.cleanup = function () {};

      this.main.model.ui.secondRow.restorePanel();
    }
  }, {
    key: "finalize",
    value: function finalize(cleanupFunction, listeners) {
      var _this3 = this;

      this.initialized = true;

      this.cleanup = function () {
        return cleanupFunction(_this3.pygameObj, listeners);
      };
    }
  }]);

  return ConsoleLinePygame;
}(ConsoleLine);

var ConsoleLineImage = /*#__PURE__*/function (_ConsoleLine3) {
  _inherits(ConsoleLineImage, _ConsoleLine3);

  var _super3 = _createSuper(ConsoleLineImage);

  function ConsoleLineImage(main, content) {
    var _this4;

    _classCallCheck(this, ConsoleLineImage);

    _this4 = _super3.call(this, main, ConsoleLineType.IMAGE, content);

    _this4.html.addClass("blockpy-console-image-output");

    return _this4;
  }

  _createClass(ConsoleLineImage, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        console.log(this.content);
        this.html.append(this.content);
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineImage;
}(ConsoleLine);

var ConsoleLinePlot = /*#__PURE__*/function (_ConsoleLine4) {
  _inherits(ConsoleLinePlot, _ConsoleLine4);

  var _super4 = _createSuper(ConsoleLinePlot);

  function ConsoleLinePlot(main, content) {
    var _this5;

    _classCallCheck(this, ConsoleLinePlot);

    _this5 = _super4.call(this, main, ConsoleLineType.PLOT, content);

    _this5.html.addClass("blockpy-console-plot-output");

    return _this5;
  }

  _createClass(ConsoleLinePlot, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        where.append(this.html); //this.html.tooltip();
      }
    }
  }]);

  return ConsoleLinePlot;
}(ConsoleLine);

var ConsoleLineText = /*#__PURE__*/function (_ConsoleLine5) {
  _inherits(ConsoleLineText, _ConsoleLine5);

  var _super5 = _createSuper(ConsoleLineText);

  function ConsoleLineText() {
    _classCallCheck(this, ConsoleLineText);

    return _super5.apply(this, arguments);
  }

  _createClass(ConsoleLineText, [{
    key: "addContent",
    value: function addContent(content) {
      this.content = this.content + content;
    }
  }, {
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);

        if (!encodedText || encodedText.trim().length <= 0) {
          encodedText = "\n";
        }

        var lineData = $("<samp></samp>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineText;
}(ConsoleLine);

var ConsoleLineValue = /*#__PURE__*/function (_ConsoleLine6) {
  _inherits(ConsoleLineValue, _ConsoleLine6);

  var _super6 = _createSuper(ConsoleLineValue);

  function ConsoleLineValue(main, content) {
    _classCallCheck(this, ConsoleLineValue);

    return _super6.call(this, main, ConsoleLineType.VALUE, content);
  }

  _createClass(ConsoleLineValue, [{
    key: "render",
    value: function render(where) {
      if (this.visible) {
        var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
        var lineData = $("<code></code>", {
          "html": encodedText
        });
        this.html.append(lineData);
        where.append(this.html);
        this.html.tooltip();
      }
    }
  }]);

  return ConsoleLineValue;
}(ConsoleLine);

var ConsoleLineInput = /*#__PURE__*/function (_ConsoleLine7) {
  _inherits(ConsoleLineInput, _ConsoleLine7);

  var _super7 = _createSuper(ConsoleLineInput);

  function ConsoleLineInput(main, promptMessage) {
    var _this6;

    _classCallCheck(this, ConsoleLineInput);

    _this6 = _super7.call(this, main, ConsoleLineType.INPUT, promptMessage);
    _this6.visible = true;
    return _this6;
  }
  /**
   * Creates an Input box for receiving input() from the user.
   *
   */


  _createClass(ConsoleLineInput, [{
    key: "render",
    value: function render(where) {
      // Perform any necessary cleaning
      if (this.visible) {
        // Input form
        var inputForm = $("<input type='text' />"); // Enter button

        var inputBtn = $("<button></button>", {
          "html": "Enter"
        }); // Group form and button

        var inputGroup = $("<div></div>", {
          "class": "blockpy-console-input"
        });
        inputGroup.append(inputForm);
        inputGroup.append(inputBtn); // Prompt box, new line, input group

        var inputBox = $("<div></div>");

        if (this.content !== "\n") {
          var encodedText = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["encodeHTML"])(this.content);
          var inputMsg = $("<samp></samp>", {
            "html": encodedText
          });
          inputBox.append(inputMsg);
        }

        inputBox.append($("<br>")).append(inputGroup); // Render

        this.html.append(inputBox);
        where.append(this.html); // Make it interactive

        return this.makeInteractive(inputForm, inputBtn);
      }

      return "";
    }
  }, {
    key: "makeInteractive",
    value: function makeInteractive(input, button) {
      var _this7 = this;

      var resolveOnClick;
      var submittedPromise = new Promise(function (resolve) {
        resolveOnClick = resolve;
      });
      var inputIndex = this.main.model.execution.inputIndex();

      var submitForm = function submitForm() {
        var userInputtedValue = input.val();
        Sk.queuedInput.push(userInputtedValue);

        _this7.main.model.execution.inputIndex(inputIndex + 1);

        _this7.main.model.execution.input().push(userInputtedValue);

        resolveOnClick(userInputtedValue);
        input.prop("disabled", true);
        button.prop("disabled", true);

        _this7.html.tooltip();
      };

      button.click(submitForm);
      input.keyup(function (e) {
        if (e.keyCode === 13) {
          submitForm();
        }
      });
      input.focus();
      console.log(inputIndex, this.main.model.execution.input().length);

      if (inputIndex < this.main.model.execution.input().length) {
        var userInputtedValue = this.main.model.execution.input()[inputIndex];
        input.val(userInputtedValue);
        this.main.model.execution.inputIndex(inputIndex + 1);
        return new Promise(function (resolve) {
          input.prop("disabled", true);
          button.prop("disabled", true);

          _this7.html.tooltip();

          resolve(userInputtedValue);
        });
      }

      return submittedPromise;
    }
  }]);

  return ConsoleLineInput;
}(ConsoleLine);

var ConsoleLineEvaluate = /*#__PURE__*/function (_ConsoleLineInput) {
  _inherits(ConsoleLineEvaluate, _ConsoleLineInput);

  var _super8 = _createSuper(ConsoleLineEvaluate);

  function ConsoleLineEvaluate(main) {
    _classCallCheck(this, ConsoleLineEvaluate);

    return _super8.call(this, main, "Evaluate:");
  }

  return ConsoleLineEvaluate;
}(ConsoleLineInput);

var ConsoleLineStartEvaluate = /*#__PURE__*/function (_ConsoleLine8) {
  _inherits(ConsoleLineStartEvaluate, _ConsoleLine8);

  var _super9 = _createSuper(ConsoleLineStartEvaluate);

  function ConsoleLineStartEvaluate(main) {
    var _this8;

    _classCallCheck(this, ConsoleLineStartEvaluate);

    _this8 = _super9.call(this, main, ConsoleLineType.START_EVAL);

    _this8.html.append($(START_EVAL_HTML));

    _this8.html.click(function () {
      _this8.main.model.ui.execute.evaluate();

      _this8["delete"]();
    });

    return _this8;
  }

  _createClass(ConsoleLineStartEvaluate, [{
    key: "render",
    value: function render(where) {
      where.append(this.html);
    }
  }]);

  return ConsoleLineStartEvaluate;
}(ConsoleLine);

var BlockPyConsole = /*#__PURE__*/function () {
  /**
   * An object for managing the console, with features for things like printing, plotting, evaling, inputing.
   * The "printer" is the region where we put things, as opposed to the console as a whole.
   *
   * @constructor
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyConsole(main, tag) {
    _classCallCheck(this, BlockPyConsole);

    this.main = main;
    this.tag = tag;
    this.printerTag = tag.find(".blockpy-printer");
    this.MINIMUM_WIDTH = 200;
    this.MINIMUM_HEIGHT = 200;
    this.DEFAULT_HEIGHT = this.printerTag.height(); // Let CSS define this

    this.main.model.display.previousConsoleHeight(this.DEFAULT_HEIGHT);
    this.output = this.main.model.execution.output; //this.input = this.main.model.execution.input;

    this.settings = {};
    this.clear(); // TODO: If the user modifies a file, then make the console look faded a little
  }

  _createClass(BlockPyConsole, [{
    key: "clear",

    /**
     * Reset the status of the printer, including removing any text in it and
     * fixing its size.
     */
    value: function clear() {
      this.output.removeAll();
      this.lineBuffer = null;
      this.plotBuffer = null;
      this.printerTag.empty(); // If the user hasn't changed the console size, we'll reset it

      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
        this.printerTag.height(this.DEFAULT_HEIGHT);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      }

      this.turtleLine = null;
      Sk.TurtleGraphics = {
        target: this.getTurtleLine.bind(this),
        width: this.getWidth(),
        height: this.getHeight(),
        assets: this.loadAsset.bind(this)
      };
      this.pygameLine = null;
    }
  }, {
    key: "loadAsset",
    value: function loadAsset(name) {
      return name;
    }
  }, {
    key: "getTurtleLine",
    value: function getTurtleLine() {
      if (this.turtleLine === null) {
        this.turtleLine = new ConsoleLineTurtle(this.main);
        this.turtleLine.render(this.printerTag); // If the user hasn't changed the console size, we'll do so

        if (this.main.model.display.previousConsoleHeight() === this.printerTag.height()) {
          var currentPrinterDimension = this.printerTag.width();
          this.printerTag.height(currentPrinterDimension);
          this.main.model.display.previousConsoleHeight(this.printerTag.height());
          Sk.TurtleGraphics.height = currentPrinterDimension - 40;
        }
      }

      return this.turtleLine.html[0];
    }
  }, {
    key: "handlePygameResize",
    value: function handlePygameResize(newWidth, newHeight) {
      // If the user hasn't changed the console size, and the newHeight is bigger than default, we'll change it
      if (this.main.model.display.previousConsoleHeight() === this.printerTag.height() && newHeight > this.DEFAULT_HEIGHT) {
        this.printerTag.height(30 + newHeight);
        this.main.model.display.previousConsoleHeight(this.printerTag.height());
      } // If the pygame window is wider than the console, we'll expand temporarily.


      if (newWidth > this.printerTag.width()) {
        this.main.model.ui.secondRow.makeWide();
      }
    }
  }, {
    key: "finishTurtles",
    value: function finishTurtles() {
      if (this.main.model.assignment.settings.saveTurtleOutput()) {
        if (this.turtleLine) {
          var canvas = this.turtleLine.html.find("canvas").last()[0];
          var dataUrl = canvas.toDataURL("image/png");
          this.main.components.server.saveImage("turtle_output", dataUrl);
        } else if (this.pygameLine) {
          var _canvas = this.pygameLine.canvas;

          var _dataUrl = _canvas.toDataURL("image/png");

          this.main.components.server.saveImage("turtle_output", _dataUrl);
        } else {// TODO: What if there are no turtles to save?
        }
      }
    } // TODO: turtles should be based on the current width

  }, {
    key: "newTurtle",
    value: function newTurtle() {
      return this;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return Math.max(this.MINIMUM_WIDTH, this.printerTag.width() - 40);
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return Math.max(this.MINIMUM_HEIGHT, this.printerTag.height() + 40);
    }
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.main.model.display.mutePrinter();
    }
    /**
     * Updates each printed element in the printer and makes it hidden
     * or visible, depending on what step we're on.
     *
     * @param {Number} step - The current step of the executed program that we're on; each element in the printer must be marked with a "data-step" property to resolve this.
     * @param {Number} page - Deprecated, not sure what this even does.
     */

  }, {
    key: "stepPrinter",
    value: function stepPrinter(step, page) {
      this.printerTag.find(".blockpy-printer-output").each(function () {
        if ($(this).attr("data-step") <= step) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }
  }, {
    key: "print",

    /**
     * Print a line to the on-screen printer.
     * @param {String} lineText - A line of text to be printed out.
     */
    value: function print(lineText) {
      // Empty strings means do nothing.
      // print("", end="")
      if (!lineText) {
        return;
      }

      var flush = false;

      if (lineText.charAt(lineText.length - 1) === "\n") {
        flush = true;
      }

      var splitLines = lineText.split("\n");

      if (this.lineBuffer === null) {
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[0]);
      } else {
        this.lineBuffer.addContent(splitLines[0]);
      }

      for (var i = 1; i < splitLines.length - 1; i++) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = new ConsoleLineText(this.main, ConsoleLineType.TEXT, splitLines[i]);
      }

      if (flush) {
        this.output.push(this.lineBuffer);
        this.lineBuffer.render(this.printerTag);
        this.lineBuffer = null;
      }
    }
  }, {
    key: "plot",
    value: function plot(plots) {
      this.plotBuffer = new ConsoleLinePlot(this.main, plots);
      this.plotBuffer.render(this.printerTag);
      return this.plotBuffer;
    }
  }, {
    key: "pygame",
    value: function pygame(size, fullscreen, pygameObj) {
      if (this.pygameLine === null) {
        this.pygameLine = new ConsoleLinePygame(this.main, size, fullscreen, pygameObj);
        this.pygameLine.render(this.printerTag);
      }

      return this.pygameLine;
    }
  }, {
    key: "printPILImage",
    value: function printPILImage(imageData) {
      console.log("TEST", imageData.image);
      this.imageBuffer = new ConsoleLineImage(this.main, imageData.image);
      this.imageBuffer.render(this.printerTag);
      return this.imageBuffer;
    }
  }, {
    key: "printValue",
    value: function printValue(value) {
      var printedValue = new ConsoleLineValue(this.main, value);
      printedValue.render(this.printerTag);
      return printedValue;
    }
    /**
     * Creates and registers a Promise from the Input box
     * @param {String} promptMessage - Message to display to the user.
     *
     */

  }, {
    key: "input",
    value: function input(promptMessage) {
      this.inputBuffer = new ConsoleLineInput(this.main, promptMessage);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      this.inputBuffer = new ConsoleLineEvaluate(this.main);
      return this.inputBuffer.render(this.printerTag);
    }
  }, {
    key: "beginEval",
    value: function beginEval() {
      var startEvaluation = new ConsoleLineStartEvaluate(this.main);
      return startEvaluation.render(this.printerTag);
    }
    /**
     * Unconditionally scroll to the bottom of the window.
     *
     */

  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      this.tag.animate({
        scrollTop: this.tag.prop("scrollHeight") - this.tag.prop("clientHeight")
      }, 500);
    }
  }]);

  return BlockPyConsole;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/corgis.js":
/*!***********************!*\
  !*** ./src/corgis.js ***!
  \***********************/
/*! exports provided: _IMPORTED_DATASETS, _IMPORTED_COMPLETE_DATASETS, BlockPyCorgis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_DATASETS", function() { return _IMPORTED_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_IMPORTED_COMPLETE_DATASETS", function() { return _IMPORTED_COMPLETE_DATASETS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyCorgis", function() { return BlockPyCorgis; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/utilities.js");
 // TODO: editor.bm.blockEditor.extraTools[]

var _IMPORTED_DATASETS = {};
var _IMPORTED_COMPLETE_DATASETS = {};
/**
 * This is a very simplistic helper function that will transform
 * a given button into a "Loaded" state (disabled, pressed state, etc.).
 *
 * @param {HTMLElement} btn - An HTML element to change the text of.
 */

var setButtonLoaded = function setButtonLoaded(btn) {
  btn.addClass("active").addClass("btn-success").removeClass("btn-primary").prop("disabled", true).text("Loaded").attr("aria-pressed", "true");
};
/**
 * Module that connects to the CORGIS datasets and manages interactions
 * with them. This includes loading in datasets at launch and on-the-fly.
 * Note that this has no presence on screen, so it does not have a tag.
 *
 * @constructor
 * @this {BlockPyCorgis}
 * @param {Object} main - The main BlockPy instance
 */


function BlockPyCorgis(main) {
  this.main = main;
  this.loadedDatasets = [];
  this.loadDatasets();
}

BlockPyCorgis.prototype.loadDatasets = function (silently) {
  var _this = this;

  // Load in each the datasets
  var model = this.main.model,
      editor = this.main.components.pythonEditor,
      server = this.main.components.server;
  var imports = [];
  model.assignment.settings.datasets().split(",").forEach(function (name) {
    if (name && !(name in BlockMirrorBlockEditor.EXTRA_TOOLS)) {
      imports.push.apply(imports, _this.importDataset(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(name), name, silently));
    }
  }); // When datasets are loaded, update the toolbox.

  $.when.apply($, imports).done(function () {
    //console.log("TRIGGERED");
    editor.bm.forceBlockRefresh();
    editor.bm.blockEditor.remakeToolbox();
  }).fail(function (e) {
    console.log(arguments);
    console.error(e);
  }).always(function () {
    server.finalizeSubscriptions();
  });
};
/**
 * Loads the definitions for a dataset into the environment, including
 * the dataset (as a JS file), the skulpt bindings, and the blockly
 * bindings. This requires access to a CORGIS server, and occurs
 * asynchronously. The requests are fired and their deferred objects
 * are returned - callers can use this information to perform an action
 * on completion of the import.
 *
 * @param {String} slug - The URL safe version of the dataset name
 * @param {String} name - The user-friendly version of the dataset name.
 * @returns {Array.<Deferred>} - Returns the async requests as deferred objects.
 */


BlockPyCorgis.prototype.importDataset = function (slug, name) {
  var _this2 = this;

  var url_retrievals = [];

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets + "blockpy/" + slug + "/" + slug;
    this.main.model.display.loadingDatasets.push(name); // Actually get data

    var getDataset = $.getScript(root + "_dataset.js"); // Load getComplete silently in the background because its big :(

    var getComplete = $.getScript(root + "_complete.js");
    var getSkulpt = $.get(root + "_skulpt.js", function (data) {
      Sk.builtinFiles["files"]["src/lib/" + slug + "/__init__.js"] = data;
    });
    var getBlockly = $.getScript(root + "_blockly.js"); // On completion, update menus.

    $.when(getDataset, getSkulpt, getBlockly).done(function () {
      _this2.loadedDatasets.push(slug);

      _this2.main.components.pythonEditor.bm.textToBlocks.hiddenImports.push(slug);

      _this2.main.components.pythonEditor.bm.forceBlockRefresh();

      _this2.main.components.pythonEditor.bm.blockEditor.remakeToolbox();

      _this2.main.model.display.loadingDatasets.remove(name);
    });
    url_retrievals.push(getDataset, getSkulpt, getBlockly);
  }

  return url_retrievals;
};
/**
 * Opens a dialog box to present the user with the datasets available
 * through the CORGIS server. This requires a call, so this method
 * completes asynchronously. The dialog is composed of a table with
 * buttons to load the datasets (More than one dataset can be loaded
 * from within the dialog at a time).
 */


BlockPyCorgis.prototype.openDialog = function () {
  var _this3 = this;

  if (this.main.model.ui.server.isEndpointConnected("importDatasets")) {
    var root = this.main.model.configuration.urls.importDatasets;
    $.getJSON(root + "index.json", function (data) {
      // Make up the Body
      var datasets = data.blockpy;
      var documentation = root + "blockpy/index.html";
      var start = $("<p>Documentation is available at <a href='".concat(documentation, "' target=_blank>url</a></p>"));
      var body = $("<table></table>", {
        "class": "table table-bordered table-sm table-striped"
      });
      Object.keys(datasets).sort().map(function (name) {
        var sluggedName = Object(_utilities__WEBPACK_IMPORTED_MODULE_0__["slug"])(datasets[name].name);
        var titleName = name;
        var btn = $('<button type="button" class="btn btn-primary" data-toggle="button" aria-pressed="false" autocomplete="off">Load</button>');
        var imgSrc = root + "../images/datasets/" + name + "-icon.png";

        if (_this3.loadedDatasets.indexOf(sluggedName) > -1) {
          setButtonLoaded(btn);
        } else {
          btn.click(function () {
            _this3.importDataset(sluggedName, "Data - " + datasets[name].title);

            setButtonLoaded(btn);
          });
        } //let img = `<img src='${imgSrc}' class="corgis-icon">`;


        $("<tr></tr>") //.append($("<td>" + img + "</td>"))
        .append($("<td>" + datasets[name].title + "</td>")).append($("<td>" + datasets[name].overview + "</td>")).append($("<td></td>").append(btn)).appendTo(body);
      });
      body.appendTo(start); // Show the actual dialog

      _this3.main.components.dialog.show("Import Datasets", start, null);
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/css/blockpy.css":
/*!*****************************!*\
  !*** ./src/css/blockpy.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/css/bootstrap_retheme.css":
/*!***************************************!*\
  !*** ./src/css/bootstrap_retheme.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
    if(false) { var cssReload; }
  

/***/ }),

/***/ "./src/dialog.js":
/*!***********************!*\
  !*** ./src/dialog.js ***!
  \***********************/
/*! exports provided: DIALOG_HTML, BlockPyDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIALOG_HTML", function() { return DIALOG_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyDialog", function() { return BlockPyDialog; });
// TODO: Dyanmically populate aria-labelledby in this and other places
var DIALOG_HTML = "\n    <div class='blockpy-dialog modal hidden'\n         role=\"dialog\"\n         aria-label='Dialog'\n         aria-hidden=\"true\"\n         aria-modal=\"true\">\n        <div class='modal-dialog modal-lg' role=\"document\">\n            <div class='modal-content' role='region' aria-label='Dialog content'>\n                <div class='modal-header'>\n                    <h4 class='modal-title'>Dynamic Content</h4>\n                    <button type='button' class='close' data-dismiss='modal' aria-hidden='true'>\n                        <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                </div>\n                <div class='modal-body' style='max-width:100%; max-height:400px'>\n                </div>\n                <div class='modal-footer'>\n                    <button type='button' class='btn btn-white modal-close' data-dismiss='modal'>Close</button>\n                    <button type='button' class='btn btn-success modal-okay' data-dismiss='modal'>Okay</button>\n                </div>    \n            </div>\n        </div>\n    </div>\n";
/**
 * A utility object for quickly and conveniently generating dialog boxes.
 * Unfortunately, this doesn't dynamically create new boxes; it reuses the same one
 * over and over again. It turns out dynamically generating new dialog boxes
 * is a pain! So we can't stack them.
 *
 * @constructor
 * @this {BlockPyDialog}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

function BlockPyDialog(main, tag) {
  var _this = this;

  this.main = main;
  this.tag = tag;
  this.titleTag = tag.find(".modal-title");
  this.bodyTag = tag.find(".modal-body");
  this.footerTag = tag.find(".modal-footer");
  this.okayButton = tag.find(".modal-okay");
  this.closeButton = tag.find(".modal-close");

  this.yes = function () {};

  this.no = function () {};

  this.okayButton.click(function () {
    _this.yes();

    _this.tag.modal("hide");
  });
  this.closeButton.click(function () {
    _this.no(); //this.tag.modal("hide");

  });
}

BlockPyDialog.prototype.close = function () {
  this.tag.modal("hide");
};
/**
 * A simple externally available function for popping up a dialog
 * message. This menu will be draggable by its title.
 *
 * @param {String} title - The title of the message dialog. Can have HTML.
 * @param {String} body - The body of the message dialog. Can have HTML.
 * @param {function} onclose - A function to be run when the user closes the dialog.
 */


BlockPyDialog.prototype.show = function (title, body, onclose) {
  this.titleTag.html(title);
  this.bodyTag.html(body);
  this.tag.modal("show");
  this.okayButton.hide();
  this.tag.draggable({
    "handle": ".modal-title"
  });
  this.tag.on("hidden.bs.modal", function (e) {
    if (onclose !== undefined && onclose !== null) {
      onclose();
    }
  });
};

BlockPyDialog.prototype.confirm = function (title, body, yes, no, yesText) {
  if (yesText === undefined) {
    yesText = "Okay";
  }

  this.show(title, body, no);
  this.yes = yes;
  this.no = no;
  this.okayButton.show().html(yesText); // TODO: add okay button and cancel button
};

BlockPyDialog.prototype.ASSIGNMENT_VERSION_CHANGED = function () {
  this.confirm("Assignment Changed", "Your instructor has made changes to this assignment. Would you like to reload? All your work has been saved.");
};

BlockPyDialog.prototype.ERROR_LOADING_ASSIGNMNENT = function (reason) {
  this.show("Error Loading Assignment", "BlockPy encountered an error while loading the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_LISTING_UPLOADED_FILES = function (reason) {
  this.show("Error Listing Uploaded Files", "BlockPy encountered an error while listing the uploaded files.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_UPLOADING_FILE = function (reason) {
  this.show("Error Uploaded File", "BlockPy encountered an error while uploading the file.<br>\nPlease try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SAVING_ASSIGNMNENT = function (reason) {
  this.show("Error Saving Assignment", "BlockPy encountered an error while saving the assignment.<br>\nPlease reload the page and try again.<br>Response from server was:<br><pre>".concat(reason, "</pre>"));
};

BlockPyDialog.prototype.ERROR_SHOW_STUDENT_ERROR = function (error) {
  this.show("Original Error", "When I ran your code, I encountered an error:\n\n<div class=\"blockpy-dialog-student-error-message\">".concat(error, "</div>"));
};

BlockPyDialog.prototype.POSITIVE_FEEDBACK_FULL = function (title, message) {
  this.show(title, message);
};

BlockPyDialog.prototype.SCREENSHOT_BLOCKS = function () {// TODO
};

BlockPyDialog.prototype.ERROR_UPDATING_SUBMISSION_STATUS = function () {
  this.show("Error Updating Submission Status", "BlockPy encountered an error while updating your submission status.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.ERROR_LOADING_HISTORY = function () {
  this.show("Error Loading History", "BlockPy encountered an error while loading your history.<br>\nPlease reload the page and try again.");
};

BlockPyDialog.prototype.OFFER_FORK = function () {
  var setupUrl = this.main.model.configuration.urls.instructionsAssignmentSetup;
  setupUrl = setupUrl ? " (<a href=\"".concat(setupUrl, "\" target=\"_blank\">How do I do that?</a>)") : "";
  this.show("Assignment Not Owned; Fork?", "\n    <div class=\"mb-4\">\n        It looks like you want to edit this assignment, but you are not an instructor\n    or designer in the course that owns it (\"Course Name\"). Would you like to fork\n    this assignment (or its entire group) so that you can save your modifications?\n    </div>\n    \n    <div class=\"mb-4\">\n        Remember to update the Launch URL in the assignments' settings on Canvas!".concat(setupUrl, "\n    </div>\n    \n    <div><button type='button' class='btn btn-white'>Fork entire assignment group</button></div>\n    <div><button type='button' class='btn btn-white'>Fork just this assignment</button></div>\n    <div><button type='button' class='btn btn-danger'>Reset my local changes</button></div>\n    \n    <div class=\"form-check\">\n        <input type=\"checkbox\" class=\"form-check-input\"\n                name=\"blockpy-transfer-submissions\">\n        <label class=\"form-check-label\" for=\"blockpy-transfer-submissions\">Transfer Student Submissions for this course</label>\n    </div>\n    \n    <div class=\"form-check\">\n    <label class=\"form-text\" for=\"blockpy-course-id\">New owning course id: </label>\n        <input type=\"text\" name=\"blockpy-course-id\" value=\"").concat(this.main.model.user.courseId(), "\">\n    </div>\n    "));
};

BlockPyDialog.prototype.EDIT_INPUTS = function () {
  var _this2 = this;

  var inputText = this.main.model.execution.input().join("\n");
  var clearInputs = this.main.model.display.clearInputs() ? "" : "checked";

  var yes = function yes() {
    var checked = _this2.tag.find(".blockpy-remember-inputs").prop("checked");

    var inputs = _this2.tag.find(".blockpy-input-list").val().split("\n");

    _this2.main.model.display.clearInputs(!checked);

    _this2.main.model.execution.input(inputs);
  };

  this.confirm("Edit Remembered Inputs", "\n\n<div class=\"form-check\">\n<input type=\"checkbox\" class=\"blockpy-remember-inputs form-check-input\"\n        name=\"blockpy-remember-inputs\" ".concat(clearInputs, ">\n<label class=\"form-check-label\" for=\"blockpy-remember-inputs\">Reuse inputs for next execution</label>\n</div>\n\n<textarea class=\"blockpy-input-list form-control\" rows=\"4\">").concat(inputText, "</textarea><br>\nEdit the inputs above to store and reuse them across multiple executions.\nEach input should be put on its own line.\nYou do not need quotes; the text will be entered literally.\n \n"), yes, this.no, "Save"); // TODO: Allow user to specify the infinite string to keep giving when the others run out
};

/***/ }),

/***/ "./src/editor/abstract_editor.js":
/*!***************************************!*\
  !*** ./src/editor/abstract_editor.js ***!
  \***************************************/
/*! exports provided: uploadFile, sluggify, downloadFile, AbstractEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uploadFile", function() { return uploadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sluggify", function() { return sluggify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadFile", function() { return downloadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractEditor", function() { return AbstractEditor; });
/* harmony import */ var _editors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../editors */ "./src/editors.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


function uploadFile(model, event) {
  var fileReader = new FileReader();
  var files = event.target.files;

  fileReader.onload = function (e) {
    return model.ui.editors.current().uploadFile(e);
  };

  fileReader.fileName = files[0].name;
  fileReader.readAsText(files[0]);
  event.target.value = "";
}
function sluggify(text) {
  return text.replace(/[^a-z0-9]/gi, "_").toLowerCase();
}
function downloadFile(model, event) {
  var _model$ui$editors$cur = model.ui.editors.current().downloadFile(),
      name = _model$ui$editors$cur.name,
      extension = _model$ui$editors$cur.extension,
      contents = _model$ui$editors$cur.contents,
      mimetype = _model$ui$editors$cur.mimetype; // Make safe


  name = sluggify(name);
  name = name + extension; // Make the data download as a file

  var blob = new Blob([contents], {
    type: mimetype
  });

  if (window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveBlob(blob, name);
  } else {
    var temporaryDownloadLink = window.document.createElement("a");
    temporaryDownloadLink.href = window.URL.createObjectURL(blob);
    temporaryDownloadLink.download = name;
    document.body.appendChild(temporaryDownloadLink);
    temporaryDownloadLink.click();
    document.body.removeChild(temporaryDownloadLink);
  }
}
var AbstractEditor = /*#__PURE__*/function () {
  function AbstractEditor(main, tag) {
    _classCallCheck(this, AbstractEditor);

    this.main = main;
    this.tag = tag;
    this.fileSystem = main.components.fileSystem;
    this.filename = null;
    this.file = null;
  }

  _createClass(AbstractEditor, [{
    key: "deleteFile",
    value: function deleteFile() {
      this.fileSystem.deleteFile(this.filename);
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileDeleted",
    value: function onFileDeleted() {
      // TODO: Switch to the previous file instead of a default file
      this.main.model.display.filename("answer.py");
      this.main.components.editors.changeEditor("answer.py");
    }
  }, {
    key: "onFileUpdated",
    value: function onFileUpdated(file) {
      if (file.filename === this.filename) {
        //this.file = file;
        this.main.components.editors.changeEditor(this.filename); //this.fileSystem.stopWatchingFile(this.filename);
        //this.trackCurrentFile();
      }
    }
  }, {
    key: "trackCurrentFile",
    value: function trackCurrentFile() {
      this.fileSystem.watchFile(this.filename, {
        updated: this.onFileUpdated.bind(this),
        deleted: this.onFileDeleted.bind(this)
      });
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      this.filename = newFilename;
      this.file = this.fileSystem.getFile(newFilename);
      this.trackCurrentFile();
    }
    /**
     *
     * @param newFilename - the filename that the other editor will be switching to
     * @param oldEditor
     * @param newEditor
     */

  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      this.fileSystem.stopWatchingFile(this.filename);
      this.file = null;
      this.filename = null;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var contents = event.target.result;
      this.file.handle(contents);
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var filename = _editors__WEBPACK_IMPORTED_MODULE_0__["Editors"].parseFilename(this.filename);
      return {
        name: filename.name,
        extension: filename.type,
        contents: this.file.handle(),
        mimetype: "text/plain"
      };
    }
  }]);

  return AbstractEditor;
}();

/***/ }),

/***/ "./src/editor/assignment_settings.js":
/*!*******************************************!*\
  !*** ./src/editor/assignment_settings.js ***!
  \*******************************************/
/*! exports provided: AssigmentType, ASSIGNMENT_SETTINGS_EDITOR_HTML, saveAssignmentSettings, loadAssignmentSettings, makeAssignmentSettingsModel, AssignmentSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssigmentType", function() { return AssigmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ASSIGNMENT_SETTINGS_EDITOR_HTML", function() { return ASSIGNMENT_SETTINGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveAssignmentSettings", function() { return saveAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadAssignmentSettings", function() { return loadAssignmentSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAssignmentSettingsModel", function() { return makeAssignmentSettingsModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssignmentSettings", function() { return AssignmentSettings; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _python__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./python */ "./src/editor/python.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var ASSIGNMENT_SETTINGS = [["toolbox", "toolbox", "normal", "toolbox", "Which version of the toolbox to present to the user."], ["type", "type", "blockpy", "type", "The type of question; BlockPy programming problems are the default, but we also support static readings, quiz questions, and a Maze game."], ["passcode", "passcode", "", "string", "A string that the user must enter to access the problem. If blank, then no passcode is prompted."], //["toolboxLevel", "toolbox_level", "normal", "toolbox", "INCOMPLETE: What level of toolbox to present to the user (hiding and showing categories)."],
["startView", "start_view", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT, _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"], "The Python editor mode to start in when the student starts the problem."], ["datasets", "datasets", "", "string", "The current list of datasets available on load as a comma-separated string."], ["disableTimeout", "disable_timeout", false, "bool", "If checked, then students code is allowed to run without timeouts (potentially allowing infinite loops)."], ["isParsons", "is_parsons", false, "bool", "If checked, then this is a parson's style question (jumbled)."], ["saveTurtleOutput", "save_turtle_output", false, "bool", "If checked, then turtle (and pygame) output is saved whenever the program uses it."], ["disableFeedback", "disable_feedback", false, "bool", "If checked, then no instructor scripts are run (e.g., on_run and on_eval)."], ["disableInstructorRun", "disable_instructor_run", false, "bool", "If checked, then the instructor on_run will not automatically run the students' code. This still runs the students' code once beforehand, but the output/data will not be available to the instructor's on_run.py script."], ["disableStudentRun", "disable_student_run", false, "bool", "If checked, then the run button no longer run the students' code. This still runs the instructor's feedback on_run script."], ["disableTifa", "disable_tifa", false, "bool", "If checked, then do not automatically run Tifa (which can be slow)."], ["disableTrace", "disable_trace", false, "bool", "If checked, then the students code will not have its execution traced (no variables recorded, no coverage tracked)."], ["disableEdit", "disable_edit", false, "bool", "If checked, then the students' file will not be editable."], ["enableImages", "can_image", false, "bool", "If checked, then users can copy/paste images directly into the text editor."], ["enableBlocks", "can_blocks", true, "bool", "If checked, then the student can edit the block interface (if not, then it is visible but not editable)."], ["canClose", "can_close", false, "bool", "If checked, then the student should mark their submission closed when they are done. There is no way to force a student to do so. Unlike Reviewed, this still submits the correctness."], ["onlyInteractive", "only_interactive", false, "bool", "If checked, the editors are hidden, the program is automatically run, and then the console enters Eval mode (interactive)."], ["onlyUploads", "only_uploads", false, "bool", "If checked, then the students' file will not be directly editable (they will have to upload submissions)."], // What menus/feedback to show and hide
["hideSubmission", "hide_submission", false, "bool", "If checked, then students will not be able to see their submission's code or history on Canvas."], ["hideFiles", "hide_files", true, "bool", "If checked, then students will not see the View Files toolbar."], ["hideQueuedInputs", "hide_queued_inputs", false, "bool", "If checked, then the students cannot access the queued inputs box (makes repeated debugging easier for the input function)."], ["hideEditors", "hide_editors", false, "bool", "If checked, then all of the editors are hidden."], ["hideMiddlePanel", "hide_middle_panel", false, "bool", "If checked, then the console and feedback areas is hidden."], ["hideAll", "hide_all", false, "bool", "INCOMPLETE: If checked, then the entire interface is hidden."], ["hideEvaluate", "hide_evaluate", false, "bool", "If checked, then the Evaluate button is not shown on the console."], ["hideImportDatasetsButton", "hide_import_datasets_button", false, "bool", "If checked, then students cannot see the import datasets button."], // TODO: Fix this one to be settable
["hideImportStatements", "hide_import_statements", false, "bool", "INCOMPLETE: If checked, certain kinds of import statements (matplotlib, turtle, datasets) are not shown in the block interface."], ["hideCoverageButton", "hide_coverage_button", false, "bool", "INCOMPLETE: If checked, the coverage button is not shown."], ["hideTraceButton", "hide_trace_button", false, "bool", "If checked, then the Trace button is not shown."], ["smallLayout", "small_layout", false, "bool", "If checked, then the interface fits into a smaller region."]];
var AssigmentType = {
  BLOCKPY: "blockpy",
  MAZE: "maze",
  QUIZ: "quiz",
  READING: "reading"
};

function getDocumentation(name) {
  for (var i = 0; i < ASSIGNMENT_SETTINGS.length; i++) {
    if (ASSIGNMENT_SETTINGS[i][0] === name) {
      return ASSIGNMENT_SETTINGS[i][4];
    }
  }

  return "Documentation not found for field";
}

function makeStartViewTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: assignment.settings.startView() === '".concat(mode, "'},\n                           click: assignment.settings.startView.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-start-view-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML = ASSIGNMENT_SETTINGS // Only handle the simple booleans this way
.filter(function (setting) {
  return setting[3] === "bool";
}).map(function (setting) {
  var prettyName = setting[1].split("_").map(function (word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ");
  return "\n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-".concat(setting[0], "\">").concat(prettyName, "</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-").concat(setting[0], "\"\n                    data-bind=\"checked: assignment.settings.").concat(setting[0], "\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    ").concat(setting[4], "\n                </small>\n            </div>\n        </div>\n        ");
}).join("\n\n");
var ASSIGNMENT_SETTINGS_EDITOR_HTML = "\n    <div class=\"blockpy-view-settings\">\n    \n    <form>\n\n        <div class=\"form-group row\">\n            <div class=\"col-sm-12 mx-auto\">\n                <button type=\"button\" class=\"btn btn-success\"\n                    data-bind=\"click: ui.editors.settings.save\">Save changes</button>\n            </div>\n        </div>\n    \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-name\" class=\"col-sm-2 col-form-label text-right\">Name:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-name\"\n                data-bind=\"value: assignment.name\">\n                <small class=\"form-text text-muted\">\n                    The student-facing name of the assignment. Assignments within a group are ordered alphabetically\n                    by their name, so you may want to use a naming scheme like \"#43.5) Whatever\".\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-url\" class=\"col-sm-2 col-form-label text-right\">URL:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-url\"\n                data-bind=\"value: assignment.url\">\n                <small class=\"form-text text-muted\">\n                    The course-unique URL that can be used to consistently refer to this assignment. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-public\">Public:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-public\"\n                    data-bind=\"checked: assignment.public\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If not public, users outside of the course will not be able to see the assignment in course listings.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-hidden\">Hidden:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-hidden\"\n                    data-bind=\"checked: assignment.hidden\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If hidden, students will not be able to see their grade while working on the assignment.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Reviewed:</label>\n            </div>\n            <div class=\"col-sm-1\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" id=\"blockpy-settings-reviewed\"\n                    data-bind=\"checked: assignment.reviewed\">\n                </div>  \n            </div>            \n            <div class=\"col-sm-9\">\n                <small class=\"form-text text-muted\">\n                    If reviewed, the assignment need to be commented upon and regraded by the staff after submission.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-points\" class=\"col-sm-2 col-form-label text-right\">Points:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"number\" class=\"form-control\" id=\"blockpy-settings-points\"\n                data-bind=\"value: assignment.points\">\n                <small class=\"form-text text-muted\">\n                    The number of points this assignment is worth; defaults to 1 point. \n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <div class=\"col-sm-2 text-right\">\n                <label class=\"form-check-label\" for=\"blockpy-settings-reviewed\">Starting View:</label>\n            </div>\n            <div class=\"col-sm-3\">\n                <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n                    ".concat(makeStartViewTab("Blocks", "th-large", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].BLOCK), "\n                    ").concat(makeStartViewTab("Split", "columns", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].SPLIT), "\n                    ").concat(makeStartViewTab("Text", "align-left", _python__WEBPACK_IMPORTED_MODULE_1__["DisplayModes"].TEXT), "\n                 </div>\n            </div>            \n            <div class=\"col-sm-7\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("startView"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-ip-ranges\" class=\"col-sm-2 col-form-label text-right\">IP Ranges:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-ip-ranges\"\n                data-bind=\"value: assignment.ipRanges\">\n                <small class=\"form-text text-muted\">\n                    Provide a comma-separated list of IP Addresses that will be explicitly allowed. If blank,\n                    then all addresses are allowed. If an address starts with <code>^</code> then it it is explicitly\n                    blacklisted, but that can be overridden in turn with a <code>!</code>. Addresses can also\n                    include a bit mask to allow a range of addresses.\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-passcode\" class=\"col-sm-2 col-form-label text-right\">Passcode:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-passcode\"\n                data-bind=\"value: assignment.settings.passcode\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("passcode"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-datasets\" class=\"col-sm-2 col-form-label text-right\">Preloaded Datasets:</label>\n            <div class=\"col-sm-10\">\n                <input type=\"text\" class=\"form-control\" id=\"blockpy-settings-datasets\"\n                data-bind=\"value: assignment.settings.datasets\">\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("datasets"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-toolbox\" class=\"col-sm-2 col-form-label text-right\">Block Toolbox:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-toolbox\"\n                       data-bind=\"value: assignment.settings.toolbox\">\n                   <option value=\"normal\">Normal Toolbox</option>\n                   <option value=\"ct\">CT@VT Toolbox</option>\n                   <option value=\"ct2\">CT@VT Toolbox V2</option>\n                   <option value=\"minimal\">Minimal Set</option>\n                   <option value=\"full\">All Blocks</option>\n                   <option value=\"custom\">Custom</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("toolbox"), "\n                </small>\n            </div>\n        </div>\n        \n        <div class=\"form-group row\">\n            <label for=\"blockpy-settings-type\" class=\"col-sm-2 col-form-label text-right\">Problem Type:</label>\n            <div class=\"col-sm-10\">\n                <select class=\"form-control\" id=\"blockpy-settings-type\"\n                       data-bind=\"value: assignment.type\">\n                   <option value=\"blockpy\">BlockPy</option>\n                   <option value=\"maze\">Maze</option>\n                   <option value=\"quiz\">Quiz Question</option>\n                   <option value=\"reading\">Reading</option>\n                </select>\n                <small class=\"form-text text-muted\">\n                    ").concat(getDocumentation("type"), "\n                </small>\n            </div>\n        </div>\n        \n        ").concat(ASSIGNMENT_SETTINGS_BOOLEAN_COMPONENTS_HTML, "\n    </form>\n    \n    </div>\n");
function saveAssignmentSettings(model) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2];
    var value = model.assignment.settings[clientName](); // Only store this setting if its different from the default

    if (value !== defaultValue) {
      settings[serverName] = value;
    }
  });
  return JSON.stringify(settings);
}
function loadAssignmentSettings(model, settings) {
  if (settings) {
    settings = JSON.parse(settings);
    ASSIGNMENT_SETTINGS.forEach(function (setting) {
      var clientName = setting[0],
          serverName = setting[1];

      if (serverName in settings) {
        model.assignment.settings[clientName](settings[serverName]);
      } else {
        model.assignment.settings[clientName](setting[2]);
      }
    });

    if (settings.start_view) {
      model.display.pythonMode(settings.start_view);
    }
  }
}
function makeAssignmentSettingsModel(configuration) {
  var settings = {};
  ASSIGNMENT_SETTINGS.forEach(function (setting) {
    var clientName = setting[0],
        serverName = setting[1],
        defaultValue = setting[2],
        fieldType = setting[3];

    if (configuration["assignment.settings." + serverName] === undefined) {
      settings[clientName] = ko.observable(defaultValue);
    } else {
      var configValue = configuration["assignment.settings." + serverName];

      if (fieldType === "bool") {
        configValue = configValue.toLowerCase() === "true";
      }

      settings[clientName] = ko.observable(configValue);
    }
  });
  return settings;
}

var AssignmentSettingsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(AssignmentSettingsView, _AbstractEditor);

  var _super = _createSuper(AssignmentSettingsView);

  function AssignmentSettingsView(main, tag) {
    var _this;

    _classCallCheck(this, AssignmentSettingsView);

    _this = _super.call(this, main, tag);
    _this.dirty = false;
    return _this;
  }

  _createClass(AssignmentSettingsView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false; //TODO: this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
      // this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //TODO: this.codeMirror.on("change", this.currentListener);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; // TODO: Do update

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true; //this.file.handle(this.codeMirror.value());
        // TODO: Update

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      //this.currentSubscription.dispose();
      // TODO: update
      //this.codeMirror.off("change", this.currentListener);
      _get(_getPrototypeOf(AssignmentSettingsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return AssignmentSettingsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var AssignmentSettings = {
  name: "Assignment Settings",
  extensions: ["!assignment_settings.blockpy"],
  constructor: AssignmentSettingsView,
  template: ASSIGNMENT_SETTINGS_EDITOR_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/default_header.js":
/*!**************************************!*\
  !*** ./src/editor/default_header.js ***!
  \**************************************/
/*! exports provided: default_header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default_header", function() { return default_header; });
var default_header = "\n<div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n     role=\"toolbar\" aria-label=\"Python Toolbar\">\n     <div class=\"btn-group mr-2\">\n        <label class=\"btn btn-outline-secondary\">\n            <span class=\"fas fa-file-upload\"></span> Upload\n            <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                hidden\n                data-bind=\"event: {change: ui.editors.upload}\">\n         </label>\n\n        <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n            data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"caret\"></span>\n            <span class=\"sr-only\">Toggle Dropdown</span>\n        </button>\n        \n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class='dropdown-item blockpy-toolbar-download'\n                data-bind=\"click: ui.editors.download\">\n            <span class='fas fa-download'></span> Download\n            </a>\n        </div>\n    </div>\n    \n    <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n        data-bind=\"visible: ui.editors.canDelete\">\n        <button type=\"button\" class=\"btn btn-outline-secondary\",\n            data-bind=\"click: ui.files.delete\">\n            <span class=\"fas fa-trash\"></span> Delete\n         </button>\n     </div>\n </div>\n";

/***/ }),

/***/ "./src/editor/images.js":
/*!******************************!*\
  !*** ./src/editor/images.js ***!
  \******************************/
/*! exports provided: IMAGE_EDITOR_HTML, ImageEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGE_EDITOR_HTML", function() { return IMAGE_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageEditor", function() { return ImageEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var IMAGE_EDITOR_HTML = "\n     <div>\n        <h3>Available Images</h3>\n        \n        <button data-bind=\"click: ui.editors.images.reloadImages\">Reload Available Images</button>\n        <!-- ko if: display.uploadedFiles() !== null -->\n            <ul>\n                <!-- ko foreach: { data: Object.keys(display.uploadedFiles()), as: 'placement' } -->\n                <li>\n                    <strong data-bind=\"text: $data\"></strong>:\n                    <ul>\n                    <!-- ko foreach: { data: $root.display.uploadedFiles()[placement], as: 'filename' } -->\n                        <li>\n                            <span data-bind=\"text: filename[0]\"></span>:\n                            <img data-bind=\"attr: { src: filename[1], alt: filename[1] }\"\n                                width=\"30px\" height=\"30px\"/>\n                        </li>\n                    <!-- /ko -->\n                    </ul>\n                </li>\n                <!-- /ko -->\n            </ul>\n        <!-- /ko -->\n    </div>\n";

var ImageEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ImageEditorView, _AbstractEditor);

  var _super = _createSuper(ImageEditorView);

  function ImageEditorView(main, tag) {
    _classCallCheck(this, ImageEditorView);

    return _super.call(this, main, tag);
  }

  _createClass(ImageEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ImageEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      var uploadedFiles = this.main.model.display.uploadedFiles();

      if (uploadedFiles === null) {
        this.reloadImages();
      }

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this));
      /*
      this.updateEditor(this.file.handle());
      // Subscribe to the relevant File
        // Notify relevant file of changes to BM
      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);*/
    }
  }, {
    key: "reloadImages",
    value: function reloadImages() {
      var _this = this;

      this.main.components.server.listUploadedFiles(function (response) {
        if (response.success) {
          _this.main.model.display.uploadedFiles(response.files);
        } else {
          _this.main.components.dialogs.ERROR_LISTING_UPLOADED_FILES(response.message);
        }
      });
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {}
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      /*this.dirty = !this.dirty;
      if (this.dirty) {
          this.dirty = true;
          this.file.handle(this.codeMirror.getValue());
          this.dirty = false;
      }*/
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();

      _get(_getPrototypeOf(ImageEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ImageEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ImageEditor = {
  name: "Image",
  extensions: ["?images.blockpy"],
  constructor: ImageEditorView,
  template: IMAGE_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/json.js":
/*!****************************!*\
  !*** ./src/editor/json.js ***!
  \****************************/
/*! exports provided: JSON_EDITOR_HTML, JsonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSON_EDITOR_HTML", function() { return JSON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonEditor", function() { return JsonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var JSON_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n     <div>\n        <textarea class=\"blockpy-editor-json\"></textarea>\n    </div>\n");

var JsonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(JsonEditorView, _AbstractEditor);

  var _super = _createSuper(JsonEditorView);

  function JsonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, JsonEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-json")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(JsonEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(JsonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(JsonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return JsonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var JsonEditor = {
  name: "JSON",
  extensions: [".json"],
  constructor: JsonEditorView,
  template: JSON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/markdown.js":
/*!********************************!*\
  !*** ./src/editor/markdown.js ***!
  \********************************/
/*! exports provided: MARKDOWN_EDITOR_HTML, MarkdownEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKDOWN_EDITOR_HTML", function() { return MARKDOWN_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownEditor", function() { return MarkdownEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MARKDOWN_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <textarea class=\"blockpy-editor-markdown\"></textarea>    \n");

var MarkdownEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(MarkdownEditorView, _AbstractEditor);

  var _super = _createSuper(MarkdownEditorView);

  function MarkdownEditorView(main, tag) {
    var _this;

    _classCallCheck(this, MarkdownEditorView);

    _this = _super.call(this, main, tag);
    _this.mde = new EasyMDE({
      element: tag.find(".blockpy-editor-markdown")[0],
      autoDownloadFontAwesome: false,
      forceSync: true,
      minHeight: "300px",
      //scrollbarStyle: "native",
      // TODO: imageUploadFunction
      renderingConfig: {
        codeSyntaxHighlighting: true
      },
      indentWithTabs: false,
      tabSize: 4
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(MarkdownEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(MarkdownEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.mde.codemirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.mde.codemirror.refresh.bind(this.mde.codemirror), 1);
      }
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.mde.value(newContents);
        this.mde.codemirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.mde.value());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.mde.codemirror.off("change", this.currentListener);

      _get(_getPrototypeOf(MarkdownEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return MarkdownEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var MarkdownEditor = {
  name: "Markdown",
  extensions: [".md"],
  constructor: MarkdownEditorView,
  template: MARKDOWN_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/python.js":
/*!******************************!*\
  !*** ./src/editor/python.js ***!
  \******************************/
/*! exports provided: DisplayModes, PYTHON_EDITOR_HTML, PythonEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayModes", function() { return DisplayModes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PYTHON_EDITOR_HTML", function() { return PYTHON_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PythonEditor", function() { return PythonEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../history */ "./src/history.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface */ "./src/interface.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * TODO: rename files, manual save, tags, sample_submissions, on_eval, non-builtin files
 * TODO: import data, history, run, url_data, assignment_settings, parsons_mode
 * TODO: delete becomes "clear" for instructor files
 */

/**
 *
 * @enum {str}
 */



var DisplayModes = {
  BLOCK: "block",
  SPLIT: "split",
  TEXT: "text"
};

function makeTab(name, icon, mode) {
  return "<label class=\"btn btn-outline-secondary blockpy-mode-set-blocks\"\n                data-bind=\"css: {active: display.pythonMode() === '".concat(mode, "'},\n                           click: ui.editors.python.updateMode.bind($data, '").concat(mode, "')\">\n                <span class='fas fa-").concat(icon, "'></span>\n                <input type=\"radio\" name=\"blockpy-mode-set\" autocomplete=\"off\" checked> ").concat(name, "\n            </label>");
}

var PYTHON_EDITOR_HTML = "\n\n    <div class=\"blockpy-python-toolbar col-md-12 btn-toolbar\"\n         role=\"toolbar\" aria-label=\"Python Toolbar\">\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Run Group\">         \n            <button type=\"button\" class=\"btn blockpy-run notransition\"\n                data-bind=\"click: ui.execute.run,\n                            css: {'blockpy-run-running': ui.execute.isRunning}\">\n                <span class=\"fas fa-play\"></span> <span data-bind=\"text: ui.execute.runLabel\"></span>\n             </button>\n         </div>\n         \n         <div class=\"btn-group btn-group-toggle mr-2\" data-toggle=\"buttons\">\n            <!-- ko if: $root.assignment.settings.enableBlocks() -->\n            ".concat(makeTab("Blocks", "th-large", DisplayModes.BLOCK), "\n            ").concat(makeTab("Split", "columns", DisplayModes.SPLIT), "\n            ").concat(makeTab("Text", "align-left", DisplayModes.TEXT), "\n            <!-- /ko -->\n         </div>\n\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Reset Group\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\"\n                 data-bind=\"click: ui.editors.reset\">\n                 <span class=\"fas fa-sync\"></span> Reset\n              </button>\n         </div>\n         \n         <!-- ko if: !assignment.settings.hideImportDatasetsButton() && !ui.smallLayout()-->\n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Import Group\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.importDataset\">\n                <span class=\"fas fa-cloud-download-alt\"></span> Import datasets\n             </button>\n         </div>\n         <!-- /ko -->\n         \n         <div class=\"btn-group mr-2\" data-bind=\"hidden: ui.smallLayout\">\n                <label class=\"btn btn-outline-secondary\">\n                    <span class=\"fas fa-file-upload\"></span> Upload\n                    <input class=\"blockpy-toolbar-upload\" type=\"file\"\n                        hidden\n                        data-bind=\"event: {change: ui.editors.upload}\">\n                 </label>\n\n                <button type=\"button\" class=\"btn btn-outline-secondary dropdown-toggle dropdown-toggle-split\"\n                    data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"caret\"></span>\n                    <span class=\"sr-only\">Toggle Dropdown</span>\n                </button>\n                \n                <div class=\"dropdown-menu dropdown-menu-right\">\n                    <a class='dropdown-item blockpy-toolbar-download'\n                        data-bind=\"click: ui.editors.download\">\n                    <span class='fas fa-download'></span> Download\n                    </a>\n                </div>\n            </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"History Group\" data-bind=\"hidden: ui.smallLayout\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                aria-pressed=\"false\"\n                data-bind=\"click: ui.editors.python.toggleHistoryMode,\n                           enable: ui.editors.python.isHistoryAvailable,\n                           css: { active: display.historyMode },\n                           attr: { 'aria-pressed': display.historyMode }\">\n                <span class=\"fas fa-history\"></span> History\n             </button>\n         </div>\n         \n         <!-- Fully functional, but a little too.. Invasive \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Fullscreen Group\"\n            data-bind=\"visible: display.pythonMode() === 'text'\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\"\n                data-bind=\"click: ui.editors.python.fullscreen\">\n                <span class=\"fas fa-expand-arrows-alt\"></span> Fullscreen\n             </button>\n         </div>\n         -->\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\"\n            data-bind=\"visible: ui.editors.canSave\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-save\"></span> Save\n             </button>\n         </div>\n         \n         <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Delete Group\"\n            data-bind=\"visible: ui.editors.canDelete\">\n            <button type=\"button\" class=\"btn btn-outline-secondary\",\n                data-bind=\"click: ui.files.delete\">\n                <span class=\"fas fa-trash\"></span> Delete\n             </button>\n         </div>\n         \n         <!--<div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Rename Group\"\n            data-bind=\"visible: ui.editors.canRename\">\n             <button type=\"button\" class=\"btn btn-outline-secondary\">\n                <span class=\"fas fa-file-signature\"></span> Rename\n             </button>\n         </div>-->\n         \n    </div>\n    \n    ").concat(_history__WEBPACK_IMPORTED_MODULE_1__["HISTORY_TOOLBAR_HTML"], "\n\n\n    <div class=\"blockpy-python-blockmirror\"\n        data-bind=\"hidden: ui.menu.isSubmitted\">\n    </div>\n");

function convertIpynbToPython(code) {
  var ipynb = JSON.parse(code);

  var isUsable = function isUsable(cell) {
    if (cell.cell_type === "code") {
      return cell.source.length > 0 && !cell.source[0].startsWith("%");
    } else {
      return cell.cell_type === "markdown" || cell.cell_type === "raw";
    }
  };

  var makePython = function makePython(cell) {
    if (cell.cell_type === "code") {
      return cell.source.join("\n");
    } else if (cell.cell_type === "markdown" || cell.cell_type === "raw") {
      return "'''" + cell.source.join("\n") + "'''";
    }
  };

  return ipynb.cells.filter(isUsable).map(makePython).join("\n");
}

var PythonEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(PythonEditorView, _AbstractEditor);

  var _super = _createSuper(PythonEditorView);

  function PythonEditorView(main, tag) {
    var _this;

    _classCallCheck(this, PythonEditorView);

    _this = _super.call(this, main, tag.find(".blockpy-python-blockmirror"));
    Blockly.setParentContainer(main.model.configuration.container[0]);
    _this.bm = new BlockMirror({
      "container": _this.tag[0],
      "run": main.components.engine.run.bind(main.components.engine),
      "skipSkulpt": true,
      "blocklyMediaPath": main.model.configuration.blocklyPath,
      "toolbox": main.model.assignment.settings.toolbox(),
      "imageMode": true,
      imageDownloadHook: function imageDownloadHook(oldUrl) {
        return oldUrl;
      },
      imageUploadHook: function imageUploadHook(blob) {
        //const uuid = window.URL.createObjectURL(new Blob([])).substring(31);
        return new Promise(function (resolve, reject) {
          var submissionId = main.model.submission.id();
          main.components.server.uploadFile("submission", submissionId, blob.name, blob, function (response) {
            resolve(JSON.stringify(response.endpoint)); //resolve(JSON.stringify(main.model.configuration.urls["downloadFile"] + `?placement=submission&directory=${submissionId}&filename=${blob.name}`));
          }); //return Promise.resolve("Image("+JSON.stringify(URL.createObjectURL(blob))+")");
          //return Promise.resolve(JSON.stringify(URL.createObjectURL(blob)));
        });
      },
      imageLiteralHook: function imageLiteralHook(oldUrl) {
        //return `Image("${oldUrl}")`;
        return "\"".concat(oldUrl, "\"");
      } //'height': '2000px'

    });
    _this.dirty = false;
    _this.readOnly = false;

    _this.makeSubscriptions();

    _this.lineErrorSubscription = null;
    _this.lineUncoveredSubscription = null;
    _this.lineTraceSubscription = null;
    _this.oldPythonMode = _this.main.model.display.pythonMode();

    _this.makePerAssignmentSubscriptions();

    return _this;
  }

  _createClass(PythonEditorView, [{
    key: "configureExtraBlockly",
    value: function configureExtraBlockly() {
      var _this2 = this;

      this.bm.blockEditor.workspace.configureContextMenu = function (options) {
        options.push({
          enabled: true,
          text: "Screenshot",
          callback: function callback() {
            return _this2.main.components.dialog.SCREENSHOT_BLOCKS;
          }
        });
      };
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this3 = this;

      var oldFilename = this.filename;

      _get(_getPrototypeOf(PythonEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;

      if (newFilename !== "answer.py") {
        if (oldFilename === "answer.py") {
          this.oldPythonMode = this.main.model.display.pythonMode();
        }

        this.main.model.display.pythonMode(DisplayModes.TEXT);
      } else {
        this.main.model.display.pythonMode(this.oldPythonMode);
      }

      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentBMListener = this.updateHandle.bind(this);
      this.bm.addChangeListener(this.currentBMListener);

      if (newFilename !== "answer.py") {
        this.bm.isParsons = function () {
          return false;
        };
      } else {
        this.bm.isParsons = this.main.model.assignment.settings.isParsons;
        this.lineErrorSubscription = this.main.model.execution.feedback.linesError.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-error-line");
        });
        this.lineUncoveredSubscription = this.main.model.execution.feedback.linesUncovered.subscribe(function (lines) {
          return _this3.bm.setHighlightedLines(lines, "editor-uncovered-line");
        });
        this.lineTraceSubscription = this.main.model.ui.trace.highlightedLine.subscribe(function (lines) {
          _this3.bm.clearHighlightedLines("editor-traced-line");

          _this3.bm.setHighlightedLines(lines, "editor-traced-line");
        });
      } //this.bm.blockEditor.workspace.render();
      //this.bm.refresh();
      // TODO: Figure out why this doesn't end up looking right (go to a different editor, come back, and it'll be squished)
      //this.bm.refresh();


      setTimeout(function () {
        return _this3.bm.refresh();
      }, 0);
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      if (newContents === undefined) {
        if (this.file !== null) {
          newContents = this.file.handle();
        } else {
          // Doesn't matter, file was already shut down.
          newContents = "";
        }
      } else if (newContents === null) {
        // We're closing this file
        this.main.components.fileSystem.deleteFileLocally_(this.filename);
        return;
      }

      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.bm.setCode(newContents); // Delay so that everything is rendered

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.bm.clearHighlightedLines();
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;

        if (!this.main.model.display.historyMode()) {
          this.file.handle(this.bm.getCode());
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.dirty = false;
      this.currentSubscription.dispose();
      this.bm.removeChangeListener(this.currentBMListener);

      if (this.main.model.display.historyMode()) {
        this.main.model.ui.editors.python.turnOffHistoryMode();
      }

      this.clearLineSubscriptions();

      _get(_getPrototypeOf(PythonEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }, {
    key: "clearLineSubscriptions",
    value: function clearLineSubscriptions() {
      this.bm.clearHighlightedLines();

      if (this.lineErrorSubscription) {
        this.lineErrorSubscription.dispose();
        this.lineErrorSubscription = null;
      }

      if (this.lineUncoveredSubscription) {
        this.lineUncoveredSubscription.dispose();
        this.lineUncoveredSubscription = null;
      }

      if (this.lineTraceSubscription) {
        this.lineTraceSubscription.dispose();
        this.lineTraceSubscription = null;
      }
    }
  }, {
    key: "makeSubscriptions",
    value: function makeSubscriptions() {
      var _this4 = this;

      this.bm.setMode(this.main.model.display.pythonMode());
      this.main.model.display.pythonMode.subscribe(function (mode) {
        _this4.bm.setMode(mode);
      });
      this.main.model.assignment.settings.enableBlocks.subscribe(function (enabled) {
        if (!enabled) {
          _this4.bm.setMode(DisplayModes.TEXT);
        } else {
          _this4.bm.setMode(_this4.main.model.display.pythonMode());
        }
      });
      this.main.model.assignment.settings.toolbox.subscribe(this.reloadToolbox.bind(this));
      this.main.model.assignment.settings.enableImages.subscribe(function (imageMode) {
        _this4.bm.setImageMode(imageMode);
      }); // Small Layout Stuff

      this.oldHeight = null;

      if (this.main.model.ui.smallLayout()) {
        this.useSmallLayout();
      }

      this.main.model.ui.smallLayout.subscribe(function (useSmallLayout) {
        if (useSmallLayout) {
          _this4.useSmallLayout();
        } else if (_this4.oldHeight !== null) {
          _this4.bm.configuration.height = _this4.oldHeight;

          _this4.bm.textEditor.resizeResponsively();

          _this4.oldHeight = null;
        }
      });
    }
  }, {
    key: "useSmallLayout",
    value: function useSmallLayout() {
      this.bm.textEditor.updateGutter({
        indentSidebar: false
      });
      this.oldHeight = this.bm.configuration.height;
      this.bm.configuration.height = 300; // TODO: Parameterize this

      this.bm.textEditor.resizeResponsively();
    }
  }, {
    key: "reloadToolbox",
    value: function reloadToolbox(toolbox) {
      if (toolbox === "custom") {
        var customToolbox = this.main.components.fileSystem.getFile("?toolbox.blockpy");

        if (customToolbox == null) {
          toolbox = "empty";
        } else {
          try {
            toolbox = JSON.parse(customToolbox.handle());
          } catch (e) {
            console.error(e); // TODO: Improve error message for instructor

            toolbox = "minimal";
          }
        }
      }

      this.bm.configuration.toolbox = toolbox; // TODO: Handle invalid toolbox better

      try {
        this.bm.blockEditor.remakeToolbox();
      } catch (e) {
        console.error(e);
        this.bm.configuration.toolbox = "empty";
        this.bm.blockEditor.remakeToolbox();
      }
    }
  }, {
    key: "makePerAssignmentSubscriptions",
    value: function makePerAssignmentSubscriptions() {
      var _this5 = this;

      this.main.model.display.instructor.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
      this.main.model.assignment.settings.onlyUploads.subscribe(function (changed) {
        _this5.setReadOnly(_this5.decideIfNotEditable());
      });
    }
  }, {
    key: "decideIfNotEditable",
    value: function decideIfNotEditable() {
      var model = this.main.model;
      return model.display.historyMode() || model.assignment.settings.onlyUploads() && !model.display.instructor();
    }
  }, {
    key: "setReadOnly",
    value: function setReadOnly(isReadOnly) {
      this.readOnly = isReadOnly;
      this.bm.setReadOnly(isReadOnly);
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(event) {
      var filename = event.target.fileName;
      var code = event.target.result;

      if (filename.endsWith(".ipynb")) {
        code = convertIpynbToPython(code);
      }

      this.main.components.server.logEvent("X-File.Upload", "", "", code, this.filename);
      this.file.handle(code);
      this.main.components.engine.run(); // TODO: Run code
    }
  }, {
    key: "downloadFile",
    value: function downloadFile() {
      var result = _get(_getPrototypeOf(PythonEditorView.prototype), "downloadFile", this).call(this);

      if (result.name === "answer" && result.extension === ".py") {
        result.name = Object(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["sluggify"])(this.main.model.assignment.name());
      }

      result.mimetype = "text/x-python";
      this.main.components.server.logEvent("X-File.Download", "", "", "", result.name);
      return result;
    }
  }]);

  return PythonEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var PythonEditor = {
  name: "Python",
  extensions: [".py"],
  constructor: PythonEditorView,
  template: PYTHON_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/quiz.js":
/*!****************************!*\
  !*** ./src/editor/quiz.js ***!
  \****************************/
/*! exports provided: QUIZ_EDITOR_HTML, QuizEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUIZ_EDITOR_HTML", function() { return QUIZ_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuizEditor", function() { return QuizEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var QUIZ_EDITOR_HTML = "\n    <div>\n    <textarea class=\"blockpy-editor-quiz\"></textarea>\n    </div>\n";

var QuizEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(QuizEditorView, _AbstractEditor);

  var _super = _createSuper(QuizEditorView);

  function QuizEditorView(main, tag) {
    var _this;

    _classCallCheck(this, QuizEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(QuizEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(QuizEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(QuizEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return QuizEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var QuizEditor = {
  name: "Quiz",
  extensions: [".quiz"],
  constructor: QuizEditorView,
  template: QUIZ_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/sample_submissions.js":
/*!******************************************!*\
  !*** ./src/editor/sample_submissions.js ***!
  \******************************************/
/*! exports provided: SubmissionStatuses, SampleSubmission, SAMPLE_SUBMISSIONS_HTML, SampleSubmissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubmissionStatuses", function() { return SubmissionStatuses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmission", function() { return SampleSubmission; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAMPLE_SUBMISSIONS_HTML", function() { return SAMPLE_SUBMISSIONS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleSubmissions", function() { return SampleSubmissions; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Panel for editing the set of Sample Submissions.
 * These are not provided at all to students without the Grader role.
 */

var SubmissionStatuses = {
  UNKNOWN: "unknown",
  PASSED: "passed",
  FAILED: "failed",
  ERROR: "error",
  SKIPPED: "skipped"
};
var SampleSubmission = /*#__PURE__*/function () {
  function SampleSubmission(name, status, code) {
    _classCallCheck(this, SampleSubmission);

    this.name = name;
    this.status = status;
    this.code = code;
  }

  _createClass(SampleSubmission, [{
    key: "serialize",
    value: function serialize() {
      return {
        name: this.name,
        status: this.status,
        code: this.code
      };
    }
  }], [{
    key: "Blank",
    value: function Blank(count) {
      return new SampleSubmission("Untitled" + (count || 1), SubmissionStatuses.UNKNOWN, "a=0");
    }
  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return new SampleSubmission(data.name, data.status, data.code);
    }
  }]);

  return SampleSubmission;
}();
var SAMPLE_SUBMISSIONS_HTML = "\n<div>\n    <div data-bind=\"foreach: {data: assignment.sampleSubmissions}\"\n        class=\"row\">\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: name\"></span>\n            <textarea class=\"blockpy-editor-sample-submissions-code\"\n                data-bind=\"codeMirrorInstance: code\"></textarea>\n        </div>\n        <div class=\"col-md-6\">\n            <span data-bind=\"text: status\"></span>        \n        </div>\n    </div>\n</div>\n";
ko.bindingHandlers.codeMirrorInstance = {
  init: function init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called when the binding is first applied to an element
    // Set up any initial state, event handlers, etc. here
    console.log("INIT");
    var cm = CodeMirror.fromTextArea(element, {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    cm.setSize("100%", "100px");
    return cm;
  },
  update: function update(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // This will be called once when the binding is first applied to an element,
    // and again whenever any observables/computeds that are accessed change
    // Update the DOM element based on the supplied values here.
    console.log("UPDATE");
  }
};

var SampleSubmissionsView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(SampleSubmissionsView, _AbstractEditor);

  var _super = _createSuper(SampleSubmissionsView);

  function SampleSubmissionsView(main, tag) {
    var _this;

    _classCallCheck(this, SampleSubmissionsView);

    _this = _super.call(this, main, tag);
    _this.tag = tag;
    _this.codeMirrors = [];
    _this.dirty = false;
    return _this;
  }

  _createClass(SampleSubmissionsView, [{
    key: "buildEditor",
    value: function buildEditor(newDOM, index, newElement) {}
  }, {
    key: "rebuildEditors",
    value: function rebuildEditors() {
      console.log("Rebuilding editors");
    }
  }, {
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      var _this2 = this;

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this); //this.rebuildEditors();
      //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        console.log(this.tag);
        console.log(this.tag.find(".CodeMirror"));
        console.log(this.tag.find(".CodeMirror").map(function (i, cm) {
          return console.log("+++", cm.CodeMirror);
        }));
        this.tag.find(".CodeMirror").map(function (i, cm) {
          return cm.CodeMirror.refresh();
        });
        console.log("REFRESH"); // Delay so that everything is rendered

        setTimeout(function () {
          return _this2.tag.find(".CodeMirror").map(function (i, cm) {
            return cm.CodeMirror.refresh();
          });
        }, 1);
      } // TODO: update dynamically when changing instructor status
      //this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());

    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        console.log(this.codeMirrors); //this.codeMirrors.each( (i, cm) => cm.setValue(newContents.join("\n")));
        //this.codeMirrors.each( (i, cm) => cm.refresh());

        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirrors.map(function (cm) {
          return cm.getValue();
        }));
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirrors = []; //this.codeMirrors.off("change", this.currentListener);
      //this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(SampleSubmissionsView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return SampleSubmissionsView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var SampleSubmissions = {
  name: "Sample Submissions",
  extensions: ["!sample_submissions.blockpy"],
  constructor: SampleSubmissionsView,
  template: SAMPLE_SUBMISSIONS_HTML
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout")))

/***/ }),

/***/ "./src/editor/tags.js":
/*!****************************!*\
  !*** ./src/editor/tags.js ***!
  \****************************/
/*! exports provided: TAGS_EDITOR_HTML, TagsEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAGS_EDITOR_HTML", function() { return TAGS_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TagsEditor", function() { return TagsEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TAGS_EDITOR_HTML = "\nCreate new\nImport by name\nFind by owner/course/kind\n\nTags:\n    Data:\n        Name\n        Kind\n        Level\n        Version\n        Description\n    Controls:\n        Edit\n        Remove\n        Delete \n";

var TagsEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TagsEditorView, _AbstractEditor);

  var _super = _createSuper(TagsEditorView);

  function TagsEditorView(main, tag) {
    _classCallCheck(this, TagsEditorView);

    return _super.call(this, main, tag.find(".blockpy-editor-tags"));
  }

  return TagsEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TagsEditor = {
  name: "Tags",
  extensions: ["!tags.blockpy"],
  constructor: TagsEditorView,
  template: TAGS_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/text.js":
/*!****************************!*\
  !*** ./src/editor/text.js ***!
  \****************************/
/*! exports provided: TEXT_EDITOR_HTML, TextEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_EDITOR_HTML", function() { return TEXT_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextEditor", function() { return TextEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
/* harmony import */ var _default_header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_header */ "./src/editor/default_header.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var TEXT_EDITOR_HTML = "\n    ".concat(_default_header__WEBPACK_IMPORTED_MODULE_1__["default_header"], "\n    <div>\n    <textarea class=\"blockpy-editor-text\"></textarea>\n    </div>\n");

var TextEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(TextEditorView, _AbstractEditor);

  var _super = _createSuper(TextEditorView);

  function TextEditorView(main, tag) {
    var _this;

    _classCallCheck(this, TextEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-text")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(TextEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(TextEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());
        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.codeMirror.off("change", this.currentListener);
      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(TextEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return TextEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var TextEditor = {
  name: "Text",
  extensions: [".txt"],
  constructor: TextEditorView,
  template: TEXT_EDITOR_HTML
};

/***/ }),

/***/ "./src/editor/toolbox.js":
/*!*******************************!*\
  !*** ./src/editor/toolbox.js ***!
  \*******************************/
/*! exports provided: TOOLBOX_EDITOR_HTML, ToolboxEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLBOX_EDITOR_HTML", function() { return TOOLBOX_EDITOR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolboxEditor", function() { return ToolboxEditor; });
/* harmony import */ var _abstract_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract_editor */ "./src/editor/abstract_editor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var TOOLBOX_EDITOR_HTML = "\n    <div>\n        <div class=\"col-md-12\"\n         role=\"toolbar\" aria-label=\"Toolbox Toolbar\">\n             <div class=\"btn-group mr-2\" role=\"group\" aria-label=\"Save Group\">         \n                <button type=\"button\" class=\"btn btn-outline-secondary btn-editor-json-save\">\n                    <span class=\"fas fa-save\"></span> Save\n                 </button>\n             </div>\n         </div>\n        <textarea class=\"blockpy-editor-toolbox\"></textarea>\n    </div>\n";

var ToolboxEditorView = /*#__PURE__*/function (_AbstractEditor) {
  _inherits(ToolboxEditorView, _AbstractEditor);

  var _super = _createSuper(ToolboxEditorView);

  function ToolboxEditorView(main, tag) {
    var _this;

    _classCallCheck(this, ToolboxEditorView);

    _this = _super.call(this, main, tag);
    _this.codeMirror = CodeMirror.fromTextArea(tag.find(".blockpy-editor-toolbox")[0], {
      showCursorWhenSelecting: true,
      lineNumbers: true,
      firstLineNumber: 1,
      indentUnit: 4,
      tabSize: 4,
      indentWithTabs: false,
      mode: "json",
      extraKeys: {
        "Tab": "indentMore",
        "Shift-Tab": "indentLess",
        "Esc": function Esc(cm) {
          if (cm.getOption("fullScreen")) {
            cm.setOption("fullScreen", false);
          } else {
            cm.display.input.blur();
          }
        },
        "F11": function F11(cm) {
          cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        }
      }
    });
    _this.dirty = false;
    return _this;
  }

  _createClass(ToolboxEditorView, [{
    key: "enter",
    value: function enter(newFilename, oldEditor) {
      _get(_getPrototypeOf(ToolboxEditorView.prototype), "enter", this).call(this, newFilename, oldEditor);

      this.dirty = false;
      this.updateEditor(this.file.handle()); // Subscribe to the relevant File

      this.currentSubscription = this.file.handle.subscribe(this.updateEditor.bind(this)); // Notify relevant file of changes to BM

      this.currentListener = this.updateHandle.bind(this);
      this.tag.find(".btn-editor-json-save").on("click", this.currentListener); //this.codeMirror.on("change", this.currentListener);

      if (oldEditor !== this) {
        // Delay so that everything is rendered
        setTimeout(this.codeMirror.refresh.bind(this.codeMirror), 1);
      } // TODO: update dynamically when changing instructor status


      this.codeMirror.setOption("readOnly", newFilename.startsWith("&") && !this.main.model.display.instructor());
    }
  }, {
    key: "updateEditor",
    value: function updateEditor(newContents) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.codeMirror.setValue(newContents);
        this.codeMirror.refresh();
        this.dirty = false;
      }
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(event) {
      this.dirty = !this.dirty;

      if (this.dirty) {
        this.dirty = true;
        this.file.handle(this.codeMirror.getValue());

        if (this.main.model.assignment.settings.toolbox() === "custom") {
          this.main.components.pythonEditor.reloadToolbox("custom");
        }

        this.dirty = false;
      }
    }
  }, {
    key: "exit",
    value: function exit(newFilename, oldEditor, newEditor) {
      // Remove subscriber
      this.currentSubscription.dispose();
      this.tag.find(".btn-editor-toolbox-save").off("click", this.currentListener); //this.codeMirror.off("change", this.currentListener);

      this.codeMirror.setOption("readOnly", false);

      _get(_getPrototypeOf(ToolboxEditorView.prototype), "exit", this).call(this, newFilename, oldEditor);
    }
  }]);

  return ToolboxEditorView;
}(_abstract_editor__WEBPACK_IMPORTED_MODULE_0__["AbstractEditor"]);

var ToolboxEditor = {
  name: "Toolbox",
  extensions: ["?toolbox.blockpy"],
  constructor: ToolboxEditorView,
  template: TOOLBOX_EDITOR_HTML
};

/***/ }),

/***/ "./src/editors.js":
/*!************************!*\
  !*** ./src/editors.js ***!
  \************************/
/*! exports provided: EditorsEnum, EDITORS_HTML, Editors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorsEnum", function() { return EditorsEnum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDITORS_HTML", function() { return EDITORS_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editors", function() { return Editors; });
/* harmony import */ var _editor_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor/python */ "./src/editor/python.js");
/* harmony import */ var _editor_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/text */ "./src/editor/text.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
/* harmony import */ var _editor_tags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./editor/tags */ "./src/editor/tags.js");
/* harmony import */ var _editor_markdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor/markdown */ "./src/editor/markdown.js");
/* harmony import */ var _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/sample_submissions */ "./src/editor/sample_submissions.js");
/* harmony import */ var _editor_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/json */ "./src/editor/json.js");
/* harmony import */ var _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./editor/toolbox */ "./src/editor/toolbox.js");
/* harmony import */ var _editor_quiz__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor/quiz */ "./src/editor/quiz.js");
/* harmony import */ var _editor_images__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./editor/images */ "./src/editor/images.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Editors are inferred from Filenames.
 *
 * The editor is based on the extension:
 *  .blockpy: Special editor (will be chosen by filename)
 *  .py: Python Editor
 *  .md: Markdown Editor
 *  .txt: Text Editor (also used for other types)
 *  .peml: PEML Editor
 *  .png, .gif, .jpeg, .jpg, .bmp: Image Editor
 *  .json: JSON Editor
 *  .yaml: YAML Editor
 */










/**
 * The different possible editors available
 * @enum {string}
 */

var EditorsEnum = {
  SUBMISSION: "submission",
  ASSIGNMENT: "assignment",
  INSTRUCTIONS: "instructions",
  ON_RUN: "on_run",
  ON_CHANGE: "on_change",
  ON_EVAL: "on_eval",
  STARTING_CODE: "starting_code",
  SAMPLE_SUBMISSIONS: "sample_submissions",
  INSTRUCTOR_FILE: "instructor_file"
};
var SPECIAL_NAMESPACES = ["!", "^", "?", "$"];
var AVAILABLE_EDITORS = [_editor_text__WEBPACK_IMPORTED_MODULE_1__["TextEditor"], _editor_python__WEBPACK_IMPORTED_MODULE_0__["PythonEditor"], _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssignmentSettings"], _editor_tags__WEBPACK_IMPORTED_MODULE_3__["TagsEditor"], _editor_markdown__WEBPACK_IMPORTED_MODULE_4__["MarkdownEditor"], _editor_sample_submissions__WEBPACK_IMPORTED_MODULE_5__["SampleSubmissions"], _editor_json__WEBPACK_IMPORTED_MODULE_6__["JsonEditor"], _editor_toolbox__WEBPACK_IMPORTED_MODULE_7__["ToolboxEditor"], _editor_quiz__WEBPACK_IMPORTED_MODULE_8__["QuizEditor"], _editor_images__WEBPACK_IMPORTED_MODULE_9__["ImageEditor"]];
var EDITORS_HTML = AVAILABLE_EDITORS.map(function (editor) {
  return "\n<div class=\"blockpy-panel blockpy-editor\" \n     data-bind=\"visible: ui.editors.view().name === '".concat(editor.name, "', class: ui.editors.width\">\n    <div>\n    ").concat(editor.template, "\n    </div>\n</div>\n");
}
/*
`
<!-- ko if: ui.editors.view().name === '${editor.name}' -->
${editor.template}
<!-- /ko -->`*/
).join("\n");
var Editors = /*#__PURE__*/function () {
  function Editors(main, tag) {
    var _this = this;

    _classCallCheck(this, Editors);

    this.main = main;
    this.tag = tag;
    this.current = null;
    this.registered_ = [];
    this.extensions_ = {};
    this.byName_ = {};
    AVAILABLE_EDITORS.forEach(function (editor) {
      return _this.registerEditor(editor);
    });
    this.main.model.display.filename.subscribe(this.changeEditor, this);
  }

  _createClass(Editors, [{
    key: "registerEditor",
    value: function registerEditor(data) {
      var extensions = data.extensions;
      var instance = new data.constructor(this.main, this.tag);
      instance.name = data.name;
      this.registered_.push(instance);
      this.byName_[data.name.toLowerCase()] = instance;

      for (var i = 0; i < extensions.length; i++) {
        this.extensions_[extensions[i]] = instance;
      }
    }
  }, {
    key: "byName",
    value: function byName(name) {
      return this.byName_[name.toLowerCase()];
    }
  }, {
    key: "changeEditor",
    value: function changeEditor(newFilename) {
      var oldEditor = this.current;
      var newEditor = this.getEditor(newFilename, oldEditor);

      if (oldEditor !== null) {
        oldEditor.exit(newFilename, oldEditor, newEditor);
      }

      this.current = newEditor;
      this.current.enter(newFilename, oldEditor);
    }
  }, {
    key: "getEditor",
    value: function getEditor(path) {
      var _Editors$parseFilenam = Editors.parseFilename(path),
          space = _Editors$parseFilenam.space,
          name = _Editors$parseFilenam.name,
          type = _Editors$parseFilenam.type;

      if (type === ".blockpy" && path in this.extensions_) {
        return this.extensions_[path];
      }

      var assignmentType = this.main.model.assignment.type();

      if (assignmentType !== _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_2__["AssigmentType"].BLOCKPY) {
        if (name === "answer" && type === ".py") {
          if ("." + assignmentType in this.extensions_) {
            return this.extensions_["." + assignmentType];
          } else {
            console.error("No editor registered for assignment type:", assignmentType);
            return this.registered_[0];
          }
        }
      }

      if (type in this.extensions_) {
        return this.extensions_[type];
      } else {
        return this.registered_[0];
      } //console.log(this.main.model.assignment.type(), space, name, type);

    }
  }], [{
    key: "parseFilename",
    value: function parseFilename(path) {
      var space = path.charAt(0);

      if (SPECIAL_NAMESPACES.indexOf(space) !== -1) {
        path = path.substr(1);
      } else {
        space = "";
      }

      var name = path.substr(0, path.lastIndexOf("."));
      var type = path.substr(path.lastIndexOf("."));
      return {
        "space": space,
        "name": name,
        "type": type
      };
    }
  }]);

  return Editors;
}();

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: BlockPyEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyEngine", function() { return BlockPyEngine; });
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server */ "./src/server.js");
/* harmony import */ var _engine_on_run__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/on_run */ "./src/engine/on_run.js");
/* harmony import */ var _engine_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine/run */ "./src/engine/run.js");
/* harmony import */ var _engine_eval__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine/eval */ "./src/engine/eval.js");
/* harmony import */ var _engine_sample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine/sample */ "./src/engine/sample.js");
/* harmony import */ var _engine_on_change__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./engine/on_change */ "./src/engine/on_change.js");
/* harmony import */ var _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine/on_eval */ "./src/engine/on_eval.js");
/* harmony import */ var _engine_on_sample__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine/on_sample */ "./src/engine/on_sample.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }









/**
 * An object for executing Python code and passing the results along to interested components.
 *
 * Interesting components:
 *  Execution Buffer: Responsible for collecting the trace during program execution.
 *                    This prevents Knockoutjs from updating the editor during execution.
 *
 * @constructor
 * @this {BlockPyEditor}
 * @param {Object} main - The main BlockPy instance
 * @param {HTMLElement} tag - The HTML object this is attached to.
 */

var BlockPyEngine = /*#__PURE__*/function () {
  function BlockPyEngine(main) {
    _classCallCheck(this, BlockPyEngine);

    this.main = main;
    this.executionModel = this.main.model.execution;
    this.configurations = {
      run: new _engine_run__WEBPACK_IMPORTED_MODULE_2__["RunConfiguration"](main),
      eval: new _engine_eval__WEBPACK_IMPORTED_MODULE_3__["EvalConfiguration"](main),
      onRun: new _engine_on_run__WEBPACK_IMPORTED_MODULE_1__["OnRunConfiguration"](main),
      onChange: new _engine_on_change__WEBPACK_IMPORTED_MODULE_5__["OnChangeConfiguration"](main),
      onEval: new _engine_on_eval__WEBPACK_IMPORTED_MODULE_6__["OnEvalConfiguration"](main)
    }; // Preconfigure skulpt so we can parse

    Sk.configure(this.configurations.run.getSkulptOptions()); // Keeps track of the tracing while the program is executing

    this.executionBuffer = {};
    /**
     * Definable function to be run when execution has fully ended,
     * whether it succeeds or fails.
     */

    this.onExecutionBegin = null;
    this.onExecutionEnd = null;
  }
  /**
   * Reset reports
   */


  _createClass(BlockPyEngine, [{
    key: "resetReports",
    value: function resetReports() {
      var report = this.executionModel.reports;
      report["verifier"] = {};
      report["parser"] = {};
      report["student"] = {};
      report["instructor"] = {};
      report["model"] = this.main.model;
    }
  }, {
    key: "resetStudentModel",
    value: function resetStudentModel() {
      var student = this.executionModel.student;
      student.calls = {};
      student.currentStep(null);
      student.currentTraceStep(0);
      student.lastStep(0);
      student.currentLine(null);
      student.currentTraceData.removeAll();
      student.results = null;
      student.tracing = [];
    }
  }, {
    key: "resetExecutionBuffer",
    value: function resetExecutionBuffer() {
      this.executionBuffer = {
        "trace": [],
        "step": 0,
        "line": 0
      };
    }
  }, {
    key: "reset",

    /**
     * Remove all interface aspects of the previous Run.
     */
    value: function reset() {
      // TODO: Clear out any coverage/trace/error highlights in editors
      // Reset execution in model
      this.resetStudentModel(); // Get reports ready

      this.resetReports(); // Clear out the execution buffer

      this.resetExecutionBuffer(); // Clear out the console of printed stuff

      this.main.components.console.clear(); // Clear out any old feedback

      this.main.components.feedback.clear();
    }
  }, {
    key: "delayedRun",
    value: function delayedRun() {
      //this.main.model.status.onExecution(StatusState.ACTIVE);
      //$(".blockpy-run").addClass("blockpy-run-running");
      this.run(); //setTimeout(this.run.bind(this), 1);
    }
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.configuration = this.configurations.run.use(this);
      var execution = this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration));

      if (!this.main.model.assignment.settings.disableFeedback()) {
        execution.then(function () {
          _this.configuration.provideSecretError();

          return _this.onRun();
        });
      } else {
        execution.then(this.configuration.showErrors.bind(this.configuration));
      }

      execution.then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onRun",
    value: function onRun() {
      this.configuration = this.configurations.onRun.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.configuration["finally"].bind(this.configuration)).then(this.executionEnd_.bind(this));
    }
  }, {
    key: "evaluate",
    value: function evaluate() {
      var _this2 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      var evaluationInput = this.main.components.console.evaluate();
      console.log(evaluationInput);
      evaluationInput.then(function (userInput) {
        _this2.configuration = _this2.configurations.eval.use(_this2, userInput);

        var execution = _this2.execute().then(_this2.configuration.success.bind(_this2.configuration), _this2.configuration.failure.bind(_this2.configuration));

        if (!_this2.main.model.assignment.settings.disableFeedback() && _this2.main.model.assignment.onEval()) {
          _this2.configuration.provideSecretError();

          execution.then(_this2.onEval.bind(_this2));
        } else {
          execution.then(_this2.configuration.showErrors.bind(_this2.configuration)).then(_this2.evaluate.bind(_this2));
        }

        execution.then(_this2.configuration["finally"].bind(_this2.configuration));
      });
    }
  }, {
    key: "onEval",
    value: function onEval() {
      this.configuration = this.configurations.onEval.use(this);
      this.execute().then(this.configuration.success.bind(this.configuration), this.configuration.failure.bind(this.configuration)).then(this.evaluate.bind(this)).then(this.configuration["finally"].bind(this.configuration));
    }
  }, {
    key: "onChange",
    value: function onChange() {
      this.configuration = this.configurations.onChange.use(this);
    }
  }, {
    key: "execute",
    value: function execute() {
      var _this3 = this;

      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_0__["StatusState"].ACTIVE);
      return Sk.misceval.asyncToPromise(function () {
        return Sk.importMainWithBody(_this3.configuration.filename, false, _this3.configuration.code, true, _this3.configuration.sysmodules);
      });
    }
    /**
     * Activated whenever the Python code changes
     */

  }, {
    key: "on_change",
    value: function on_change() {
      var FILENAME = "on_change"; // Skip if the instructor has not defined anything

      if (!this.main.model.programs[FILENAME]().trim()) {
        return false;
      }

      this.main.model.execution.status("changing");
      this.main.components.server.saveCode(); // On step does not perform parse analysis by default or run student code

      var engine = this;
      var feedback = this.main.components.feedback;
      engine.resetReports();
      engine.verifyCode();
      engine.updateParse();
      engine.runInstructorCode(FILENAME, true, function (module) {
        if (Sk.executionReports["instructor"]["success"]) {
          // SUCCESS, SCORE, CATEGORY, LABEL, MESSAGE, DATA, HIDE
          // TODO: only show under certain circumstances
          if (!success && !(category === "Instructor" && label === "No errors")) {
            feedback.presentFeedback(category, label, message, line);
          }

          engine.main.components.feedback.presentFeedback(module.$d);
          engine.main.model.execution.status("complete");
        }
      });
      engine.main.components.server.logEvent("engine", "on_change");
    }
  }, {
    key: "executionEnd_",

    /**
     * Helper function that will attempt to call the defined onExecutionEnd,
     * but will do nothing if there is no function defined.
     */
    value: function executionEnd_() {
      if (this.onExecutionEnd !== null) {
        this.onExecutionEnd();
      }
    }
    /**
     *
     */

  }, {
    key: "executionBegin_",
    value: function executionBegin_() {
      if (this.onExecutionBegin !== null) {
        this.onExecutionBegin();
      }
    }
  }]);

  return BlockPyEngine;
}();

/***/ }),

/***/ "./src/engine/configurations.js":
/*!**************************************!*\
  !*** ./src/engine/configurations.js ***!
  \**************************************/
/*! exports provided: EMPTY_MODULE, Configuration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_MODULE", function() { return EMPTY_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Configuration", function() { return Configuration; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EMPTY_MODULE = "let $builtinmodule = function(mod){ return mod; }";
/**
 * A container for holding settings of a particular run configuration.
 * This is the root class for all other configurations.
 */

var Configuration = /*#__PURE__*/function () {
  function Configuration(main) {
    _classCallCheck(this, Configuration);

    this.main = main;
    this.filename = null;
    this.code = null;
    this.sysmodules = undefined;
  }

  _createClass(Configuration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      // Access point for instructor data
      this.engine = engine;
      Sk.executionReports = this.main.model.execution.reports;
      Sk.console = this.main.components.console;
      Sk.queuedInput = [];
      Sk.configure(this.getSkulptOptions()); // Set openFile as mechanism to read files

      Sk.inBrowser = this.openFile.bind(this); // Proxy requests

      Sk.requestsGet = function (url, data, timeout) {
        return _this.openURL(url, data, timeout);
      }; // Configure a "do you want to wait? prompt"


      Sk.timeoutHandler = function (timePassed, execLimit) {
        if (_this.main.model.assignment.settings.disableTimeout()) {
          return null;
        }

        var promptMessage = _this.getTimeoutPrompt(timePassed / 1000 > 30);

        var delay = prompt(promptMessage, Sk.execLimit / 1000);

        if (delay !== null || delay == 0) {
          delay = Sk.execLimit + parseInt(delay, 10) * 1000;
          Sk.execLimit = delay;

          Sk.execLimitFunction = function () {
            return _this.main.model.assignment.settings.disableTimeout() ? Infinity : delay;
          };
        }

        return delay;
      }; // Attach beforeCall


      Sk.beforeCall = this.beforeCall.bind(this);
      return this;
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The program has taken a REALLY long time to run (30 or more seconds). You might want to cancel and check your code. Or, you can add more seconds to wait below.";
      } else {
        return "The program is taking a while to run. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "getSkulptOptions",
    value: function getSkulptOptions() {
      return {
        __future__: Sk.python3,
        // import
        read: this.importFile.bind(this),
        // open
        //fileopen: this.openFile.bind(this),
        // file.write
        filewrite: this.writeFile.bind(this),
        // print
        output: this.print.bind(this),
        // input
        inputfun: this.input.bind(this),
        inputfunTakesPrompt: true,
        // Media Image Proxy URL
        imageProxy: this.getImageProxy.bind(this),
        // TODO: Make this set by the system so we can use our own servers in practice
        emojiProxy: function emojiProxy(part) {
          return "https://twemoji.maxcdn.com/v/13.1.0/svg/".concat(part.toLowerCase(), ".svg");
        },
        // Whether or not to keep the globals
        retainGlobals: true
      };
    }
    /**
     * Used to access Skulpt built-ins. This is pretty generic, taken
     * almost directly from the Skulpt docs.
     *
     * @param {String} filename - The python filename (e.g., "os" or "pprint") that will be loaded.
     * @returns {String} The JavaScript source code of the file (weird, right?)
     * @throws Will throw an error if the file isn't found.
     */

  }, {
    key: "importFile",
    value: function importFile(filename) {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "openURL",
    value: function openURL(url, data, timeout) {
      //return new Promise((resolve, reject) => {
      var mockUrlData = this.main.components.fileSystem.getFile("?mock_urls.blockpy");

      if (mockUrlData == null) {
        throw new Sk.builtin.IOError("Cannot access url: URL Data was not made available for this assignment");
      }

      mockUrlData = JSON.parse(mockUrlData.handle());

      for (var filename in mockUrlData) {
        if (mockUrlData.hasOwnProperty(filename)) {
          for (var i = 0; i < mockUrlData[filename].length; i += 1) {
            if (mockUrlData[filename][i] === url) {
              var fileData = this.main.components.fileSystem.readFile(filename);
              return fileData;
            }
          }
        }
      } //reject(new Sk.builtin.IOError("Cannot access url: "+url+" was not made available for this assignment"));


      throw new Sk.builtin.IOError("Cannot access url: " + url + " was not made available for this assignment"); //});
    }
  }, {
    key: "openFile",
    value: function openFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "writeFile",
    value: function writeFile() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "print",
    value: function print(value) {
      this.main.components.console.print(value);
    }
  }, {
    key: "input",
    value: function input() {
      console.warn("Unimplemented method!"); // TODO
    }
  }, {
    key: "clearInput",
    value: function clearInput() {
      if (this.main.model.display.clearInputs()) {
        this.main.model.execution.input([]);
      }

      this.main.model.execution.inputIndex(0);
    }
  }, {
    key: "getImageProxy",
    value: function getImageProxy(url) {
      // TODO
      return url;
    }
  }, {
    key: "step",
    value: function step() {}
  }, {
    key: "lastStep",
    value: function lastStep() {}
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return false;
    }
  }, {
    key: "success",
    value: function success(module) {
      throw new Error("Abstract success execution");
    }
  }, {
    key: "failure",
    value: function failure(error) {
      throw new Error("Abstract failure execution");
    }
  }, {
    key: "finally",
    value: function _finally(result) {
      // Force Pygame to stop trapping keyboard events
      if (this.main.components.console.pygameLine) {
        this.main.components.console.pygameLine.cleanup();
        this.main.components.console.pygameLine.stop();
      }
    }
  }, {
    key: "dummyOutSandbox",
    value: function dummyOutSandbox() {//Sk.builtinFiles.files["src/lib/pedal/sandbox/sandbox.py"] = "class Sandbox: pass\ndef run(): pass\ndef reset(): pass\n";
    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      //console.log("TRACKING CALL", functionName, posargs, kwargs);
      // TODO: Handle fastcall too? Check how that works in Skulpt side
      var studentModel = this.main.model.execution.reports.student;

      if (!("calls" in studentModel)) {
        studentModel.calls = {};
      }

      if (!(functionName in studentModel.calls)) {
        studentModel.calls[functionName] = [];
      }

      var args = {}; // Get actual parameter names!!

      for (var i = 0; i < posargs.length; i += 1) {
        args["__ARG" + i] = posargs[i];
      }

      if (kwargs && kwargs[0] != null) {
        args["__ARGS"] = kwargs[0];
      }

      if (kwargs && kwargs[1] != null) {
        args["__KWARGS"] = kwargs[1];
      } //console.log(args);


      studentModel.calls[functionName].push(args);
    }
  }], [{
    key: "inputMockFunction",
    value: function inputMockFunction() {
      if (Sk.queuedInput.length) {
        return Sk.queuedInput.pop();
      } else {
        return "";
      }
    }
  }]);

  return Configuration;
}();

/***/ }),

/***/ "./src/engine/eval.js":
/*!****************************!*\
  !*** ./src/engine/eval.js ***!
  \****************************/
/*! exports provided: EvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EvalConfiguration", function() { return EvalConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../trace */ "./src/trace.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var EvalConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(EvalConfiguration, _StudentConfiguration);

  var _super = _createSuper(EvalConfiguration);

  function EvalConfiguration() {
    _classCallCheck(this, EvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(EvalConfiguration, [{
    key: "use",
    value: function use(engine, code) {
      // TODO: fix to be currently added line
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = "_ = " + code;
      Sk.afterSingleExecution = null;
      Sk.beforeCall = null;

      _get(_getPrototypeOf(EvalConfiguration.prototype), "use", this).call(this, engine);

      Sk.retainGlobals = true;
      Sk.globals = this.main.model.execution.student.globals();
      this.main.components.server.logEvent("X-File.Add", "", "", code, "evaluations");
      this.main.components.server.logEvent("Compile", "", "", this.code, "evaluations");
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Eval success");
      this.main.components.server.logEvent("X-Evaluate.Program", "", "", "", "evaluations");
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;
      this.main.components.console.printValue(Sk.ffi.remapToJs(module.$d._.$r()));
      return new Promise(function (resolve, reject) {
        //this.step(module.$d, module.$d,-1, 0, filename + ".py");
        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "evaluation": _this.code,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.log("Eval failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;
      this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "evaluations");
      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "evaluation": _this2.code,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return EvalConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/instructor.js":
/*!**********************************!*\
  !*** ./src/engine/instructor.js ***!
  \**********************************/
/*! exports provided: InstructorConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstructorConfiguration", function() { return InstructorConfiguration; });
/* harmony import */ var _configurations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations.js */ "./src/engine/configurations.js");
/* harmony import */ var _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../skulpt_modules/sk_mod_instructor */ "./src/skulpt_modules/sk_mod_instructor.js");
/* harmony import */ var _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skulpt_modules/coverage */ "./src/skulpt_modules/coverage.js");
/* harmony import */ var _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../skulpt_modules/pedal_tracer */ "./src/skulpt_modules/pedal_tracer.js");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../files */ "./src/files.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var UTILITY_MODULE_CODE = "var $builtinmodule = " + _skulpt_modules_sk_mod_instructor__WEBPACK_IMPORTED_MODULE_1__["$sk_mod_instructor"].toString();
var COVERAGE_MODULE_CODE = _skulpt_modules_coverage__WEBPACK_IMPORTED_MODULE_2__["$sk_mod_coverage"];
var InstructorConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(InstructorConfiguration, _Configuration);

  var _super = _createSuper(InstructorConfiguration);

  function InstructorConfiguration() {
    _classCallCheck(this, InstructorConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(InstructorConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(InstructorConfiguration.prototype), "use", this).call(this, engine); // Instructors get 4 seconds


      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 7000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = null; // 10 *1000
      // Mute everything

      this.main.model.display.mutePrinter(true); // Disable input box

      Sk.queuedInput = []; // TODO Sk.inputfun = BlockPyEngine.inputMockFunction;
      // TODO: Allow input function to disable the timer, somehow
      // Disable the beforeCall checker unless specifically requested

      Sk.beforeCallBackup = Sk.beforeCall;
      Sk.beforeCall = null; // Enable utility mode

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = UTILITY_MODULE_CODE;
      Sk.builtinFiles.files["src/lib/coverage.py"] = COVERAGE_MODULE_CODE; // TODO: Check if this needs to be optimized
      //const PEDAL_TRACER_MODULE_CODE = Sk.compile($pedal_tracer, "tracer.py", "exec", true, false);

      Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.py"] = _skulpt_modules_pedal_tracer__WEBPACK_IMPORTED_MODULE_3__["$pedal_tracer"];
      delete Sk.builtinFiles.files["src/lib/pedal/sandbox/tracer.js"]; // TODO: Mock Pedal's tracer module with the appropriate version

      Sk.builtinFiles.files["./_instructor/__init__.js"] = _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"]; // Reuse any existing sysmodules that we previously found, but not __main__ modules

      this.sysmodules = this.clearExistingStudentImports(); // Horrific hack, to prevent Tifa from caching a bad version of the students' import

      Sk.clearExistingStudentImports = this.clearExistingStudentImports;
      return this;
    }
  }, {
    key: "clearExistingStudentImports",
    value: function clearExistingStudentImports() {
      var sysmodules = this.main.model.execution.instructor.sysmodules; // Remove any existing __main__ modules

      if (sysmodules !== undefined) {
        var _iterator = _createForOfIteratorHelper(this.getAllFilenames()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var filename = _step.value;
            var skFilename = new Sk.builtin.str(filename);
            /*if (sysmodules.quick$lookup(skFilename)) {
                sysmodules.pop$item(skFilename);
            }*/

            sysmodules.pop$item(skFilename);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return sysmodules;
    }
  }, {
    key: "getAllStudentFiles",
    value: function getAllStudentFiles() {
      var files = {
        "answer.py": this.main.model.ui.files.getStudentCode()
      }; // Skip special instructor files

      this.main.model.assignment.extraInstructorFiles().forEach(function (file) {
        if (!"!^$#".includes(file.filename()[0])) {
          files[file.filename()] = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(file.contents());
        }
      }); // Include normal student extra files

      this.main.model.submission.extraFiles().forEach(function (file) {
        files[file.filename()] = file.contents();
      });
      return files;
    }
  }, {
    key: "getAllFilenames",
    value: function getAllFilenames() {
      function clean(filename) {
        filename = Object(_files__WEBPACK_IMPORTED_MODULE_4__["chompSpecialFile"])(filename);

        if (filename.endsWith(".py")) {
          filename = filename.slice(0, -3);
        }

        return filename;
      }

      return ["__main__", "_instructor"].concat(_toConsumableArray(this.main.model.assignment.extraInstructorFiles().map(function (file) {
        return "_instructor." + clean(file.filename());
      })), _toConsumableArray(this.main.model.submission.extraFiles().map(function (file) {
        return clean(file.filename());
      })));
    }
  }, {
    key: "getTimeoutPrompt",
    value: function getTimeoutPrompt(longTimeout) {
      if (longTimeout) {
        return "The instructor code has taken a REALLY long time to check your code (30 or more seconds). You might want to cancel and check your code (or get help from an instructor). Or, you can add more seconds to wait below.";
      } else {
        return "The instructor code is taking a little while to check your code; it might just need a little more time. How many more seconds would you like to wait?";
      }
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, false);

      if (found === undefined) {
        throw new Sk.builtin.OSError("File not found: " + filename);
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (filename === "./_instructor/on_run.py") {
        return this.main.model.assignment.onRun();
      } else if (filename === "./_instructor/on_eval.py") {
        return this.main.model.assignment.onEval() || "";
      } else if (filename === "./_instructor/__init__.js") {
        return _configurations_js__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, false);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      //return "ApplePie";
      console.log(">>>", this.main.model.execution.input(), this.main.model.execution.inputIndex());

      if (this.main.model.execution.inputIndex() < this.main.model.execution.input().length) {
        var inputIndex = this.main.model.execution.inputIndex();
        var nextInput = this.main.model.execution.input()[inputIndex];
        this.main.model.execution.inputIndex(inputIndex + 1);
        return nextInput;
      } else {
        return "ApplePie";
      }
      /*return new Promise((resolve) => {
          resolve(Sk.queuedInput.pop());
      });*/

    }
  }, {
    key: "beforeCall",
    value: function beforeCall(functionName, posargs, kwargs) {
      var studentModel = this.main.model.execution.reports.student; //console.log("HEY INSTRUCTOR CALL", functionName, studentModel.tracing);

      if (studentModel.tracing && studentModel.tracing.length) {
        _get(_getPrototypeOf(InstructorConfiguration.prototype), "beforeCall", this).call(this, functionName, posargs, kwargs);
      }
    }
  }]);

  return InstructorConfiguration;
}(_configurations_js__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/engine/on_change.js":
/*!*********************************!*\
  !*** ./src/engine/on_change.js ***!
  \*********************************/
/*! exports provided: OnChangeConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnChangeConfiguration", function() { return OnChangeConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnChangeConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnChangeConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnChangeConfiguration);

  function OnChangeConfiguration() {
    _classCallCheck(this, OnChangeConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnChangeConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnChangeConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_change.py";
      this.code = this.main.model.assignment.onChange();
      clearTimeout(this.main.model.display.triggerOnChange);
      return this;
    }
  }]);

  return OnChangeConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_eval.js":
/*!*******************************!*\
  !*** ./src/engine/on_eval.js ***!
  \*******************************/
/*! exports provided: WRAP_INSTRUCTOR_CODE, OnEvalConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnEvalConfiguration", function() { return OnEvalConfiguration; });
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentCode, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentCode);
  return "\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\n# Backup the feedback\non_run_feedback = []\nfor feedback in MAIN_REPORT.feedback:\n    on_run_feedback.append(feedback)\nMAIN_REPORT.feedback.clear()\n\nfrom pedal.environments.blockpy import setup_environment\n# Add in evaluated stuff from last time\nstudent = get_sandbox()\n# TODO: What about new inputs since we last ran/evaled?\n# MAIN_REPORT.submission.files['evaluation'] = ".concat(safeCode, "\nevaluate(").concat(safeCode, "['evaluation'])\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(_on_run__WEBPACK_IMPORTED_MODULE_2__["INSTRUCTOR_MARKER"], "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnEvalConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnEvalConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnEvalConfiguration);

  function OnEvalConfiguration() {
    _classCallCheck(this, OnEvalConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnEvalConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_eval";
      this.code = this.main.model.assignment.onEval() || "";
      var disableTifa = this.main.model.assignment.settings.disableTifa();
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.execution.reports.student.evaluation || "None";

      var studentFiles = this.getAllStudentFiles();
      studentFiles["evaluation"] = this.main.model.execution.reports.student.evaluation || "None";
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      console.log(">>>", instructorCode);
      var lineOffset = Object(_on_run__WEBPACK_IMPORTED_MODULE_2__["findActualInstructorOffset"])(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_eval.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;

      _get(_getPrototypeOf(OnEvalConfiguration.prototype), "use", this).call(this, engine); //Sk.retainGlobals = false;


      Sk.globals = this.main.model.execution.instructor.globals;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      console.log("OnEval success"); // TODO: Actually parse results

      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      console.log(module);
      var results = module.$d.on_eval.$d;
      console.log(module.$d);
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0.0, Math.min(1.0, score));
      var oldScore = this.main.model.submission.score();
      this.main.model.submission.score(Math.max(oldScore, score)); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.log("OnEval failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnEvalConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_0__["InstructorConfiguration"]);

/***/ }),

/***/ "./src/engine/on_run.js":
/*!******************************!*\
  !*** ./src/engine/on_run.js ***!
  \******************************/
/*! exports provided: findActualInstructorOffset, INSTRUCTOR_MARKER, NEW_LINE_REGEX, WRAP_INSTRUCTOR_CODE, OnRunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findActualInstructorOffset", function() { return findActualInstructorOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INSTRUCTOR_MARKER", function() { return INSTRUCTOR_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEW_LINE_REGEX", function() { return NEW_LINE_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WRAP_INSTRUCTOR_CODE", function() { return WRAP_INSTRUCTOR_CODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnRunConfiguration", function() { return OnRunConfiguration; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ "./src/utilities.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
/* harmony import */ var _instructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instructor */ "./src/engine/instructor.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




function findActualInstructorOffset(instructorCode) {
  var index = instructorCode.indexOf(INSTRUCTOR_MARKER);
  var before = instructorCode.slice(0, index);
  var match = before.match(NEW_LINE_REGEX);
  return match ? 1 + match.length : 0;
}
var INSTRUCTOR_MARKER = "###Run the actual instructor code###";
var NEW_LINE_REGEX = /\n/g;
/**
 * @return {string}
 */

var WRAP_INSTRUCTOR_CODE = function WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, quick, isSafe) {
  var safeCode = JSON.stringify(studentFiles);
  var skip_tifa = quick ? "True" : "False"; // TODO: Add in Sk.queuedInput to be passed in

  return "\n# Support our sysmodules hack by clearing out any lingering old data\nfrom pedal.core.report import MAIN_REPORT\nMAIN_REPORT.clear()\n\nfrom cisc108 import student_tests\nstudent_tests.reset()\n\nfrom utility import *\n\n# Load in some commonly used tools\nfrom pedal.cait.cait_api import parse_program\nfrom pedal.sandbox.commands import *\nfrom pedal.core.commands import *\n\nfrom pedal.environments.blockpy import setup_environment\n# Do we execute student's code?\nskip_run = get_model_info('assignment.settings.disableInstructorRun')\ninputs = None if skip_run else get_model_info('execution.input')\n\n# Set the seed to the submission ID by default?\nfrom pedal.questions import set_seed\nset_seed(str(get_model_info(\"submission.id\")))\n\n# Initialize the BlockPy environment\npedal = setup_environment(skip_tifa=".concat(skip_tifa, ",\n                          skip_run=skip_run,\n                          inputs=inputs,\n                          main_file='answer.py',\n                          files=").concat(safeCode, ")\nstudent = pedal.fields['student']\n\n# TODO: Refactor resolver to return instructions\n# Monkey-patch questions\n#from pedal import questions\n#questions.show_question = set_instructions\n\n").concat(INSTRUCTOR_MARKER, "\n").concat(instructorCode, "\n\n# Resolve everything\nfrom pedal.resolvers.simple import resolve\nfinal = resolve()\nSUCCESS = final.success\nSCORE = final.score\nCATEGORY = final.category\nLABEL = final.title\nMESSAGE = final.message\nDATA = final.data\nHIDE = final.hide_correctness\n\n# Handle questions\nif final.instructions:\n    set_instructions(final.instructions[-1].message)\n    \n# Handle positive feedback\nPOSITIVE = []\nfor positive in final.positives:\n    message = positive.message\n    if not positive:\n        message = positive.else_message\n    POSITIVE.append({\n        \"title\": positive.title,\n        \"label\": positive.label,\n        \"message\": message\n    })\n    \n# Handle system messages\nfor system in final.systems:\n    if system.label == 'log':\n        console_log(system.title, system.message);\n    if system.label == 'debug':\n        console_debug(system.title, system.message);\n\n");
};
var OnRunConfiguration = /*#__PURE__*/function (_InstructorConfigurat) {
  _inherits(OnRunConfiguration, _InstructorConfigurat);

  var _super = _createSuper(OnRunConfiguration);

  function OnRunConfiguration() {
    _classCallCheck(this, OnRunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnRunConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnRunConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "_instructor.on_run";
      this.code = this.main.model.assignment.onRun();
      var disableTifa = this.main.model.assignment.settings.disableTifa(); // Put the input index back to the front, so we can replay inputs

      this.main.model.execution.inputIndex(1);
      var report = this.main.model.execution.reports; //let studentCodeSafe = this.main.model.submission.code();

      var studentFiles = this.getAllStudentFiles();
      this.dummyOutSandbox();
      var instructorCode = this.code;
      var isSafe = !report["parser"].empty && report["verifier"].success;
      instructorCode = WRAP_INSTRUCTOR_CODE(studentFiles, instructorCode, disableTifa, isSafe);
      var lineOffset = findActualInstructorOffset(instructorCode); //instructorCode.split(NEW_LINE_REGEX).length;
      //lineOffset = 0; //instructorCode.split(NEW_LINE_REGEX).length - lineOffset - 4;

      report["instructor"] = {
        "compliments": [],
        "filename": "./_instructor/on_run.py",
        "code": instructorCode,
        "lineOffset": lineOffset //'complete': false // Actually, let's use undefined for now.

      };
      this.code = instructorCode;
      Sk.retainGlobals = false;
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      // TODO Logging!!!!
      //console.log("OnRun success");
      // TODO: Actually parse results
      this.main.model.execution.instructor.globals = Sk.globals;
      this.main.model.execution.instructor.sysmodules = Sk.sysmodules;
      Sk.globals = {};
      var results = module.$d.on_run.$d;
      this.main.components.feedback.presentFeedback(results);
      this.main.model.execution.reports["instructor"]["success"] = true;
      var success = Sk.ffi.remapToJs(results.SUCCESS);
      this.main.model.submission.correct(success || this.main.model.submission.correct()); // Cannot exceed 1 point, cannot go below 0 points

      var score = Sk.ffi.remapToJs(results.SCORE);
      score = Math.max(0, Math.min(1, score));
      var oldScore = this.main.model.submission.score();
      score = Math.max(oldScore, score);
      this.main.model.submission.score(score); // Hide status

      var hide = Sk.ffi.remapToJs(results.HIDE); // And fire the result!

      this.main.components.server.updateSubmission(score, success, hide, false);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY); //after(module);

      /*if (success && this.main.model.configuration.callbacks.success) {
          this.main.model.configuration.callbacks.success(this.main.model.assignment.id());
      }*/

      if (!Sk.executionReports.instructor.scrolling) {
        try {
          this.main.components.console.scrollToBottom();
        } catch (e) {}
      }
    }
  }, {
    key: "failure",
    value: function failure(error) {
      console.error("OnRun failure", error);
      var report = this.main.model.execution.reports;

      if (error.tp$name === "GracefulExit") {
        report["instructor"]["success"] = true;
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      } else {
        this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED); //console.log(report["instructor"]["code"]);

        this.main.components.feedback.presentInternalError(error, this.filename); //report["instructor"]["success"] = false;
        //report["instructor"]["error"] = error;
        //TODO: report["instructor"]["line_offset"] = lineOffset;
      } //TODO: after(error);

    }
  }]);

  return OnRunConfiguration;
}(_instructor__WEBPACK_IMPORTED_MODULE_2__["InstructorConfiguration"]);
/*
# The following is the old instructor code, leaving it here for now.

from pedal.core.report import MAIN_REPORT
# Support our sysmodules hack by clearing out any lingering old data
MAIN_REPORT.clear()
from pedal.core.commands import contextualize_report
contextualize_report(${safeCode}, "answer.py")
${tifaAnalysis}
from pedal.sandbox.sandbox import Sandbox
from pedal.sandbox import compatibility
from utility import *
student = MAIN_REPORT['sandbox']['run'] = Sandbox()
student.report_exceptions_mode = True
log(get_model_info('execution.input'))
student.set_input(get_model_info('execution.input'))
if not get_model_info('assignment.settings.disableInstructorRun'):
    compatibility.run_student(raise_exceptions=False)
#log(student.data)
#student = get_student_data()
#error, position = get_student_error()
#compatibility.raise_exception(error, position)
run_student = compatibility.run_student
reset_output = compatibility.reset_output
queue_input = compatibility.queue_input
get_output = compatibility.get_output
get_plots = compatibility.get_plots
compatibility.trace_lines = trace_lines
from pedal import questions
questions.show_question = set_instructions
# TODO: Remove the need for this hack!
def capture_output(func, *args):
   reset_output()
   student.call(func.__name__, *args)
   return get_output()
compatibility.capture_output = capture_output

from pedal.cait.cait_api import parse_program
${instructorCode}
from pedal.resolvers import simple
final = simple.resolve()
SUCCESS = final.success
SCORE = final.score
CATEGORY = final.category
LABEL = final.title
MESSAGE = final.message
DATA = final.data
HIDE = final.hide_correctness

 */

/***/ }),

/***/ "./src/engine/on_sample.js":
/*!*********************************!*\
  !*** ./src/engine/on_sample.js ***!
  \*********************************/
/*! exports provided: OnSampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OnSampleConfiguration", function() { return OnSampleConfiguration; });
/* harmony import */ var _on_run__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./on_run */ "./src/engine/on_run.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var OnSampleConfiguration = /*#__PURE__*/function (_OnRunConfiguration) {
  _inherits(OnSampleConfiguration, _OnRunConfiguration);

  var _super = _createSuper(OnSampleConfiguration);

  function OnSampleConfiguration() {
    _classCallCheck(this, OnSampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(OnSampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(OnSampleConfiguration.prototype), "use", this).call(this, engine);

      this.filename = "on_run.py";
      this.code = this.main.model.assignment.onRun();
      return this;
    }
  }]);

  return OnSampleConfiguration;
}(_on_run__WEBPACK_IMPORTED_MODULE_0__["OnRunConfiguration"]);

/***/ }),

/***/ "./src/engine/run.js":
/*!***************************!*\
  !*** ./src/engine/run.js ***!
  \***************************/
/*! exports provided: RunConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RunConfiguration", function() { return RunConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server */ "./src/server.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var RunConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(RunConfiguration, _StudentConfiguration);

  var _super = _createSuper(RunConfiguration);

  function RunConfiguration() {
    _classCallCheck(this, RunConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(RunConfiguration, [{
    key: "use",
    value: function use(engine) {
      this.main.model.execution.feedback.message("Running...");
      this.filename = "answer";
      this.code = this.main.model.ui.files.getStudentCode();

      if (this.main.model.assignment.settings.disableStudentRun()) {
        this.code = "";
      } //this.code = this.main.model.submission.code();


      this.main.components.server.saveFile("answer.py", this.main.model.submission.code(), null);
      this.main.components.server.logEvent("Compile", "", "", "", "answer.py"); //console.log(this.code);

      _get(_getPrototypeOf(RunConfiguration.prototype), "use", this).call(this, engine);

      engine.reset();
      this.updateParse();
      this.main.model.execution.reports["verifier"] = {
        "success": Boolean(this.code.trim()),
        "code": this.code
      };
      Sk.retainGlobals = false;
      this.clearInput();
      return this;
    }
  }, {
    key: "success",
    value: function success(module) {
      var _this = this;

      console.log("Run success");
      var message = {
        "inputs": this.main.model.execution.input().join("\n"),
        "outputs": this.main.model.execution.output().map(function (line) {
          return line.content;
        }).join("\n")
      };
      this.main.components.server.logEvent("Run.Program", "", "", JSON.stringify(message), "answer.py");
      this.main.model.display.dirtySubmission(false);
      this.main.components.console.finishTurtles();
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].READY);
      this.main.model.execution.student.globals(Sk.globals);
      Sk.globals = {};
      var report = this.main.model.execution.reports;
      var filename = this.filename;
      this.main.model.execution.student.results = module;

      if (!this.main.model.assignment.settings.hideEvaluate()) {
        this.main.components.console.beginEval();
      }

      return new Promise(function (resolve, reject) {
        _this.step(module.$d, module.$d, -1, 0, filename + ".py");

        _this.lastStep();

        report["student"] = {
          "success": true,
          "trace": _this.engine.executionBuffer.trace,
          "lines": _this.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "results": module,
          "output": _this.main.model.execution.output,
          "input": _this.main.model.execution.input,
          "calls": _this.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }, {
    key: "failure",
    value: function failure(error) {
      var _this2 = this;

      console.error("Run failure", error);
      this.main.model.status.onExecution(_server__WEBPACK_IMPORTED_MODULE_1__["StatusState"].FAILED);
      var report = this.main.model.execution.reports;

      if (report.parser.success && report.verifier.success) {
        this.main.components.server.logEvent("Compile.Error", "", "", error.toString(), "answer.py");
      } else {
        this.main.components.server.logEvent("Run.Program", "ProgramErrorOutput", "", error.toString(), "answer.py");
      }

      return new Promise(function (resolve, reject) {
        report["student"] = {
          "success": false,
          "error": error,
          "lines": _this2.engine.executionBuffer.trace.map(function (x) {
            return x.line;
          }),
          "realLines": _this2.engine.executionBuffer.trace.filter(function (x) {
            return !x.isDocstring;
          }).map(function (x) {
            return x.line;
          }),
          "input": _this2.main.model.execution.input,
          "calls": _this2.main.model.execution.student.calls,
          "tracing": []
        };
        resolve();
      });
    }
  }]);

  return RunConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/sample.js":
/*!******************************!*\
  !*** ./src/engine/sample.js ***!
  \******************************/
/*! exports provided: SampleConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SampleConfiguration", function() { return SampleConfiguration; });
/* harmony import */ var _student__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./student */ "./src/engine/student.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var SampleConfiguration = /*#__PURE__*/function (_StudentConfiguration) {
  _inherits(SampleConfiguration, _StudentConfiguration);

  var _super = _createSuper(SampleConfiguration);

  function SampleConfiguration() {
    _classCallCheck(this, SampleConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(SampleConfiguration, [{
    key: "use",
    value: function use(engine) {
      _get(_getPrototypeOf(SampleConfiguration.prototype), "use", this).call(this, engine); // TODO: Fix to be the current sample submission


      this.filename = "answer.py";
      this.code = "print('Not ready yet!')";
      return this;
    }
  }]);

  return SampleConfiguration;
}(_student__WEBPACK_IMPORTED_MODULE_0__["StudentConfiguration"]);

/***/ }),

/***/ "./src/engine/student.js":
/*!*******************************!*\
  !*** ./src/engine/student.js ***!
  \*******************************/
/*! exports provided: StudentConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StudentConfiguration", function() { return StudentConfiguration; });
/* harmony import */ var _configurations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configurations */ "./src/engine/configurations.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var StudentConfiguration = /*#__PURE__*/function (_Configuration) {
  _inherits(StudentConfiguration, _Configuration);

  var _super = _createSuper(StudentConfiguration);

  function StudentConfiguration() {
    _classCallCheck(this, StudentConfiguration);

    return _super.apply(this, arguments);
  }

  _createClass(StudentConfiguration, [{
    key: "use",
    value: function use(engine) {
      var _this = this;

      _get(_getPrototypeOf(StudentConfiguration.prototype), "use", this).call(this, engine); // Limit execution to 4 seconds


      var settings = this.main.model.settings;

      Sk.execLimitFunction = function () {
        return _this.main.model.assignment.settings.disableTimeout() ? Infinity : 5000;
      };

      Sk.execLimit = Sk.execLimitFunction(); // Stepper! Executed after every statement.

      Sk.afterSingleExecution = this.step.bind(this); // Unmute everything

      this.main.model.display.mutePrinter(false); // Function to call after each step
      // afterSingleExecution

      Sk.builtinFiles.files["src/lib/utility/__init__.js"] = _configurations__WEBPACK_IMPORTED_MODULE_0__["EMPTY_MODULE"];
      return this;
    }
  }, {
    key: "openFile",
    value: function openFile(filename) {
      var found = this.main.components.fileSystem.searchForFile(filename, true); //console.log(filename, found);

      if (found === undefined) {
        if (Sk.builtinFiles && Sk.builtinFiles["files"][filename] !== undefined) {
          return Sk.builtinFiles["files"][filename];
        } else {
          throw new Sk.builtin.OSError("File not found: " + filename);
        }
      } else {
        return found.contents();
      }
    }
  }, {
    key: "importFile",
    value: function importFile(filename) {
      if (this.isForbidden(filename)) {
        throw "File not accessible: '" + filename + "'";
      } else if (filename === "./answer.py") {
        return this.main.model.submission.code();
      } else if (Sk.builtinFiles === undefined) {
        throw new Sk.builtin.OSError("Built-in modules not accessible.");
      } else if (Sk.builtinFiles["files"][filename] !== undefined) {
        return Sk.builtinFiles["files"][filename];
      } else {
        var found = this.main.components.fileSystem.searchForFile(filename, true);

        if (found === undefined) {
          throw new Sk.builtin.OSError("File not found: '" + filename + "'");
        } else {
          return found.contents();
        }
      }
    }
  }, {
    key: "input",
    value: function input(promptMessage) {
      return this.main.components.console.input(promptMessage);
    }
  }, {
    key: "isForbidden",
    value: function isForbidden(filename) {
      return filename.startsWith("src/lib/utility/") || filename.startsWith("src/lib/pedal/") || filename.startsWith("./_instructor/");
    }
    /**
     * "Steps" the execution of the code, meant to be used as a callback to the Skulpt
     * environment.
     *
     * @param {Object} globals - Hash that maps the names of global variables (Strings) to their Skulpt representation.
     * @param {Object} locals - Hash that maps the names of local variables (Strings) to their Skulpt representation.
     * @param {Number} lineNumber - The corresponding line number in the source code that is being executed.
     * @param {Number} columnNumber - The corresponding column number in the source code that is being executed.
     *                                Think of it as the "X" position to the lineNumber's "Y" position.
     * @param {String} filename - The name of the python file being executed (e.g., "__main__.py").
     * @param {Boolean} isDocstring - Whether or not this is an actual line or a docstring.
     */

  }, {
    key: "step",
    value: function step(globals, locals, lineNumber, columnNumber, filename, isDocstring, execStack) {
      if (filename === "answer.py") {
        if (execStack) {
          console.log(execStack.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                n = _ref2[0],
                o = _ref2[1];

            return [n, _objectSpread({}, o)];
          }));
        }

        var currentStep = this.engine.executionBuffer.step;
        globals = this.main.components.trace.parseGlobals(_objectSpread(_objectSpread({}, globals), locals)); // TODO: Trace local variables properly
        //let locals = this.main.components.trace.parseGlobals(locals);
        //Object.assign(globals, locals);

        this.engine.executionBuffer.trace.push({
          "step": currentStep,
          "filename": filename,
          //'block': highlightMap[lineNumber-1],
          "line": lineNumber,
          "column": columnNumber,
          "properties": globals.properties,
          "modules": globals.modules,
          "isDocstring": isDocstring
        });
        this.engine.executionBuffer.step = currentStep + 1;
        this.engine.executionBuffer.line = lineNumber;
      }
    }
  }, {
    key: "lastStep",

    /**
     * Called at the end of the Skulpt execution to terminate the executionBuffer
     * and hand it off to the execution trace in the model.
     */
    value: function lastStep() {
      var execution = this.main.model.execution;
      execution.student.currentTraceData(this.engine.executionBuffer.trace);
      execution.student.currentStep(this.engine.executionBuffer.step);
      execution.student.lastStep(this.engine.executionBuffer.step);
      execution.student.currentLine(this.engine.executionBuffer.line);
      execution.student.lastLine(this.engine.executionBuffer.line);
      execution.student.currentTraceStep(this.engine.executionBuffer.step);
    }
  }, {
    key: "getLines",
    value: function getLines(ast) {
      var visitedLines = new Set();

      var visitBody = function visitBody(node) {
        if (node.lineno !== undefined) {
          visitedLines.add(node.lineno);
        }

        if (node.body) {
          node.body.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.orelse) {
          node.orelse.forEach(function (statement) {
            return visitBody(statement);
          });
        }

        if (node.finalbody) {
          node.finalbody.forEach(function (statement) {
            return visitBody(statement);
          });
        }
      };

      visitBody(ast);
      return Array.from(visitedLines);
    }
    /**
     * Ensure that the parse information is up-to-date
     */

  }, {
    key: "updateParse",
    value: function updateParse() {
      var report = this.main.model.execution.reports; // Hold all the actually discovered lines from the parse

      var lines = []; // Attempt a parse

      var ast;

      try {
        var parse = Sk.parse(this.filename, this.code);
        ast = Sk.astFromParse(parse.cst, this.filename, parse.flags);
        lines = this.getLines(ast);
      } catch (error) {
        // Report the error
        report["parser"] = {
          "success": false,
          "error": error,
          "empty": true,
          "lines": lines
        };
        console.error(error);
        console.log(this.filename, this.code);
        return false;
      } // Successful parse


      report["parser"] = {
        "success": true,
        "ast": ast,
        "empty": ast.body.length === 0,
        "lines": lines
      };
      return true;
    }
  }, {
    key: "showErrors",
    value: function showErrors() {
      var report = this.main.model.execution.reports;

      if (report["student"].success) {
        this.main.components.feedback.clear();
      } else {
        this.main.components.feedback.presentRunError(report.student.error);
      }
    }
  }, {
    key: "provideSecretError",
    value: function provideSecretError() {
      var _this2 = this;

      var report = this.main.model.execution.reports;
      var feedback = this.main.components.feedback;

      if (!report["student"].success) {
        var errorButton = this.main.model.configuration.container.find(".blockpy-student-error");
        var message = feedback.presentRunError(report.student.error, true);
        errorButton.attr("title", "Click to see Original Error");
        errorButton.tooltip({
          "trigger": "hover",
          "container": this.main.model.configuration.attachmentPoint
        });
        errorButton.click(function () {
          return _this2.main.components.dialog.ERROR_SHOW_STUDENT_ERROR(message);
        });
        errorButton.show();
      }
    }
  }]);

  return StudentConfiguration;
}(_configurations__WEBPACK_IMPORTED_MODULE_0__["Configuration"]);

/***/ }),

/***/ "./src/feedback.js":
/*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
/*! exports provided: FEEDBACK_HTML, BlockPyFeedback */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEEDBACK_HTML", function() { return FEEDBACK_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFeedback", function() { return BlockPyFeedback; });
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FEEDBACK_HTML = "\n\n<span class='blockpy-floating-feedback text-muted-less pull-right position-sticky sticky-top'\n    aria-hidden=\"true\" role=\"presentation\" aria-label=\"New Feedback Alert\">\n    New feedback &uarr;\n</span>\n\n<div class='blockpy-feedback blockpy-panel'\n            role=\"region\" aria-label=\"Feedback\"\n            aria-live=\"polite\"\n            data-bind=\"class: ui.console.size\">\n\n    <!-- Feedback/Trace Visibility Control -->\n    <!-- ko ifnot: ui.secondRow.hideTraceButton -->\n    <button type='button'\n            class='btn btn-sm btn-outline-secondary float-right'\n            data-bind=\"click: ui.secondRow.advanceState\">\n        <span class='fas fa-eye'></span>\n        <span data-bind=\"text: ui.secondRow.switchLabel\"></span>\n    </button>\n    <!-- /ko -->\n    \n    <!-- Positive Feedback Region -->\n    <div class=\"blockpy-feedback-positive float-right\">\n        \n    \n    </div>\n\n    <!-- Actual Feedback Region -->    \n    <div>\n        <strong>Feedback: </strong>\n        <span class='badge blockpy-feedback-category feedback-badge'\n            data-bind=\"css: ui.feedback.badge,\n                       text: ui.feedback.category\">Feedback Kind</span>\n        <small data-bind=\"text: (100*submission.score())+'%',\n                          visible: display.instructor() && execution.feedback.label()\"\n            class=\"text-muted\"></small>\n    </div>\n    <div>\n        <strong class=\"blockpy-feedback-label\"\n            data-bind=\"text: execution.feedback.label\"></strong>\n        <div class=\"blockpy-feedback-message\"\n            data-bind=\"html: execution.feedback.message\"></div>\n    </div>\n</div>            \n";
var BlockPyFeedback = /*#__PURE__*/function () {
  /**
   * An object that manages the feedback area, where users are told the state of their
   * program's execution and given guidance. Also manages the creation of the Trace Table.
   *
   * @constructor
   * @this {BlockPyFeedback}
   * @param {Object} main - The main BlockPy instance
   * @param {HTMLElement} tag - The HTML object this is attached to.
   */
  function BlockPyFeedback(main, tag) {
    var _this = this;

    _classCallCheck(this, BlockPyFeedback);

    this.main = main;
    this.tag = tag;
    this.feedbackModel = this.main.model.execution.feedback;
    this.category = this.tag.find(".blockpy-feedback-category");
    this.label = this.tag.find(".blockpy-feedback-label");
    this.message = this.tag.find(".blockpy-feedback-message");
    this.positive = this.tag.find(".blockpy-feedback-positive"); // TODO: If they change the student extra files, also update the dirty flag

    this.main.model.submission.code.subscribe(function () {
      return _this.main.model.display.dirtySubmission(true);
    });
  }

  _createClass(BlockPyFeedback, [{
    key: "scrollIntoView",

    /**
     * Moves the screen (takes 1 second) to make the Feedback area visible.
     */
    value: function scrollIntoView() {
      $("html, body").animate({
        scrollTop: this.tag.offset().top
      }, 700);
    }
  }, {
    key: "isFeedbackVisible",

    /**
     * Determines if the feedback area is currently visible
     * @returns {boolean}
     */
    value: function isFeedbackVisible() {
      var visibilityBuffer = 100;
      var topOfElement = this.tag.offset().top; //let bottomOfElement = this.tag.offset().top + this.tag.outerHeight();

      var bottomOfElement = topOfElement + visibilityBuffer;
      var bottomOfScreen = $(window).scrollTop() + $(window).height();
      var topOfScreen = $(window).scrollTop(); //bottom_of_element -= 40; // User friendly padding

      return topOfElement < bottomOfScreen && topOfScreen < bottomOfElement;
    }
  }, {
    key: "clear",

    /**
     * Clears any output currently in the feedback area. Also resets the printer and
     * any highlighted lines in the editor.
     */
    value: function clear() {
      this.feedbackModel.message("*Ready*");
      this.feedbackModel.category(null);
      this.feedbackModel.label(null);
      this.feedbackModel.hidden(false);
      this.feedbackModel.linesError.removeAll();
      this.feedbackModel.linesUncovered.removeAll();
      this.clearPositiveFeedback();
    }
  }, {
    key: "updateRegularFeedback",
    value: function updateRegularFeedback() {}
    /**
     * Updates the model with these new execution results
     * @param executionResults
     */

  }, {
    key: "updateFeedback",
    value: function updateFeedback(executionResults) {
      var _this2 = this;

      // Parse out data
      var message = Sk.ffi.remapToJs(executionResults.MESSAGE);
      var category = Sk.ffi.remapToJs(executionResults.CATEGORY);
      var label = Sk.ffi.remapToJs(executionResults.LABEL);
      var hide = Sk.ffi.remapToJs(executionResults.HIDE);
      var data = executionResults.DATA;
      var positives = Sk.ffi.remapToJs(executionResults.POSITIVE); // Override based on assignments' settings

      var hideScore = this.main.model.assignment.hidden();

      if (hideScore && category.toLowerCase() === "complete") {
        category = "no errors";
        label = "No errors";
        message = "No errors reported.";
      } // Remap to expected BlockPy labels


      if (category.toLowerCase() === "instructor" && label.toLowerCase() === "explain") {
        label = "Instructor Feedback";
      } // Don't present a lack of error as being incorrect


      if (category === "Instructor" && label === "No errors") {
        category = "no errors";
      } // Update model accordingly


      message = this.main.utilities.markdown(message).replace(/<pre>\n/g, "<pre>\n\n");
      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label); //let highlightTimeout = setTimeout(() => {

      this.message.find("pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      }); //}, 400);
      // TODO: Instead of tracking student file, let's track the instructor file

      this.main.components.server.logEvent("Intervention", category, label, message, "answer.py"); // Clear out any previously highlighted lines

      this.main.components.pythonEditor.bm.clearHighlightedLines(); // Find the first error on a line and report that

      var line = BlockPyFeedback.findFirstErrorLine(data);
      this.feedbackModel.linesError.removeAll();

      if (line !== null && line !== undefined) {
        this.feedbackModel.linesError.push(line);
      } // Invert the set of traced lines


      var studentReport = this.main.model.execution.reports.student;
      this.feedbackModel.linesUncovered.removeAll();

      if (studentReport.success) {
        var uncoveredLines = [];
        this.main.model.execution.reports.parser.lines.forEach(function (line) {
          if (studentReport.lines.indexOf(line) === -1) {
            uncoveredLines.push(line);
          }
        });
        this.feedbackModel.linesUncovered(uncoveredLines);
      }

      var _loop = function _loop(i) {
        var positiveData = positives[i];

        _this2.addPositiveFeedback(positiveData.message, "star", "green", function () {
          return _this2.main.components.dialog.POSITIVE_FEEDBACK_FULL(positiveData.title, positiveData.message);
        });
      };

      for (var i = 0; i < positives.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "clearPositiveFeedback",
    value: function clearPositiveFeedback() {
      this.positive.empty();
      this.main.model.configuration.container.find(".blockpy-student-error").hide();
    }
  }, {
    key: "addPositiveFeedback",
    value: function addPositiveFeedback(text, icon, color, onclick, toEnd) {
      var _this3 = this;

      var positive = $("<span></span>");
      positive.addClass("blockpy-feedback-positive-icon fas fa-" + icon);
      positive.css("color", color);
      positive.attr("title", text);

      if (toEnd) {
        this.positive.append(positive);
      } else {
        this.positive.prepend(positive);
      }

      positive.tooltip({
        "trigger": "hover",
        "container": this.main.model.configuration.attachmentPoint
      });

      if (onclick !== undefined) {
        positive.click(onclick);
      }

      positive.hover(function () {
        _this3.main.components.server.logEvent("X-Feedback", "positive", "hover", text, "");
      });
    }
    /**
     * Present any accumulated feedback
     */

  }, {
    key: "presentFeedback",
    value: function presentFeedback(executionResults) {
      this.updateFeedback(executionResults); // TODO: Logging
      //this.main.components.server.logEvent("feedback", category+"|"+label, message);

      this.notifyFeedbackUpdate();
    }
  }, {
    key: "notifyFeedbackUpdate",
    value: function notifyFeedbackUpdate() {
      if (!this.isFeedbackVisible()) {
        this.tag.find(".blockpy-floating-feedback").show().fadeOut(7000);
        this.scrollIntoView();
      }
    }
  }, {
    key: "presentRunError",
    value: function presentRunError(error, just_return) {
      if (just_return === undefined) {
        just_return = false;
      }

      var message, label, category, lineno;
      label = error.tp$name;
      category = "runtime";
      message = this.convertSkulptError(error);

      if (just_return) {
        return message;
      }

      this.feedbackModel.message(message);
      this.feedbackModel.category(category);
      this.feedbackModel.label(label);
      this.feedbackModel.linesError.removeAll();

      if (lineno !== undefined && lineno !== null) {
        this.feedbackModel.linesError.push(lineno);
      }
    }
  }, {
    key: "buildTraceback",
    value: function buildTraceback(error, filenameExecuted) {
      var _this4 = this;

      return error.traceback.map(function (frame) {
        var lineno = frame.lineno;

        if (frame.filename.slice(0, -3) === filenameExecuted) {
          lineno -= _this4.main.model.execution.reports.instructor.lineOffset;
        }

        var file = "File <code class=\"filename\">\"".concat(frame.filename, "\"</code>, ");
        var line = "on line <code class=\"lineno\">".concat(lineno, "</code>, ");
        var scope = frame.scope !== "<module>" && frame.scope !== undefined ? "in scope ".concat(frame.scope) : "";
        var source = "";

        if (frame.source !== undefined) {
          source = "\n<pre><code>".concat(frame.source, "</code></pre>");
        }

        return file + line + scope + source;
      });
    }
  }, {
    key: "convertSkulptError",
    value: function convertSkulptError(error, filenameExecuted, isInstructor) {
      var name = error.tp$name;
      var args = Sk.ffi.remapToJs(error.args);
      var top = "".concat(name, ": ").concat(args[0], "\n<br>\n<br>");
      var traceback = "";

      if (name === "TimeoutError") {
        if (error.err && error.err.traceback && error.err.traceback.length) {
          var allFrames = this.buildTraceback(error.err, filenameExecuted);
          var result = ["Traceback:"];

          if (allFrames.length > 5) {
            result.push.apply(result, _toConsumableArray(allFrames.slice(0, 3)).concat(["... Hiding ".concat(allFrames.length - 3, " other stack frames ...,")], _toConsumableArray(allFrames.slice(-3, -2))));
          } else {
            result.push.apply(result, _toConsumableArray(allFrames));
          }

          traceback = result.join("\n<br>");
        }
      } else {
        if (isInstructor) {
          top = "Error in instructor feedback. Please show the following to an instructor:<br>\n" + top;
        }

        if (error.traceback && error.traceback.length) {
          traceback = "Traceback:<br>\n" + this.buildTraceback(error, filenameExecuted).join("\n<br>");
        }
      }

      return top + "\n" + traceback;
    }
  }, {
    key: "presentInternalError",
    value: function presentInternalError(error, filenameExecuted) {
      if (error.tp$name === "TimeoutError") {
        this.main.model.execution.feedback.category("runtime");
        this.main.model.execution.feedback.label("Timeout Error");
      } else {
        this.main.model.execution.feedback.category("internal");
        this.main.model.execution.feedback.label("Internal Error");
      }

      var message = this.convertSkulptError(error, filenameExecuted, true);
      this.main.model.execution.feedback.message(message);
      this.notifyFeedbackUpdate();
      this.main.components.server.logEvent("X-System.Error", "internal", "Internal Error", message, filenameExecuted);
    }
  }], [{
    key: "findFirstErrorLine",
    value: function findFirstErrorLine(feedbackData) {
      if (feedbackData.quick$lookup) {
        var location = feedbackData.quick$lookup(new Sk.builtin.str("location"));

        if (location) {
          var line = location.tp$getattr(new Sk.builtin.str("line"));

          if (line) {
            return Sk.ffi.remapToJs(line);
          }
        }
      }

      return null;
      /*for (let i = feedbackData.length-1; i >= 0; i-= 1) {
          if ("position" in feedbackData[i]) {
              return feedbackData[i].position.line;
          }
      }
      return null;*/
    }
  }]);

  return BlockPyFeedback;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/files.js":
/*!**********************!*\
  !*** ./src/files.js ***!
  \**********************/
/*! exports provided: FILES_HTML, STARTING_FILES, BASIC_NEW_FILES, chompSpecialFile, UNDELETABLE_FILES, UNRENAMABLE_FILES, makeModelFile, loadConcatenatedFile, createConcatenatedFile, observeConcatenatedFile, BlockPyFileSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(ko, $) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILES_HTML", function() { return FILES_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING_FILES", function() { return STARTING_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIC_NEW_FILES", function() { return BASIC_NEW_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chompSpecialFile", function() { return chompSpecialFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDELETABLE_FILES", function() { return UNDELETABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNRENAMABLE_FILES", function() { return UNRENAMABLE_FILES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeModelFile", function() { return makeModelFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadConcatenatedFile", function() { return loadConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConcatenatedFile", function() { return createConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observeConcatenatedFile", function() { return observeConcatenatedFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyFileSystem", function() { return BlockPyFileSystem; });
/* harmony import */ var utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! utilities.js */ "./src/utilities.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // ${makeTab("?mock_urls.blockpy", "URL Data", true)}

var makeTab = function makeTab(filename, friendlyName, hideIfEmpty, notInstructor) {
  if (friendlyName === undefined) {
    friendlyName = filename;
  }

  var instructorFileClass = "";
  var hideIfNotInstructor = "true";

  if (!notInstructor) {
    instructorFileClass = "blockpy-file-instructor";
    hideIfNotInstructor = "display.instructor()";
  }

  return "\n    <li class=\"nav-item ".concat(instructorFileClass, "\">\n        <a class=\"nav-link\" href=\"#\"\n            data-toggle=\"tab\"\n            data-bind=\"css: {active: display.filename() === '").concat(filename, "'},\n                click: display.filename.bind($data, '").concat(filename, "'),\n                visible: (!").concat(hideIfEmpty, " || ui.files.hasContents('").concat(filename, "')) && ").concat(hideIfNotInstructor, "\">\n            ").concat(friendlyName, "</a>\n    </li>");
};

var FILES_HTML = "\n<div class=\"blockpy-panel blockpy-files\"\n    data-bind=\"visible: ui.files.visible, class: ui.files.width\">\n<ul class=\"nav nav-tabs\" role=\"tablist\">\n\n    <li class=\"nav-item\">\n        <strong>View: </strong>\n    </li>\n\n    ".concat(makeTab("answer.py", undefined, undefined, true), "\n    ").concat(makeTab("!instructions.md", "Instructions"), "\n    ").concat(makeTab("!assignment_settings.blockpy", "Settings"), "\n    ").concat(makeTab("^starting_code.py", "Starting Code"), "\n    ").concat(makeTab("!on_run.py", "On Run"), "\n    ").concat(makeTab("!on_change.py", "On Change", true), "\n    ").concat(makeTab("!on_eval.py", "On Eval", true), "\n    ").concat(makeTab("!sample_submissions.blockpy", "Sample Submissions", true), "\n    ").concat(makeTab("!tags.blockpy", "Tags", true), "\n    \n    <!-- ko foreach: assignment.extraInstructorFiles -->\n        <li class=\"nav-item\"\n            data-bind=\"css: {'blockpy-file-instructor': !filename().startsWith('&')},\n                       visible: filename().startsWith('&') || $root.display.instructor() \">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename(),\n                                 uneditable: filename().startsWith('&')},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    <!-- ko foreach: assignment.extraStartingFiles -->\n        <li class=\"nav-item blockpy-file-instructor\"\n            data-bind=\"visible: $root.display.instructor()\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: filename\">\n            </a>        \n        </li>\n    <!-- /ko -->\n    \n    <!-- ko foreach: submission.extraFiles -->\n        <li class=\"nav-item\">\n            <a class=\"nav-link\" href=\"#\"\n                data-toggle=\"tab\"\n                data-bind=\"css: {active: $root.display.filename() === filename()},\n                            click: $root.display.filename.bind($data, filename()),\n                            text: $root.ui.files.displayFilename(filename())\">\n            </a>        \n        </li>\n    <!-- /ko -->\n  \n    <li class=\"nav-item dropdown\">\n        <a class=\"nav-link dropdown-toggle\" href=\"#\" data-toggle=\"dropdown\"\n         role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">Add New</a>\n        <div class=\"dropdown-menu dropdown-menu-right\">\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?mock_urls.blockpy'),\n                           click: ui.files.add.bind($data, '?mock_urls.blockpy')\">URL Data</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?images.blockpy'),\n                           click: ui.files.add.bind($data, '?images.blockpy')\">Images</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('?toolbox.blockpy'),\n                           click: ui.files.add.bind($data, '?toolbox.blockpy')\">Toolbox</a>\n            \n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!tags.blockpy')\">Tags</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!sample_submissions.blockpy'),\n                           click: ui.files.add.bind($data, '!sample_submissions.blockpy')\">Sample Submissions</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onChange,\n                           click: ui.files.add.bind($data, '!on_change.py')\">On Change</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: assignment.onEval,\n                           click: ui.files.add.bind($data, '!on_eval.py')\">On Eval</a>\n            <div class=\"dropdown-divider\"></div>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_prefix.py'),\n                           click: ui.files.add.bind($data, '!answer_prefix.py')\">Answer Prefix</a>\n           <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"hidden: ui.files.hasContents('!answer_suffix.py'),\n                           click: ui.files.add.bind($data, '!answer_suffix.py')\">Answer Suffix</a>\n            <div class=\"dropdown-divider\"></div>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'starting')\">Starting File</a>\n            <a class=\"dropdown-item blockpy-file-instructor\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'instructor')\">Instructor File</a>\n            <a class=\"dropdown-item\" href=\"#\"\n                data-bind=\"click: ui.files.add.bind($data, 'student')\">Student File</a>\n        </div>\n    </li>\n  \n</ul>\n</div>\n");
var NEW_INSTRUCTOR_FILE_DIALOG_HTML = "\n<form>\n<div class=\"form-group row\">\n    <!-- Filename -->\n    <div class=\"col-sm-2 text-right\">\n        <label for=\"blockpy-instructor-file-dialog-filename\">Filename:</label>\n    </div>\n    <div class=\"col-sm-10\">\n        <input type=\"text\" class=\"form-control blockpy-instructor-file-dialog-filename\"\n            id=\"blockpy-instructor-file-dialog-filename\">    \n    </div>\n    <!-- Filetype -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-filetype\">Filetype: </label>\n    </div>\n    <div class=\"col-sm-10\">\n        <span class=\"blockpy-instructor-file-dialog-filetype\"\n            id=\"blockpy-instructor-file-dialog-filetype\"></span>    \n    </div>\n    <!-- Inaccessible to student? -->\n    <div class=\"col-sm-2 text-right mt-2\">\n        <label for=\"blockpy-instructor-file-dialog-namespace\">Namespace: </label>\n    </div>\n    <div class=\"col-sm-4\">\n        <select class=\"form-control blockpy-instructor-file-dialog-namespace\"\n            id=\"blockpy-instructor-file-dialog-namespace\">\n            <option value=\"!\">Completely inaccessible</option>\n            <option value=\"?\">Hidden from student, accessible programatically</option>\n            <option value=\"&\">Visible to student, but not editable</option>\n        </select>\n    </div>\n</div>\n</form>\n";
/**
 * Filenames live in one of five possible namespaces:
 *  Instructor (!): Invisible to the student under all circumstances
 *  Start Space (^): Used to reset the student namespace
 *  Student Space (): Visible to the student when display.hideFiles is not true, able to be edited
 *  Hidden Space (?): Not directly visible to the student, but accessible programmatically
 *  Read-only Space (&): An instructor file type visible to the student, but is uneditable by them
 *  Secret Space ($): Not visible from the menu at all, some other mechanism controls it
 *  Generated Space (*): Visible to the student, but destroyed after Engine.Clear. Can shadow an actual file.
 *  Concatenated Space (#): Used when bundling a space for the server.
 */

var STARTING_FILES = [// Submission
"answer.py", // Instructor files
"!instructions.md", "!assignment_settings.blockpy", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var BASIC_NEW_FILES = ["!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];
function chompSpecialFile(filename) {
  if ("!^?&$*#".includes(filename[0])) {
    return filename.slice(1);
  } else {
    return filename;
  }
}
var INSTRUCTOR_DIRECTORY = "_instructor/";
var STUDENT_DIRECTORY = "_student/";
var SearchModes = {
  EVERYWHERE: "EVERYWHERE",
  START_WITH_INSTRUCTOR: "START_WITH_INSTRUCTOR",
  ONLY_STUDENT_FILES: "ONLY_STUDENT_FILES"
};
var DELETABLE_SIMPLE_FILES = ["!on_change.py", "!on_eval.py"];
var UNDELETABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy"];
var UNRENAMABLE_FILES = ["answer.py", "!instructions.md", "!assignment_settings.py", "^starting_code.py", "!on_run.py", "$settings.blockpy", "!on_change.py", "!on_eval.py", "?mock_urls.blockpy", "?toolbox.blockpy", "!tags.blockpy", "!sample_submissions.blockpy", "!answer_prefix.py", "!answer_suffix.py"];

var BlockPyFile = function BlockPyFile(main, filename, contents) {
  _classCallCheck(this, BlockPyFile);

  this.main = main;
  this.filename = filename;
  this.contents = contents || "";
  this.owner = null;
  this.handle = null;
};

function makeModelFile(filename, contents) {
  return {
    "filename": ko.observable(filename),
    contents: ko.observable(contents || "")
  };
}

function makeMockModelFile(filename, _contents) {
  return {
    filename: function (_filename) {
      function filename() {
        return _filename.apply(this, arguments);
      }

      filename.toString = function () {
        return _filename.toString();
      };

      return filename;
    }(function () {
      return filename;
    }),
    contents: function contents() {
      return _contents;
    }
  };
}

function loadConcatenatedFile(concatenatedFile, modelFileList) {
  if (concatenatedFile) {
    var files = JSON.parse(concatenatedFile);
    var modelFiles = [];

    for (var _filename2 in files) {
      if (files.hasOwnProperty(_filename2)) {
        modelFiles.push(makeModelFile(_filename2, files[_filename2]));
      }
    } //files = files.map(file => makeModelFile(file.filename, file.contents));


    if (modelFileList) {
      modelFileList(modelFiles);
    } else {
      return modelFiles;
    }
  } else {
    if (modelFileList) {
      modelFileList([]);
    } else {
      return [];
    }
  }
}
function createConcatenatedFile(modelFileList) {
  return JSON.stringify(modelFileList().map(function (file) {
    return {
      filename: file.filename(),
      contents: file.contents()
    };
  }));
}
function observeConcatenatedFile(modelFileList) {
  return ko.pureComputed(function () {
    var result = {};
    modelFileList().forEach(function (file) {
      return result[file.filename()] = file.contents();
    });
    return JSON.stringify(result);
  });
}
/**
 * Abstracts away database logic
 */

var BlockPyFileSystem = /*#__PURE__*/function () {
  function BlockPyFileSystem(main) {
    _classCallCheck(this, BlockPyFileSystem);

    this.main = main;
    this.files_ = {};
    this.mountFiles();
    this.watchModel();
    this.watches_ = {};
    this.main.model.display.instructor.subscribe(function (visiblity) {
      $(".blockpy-file-instructor").toggle(visiblity);
    });
  }

  _createClass(BlockPyFileSystem, [{
    key: "watchFile",
    value: function watchFile(filename, callback) {
      if (!(filename in this.watches_)) {
        this.watches_[filename] = [];
      }

      this.watches_[filename].push(callback);
    }
  }, {
    key: "stopWatchingFile",
    value: function stopWatchingFile(filename) {
      delete this.watches_[filename];
    }
  }, {
    key: "watchModel",
    value: function watchModel() {
      var _this = this;

      var filesystem = this;
      [this.main.model.submission.extraFiles, this.main.model.assignment.extraStartingFiles, this.main.model.assignment.extraInstructorFiles].forEach(function (fileArray) {
        return fileArray.subscribe(function (changes) {
          changes.sort(function (first, second) {
            return second.status.localeCompare(first.status);
          }).forEach(function (change) {
            var modelFile = change.value;

            if (change.status === "added") {
              // Track new file
              var file = filesystem.newFile(modelFile.filename(), modelFile.contents(), modelFile.contents);
              filesystem.notifyWatches(file);
            } else if (change.status === "deleted") {
              // Delete file
              var _file = filesystem.deleteFileLocally_(modelFile.filename());

              if (filesystem.main.model.display.filename() === modelFile.filename()) {
                filesystem.main.model.display.filename("answer.py");
              }
            }
          });
        }, _this, "arrayChange");
      });
    } // answer.py
    //   => subscribe to first element of submission.code)
    // !on_run.py, !on_change.py, !on_eval.py
    //   => subscribe to relevant assignment.<whatever>
    // ^starting_code.py
    //   => subscribe to first element of assignment.startingCode
    // ^whatever
    //   => subscribe to rest of the elements of assignment.startingCode
    // !whatever or ?whatever
    //   => subscribe to elements of assignment.extraFiles
    // Otherwise:
    //   => subscribe to rest of the elements of submission.code

    /**
     * New special files need to be registered here
     * @param file {BlockPyFile}
     * @private
     */

  }, {
    key: "observeFile_",
    value: function observeFile_(file) {
      if (file.filename === "answer.py") {
        file.handle = this.main.model.submission.code;
      } else if (file.filename === "!on_run.py") {
        file.handle = this.main.model.assignment.onRun;
      } else if (file.filename === "!on_change.py") {
        file.handle = this.main.model.assignment.onChange;
      } else if (file.filename === "!on_eval.py") {
        file.handle = this.main.model.assignment.onEval;
      } else if (file.filename === "!instructions.md") {
        file.handle = this.main.model.assignment.instructions;
      } else if (file.filename === "^starting_code.py") {
        file.handle = this.main.model.assignment.startingCode;
      } else if (file.filename === "?mock_urls.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "?toolbox.blockpy") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_prefix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!answer_suffix.py") {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else if (file.filename === "!tags.blockpy") {
        file.handle = this.main.model.assignment.tags;
      } else if (file.filename === "!assignment_settings.blockpy") {
        file.handle = this.main.model.assignment.settings;
      } else if (file.filename === "!sample_submissions.blockpy") {
        file.handle = this.main.model.assignment.sampleSubmissions;
      } else if (file.filename === "$settings.blockpy") {
        file.handle = this.main.model.display;
      } else if (file.filename.startsWith("^")) {
        this.observeInArray_(file, this.main.model.assignment.extraStartingFiles);
      } else if (file.filename.startsWith("!") || file.filename.startsWith("?") || file.filename.startsWith("&")) {
        this.observeInArray_(file, this.main.model.assignment.extraInstructorFiles);
      } else {
        this.observeInArray_(file, this.main.model.submission.extraFiles);
      }
    }
  }, {
    key: "observeInArray_",
    value: function observeInArray_(file, array) {
      file.owner = array;
      var codeBundle = file.owner();

      for (var i = 0; i < codeBundle.length; i++) {
        if (codeBundle[i].filename() === file.filename) {
          file.handle = codeBundle[i].contents;
        }
      }

      if (file.handle === null) {
        var newFile = makeModelFile(file.filename);
        file.handle = newFile.contents;
        array.push(newFile);
      }
    }
  }, {
    key: "mountFiles",
    value: function mountFiles() {
      this.newFile("answer.py");
      this.newFile("^starting_code.py");
      this.newFile("!on_run.py");
      this.newFile("!instructions.md");
      this.newFile("!assignment_settings.blockpy");
    }
  }, {
    key: "dismountExtraFiles",
    value: function dismountExtraFiles() {
      for (var name in this.files_) {
        if (this.files_.hasOwnProperty(name)) {
          if (UNDELETABLE_FILES.indexOf(name) === -1) {
            delete this.files_[name];
            delete this.watches_[name];
          }
        }
      } // submission.codeTODO: Shouldn't we notify the UI that the file was deleted?

    }
  }, {
    key: "newFile",
    value: function newFile(filename, contents, modelFile) {
      if (filename in this.files_) {
        // File already exists! Just update its handle
        var existingFile = this.files_[filename];

        if (modelFile === undefined) {
          this.observeFile_(existingFile);
        } else {
          existingFile.handle = modelFile;
        }

        existingFile.handle(contents || "");
        return existingFile;
      } else {
        // File does not exist
        var newFile = new BlockPyFile(this.main, filename);
        this.files_[filename] = newFile;

        if (modelFile === undefined) {
          this.observeFile_(newFile);
        } else {
          newFile.handle = modelFile;
        }

        if (contents !== undefined) {
          newFile.handle(contents);
        }

        return newFile;
      }
    }
  }, {
    key: "writeFile",
    value: function writeFile(filename, contents) {
      contents = contents || "";
      this.files_[filename].handle(contents);
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      return this.files_[filename].handle();
    }
  }, {
    key: "getFile",
    value: function getFile(filename) {
      return this.files_[filename];
    }
    /**
     *
     * @param filename
     * @returns {boolean|object} The info about the file, or false if it could not be deleted
     */

  }, {
    key: "deleteFile",
    value: function deleteFile(filename) {
      if (DELETABLE_SIMPLE_FILES.indexOf(filename) !== -1) {
        var file = this.deleteFileLocally_(filename);
        file.handle(null);
        return true;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "deleteFileLocally_",
    value: function deleteFileLocally_(filename) {
      var file = this.files_[filename];
      delete this.files_[filename];

      if (filename in this.watches_) {
        this.watches_[filename].forEach(function (callback) {
          return callback.deleted();
        });
      }

      return file;
    }
  }, {
    key: "renameFile",
    value: function renameFile(source, destination) {
      if (UNRENAMABLE_FILES.indexOf(source) !== -1) {
        return false;
      } else if (this.files_[filename].owner === null) {
        return false;
      } else {
        // Triggers a callback to eventually call deleteFileLocally_
        var found = this.files_[filename].owner.remove(function (modelFile) {
          return modelFile.filename() === filename;
        });
        return found || false;
      }
    }
  }, {
    key: "notifyWatches",
    value: function notifyWatches(file) {
      if (file.filename in this.watches_) {
        this.watches_[file.filename].forEach(function (callback) {
          return callback.updated(file);
        });
      }
    }
  }, {
    key: "searchForFile",
    value: function searchForFile(name, studentSearch) {
      /*
      TODO: This is called quite a bit by the Import mechanism, might need
            to optimize it some more. Do timing tests.
       files.*
      _instructor/files.*
      _student/files.*
       If a student searches for a file, it checks the "?", "&", "*", "" namespaces
          import helper => "./helper.py"
          open("external.json") => "external.json"
      If an instructor searches for a file, it checks "!", "^", "?", "&", "*", "" namespaces
          To explicitly search instructor namespaces first
              import _instructor.helper => "./instructor/helper.py"
              open("_instructor/external.json") => "_instructor/external.json"
          to allow student files to override:
              import helper => "./helper.py"
              open("external.json") => "external.json"
          to only check student files, prepend with _student
       */
      // Chop off starting "./"
      if (name.startsWith("./")) {
        name = name.slice(2);
      }

      var searchMode = SearchModes.EVERYWHERE; // Should the search be start with instructor side?

      if (name.startsWith(INSTRUCTOR_DIRECTORY)) {
        name = name.slice(INSTRUCTOR_DIRECTORY.length);
        searchMode = SearchModes.START_WITH_INSTRUCTOR;
      } // Should the search be limited to the student mode?


      if (name.startsWith(STUDENT_DIRECTORY)) {
        name = name.slice(STUDENT_DIRECTORY.length);
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } else if (studentSearch) {
        searchMode = SearchModes.ONLY_STUDENT_FILES;
      } // Shortcut for instructor versions


      var extraStudentFiles = this.main.model.submission.extraFiles();
      var extraInstructorFiles = this.main.model.assignment.extraInstructorFiles();
      var extraStartingFiles = this.main.model.assignment.extraStartingFiles(); // Check special files (TODO: how would an instructor access "./_instructor/answer.py"?

      var specialFile = this.searchForSpecialFiles_(name, searchMode);

      if (specialFile !== undefined) {
        return specialFile;
      } // Start looking through possible files


      var studentVersion = this.searchForFileInList_(extraStudentFiles, name);
      var generatedVersion = this.searchForFileInList_(extraStudentFiles, "*" + name);
      var defaultVersion = this.searchForFileInList_(extraInstructorFiles, "&" + name);
      var hiddenVersion = this.searchForFileInList_(extraInstructorFiles, "?" + name);

      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(hiddenVersion, defaultVersion, studentVersion, generatedVersion);
      }

      var instructorVersion = this.searchForFileInList_(extraInstructorFiles, "!" + name);
      var startingVersion = this.searchForFileInList_(extraStartingFiles, "^" + name);

      if (searchMode === SearchModes.START_WITH_INSTRUCTOR) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(instructorVersion, hiddenVersion, startingVersion, defaultVersion, studentVersion, generatedVersion);
      } else if (searchMode === SearchModes.EVERYWHERE) {
        return Object(utilities_js__WEBPACK_IMPORTED_MODULE_0__["firstDefinedValue"])(defaultVersion, studentVersion, generatedVersion, instructorVersion, hiddenVersion, startingVersion);
      }
    }
  }, {
    key: "searchForFileInList_",
    value: function searchForFileInList_(modelList, filename) {
      for (var i = 0; i < modelList.length; i++) {
        if (modelList[i].filename() === filename) {
          return modelList[i];
        }
      }

      return undefined;
    }
  }, {
    key: "searchForSpecialFiles_",
    value: function searchForSpecialFiles_(filename, searchMode) {
      if (searchMode === SearchModes.ONLY_STUDENT_FILES) {
        if (filename === "answer.py") {
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());
        }

        return undefined;
      }

      switch (filename) {
        case "answer.py":
          return makeMockModelFile("_instructor/answer.py", this.main.model.submission.code());

        case "on_run.py":
          return makeMockModelFile("_instructor/on_run.py", this.main.model.assignment.onRun());

        case "on_change.py":
          return makeMockModelFile("_instructor/on_change.py", this.main.model.assignment.onChange());

        case "on_eval.py":
          return makeMockModelFile("_instructor/on_eval.md", this.main.model.assignment.onEval());

        case "instructions.md":
          return makeMockModelFile("_instructor/instructions.md", this.main.model.assignment.instructions());

        case "starting_code.py":
          return makeMockModelFile("_instructor/starting_code.py", this.main.model.assignment.startingCode());
      }

      return undefined;
    }
  }, {
    key: "newFileDialog",
    value: function newFileDialog(kind) {
      var _this2 = this;

      var body = $(NEW_INSTRUCTOR_FILE_DIALOG_HTML);
      var filename = body.find(".blockpy-instructor-file-dialog-filename");
      var filetype = body.find(".blockpy-instructor-file-dialog-filetype");
      var namespace = body.find(".blockpy-instructor-file-dialog-namespace");
      var extensionRegex = /(?:\.([^.]+))?$/;
      filename.on("input", function () {
        var extension = extensionRegex.exec(filename.val())[1];
        extension = extension === undefined ? "No extension" : extension; //TODO: this.main.components.editors.getEditorFromExtension(extension);

        filetype.text(extension);
      });

      var yes = function yes() {
        var prefix = "";

        if (kind === "instructor") {
          prefix = namespace.val();
        } else if (kind === "starting") {
          prefix = "^";
        }

        if (filename.val()) {
          filename = prefix + filename.val();

          _this2.newFile(filename);
        }
      };

      body.submit(function (e) {
        e.preventDefault();
        yes();

        _this2.main.components.dialog.close();
      });
      this.main.components.dialog.confirm("Make New File", body, yes, function () {}, "Add");
    }
  }]);

  return BlockPyFileSystem;
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! knockout */ "knockout"), __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/footer.js":
/*!***********************!*\
  !*** ./src/footer.js ***!
  \***********************/
/*! exports provided: FOOTER_HTML */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FOOTER_HTML", function() { return FOOTER_HTML; });
//TODO: Move get link down to footer, remove vertical bar from quick-menu
var FOOTER_HTML = "\n<div class=\"col-md-12 blockpy-panel blockpy-status\">\n    <div>\n        <label class=\"badge\" data-bind=\"class: ui.server.status('loadAssignment')\">Load Assignment\n            <!-- ko if: display.instructor -->\n            <input type=\"file\"\n            class=\"blockpy-force-load-assignment-file blockpy-hidden-file\"\n            accept=\"application/JSON\"\n            data-bind=\"event: {change: ui.server.force.loadAssignment}\">\n            <!-- /ko -->\n        </label>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveAssignment')\">Save Assignment</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadFile')\">Load File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('saveFile')\">Save File</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('loadDataset')\">Load Dataset</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('logEvent')\">Log Event</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('updateSubmission'),\n                                        click: ui.server.force.updateSubmission\">Update Submission</span>, \n        <span class=\"badge\" data-bind=\"class: ui.server.status('onExecution')\">Execution</span>\n    </div>\n    <div\n        <span data-bind=\"text: ui.server.messages\"></span>\n    </div>\n    <div>\n        <span>User: <span data-bind=\"text: user.id\"></span> (<span data-bind=\"text: user.name\"></span>, <span data-bind=\"text: user.role\"></span>)</span>, \n        <span>Course: <span data-bind=\"text: user.courseId\"></span></span>,\n        <span>Group: <span data-bind=\"text: user.groupId\"></span></span>,\n        <span>Assignment: <span data-bind=\"text: assignment.id\"></span></span>,\n        <span>Assignment Version: <span data-bind=\"text: assignment.version\"></span></span>,\n        <span>Submission: \n            <span data-bind=\"text: submission.id\"></span>\n            <span data-bind=\"if: submission.ownerId() != user.id()\">\n                (Owner ID: <span data-bind=\"text: submission.ownerId()\"></span>)\n            </span>\n        </span>, \n        <span>Submission Version: <span data-bind=\"text: submission.version\"></span></span>,\n        <span>Editor Version: <span data-bind=\"text: display.editorVersion\"></span></span>\n    </div>\n</div>\n";

/***/ }),

/***/ "./src/history.js":
/*!************************!*\
  !*** ./src/history.js ***!
  \************************/
/*! exports provided: HISTORY_TOOLBAR_HTML, BlockPyHistory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HISTORY_TOOLBAR_HTML", function() { return HISTORY_TOOLBAR_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyHistory", function() { return BlockPyHistory; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO: Should disable buttons if we can't activate them.
var HISTORY_TOOLBAR_HTML = "\n<div class=\"blockpy-history-toolbar col-md-12\" data-bind=\"visible: display.historyMode\">\n\n    <form class=\"form-inline\">\n        <button class=\"blockpy-history-start btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.start\">\n            <span class='fas fa-step-backward'></span> Start\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.previous\">\n            <span class='fas fa-backward'></span> Previous\n        </button>\n        <select class=\"blockpy-history-selector form-control custom-select mr-2\" aria-title=\"History Selector\">\n        </select>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.use\">\n            <span class='fas fa-file-import'></span> Use\n        </button>\n        <button class=\"btn btn-outline-secondary mr-2\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.next\">\n            <span class='fas fa-forward'></span> Next\n        </button>\n        <button class=\"btn btn-outline-secondary\" type=\"button\"\n            data-bind=\"click: ui.editors.python.history.mostRecent\">\n            <span class='fas fa-step-forward'></span> Most Recent\n        </button>\n    </form>\n</div>\n";
/**
 * An object for displaying the user's coding logs (their history).
 * A lightweight component, its only job is to open a dialog.
 *
 * @constructor
 * @this {BlockPyHistory}
 * @param {Object} main - The main BlockPy instance
 */

var BlockPyHistory = /*#__PURE__*/function () {
  function BlockPyHistory(main, tag) {
    _classCallCheck(this, BlockPyHistory);

    this.main = main;
    this.tag = tag;
    this.currentId = null;
    this.history = [];
    this.editEvents = [];
  }

  _createClass(BlockPyHistory, [{
    key: "load",
    value: function load(history) {
      var _this = this;

      this.history = history;
      this.editEvents = [];
      this.selector = $(".blockpy-history-selector").empty();
      var editId = 0;
      history.filter(function (entry) {
        return !entry.file_path.startsWith("_instructor.") && entry.event_type !== "Compile" && entry.event_type !== "Intervention" && (!_this.main.model.assignment.hidden() || entry.event_type !== "X-Submission.LMS");
      }).forEach(function (entry, index) {
        var event_type = REMAP_EVENT_TYPES[entry.event_type] || entry.event_type;
        var displayed = prettyPrintDateTime(entry.client_timestamp) + " - " + event_type;
        var disable = entry.event_type !== "File.Edit";
        var option = $("<option></option>", {
          text: displayed,
          disabled: disable
        });

        if (_this.isEditEvent(entry)) {
          option.attr("value", editId);

          _this.editEvents.push(entry);

          editId += 1;
        }

        _this.selector.append(option);
      });
      this.selector.val(Math.max(0, editId - 1));
      this.selector.change(function (evt) {
        _this.updateEditor();
      });
    }
  }, {
    key: "moveToStart",
    value: function moveToStart() {
      this.selector.val(0);
      this.updateEditor();
    }
  }, {
    key: "movePrevious",
    value: function movePrevious() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.max(0, currentId - 1));
      this.updateEditor();
    }
  }, {
    key: "moveNext",
    value: function moveNext() {
      var currentId = parseInt(this.selector.val(), 10);
      this.selector.val(Math.min(this.editEvents.length - 1, currentId + 1));
      this.updateEditor();
    }
  }, {
    key: "moveToMostRecent",
    value: function moveToMostRecent() {
      this.selector.val(this.editEvents.length - 1);
      this.updateEditor();
    }
  }, {
    key: "updateEditor",
    value: function updateEditor() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        this.main.components.pythonEditor.bm.setCode(this.editEvents[currentId].message);
      }
    }
  }, {
    key: "use",
    value: function use() {
      if (this.editEvents.length) {
        var currentId = parseInt(this.selector.val(), 10);
        var code = this.editEvents[currentId].message;
        this.main.model.ui.editors.python.turnOffHistoryMode();
        this.main.components.pythonEditor.file.handle(code);
      }
    }
  }, {
    key: "isEditEvent",
    value: function isEditEvent(entry) {
      return (entry.event_type === "File.Edit" || entry.event_type === "File.Create") && this.main.model.display.filename() === entry.file_path;
    }
  }]);

  return BlockPyHistory;
}();
var REMAP_EVENT_TYPES = {
  "Session.Start": "Began session",
  "X-IP.Change": "Changed IP address",
  "File.Edit": "Edited code",
  "File.Create": "Started assignment",
  "Run.Program": "Ran program",
  "Compile.Error": "Syntax error",
  "X-Submission.LMS": "Updated grade"
};
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"];
var weekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

function isSameDay(first, second) {
  return first.getDate() === second.getDate() && first.getMonth() === second.getMonth() && first.getFullYear() === second.getFullYear();
}
/**
 * Helper function to parse a date/time string and rewrite it as something
 * more human readable.
 * @param {String} timeString - the string representation of time ("YYYYMMDD HHMMSS")
 * @returns {String} - A human-readable time string.
 */


function prettyPrintDateTime(timeString) {
  /*let year = timeString.slice(0, 4),
      month = parseInt(timeString.slice(4, 6), 10)-1,
      day = timeString.slice(6, 8),
      hour = timeString.slice(9, 11),
      minutes = timeString.slice(11, 13),
      seconds = timeString.slice(13, 15);*/
  // TODO: Handle timezones correctly
  if (timeString === undefined) {
    return "Undefined Time";
  }

  var now = new Date();
  var past = new Date(parseInt(timeString, 10));

  if (isSameDay(now, past)) {
    return "Today at " + past.toLocaleTimeString();
  } else {
    var dayStr = weekDays[past.getDay()];
    var monthStr = monthNames[past.getMonth()];
    var date = dayStr + ", " + monthStr + " " + past.getDate();

    if (now.getFullYear() === past.getFullYear()) {
      return date + " at " + past.toLocaleTimeString();
    } else {
      return date + ", " + past.getFullYear() + " at " + past.toLocaleTimeString();
    }
  }
}
/**
 * Opens the history dialog box. This requires a trip to the server and
 * occurs asynchronously. The users' code is shown in preformatted text
 * tags (no code highlighting currently) along with the timestamp.
 */


BlockPyHistory.prototype.openDialog = function () {
  var dialog = this.main.components.dialog;
  var body = "<pre>a = 0</pre>";
  this.main.components.server.getHistory(function (data) {
    body = data.reverse().reduce(function (complete, elem) {
      var complete_str = prettyPrintDateTime(elem.time);
      var new_line = "<b>" + complete_str + "</b><br><pre>" + elem.code + "</pre>";
      return complete + "\n" + new_line;
    }, "");
    dialog.show("Work History", body, function () {});
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/interface.js":
/*!**************************!*\
  !*** ./src/interface.js ***!
  \**************************/
/*! exports provided: SecondRowSecondPanelOptions, makeExtraInterfaceSubscriptions, makeInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SecondRowSecondPanelOptions", function() { return SecondRowSecondPanelOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeExtraInterfaceSubscriptions", function() { return makeExtraInterfaceSubscriptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeInterface", function() { return makeInterface; });
/* harmony import */ var trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trace.js */ "./src/trace.js");
/* harmony import */ var dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dialog.js */ "./src/dialog.js");
/* harmony import */ var feedback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! feedback.js */ "./src/feedback.js");
/* harmony import */ var files_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! files.js */ "./src/files.js");
/* harmony import */ var footer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! footer.js */ "./src/footer.js");
/* harmony import */ var editors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! editors.js */ "./src/editors.js");
/* harmony import */ var console_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! console.js */ "./src/console.js");
/**
 * @fileoverview Contains main HTML of BlockPy interface, and helper functions.
 * Combines a lot of HTML from components.
 *
 * Here's the layout:
 *  Row 1: Header and Quick Menu
 *  Row 2: Console and Feedback
 *  Row 3: File Navigation
 *  Row 4: View Row
 *  Row 5: Footer Row
 */







/**
 * The different layout options of the panes in the second row of the layout.
 * @enum {String}
 */

var SecondRowSecondPanelOptions = {
  FEEDBACK: "feedback",
  TRACE: "trace",
  NONE: "none"
};
/**
 * Setup any additional Knockout subscriptions to fire on interface changes.
 * @param self
 * @param model
 */

function makeExtraInterfaceSubscriptions(self, model) {
  // Highlight Markdown when instructions update
  var highlightTimeout = null;
  model.ui.instructions.current.subscribe(function () {
    if (highlightTimeout !== null) {
      clearTimeout(highlightTimeout);
    }

    highlightTimeout = setTimeout(function () {
      model.configuration.container.find(".blockpy-instructions pre code").map(function (i, block) {
        window.hljs.highlightBlock(block);
      });
    }, 400);
  }); // Provide Fullscreen support

  model.display.fullscreen.subscribe(function (isFullscreen) {
    self.components.server.logEvent("X-Display.Fullscreen.Request", "", "", isFullscreen.toString(), "");

    if (isFullscreen) {
      // NOTE: navigationUI could allow us to force controls to show
      model.configuration.container.parent()[0].requestFullscreen()["catch"](function (err) {
        var message = "Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")");
        self.components.server.logEvent("X-Display.Fullscreen.Error", "", "", message, "");
        alert(message);
      }).then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Success", "", "", "", "");
        model.display.fullscreen(true);
        model.configuration.container.css("overflow-y", "auto");
      });
    } else {
      document.exitFullscreen().then(function () {
        self.components.server.logEvent("X-Display.Fullscreen.Exit", "", "", isFullscreen.toString(), "");
        model.display.fullscreen(false);
      });
    }
  });
} // TODO: Get shareable link button

function makeInterface(main) {
  return "\n<div class='blockpy-content container-fluid'>\n\n    <!-- Dialog -->\n    ".concat(dialog_js__WEBPACK_IMPORTED_MODULE_1__["DIALOG_HTML"], "\n    \n    <!-- Hidden Capture Canvas -->\n    <canvas id='capture-canvas' class='d-none' role=\"presentation\" aria-hidden=\"true\"></canvas>\n    \n    <!-- Row 1: Header and Quick Menu -->\n    <div class='row'>\n         \n         <!-- Description -->\n         <div class='col-md-9 blockpy-panel blockpy-header'\n               role='heading' aria-label='Assignment Description'>\n         \n            <!-- Assignment Name -->\n            <span role='heading' aria-level='1'\n                  class=\"blockpy-name\">\n                <strong>BlockPy: </strong> \n                <span data-bind='text: assignment.name'></span>\n            </span>\n            \n            <!-- Reset Instructions Button -->\n            <div class=\"blockpy-instructions-reset\"\n                data-bind=\"visible: ui.instructions.isChanged\">\n                <a class=\"float-right\"\n                    data-bind=\"click: ui.instructions.reset\"\n                    href=\"\">\n                    Reset instructions</a>\n            </div>\n            \n            <!-- Instructions -->\n            <div class='blockpy-instructions'\n                 data-bind=\"html: ui.instructions.current\">\n            </div>\n        </div>\n        \n        <div class='col-md-3 blockpy-panel blockpy-quick-menu'\n             role='menubar' aria-label='Quick Menu' title=\"Quick Menu\">\n            <!-- Get Shareable Link -->\n            <!--<button class=\"btn btn-outline-secondary btn-sm\">\n                Get shareable link</button>-->\n            <span data-bind=\"visible: ui.menu.isSubmitted\">\n                Your submission is ready to be reviewed!</span>\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"visible: ui.menu.canMarkSubmitted,\n                           text: ui.menu.textMarkSubmitted,\n                           click: ui.menu.clickMarkSubmitted\"></button>\n            <!-- View as instructor -->\n            <div class=\"form-check\"\n                 data-bind=\"visible: ui.role.isGrader\">\n                <input class=\"form-check-input\" type=\"checkbox\" value=\"\" id=\"blockpy-as-instructor\"\n                    data-bind=\"checked: display.instructor\">\n                <label class=\"form-check-label\" for=\"blockpy-as-instructor\">\n                    View as instructor\n                </label>\n            </div>\n            <!-- Readonly mode for spying -->\n            <div data-bind=\"if: submission.ownerId() != user.id()\">\n                Owner: <span data-bind=\"text: submission.ownerId\"></span>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input\" type=\"checkbox\" value=\"blockpy-read-only\"\n                        data-bind=\"checked: display.readOnly\">\n                    <label class=\"form-check-label\" for=\"blockpy-read-only\">\n                        Readonly?\n                    </label>\n                </div>\n            </div>\n            \n            \n            <!-- Fullscreen button -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.clickFullscreen\"\n                title=\"Full Screen\">\n                <span class='fas' data-bind=\"class: ui.menu.textFullscreen\"></span>\n            </button>\n            <!-- Edit Queued Inputs -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-bind=\"click: ui.menu.editInputs, visible: ui.menu.showQueuedInputs\" title=\"Edit Inputs\">\n                <span class='fas fa-list-alt'></span>\n            </button>\n            <!-- Toggle Image Rendering -->\n            <button class=\"btn btn-outline-secondary btn-sm\"\n                data-toggle=\"button\"\n                data-bind=\"click: ui.menu.toggleImages\" title=\"Toggle Images\">\n                <span class=\"fas fa-images\"></span>\n            </button>\n            <!-- Pink Bug for actual errors -->\n            <span class=\"blockpy-student-error fas fa-bug\"></span>\n        </div>\n         \n    </div>\n    \n    <div class='row'>\n    <!-- Row 2: Console and Feedback -->\n    <!-- ko if: ui.secondRow.isAllVisible -->\n    <div data-bind=\"class: ui.secondRow.width\">\n    <div class='row'>\n        <!-- Console -->\n        ").concat(console_js__WEBPACK_IMPORTED_MODULE_6__["CONSOLE_HTML"], "\n        <!-- Feedback -->\n        <!-- ko if: ui.secondRow.isFeedbackVisible -->\n        ").concat(feedback_js__WEBPACK_IMPORTED_MODULE_2__["FEEDBACK_HTML"], "\n        <!-- /ko -->\n        <!-- Trace -->\n        <!-- ko if: ui.secondRow.isTraceVisible -->\n        ").concat(trace_js__WEBPACK_IMPORTED_MODULE_0__["TRACE_HTML"], "\n        <!-- /ko -->\n    </div>\n    </div>\n    <!-- /ko -->\n    \n    <!-- Row 3: File Navigation -->\n    <!-- ko if: ui.files.visible -->\n    ").concat(files_js__WEBPACK_IMPORTED_MODULE_3__["FILES_HTML"], "\n    <!-- /ko -->\n    \n    <!-- Row 4: View Row -->\n    ").concat(editors_js__WEBPACK_IMPORTED_MODULE_5__["EDITORS_HTML"], "\n    </div>\n    \n    \n    <!-- Row 5: Footer Row -->    \n    <!-- ko if: ui.footer.visible -->\n    <div class=\"row\">\n        ").concat(footer_js__WEBPACK_IMPORTED_MODULE_4__["FOOTER_HTML"], "\n    </div>\n    <!-- /ko -->\n    \n</div>\n    ");
}

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! exports provided: StatusState, BlockPyServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StatusState", function() { return StatusState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyServer", function() { return BlockPyServer; });
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ "./src/storage.js");
/* harmony import */ var _editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor/assignment_settings */ "./src/editor/assignment_settings.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 *
 * @enum {string}
 */

var StatusState = {
  READY: "ready",
  ACTIVE: "active",
  RETRYING: "retrying",
  FAILED: "failed",
  OFFLINE: "offline"
};
/**
 * Object for communicating with the external servers. This includes functionality for
 * saving and loading files, logging events, saving completions, and retrieving history.
 *
 * @constructor
 * @this {BlockPyServer}
 * @param {Object} main - The main BlockPy instance
 */

function BlockPyServer(main) {
  this.main = main; // Save URLs locally for quicker access

  this.urls = main.model.configuration.urls; // Add the LocalStorage connection

  this.storage = new _storage__WEBPACK_IMPORTED_MODULE_0__["LocalStorageWrapper"]("BLOCKPY"); // FaultResistantCache

  this.queue = {
    "logEvent": JSON.parse(this.storage.getDefault("logEvent", "[]")),
    "updateSubmission": JSON.parse(this.storage.getDefault("updateSubmission", "[]"))
  };
  this.MAX_QUEUE_SIZE = {
    "logEvent": 200,
    "updateSubmission": 50
  };
  this.TIMER_DELAY = 1000;
  this.FAIL_DELAY = 2000;
  this.timers = {};
  this.overlay = null;
  this.blockingAttempts = 0;
  this.cachedFilenames = [];
  this.createSubscriptions();
  this.checkCaches();
  this.altLogEntry = null;
}
/**
 * Checks whether the IP address has changed, logging an event if that occurs.
 * @param response
 */

BlockPyServer.prototype.checkIP = function (response) {
  if (response.success) {
    if (this.storage.has("IP")) {
      var oldIP = this.storage.get("IP");

      if (oldIP !== response.ip) {
        var message = JSON.stringify({
          "old": oldIP,
          "new": response.ip
        });

        if (this.altLogEntry) {
          this.altLogEntry("X-IP.Change", undefined, undefined, message);
        } else {
          this.logEvent("X-IP.Change", undefined, undefined, message);
        }

        this.storage.set("IP", response.ip);
      }
    } else {
      this.storage.set("IP", response.ip);
    }
  }
};
/**
 * Determines if there have been previous failures cached, and if so retries them.
 * TODO: update
 */


BlockPyServer.prototype.checkCaches = function () {
  var _this = this;

  if (this.storage.has("saveAssignment")) {
    var data = JSON.parse(this.storage.get("saveAssignment"));

    this._postLatestRetry(data, "assignment", "saveAssignment", this.TIMER_DELAY);
  }

  this.cachedFilenames.forEach(function (filename) {
    if (_this.storage.has("saveFile" + filename)) {
      var _data = JSON.parse(_this.storage.get("saveFile" + filename));

      _this._postLatestRetry(_data, filename, "saveFile", _this.TIMER_DELAY);
    }
  });
  var server = this;
  Object.keys(this.queue).forEach(function (endpoint) {
    (function pushAnyQueued(response) {
      if (response.success) {
        if (server.queue[endpoint].length) {
          var data = JSON.parse(server.queue[endpoint].pop());
          var url = server.urls[endpoint];

          server._postRetry(data, endpoint, 1000, pushAnyQueued);
        }
      }
    })({
      "success": true
    });
  });
};

BlockPyServer.prototype.createFileSubscription = function (model, filename) {
  var _this2 = this;

  model.subscribe(function (contents) {
    return _this2.main.model.display.autoSave() ? _this2.saveFile(filename, contents) : false;
  }, this);
  this.cachedFilenames.push(filename);
};
/**
 * TODO: fix
 */


BlockPyServer.prototype.createSubscriptions = function () {
  var model = this.main.model;
  this.createFileSubscription(model.submission.code, "answer.py");
  this.createFileSubscription(model.assignment.onRun, "!on_run.py");
  this.createFileSubscription(model.assignment.onEval, "!on_eval.py");
  this.createFileSubscription(model.assignment.onChange, "!on_change.py");
  this.createFileSubscription(model.assignment.instructions, "!instructions.md");
  this.createFileSubscription(model.assignment.startingCode, "^starting_code.py");
  this.createFileSubscription(model.ui.files.extraStudentFiles, "#extra_student_files.blockpy");
  this.createFileSubscription(model.ui.files.extraStartingFiles, "#extra_starting_files.blockpy");
  this.createFileSubscription(model.ui.files.extraInstructorFiles, "#extra_instructor_files.blockpy");
};

BlockPyServer.prototype.createEventLogs = function () {
  var _this3 = this;

  window.onblur = function () {
    _this3.logEvent("Session.End", undefined, undefined, undefined);
  };

  window.onfocus = function () {
    _this3.logEvent("Session.Start", undefined, undefined, undefined);
  }; // TODO: Add in beacon?

};
/**
 *
 * Some subscriptions have to happen after other things have been loaded.
 * Right now this is just after CORGIS libraries have been loaded, but maybe
 * we'll add more later and this will need to be refactored.
 *
 * TODO: fix
 *
 */


BlockPyServer.prototype.finalizeSubscriptions = function () {//this.main.model.assignment.settings.datasets.subscribe(this.saveAssignment.bind(this));
};
/**
 * Creates the default payload for any communication with the server API
 * @returns {{assignment_id: *, course_id: *, group_id: *, user_id: *, timezone: *, version: *, timestamp: *}}
 */


BlockPyServer.prototype.createServerData = function () {
  var assignment = this.main.model.assignment;
  var user = this.main.model.user;
  var submission = this.main.model.submission;
  var display = this.main.model.display;
  var now = new Date();
  var microseconds = now.getTime();
  return {
    "assignment_id": assignment.id(),
    "assignment_group_id": user.groupId(),
    "course_id": user.courseId(),
    "submission_id": submission.id(),
    "user_id": user.id(),
    "version": assignment.version(),
    "timestamp": microseconds,
    "timezone": now.getTimezoneOffset(),
    "passcode": display.passcode()
  };
};
/**
 * Updates the status and message for the relevant endpoint.
 * @param endpoint {string} one of the URL endpoints
 * @param status {StatusState}
 * @param message {string?}
 */


BlockPyServer.prototype.setStatus = function (endpoint, status, message) {
  this.main.model.status[endpoint](status);
  this.main.model.status[endpoint + "Message"](message || "");
};
/**
 * Renders an overlay on the screen that blocks operation until the system is ready.
 * The overlay gets progressively darker to indicate repeated failures.
 */


BlockPyServer.prototype.showOverlay = function (attempt) {
  this.blockingAttempts += 1;

  if (!document.getElementsByClassName("blockpy-overlay").length) {
    this.overlay = $('<div class="blockpy-overlay"> </div>');
    this.overlay.appendTo(document.body);
  }

  switch (attempt) {
    case 0:
      this.overlay.css("background-color", "#988");
      break;

    case 1:
      this.overlay.css("background-color", "#655");
      break;

    case 2:
      this.overlay.css("background-color", "#333");
      break;

    default:
      this.overlay.css("background-color", "black");
      break;
  }
};
/**
 * Undo a level of overlay; if this was the last level, removes it from the screen.
 */


BlockPyServer.prototype.hideOverlay = function () {
  this.blockingAttempts -= 1;

  if (this.blockingAttempts <= 0) {
    this.overlay.remove();
  }
};

BlockPyServer.prototype._enqueueData = function (cache, data) {
  // Ensure we have not overfilled the queue
  var length = this.queue[cache].length;
  var max = this.MAX_QUEUE_SIZE[cache];

  if (length > max) {
    this.queue[cache] = this.queue[cache].slice(length - max, max);
  } // Only add the element if it's new


  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index === -1) {
    this.queue[cache].push(key);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._dequeueData = function (cache, data) {
  var key = JSON.stringify(data);
  var index = this.queue[cache].indexOf(key);

  if (index >= 0) {
    this.queue[cache].splice(index);
    this.storage.set(cache, JSON.stringify(this.queue[cache]));
  }
};

BlockPyServer.prototype._postRetry = function (data, endpoint, delay, callback) {
  var _this4 = this;

  // Trigger request
  var postRequest = function postRequest() {
    // Make a backup of the current post
    _this4._enqueueData(endpoint, data);

    $.post(_this4.urls[endpoint], data).done(function (response) {
      _this4._dequeueData(endpoint, data);

      if (response.success) {
        _this4.setStatus(endpoint, StatusState.READY);
      } else {
        console.error(response);

        _this4.setStatus(endpoint, StatusState.FAILED, response.message);
      }

      if (callback) {
        callback(response);
      }

      if (response.success) {
        _this4.checkIP(response.ip);
      }
    }) // If server request is the latest one, then let's try it again in a bit
    .fail(function (error, textStatus) {
      _this4.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

      _this4._postRetry(data, endpoint, delay + _this4.FAIL_DELAY, callback);
    });
  };

  if (delay === null) {
    postRequest();
  } else {
    setTimeout(postRequest, delay);
  }
};
/**
 * Make a AJAX request that, upon failure, will check to see if this was the
 * latest attempt for this `cache` marker. If so, it will attempt again until
 * successful; otherwise, it gives up the request.
 *
 * @param {Object} data - The AJAX-ready data to be posted
 * @param {String} filename - The unique name given to the relevant timer
 * @param {String} endpoint - The unique name given to the relevant cache entry
 * @param {Integer} delay - The current number of milliseconds to wait before
 trying the request again.
 */


BlockPyServer.prototype._postLatestRetry = function (data, filename, endpoint, delay, failureFunction, doneFunction) {
  var _this5 = this;

  var cache = endpoint + filename;

  var request = function request() {
    // Make a backup of the current post
    _this5.storage.set(cache, JSON.stringify(data));

    var time = _this5.storage.getTime(cache); // Send the request


    $.post(_this5.urls[endpoint], data).done(function (response) {
      if (response.success) {
        _this5.checkIP(response); // If server request is the latest one, clear it from the cache


        var cachedTime = _this5.storage.getTime(cache);

        if (time >= cachedTime) {
          _this5.storage.remove(cache);
        }

        _this5.setStatus(endpoint, StatusState.READY);
      } else {
        // This connected but failed, don't try again but let the user know why.
        _this5.setStatus(endpoint, StatusState.FAILED, response.message);

        if (response.success === false) {
          // If we're the latest one, clear it from the cache
          var _cachedTime = _this5.storage.getTime(cache);

          if (time >= _cachedTime) {
            _this5.storage.remove(cache);
          }

          if (failureFunction) {
            failureFunction(response);
          }
        }
      }
    }).fail(function (error, textStatus) {
      _this5.setStatus(endpoint, StatusState.RETRYING, textStatus.toString()); // If server request is the latest one, then let's try it again in a bit


      var cachedTime = _this5.storage.getTime(cache);

      if (time >= cachedTime) {
        _this5._postLatestRetry(data, filename, endpoint, delay + _this5.FAIL_DELAY);
      }
    }).done(doneFunction);
  };

  clearTimeout(this.timers[cache]);

  if (delay === null) {
    return request();
  } else {
    this.timers[cache] = setTimeout(request, delay);
  }
};

BlockPyServer.prototype._postBlocking = function (endpoint, data, attempts, success, failure) {
  var _this6 = this;

  var extraSettings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  this.showOverlay(attempts);
  return $.ajax(_objectSpread({
    type: "POST",
    url: this.urls[endpoint],
    data: data
  }, extraSettings)).done(function (response) {
    _this6.hideOverlay();

    _this6.setStatus(endpoint, StatusState.READY);

    success(response);

    _this6.checkIP(response);
  }).fail(function (e, textStatus, errorThrown) {
    if (attempts <= 0) {
      _this6.hideOverlay();

      _this6.setStatus(endpoint, StatusState.FAILED, textStatus.toString());

      if (failure) {
        failure(e, textStatus, errorThrown);
      }
    } else {
      setTimeout(function () {
        _this6.hideOverlay();

        _this6.setStatus(endpoint, StatusState.RETRYING, textStatus.toString());

        _this6._postBlocking(endpoint, data, attempts - 1, success, failure);
      }, _this6.FAIL_DELAY);
    }
  });
};

BlockPyServer.prototype.loadAssignment = function (assignment_id) {
  var _this7 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("loadAssignment")) {
    var data = this.createServerData();
    data["assignment_id"] = assignment_id;

    this._postBlocking("loadAssignment", data, 4, function (response) {
      if (response.success) {
        _this7.main.loadAssignmentData_(response);
      } else {
        _this7.setStatus("loadAssignment", StatusState.FAILED, response.message);

        _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(response.message);
      }
    }, function (e, textStatus, errorThrown) {
      _this7.main.components.dialog.ERROR_LOADING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("loadAssignment", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveAssignment = function () {
  var _this8 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("saveAssignment")) {
    var data = this.createServerData();
    data["hidden"] = model.assignment.hidden();
    data["reviewed"] = model.assignment.reviewed();
    data["public"] = model.assignment["public"]();
    data["url"] = model.assignment.url();
    data["points"] = model.assignment.points();
    data["ip_ranges"] = model.assignment.ipRanges();
    data["name"] = model.assignment.name();
    data["settings"] = Object(_editor_assignment_settings__WEBPACK_IMPORTED_MODULE_1__["saveAssignmentSettings"])(model);

    this._postBlocking("saveAssignment", data, 3, this.startPossibleFork.bind(this), function (e, textStatus, errorThrown) {
      _this8.main.components.dialog.ERROR_SAVING_ASSIGNMNENT(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  } else {
    this.setStatus("saveAssignment", StatusState.OFFLINE, "Server is not connected! (Save Assignment)");
  }
};

BlockPyServer.prototype.loadHistory = function (callback) {
  var _this9 = this;

  if (this.main.model.ui.server.isEndpointConnected("loadHistory")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("loadHistory", data, 2, callback, function (e, textStatus, errorThrown) {
      _this9.main.components.dialog.ERROR_LOADING_HISTORY();

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.listUploadedFiles = function (callback) {
  var _this10 = this;

  if (this.main.model.ui.server.isEndpointConnected("listUploadedFiles")) {
    var model = this.main.model;
    var data = this.createServerData();

    this._postBlocking("listUploadedFiles", data, 2, callback, function (e, textStatus, errorThrown) {
      _this10.main.components.dialog.ERROR_LISTING_UPLOADED_FILES(textStatus);

      console.error(e, textStatus, errorThrown);
    });
  }
};

BlockPyServer.prototype.uploadFile = function (placement, directory, filename, contents, callback) {
  var _this11 = this;

  var model = this.main.model;

  if (model.ui.server.isEndpointConnected("uploadFile")) {
    var data = this.createServerData();
    data["placement"] = placement;
    data["directory"] = directory;
    data["filename"] = filename;
    data["contents"] = contents;
    var fd = Object.entries(data).reduce(function (d, e) {
      return d.append.apply(d, _toConsumableArray(e)), d;
    }, new FormData());
    return this._postBlocking("uploadFile", fd, 3, callback, function (e, textStatus, errorThrown) {
      _this11.main.components.dialog.ERROR_UPLOADING_FILE(textStatus);

      console.error(e, textStatus, errorThrown);
    }, {
      processData: false,
      contentType: false
    });
  } else {
    this.setStatus("uploadFile", StatusState.OFFLINE, "Server is not connected! (Upload File)");
  }
};

BlockPyServer.prototype.logEvent = function (event_type, category, label, message, file_path) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("logEvent", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("logEvent")) {
    var data = this.createServerData();
    data["event_type"] = event_type;
    data["category"] = category;
    data["label"] = label;
    data["message"] = message;
    data["file_path"] = file_path;
    this.setStatus("logEvent", StatusState.ACTIVE); // Trigger request

    this._postRetry(data, "logEvent", 0, function () {});
  } else {
    this.setStatus("logEvent", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.saveImage = function (directory, image) {
  if (this.main.model.display.readOnly()) {
    this.setStatus("saveImage", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("saveImage")) {
    var data = this.createServerData();
    data["directory"] = directory;
    data["image"] = image;
    this.setStatus("saveImage", StatusState.ACTIVE); // Trigger request

    this._postLatestRetry(data, "turtle_output", "saveImage", 0);
  } else {
    this.setStatus("saveImage", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.updateSubmissionStatus = function (newStatus) {
  var _this12 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmissionStatus", StatusState.OFFLINE);
    return;
  }

  if (this.main.model.ui.server.isEndpointConnected("updateSubmissionStatus")) {
    var data = this.createServerData();
    data["status"] = newStatus;

    var postStatusChange = function postStatusChange(data) {
      if (data.success) {
        _this12.main.model.submission.submissionStatus(newStatus);
      }
    };

    this._postBlocking("updateSubmissionStatus", data, 2, postStatusChange, function (e, textStatus, errorThrown) {
      _this12.main.components.dialog.ERROR_UPDATING_SUBMISSION_STATUS();

      console.error(e, textStatus, errorThrown);
    });
  }
};
/**
 * This function can be used to load files and web resources.
 *
 * DEPRECATED
 */


BlockPyServer.prototype.loadFile = function (filename, type, callback, errorCallback) {
  var model = this.main.model;
  var server = this;

  if (model.ui.server.isEndpointConnected("load_file")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["type"] = type;

    this._postBlocking(this.urls.load_file, data, 5, function (response) {
      if (response.success) {
        callback(response.data);
      } else {
        errorCallback(response.message);
        server.setStatus("loadFile", StatusState.FAILED, response.message);
      }
    }, function (e, textStatus, errorThrown) {
      errorCallback("Server failure! Report to instructor");
      console.error(errorThrown);
    });
  } else {
    errorCallback("No file server available.");
    this.setStatus("loadFile", StatusState.OFFLINE, "Server is not connected! (Load File)");
  }
};

BlockPyServer.prototype.saveFile = function (filename, contents, delay) {
  if (delay === undefined) {
    delay = this.TIMER_DELAY;
  }

  var model = this.main.model;

  if (model.display.readOnly()) {
    this.setStatus("saveFile", StatusState.OFFLINE);
    return;
  }

  if (model.ui.server.isEndpointConnected("saveFile")) {
    var data = this.createServerData();
    data["filename"] = filename;
    data["code"] = contents;
    this.setStatus("saveFile", StatusState.ACTIVE);
    return this._postLatestRetry(data, filename, "saveFile", delay, this.startPossibleFork.bind(this));
  } else {
    return this.setStatus("saveFile", StatusState.OFFLINE);
  }
};

BlockPyServer.prototype.startPossibleFork = function (response) {
  if (!response.success && response.forkable) {
    this.main.components.dialog.OFFER_FORK();
  }
};

BlockPyServer.prototype.updateSubmission = function (score, correct, hiddenOverride, forceUpdate) {
  var _this13 = this;

  if (this.main.model.display.readOnly()) {
    this.setStatus("updateSubmission", StatusState.OFFLINE);
    return;
  }

  var callback = this.main.model.configuration.callbacks.success;

  if (this.main.model.ui.server.isEndpointConnected("updateSubmission")) {
    var data = this.createServerData();
    data["score"] = score;
    data["correct"] = correct;
    data["hidden_override"] = hiddenOverride;
    data["force_update"] = forceUpdate;
    this.main.components.pythonEditor.bm.blockEditor.getPngFromBlocks(function (pngData, img) {
      data["image"] = pngData;

      if (img.remove) {
        img.remove();
      }

      _this13._postRetry(data, "updateSubmission", 0, function (response) {
        if (response.success) {
          _this13.setStatus("updateSubmission", StatusState.READY);
        } else {
          _this13.setStatus("updateSubmission", StatusState.FAILED, response.message);
        }

        if (!hiddenOverride && correct && callback) {
          callback(data["assignment_id"]);
        }
      });
    });
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/skulpt_modules/coverage.js":
/*!****************************************!*\
  !*** ./src/skulpt_modules/coverage.js ***!
  \****************************************/
/*! exports provided: $sk_mod_coverage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_coverage", function() { return $sk_mod_coverage; });
var $sk_mod_coverage = "\n\"\"\"\nHideous fill-in replacement for Coverage, leveraging some magic from the\nUtility function. The data this returns is false - it doesn't actually\ndescribe the missing lines and all lines; it just describes the traced lines.\nBut since Pedal doesn't need the other two, it works out fine when you do:\n\nstatements - missing\n\"\"\"\n\nimport utility\n\nclass Coverage:\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n    def save(self):\n        pass\n\n    def _analyze(self, filename: str):\n        lines = set(utility.trace_lines())\n        # lines will be the lines that were actually executed\n        return Analysis(None, len(lines), None, set(), lines)\n\n\nclass Numbers:\n    def __init__(self, n_missing, n_statements, pc_covered):\n        self.n_missing = n_missing\n        self.n_statements = n_statements\n        self.pc_covered = pc_covered\n\n\nclass Analysis:\n    def __init__(self, n_missing, n_statements, pc_covered, missing, statements):\n        self.missing = missing\n        self.statements = statements\n        self.numbers = Numbers(n_missing, n_statements, pc_covered)\n\n\nclass python:\n    def get_python_source(self):\n        return None\n";

/***/ }),

/***/ "./src/skulpt_modules/image.js":
/*!*************************************!*\
  !*** ./src/skulpt_modules/image.js ***!
  \*************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "image"
  };

  if (!Sk.PIL) {
    Sk.PIL = {
      assets: {}
    };
  } // InstantPromise is a workaround to allow usage of the clean promise-style
  // then/catch syntax but to instantly call resolve the then/catch chain so we
  // can avoid creating Suspensions in unnecessary cases.  This is desirable
  // because Suspensions have a fairly large negative impact on overall
  // performance.  These 'instant promises' come into play when a tracer()
  // call is made with a value other than 1.  When tracer is 0 or greater than 1
  // , we can bypass the creation of a Suspension and proceed to the next line of
  // code immediately if the current line is not going to involve a screen
  // update. We determine if a real promise or InstantPromise is necessary by
  // checking FrameManager.willRenderNext()


  function InstantPromise(err, result) {
    this.lastResult = result;
    this.lastError = err;
  }

  InstantPromise.prototype.then = function (cb) {
    if (this.lastError) {
      return this;
    }

    try {
      this.lastResult = cb(this.lastResult);
    } catch (e) {
      this.lastResult = undefined;
      this.lastError = e;
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  InstantPromise.prototype["catch"] = function (cb) {
    if (this.lastError) {
      try {
        this.lastResult = cb(this.lastError);
        this.lastError = undefined;
      } catch (e) {
        this.lastResult = undefined;
        this.lastError = e;
      }
    }

    return this.lastResult instanceof Promise ? this.lastResult : this;
  };

  var buildImage = function buildImage(imageData) {};

  function getAsset(name) {
    return new Promise(function (resolve, reject) {
      if (Sk.PIL.assets[name] !== undefined) {
        //return Sk.PIL.assets[name];
        resolve(Sk.PIL.assets[name]);
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
          Sk.PIL.assets[name] = img;
          resolve(img);
        };

        img.onerror = function () {
          //throw new Error("Failed to load asset: " + name);
          reject(name);
        };

        img.src = name;
      }
    });
  }

  var image = function image($gbl, $loc) {
    // open(filename) or open(url)
    // show()
    $loc.__init__ = new Sk.builtin.func(function (self, file_or_url) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("file_or_url", "string", Sk.builtin.checkString(file_or_url));
      self.file_or_url = file_or_url; // TODO: Change to suspension

      var imagePromise = getAsset(Sk.ffi.remapToJs(file_or_url));
      var susp = new Sk.misceval.Suspension();
      self.image = Sk.builtin.none.none$;

      susp.resume = function () {
        if (susp.data["error"]) {
          //throw new Sk.builtin.IOError(susp.data["error"].message);
          throw susp.data["error"];
        } else {//return self.image;
        }
      };

      susp.data = {
        type: "Sk.promise",
        promise: imagePromise.then(function (value) {
          self.image = value;
          self.canvas = document.createElement("canvas");
          self.canvas.width = self.image.width;
          self.canvas.height = self.image.height;
          self.canvas.getContext("2d").drawImage(self.image, 0, 0, self.image.width, self.image.height);
          self.pixels = self.canvas.getContext("2d").getImageData(0, 0, self.image.width, self.image.height).data; //return value;
        }, function (err) {
          self.image = "";
          throw err; //return err;
        })
      };
      return susp;
    });
    $loc.show = new Sk.builtin.func(function (self) {
      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      var consoleData = {
        image: self.image,
        file_or_url: self.file_or_url
      };
      Sk.console.printPILImage(consoleData);
    });
    $loc.flip = new Sk.builtin.func(function (self) {
      self.image.style.transform = "scaleX(-1)";

      if (Sk.console === undefined) {
        throw new Sk.builtin.NameError("Can not resolve drawing area. Sk.console is undefined!");
      }

      return self;
    });
  };

  mod.Image = Sk.misceval.buildClass(mod, image, "Image", []);
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/pedal_tracer.js":
/*!********************************************!*\
  !*** ./src/skulpt_modules/pedal_tracer.js ***!
  \********************************************/
/*! exports provided: $pedal_tracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$pedal_tracer", function() { return $pedal_tracer; });
var $pedal_tracer = "\n\n\"\"\"\nWraps the tracer module in Pedal\n\"\"\"\n\nimport os\nimport utility\n        \nclass SandboxBasicTracer:\n    \"\"\"\n\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self.filename = \"student.py\"\n        self.code = None\n\n    def as_filename(self, filename, code):\n        if os.path.isabs(filename):\n            self.filename = filename\n        else:\n            self.filename = os.path.abspath(filename)\n        self.code = code\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        pass\n\nclass SandboxNativeTracer(SandboxBasicTracer):\n    \"\"\"\n    Tracks lines covered and function calls. Possibly other things? We could track variables, if that\n    was something people wanted.\n\n    TODO: Handle multiple submission files?\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        #self.calls = utility.trace_calls()\n        self.lines = utility.trace_lines()\n        self.step_index = len(utility.trace_lines())\n    \n    def get_calls(self):\n        return utility.trace_calls()\n    \n    calls = property(get_calls)\n    \n    def __enter__(self):\n        utility.start_trace(self)\n\n    def __exit__(self, exc_type, exc_val, traceback):\n        utility.stop_trace(self)\n\nTRACER_STYLES = {\n    'none': SandboxBasicTracer,\n    'native': SandboxNativeTracer\n}\n\n";

/***/ }),

/***/ "./src/skulpt_modules/sk_mod_instructor.js":
/*!*************************************************!*\
  !*** ./src/skulpt_modules/sk_mod_instructor.js ***!
  \*************************************************/
/*! exports provided: $sk_mod_instructor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$sk_mod_instructor", function() { return $sk_mod_instructor; });
/**
 * Skulpt Module for holding the Instructor API.
 *
 * This module is loaded in by getting the functions' source code from toString.
 * Isn't that crazy?
 *
 *
 */
var $sk_mod_instructor = function $sk_mod_instructor() {
  // Main module object that gets returned at the end.
  var mod = {};
  var none = Sk.builtin.none.none$;
  var prior = null;
  mod.timeit = new Sk.builtin.func(function (name) {
    Sk.builtin.pyCheckArgs("timeit", arguments, 1, 1);
    var difference;

    if (prior === null) {
      difference = 0;
    } else {
      difference = Date.now() - prior;
    }

    console.log(Sk.ffi.remapToJs(name), difference / 1000);
    prior = Date.now();
  });
  /**
   * Logs feedback to javascript console
   */

  mod.console_log = new Sk.builtin.func(function () {
    console.log(Array.prototype.slice.call(arguments).map(Sk.ffi.remapToJs));
  });
  /**
   * Logs debug to javascript console
   */

  mod.console_debug = new Sk.builtin.func(function () {
    console.log(arguments);
  });
  /**
   * This function coverts the output in the student report to a python 
   * list and returns it.
  **/

  mod.get_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var output = Sk.executionReports["student"]["output"]();
      output = output.map(function (item) {
        return item.toSkulpt();
      });
      return new Sk.builtin.list(output);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  /**
   * This function resets the output, particularly useful if the student
   * code is going to be rerun.
   */

  mod.reset_output = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("reset_output", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      Sk.executionReports["student"].output.removeAll();
    }

    return Sk.builtin.none.none$;
  });
  /*mod.queue_input = new Sk.builtin.func(function() {
      Sk.builtin.pyCheckArgs("queue_input", arguments, 1, Infinity);
      let args = arguments;
      for (let i = args.length-1; i >= 0; i--) {
          let input = args[i];
          Sk.builtin.pyCheckType("input", "string", Sk.builtin.checkString(input));
          Sk.queuedInput.push(Sk.ffi.remapToJs(input));
      }
  });*/

  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_program = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_program", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["verifier"].code);
  });
  /**
   * This function is called by instructors to get the students' code as a string.
  **/

  mod.get_evaluation = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_evaluation", arguments, 0, 0);
    return Sk.ffi.remapToPy(Sk.executionReports["student"].evaluation || "");
  });
  mod.trace_lines = new Sk.builtin.func(function () {
    if (Sk.executionReports["student"].success) {
      var lines = Sk.executionReports["student"].realLines;
      return Sk.ffi.remapToPy(lines);
    } else {
      return new Sk.builtin.list([]);
    }
  });
  mod.trace_calls = new Sk.builtin.func(function () {
    //console.log("--", Sk.executionReports["student"]);
    //console.log("CHECKING CALLS", Sk.executionReports['student'].success);
    if (Sk.executionReports["student"].success) {
      var calls = Sk.executionReports["student"].calls;
      return Sk.ffi.remapToPy(calls);
    }

    return new Sk.builtin.dict([]);
  });
  mod.start_trace = new Sk.builtin.func(function () {
    //console.log("START/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    if (Sk.beforeCall === null) {
      Sk.beforeCall = Sk.beforeCallBackup;
    }

    Sk.executionReports["student"].tracing.push(true); //console.log("START/END", Sk.beforeCall, Sk.executionReports.student.tracing);
  });
  mod.stop_trace = new Sk.builtin.func(function () {
    //console.log("STOP/BEGIN", Sk.beforeCall, Sk.executionReports.student.tracing);
    Sk.executionReports["student"].tracing.pop();

    if (Sk.executionReports["student"].tracing.length === 0) {
      Sk.beforeCall = null;
    } //console.log("STOP/END", Sk.beforeCall, Sk.executionReports.student.tracing);

  });
  /**
   *
   */

  mod.get_student_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_error", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      return new Sk.builtin.tuple([none, none]);
    } else {
      var error = Sk.executionReports["student"].error,
          position = {};

      if (error && error.traceback && error.traceback.length > 0) {
        position["line"] = error.traceback[0].lineno;
      } else {
        error = none;
      }

      position = Sk.ffi.remapToPy(position);
      return new Sk.builtin.tuple([error, position]);
    }
  });
  mod.had_execution_time_error = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("had_execution_time_error", arguments, 0, 0);
    return !Sk.executionReports["student"].success && Sk.executionReports["student"].error && Sk.executionReports["student"].error.tp$name === "TimeLimitError";
  });
  var backupTime = undefined;
  mod.limit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("limit_execution_time", arguments, 0, 0);
    backupTime = Sk.execLimit;

    if (Sk.execLimitFunction) {
      Sk.execLimit = Sk.execLimitFunction();
      Sk.execStart = Date.now();
    }
  });
  mod.unlimit_execution_time = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("unlimit_execution_time", arguments, 0, 0);
    Sk.execLimit = backupTime;
    Sk.execStart = Date.now();
  });
  mod.suppress_scrolling = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("suppress_scrolling", arguments, 0, 0);
    Sk.executionReports.instructor.scrolling = true;
  });
  /*
  def hist(self, data, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Histogram', 'values': data, 'label': label})
  def plot(self, xs, ys=None, **kwargs):
      label = kwargs.get('label', None)
      if ys == None:
          self.active_plot['data'].append({'type': 'Line', 
                                          'x': range(len(xs)), 'y': xs, 'label': label})
      else:
          self.active_plot['data'].append({'type': 'Line', 'x': xs, 'y': ys, 'label': label})
  def scatter(self, xs, ys, **kwargs):
      label = kwargs.get('label', None)
      self.active_plot['data'].append({'type': 'Scatter', 'x': xs, 'y': ys, 'label': label})
  */

  mod.get_plots = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_plots", arguments, 0, 0);

    if (Sk.executionReports["student"].success) {
      var outputs = Sk.executionReports["student"]["output"]();
      outputs = outputs.filter(function (output) {
        return output.type === "plot";
      }).map(function (graph) {
        return {
          "data": graph.content.map(function (plot) {
            var newPlot = {
              "type": plot.type,
              "label": ""
            };

            if (plot.type === "line" || plot.type === "scatter") {
              newPlot["x"] = plot.data.map(function (v) {
                return v.x;
              });
              newPlot["y"] = plot.data.map(function (v) {
                return v.y;
              });
            } else if (plot.type === "hist") {
              newPlot["values"] = plot.data;
            }

            return newPlot;
          }),
          "xlabel": "",
          "ylabel": "",
          "title": "",
          "legend": false
        };
      });
      return Sk.ffi.remapToPy(outputs);
    } else {
      return Sk.ffi.remapToPy([]);
    }
  }); // Provides `student` as an object with all the data that the student declared.

  mod.StudentData = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self) {
      //self.data = Sk.builtin.dict();
      var newDict = new Sk.builtin.dict();
      Sk.abstr.sattr(self, new Sk.builtin.str("data"), newDict, true);
      self.module = Sk.executionReports["student"].results;

      if (self.module !== undefined) {
        self.module = self.module.$d;

        for (var key in self.module) {
          if (self.module.hasOwnProperty(key)) {
            Sk.abstr.objectSetItem(newDict, Sk.ffi.remapToPy(Sk.unfixReserved(key)), self.module[key]);
          }
        }
      } else {
        self.module = {};
      }

      return Sk.builtin.none.none$;
    });

    var call_f = function call_f(kwa) {
      Sk.builtin.pyCheckArgsLen("call", arguments.length, 1, Infinity, true, true);
      var args = Array.prototype.slice.call(arguments, 1);
      var kwargs = new Sk.builtins.dict(kwa);
      var self = args[0];
      var functionName = args[1];
      args = args.slice(2);
      var inputs = kwargs.mp$lookup(new Sk.builtin.str("inputs"));

      if (inputs !== undefined) {
        inputs = Sk.ffi.remapToJs(inputs);

        if (inputs.constructor === Array) {
          inputs.forEach(function (item) {
            Sk.queuedInput.push(item);
          });
        } else {
          Sk.queuedInput.push(input);
        }
      }

      var data = self.tp$getattr(new Sk.builtin.str("data"));
      var functionObject = data.mp$lookup(functionName);
      var result = functionObject.tp$call(args);
      return result;
    };

    call_f.co_kwargs = true; //call_f.co_varnames = ["self", "function"];

    call_f.co_name = new Sk.builtin.str("call");
    $loc["call_$rn$"] = new Sk.builtin.func(call_f);
    $loc["__repr__"] = new Sk.builtin.func(function (self) {
      return new Sk.builtin.str("");
    });
    $loc.get_names_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_names_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            //console.log(exclude_builtins);
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(Sk.ffi.remapToPy(Sk.unfixReserved(property)));
          }
        }
      }

      return new Sk.builtin.list(result);
    });
    $loc.get_values_by_type = new Sk.builtin.func(function (self, type, exclude_builtins) {
      Sk.builtin.pyCheckArgs("get_values_by_type", arguments, 2, 3);

      if (exclude_builtins === undefined) {
        exclude_builtins = true;
      } else {
        Sk.builtin.pyCheckType("exclude_builtins", "boolean", Sk.builtin.checkBool(exclude_builtins));
        exclude_builtins = Sk.ffi.remapToJs(exclude_builtins);
      }

      var result = [];

      for (var property in self.module) {
        if (self.module.hasOwnProperty(property)) {
          if (self.module[property].tp$name === type.tp$name) {
            if (exclude_builtins && property.startsWith("__")) {
              continue;
            }

            result.push(self.module[property]);
          }
        }
      }

      return new Sk.builtin.list(result);
    });
  }, "StudentData");
  mod.student = Sk.misceval.callsimOrSuspend(mod.StudentData);
  mod.get_student_data = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    return mod.student;
  });
  mod.set_instructions = new Sk.builtin.func(function (newInstructions) {
    Sk.builtin.pyCheckArgs("set_instructions", arguments, 1, 2);
    newInstructions = Sk.ffi.remapToJs(newInstructions);
    Sk.executionReports["model"].display.changedInstructions(newInstructions);
  });
  mod.get_model_info = new Sk.builtin.func(function (keys) {
    Sk.builtin.pyCheckArgs("get_model_info", arguments, 1, 1);
    var model = Sk.executionReports["model"];
    keys = Sk.ffi.remapToJs(keys).split(".");

    for (var i = 0; i < keys.length; i++) {
      model = model[keys[i]];
    }

    return Sk.ffi.remapToPy(model());
  });
  mod.clear_existing_student_imports = new Sk.builtin.func(function () {
    Sk.builtin.pyCheckArgs("get_student_data", arguments, 0, 0);
    Sk.clearExistingStudentImports();
  });
  return mod;
};

/***/ }),

/***/ "./src/skulpt_modules/weakref.js":
/*!***************************************!*\
  !*** ./src/skulpt_modules/weakref.js ***!
  \***************************************/
/*! exports provided: $builtinmodule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$builtinmodule", function() { return $builtinmodule; });
var $builtinmodule = function $builtinmodule(name) {
  var mod, sampleWrapper;
  mod = {
    __name__: "weakref"
  };
  /*mod.WeakSet = Sk.abstr.buildNativeClass("weakref.WeakSet", {
      constructor: function WeakSet()
  });*/

  var WeakSet = function WeakSet($gbl, $loc) {
    $loc.__init__ = new Sk.builtin.func(function (self, data) {
      Sk.builtin.pyCheckArgs("__init__", arguments, 2, 2);
      Sk.builtin.pyCheckType("data", "iterable", Sk.builtin.checkIterable(data));
      self.data = [];
      var iter = Sk.abstr.iter(data);
      var next;

      do {
        next = Sk.abstr.iternext(iter);

        if (next !== undefined) {
          self.data.push(new WeakRef(next));
        }
      } while (next !== undefined);

      return Sk.builtin.none.none$;
    });
    $loc.__iter__ = new Sk.builtin.func(function (self) {
      var viewOfData = [];

      for (var i = 0; i < self.data.length; i++) {
        var item = self.data[i].deref();

        if (item !== undefined) {
          viewOfData.push(item);
        }
      }

      self.data = viewOfData;
      return Sk.abstr.iter(new Sk.builtin.list(viewOfData));
    });
    /*$loc.next$ = new Sk.builtin.func(function (self) {
        return self.tp$iter();
    });*/

    $loc.add = new Sk.builtin.func(function (self, item) {
      self.data.push(new WeakRef(item));
    });
  };

  mod.WeakSet = Sk.misceval.buildClass(mod, WeakSet, "WeakSet", []);
  return mod;
};

/***/ }),

/***/ "./src/storage.js":
/*!************************!*\
  !*** ./src/storage.js ***!
  \************************/
/*! exports provided: LocalStorageWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalStorageWrapper", function() { return LocalStorageWrapper; });
var LOCAL_STORAGE_REF;

try {
  LOCAL_STORAGE_REF = localStorage;
  var mod = "BLOCKPY_LOCALSTORAGE_TEST";
  LOCAL_STORAGE_REF.setItem(mod, mod);
  LOCAL_STORAGE_REF.removeItem(mod);
} catch (e) {
  LOCAL_STORAGE_REF = {
    _data: {},
    setItem: function setItem(id, val) {
      return this._data[id] = String(val);
    },
    getItem: function getItem(id) {
      return this._data.hasOwnProperty(id) ? this._data[id] : null;
    },
    removeItem: function removeItem(id) {
      return delete this._data[id];
    },
    clear: function clear() {
      return this._data = {};
    }
  };
}
/**
 * Helper object for interfacing with the LocalStorage. The LocalStorage
 * browser API allows for offline storage. That API is very unsophisticated,
 * and is essentially a lame key-value store. This object sits on top
 * and provides a number of useful utilities, including rudimentarycache
 * cache expiration.
 *
 * @constructor
 * @this {LocalStorageWrapper}
 * @param {String} namespace - A namespace to use in grouping access to localstorage. This keeps access clean and organized, while also making it possible to have multiple LocalStorage connections.
 */


function LocalStorageWrapper(namespace) {
  this.namespace = namespace;
}
/**
 * A method for adding a key/value pair to LocalStorage.
 * Note that both parameters must be strings (JSON.stringify is your friend).
 *
 * @param {String} key - The name of the key.
 * @param {String} value - The value.
 */

LocalStorageWrapper.prototype.set = function (key, value) {
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_value", value);
  LOCAL_STORAGE_REF.setItem(this.namespace + "_" + key + "_timestamp", $.now());
};
/**
 * A method for removing a key from LocalStorage.
 *
 * @param {String} key - The name of the key to remove.
 */


LocalStorageWrapper.prototype.remove = function (key) {
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_value");
  LOCAL_STORAGE_REF.removeItem(this.namespace + "_" + key + "_timestamp");
};
/**
 * A method for retrieving the value associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 */


LocalStorageWrapper.prototype.get = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value");
};
/**
 * A method for retrieving the time associated with the given key.
 *
 * @param {String} key - The name of the key to retrieve the time for.
 * @returns {Integer} - The timestamp (local epoch) when the key was last set.
 */


LocalStorageWrapper.prototype.getTime = function (key) {
  return parseInt(LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp"));
};
/**
 * A method for retrieving the value associated with the given key.
 * If the key does not exist, then the default value is used instead.
 * This default will be set.
 *
 * @param {String} key - The name of the key to retrieve the value for.
 * @param {String} defaultValue - The default value to use. Must be a string.
 */


LocalStorageWrapper.prototype.getDefault = function (key, defaultValue) {
  if (this.has(key)) {
    return this.get(key);
  } else {
    this.set(key, defaultValue);
    return defaultValue;
  }
};
/**
 * A test for whether the given key is in LocalStorage.
 *
 * @param {String} key - The key to test existence for.
 */


LocalStorageWrapper.prototype.has = function (key) {
  return LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_value") !== null;
};
/**
 * A test for whether the server has the newer version. This function
 * assumes that the server trip takes about 5 seconds. This method
 * is largely deprecated.
 *
 * @param {String} key - The key to check.
 * @param {Integer} server_time - The server's time as an epoch (in milliseconds)
 */


LocalStorageWrapper.prototype.is_new = function (key, server_time) {
  var stored_time = LOCAL_STORAGE_REF.getItem(this.namespace + "_" + key + "_timestamp");
  return server_time >= stored_time + 5000;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "jquery")))

/***/ }),

/***/ "./src/trace.js":
/*!**********************!*\
  !*** ./src/trace.js ***!
  \**********************/
/*! exports provided: TRACE_HTML, BlockPyTrace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRACE_HTML", function() { return TRACE_HTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockPyTrace", function() { return BlockPyTrace; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TRACE_HTML = "\n\n<div class=\"blockpy-trace col-md-6 blockpy-panel\"\n            role=\"region\" aria-label=\"Trace\">\n    \n    <div class=\"clearfix\">\n        <strong>Trace: </strong>\n        \n        <!-- Feedback/Trace Visibility Control -->\n        <button type='button'\n                class='btn btn-sm btn-outline-secondary float-right blockpy-hide-trace'\n                data-bind=\"click: ui.secondRow.advanceState\">\n            <span class='fas fa-eye'></span> Hide Trace\n        </button>\n    </div>\n\n    <div class=\"input-group mb-3 blockpy-trace-controls\">\n        <div class=\"input-group-prepend\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.first\">\n                <span class='fas fa-step-backward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.backward\">\n                <span class='fas fa-backward'></span>\n            </button>\n            <span class=\"input-group-text\">Step:</span>\n            <span class=\"input-group-text\">\n                <span data-bind='text: execution.student.currentTraceStep'></span>\n                / <span data-bind='text: execution.student.lastStep'></span>\n            </span>\n        </div>\n        <div class=\"input-group-append\">\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.forward\">\n                <span class='fas fa-forward'></span>\n            </button>\n            <button type='button' class='btn btn-outline-secondary'\n                data-bind=\"click: ui.trace.last\">\n                <span class='fas fa-step-forward'></span>\n            </button>\n            <span class=\"input-group-text\">\n                <span data-bind='text: ui.trace.line'></span>\n            </span>\n        </div>\n    </div>\n    \n    <table class='table table-sm table-striped table-bordered table-hover'>\n        <caption>Current variables at this step</caption>\n        <thead>\n            <tr><th>Name</th><th>Type</th><th>Value</th></tr>\n        </thead>\n        <tbody data-bind=\"foreach: ui.trace.data().properties\">\n            <tr data-bind=\"visible: name != '__file__' && name != '__path__'\">\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: type\"></td>\n                <td>\n                    <code data-bind=\"text: value\"></code>\n                    <!-- ko if: type == \"List\" -->\n                    \n                    <a href=\"\" data-bind=\"click: //$root.viewExactValue(type, exact_value)\">\n                    <span class='glyphicon glyphicon-new-window'></span>\n                    </a>\n                    <!-- /ko -->\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    \n</div>\n";
var BlockPyTrace = /*#__PURE__*/function () {
  function BlockPyTrace(main, tag) {
    _classCallCheck(this, BlockPyTrace);

    this.main = main;
    this.tag = tag;
    this.IGNORED_GLOBALS = ["__name__", "__doc__", "__package__", "classmethod", "property", "staticmethod", "$free", "$cell"]; // this.trace.click(this.buildTraceTable.bind(this));
  }
  /**
   * Consume a set of variables traced from the execution and parse out any
   * global variables and modules.
   *
   * @param {Object} variables - a mapping of variable names to their Skupt value.
   */


  _createClass(BlockPyTrace, [{
    key: "parseGlobals",
    value: function parseGlobals(variables) {
      var result = [];
      var modules = [];
      console.log(variables);

      if (!this.main.model.display.traceExecution()) {
        /*if ("$cell" in variables) {
            variables = {...variables, ...variables.$cell};
        }*/

        /*if ("$free" in variables) {
            variables = {...variables, ...variables.$free};
        }*/
        for (var property in variables) {
          var value = variables[property];

          if (this.IGNORED_GLOBALS.indexOf(property) === -1 && value !== undefined) {
            property = property.replace("_$rw$", "").replace("_$rn$", "");
            var parsed = void 0;

            try {
              parsed = BlockPyTrace.parseValue(property, value);
            } catch (_unused) {
              parsed = {
                "name": property,
                "type": "Unknown",
                "value": value.toString()
              };
            }

            if (parsed !== null) {
              result.push(parsed);
            } else if (value.constructor === Sk.builtin.module) {
              modules.push(value.$d.__name__.v);
            }
          }
        }
      }

      return {
        "properties": result,
        "modules": modules
      };
    }
  }], [{
    key: "parseValue",

    /**
     * Convert a Skulpt value into a more easily printable object.
     *
     * @param {String} property
     * @param {Object} value - the skulpt value
     */
    value: function parseValue(property, value, fullLength) {
      if (value === undefined) {
        return {
          "name": property,
          "type": "Unknown",
          "value": "Undefined"
        };
      }

      switch (property) {
        case "dataclass":
          return {
            name: property,
            type: "Decorator",
            value: "<dataclass decorator>"
          };
      }

      switch (value.constructor) {
        case Sk.builtin.func:
          return {
            "name": property,
            "type": "Function",
            "value": value.func_code.co_varnames !== undefined ? " Arguments: " + value.func_code.co_varnames.join(", ") : " No arguments"
          };

        case Sk.builtin.module:
          return null;

        case Sk.builtin.str:
          if (fullLength || value.v.length <= 32) {
            return {
              "name": property,
              "type": "String",
              "value": value.$r().v
            };
          } else {
            return {
              "name": property,
              "type": "String",
              "value": "[" + value.sq$length() + " characters not shown]"
            };
          }

        case Sk.builtin.none:
          return {
            "name": property,
            "type": "None",
            "value": "None"
          };

        case Sk.builtin.bool:
          return {
            "name": property,
            "type": "Boolean",
            "value": value.$r().v
          };

        case Sk.builtin.nmber:
          return {
            "name": property,
            "type": "int" === value.skType ? "Integer" : "Float",
            "value": value.$r().v
          };

        case Sk.builtin.int_:
          return {
            "name": property,
            "type": "Integer",
            "value": value.$r().v
          };

        case Sk.builtin.float_:
          return {
            "name": property,
            "type": "Float",
            "value": value.$r().v
          };

        case Sk.builtin.tuple:
          return {
            "name": property,
            "type": "Tuple",
            "value": value.$r().v
          };

        case Sk.builtin.list:
          if (value.v.length <= 20) {
            return {
              "name": property,
              "type": "List",
              "value": value.$r().v,
              "exact_value": value
            };
          } else {
            return {
              "name": property,
              "type": "List",
              "value": "[... " + value.v.length + " elements ...]",
              "exact_value": value
            };
          }

        case Sk.builtin.dict:
          return {
            "name": property,
            "type": "Dictionary",
            "value": value.$r().v
          };

        case Number:
          return {
            "name": property,
            "type": value % 1 === 0 ? "Integer" : "Float",
            "value": value
          };

        case String:
          return {
            "name": property,
            "type": "String",
            "value": value
          };

        case Boolean:
          return {
            "name": property,
            "type": "Boolean",
            "value": value ? "True" : "False"
          };

        default:
          return {
            "name": property,
            "type": value.tp$name === undefined ? value : value.tp$name,
            "value": value.$r === undefined ? value : value.$r().v
          };
      }
    }
  }]);

  return BlockPyTrace;
}(); // TODO: viewExactValue

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/*! exports provided: indent, slug, capitalize, encodeHTML, firstDefinedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indent", function() { return indent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slug", function() { return slug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeHTML", function() { return encodeHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstDefinedValue", function() { return firstDefinedValue; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Determines if the element is in the list.
 * @param {anything} needle - The element to look for.
 * @param {Array} haystack - The list to search.
 * @return {Boolean} Whether the element exists
 */
function arrayContains(needle, haystack) {
  return haystack.indexOf(needle) > -1;
}
/**
 * Remove duplicate values from an array, preserving order.
 * Creates a new array, so is non-destructive.
 * Courtesy:
 * https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items
 *
 * @param {Array} array - The array to uniquify. Elements compared with ===.
 */


function arrayUnique(array) {
  var a = array.concat();

  for (var i = 0; i < a.length; ++i) {
    for (var j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
}
/**
 * A helper function for extending an array based
 * on an "addArray" and "removeArray". Any element
 * found in removeArray is removed from the first array
 * and all the elements of addArray are added.
 * Any duplicate items are removed.
 * Creates a new array, so is non-destructive.
 *
 * @param {Array} array - the array to manipulate
 * @param {Array} addArray - the elements to add to the array
 * @param {Array} removeArray - the elements to remove from the array
 * @return {Array} The modified array
 */


function expandArray(array, addArray, removeArray) {
  var copyArray = array.filter(function (item) {
    return removeArray.indexOf(item) === -1;
  });
  return arrayUnique(copyArray.concat(addArray));
}
/**
 * Deeply clones a node
 * @param {Node} node A node to clone
 * @return {Node} A clone of the given node and all its children
 */


function cloneNode(node) {
  // If the node is a text node, then re-create it rather than clone it
  var clone = node.nodeType == 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false); // Recurse     

  var child = node.firstChild;

  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }

  return clone;
}
/**
 * Indents the given string by 4 spaces. This correctly handles multi-line strings.
 *
 * @param {String} str - The string to be manipulated.
 * @returns {String} The string with four spaces added at the start of every new line.
 */


function indent(str) {
  return str.replace(/^(?=.)/gm, "    ");
}
/**
 * Turns spaces into underscores in the string, makes it lowercase.
 * @param {String} str - the string to be manipulated
 * @returns {string}
 */

function slug(str) {
  return str.replace(/\s/g, "_").toLowerCase();
}
/**
 * Capitalize the first letter of a string.
 * @param {String} s - The string to be capitalized.
 * @returns {string}
 */

function capitalize(s) {
  if (typeof s !== "string") {
    return "";
  }

  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * Return a random integer between [`min`, `max`].
 * 
 * @param {number} min - The lowest possible integer.
 * @param {number} max - The highest possible integer (inclusive).
 * @returns {number} A random integer.
 */

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Encodes some text so that it can be safely written into an HTML box.
 * This includes replacing special HTML characters (&, <, >, etc.).
 *
 * @param {string} str - The text to be converted.
 * @return {string} The HTML-safe text.
 */


function encodeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
/**
 * Shuffle the blocks in the workspace
 */

if (typeof Blockly !== "undefined") {
  Blockly.WorkspaceSvg.prototype.shuffle = function () {
    var metrics = this.getMetrics();
    var width = metrics.viewWidth / 2,
        height = metrics.viewHeight;
    var blocks = this.getTopBlocks(false);
    var y = 5,
        x = 0,
        maximal_increase = height / blocks.length;

    for (var i = 0; i < blocks.length; i++) {
      // Get a block
      var block = blocks[i];
      var properties = block.getRelativeToSurfaceXY();

      if (i == 0) {
        x = 5;
      } else {
        x = -properties.x + randomInteger(10, width);
      }

      block.moveBy(x, -properties.y + y);
      y = y + randomInteger(5, maximal_increase);
    }
  };
}
/**
 * Move elements from one array to another based on a conditional check.
 * https://stackoverflow.com/questions/31887967/javascript-move-objects-from-one-array-to-another-best-approach
 */


function moveElements(source, target, moveCheck) {
  for (var i = 0; i < source.length; i++) {
    var element = source[i];

    if (moveCheck(element)) {
      source.splice(i, 1);
      target.push(element);
      i--;
    }
  }
}

function firstDefinedValue() {
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }

  return undefined;
}
/**
 * This function checks if the given object is one of the Sk.builtin objects
 * TODO: make this so we don't have to explicitly put out every option
 *          one possible thing we could do is get a string version of the 
 *          of the constructor and look for the substring "return new Sk.builtin"
 *          But I don't know how reliable that is.  Rather, it's kind of hackish.
 *          Should tehoretically belong in Sk.ffi
 * @param {object} obj - the object to be examined
 * @return {boolean} true if the object is one of the Sk.builtin types
**/

function isSkBuiltin(obj) {
  return obj instanceof Sk.builtin.dict || obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple || obj instanceof Sk.builtin.bool || obj instanceof Sk.builtin.int_ || obj instanceof Sk.builtin.float_ || obj instanceof Sk.builtin.str || obj instanceof Sk.builtin.lng; //var cons_str = obj.constructor + "";
  //return cons_str.indexOf("return new Sk.builtin") !== -1;
}

function isAstNode(obj) {
  return obj instanceof Object && "_astname" in obj;
}
/**
 * Should theoretically belong in Sk.ffi, but I put it here instead to not mess up the skulpt files
 * like the normal Sk.ffi.remapToPy, it doesn't work for functions or more complex objects, but it handles
 * cases where the types in obj are a mix of python SIMPLE objects and SIMPLE normal javascript objects
 * @param {object} obj - the object to be converted
 * @return {Sk.builtin.???} - returns the corresponding python object, dropping all functions and things it can't convert
**/


function mixedRemapToPy(obj) {
  var k;
  var kvs;
  var i;
  var arr; //@TODO: should theoretically check if the object is a pyhon dict or array with js objects

  if (isSkBuiltin(obj)) {
    //object is already python ready
    return obj;
  } else if (Object.prototype.toString.call(obj) === "[object Array]") {
    //object is actually a javascript array
    arr = [];

    for (i = 0; i < obj.length; ++i) {
      //for each object, convert it to a python object if it isn't one already
      var subval = obj[i];

      if (!isSkBuiltin(subval)) {
        arr.push(mixedRemapToPy(subval));
      } else {
        arr.push(subval);
      }
    }

    return new Sk.builtin.list(arr);
  } else if (obj === null) {
    //null object
    return Sk.builtin.none.none$;
  } else if (_typeof(obj) === "object") {
    if (!isSkBuiltin(obj)) {
      //assuming it's a standard dictionary
      kvs = []; //Sk.builtin.dict uses an array of key-value,key-value...

      for (k in obj) {
        //convert the key if it needs to be converted
        kvs.push(mixedRemapToPy(k)); //covert corresponding value if it needs to be converted

        kvs.push(mixedRemapToPy(obj[k]));
      } //create the new dictionary


      return new Sk.builtin.dict(kvs);
    } else {
      return obj;
    }
  } else if (typeof obj === "string") {
    return new Sk.builtin.str(obj);
  } else if (typeof obj === "number") {
    return Sk.builtin.assk$(obj);
  } else if (typeof obj === "boolean") {
    return new Sk.builtin.bool(obj);
  } else if (typeof obj === "function") {
    return new Sk.builtin.str(obj.name);
  }
}

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;

/***/ }),

/***/ "knockout":
/*!*********************!*\
  !*** external "ko" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_knockout__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9ibG9ja3B5L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvYmxvY2tweS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jb3JnaXMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYmxvY2tweS5jc3MiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZGlhbG9nLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2Fic3RyYWN0X2VkaXRvci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2RlZmF1bHRfaGVhZGVyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL2ltYWdlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9qc29uLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL21hcmtkb3duLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3B5dGhvbi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci9xdWl6LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvci90YWdzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZWRpdG9yL3RleHQuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lZGl0b3IvdG9vbGJveC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VkaXRvcnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvY29uZmlndXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvZXZhbC5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9pbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX2NoYW5nZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9ldmFsLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL29uX3J1bi5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9vbl9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9lbmdpbmUvcnVuLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZW5naW5lL3NhbXBsZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2VuZ2luZS9zdHVkZW50LmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvZmVlZGJhY2suanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9maWxlcy5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy9jb3ZlcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3NrdWxwdF9tb2R1bGVzL2ltYWdlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvcGVkYWxfdHJhY2VyLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc2t1bHB0X21vZHVsZXMvc2tfbW9kX2luc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vYmxvY2tweS8uL3NyYy9za3VscHRfbW9kdWxlcy93ZWFrcmVmLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9ibG9ja3B5Ly4vc3JjL3RyYWNlLmpzIiwid2VicGFjazovL2Jsb2NrcHkvLi9zcmMvdXRpbGl0aWVzLmpzIiwid2VicGFjazovL2Jsb2NrcHkvZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly9ibG9ja3B5L2V4dGVybmFsIFwia29cIiJdLCJuYW1lcyI6WyJFRElUT1JfVkVSU0lPTiIsIkJsb2NrUHkiLCJjb25maWd1cmF0aW9uIiwiYXNzaWdubWVudCIsInN1Ym1pc3Npb24iLCJpbml0TW9kZWwiLCJ1bmRlZmluZWQiLCJzZXRBc3NpZ25tZW50IiwiaW5pdE1haW4iLCJpbml0VXRpbGl0aWVzIiwiaW5pdE1vZGVsTWV0aG9kcyIsInR1cm5PbkhhY2tzIiwiaW5pdEludGVyZmFjZSIsImFwcGx5TW9kZWwiLCJpbml0Q29tcG9uZW50cyIsIm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMiLCJzdGFydCIsImtleSIsImRlZmF1bHRWYWx1ZSIsImluaXRpYWxDb25maWd1cmF0aW9uXyIsImxvY2FsU2V0dGluZ3NfIiwiaGFzIiwiZ2V0IiwiTG9jYWxTdG9yYWdlV3JhcHBlciIsIm1vZGVsIiwidXNlciIsImlkIiwia28iLCJvYnNlcnZhYmxlIiwibmFtZSIsInJvbGUiLCJnZXRTZXR0aW5nIiwiY291cnNlSWQiLCJncm91cElkIiwiaW5zdHJ1Y3Rpb25zIiwidXJsIiwidHlwZSIsIkFzc2lnbWVudFR5cGUiLCJCTE9DS1BZIiwicG9pbnRzIiwic3RhcnRpbmdDb2RlIiwib25SdW4iLCJvbkNoYW5nZSIsIm9uRXZhbCIsImV4dHJhSW5zdHJ1Y3RvckZpbGVzIiwib2JzZXJ2YWJsZUFycmF5IiwibG9hZENvbmNhdGVuYXRlZEZpbGUiLCJleHRyYVN0YXJ0aW5nRmlsZXMiLCJmb3JrZWRJZCIsImZvcmtlZFZlcnNpb24iLCJvd25lcklkIiwidmVyc2lvbiIsInRhZ3MiLCJzYW1wbGVTdWJtaXNzaW9ucyIsInJldmlld2VkIiwiaGlkZGVuIiwiaXBSYW5nZXMiLCJzZXR0aW5ncyIsIm1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbCIsImNvZGUiLCJleHRyYUZpbGVzIiwiZW5kcG9pbnQiLCJzY29yZSIsImNvcnJlY3QiLCJzdWJtaXNzaW9uU3RhdHVzIiwiZ3JhZGluZ1N0YXR1cyIsImRpc3BsYXkiLCJmaWxlbmFtZSIsImluc3RydWN0b3IiLCJtdXRlUHJpbnRlciIsInB5dGhvbk1vZGUiLCJEaXNwbGF5TW9kZXMiLCJTUExJVCIsImhpc3RvcnlNb2RlIiwiYXV0b1NhdmUiLCJiaWdDb25zb2xlIiwicHJldmlvdXNDb25zb2xlSGVpZ2h0IiwiY3VycmVudENvbnNvbGVIZWlnaHQiLCJzZWNvbmRSb3dTZWNvbmRQYW5lbCIsIlNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucyIsIkZFRURCQUNLIiwicHJldmlvdXNTZWNvbmRSb3dTZWNvbmRQYW5lbCIsInRyYWNlRXhlY3V0aW9uIiwibG9hZGluZ0RhdGFzZXRzIiwiY2hhbmdlZEluc3RydWN0aW9ucyIsInRyaWdnZXJPbkNoYW5nZSIsImRpcnR5U3VibWlzc2lvbiIsImZ1bGxzY3JlZW4iLCJwYXNzY29kZSIsImNsZWFySW5wdXRzIiwicmVuZGVySW1hZ2VzIiwiZWRpdG9yVmVyc2lvbiIsInJlYWRPbmx5IiwidG9TdHJpbmciLCJ1cGxvYWRlZEZpbGVzIiwic3RhdHVzIiwibG9hZEFzc2lnbm1lbnQiLCJTdGF0dXNTdGF0ZSIsIlJFQURZIiwibG9hZEFzc2lnbm1lbnRNZXNzYWdlIiwibG9hZEhpc3RvcnkiLCJsb2FkSGlzdG9yeU1lc3NhZ2UiLCJsb2FkRmlsZSIsImxvYWRGaWxlTWVzc2FnZSIsImxvYWREYXRhc2V0IiwibG9hZERhdGFzZXRNZXNzYWdlIiwibG9nRXZlbnQiLCJsb2dFdmVudE1lc3NhZ2UiLCJzYXZlSW1hZ2UiLCJzYXZlSW1hZ2VNZXNzYWdlIiwic2F2ZUZpbGUiLCJzYXZlRmlsZU1lc3NhZ2UiLCJzYXZlQXNzaWdubWVudCIsInNhdmVBc3NpZ25tZW50TWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb24iLCJ1cGRhdGVTdWJtaXNzaW9uTWVzc2FnZSIsInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMiLCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSIsImxpc3RVcGxvYWRlZEZpbGVzIiwibGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlIiwiZG93bmxvYWRGaWxlIiwiZG93bmxvYWRGaWxlTWVzc2FnZSIsInVwbG9hZEZpbGUiLCJ1cGxvYWRGaWxlTWVzc2FnZSIsIm9uRXhlY3V0aW9uIiwiZXhlY3V0aW9uIiwicmVwb3J0cyIsIm91dHB1dCIsImlucHV0IiwiaW5wdXRJbmRleCIsInN0dWRlbnQiLCJjdXJyZW50U3RlcCIsImxhc3RTdGVwIiwiY3VycmVudExpbmUiLCJsYXN0TGluZSIsImN1cnJlbnRUcmFjZURhdGEiLCJjdXJyZW50VHJhY2VTdGVwIiwicmVzdWx0cyIsImdsb2JhbHMiLCJjYWxscyIsInN5c21vZHVsZXMiLCJmZWVkYmFjayIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxhYmVsIiwibGluZXNFcnJvciIsImxpbmVzVW5jb3ZlcmVkIiwiY2FsbGJhY2tzIiwic2VydmVyQ29ubmVjdGVkIiwiYmxvY2tseVBhdGgiLCJhdHRhY2htZW50UG9pbnQiLCJjb250YWluZXIiLCJ1cmxzIiwiY29uc3RhbnRzIiwiZ3VpIiwibWFrZUludGVyZmFjZSIsIiQiLCJodG1sIiwiYXNzaWdubWVudF9pZCIsImNvbXBvbmVudHMiLCJzZXJ2ZXIiLCJzYW1wbGVzIiwic3RhcnRpbmdfY29kZSIsImV4dHJhX3N0YXJ0aW5nX2ZpbGVzIiwibG9hZE5vU3VibWlzc2lvbiIsImdyYWRpbmdfc3RhdHVzIiwic3VibWlzc2lvbl9zdGF0dXMiLCJ1c2VyX2lkIiwiY291cnNlX2lkIiwiZXh0cmFfZmlsZXMiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsInJlc2V0SW50ZXJmYWNlIiwiZmlsZVN5c3RlbSIsImRpc21vdW50RXh0cmFGaWxlcyIsIndhc1NlcnZlckNvbm5lY3RlZCIsImZvcmtlZF9pZCIsImZvcmtlZF92ZXJzaW9uIiwiaXBfcmFuZ2VzIiwib25fY2hhbmdlIiwibmV3RmlsZSIsIm9uX2V2YWwiLCJvbl9ydW4iLCJvd25lcl9pZCIsImxvYWRUYWdzIiwibG9hZFNhbXBsZVN1Ym1pc3Npb25zIiwic2FtcGxlX3N1Ym1pc3Npb25zIiwiZXh0cmFfaW5zdHJ1Y3Rvcl9maWxlcyIsImxvYWRBc3NpZ25tZW50U2V0dGluZ3MiLCJsb2FkU3VibWlzc2lvbiIsImNvcmdpcyIsImxvYWREYXRhc2V0cyIsInB5dGhvbkVkaXRvciIsImJtIiwicmVmcmVzaCIsInNldFN0YXR1cyIsInNlbGYiLCJ1aSIsInNtYWxsTGF5b3V0IiwicHVyZUNvbXB1dGVkIiwiaXNHcmFkZXIiLCJpc0NoYW5nZWQiLCJjdXJyZW50IiwidXRpbGl0aWVzIiwibWFya2Rvd24iLCJyZXNldCIsIm1lbnUiLCJ2aXNpYmxlIiwib25seUludGVyYWN0aXZlIiwidGV4dEZ1bGxzY3JlZW4iLCJjbGlja0Z1bGxzY3JlZW4iLCJlZGl0SW5wdXRzIiwiZGlhbG9nIiwiRURJVF9JTlBVVFMiLCJ0b2dnbGVJbWFnZXMiLCJ0ZXh0RWRpdG9yIiwiZGlzYWJsZUltYWdlcyIsImVuYWJsZUltYWdlcyIsImNhbk1hcmtTdWJtaXR0ZWQiLCJjYW5DbG9zZSIsInRleHRNYXJrU3VibWl0dGVkIiwiaXNDb21wbGV0ZWQiLCJpc1N1Ym1pdHRlZCIsImNsaWNrTWFya1N1Ym1pdHRlZCIsImFsZXJ0IiwiZW5naW5lIiwiZGVsYXllZFJ1biIsInRvTG93ZXJDYXNlIiwic2hvd1F1ZXVlZElucHV0cyIsImhpZGVRdWV1ZWRJbnB1dHMiLCJzZWNvbmRSb3ciLCJ3aWR0aCIsImhpZGVUcmFjZUJ1dHRvbiIsImlzQWxsVmlzaWJsZSIsImhpZGVNaWRkbGVQYW5lbCIsImlzRmVlZGJhY2tWaXNpYmxlIiwiaXNUcmFjZVZpc2libGUiLCJUUkFDRSIsImlzQ29uc29sZVNob3dWaXNpYmxlIiwic3dpdGNoTGFiZWwiLCJhZHZhbmNlU3RhdGUiLCJjdXJyZW50UGFuZWwiLCJOT05FIiwibWFrZVdpZGUiLCJyZXN0b3JlUGFuZWwiLCJvbGRQYW5lbCIsInNpemUiLCJoaWRlRXZhbHVhdGUiLCJBQ1RJVkUiLCJiYWRnZSIsInRyYWNlIiwiaGlnaGxpZ2h0ZWRMaW5lIiwic3RlcCIsInRyYWNlRGF0YSIsImxpbmUiLCJmaXJzdCIsImJhY2t3YXJkIiwicHJldmlvdXMiLCJNYXRoIiwibWF4IiwiZm9yd2FyZCIsIm5leHQiLCJtaW4iLCJsYXN0IiwiZmlsZXMiLCJoaWRlRmlsZXMiLCJoYXNDb250ZW50cyIsInBhdGgiLCJzb21lIiwiZmlsZSIsImxlbmd0aCIsImFkZCIsIm5vcm1hbFRvb2xib3giLCJibG9ja0VkaXRvciIsIlRPT0xCT1hFUyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTYW1wbGVTdWJtaXNzaW9uIiwiQmxhbmsiLCJuZXdGaWxlRGlhbG9nIiwiZGVsZXRlRmlsZSIsInJlbmFtZSIsIm5ld05hbWUiLCJyZW5hbWVGaWxlIiwiZ2V0U3R1ZGVudENvZGUiLCJwcmVmaXhQeSIsImdldEZpbGUiLCJzdWZmaXhQeSIsImhhbmRsZSIsImV4dHJhU3R1ZGVudEZpbGVzIiwib2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUiLCJkaXNwbGF5RmlsZW5hbWUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZGl0b3JzIiwiZ2V0RWRpdG9yIiwidmlldyIsImhpZGVFZGl0b3JzIiwibWFwIiwic3Vic3RyIiwibWFrZU1vZGVsRmlsZSIsImNvbnRlbnRzIiwiY2FuU2F2ZSIsImNhbkRlbGV0ZSIsIlVOREVMRVRBQkxFX0ZJTEVTIiwiaW5kZXhPZiIsImNhblJlbmFtZSIsIlVOUkVOQU1BQkxFX0ZJTEVTIiwidXBsb2FkIiwiYmluZCIsImRvd25sb2FkIiwiaW1wb3J0RGF0YXNldCIsIm9wZW5EaWFsb2ciLCJweXRob24iLCJjb2RlTWlycm9yIiwic2V0T3B0aW9uIiwiZ2V0T3B0aW9uIiwidXBkYXRlTW9kZSIsIm5ld01vZGUiLCJvbGRQeXRob25Nb2RlIiwiaXNIaXN0b3J5QXZhaWxhYmxlIiwiaXNFbmRwb2ludENvbm5lY3RlZCIsInR1cm5PZmZIaXN0b3J5TW9kZSIsInVwZGF0ZUVkaXRvciIsInNldFJlYWRPbmx5IiwidHVybk9uSGlzdG9yeU1vZGUiLCJyZXNwb25zZSIsInN1Y2Nlc3MiLCJoaXN0b3J5IiwibG9hZCIsIkVSUk9SX0xPQURJTkdfSElTVE9SWSIsInRvZ2dsZUhpc3RvcnlNb2RlIiwibW92ZVRvU3RhcnQiLCJtb3ZlUHJldmlvdXMiLCJtb3ZlTmV4dCIsIm1vc3RSZWNlbnQiLCJtb3ZlVG9Nb3N0UmVjZW50IiwidXNlIiwiaW1hZ2VzIiwicmVsb2FkSW1hZ2VzIiwiYnlOYW1lIiwic2F2ZSIsImJ1aWxkRWRpdG9yIiwibmV3RE9NIiwiaW5kZXgiLCJuZXdFbGVtZW50IiwiZWRpdG9yIiwiZXhlY3V0ZSIsImlzUnVubmluZyIsInJ1bkxhYmVsIiwicnVuIiwiUHlnYW1lTGliIiwicnVubmluZyIsIlN0b3BQeWdhbWUiLCJldmFsdWF0ZSIsIm1lc3NhZ2VzIiwiY2FwaXRhbGl6ZSIsImZvcmNlIiwiZXZlbnQiLCJhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uIiwidGFyZ2V0IiwicGFyZW50IiwiZmFkZU91dCIsImZhZGVJbiIsImZyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJhc3NpZ25tZW50U3VibWlzc2lvbiIsInBhcnNlIiwicmVzdWx0IiwibG9hZEFzc2lnbm1lbnREYXRhXyIsImZpbGVOYW1lIiwicmVhZEFzVGV4dCIsInZhbCIsImZvb3RlciIsIm1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMiLCJTayIsImJ1aWx0aW5GaWxlcyIsImltYWdlTW9kdWxlIiwiYXBwbHlCaW5kaW5ncyIsIm1haW4iLCJ0ZXh0IiwiRWFzeU1ERSIsInByb3RvdHlwZSIsIkJsb2NrUHlEaWFsb2ciLCJmaW5kIiwiQmxvY2tQeUZlZWRiYWNrIiwiQmxvY2tQeVRyYWNlIiwiQmxvY2tQeUNvbnNvbGUiLCJCbG9ja1B5RW5naW5lIiwiQmxvY2tQeUZpbGVTeXN0ZW0iLCJFZGl0b3JzIiwiQmxvY2tQeVNlcnZlciIsIkJsb2NrUHlDb3JnaXMiLCJCbG9ja1B5SGlzdG9yeSIsInNob3ciLCJoaWRlIiwic3Vic2NyaWJlIiwiY2hhbmdlZCIsImFsdExvZ0VudHJ5IiwidXNlclN1cHBsaWVkUGFzc2NvZGUiLCJwcm9tcHQiLCJTVEFSVF9FVkFMX0hUTUwiLCJORVdfQ09OU09MRV9MSU5FX0hUTUwiLCJDT05TT0xFX0hUTUwiLCJDb25zb2xlTGluZVR5cGUiLCJURVhUIiwiSFRNTCIsIlBMT1QiLCJJTUFHRSIsIlBZR0FNRSIsIlRVUlRMRSIsIkVWQUwiLCJTVEFSVF9FVkFMIiwiVkFMVUUiLCJJTlBVVCIsIlRFU1RfQ0FTRSIsIkNvbnNvbGVMaW5lIiwiY29udGVudCIsIm9yaWdpbiIsImN1cnJGaWxlbmFtZSIsImV4ZWN1dGlvbkJ1ZmZlciIsImZmaSIsInJlbWFwVG9QeSIsInJlbW92ZSIsIkNvbnNvbGVMaW5lVHVydGxlIiwiYWRkQ2xhc3MiLCJ3aGVyZSIsInByZXBlbmQiLCJ0b3AiLCJvZmZzZXQiLCJzY3JvbGxUb3AiLCJDb25zb2xlTGluZVB5Z2FtZSIsInB5Z2FtZU9iaiIsImluaXRpYWxpemVkIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kIiwiY2xlYW51cCIsImNsZWFudXBGdW5jdGlvbiIsImxpc3RlbmVycyIsIkNvbnNvbGVMaW5lSW1hZ2UiLCJDb25zb2xlTGluZVBsb3QiLCJDb25zb2xlTGluZVRleHQiLCJlbmNvZGVkVGV4dCIsImVuY29kZUhUTUwiLCJ0cmltIiwibGluZURhdGEiLCJ0b29sdGlwIiwiQ29uc29sZUxpbmVWYWx1ZSIsIkNvbnNvbGVMaW5lSW5wdXQiLCJwcm9tcHRNZXNzYWdlIiwiaW5wdXRGb3JtIiwiaW5wdXRCdG4iLCJpbnB1dEdyb3VwIiwiaW5wdXRCb3giLCJpbnB1dE1zZyIsIm1ha2VJbnRlcmFjdGl2ZSIsImJ1dHRvbiIsInJlc29sdmVPbkNsaWNrIiwic3VibWl0dGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3VibWl0Rm9ybSIsInVzZXJJbnB1dHRlZFZhbHVlIiwicXVldWVkSW5wdXQiLCJwdXNoIiwicHJvcCIsImNsaWNrIiwia2V5dXAiLCJrZXlDb2RlIiwiZm9jdXMiLCJDb25zb2xlTGluZUV2YWx1YXRlIiwiQ29uc29sZUxpbmVTdGFydEV2YWx1YXRlIiwidGFnIiwicHJpbnRlclRhZyIsIk1JTklNVU1fV0lEVEgiLCJNSU5JTVVNX0hFSUdIVCIsIkRFRkFVTFRfSEVJR0hUIiwiaGVpZ2h0IiwiY2xlYXIiLCJyZW1vdmVBbGwiLCJsaW5lQnVmZmVyIiwicGxvdEJ1ZmZlciIsImVtcHR5IiwidHVydGxlTGluZSIsIlR1cnRsZUdyYXBoaWNzIiwiZ2V0VHVydGxlTGluZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiYXNzZXRzIiwibG9hZEFzc2V0IiwicHlnYW1lTGluZSIsInJlbmRlciIsImN1cnJlbnRQcmludGVyRGltZW5zaW9uIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJzYXZlVHVydGxlT3V0cHV0IiwiZGF0YVVybCIsInRvRGF0YVVSTCIsInBhZ2UiLCJlYWNoIiwiYXR0ciIsImxpbmVUZXh0IiwiZmx1c2giLCJjaGFyQXQiLCJzcGxpdExpbmVzIiwic3BsaXQiLCJhZGRDb250ZW50IiwiaSIsInBsb3RzIiwiaW1hZ2VEYXRhIiwiaW1hZ2UiLCJpbWFnZUJ1ZmZlciIsInZhbHVlIiwicHJpbnRlZFZhbHVlIiwiaW5wdXRCdWZmZXIiLCJzdGFydEV2YWx1YXRpb24iLCJhbmltYXRlIiwiX0lNUE9SVEVEX0RBVEFTRVRTIiwiX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTIiwic2V0QnV0dG9uTG9hZGVkIiwiYnRuIiwicmVtb3ZlQ2xhc3MiLCJsb2FkZWREYXRhc2V0cyIsInNpbGVudGx5IiwiaW1wb3J0cyIsImRhdGFzZXRzIiwiZm9yRWFjaCIsIkJsb2NrTWlycm9yQmxvY2tFZGl0b3IiLCJFWFRSQV9UT09MUyIsImFwcGx5Iiwic2x1ZyIsIndoZW4iLCJkb25lIiwiZm9yY2VCbG9ja1JlZnJlc2giLCJyZW1ha2VUb29sYm94IiwiZmFpbCIsImFyZ3VtZW50cyIsImVycm9yIiwiYWx3YXlzIiwiZmluYWxpemVTdWJzY3JpcHRpb25zIiwidXJsX3JldHJpZXZhbHMiLCJyb290IiwiaW1wb3J0RGF0YXNldHMiLCJnZXREYXRhc2V0IiwiZ2V0U2NyaXB0IiwiZ2V0Q29tcGxldGUiLCJnZXRTa3VscHQiLCJnZXRCbG9ja2x5IiwidGV4dFRvQmxvY2tzIiwiaGlkZGVuSW1wb3J0cyIsImdldEpTT04iLCJibG9ja3B5IiwiZG9jdW1lbnRhdGlvbiIsImJvZHkiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsInNsdWdnZWROYW1lIiwidGl0bGVOYW1lIiwiaW1nU3JjIiwidGl0bGUiLCJvdmVydmlldyIsImFwcGVuZFRvIiwiRElBTE9HX0hUTUwiLCJ0aXRsZVRhZyIsImJvZHlUYWciLCJmb290ZXJUYWciLCJva2F5QnV0dG9uIiwiY2xvc2VCdXR0b24iLCJ5ZXMiLCJubyIsIm1vZGFsIiwiY2xvc2UiLCJvbmNsb3NlIiwiZHJhZ2dhYmxlIiwib24iLCJjb25maXJtIiwieWVzVGV4dCIsIkFTU0lHTk1FTlRfVkVSU0lPTl9DSEFOR0VEIiwiRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCIsInJlYXNvbiIsIkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMiLCJFUlJPUl9VUExPQURJTkdfRklMRSIsIkVSUk9SX1NBVklOR19BU1NJR05NTkVOVCIsIkVSUk9SX1NIT1dfU1RVREVOVF9FUlJPUiIsIlBPU0lUSVZFX0ZFRURCQUNLX0ZVTEwiLCJTQ1JFRU5TSE9UX0JMT0NLUyIsIkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTIiwiT0ZGRVJfRk9SSyIsInNldHVwVXJsIiwiaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwIiwiaW5wdXRUZXh0Iiwiam9pbiIsImNoZWNrZWQiLCJpbnB1dHMiLCJmaWxlUmVhZGVyIiwic2x1Z2dpZnkiLCJyZXBsYWNlIiwiZXh0ZW5zaW9uIiwibWltZXR5cGUiLCJibG9iIiwiQmxvYiIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm1zU2F2ZU9yT3BlbkJsb2IiLCJtc1NhdmVCbG9iIiwidGVtcG9yYXJ5RG93bmxvYWRMaW5rIiwiaHJlZiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJBYnN0cmFjdEVkaXRvciIsImNoYW5nZUVkaXRvciIsIndhdGNoRmlsZSIsInVwZGF0ZWQiLCJvbkZpbGVVcGRhdGVkIiwiZGVsZXRlZCIsIm9uRmlsZURlbGV0ZWQiLCJuZXdGaWxlbmFtZSIsIm9sZEVkaXRvciIsInRyYWNrQ3VycmVudEZpbGUiLCJuZXdFZGl0b3IiLCJzdG9wV2F0Y2hpbmdGaWxlIiwicGFyc2VGaWxlbmFtZSIsIkFTU0lHTk1FTlRfU0VUVElOR1MiLCJNQVpFIiwiUVVJWiIsIlJFQURJTkciLCJnZXREb2N1bWVudGF0aW9uIiwibWFrZVN0YXJ0Vmlld1RhYiIsImljb24iLCJtb2RlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19CT09MRUFOX0NPTVBPTkVOVFNfSFRNTCIsImZpbHRlciIsInNldHRpbmciLCJwcmV0dHlOYW1lIiwid29yZCIsInRvVXBwZXJDYXNlIiwiQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCIsIkJMT0NLIiwic2F2ZUFzc2lnbm1lbnRTZXR0aW5ncyIsImNsaWVudE5hbWUiLCJzZXJ2ZXJOYW1lIiwic3RhcnRfdmlldyIsImZpZWxkVHlwZSIsImNvbmZpZ1ZhbHVlIiwiQXNzaWdubWVudFNldHRpbmdzVmlldyIsImRpcnR5IiwiY3VycmVudExpc3RlbmVyIiwidXBkYXRlSGFuZGxlIiwibmV3Q29udGVudHMiLCJBc3NpZ25tZW50U2V0dGluZ3MiLCJleHRlbnNpb25zIiwiY29uc3RydWN0b3IiLCJ0ZW1wbGF0ZSIsImRlZmF1bHRfaGVhZGVyIiwiSU1BR0VfRURJVE9SX0hUTUwiLCJJbWFnZUVkaXRvclZpZXciLCJjdXJyZW50U3Vic2NyaXB0aW9uIiwiZGlhbG9ncyIsImRpc3Bvc2UiLCJJbWFnZUVkaXRvciIsIkpTT05fRURJVE9SX0hUTUwiLCJKc29uRWRpdG9yVmlldyIsIkNvZGVNaXJyb3IiLCJmcm9tVGV4dEFyZWEiLCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZyIsImxpbmVOdW1iZXJzIiwiZmlyc3RMaW5lTnVtYmVyIiwiaW5kZW50VW5pdCIsInRhYlNpemUiLCJpbmRlbnRXaXRoVGFicyIsImV4dHJhS2V5cyIsImNtIiwiYmx1ciIsInNldFRpbWVvdXQiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwib2ZmIiwiSnNvbkVkaXRvciIsIk1BUktET1dOX0VESVRPUl9IVE1MIiwiTWFya2Rvd25FZGl0b3JWaWV3IiwibWRlIiwiZWxlbWVudCIsImF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lIiwiZm9yY2VTeW5jIiwibWluSGVpZ2h0IiwicmVuZGVyaW5nQ29uZmlnIiwiY29kZVN5bnRheEhpZ2hsaWdodGluZyIsImNvZGVtaXJyb3IiLCJNYXJrZG93bkVkaXRvciIsIm1ha2VUYWIiLCJQWVRIT05fRURJVE9SX0hUTUwiLCJISVNUT1JZX1RPT0xCQVJfSFRNTCIsImNvbnZlcnRJcHluYlRvUHl0aG9uIiwiaXB5bmIiLCJpc1VzYWJsZSIsImNlbGwiLCJjZWxsX3R5cGUiLCJzb3VyY2UiLCJtYWtlUHl0aG9uIiwiY2VsbHMiLCJQeXRob25FZGl0b3JWaWV3IiwiQmxvY2tseSIsInNldFBhcmVudENvbnRhaW5lciIsIkJsb2NrTWlycm9yIiwidG9vbGJveCIsImltYWdlRG93bmxvYWRIb29rIiwib2xkVXJsIiwiaW1hZ2VVcGxvYWRIb29rIiwicmVqZWN0Iiwic3VibWlzc2lvbklkIiwiaW1hZ2VMaXRlcmFsSG9vayIsIm1ha2VTdWJzY3JpcHRpb25zIiwibGluZUVycm9yU3Vic2NyaXB0aW9uIiwibGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiIsImxpbmVUcmFjZVN1YnNjcmlwdGlvbiIsIm1ha2VQZXJBc3NpZ25tZW50U3Vic2NyaXB0aW9ucyIsIndvcmtzcGFjZSIsImNvbmZpZ3VyZUNvbnRleHRNZW51Iiwib3B0aW9ucyIsImVuYWJsZWQiLCJjYWxsYmFjayIsIm9sZEZpbGVuYW1lIiwiY3VycmVudEJNTGlzdGVuZXIiLCJhZGRDaGFuZ2VMaXN0ZW5lciIsImlzUGFyc29ucyIsImxpbmVzIiwic2V0SGlnaGxpZ2h0ZWRMaW5lcyIsImNsZWFySGlnaGxpZ2h0ZWRMaW5lcyIsImRlbGV0ZUZpbGVMb2NhbGx5XyIsInNldENvZGUiLCJnZXRDb2RlIiwicmVtb3ZlQ2hhbmdlTGlzdGVuZXIiLCJjbGVhckxpbmVTdWJzY3JpcHRpb25zIiwic2V0TW9kZSIsImVuYWJsZUJsb2NrcyIsInJlbG9hZFRvb2xib3giLCJpbWFnZU1vZGUiLCJzZXRJbWFnZU1vZGUiLCJvbGRIZWlnaHQiLCJ1c2VTbWFsbExheW91dCIsInJlc2l6ZVJlc3BvbnNpdmVseSIsInVwZGF0ZUd1dHRlciIsImluZGVudFNpZGViYXIiLCJjdXN0b21Ub29sYm94IiwiZGVjaWRlSWZOb3RFZGl0YWJsZSIsIm9ubHlVcGxvYWRzIiwiaXNSZWFkT25seSIsImVuZHNXaXRoIiwiUHl0aG9uRWRpdG9yIiwiUVVJWl9FRElUT1JfSFRNTCIsIlF1aXpFZGl0b3JWaWV3IiwiUXVpekVkaXRvciIsIlN1Ym1pc3Npb25TdGF0dXNlcyIsIlVOS05PV04iLCJQQVNTRUQiLCJGQUlMRUQiLCJFUlJPUiIsIlNLSVBQRUQiLCJjb3VudCIsIlNBTVBMRV9TVUJNSVNTSU9OU19IVE1MIiwiYmluZGluZ0hhbmRsZXJzIiwiY29kZU1pcnJvckluc3RhbmNlIiwiaW5pdCIsInZhbHVlQWNjZXNzb3IiLCJhbGxCaW5kaW5ncyIsInZpZXdNb2RlbCIsImJpbmRpbmdDb250ZXh0Iiwic2V0U2l6ZSIsInVwZGF0ZSIsIlNhbXBsZVN1Ym1pc3Npb25zVmlldyIsImNvZGVNaXJyb3JzIiwiU2FtcGxlU3VibWlzc2lvbnMiLCJUQUdTX0VESVRPUl9IVE1MIiwiVGFnc0VkaXRvclZpZXciLCJUYWdzRWRpdG9yIiwiVEVYVF9FRElUT1JfSFRNTCIsIlRleHRFZGl0b3JWaWV3IiwiVGV4dEVkaXRvciIsIlRPT0xCT1hfRURJVE9SX0hUTUwiLCJUb29sYm94RWRpdG9yVmlldyIsIlRvb2xib3hFZGl0b3IiLCJFZGl0b3JzRW51bSIsIlNVQk1JU1NJT04iLCJBU1NJR05NRU5UIiwiSU5TVFJVQ1RJT05TIiwiT05fUlVOIiwiT05fQ0hBTkdFIiwiT05fRVZBTCIsIlNUQVJUSU5HX0NPREUiLCJTQU1QTEVfU1VCTUlTU0lPTlMiLCJJTlNUUlVDVE9SX0ZJTEUiLCJTUEVDSUFMX05BTUVTUEFDRVMiLCJBVkFJTEFCTEVfRURJVE9SUyIsIkVESVRPUlNfSFRNTCIsInJlZ2lzdGVyZWRfIiwiZXh0ZW5zaW9uc18iLCJieU5hbWVfIiwicmVnaXN0ZXJFZGl0b3IiLCJpbnN0YW5jZSIsImV4aXQiLCJlbnRlciIsInNwYWNlIiwiYXNzaWdubWVudFR5cGUiLCJBc3NpZ25tZW50VHlwZSIsImxhc3RJbmRleE9mIiwiZXhlY3V0aW9uTW9kZWwiLCJjb25maWd1cmF0aW9ucyIsIlJ1bkNvbmZpZ3VyYXRpb24iLCJldmFsIiwiRXZhbENvbmZpZ3VyYXRpb24iLCJPblJ1bkNvbmZpZ3VyYXRpb24iLCJPbkNoYW5nZUNvbmZpZ3VyYXRpb24iLCJPbkV2YWxDb25maWd1cmF0aW9uIiwiY29uZmlndXJlIiwiZ2V0U2t1bHB0T3B0aW9ucyIsIm9uRXhlY3V0aW9uQmVnaW4iLCJvbkV4ZWN1dGlvbkVuZCIsInJlcG9ydCIsInRyYWNpbmciLCJyZXNldFN0dWRlbnRNb2RlbCIsInJlc2V0UmVwb3J0cyIsInJlc2V0RXhlY3V0aW9uQnVmZmVyIiwidGhlbiIsImZhaWx1cmUiLCJkaXNhYmxlRmVlZGJhY2siLCJwcm92aWRlU2VjcmV0RXJyb3IiLCJzaG93RXJyb3JzIiwiZXhlY3V0aW9uRW5kXyIsImV2YWx1YXRpb25JbnB1dCIsInVzZXJJbnB1dCIsIm1pc2NldmFsIiwiYXN5bmNUb1Byb21pc2UiLCJpbXBvcnRNYWluV2l0aEJvZHkiLCJGSUxFTkFNRSIsInByb2dyYW1zIiwic2F2ZUNvZGUiLCJ2ZXJpZnlDb2RlIiwidXBkYXRlUGFyc2UiLCJydW5JbnN0cnVjdG9yQ29kZSIsIm1vZHVsZSIsImV4ZWN1dGlvblJlcG9ydHMiLCJwcmVzZW50RmVlZGJhY2siLCIkZCIsIkVNUFRZX01PRFVMRSIsIkNvbmZpZ3VyYXRpb24iLCJpbkJyb3dzZXIiLCJvcGVuRmlsZSIsInJlcXVlc3RzR2V0IiwidGltZW91dCIsIm9wZW5VUkwiLCJ0aW1lb3V0SGFuZGxlciIsInRpbWVQYXNzZWQiLCJleGVjTGltaXQiLCJkaXNhYmxlVGltZW91dCIsImdldFRpbWVvdXRQcm9tcHQiLCJkZWxheSIsInBhcnNlSW50IiwiZXhlY0xpbWl0RnVuY3Rpb24iLCJJbmZpbml0eSIsImJlZm9yZUNhbGwiLCJsb25nVGltZW91dCIsIl9fZnV0dXJlX18iLCJweXRob24zIiwicmVhZCIsImltcG9ydEZpbGUiLCJmaWxld3JpdGUiLCJ3cml0ZUZpbGUiLCJwcmludCIsImlucHV0ZnVuIiwiaW5wdXRmdW5UYWtlc1Byb21wdCIsImltYWdlUHJveHkiLCJnZXRJbWFnZVByb3h5IiwiZW1vamlQcm94eSIsInBhcnQiLCJyZXRhaW5HbG9iYWxzIiwid2FybiIsIm1vY2tVcmxEYXRhIiwiYnVpbHRpbiIsIklPRXJyb3IiLCJoYXNPd25Qcm9wZXJ0eSIsImZpbGVEYXRhIiwicmVhZEZpbGUiLCJFcnJvciIsInN0b3AiLCJmdW5jdGlvbk5hbWUiLCJwb3NhcmdzIiwia3dhcmdzIiwic3R1ZGVudE1vZGVsIiwiYXJncyIsInBvcCIsImFmdGVyU2luZ2xlRXhlY3V0aW9uIiwicHJpbnRWYWx1ZSIsInJlbWFwVG9KcyIsIl8iLCIkciIsIngiLCJpc0RvY3N0cmluZyIsIlN0dWRlbnRDb25maWd1cmF0aW9uIiwiVVRJTElUWV9NT0RVTEVfQ09ERSIsIiRza19tb2RfaW5zdHJ1Y3RvciIsIkNPVkVSQUdFX01PRFVMRV9DT0RFIiwiJHNrX21vZF9jb3ZlcmFnZSIsIkluc3RydWN0b3JDb25maWd1cmF0aW9uIiwiYmVmb3JlQ2FsbEJhY2t1cCIsIiRwZWRhbF90cmFjZXIiLCJjbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMiLCJnZXRBbGxGaWxlbmFtZXMiLCJza0ZpbGVuYW1lIiwic3RyIiwicG9wJGl0ZW0iLCJpbmNsdWRlcyIsImNob21wU3BlY2lhbEZpbGUiLCJjbGVhbiIsImZvdW5kIiwic2VhcmNoRm9yRmlsZSIsIk9TRXJyb3IiLCJuZXh0SW5wdXQiLCJjbGVhclRpbWVvdXQiLCJXUkFQX0lOU1RSVUNUT1JfQ09ERSIsInN0dWRlbnRDb2RlIiwiaW5zdHJ1Y3RvckNvZGUiLCJxdWljayIsImlzU2FmZSIsInNhZmVDb2RlIiwiSU5TVFJVQ1RPUl9NQVJLRVIiLCJkaXNhYmxlVGlmYSIsInN0dWRlbnRGaWxlcyIsImdldEFsbFN0dWRlbnRGaWxlcyIsImV2YWx1YXRpb24iLCJkdW1teU91dFNhbmRib3giLCJsaW5lT2Zmc2V0IiwiZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQiLCJTVUNDRVNTIiwiU0NPUkUiLCJvbGRTY29yZSIsIkhJREUiLCJzY3JvbGxpbmciLCJzY3JvbGxUb0JvdHRvbSIsInRwJG5hbWUiLCJwcmVzZW50SW50ZXJuYWxFcnJvciIsImJlZm9yZSIsIm1hdGNoIiwiTkVXX0xJTkVfUkVHRVgiLCJza2lwX3RpZmEiLCJPblNhbXBsZUNvbmZpZ3VyYXRpb24iLCJkaXNhYmxlU3R1ZGVudFJ1biIsIkJvb2xlYW4iLCJjbGVhcklucHV0IiwiZmluaXNoVHVydGxlcyIsImJlZ2luRXZhbCIsInBhcnNlciIsInZlcmlmaWVyIiwiU2FtcGxlQ29uZmlndXJhdGlvbiIsImlzRm9yYmlkZGVuIiwibG9jYWxzIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsImV4ZWNTdGFjayIsIm4iLCJvIiwicGFyc2VHbG9iYWxzIiwicHJvcGVydGllcyIsIm1vZHVsZXMiLCJhc3QiLCJ2aXNpdGVkTGluZXMiLCJTZXQiLCJ2aXNpdEJvZHkiLCJub2RlIiwibGluZW5vIiwic3RhdGVtZW50Iiwib3JlbHNlIiwiZmluYWxib2R5IiwiQXJyYXkiLCJmcm9tIiwiYXN0RnJvbVBhcnNlIiwiY3N0IiwiZmxhZ3MiLCJnZXRMaW5lcyIsInByZXNlbnRSdW5FcnJvciIsImVycm9yQnV0dG9uIiwiRkVFREJBQ0tfSFRNTCIsImZlZWRiYWNrTW9kZWwiLCJwb3NpdGl2ZSIsInZpc2liaWxpdHlCdWZmZXIiLCJ0b3BPZkVsZW1lbnQiLCJib3R0b21PZkVsZW1lbnQiLCJib3R0b21PZlNjcmVlbiIsInRvcE9mU2NyZWVuIiwiY2xlYXJQb3NpdGl2ZUZlZWRiYWNrIiwiZXhlY3V0aW9uUmVzdWx0cyIsIk1FU1NBR0UiLCJDQVRFR09SWSIsIkxBQkVMIiwiREFUQSIsInBvc2l0aXZlcyIsIlBPU0lUSVZFIiwiaGlkZVNjb3JlIiwiYmxvY2siLCJobGpzIiwiaGlnaGxpZ2h0QmxvY2siLCJmaW5kRmlyc3RFcnJvckxpbmUiLCJzdHVkZW50UmVwb3J0IiwidW5jb3ZlcmVkTGluZXMiLCJwb3NpdGl2ZURhdGEiLCJhZGRQb3NpdGl2ZUZlZWRiYWNrIiwiY29sb3IiLCJvbmNsaWNrIiwidG9FbmQiLCJjc3MiLCJob3ZlciIsInVwZGF0ZUZlZWRiYWNrIiwibm90aWZ5RmVlZGJhY2tVcGRhdGUiLCJzY3JvbGxJbnRvVmlldyIsImp1c3RfcmV0dXJuIiwiY29udmVydFNrdWxwdEVycm9yIiwiZmlsZW5hbWVFeGVjdXRlZCIsInRyYWNlYmFjayIsImZyYW1lIiwic2NvcGUiLCJpc0luc3RydWN0b3IiLCJlcnIiLCJhbGxGcmFtZXMiLCJidWlsZFRyYWNlYmFjayIsImZlZWRiYWNrRGF0YSIsInF1aWNrJGxvb2t1cCIsImxvY2F0aW9uIiwidHAkZ2V0YXR0ciIsImZyaWVuZGx5TmFtZSIsImhpZGVJZkVtcHR5Iiwibm90SW5zdHJ1Y3RvciIsImluc3RydWN0b3JGaWxlQ2xhc3MiLCJoaWRlSWZOb3RJbnN0cnVjdG9yIiwiRklMRVNfSFRNTCIsIk5FV19JTlNUUlVDVE9SX0ZJTEVfRElBTE9HX0hUTUwiLCJTVEFSVElOR19GSUxFUyIsIkJBU0lDX05FV19GSUxFUyIsIklOU1RSVUNUT1JfRElSRUNUT1JZIiwiU1RVREVOVF9ESVJFQ1RPUlkiLCJTZWFyY2hNb2RlcyIsIkVWRVJZV0hFUkUiLCJTVEFSVF9XSVRIX0lOU1RSVUNUT1IiLCJPTkxZX1NUVURFTlRfRklMRVMiLCJERUxFVEFCTEVfU0lNUExFX0ZJTEVTIiwiQmxvY2tQeUZpbGUiLCJvd25lciIsIm1ha2VNb2NrTW9kZWxGaWxlIiwiY29uY2F0ZW5hdGVkRmlsZSIsIm1vZGVsRmlsZUxpc3QiLCJtb2RlbEZpbGVzIiwiY3JlYXRlQ29uY2F0ZW5hdGVkRmlsZSIsImZpbGVzXyIsIm1vdW50RmlsZXMiLCJ3YXRjaE1vZGVsIiwid2F0Y2hlc18iLCJ2aXNpYmxpdHkiLCJ0b2dnbGUiLCJmaWxlc3lzdGVtIiwiZmlsZUFycmF5IiwiY2hhbmdlcyIsInNlY29uZCIsImxvY2FsZUNvbXBhcmUiLCJjaGFuZ2UiLCJtb2RlbEZpbGUiLCJub3RpZnlXYXRjaGVzIiwib2JzZXJ2ZUluQXJyYXlfIiwiYXJyYXkiLCJjb2RlQnVuZGxlIiwiZXhpc3RpbmdGaWxlIiwib2JzZXJ2ZUZpbGVfIiwiZGVzdGluYXRpb24iLCJzdHVkZW50U2VhcmNoIiwic2VhcmNoTW9kZSIsInNwZWNpYWxGaWxlIiwic2VhcmNoRm9yU3BlY2lhbEZpbGVzXyIsInN0dWRlbnRWZXJzaW9uIiwic2VhcmNoRm9yRmlsZUluTGlzdF8iLCJnZW5lcmF0ZWRWZXJzaW9uIiwiZGVmYXVsdFZlcnNpb24iLCJoaWRkZW5WZXJzaW9uIiwiZmlyc3REZWZpbmVkVmFsdWUiLCJpbnN0cnVjdG9yVmVyc2lvbiIsInN0YXJ0aW5nVmVyc2lvbiIsIm1vZGVsTGlzdCIsImtpbmQiLCJmaWxldHlwZSIsIm5hbWVzcGFjZSIsImV4dGVuc2lvblJlZ2V4IiwiZXhlYyIsInByZWZpeCIsInN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwiRk9PVEVSX0hUTUwiLCJjdXJyZW50SWQiLCJlZGl0RXZlbnRzIiwic2VsZWN0b3IiLCJlZGl0SWQiLCJlbnRyeSIsImZpbGVfcGF0aCIsImV2ZW50X3R5cGUiLCJSRU1BUF9FVkVOVF9UWVBFUyIsImRpc3BsYXllZCIsInByZXR0eVByaW50RGF0ZVRpbWUiLCJjbGllbnRfdGltZXN0YW1wIiwiZGlzYWJsZSIsIm9wdGlvbiIsImRpc2FibGVkIiwiaXNFZGl0RXZlbnQiLCJldnQiLCJtb250aE5hbWVzIiwid2Vla0RheXMiLCJpc1NhbWVEYXkiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsInRpbWVTdHJpbmciLCJub3ciLCJEYXRlIiwicGFzdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImRheVN0ciIsImdldERheSIsIm1vbnRoU3RyIiwiZGF0ZSIsImdldEhpc3RvcnkiLCJyZXZlcnNlIiwicmVkdWNlIiwiY29tcGxldGUiLCJlbGVtIiwiY29tcGxldGVfc3RyIiwidGltZSIsIm5ld19saW5lIiwiaGlnaGxpZ2h0VGltZW91dCIsImlzRnVsbHNjcmVlbiIsInJlcXVlc3RGdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJUUkFDRV9IVE1MIiwiUkVUUllJTkciLCJPRkZMSU5FIiwic3RvcmFnZSIsInF1ZXVlIiwiZ2V0RGVmYXVsdCIsIk1BWF9RVUVVRV9TSVpFIiwiVElNRVJfREVMQVkiLCJGQUlMX0RFTEFZIiwidGltZXJzIiwib3ZlcmxheSIsImJsb2NraW5nQXR0ZW1wdHMiLCJjYWNoZWRGaWxlbmFtZXMiLCJjcmVhdGVTdWJzY3JpcHRpb25zIiwiY2hlY2tDYWNoZXMiLCJjaGVja0lQIiwib2xkSVAiLCJpcCIsInNldCIsIl9wb3N0TGF0ZXN0UmV0cnkiLCJwdXNoQW55UXVldWVkIiwiX3Bvc3RSZXRyeSIsImNyZWF0ZUZpbGVTdWJzY3JpcHRpb24iLCJjcmVhdGVFdmVudExvZ3MiLCJvbmJsdXIiLCJvbmZvY3VzIiwiY3JlYXRlU2VydmVyRGF0YSIsIm1pY3Jvc2Vjb25kcyIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNob3dPdmVybGF5IiwiYXR0ZW1wdCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoaWRlT3ZlcmxheSIsIl9lbnF1ZXVlRGF0YSIsImNhY2hlIiwiX2RlcXVldWVEYXRhIiwic3BsaWNlIiwicG9zdFJlcXVlc3QiLCJwb3N0IiwidGV4dFN0YXR1cyIsImZhaWx1cmVGdW5jdGlvbiIsImRvbmVGdW5jdGlvbiIsInJlcXVlc3QiLCJjYWNoZWRUaW1lIiwiX3Bvc3RCbG9ja2luZyIsImF0dGVtcHRzIiwiZXh0cmFTZXR0aW5ncyIsImFqYXgiLCJlcnJvclRocm93biIsInN0YXJ0UG9zc2libGVGb3JrIiwicGxhY2VtZW50IiwiZGlyZWN0b3J5IiwiZmQiLCJlbnRyaWVzIiwiZCIsIkZvcm1EYXRhIiwicHJvY2Vzc0RhdGEiLCJjb250ZW50VHlwZSIsIm5ld1N0YXR1cyIsInBvc3RTdGF0dXNDaGFuZ2UiLCJlcnJvckNhbGxiYWNrIiwibG9hZF9maWxlIiwiZm9ya2FibGUiLCJoaWRkZW5PdmVycmlkZSIsImZvcmNlVXBkYXRlIiwiZ2V0UG5nRnJvbUJsb2NrcyIsInBuZ0RhdGEiLCJpbWciLCIkYnVpbHRpbm1vZHVsZSIsIm1vZCIsInNhbXBsZVdyYXBwZXIiLCJfX25hbWVfXyIsIlBJTCIsIkluc3RhbnRQcm9taXNlIiwibGFzdFJlc3VsdCIsImxhc3RFcnJvciIsImNiIiwiYnVpbGRJbWFnZSIsImdldEFzc2V0IiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9uZXJyb3IiLCJzcmMiLCIkZ2JsIiwiJGxvYyIsIl9faW5pdF9fIiwiZnVuYyIsImZpbGVfb3JfdXJsIiwicHlDaGVja0FyZ3MiLCJweUNoZWNrVHlwZSIsImNoZWNrU3RyaW5nIiwiaW1hZ2VQcm9taXNlIiwic3VzcCIsIlN1c3BlbnNpb24iLCJub25lIiwibm9uZSQiLCJyZXN1bWUiLCJwcm9taXNlIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInBpeGVscyIsImdldEltYWdlRGF0YSIsIk5hbWVFcnJvciIsImNvbnNvbGVEYXRhIiwicHJpbnRQSUxJbWFnZSIsImZsaXAiLCJzdHlsZSIsInRyYW5zZm9ybSIsImJ1aWxkQ2xhc3MiLCJwcmlvciIsInRpbWVpdCIsImRpZmZlcmVuY2UiLCJjb25zb2xlX2xvZyIsImNvbnNvbGVfZGVidWciLCJnZXRfb3V0cHV0IiwiaXRlbSIsInRvU2t1bHB0IiwibGlzdCIsInJlc2V0X291dHB1dCIsImdldF9wcm9ncmFtIiwiZ2V0X2V2YWx1YXRpb24iLCJ0cmFjZV9saW5lcyIsInJlYWxMaW5lcyIsInRyYWNlX2NhbGxzIiwiZGljdCIsInN0YXJ0X3RyYWNlIiwic3RvcF90cmFjZSIsImdldF9zdHVkZW50X2Vycm9yIiwidHVwbGUiLCJwb3NpdGlvbiIsImhhZF9leGVjdXRpb25fdGltZV9lcnJvciIsImJhY2t1cFRpbWUiLCJsaW1pdF9leGVjdXRpb25fdGltZSIsImV4ZWNTdGFydCIsInVubGltaXRfZXhlY3V0aW9uX3RpbWUiLCJzdXBwcmVzc19zY3JvbGxpbmciLCJnZXRfcGxvdHMiLCJvdXRwdXRzIiwiZ3JhcGgiLCJwbG90IiwibmV3UGxvdCIsInYiLCJ5IiwiU3R1ZGVudERhdGEiLCJuZXdEaWN0IiwiYWJzdHIiLCJzYXR0ciIsIm9iamVjdFNldEl0ZW0iLCJ1bmZpeFJlc2VydmVkIiwiY2FsbF9mIiwia3dhIiwicHlDaGVja0FyZ3NMZW4iLCJjYWxsIiwiYnVpbHRpbnMiLCJtcCRsb29rdXAiLCJmdW5jdGlvbk9iamVjdCIsInRwJGNhbGwiLCJjb19rd2FyZ3MiLCJjb19uYW1lIiwiZ2V0X25hbWVzX2J5X3R5cGUiLCJleGNsdWRlX2J1aWx0aW5zIiwiY2hlY2tCb29sIiwicHJvcGVydHkiLCJnZXRfdmFsdWVzX2J5X3R5cGUiLCJjYWxsc2ltT3JTdXNwZW5kIiwiZ2V0X3N0dWRlbnRfZGF0YSIsInNldF9pbnN0cnVjdGlvbnMiLCJuZXdJbnN0cnVjdGlvbnMiLCJnZXRfbW9kZWxfaW5mbyIsImNsZWFyX2V4aXN0aW5nX3N0dWRlbnRfaW1wb3J0cyIsIldlYWtTZXQiLCJjaGVja0l0ZXJhYmxlIiwiaXRlciIsIml0ZXJuZXh0IiwiV2Vha1JlZiIsIl9faXRlcl9fIiwidmlld09mRGF0YSIsImRlcmVmIiwiTE9DQUxfU1RPUkFHRV9SRUYiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIl9kYXRhIiwiU3RyaW5nIiwiZ2V0SXRlbSIsImlzX25ldyIsInNlcnZlcl90aW1lIiwic3RvcmVkX3RpbWUiLCJJR05PUkVEX0dMT0JBTFMiLCJ2YXJpYWJsZXMiLCJwYXJzZWQiLCJwYXJzZVZhbHVlIiwiZnVsbExlbmd0aCIsImZ1bmNfY29kZSIsImNvX3Zhcm5hbWVzIiwic3EkbGVuZ3RoIiwiYm9vbCIsIm5tYmVyIiwic2tUeXBlIiwiaW50XyIsImZsb2F0XyIsIk51bWJlciIsImFycmF5Q29udGFpbnMiLCJuZWVkbGUiLCJoYXlzdGFjayIsImFycmF5VW5pcXVlIiwiYSIsImNvbmNhdCIsImoiLCJleHBhbmRBcnJheSIsImFkZEFycmF5IiwicmVtb3ZlQXJyYXkiLCJjb3B5QXJyYXkiLCJjbG9uZU5vZGUiLCJjbG9uZSIsIm5vZGVUeXBlIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImluZGVudCIsInMiLCJyYW5kb21JbnRlZ2VyIiwiZmxvb3IiLCJyYW5kb20iLCJXb3Jrc3BhY2VTdmciLCJzaHVmZmxlIiwibWV0cmljcyIsImdldE1ldHJpY3MiLCJ2aWV3V2lkdGgiLCJ2aWV3SGVpZ2h0IiwiYmxvY2tzIiwiZ2V0VG9wQmxvY2tzIiwibWF4aW1hbF9pbmNyZWFzZSIsImdldFJlbGF0aXZlVG9TdXJmYWNlWFkiLCJtb3ZlQnkiLCJtb3ZlRWxlbWVudHMiLCJtb3ZlQ2hlY2siLCJpc1NrQnVpbHRpbiIsIm9iaiIsImxuZyIsImlzQXN0Tm9kZSIsIm1peGVkUmVtYXBUb1B5IiwiayIsImt2cyIsImFyciIsInN1YnZhbCIsImFzc2skIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtDQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSxJQUFNQSxjQUFjLEdBQUcsT0FBdkI7QUFFQTs7Ozs7Ozs7OztBQVNPLElBQU1DLE9BQWI7QUFDSTs7Ozs7QUFLQSxtQkFBWUMsYUFBWixF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LENBQUMyZixPQUFILENBQVcrWCxJQUFmLENBQW9CeUgsR0FBcEIsQ0FBUDtBQUNILEtBWEQsTUFXSztBQUNELGFBQU9MLEdBQVA7QUFDSDtBQUNKLEdBZk0sTUFlQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNoQyxXQUFPLElBQUk5K0IsRUFBRSxDQUFDMmYsT0FBSCxDQUFXK0IsR0FBZixDQUFtQm9kLEdBQW5CLENBQVA7QUFDSCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDaEMsV0FBTzkrQixFQUFFLENBQUMyZixPQUFILENBQVcyZixLQUFYLENBQWlCUixHQUFqQixDQUFQO0FBQ0gsR0FGTSxNQUVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFNBQW5CLEVBQThCO0FBQ2pDLFdBQU8sSUFBSTkrQixFQUFFLENBQUMyZixPQUFILENBQVd1YyxJQUFmLENBQW9CNEMsR0FBcEIsQ0FBUDtBQUNILEdBRk0sTUFFQSxJQUFHLE9BQU9BLEdBQVAsS0FBZSxVQUFsQixFQUE4QjtBQUNqQyxXQUFPLElBQUk5K0IsRUFBRSxDQUFDMmYsT0FBSCxDQUFXK0IsR0FBZixDQUFtQm9kLEdBQUcsQ0FBQzMwQyxJQUF2QixDQUFQO0FBQ0g7QUFDSixDOzs7Ozs7Ozs7OztBQ25RRCxvRDs7Ozs7Ozs7Ozs7QUNBQSxzRCIsImZpbGUiOiJibG9ja3B5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwialF1ZXJ5XCIpLCByZXF1aXJlKFwia29cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJibG9ja3B5XCIsIFtcImpRdWVyeVwiLCBcImtvXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImJsb2NrcHlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJqUXVlcnlcIiksIHJlcXVpcmUoXCJrb1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiYmxvY2tweVwiXSA9IGZhY3Rvcnkocm9vdFtcImpRdWVyeVwiXSwgcm9vdFtcImtvXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2tub2Nrb3V0X18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9ibG9ja3B5LmpzXCIpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YXJ0aW5nIHBvaW50IG9mIHRoZSBCbG9ja1B5IGFwcGxpY2F0aW9uLCBjb250YWluaW5nIHRoZSBtYWluXG4gKiBCbG9ja1B5IGNsYXNzLlxuICovXG5pbXBvcnQgXCIuL2Nzcy9ibG9ja3B5LmNzc1wiO1xuaW1wb3J0IFwiLi9jc3MvYm9vdHN0cmFwX3JldGhlbWUuY3NzXCI7XG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgeyRidWlsdGlubW9kdWxlIGFzIGltYWdlTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvaW1hZ2VcIjtcbmltcG9ydCB7JGJ1aWx0aW5tb2R1bGUgYXMgd2Vha3JlZk1vZHVsZX0gZnJvbSBcInNrdWxwdF9tb2R1bGVzL3dlYWtyZWZcIjtcbi8vaW1wb3J0IHskYnVpbHRpbm1vZHVsZSBhcyBtYXRwbG90bGliTW9kdWxlfSBmcm9tIFwic2t1bHB0X21vZHVsZXMvbWF0cGxvdGxpYjJcIjtcbmltcG9ydCB7TG9jYWxTdG9yYWdlV3JhcHBlcn0gZnJvbSBcInN0b3JhZ2UuanNcIjtcbmltcG9ydCB7RWRpdG9yc0VudW19IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge0Rpc3BsYXlNb2Rlc30gZnJvbSBcImVkaXRvci9weXRob24uanNcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCJzZXJ2ZXIuanNcIjtcbmltcG9ydCB7bWFrZUludGVyZmFjZSwgbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucywgU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zfSBmcm9tIFwiaW50ZXJmYWNlLmpzXCI7XG5pbXBvcnQge0VkaXRvcnN9IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge1xuICAgIEJsb2NrUHlGaWxlU3lzdGVtLFxuICAgIGxvYWRDb25jYXRlbmF0ZWRGaWxlLFxuICAgIG1ha2VNb2RlbEZpbGUsXG4gICAgb2JzZXJ2ZUNvbmNhdGVuYXRlZEZpbGUsXG4gICAgVU5ERUxFVEFCTEVfRklMRVMsXG4gICAgVU5SRU5BTUFCTEVfRklMRVNcbn0gZnJvbSBcIi4vZmlsZXNcIjtcbmltcG9ydCB7dXBsb2FkRmlsZSwgZG93bmxvYWRGaWxlfSBmcm9tIFwiLi9lZGl0b3IvYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0Jsb2NrUHlFbmdpbmV9IGZyb20gXCJlbmdpbmUuanNcIjtcbmltcG9ydCB7QmxvY2tQeVRyYWNlfSBmcm9tIFwiLi90cmFjZVwiO1xuaW1wb3J0IHtCbG9ja1B5Q29uc29sZX0gZnJvbSBcIi4vY29uc29sZVwiO1xuaW1wb3J0IHtCbG9ja1B5RmVlZGJhY2t9IGZyb20gXCJmZWVkYmFjay5qc1wiO1xuaW1wb3J0IHtCbG9ja1B5U2VydmVyfSBmcm9tIFwiLi9zZXJ2ZXJcIjtcbmltcG9ydCB7QmxvY2tQeURpYWxvZ30gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQge0Fzc2lnbWVudFR5cGUsIGxvYWRBc3NpZ25tZW50U2V0dGluZ3MsIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbH0gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcbmltcG9ydCB7QmxvY2tQeUNvcmdpcywgX0lNUE9SVEVEX0NPTVBMRVRFX0RBVEFTRVRTLCBfSU1QT1JURURfREFUQVNFVFN9IGZyb20gXCIuL2Nvcmdpc1wiO1xuaW1wb3J0IHtCbG9ja1B5SGlzdG9yeX0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtjYXBpdGFsaXplfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcbmltcG9ydCB7U2FtcGxlU3VibWlzc2lvbn0gZnJvbSBcIi4vZWRpdG9yL3NhbXBsZV9zdWJtaXNzaW9uc1wiO1xuXG5leHBvcnQge19JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUywgX0lNUE9SVEVEX0RBVEFTRVRTfTtcblxuY29uc3QgRURJVE9SX1ZFUlNJT04gPSBcIjUuMS4yXCI7XG5cbi8qKlxuICogTWFqb3IgZW50cnkgcG9pbnQgZm9yIGNyZWF0aW5nIGEgQmxvY2tQeSBpbnN0YW5jZS5cbiAqIFR3byBtb3N0IGltcG9ydGFudCBmaWVsZHMgYXJlIGBtb2RlbGAgYW5kIGBjb21wb25lbnRzYC5cbiAqIFRoZSBgbW9kZWxgIGhvbGRzIGFsbCB0aGUgZGF0YSBhYm91dCB0aGUgaW50ZXJmYWNlLlxuICogVGhlIGBjb21wb25lbnRzYCBhcmUgcmVmZXJlbmNlcyB0byB0aGUgZGlzcGFyYXRlIHBhcnRzIG9mIEJsb2NrUHkuXG4gKlxuICogTW9zdCBvZiB0aGlzIGNsYXNzZXMgZGVmaW5pdGlvbiBpcyBqdXN0IGluaXRpYWxpemluZyB0aGUgbW9kZWwgYW5kIHVwZGF0aW5nXG4gKiBpdCBvbiBhbiBhc3NpZ25tZW50IHN3aXRjaC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrUHkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIC0gVXNlciBsZXZlbCBzZXR0aW5ncyAoZS5nLiwgd2hhdCBlZGl0b3IgbW9kZSwgd2hldGhlciB0byBtdXRlIHNlbWFudGljIGVycm9ycywgZXRjLilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudCAtIEFzc2lnbm1lbnQgbGV2ZWwgc2V0dGluZ3MgKGRhdGEgYWJvdXQgdGhlIGxvYWRlZCBhc3NpZ25tZW50LCB1c2VyLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIC0gSW5jbHVkZXMgdGhlIHNvdXJjZSBjb2RlIG9mIGFueSBwcm9ncmFtcyB0byBiZSBsb2FkZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBhc3NpZ25tZW50LCBzdWJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBpZiAoYXNzaWdubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFzc2lnbm1lbnQoY29uZmlndXJhdGlvbiwgYXNzaWdubWVudCwgc3VibWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWFpbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBCbG9ja1B5IG9iamVjdCBieSBpbml0aWFsaXppbmcgaXRzIGludGVyZmFjZSxcbiAgICAgKiBtb2RlbCwgYW5kIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0TWFpbigpIHtcbiAgICAgICAgdGhpcy5pbml0VXRpbGl0aWVzKCk7XG4gICAgICAgIHRoaXMuaW5pdE1vZGVsTWV0aG9kcygpO1xuICAgICAgICB0aGlzLnR1cm5PbkhhY2tzKCk7XG4gICAgICAgIHRoaXMuaW5pdEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLmFwcGx5TW9kZWwoKTtcbiAgICAgICAgdGhpcy5pbml0Q29tcG9uZW50cygpO1xuICAgICAgICB0aGlzLm1ha2VFeHRyYVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBkZWZhdWx0IHZhbHVlIG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdG8gbG9vayB1cCBhIHZhbHVlIGZvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0VmFsdWUgLSBpZiB0aGUga2V5IGlzIG5vdCBmb3VuZCBhbnl3aGVyZSwgdXNlIHRoaXMgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5nKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxTZXR0aW5nc18uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU2V0dGluZ3NfLmdldChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RlbCB0byBpdHMgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBDYXRlZ29yaWVzOlxuICAgICAqICAgKiB1c2VyOiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIgKHN0b3JlZCB0byBzZXJ2ZXIpXG4gICAgICogICAqIGFzc2lnbm1lbnQ6IHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgYXNzaWdubWVudCAoc3RvcmVkIHRvIHNlcnZlcilcbiAgICAgKiAgICogc3VibWlzc2lvbjogdmFsdWVzIGZvciB0aGUgY3VycmVudCBzdWJtaXNzaW9uIChzdG9yZWQgdG8gc2VydmVyKVxuICAgICAqICAgKiBkaXNwbGF5OiBmbGFncyByZWxhdGVkIHRvIGN1cnJlbnQgdmlzaWJpbGl0eSAoc3RvcmVkIHRvIGxvY2FsU2V0dGluZ3MpXG4gICAgICogICAqIHN0YXR1czogbWVzc2FnZXMgcmVsYXRlZCB0byBjdXJyZW50IHN0YXR1cyAobm90IHN0b3JlZClcbiAgICAgKiAgICogZXhlY3V0aW9uOiB2YWx1ZXMgcmVsYXRlZCB0byBsYXN0IHJ1biAobm90IHN0b3JlZClcbiAgICAgKiAgICogY29uZmlndXJhdGlvbjogY29uc3RhbnQgdmFsdWVzIHJlbGF0ZWQgdG8gc2V0dXAgKG5vdCBzdG9yZWQpXG4gICAgICovXG4gICAgaW5pdE1vZGVsKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgLy8gQ29ubmVjdCB0byBsb2NhbCBzdG9yYWdlXG4gICAgICAgIHRoaXMubG9jYWxTZXR0aW5nc18gPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcImxvY2FsU2V0dGluZ3NcIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fID0gY29uZmlndXJhdGlvbjtcblxuICAgICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmlkXCJdKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLm5hbWVcIl0pLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgeW91IGFyZSBhbiBPd25lciAoY2FuIG1vZGlmeSB0aGUgYXNzaWdubWVudCksIEdyYWRlciAoY2FuIHZpZXdcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXNzaWdubWVudHMnIGluZm9ybWF0aW9uKSBvciBTdHVkZW50IChjYW4gbm90IHNlZSBhbnkgaW5zdHJ1Y3RvciBzdHVmZikuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcm9sZToga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJ1c2VyLnJvbGVcIiwgXCJvd25lclwiKSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBjb3Vyc2UgZm9yIHRoaXMgdXNlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvdXJzZUlkOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJ1c2VyLmNvdXJzZV9pZFwiXSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBhc3NpZ25tZW50IGdyb3VwIHRoYXQgdGhpcyB1c2VyIGlzIGluc2lkZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcInVzZXIuZ3JvdXBfaWRcIl0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWdubWVudDoge1xuICAgICAgICAgICAgICAgIGlkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWU6IGtvLm9ic2VydmFibGUoXCJTY3JhdGNoIENhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IGtvLm9ic2VydmFibGUoXCJXZWxjb21lIHRvIEJsb2NrUHkuIFRyeSBlZGl0aW5nIGFuZCBydW5uaW5nIHRoZSBjb2RlIGJlbG93LlwiKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaHVtYW4tZnJpZW5kbHkgVVJMIHRvIHVzZSBhcyBhIHNob3J0Y3V0IGZvciB0aGlzIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybmluZyBtZXNzYWdlIGlmIG1hemVcbiAgICAgICAgICAgICAgICB0eXBlOiBrby5vYnNlcnZhYmxlKEFzc2lnbWVudFR5cGUuQkxPQ0tQWSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQ29kZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5zdGFydGluZ19jb2RlXCJdIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAgIG9uUnVuOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX3J1blwiXSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZToga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5vbl9jaGFuZ2VcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgb25FdmFsOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50Lm9uX2V2YWxcIl0gfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgZXh0cmFJbnN0cnVjdG9yRmlsZXM6IGtvLm9ic2VydmFibGVBcnJheShsb2FkQ29uY2F0ZW5hdGVkRmlsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzXCJdKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgZXh0cmFTdGFydGluZ0ZpbGVzOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgIGZvcmtlZElkOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGZvcmtlZFZlcnNpb246IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgb3duZXJJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb3Vyc2VJZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgc2FtcGxlU3VibWlzc2lvbnM6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgcmV2aWV3ZWQ6IGtvLm9ic2VydmFibGUoY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQucmV2aWV3ZWRcIl0pLFxuICAgICAgICAgICAgICAgIHB1YmxpYzoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5wdWJsaWNcIl0pLFxuICAgICAgICAgICAgICAgIGhpZGRlbjoga28ub2JzZXJ2YWJsZShjb25maWd1cmF0aW9uW1wiYXNzaWdubWVudC5oaWRkZW5cIl0pLFxuICAgICAgICAgICAgICAgIGlwUmFuZ2VzOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LmlwX3Jhbmdlc1wiXSksXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgICAgICBpZDoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBrby5vYnNlcnZhYmxlKGNvbmZpZ3VyYXRpb25bXCJzdWJtaXNzaW9uLmNvZGVcIl0gfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgZXh0cmFGaWxlczoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICB1cmw6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgc2NvcmU6IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgY29ycmVjdDoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudElkIGluZmVycmVkIGZyb20gYXNzaWdubWVudC5pZFxuICAgICAgICAgICAgICAgIC8vIGNvdXJzZUlkIGluZmVycmVkIGZyb20gdXNlci5jb3Vyc2VJZFxuICAgICAgICAgICAgICAgIC8vIHVzZXJJZCBpbmZlcnJlZCBmcm9tIHVzZXIuaWRcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50VmVyc2lvbiBpbmZlcnJlZCBmcm9tIGFzc2lnbm1lbnQudmVyc2lvblxuICAgICAgICAgICAgICAgIHZlcnNpb246IGtvLm9ic2VydmFibGUoMCksXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShcIlN0YXJ0ZWRcIiksXG4gICAgICAgICAgICAgICAgZ3JhZGluZ1N0YXR1czoga28ub2JzZXJ2YWJsZShcIk5vdFJlYWR5XCIpLFxuICAgICAgICAgICAgICAgIG93bmVySWQ6IGtvLm9ic2VydmFibGUobnVsbClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudGx5IHZpc2libGUgRmlsZSwgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgcHJlc2VudGVkIHdpdGggdGhlIGluc3RydWN0b3Igc2V0dGluZ3MgYW5kIGZpbGVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rvcjoga28ub2JzZXJ2YWJsZShcIlwiK3RoaXMuZ2V0U2V0dGluZyhcImRpc3BsYXkuaW5zdHJ1Y3RvclwiLCBcImZhbHNlXCIpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHByZXZlbnQgdGhlIHByaW50ZXIgZnJvbSBzaG93aW5nIHRoaW5nc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG11dGVQcmludGVyOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAoUHl0aG9uIFZpZXdzKSBUaGUgY3VycmVudCBlZGl0b3IgbW9kZS5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7RGlzcGxheU1vZGVzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHB5dGhvbk1vZGU6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5weXRob24ubW9kZVwiLCBEaXNwbGF5TW9kZXMuU1BMSVQpKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBIaXN0b3J5IG1vZGUgaXMgZW5nYWdlZC5cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBoaXN0b3J5TW9kZToga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgYXV0by1zYXZpbmcgY2hhbmdlcyBpbiBQeXRob24gZWRpdG9yXG4gICAgICAgICAgICAgICAgICogSWYgYW4gaW50ZWdlciwgc3BlY2lmaWVzIHRoZSBkZWxheSB0aGF0IHNob3VsZCBiZSB1c2VkIChtaWNyb3NlY29uZHMpLlxuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgbmV2ZXIgb24gaW4gbm9uLVB5dGhvbiBlZGl0b3JzLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfGludH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBhdXRvU2F2ZToga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY29uc29sZSBpcyBmdWxsIHdpZHRoIGFuZCBmZWVkYmFjayBpcyBoaWRkZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBiaWdDb25zb2xlOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIGNvbnNvbGUuXG4gICAgICAgICAgICAgICAgICogICAgSWYgbnVsbCwgdGhlbiBsZXQgdGhlIGhlaWdodCByZW1haW4gdW5jaGFuZ2VkXG4gICAgICAgICAgICAgICAgICogICAgSWYgYSBudW1iZXIsIHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcHJldmlvdXNDb25zb2xlSGVpZ2h0OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb25zb2xlSGVpZ2h0OiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoaWNoIHBhbmVsIHRvIHNob3cgaW4gdGhlIHNlY29uZCByb3cncyBzZWNvbmQgY29sdW1uXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1NlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9uc31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWNvbmRSb3dTZWNvbmRQYW5lbDoga28ub2JzZXJ2YWJsZShTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0spLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWw6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gYmUgdHJhY2luZyB0aGUgY29kZSByaWdodCBub3dcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0cmFjZUV4ZWN1dGlvbjoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGxpc3Qgb2YgcHJvbWlzZXMgdG8gc3RpbGwgcmVzb2x2ZSB3aGlsZSBsb2FkaW5nIGRhdGFzZXRzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5PFByb21pc2U+fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxvYWRpbmdEYXRhc2V0czoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgdGVtcG9yYXJ5IGNoYW5nZWQgdmFsdWUgb2YgdGhlIGluc3RydWN0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZCBmcm9tIHdoYXQgaXMgaW4gdGhlIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjaGFuZ2VkSW5zdHJ1Y3Rpb25zOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEEgaG9sZGVyIGZvciB0aGUgdGltZXIgdG8gdHJpZ2dlciBvbi1jaGFuZ2VzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdHJpZ2dlck9uQ2hhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgZmVlZGJhY2sgYW5kIG91dHB1dCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudCBzdWJtaXNzaW9uLlxuICAgICAgICAgICAgICAgICAqIFRoaXMgd291bGQgYmUgZmFsc2UgaWYgdGhlcmUgaXMgbm8gZmVlZGJhY2svb3V0cHV0IChpLmUuLCBjb2RlIGhhcyBub3QgYmVlbiBydW4pLFxuICAgICAgICAgICAgICAgICAqIG9yIGlmIHRoZSB1c2VyIGhhcyBtb2RpZmllZCB0aGUgc3VibWlzc2lvbiBhZnRlciB0aGUgbGFzdCBydW4gKGUuZy4sIGJ5IGVkaXRpbmdcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGlydHlTdWJtaXNzaW9uOiBrby5vYnNlcnZhYmxlKHRydWUpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqICBXaGV0aGVyIG9yIG5vdCB0byBtYWtlIHRoZSBCbG9ja1B5IGVsZW1lbnQgaW4gRlVMTCBTQ1JFRU4gbW9kZS4gU2FkbHksIG5vdCBmdWxsc2NyZWVuXG4gICAgICAgICAgICAgICAgICogIHdpdGhpbiB0aGUgd2luZG93LCBidXQgRlVMTCBTQ1JFRU4uIFZlcnkgYWdncmVzc2l2ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdWxsc2NyZWVuOiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVc2VyLXN1cHBsaWVkIHBhc3Njb2RlIHRvIGNvbXBhcmUgb24gdGhlIHNlcnZlciBhZ2FpbnN0IHRoZSBjdXJyZW50IHBhc3Njb2RlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBhc3Njb2RlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGNsZWFyIG91dCBpbnB1dHMgYWZ0ZXIgYSBydW4vb25fcnVuIGN5Y2xlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2xlYXJJbnB1dHM6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgaW1hZ2VzIHNob3VsZCBiZSByZW5kZXJlZCAodHJ1ZSksIG9yIGp1c3Qgc3RheSBhcyB0ZXh0IGNvZGUgKGZhbHNlKS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW5kZXJJbWFnZXM6IGtvLm9ic2VydmFibGUodHJ1ZSksXG4gICAgICAgICAgICAgICAgZWRpdG9yVmVyc2lvbjogRURJVE9SX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGtvLm9ic2VydmFibGUodGhpcy5nZXRTZXR0aW5nKFwiZGlzcGxheS5yZWFkX29ubHlcIiwgXCJmYWxzZVwiKS50b1N0cmluZygpPT09XCJ0cnVlXCIpLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVwbG9hZGVkIGZpbGVzIGFyZSBvbmVzIHRoYXQgaGF2ZSBiZWVuIGxpc3RlZCBieSB0aGUgcmVtb3RlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdXBsb2FkZWRGaWxlczoga28ub2JzZXJ2YWJsZShudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZEFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWRBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvYWRIaXN0b3J5OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2FkSGlzdG9yeU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgbG9hZERhdGFzZXQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIGxvYWREYXRhc2V0TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIGxvZ0V2ZW50OiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBsb2dFdmVudE1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2U6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVJbWFnZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBzYXZlRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgc2F2ZUFzc2lnbm1lbnQ6IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHNhdmVBc3NpZ25tZW50TWVzc2FnZToga28ub2JzZXJ2YWJsZShcIlwiKSxcbiAgICAgICAgICAgICAgICAvLyBAdHlwZSB7U2VydmVyU3RhdHVzfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb246IGtvLm9ic2VydmFibGUoU3RhdHVzU3RhdGUuUkVBRFkpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1czoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvblN0YXR1c01lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBsaXN0VXBsb2FkZWRGaWxlczoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgbGlzdFVwbG9hZGVkRmlsZXNNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgZG93bmxvYWRGaWxlOiBrby5vYnNlcnZhYmxlKFN0YXR1c1N0YXRlLlJFQURZKSxcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGVNZXNzYWdlOiBrby5vYnNlcnZhYmxlKFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEB0eXBlIHtTZXJ2ZXJTdGF0dXN9XG4gICAgICAgICAgICAgICAgdXBsb2FkRmlsZToga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICAgICAgdXBsb2FkRmlsZU1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJcIiksXG4gICAgICAgICAgICAgICAgLy8gQHR5cGUge1NlcnZlclN0YXR1c31cbiAgICAgICAgICAgICAgICBvbkV4ZWN1dGlvbjoga28ub2JzZXJ2YWJsZShTdGF0dXNTdGF0ZS5SRUFEWSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgaW4tcHJvZ3Jlc3MgZXhlY3V0aW9uc1xuICAgICAgICAgICAgICAgIHJlcG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgT3V0cHV0IG9iamVjdHNcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBpbnB1dHRlZCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGtvLm9ic2VydmFibGVBcnJheShbXSksXG4gICAgICAgICAgICAgICAgaW5wdXRJbmRleDoga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIGEgc3R1ZGVudCBydW5cbiAgICAgICAgICAgICAgICBzdHVkZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cjogdGhlIGZpbGVuYW1lIHRoYXQgd2FzIGxhc3QgZXhlY3V0ZWQgYW5kIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGVwOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZToga28ub2JzZXJ2YWJsZSgwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgb2Ygc2ltcGxlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYWNlRGF0YToga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2VTdGVwOiBrby5vYnNlcnZhYmxlKDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWwgZXhlY3V0aW9uIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsczoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbHM6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN5c21vZHVsZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gcmVsYXRlZCB0byBmZWVkYmFjayBmcm9tIHRoZSBpbnN0cnVjdG9yIHJ1blxuICAgICAgICAgICAgICAgIGZlZWRiYWNrOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0ciAobWFya2Rvd24pXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGtvLm9ic2VydmFibGUoXCJSZWFkeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBrby5vYnNlcnZhYmxlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc0Vycm9yOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLFxuICAgICAgICAgICAgICAgICAgICBsaW5lc1VuY292ZXJlZDoga28ub2JzZXJ2YWJsZUFycmF5KFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHM6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRnVuY3Rpb25zIHRvIGZpcmUgd2hlbiBjZXJ0YWluIGV2ZW50cyBvY2N1clxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogV2hlbiB0aGUgc3R1ZGVudCBnZXRzIGEgc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRoaXMuaW5pdGlhbENvbmZpZ3VyYXRpb25fW1wiY2FsbGJhY2suc3VjY2Vzc1wiXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzZXJ2ZXIgaXMgY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlcnZlckNvbm5lY3RlZDoga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNldHRpbmcoXCJzZXJ2ZXIuY29ubmVjdGVkXCIsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBibG9ja2x5UGF0aDogdGhpcy5pbml0aWFsQ29uZmlndXJhdGlvbl9bXCJibG9ja2x5LnBhdGhcIl0sXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudFBvaW50OiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcImF0dGFjaG1lbnQucG9pbnRcIl0sXG4gICAgICAgICAgICAgICAgLy8gSlF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBNYXBzIGNvZGVzICgnbG9nX2V2ZW50JywgJ3NhdmVfY29kZScpIHRvIFVSTHNcbiAgICAgICAgICAgICAgICB1cmxzOiB0aGlzLmluaXRpYWxDb25maWd1cmF0aW9uX1tcInVybHNcIl0gfHwge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgaW50ZXJmYWNlXG4gICAgICovXG4gICAgaW5pdEludGVyZmFjZSgpIHtcbiAgICAgICAgbGV0IGNvbnN0YW50cyA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbjtcbiAgICAgICAgbGV0IGd1aSA9IG1ha2VJbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIGNvbnN0YW50cy5jb250YWluZXIgPSAkKGNvbnN0YW50cy5hdHRhY2htZW50UG9pbnQpLmh0bWwoJChndWkpKTtcbiAgICB9O1xuXG4gICAgbG9hZEFzc2lnbm1lbnQoYXNzaWdubWVudF9pZCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvYWRBc3NpZ25tZW50KGFzc2lnbm1lbnRfaWQpO1xuICAgIH1cblxuICAgIGxvYWRUYWdzKHRhZ3MpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhIEpTT04gbGlzdCByZXByZXNlbnRpbmcgdGFnc1xuICAgIH1cblxuICAgIGxvYWRTYW1wbGVTdWJtaXNzaW9ucyhzYW1wbGVzKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBKU09OIGxpc3QgcmVwcmVzZW50aW5nIHNhbXBsZXNcbiAgICB9XG5cbiAgICBsb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmNvZGUoYXNzaWdubWVudC5zdGFydGluZ19jb2RlKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9zdGFydGluZ19maWxlcywgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpO1xuICAgIH1cblxuICAgIGxvYWRTdWJtaXNzaW9uKHN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpIHtcbiAgICAgICAgaWYgKCFzdWJtaXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2FyaWVyIFwiWW91IGFyZSBub3QgbG9nZ2VkIGluIG1lc3NhZ2VcIlxuICAgICAgICAgICAgdGhpcy5sb2FkTm9TdWJtaXNzaW9uKGFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFdoYXQgaWYgc3VibWlzc2lvbnMnIGFzc2lnbm1lbnQgdmVyc2lvbiBhbmQgdGhlIGFzc2lnbm1lbnRzJyB2ZXJzaW9uIGNvbmZsaWN0P1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uaWQoc3VibWlzc2lvbi5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb2RlKHN1Ym1pc3Npb24uY29kZSk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KHN1Ym1pc3Npb24uY29ycmVjdCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zY29yZShzdWJtaXNzaW9uLnNjb3JlKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmVuZHBvaW50KHN1Ym1pc3Npb24uZW5kcG9pbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24udXJsKHN1Ym1pc3Npb24udXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLnZlcnNpb24oc3VibWlzc2lvbi52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdWJtaXNzaW9uLmdyYWRpbmdTdGF0dXMoc3VibWlzc2lvbi5ncmFkaW5nX3N0YXR1cyk7XG4gICAgICAgIHRoaXMubW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKHN1Ym1pc3Npb24uc3VibWlzc2lvbl9zdGF0dXMpO1xuICAgICAgICB0aGlzLm1vZGVsLnN1Ym1pc3Npb24ub3duZXJJZChzdWJtaXNzaW9uLnVzZXJfaWQpO1xuICAgICAgICB0aGlzLm1vZGVsLnVzZXIuY291cnNlSWQoc3VibWlzc2lvbi5jb3Vyc2VfaWQpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShzdWJtaXNzaW9uLmV4dHJhX2ZpbGVzLCB0aGlzLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyk7XG4gICAgfVxuXG4gICAgbG9hZEFzc2lnbm1lbnREYXRhXyhkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5maWxlU3lzdGVtLmRpc21vdW50RXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgd2FzU2VydmVyQ29ubmVjdGVkID0gdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCgpO1xuICAgICAgICB0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgbGV0IGFzc2lnbm1lbnQgPSBkYXRhLmFzc2lnbm1lbnQ7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pZChhc3NpZ25tZW50LmlkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnZlcnNpb24oYXNzaWdubWVudC52ZXJzaW9uKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmNvdXJzZUlkKGFzc2lnbm1lbnQuY291cnNlX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZElkKGFzc2lnbm1lbnQuZm9ya2VkX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LmZvcmtlZFZlcnNpb24oYXNzaWdubWVudC5mb3JrZWRfdmVyc2lvbik7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oYXNzaWdubWVudC5oaWRkZW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoYXNzaWdubWVudC5yZXZpZXdlZCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5wdWJsaWMoYXNzaWdubWVudC5wdWJsaWMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudHlwZShhc3NpZ25tZW50LnR5cGUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQudXJsKGFzc2lnbm1lbnQudXJsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hc3NpZ25tZW50LnBvaW50cyhhc3NpZ25tZW50LnBvaW50cyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pcFJhbmdlcyhhc3NpZ25tZW50LmlwX3Jhbmdlcyk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoYXNzaWdubWVudC5pbnN0cnVjdGlvbnMpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQubmFtZShhc3NpZ25tZW50Lm5hbWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoYXNzaWdubWVudC5vbl9jaGFuZ2UgfHwgbnVsbCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50Lm9uX2NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShcIiFvbl9jaGFuZ2UucHlcIiwgYXNzaWdubWVudC5vbl9jaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoYXNzaWdubWVudC5vbl9ldmFsIHx8IG51bGwpO1xuICAgICAgICBpZiAoYXNzaWdubWVudC5vbl9ldmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKFwiIW9uX2V2YWwucHlcIiwgYXNzaWdubWVudC5vbl9ldmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oYXNzaWdubWVudC5vbl9ydW4pO1xuICAgICAgICB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKGFzc2lnbm1lbnQuc3RhcnRpbmdfY29kZSk7XG4gICAgICAgIHRoaXMubW9kZWwuYXNzaWdubWVudC5vd25lcklkKGFzc2lnbm1lbnQub3duZXJfaWQpO1xuICAgICAgICB0aGlzLmxvYWRUYWdzKGFzc2lnbm1lbnQudGFncyk7XG4gICAgICAgIHRoaXMubG9hZFNhbXBsZVN1Ym1pc3Npb25zKGFzc2lnbm1lbnQuc2FtcGxlX3N1Ym1pc3Npb25zKTtcbiAgICAgICAgbG9hZENvbmNhdGVuYXRlZEZpbGUoYXNzaWdubWVudC5leHRyYV9pbnN0cnVjdG9yX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMpO1xuICAgICAgICBsb2FkQ29uY2F0ZW5hdGVkRmlsZShhc3NpZ25tZW50LmV4dHJhX3N0YXJ0aW5nX2ZpbGVzLCB0aGlzLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKTtcbiAgICAgICAgbG9hZEFzc2lnbm1lbnRTZXR0aW5ncyh0aGlzLm1vZGVsLCBhc3NpZ25tZW50LnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5sb2FkU3VibWlzc2lvbihkYXRhLnN1Ym1pc3Npb24sIGFzc2lnbm1lbnQpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKHRydWUpO1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLnNlcnZlckNvbm5lY3RlZCh3YXNTZXJ2ZXJDb25uZWN0ZWQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuY29yZ2lzLmxvYWREYXRhc2V0cyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5yZWZyZXNoKCk7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5zZXRTdGF0dXMoXCJzYXZlRmlsZVwiLCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgfVxuXG4gICAgaW5pdE1vZGVsTWV0aG9kcygpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBtb2RlbC51aSA9IHtcbiAgICAgICAgICAgIHNtYWxsTGF5b3V0OiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSAmJiBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkpLFxuICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgIGlzR3JhZGVyOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC51c2VyLnJvbGUoKSA9PT0gXCJvd25lclwiIHx8IG1vZGVsLnVzZXIucm9sZSgpID09PSBcImdyYWRlclwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uczoge1xuICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuaW5zdHJ1Y3Rpb25zLmlzQ2hhbmdlZCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXRpbGl0aWVzLm1hcmtkb3duKG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucygpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnV0aWxpdGllcy5tYXJrZG93bihtb2RlbC5hc3NpZ25tZW50Lmluc3RydWN0aW9ucygpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcmVzZXQ6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuY2hhbmdlZEluc3RydWN0aW9ucyhudWxsKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5SW50ZXJhY3RpdmUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dEZ1bGxzY3JlZW46IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAobW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCkpID8gXCJmYS1jb21wcmVzcy1hcnJvd3MtYWx0XCIgOiBcImZhLWV4cGFuZC1hcnJvd3MtYWx0XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNsaWNrRnVsbHNjcmVlbjogKCkgPT57XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbighbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZWRpdElucHV0czogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuZGlhbG9nLkVESVRfSU5QVVRTKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b2dnbGVJbWFnZXM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0udGV4dEVkaXRvci5kaXNhYmxlSW1hZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuZW5hYmxlSW1hZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5yZW5kZXJJbWFnZXMoIW1vZGVsLmRpc3BsYXkucmVuZGVySW1hZ2VzKCkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FuTWFya1N1Ym1pdHRlZDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuaGlkZGVuKCkgfHwgbW9kZWwuYXNzaWdubWVudC5yZXZpZXdlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuY2FuQ2xvc2UoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dE1hcmtTdWJtaXR0ZWQ6IGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC51c2VyLmdyb3VwSWQoKSA/IFwiUHJvYmxlbSBjbG9zZWRcIiA6IFwiQXNzaWdubWVudCBjbG9zZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJlb3BlbiBmb3IgZWRpdGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc3BsYXkuZGlydHlTdWJtaXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJ1blwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpICYmIG1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiU3VibWl0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN1Ym1pdCBlYXJseVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2xpY2tNYXJrU3VibWl0dGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC51aS5tZW51LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiWW91IGNhbm5vdCByZW9wZW4gY2xvc2VkIGFzc2lnbm1lbnRzLiBDb250YWN0IGEgZ3JhZGVyIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbC51aS5tZW51LmlzU3VibWl0dGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvblN0YXR1cyhcImluUHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5kZWxheWVkUnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb25TdGF0dXMoXCJTdWJtaXR0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmFzc2lnbm1lbnQucmV2aWV3ZWQoKSB8fCBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmNhbkNsb3NlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN1Ym1pc3Npb24uc3VibWlzc2lvblN0YXR1cygpLnRvTG93ZXJDYXNlKCkgPT09IFwic3VibWl0dGVkXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLnN1Ym1pc3Npb25TdGF0dXMoKS50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBsZXRlZFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG93UXVldWVkSW5wdXRzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZVF1ZXVlZElucHV0cygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlY29uZFJvdzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOiBcImNvbC1tZC01XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZGVUcmFjZUJ1dHRvbjoga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZVRyYWNlQnV0dG9uKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGlzQWxsVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVNaWRkbGVQYW5lbCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0ZlZWRiYWNrVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLkZFRURCQUNLXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc1RyYWNlVmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0NvbnNvbGVTaG93VmlzaWJsZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlY29uZFJvdy5pc0ZlZWRiYWNrVmlzaWJsZSgpIHx8IG1vZGVsLnVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hMYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJWaWV3IFRyYWNlXCIgOiBcIlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhZHZhbmNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQYW5lbCA9IG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuRkVFREJBQ0spO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQYW5lbCgpID09PSBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuVFJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lbChTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMuTk9ORSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmVsKFNlY29uZFJvd1NlY29uZFBhbmVsT3B0aW9ucy5UUkFDRSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYWtlV2lkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFuZWwgPSBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWwoY3VycmVudFBhbmVsKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZWwoU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdG9yZVBhbmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFuZWwgPSBtb2RlbC5kaXNwbGF5LnByZXZpb3VzU2Vjb25kUm93U2Vjb25kUGFuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQYW5lbCgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5LnNlY29uZFJvd1NlY29uZFBhbmVsKG9sZFBhbmVsKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFuZWwobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uc29sZToge1xuICAgICAgICAgICAgICAgIHNpemU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3Muc21hbGxMYXlvdXQoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSA9PT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLk5PTkUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtNlwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoaWRlRXZhbHVhdGU6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpIHx8ICFtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZWVkYmFjazoge1xuICAgICAgICAgICAgICAgIGJhZGdlOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcnVudGltZS1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLXN5bnRheC1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtaW50ZXJuYWwtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtc2VtYW50aWMtZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmZWVkYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbC1mZWVkYmFjay1lcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWwtcHJvYmxlbS1jb21wbGV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLWluc3RydWN0aW9uc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vIGVycm9yc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxhYmVsLW5vLWVycm9yc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGtvLnB1cmVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbC5leGVjdXRpb24uZmVlZGJhY2suY2F0ZWdvcnkoKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJydW50aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUnVudGltZSBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlN5bnRheCBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVkaXRvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVkaXRvciBFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW50ZXJuYWwgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW1hbnRpY1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuYWx5emVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWxnb3JpdGhtIEVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmVlZGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnN0cnVjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5jb3JyZWN0IEFuc3dlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29tcGxldGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJubyBlcnJvcnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2U6IHtcbiAgICAgICAgICAgICAgICBoYXM6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCkgIT09IG51bGxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkTGluZToga28ucHVyZUNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuc2Vjb25kUm93U2Vjb25kUGFuZWwoKSAhPT0gU2Vjb25kUm93U2Vjb25kUGFuZWxPcHRpb25zLlRSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhIHx8IHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RyYWNlRGF0YVtzdGVwLTFdLmxpbmVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbGluZToga28ucHVyZUNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0U3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmxhc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFjZURhdGEgPSBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2VEYXRhIHx8IHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHRyYWNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkJlZm9yZSBydW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBsYXN0U3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRmluaXNoZWQgcnVuXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgYXJlIHRoZXNlIG51bWJlcnMgd29ua3k/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJMaW5lIFwiKyh0cmFjZURhdGFbc3RlcC0xXS5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYWNrd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBNYXRoLm1heCgwLCBtb2RlbC5leGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcChwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3J3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gTWF0aC5taW4obW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSwgbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobmV4dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAobW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiBrby5wdXJlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RTdGVwID0gbW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNlRGF0YSA9IG1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxhc3RTdGVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZURhdGFbc3RlcCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VEYXRhW3N0ZXBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgfHwgIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBrby5wdXJlQ29tcHV0ZWQoKCk9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSB8fCAhbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zbWFsbExheW91dCgpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sLW1kLTEyXCIgOiBcImNvbC1tZC02XCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnRzOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuc3dlci5weVwiOiByZXR1cm4gbW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWluc3RydWN0aW9ucy5tZFwiOiByZXR1cm4gbW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhb25fY2hhbmdlLnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2V2YWwucHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP21vY2tfdXJscy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/aW1hZ2VzLmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP2ltYWdlcy5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfcHJlZml4LnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFhbnN3ZXJfc3VmZml4LnB5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKCkuc29tZShmaWxlID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5maWxlbmFtZSgpID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90b29sYm94LmJsb2NrcHlcIjogcmV0dXJuIG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5zb21lKGZpbGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lKCkgPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhdGFncy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LnRhZ3MoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCI6IHJldHVybiBtb2RlbC5hc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP21vY2tfdXJscy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIWFuc3dlcl9wcmVmaXgucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhYW5zd2VyX3N1ZmZpeC5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90YWdzLmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI/c2V0dGluZ3MuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiP2ltYWdlcy5ibG9ja3B5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoLCBcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj90b29sYm94LmJsb2NrcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9ybWFsVG9vbGJveCA9IHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IuVE9PTEJPWEVTW1wibm9ybWFsXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbFRvb2xib3ggPSBKU09OLnN0cmluZ2lmeShub3JtYWxUb29sYm94LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgsIG5vcm1hbFRvb2xib3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnMoW1NhbXBsZVN1Ym1pc3Npb24uQmxhbmsoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2NoYW5nZS5weVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0ubmV3RmlsZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGZpeCBleHRyYWZpbGVzIGZvciBpbnN0cnVjdG9yIGFuZCBzdHVkZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIW9uX2V2YWwucHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50Lm9uRXZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImluc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5uZXdGaWxlRGlhbG9nKFwiaW5zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3R1ZGVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJzdHVkZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydGluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLm5ld0ZpbGVEaWFsb2coXCJzdGFydGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5maWxlbmFtZShwYXRoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5kZWxldGVGaWxlKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5hbWU6IChuZXdOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5yZW5hbWVGaWxlKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRTdHVkZW50Q29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVmaXhQeSA9IHNlbGYuY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCIhYW5zd2VyX3ByZWZpeC5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeFB5ID0gc2VsZi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uZ2V0RmlsZShcIiFhbnN3ZXJfc3VmZml4LnB5XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IHNlbGYubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXhQeSAmJiBwcmVmaXhQeS5oYW5kbGUgJiYgcHJlZml4UHkuaGFuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBwcmVmaXhQeS5oYW5kbGUoKSArIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1ZmZpeFB5ICYmIHN1ZmZpeFB5LmhhbmRsZSAmJiBzdWZmaXhQeS5oYW5kbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKyBzdWZmaXhQeS5oYW5kbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4dHJhU3R1ZGVudEZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMpLFxuICAgICAgICAgICAgICAgIGV4dHJhSW5zdHJ1Y3RvckZpbGVzOiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKSxcbiAgICAgICAgICAgICAgICBleHRyYVN0YXJ0aW5nRmlsZXM6IG9ic2VydmVDb25jYXRlbmF0ZWRGaWxlKG1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RmlsZW5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP21vY2tfdXJscy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVSTCBEYXRhXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP2ltYWdlcy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkltYWdlc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkFuc3dlciBQcmVmaXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCIhYW5zd2VyX3N1ZmZpeC5weVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbnN3ZXIgU3VmZml4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiP3Rvb2xib3guYmxvY2tweVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJUb29sYm94XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIiZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdG9yczoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtvLnB1cmVDb21wdXRlZCggKCk9PlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5nZXRFZGl0b3IobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGtvLnB1cmVDb21wdXRlZCgoKT0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLnNtYWxsTGF5b3V0KCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2wtbWQtMTJcIiA6IFwiY29sLW1kLTdcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdmlldzoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRWRpdG9ycygpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLm9ubHlJbnRlcmFjdGl2ZSgpKSkgPyBcIk5vbmVcIiA6XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA/IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpIDogXCJOb25lXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRmlsZS5SZXNldFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3VibWlzc2lvbi5jb2RlKG1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKCkpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMobW9kZWwuYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMoKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lKCkuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhblNhdmU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAhbW9kZWwuZGlzcGxheS5hdXRvU2F2ZSgpKSxcbiAgICAgICAgICAgICAgICBjYW5EZWxldGU6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIW1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaGlkZUZpbGVzKCkgfHwgbW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIFVOREVMRVRBQkxFX0ZJTEVTLmluZGV4T2YobW9kZWwuZGlzcGxheS5maWxlbmFtZSgpKSA9PT0gLTEpLFxuICAgICAgICAgICAgICAgIGNhblJlbmFtZToga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgICghbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5oaWRlRmlsZXMoKSB8fCBtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgVU5SRU5BTUFCTEVfRklMRVMuaW5kZXhPZihtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpID09PSAtMSksXG4gICAgICAgICAgICAgICAgdXBsb2FkOiB1cGxvYWRGaWxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkRmlsZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgICAgIGltcG9ydERhdGFzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmNvcmdpcy5vcGVuRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBweXRob246IHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGVNaXJyb3IgPSBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLnRleHRFZGl0b3IuY29kZU1pcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlTWlycm9yLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNvZGVNaXJyb3IuZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1vZGU6IChuZXdNb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1WaWV3LkNoYW5nZVwiLCBcIlwiLCBcIlwiLCBuZXdNb2RlLCBtb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZGlzcGxheS5weXRob25Nb2RlKG5ld01vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iub2xkUHl0aG9uTW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzSGlzdG9yeUF2YWlsYWJsZToga28ucHVyZUNvbXB1dGVkKCgpPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZEhpc3RvcnlcIikpLFxuICAgICAgICAgICAgICAgICAgICB0dXJuT2ZmSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3IudXBkYXRlRWRpdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLnNldFJlYWRPbmx5KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0dXJuT25IaXN0b3J5TW9kZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2FkSGlzdG9yeSgocmVzcG9uc2UpID0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5oaXN0b3J5LmxvYWQocmVzcG9uc2UuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaGlzdG9yeU1vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5weXRob25FZGl0b3Iuc2V0UmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0hJU1RPUlkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlSGlzdG9yeU1vZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9uSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICgpPT57IHNlbGYuY29tcG9uZW50cy5oaXN0b3J5Lm1vdmVUb1N0YXJ0KCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVByZXZpb3VzKCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS5tb3ZlTmV4dCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFJlY2VudDogKCk9Pnsgc2VsZi5jb21wb25lbnRzLmhpc3RvcnkubW92ZVRvTW9zdFJlY2VudCgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlOiAoKT0+eyBzZWxmLmNvbXBvbmVudHMuaGlzdG9yeS51c2UoKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbWFnZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkSW1hZ2VzOiAoKSA9PiBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJpbWFnZVwiKS5yZWxvYWRJbWFnZXMoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZTogKCkgPT4gc2VsZi5jb21wb25lbnRzLnNlcnZlci5zYXZlQXNzaWdubWVudCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzYW1wbGVTdWJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBidWlsZEVkaXRvcjogKG5ld0RPTSwgaW5kZXgsIG5ld0VsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGl0b3IgPSBzZWxmLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJTYW1wbGUgU3VibWlzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYnVpbGRFZGl0b3IobmV3RE9NLCBpbmRleCwgbmV3RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IHtcbiAgICAgICAgICAgICAgICBpc1J1bm5pbmc6IGtvLnB1cmVDb21wdXRlZCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMub25FeGVjdXRpb24oKSA9PT0gU3RhdHVzU3RhdGUuQUNUSVZFXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBydW5MYWJlbDoga28ucHVyZUNvbXB1dGVkKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbigpID09PSBTdGF0dXNTdGF0ZS5BQ1RJVkUgPyBcIlN0b3BcIiA6IFwiUnVuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJ1bjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKCkgPT09IFN0YXR1c1N0YXRlLkFDVElWRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQeWdhbWVMaWIgIT09IFwidW5kZWZpbmVkXCIgJiYgUHlnYW1lTGliLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQeWdhbWVMaWIuU3RvcFB5Z2FtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5lbmdpbmUuZGVsYXllZFJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmFsdWF0ZTogKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLmVuZ2luZS5ldmFsdWF0ZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAoZW5kcG9pbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXItc3RhdHVzLVwiICsgbW9kZWwuc3RhdHVzW2VuZHBvaW50XSgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpc0VuZHBvaW50Q29ubmVjdGVkOiAoZW5kcG9pbnQpID0+XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmNvbmZpZ3VyYXRpb24uc2VydmVyQ29ubmVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi51cmxzW2VuZHBvaW50XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBrby5wdXJlQ29tcHV0ZWQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgY2FwaXRhbGl6ZShtb2RlbC5zdGF0dXMubG9hZEFzc2lnbm1lbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlQXNzaWdubWVudE1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWRIaXN0b3J5TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9hZEZpbGVNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlRmlsZU1lc3NhZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLmxvYWREYXRhc2V0TWVzc2FnZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zdGF0dXMubG9nRXZlbnRNZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy5zYXZlSW1hZ2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuc3RhdHVzLnVwZGF0ZVN1Ym1pc3Npb25NZXNzYWdlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnN0YXR1cy51cGRhdGVTdWJtaXNzaW9uU3RhdHVzTWVzc2FnZSgpIHx8IFwiXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmb3JjZToge1xuICAgICAgICAgICAgICAgICAgICBsb2FkQXNzaWdubWVudDogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBmaWxlSGFuZGxlciA9ICQoXCIuYmxvY2tweS1mb3JjZS1sb2FkLWFzc2lnbm1lbnQtZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9maWxlSGFuZGxlci5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLnBhcmVudCgpLmZhZGVPdXQoMTAwKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXIgdG8gdXBsb2FkIGEgZmlsZSBjb250YWluaW5nIGFuIGFzc2lnbm1lbnQgc3VibWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IGFzc2lnbm1lbnRGb3JjZUxvYWRCdXR0b25bMF0uZmlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnRTdWJtaXNzaW9uID0gSlNPTi5wYXJzZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEFzc2lnbm1lbnREYXRhXyhhc3NpZ25tZW50U3VibWlzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIuZmlsZU5hbWUgPSBmaWxlc1swXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzVGV4dChmaWxlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50Rm9yY2VMb2FkQnV0dG9uLnZhbChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3VibWlzc2lvbjogKGRhdGEsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2VsZi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGV2ZW50LnRhcmdldCkuZmFkZU91dCgxMDApLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvb3Rlcjoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IGtvLnB1cmVDb21wdXRlZChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpIHx8ICFtb2RlbC51aS5zbWFsbExheW91dCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWFrZUV4dHJhSW50ZXJmYWNlU3Vic2NyaXB0aW9ucyhzZWxmLCBtb2RlbCk7XG4gICAgfVxuXG4gICAgdHVybk9uSGFja3MoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUT0RPXCIpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2ltYWdlLmpzXCJdID0gaW1hZ2VNb2R1bGUudG9TdHJpbmcoKTtcbiAgICAgICAgLy9Tay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3dlYWtyZWYuanNcIl0gPSB3ZWFrcmVmTW9kdWxlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9tYXRwbG90bGliL3B5cGxvdC9fX2luaXRfXy5qc1wiXSA9IG1hdHBsb3RsaWJNb2R1bGUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseXMgdGhlIEtub2Nrb3V0SlMgYmluZGluZ3MgdG8gdGhlIG1vZGVsLCBpbnN0YW50aWF0aW5nIHRoZSB2YWx1ZXMgaW50byB0aGVcbiAgICAgKiBIVE1MLlxuICAgICAqL1xuICAgIGFwcGx5TW9kZWwoKSB7XG4gICAgICAgIGtvLmFwcGx5QmluZGluZ3ModGhpcy5tb2RlbCwgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lclswXSk7XG4gICAgfVxuXG4gICAgaW5pdFV0aWxpdGllcygpIHtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzO1xuICAgICAgICB0aGlzLnV0aWxpdGllcyA9IHtcbiAgICAgICAgICAgIG1hcmtkb3duOiAodGV4dCkgPT4gdGV4dCA/IEVhc3lNREUucHJvdG90eXBlLm1hcmtkb3duKHRleHQpIDogXCI8cD48L3A+XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbml0Q29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXI7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIGxldCBtYWluID0gdGhpcztcbiAgICAgICAgLy8gRWFjaCBvZiB0aGVzZSBjb21wb25lbnRzIHdpbGwgdGFrZSB0aGUgQmxvY2tQeSBpbnN0YW5jZSwgYW5kIHBvc3NpYmx5IGFcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIHRoZSByZWxldmFudCBIVE1MIGxvY2F0aW9uIHdoZXJlIGl0IHdpbGwgYmUgZW1iZWRkZWQuXG4gICAgICAgIGNvbXBvbmVudHMuZGlhbG9nID0gbmV3IEJsb2NrUHlEaWFsb2cobWFpbiwgY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1kaWFsb2dcIikpO1xuICAgICAgICBjb21wb25lbnRzLmZlZWRiYWNrID0gbmV3IEJsb2NrUHlGZWVkYmFjayhtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrXCIpKTtcbiAgICAgICAgY29tcG9uZW50cy50cmFjZSA9IG5ldyBCbG9ja1B5VHJhY2UobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29uc29sZSA9IG5ldyBCbG9ja1B5Q29uc29sZShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWNvbnNvbGVcIikpO1xuICAgICAgICBjb21wb25lbnRzLmVuZ2luZSA9IG5ldyBCbG9ja1B5RW5naW5lKG1haW4pO1xuICAgICAgICBjb21wb25lbnRzLmZpbGVTeXN0ZW0gPSBuZXcgQmxvY2tQeUZpbGVTeXN0ZW0obWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuZWRpdG9ycyA9IG5ldyBFZGl0b3JzKG1haW4sIGNvbnRhaW5lci5maW5kKFwiLmJsb2NrcHktZWRpdG9yXCIpKTtcbiAgICAgICAgLy8gQ29udmVuaWVudCBzaG9ydGN1dCBkaXJlY3RseSB0byBQeXRob25FZGl0b3JcbiAgICAgICAgY29tcG9uZW50cy5weXRob25FZGl0b3IgPSB0aGlzLmNvbXBvbmVudHMuZWRpdG9ycy5ieU5hbWUoXCJweXRob25cIik7XG4gICAgICAgIGNvbXBvbmVudHMuc2VydmVyID0gbmV3IEJsb2NrUHlTZXJ2ZXIobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuY29yZ2lzID0gbmV3IEJsb2NrUHlDb3JnaXMobWFpbik7XG4gICAgICAgIGNvbXBvbmVudHMuaGlzdG9yeSA9IG5ldyBCbG9ja1B5SGlzdG9yeShtYWluLCBjb250YWluZXIuZmluZChcIi5ibG9ja3B5LWhpc3RvcnktdG9vbGJhclwiKSk7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgfVxuXG4gICAgbWFrZUV4dHJhU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMuc3Vic2NyaWJlKChjaGFuZ2VkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1JbnN0cnVjdGlvbnMuQ2hhbmdlXCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQsIFwiaW5zdHJ1Y3Rpb25zLm1kXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgIH1cblxuICAgIHJlc2V0SW50ZXJmYWNlKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZW5naW5lLnJlc2V0KCk7XG4gICAgICAgIC8vIERpc2FibGUgYW55IGFsdGVybmF0aXZlIGxvZ0VudHJ5IGZ1bmN0aW9ucyB3ZSBoYXZlIGJlZW4gZ2l2ZW5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNlcnZlci5hbHRMb2dFbnRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVxdWVzdFBhc3Njb2RlKCkge1xuICAgICAgICBsZXQgdXNlclN1cHBsaWVkUGFzc2NvZGUgPSBwcm9tcHQoXCJQbGVhc2UgZW50ZXIgdGhlIHBhc3Njb2RlLlwiKTtcbiAgICAgICAgdGhpcy5tb2RlbC5kaXNwbGF5LnBhc3Njb2RlKHVzZXJTdXBwbGllZFBhc3Njb2RlKTtcbiAgICB9XG5cbn1cblxuIiwiaW1wb3J0IHtlbmNvZGVIVE1MfSBmcm9tIFwiLi91dGlsaXRpZXNcIjtcblxuLyoqXG4gKiBFdmFsdWF0ZSBidXR0b24gSFRNTCB0ZW1wbGF0ZVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgU1RBUlRfRVZBTF9IVE1MID0gYFxuPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1vdXRsaW5lIGZsb2F0LXJpZ2h0IGJsb2NrcHktYnRuLWV2YWxcIj5cbiAgICBFdmFsdWF0ZVxuPC9idXR0b24+YDtcblxuLyoqXG4gKiBIVE1MIHRlbXBsYXRlIGZvciBhIG5ldyBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgTkVXX0NPTlNPTEVfTElORV9IVE1MID0gXCI8ZGl2PjwvZGl2PlwiO1xuXG4vKipcbiAqIEhUTUwgdGVtcGxhdGUgZm9yIHRoZSBlbnRpcmUgY29uc29sZSBhcmVhXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ09OU09MRV9IVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktcGFuZWwgYmxvY2tweS1jb25zb2xlJ1xuICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiQ29uc29sZVwiXG4gICAgICAgICAgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLmNvbnNvbGUuc2l6ZVwiPlxuICAgICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0IGJsb2NrcHktc2hvdy1mZWVkYmFjaydcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLnNlY29uZFJvdy5pc0NvbnNvbGVTaG93VmlzaWJsZSwgY2xpY2s6IHVpLnNlY29uZFJvdy5hZHZhbmNlU3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZXllJz48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICA8c3Ryb25nPkNvbnNvbGU6PC9zdHJvbmc+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LXByaW50ZXIgYmxvY2tweS1wcmludGVyLWRlZmF1bHQnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgIDwvZGl2PmA7XG5cbi8qKlxuICogQWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBmb3IgYSBsaW5lIGluIHRoZSBjb25zb2xlLlxuICogQGVudW1cbiAqL1xuZXhwb3J0IGxldCBDb25zb2xlTGluZVR5cGUgPSB7XG4gICAgVEVYVDogXCJ0ZXh0XCIsXG4gICAgSFRNTDogXCJodG1sXCIsXG4gICAgUExPVDogXCJwbG90XCIsXG4gICAgSU1BR0U6IFwiaW1hZ2VcIixcbiAgICBQWUdBTUU6IFwicHlnYW1lXCIsXG4gICAgVFVSVExFOiBcInR1cnRsZVwiLFxuICAgIEVWQUw6IFwiZXZhbFwiLFxuICAgIFNUQVJUX0VWQUw6IFwic3RhcnRfZXZhbFwiLFxuICAgIFZBTFVFOiBcInZhbHVlXCIsXG4gICAgSU5QVVQ6IFwiaW5wdXRcIixcbiAgICBURVNUX0NBU0U6IFwidGVzdF9jYXNlXCJcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgdmVyc2lvbiBvZiBhIGxpbmUgaW4gdGhlIGNvbnNvbGUuIEFsbCBvdGhlciBjb25zb2xlIGxpbmVzXG4gKiBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuIENyaXRpY2FsbHksIHRoZXkgbmVlZCB0byBpbXBsZW1lbnQgYSByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmNsYXNzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgYmFjayB0byB0aGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlLlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICogQHR5cGUge0Jsb2NrUHl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F0ZWdvcml6ZXMgd2hhdCBraW5kIG9mIGxpbmUgdGhpcyBpcyAodGV4dC9odG1sL3Bsb3QvZXRjLilcbiAgICAgICAgICogQHR5cGUge0NvbnNvbGVMaW5lVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0dWFsIGRhdGEgc3RvcmVkIG9uIHRoaXMgbGluZS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRhZGF0YSBhYm91dCB3aGVyZSB0aGUgbGluZSBvcmlnaW5hdGVkIGZyb20gaW4gdGhlIGNvZGUuXG4gICAgICAgICAqIEB0eXBlIHt7ZmlsZW5hbWU6IHN0cmluZywgbGluZTogbnVtYmVyLCBzdGVwOiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB7XG4gICAgICAgICAgICBmaWxlbmFtZTogU2suY3VyckZpbGVuYW1lLFxuICAgICAgICAgICAgc3RlcDogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCxcbiAgICAgICAgICAgIGxpbmU6IG1haW4uY29tcG9uZW50cy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBIVE1MIGNvbnRlbnQgc3RvcmVkIG9uIHRoaXMgbGluZSwgbWVhbnQgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICogdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEB0eXBlIHsqfGpRdWVyeS5mbi5pbml0fGpRdWVyeXxIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHRtbCA9ICQoXCI8ZGl2PjwvZGl2PlwiLCB7XG4gICAgICAgICAgICBcImNsYXNzXCI6ICBcImJsb2NrcHktcHJpbnRlci1vdXRwdXRcIixcbiAgICAgICAgICAgIFwiZGF0YS1jb250YWluZXJcIjogbWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludCxcbiAgICAgICAgICAgIFwiZGF0YS10b2dnbGVcIjogXCJ0b29sdGlwXCIsXG4gICAgICAgICAgICBcImRhdGEtcGxhY2VtZW50XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCJkYXRhLXN0ZXBcIjogdGhpcy5vcmlnaW4uc3RlcCxcbiAgICAgICAgICAgIFwidGl0bGVcIjogXCJTdGVwIFwiICsgdGhpcy5vcmlnaW4uc3RlcCArIFwiLCBMaW5lIFwiICsgdGhpcy5vcmlnaW4ubGluZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGluZSBzaG91bGQgYmUgdmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9ICFtYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTa3VscHQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zb2xlIGxpbmUncyBjb250ZW50LlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHRvU2t1bHB0KCkge1xuICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeSh0aGlzLmNvbnRlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnNvbGUgbGluZSBieSBkZWxldGluZyBpdHMgSFRNTCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuaHRtbC5yZW1vdmUoKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lVHVydGxlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIC8vIFRPRE86IENhcHR1cmUgdHVydGxlIGNvbW1hbmRzIGZvciB0cmFjaW5nIHB1cnBvc2VzXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuVFVSVExFKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXR1cnRsZS1vdXRwdXRcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHdoZXJlLnByZXBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sWzBdLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6IFwic21vb3RoXCIgfSk7XG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5odG1sLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgIC8vJCgnaHRtbCcpLnNjcm9sbFRvcCh0b3ApO1xuICAgICAgICAgICAgJChcImh0bWxcIikuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUHlnYW1lIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaikge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuUFlHQU1FKTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXB5Z2FtZS1vdXRwdXRcIik7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW47XG4gICAgICAgIHRoaXMucHlnYW1lT2JqID0gcHlnYW1lT2JqO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgLy9Tay5tYWluX2NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlDYW52YXNcIik7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgd2hlcmUucHJlcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuaHRtbC5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAkKFwiaHRtbFwiKS5zY3JvbGxUb3AodG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIC8vIFN0YXJ0cyBvZmYgYXMgYSBuby1vcFxuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCA9ICgpID0+IHt9O1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuc2Vjb25kUm93LnJlc3RvcmVQYW5lbCgpO1xuICAgIH1cblxuICAgIGZpbmFsaXplKGNsZWFudXBGdW5jdGlvbiwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiBjbGVhbnVwRnVuY3Rpb24odGhpcy5weWdhbWVPYmosIGxpc3RlbmVycyk7XG4gICAgfVxuXG59XG5cbmNsYXNzIENvbnNvbGVMaW5lSW1hZ2UgZXh0ZW5kcyBDb25zb2xlTGluZSB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgY29udGVudCkge1xuICAgICAgICBzdXBlcihtYWluLCBDb25zb2xlTGluZVR5cGUuSU1BR0UsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmh0bWwuYWRkQ2xhc3MoXCJibG9ja3B5LWNvbnNvbGUtaW1hZ2Utb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgd2hlcmUuYXBwZW5kKHRoaXMuaHRtbCk7XG4gICAgICAgICAgICAvL3RoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lUGxvdCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5QTE9ULCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5odG1sLmFkZENsYXNzKFwiYmxvY2tweS1jb25zb2xlLXBsb3Qtb3V0cHV0XCIpO1xuICAgIH1cblxuICAgIHJlbmRlcih3aGVyZSkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVUZXh0IGV4dGVuZHMgQ29uc29sZUxpbmUge1xuXG4gICAgYWRkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudCArIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIGlmICghZW5jb2RlZFRleHQgfHwgZW5jb2RlZFRleHQudHJpbSgpLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFRleHQgPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxzYW1wPjwvc2FtcD5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVWYWx1ZSBleHRlbmRzIENvbnNvbGVMaW5lIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4sIGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlZBTFVFLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IGVuY29kZWRUZXh0ID0gZW5jb2RlSFRNTCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgICAgbGV0IGxpbmVEYXRhID0gJChcIjxjb2RlPjwvY29kZT5cIiwgeyBcImh0bWxcIjogZW5jb2RlZFRleHQgfSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKGxpbmVEYXRhKTtcbiAgICAgICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgICAgICAgICAgdGhpcy5odG1sLnRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVJbnB1dCBleHRlbmRzIENvbnNvbGVMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBwcm9tcHRNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIENvbnNvbGVMaW5lVHlwZS5JTlBVVCwgcHJvbXB0TWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBJbnB1dCBib3ggZm9yIHJlY2VpdmluZyBpbnB1dCgpIGZyb20gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW5kZXIod2hlcmUpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFuaW5nXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIElucHV0IGZvcm1cbiAgICAgICAgICAgIGxldCBpbnB1dEZvcm0gPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIC8+XCIpO1xuICAgICAgICAgICAgLy8gRW50ZXIgYnV0dG9uXG4gICAgICAgICAgICBsZXQgaW5wdXRCdG4gPSAkKFwiPGJ1dHRvbj48L2J1dHRvbj5cIiwge1wiaHRtbFwiOiBcIkVudGVyXCJ9KTtcbiAgICAgICAgICAgIC8vIEdyb3VwIGZvcm0gYW5kIGJ1dHRvblxuICAgICAgICAgICAgbGV0IGlucHV0R3JvdXAgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1wiY2xhc3NcIjogXCJibG9ja3B5LWNvbnNvbGUtaW5wdXRcIn0pO1xuICAgICAgICAgICAgaW5wdXRHcm91cC5hcHBlbmQoaW5wdXRGb3JtKTtcbiAgICAgICAgICAgIGlucHV0R3JvdXAuYXBwZW5kKGlucHV0QnRuKTtcbiAgICAgICAgICAgIC8vIFByb21wdCBib3gsIG5ldyBsaW5lLCBpbnB1dCBncm91cFxuICAgICAgICAgICAgbGV0IGlucHV0Qm94ID0gJChcIjxkaXY+PC9kaXY+XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudCAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmNvZGVkVGV4dCA9IGVuY29kZUhUTUwodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRNc2cgPSAkKFwiPHNhbXA+PC9zYW1wPlwiLCAge1wiaHRtbFwiOiBlbmNvZGVkVGV4dH0pO1xuICAgICAgICAgICAgICAgIGlucHV0Qm94LmFwcGVuZChpbnB1dE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dEJveC5hcHBlbmQoJChcIjxicj5cIikpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChpbnB1dEdyb3VwKTtcbiAgICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgICAgdGhpcy5odG1sLmFwcGVuZChpbnB1dEJveCk7XG4gICAgICAgICAgICB3aGVyZS5hcHBlbmQodGhpcy5odG1sKTtcbiAgICAgICAgICAgIC8vIE1ha2UgaXQgaW50ZXJhY3RpdmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VJbnRlcmFjdGl2ZShpbnB1dEZvcm0sIGlucHV0QnRuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgbWFrZUludGVyYWN0aXZlKGlucHV0LCBidXR0b24pIHtcbiAgICAgICAgbGV0IHJlc29sdmVPbkNsaWNrO1xuICAgICAgICBsZXQgc3VibWl0dGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlT25DbGljayA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICBsZXQgc3VibWl0Rm9ybSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB1c2VySW5wdXR0ZWRWYWx1ZSA9IGlucHV0LnZhbCgpO1xuICAgICAgICAgICAgU2sucXVldWVkSW5wdXQucHVzaCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5wdXNoKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHJlc29sdmVPbkNsaWNrKHVzZXJJbnB1dHRlZFZhbHVlKTtcbiAgICAgICAgICAgIGlucHV0LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1dHRvbi5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmh0bWwudG9vbHRpcCgpO1xuICAgICAgICB9O1xuICAgICAgICBidXR0b24uY2xpY2soc3VibWl0Rm9ybSk7XG4gICAgICAgIGlucHV0LmtleXVwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgIHN1Ym1pdEZvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0SW5kZXgsIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5sZW5ndGgpO1xuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB1c2VySW5wdXR0ZWRWYWx1ZSA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIGlucHV0LnZhbCh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoaW5wdXRJbmRleCsxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBidXR0b24ucHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHRtbC50b29sdGlwKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VySW5wdXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VibWl0dGVkUHJvbWlzZTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnNvbGVMaW5lRXZhbHVhdGUgZXh0ZW5kcyBDb25zb2xlTGluZUlucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihtYWluKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIFwiRXZhbHVhdGU6XCIpO1xuICAgIH1cbn1cblxuY2xhc3MgQ29uc29sZUxpbmVTdGFydEV2YWx1YXRlIGV4dGVuZHMgQ29uc29sZUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgc3VwZXIobWFpbiwgQ29uc29sZUxpbmVUeXBlLlNUQVJUX0VWQUwpO1xuICAgICAgICB0aGlzLmh0bWwuYXBwZW5kKCQoU1RBUlRfRVZBTF9IVE1MKSk7XG4gICAgICAgIHRoaXMuaHRtbC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZXhlY3V0ZS5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKHdoZXJlKSB7XG4gICAgICAgIHdoZXJlLmFwcGVuZCh0aGlzLmh0bWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlDb25zb2xlIHtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBmb3IgbWFuYWdpbmcgdGhlIGNvbnNvbGUsIHdpdGggZmVhdHVyZXMgZm9yIHRoaW5ncyBsaWtlIHByaW50aW5nLCBwbG90dGluZywgZXZhbGluZywgaW5wdXRpbmcuXG4gICAgICogVGhlIFwicHJpbnRlclwiIGlzIHRoZSByZWdpb24gd2hlcmUgd2UgcHV0IHRoaW5ncywgYXMgb3Bwb3NlZCB0byB0aGUgY29uc29sZSBhcyBhIHdob2xlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1haW4gLSBUaGUgbWFpbiBCbG9ja1B5IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5wcmludGVyVGFnID0gdGFnLmZpbmQoXCIuYmxvY2tweS1wcmludGVyXCIpO1xuXG4gICAgICAgIHRoaXMuTUlOSU1VTV9XSURUSCA9IDIwMDtcbiAgICAgICAgdGhpcy5NSU5JTVVNX0hFSUdIVCA9IDIwMDtcbiAgICAgICAgdGhpcy5ERUZBVUxUX0hFSUdIVCA9IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKTsgLy8gTGV0IENTUyBkZWZpbmUgdGhpc1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5ERUZBVUxUX0hFSUdIVCk7XG5cbiAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dDtcbiAgICAgICAgLy90aGlzLmlucHV0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gVE9ETzogSWYgdGhlIHVzZXIgbW9kaWZpZXMgYSBmaWxlLCB0aGVuIG1ha2UgdGhlIGNvbnNvbGUgbG9vayBmYWRlZCBhIGxpdHRsZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgc3RhdHVzIG9mIHRoZSBwcmludGVyLCBpbmNsdWRpbmcgcmVtb3ZpbmcgYW55IHRleHQgaW4gaXQgYW5kXG4gICAgICogZml4aW5nIGl0cyBzaXplLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm91dHB1dC5yZW1vdmVBbGwoKTtcblxuICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByaW50ZXJUYWcuZW1wdHkoKTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGNoYW5nZWQgdGhlIGNvbnNvbGUgc2l6ZSwgd2UnbGwgcmVzZXQgaXRcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQodGhpcy5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5wcmV2aW91c0NvbnNvbGVIZWlnaHQodGhpcy5wcmludGVyVGFnLmhlaWdodCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHVydGxlTGluZSA9IG51bGw7XG4gICAgICAgIFNrLlR1cnRsZUdyYXBoaWNzID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldFR1cnRsZUxpbmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICBhc3NldHM6IHRoaXMubG9hZEFzc2V0LmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnB5Z2FtZUxpbmUgPSBudWxsO1xuICAgIH07XG5cbiAgICBsb2FkQXNzZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBnZXRUdXJ0bGVMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy50dXJ0bGVMaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnR1cnRsZUxpbmUgPSBuZXcgQ29uc29sZUxpbmVUdXJ0bGUodGhpcy5tYWluKTtcbiAgICAgICAgICAgIHRoaXMudHVydGxlTGluZS5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhc24ndCBjaGFuZ2VkIHRoZSBjb25zb2xlIHNpemUsIHdlJ2xsIGRvIHNvXG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHJldmlvdXNDb25zb2xlSGVpZ2h0KCkgPT09IHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UHJpbnRlckRpbWVuc2lvbiA9IHRoaXMucHJpbnRlclRhZy53aWR0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoY3VycmVudFByaW50ZXJEaW1lbnNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIFNrLlR1cnRsZUdyYXBoaWNzLmhlaWdodCA9IGN1cnJlbnRQcmludGVyRGltZW5zaW9uLTQwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR1cnRsZUxpbmUuaHRtbFswXTtcbiAgICB9XG5cbiAgICBoYW5kbGVQeWdhbWVSZXNpemUobmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXNuJ3QgY2hhbmdlZCB0aGUgY29uc29sZSBzaXplLCBhbmQgdGhlIG5ld0hlaWdodCBpcyBiaWdnZXIgdGhhbiBkZWZhdWx0LCB3ZSdsbCBjaGFuZ2UgaXRcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCgpID09PSB0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkgJiZcbiAgICAgICAgICAgIG5ld0hlaWdodCA+IHRoaXMuREVGQVVMVF9IRUlHSFQpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoMzArbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnByZXZpb3VzQ29uc29sZUhlaWdodCh0aGlzLnByaW50ZXJUYWcuaGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBweWdhbWUgd2luZG93IGlzIHdpZGVyIHRoYW4gdGhlIGNvbnNvbGUsIHdlJ2xsIGV4cGFuZCB0ZW1wb3JhcmlseS5cbiAgICAgICAgaWYgKG5ld1dpZHRoID4gdGhpcy5wcmludGVyVGFnLndpZHRoKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5zZWNvbmRSb3cubWFrZVdpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmlzaFR1cnRsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5zYXZlVHVydGxlT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR1cnRsZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy50dXJ0bGVMaW5lLmh0bWwuZmluZChcImNhbnZhc1wiKS5sYXN0KClbMF07XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlSW1hZ2UoXCJ0dXJ0bGVfb3V0cHV0XCIsIGRhdGFVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB5Z2FtZUxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5weWdhbWVMaW5lLmNhbnZhcztcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVJbWFnZShcInR1cnRsZV9vdXRwdXRcIiwgZGF0YVVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdoYXQgaWYgdGhlcmUgYXJlIG5vIHR1cnRsZXMgdG8gc2F2ZT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHR1cnRsZXMgc2hvdWxkIGJlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHdpZHRoXG4gICAgbmV3VHVydGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuTUlOSU1VTV9XSURUSCwgdGhpcy5wcmludGVyVGFnLndpZHRoKCktNDApO1xuICAgIH1cblxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuTUlOSU1VTV9IRUlHSFQsIHRoaXMucHJpbnRlclRhZy5oZWlnaHQoKSs0MCk7XG4gICAgfVxuXG4gICAgaXNNdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBlYWNoIHByaW50ZWQgZWxlbWVudCBpbiB0aGUgcHJpbnRlciBhbmQgbWFrZXMgaXQgaGlkZGVuXG4gICAgICogb3IgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIHdoYXQgc3RlcCB3ZSdyZSBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwIC0gVGhlIGN1cnJlbnQgc3RlcCBvZiB0aGUgZXhlY3V0ZWQgcHJvZ3JhbSB0aGF0IHdlJ3JlIG9uOyBlYWNoIGVsZW1lbnQgaW4gdGhlIHByaW50ZXIgbXVzdCBiZSBtYXJrZWQgd2l0aCBhIFwiZGF0YS1zdGVwXCIgcHJvcGVydHkgdG8gcmVzb2x2ZSB0aGlzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlIC0gRGVwcmVjYXRlZCwgbm90IHN1cmUgd2hhdCB0aGlzIGV2ZW4gZG9lcy5cbiAgICAgKi9cbiAgICBzdGVwUHJpbnRlcihzdGVwLCBwYWdlKSB7XG4gICAgICAgIHRoaXMucHJpbnRlclRhZy5maW5kKFwiLmJsb2NrcHktcHJpbnRlci1vdXRwdXRcIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmF0dHIoXCJkYXRhLXN0ZXBcIikgPD0gc3RlcCkge1xuICAgICAgICAgICAgICAgICQodGhpcykuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByaW50IGEgbGluZSB0byB0aGUgb24tc2NyZWVuIHByaW50ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVUZXh0IC0gQSBsaW5lIG9mIHRleHQgdG8gYmUgcHJpbnRlZCBvdXQuXG4gICAgICovXG4gICAgcHJpbnQobGluZVRleHQpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBtZWFucyBkbyBub3RoaW5nLlxuICAgICAgICAvLyBwcmludChcIlwiLCBlbmQ9XCJcIilcbiAgICAgICAgaWYgKCFsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAobGluZVRleHQuY2hhckF0KGxpbmVUZXh0Lmxlbmd0aC0xKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGxpdExpbmVzID0gbGluZVRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGlmICh0aGlzLmxpbmVCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVRleHQodGhpcy5tYWluLCBDb25zb2xlTGluZVR5cGUuVEVYVCwgc3BsaXRMaW5lc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIuYWRkQ29udGVudChzcGxpdExpbmVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTE7IGkgPCBzcGxpdExpbmVzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGhpcy5saW5lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlci5yZW5kZXIodGhpcy5wcmludGVyVGFnKTtcbiAgICAgICAgICAgIHRoaXMubGluZUJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZVRleHQodGhpcy5tYWluLCBDb25zb2xlTGluZVR5cGUuVEVYVCwgc3BsaXRMaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRoaXMubGluZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgICAgICB0aGlzLmxpbmVCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgcGxvdChwbG90cykge1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVQbG90KHRoaXMubWFpbiwgcGxvdHMpO1xuICAgICAgICB0aGlzLnBsb3RCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBsb3RCdWZmZXI7XG4gICAgfVxuXG4gICAgcHlnYW1lKHNpemUsIGZ1bGxzY3JlZW4sIHB5Z2FtZU9iaikge1xuICAgICAgICBpZiAodGhpcy5weWdhbWVMaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnB5Z2FtZUxpbmUgPSBuZXcgQ29uc29sZUxpbmVQeWdhbWUodGhpcy5tYWluLCBzaXplLCBmdWxsc2NyZWVuLCBweWdhbWVPYmopO1xuICAgICAgICAgICAgdGhpcy5weWdhbWVMaW5lLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB5Z2FtZUxpbmU7XG4gICAgfVxuXG4gICAgcHJpbnRQSUxJbWFnZShpbWFnZURhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJURVNUXCIsIGltYWdlRGF0YS5pbWFnZSk7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBuZXcgQ29uc29sZUxpbmVJbWFnZSh0aGlzLm1haW4sIGltYWdlRGF0YS5pbWFnZSk7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlQnVmZmVyO1xuICAgIH1cblxuICAgIHByaW50VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IHByaW50ZWRWYWx1ZSA9IG5ldyBDb25zb2xlTGluZVZhbHVlKHRoaXMubWFpbiwgdmFsdWUpO1xuICAgICAgICBwcmludGVkVmFsdWUucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgICAgIHJldHVybiBwcmludGVkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgUHJvbWlzZSBmcm9tIHRoZSBJbnB1dCBib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvbXB0TWVzc2FnZSAtIE1lc3NhZ2UgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IG5ldyBDb25zb2xlTGluZUlucHV0KHRoaXMubWFpbiwgcHJvbXB0TWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0QnVmZmVyLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH07XG5cblxuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLmlucHV0QnVmZmVyID0gbmV3IENvbnNvbGVMaW5lRXZhbHVhdGUodGhpcy5tYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRCdWZmZXIucmVuZGVyKHRoaXMucHJpbnRlclRhZyk7XG4gICAgfVxuXG4gICAgYmVnaW5FdmFsKCkge1xuICAgICAgICBsZXQgc3RhcnRFdmFsdWF0aW9uID0gbmV3IENvbnNvbGVMaW5lU3RhcnRFdmFsdWF0ZSh0aGlzLm1haW4pO1xuICAgICAgICByZXR1cm4gc3RhcnRFdmFsdWF0aW9uLnJlbmRlcih0aGlzLnByaW50ZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuY29uZGl0aW9uYWxseSBzY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93LlxuICAgICAqXG4gICAgICovXG4gICAgc2Nyb2xsVG9Cb3R0b20oKSB7XG4gICAgICAgIHRoaXMudGFnLmFuaW1hdGUoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiB0aGlzLnRhZy5wcm9wKFwic2Nyb2xsSGVpZ2h0XCIpIC0gdGhpcy50YWcucHJvcChcImNsaWVudEhlaWdodFwiKVxuICAgICAgICB9LCA1MDApO1xuICAgIH07XG5cbn0iLCJpbXBvcnQge3NsdWd9IGZyb20gXCIuL3V0aWxpdGllc1wiO1xuXG4vLyBUT0RPOiBlZGl0b3IuYm0uYmxvY2tFZGl0b3IuZXh0cmFUb29sc1tdXG5cbmV4cG9ydCBsZXQgX0lNUE9SVEVEX0RBVEFTRVRTID0ge307XG5leHBvcnQgbGV0IF9JTVBPUlRFRF9DT01QTEVURV9EQVRBU0VUUyA9IHt9O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsaXN0aWMgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCB0cmFuc2Zvcm1cbiAqIGEgZ2l2ZW4gYnV0dG9uIGludG8gYSBcIkxvYWRlZFwiIHN0YXRlIChkaXNhYmxlZCwgcHJlc3NlZCBzdGF0ZSwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnRuIC0gQW4gSFRNTCBlbGVtZW50IHRvIGNoYW5nZSB0aGUgdGV4dCBvZi5cbiAqL1xubGV0IHNldEJ1dHRvbkxvYWRlZCA9IGZ1bmN0aW9uIChidG4pIHtcbiAgICBidG4uYWRkQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgICAgLmFkZENsYXNzKFwiYnRuLXN1Y2Nlc3NcIilcbiAgICAgICAgLnJlbW92ZUNsYXNzKFwiYnRuLXByaW1hcnlcIilcbiAgICAgICAgLnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAudGV4dChcIkxvYWRlZFwiKVxuICAgICAgICAuYXR0cihcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIik7XG59O1xuXG5cbi8qKlxuICogTW9kdWxlIHRoYXQgY29ubmVjdHMgdG8gdGhlIENPUkdJUyBkYXRhc2V0cyBhbmQgbWFuYWdlcyBpbnRlcmFjdGlvbnNcbiAqIHdpdGggdGhlbS4gVGhpcyBpbmNsdWRlcyBsb2FkaW5nIGluIGRhdGFzZXRzIGF0IGxhdW5jaCBhbmQgb24tdGhlLWZseS5cbiAqIE5vdGUgdGhhdCB0aGlzIGhhcyBubyBwcmVzZW5jZSBvbiBzY3JlZW4sIHNvIGl0IGRvZXMgbm90IGhhdmUgYSB0YWcuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeUNvcmdpc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmxvY2tQeUNvcmdpcyhtYWluKSB7XG4gICAgdGhpcy5tYWluID0gbWFpbjtcblxuICAgIHRoaXMubG9hZGVkRGF0YXNldHMgPSBbXTtcbiAgICB0aGlzLmxvYWREYXRhc2V0cygpO1xufVxuXG5CbG9ja1B5Q29yZ2lzLnByb3RvdHlwZS5sb2FkRGF0YXNldHMgPSBmdW5jdGlvbiAoc2lsZW50bHkpIHtcbiAgICAvLyBMb2FkIGluIGVhY2ggdGhlIGRhdGFzZXRzXG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsLFxuICAgICAgICBlZGl0b3IgPSB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IsXG4gICAgICAgIHNlcnZlciA9IHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlcjtcbiAgICBsZXQgaW1wb3J0cyA9IFtdO1xuICAgIG1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGF0YXNldHMoKS5zcGxpdChcIixcIikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBpZiAobmFtZSAmJiAhKG5hbWUgaW4gQmxvY2tNaXJyb3JCbG9ja0VkaXRvci5FWFRSQV9UT09MUykpIHtcbiAgICAgICAgICAgIGltcG9ydHMucHVzaC5hcHBseShpbXBvcnRzLCB0aGlzLmltcG9ydERhdGFzZXQoc2x1ZyhuYW1lKSwgbmFtZSwgc2lsZW50bHkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV2hlbiBkYXRhc2V0cyBhcmUgbG9hZGVkLCB1cGRhdGUgdGhlIHRvb2xib3guXG4gICAgJC53aGVuLmFwcGx5KCQsIGltcG9ydHMpLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVFJJR0dFUkVEXCIpO1xuICAgICAgICBlZGl0b3IuYm0uZm9yY2VCbG9ja1JlZnJlc2goKTtcbiAgICAgICAgZWRpdG9yLmJtLmJsb2NrRWRpdG9yLnJlbWFrZVRvb2xib3goKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmVyLmZpbmFsaXplU3Vic2NyaXB0aW9ucygpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGUgZGVmaW5pdGlvbnMgZm9yIGEgZGF0YXNldCBpbnRvIHRoZSBlbnZpcm9ubWVudCwgaW5jbHVkaW5nXG4gKiB0aGUgZGF0YXNldCAoYXMgYSBKUyBmaWxlKSwgdGhlIHNrdWxwdCBiaW5kaW5ncywgYW5kIHRoZSBibG9ja2x5XG4gKiBiaW5kaW5ncy4gVGhpcyByZXF1aXJlcyBhY2Nlc3MgdG8gYSBDT1JHSVMgc2VydmVyLCBhbmQgb2NjdXJzXG4gKiBhc3luY2hyb25vdXNseS4gVGhlIHJlcXVlc3RzIGFyZSBmaXJlZCBhbmQgdGhlaXIgZGVmZXJyZWQgb2JqZWN0c1xuICogYXJlIHJldHVybmVkIC0gY2FsbGVycyBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gcGVyZm9ybSBhbiBhY3Rpb25cbiAqIG9uIGNvbXBsZXRpb24gb2YgdGhlIGltcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2x1ZyAtIFRoZSBVUkwgc2FmZSB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHVzZXItZnJpZW5kbHkgdmVyc2lvbiBvZiB0aGUgZGF0YXNldCBuYW1lLlxuICogQHJldHVybnMge0FycmF5LjxEZWZlcnJlZD59IC0gUmV0dXJucyB0aGUgYXN5bmMgcmVxdWVzdHMgYXMgZGVmZXJyZWQgb2JqZWN0cy5cbiAqL1xuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUuaW1wb3J0RGF0YXNldCA9IGZ1bmN0aW9uIChzbHVnLCBuYW1lKSB7XG4gICAgbGV0IHVybF9yZXRyaWV2YWxzID0gW107XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImltcG9ydERhdGFzZXRzXCIpKSB7XG4gICAgICAgIGxldCByb290ID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscy5pbXBvcnREYXRhc2V0cyArIFwiYmxvY2tweS9cIiArIHNsdWcgKyBcIi9cIiArIHNsdWc7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmxvYWRpbmdEYXRhc2V0cy5wdXNoKG5hbWUpO1xuICAgICAgICAvLyBBY3R1YWxseSBnZXQgZGF0YVxuICAgICAgICBsZXQgZ2V0RGF0YXNldCA9ICQuZ2V0U2NyaXB0KHJvb3QgKyBcIl9kYXRhc2V0LmpzXCIpO1xuICAgICAgICAvLyBMb2FkIGdldENvbXBsZXRlIHNpbGVudGx5IGluIHRoZSBiYWNrZ3JvdW5kIGJlY2F1c2UgaXRzIGJpZyA6KFxuICAgICAgICBsZXQgZ2V0Q29tcGxldGUgPSAkLmdldFNjcmlwdChyb290ICsgXCJfY29tcGxldGUuanNcIik7XG4gICAgICAgIGxldCBnZXRTa3VscHQgPSAkLmdldChyb290ICsgXCJfc2t1bHB0LmpzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtcInNyYy9saWIvXCIgKyBzbHVnICsgXCIvX19pbml0X18uanNcIl0gPSBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGdldEJsb2NrbHkgPSAkLmdldFNjcmlwdChyb290ICsgXCJfYmxvY2tseS5qc1wiKTtcbiAgICAgICAgLy8gT24gY29tcGxldGlvbiwgdXBkYXRlIG1lbnVzLlxuICAgICAgICAkLndoZW4oZ2V0RGF0YXNldCwgZ2V0U2t1bHB0LCBnZXRCbG9ja2x5KS5kb25lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkRGF0YXNldHMucHVzaChzbHVnKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS50ZXh0VG9CbG9ja3MuaGlkZGVuSW1wb3J0cy5wdXNoKHNsdWcpO1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmZvcmNlQmxvY2tSZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubG9hZGluZ0RhdGFzZXRzLnJlbW92ZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVybF9yZXRyaWV2YWxzLnB1c2goZ2V0RGF0YXNldCwgZ2V0U2t1bHB0LCBnZXRCbG9ja2x5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVybF9yZXRyaWV2YWxzO1xufTtcblxuLyoqXG4gKiBPcGVucyBhIGRpYWxvZyBib3ggdG8gcHJlc2VudCB0aGUgdXNlciB3aXRoIHRoZSBkYXRhc2V0cyBhdmFpbGFibGVcbiAqIHRocm91Z2ggdGhlIENPUkdJUyBzZXJ2ZXIuIFRoaXMgcmVxdWlyZXMgYSBjYWxsLCBzbyB0aGlzIG1ldGhvZFxuICogY29tcGxldGVzIGFzeW5jaHJvbm91c2x5LiBUaGUgZGlhbG9nIGlzIGNvbXBvc2VkIG9mIGEgdGFibGUgd2l0aFxuICogYnV0dG9ucyB0byBsb2FkIHRoZSBkYXRhc2V0cyAoTW9yZSB0aGFuIG9uZSBkYXRhc2V0IGNhbiBiZSBsb2FkZWRcbiAqIGZyb20gd2l0aGluIHRoZSBkaWFsb2cgYXQgYSB0aW1lKS5cbiAqL1xuQmxvY2tQeUNvcmdpcy5wcm90b3R5cGUub3BlbkRpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwiaW1wb3J0RGF0YXNldHNcIikpIHtcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi51cmxzLmltcG9ydERhdGFzZXRzO1xuICAgICAgICAkLmdldEpTT04ocm9vdCArIFwiaW5kZXguanNvblwiLCAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2UgdXAgdGhlIEJvZHlcbiAgICAgICAgICAgIGxldCBkYXRhc2V0cyA9IGRhdGEuYmxvY2tweTtcbiAgICAgICAgICAgIGxldCBkb2N1bWVudGF0aW9uID0gcm9vdCtcImJsb2NrcHkvaW5kZXguaHRtbFwiO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJChgPHA+RG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQgPGEgaHJlZj0nJHtkb2N1bWVudGF0aW9ufScgdGFyZ2V0PV9ibGFuaz51cmw8L2E+PC9wPmApO1xuICAgICAgICAgICAgbGV0IGJvZHkgPSAkKFwiPHRhYmxlPjwvdGFibGU+XCIsIHtcImNsYXNzXCI6IFwidGFibGUgdGFibGUtYm9yZGVyZWQgdGFibGUtc20gdGFibGUtc3RyaXBlZFwifSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhc2V0cykuc29ydCgpLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzbHVnZ2VkTmFtZSA9IHNsdWcoZGF0YXNldHNbbmFtZV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGJ0biA9ICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgZGF0YS10b2dnbGU9XCJidXR0b25cIiBhcmlhLXByZXNzZWQ9XCJmYWxzZVwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiPkxvYWQ8L2J1dHRvbj4nKTtcbiAgICAgICAgICAgICAgICBsZXQgaW1nU3JjID0gcm9vdCtcIi4uL2ltYWdlcy9kYXRhc2V0cy9cIituYW1lK1wiLWljb24ucG5nXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkRGF0YXNldHMuaW5kZXhPZihzbHVnZ2VkTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRCdXR0b25Mb2FkZWQoYnRuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidG4uY2xpY2soICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0RGF0YXNldChzbHVnZ2VkTmFtZSwgXCJEYXRhIC0gXCIgKyBkYXRhc2V0c1tuYW1lXS50aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCdXR0b25Mb2FkZWQoYnRuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vbGV0IGltZyA9IGA8aW1nIHNyYz0nJHtpbWdTcmN9JyBjbGFzcz1cImNvcmdpcy1pY29uXCI+YDtcbiAgICAgICAgICAgICAgICAkKFwiPHRyPjwvdHI+XCIpXG4gICAgICAgICAgICAgICAgICAgIC8vLmFwcGVuZCgkKFwiPHRkPlwiICsgaW1nICsgXCI8L3RkPlwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHRkPlwiICsgZGF0YXNldHNbbmFtZV0udGl0bGUgKyBcIjwvdGQ+XCIpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8dGQ+XCIgKyBkYXRhc2V0c1tuYW1lXS5vdmVydmlldyArIFwiPC90ZD5cIikpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjx0ZD48L3RkPlwiKS5hcHBlbmQoYnRuKSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGJvZHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZFRvKHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIFNob3cgdGhlIGFjdHVhbCBkaWFsb2dcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5zaG93KFwiSW1wb3J0IERhdGFzZXRzXCIsIHN0YXJ0LCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTY1NDg4NjM5NTYzMFxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9hY2JhcnQvUHJvamVjdHMvYmxvY2tweS1lZHUvYmxvY2tweS9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIuLi9cIixcImhtclwiOnRydWUsXCJsb2NhbHNcIjpmYWxzZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBtb2R1bGUuaG90LmFjY2VwdCh1bmRlZmluZWQsIGNzc1JlbG9hZCk7XG4gICAgfVxuICAiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNjU0ODg2Mzk1NjM2XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkM6L1VzZXJzL2FjYmFydC9Qcm9qZWN0cy9ibG9ja3B5LWVkdS9ibG9ja3B5L25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi4uL1wiLFwiaG1yXCI6dHJ1ZSxcImxvY2Fsc1wiOmZhbHNlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIG1vZHVsZS5ob3QuYWNjZXB0KHVuZGVmaW5lZCwgY3NzUmVsb2FkKTtcbiAgICB9XG4gICIsIi8vIFRPRE86IER5YW5taWNhbGx5IHBvcHVsYXRlIGFyaWEtbGFiZWxsZWRieSBpbiB0aGlzIGFuZCBvdGhlciBwbGFjZXNcblxuZXhwb3J0IGxldCBESUFMT0dfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPSdibG9ja3B5LWRpYWxvZyBtb2RhbCBoaWRkZW4nXG4gICAgICAgICByb2xlPVwiZGlhbG9nXCJcbiAgICAgICAgIGFyaWEtbGFiZWw9J0RpYWxvZydcbiAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1kaWFsb2cgbW9kYWwtbGcnIHJvbGU9XCJkb2N1bWVudFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtY29udGVudCcgcm9sZT0ncmVnaW9uJyBhcmlhLWxhYmVsPSdEaWFsb2cgY29udGVudCc+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtaGVhZGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPSdtb2RhbC10aXRsZSc+RHluYW1pYyBDb250ZW50PC9oND5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdjbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCcgYXJpYS1oaWRkZW49J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbW9kYWwtYm9keScgc3R5bGU9J21heC13aWR0aDoxMDAlOyBtYXgtaGVpZ2h0OjQwMHB4Jz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtb2RhbC1mb290ZXInPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUgbW9kYWwtY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPkNsb3NlPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1zdWNjZXNzIG1vZGFsLW9rYXknIGRhdGEtZGlzbWlzcz0nbW9kYWwnPk9rYXk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gICAgXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5gO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBvYmplY3QgZm9yIHF1aWNrbHkgYW5kIGNvbnZlbmllbnRseSBnZW5lcmF0aW5nIGRpYWxvZyBib3hlcy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoaXMgZG9lc24ndCBkeW5hbWljYWxseSBjcmVhdGUgbmV3IGJveGVzOyBpdCByZXVzZXMgdGhlIHNhbWUgb25lXG4gKiBvdmVyIGFuZCBvdmVyIGFnYWluLiBJdCB0dXJucyBvdXQgZHluYW1pY2FsbHkgZ2VuZXJhdGluZyBuZXcgZGlhbG9nIGJveGVzXG4gKiBpcyBhIHBhaW4hIFNvIHdlIGNhbid0IHN0YWNrIHRoZW0uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7QmxvY2tQeURpYWxvZ31cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gVGhlIEhUTUwgb2JqZWN0IHRoaXMgaXMgYXR0YWNoZWQgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja1B5RGlhbG9nKG1haW4sIHRhZykge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgdGhpcy50YWcgPSB0YWc7XG5cbiAgICB0aGlzLnRpdGxlVGFnID0gdGFnLmZpbmQoXCIubW9kYWwtdGl0bGVcIik7XG4gICAgdGhpcy5ib2R5VGFnID0gdGFnLmZpbmQoXCIubW9kYWwtYm9keVwiKTtcbiAgICB0aGlzLmZvb3RlclRhZyA9IHRhZy5maW5kKFwiLm1vZGFsLWZvb3RlclwiKTtcbiAgICB0aGlzLm9rYXlCdXR0b24gPSB0YWcuZmluZChcIi5tb2RhbC1va2F5XCIpO1xuICAgIHRoaXMuY2xvc2VCdXR0b24gPSB0YWcuZmluZChcIi5tb2RhbC1jbG9zZVwiKTtcblxuICAgIHRoaXMueWVzID0gKCkgPT4ge307XG4gICAgdGhpcy5ubyA9ICgpID0+IHt9O1xuICAgIHRoaXMub2theUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMueWVzKCk7XG4gICAgICAgIHRoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ubygpO1xuICAgICAgICAvL3RoaXMudGFnLm1vZGFsKFwiaGlkZVwiKTtcbiAgICB9KTtcbn1cblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50YWcubW9kYWwoXCJoaWRlXCIpO1xufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBleHRlcm5hbGx5IGF2YWlsYWJsZSBmdW5jdGlvbiBmb3IgcG9wcGluZyB1cCBhIGRpYWxvZ1xuICogbWVzc2FnZS4gVGhpcyBtZW51IHdpbGwgYmUgZHJhZ2dhYmxlIGJ5IGl0cyB0aXRsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIG1lc3NhZ2UgZGlhbG9nLiBDYW4gaGF2ZSBIVE1MLlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbWVzc2FnZSBkaWFsb2cuIENhbiBoYXZlIEhUTUwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmNsb3NlIC0gQSBmdW5jdGlvbiB0byBiZSBydW4gd2hlbiB0aGUgdXNlciBjbG9zZXMgdGhlIGRpYWxvZy5cbiAqL1xuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICh0aXRsZSwgYm9keSwgb25jbG9zZSkge1xuICAgIHRoaXMudGl0bGVUYWcuaHRtbCh0aXRsZSk7XG4gICAgdGhpcy5ib2R5VGFnLmh0bWwoYm9keSk7XG4gICAgdGhpcy50YWcubW9kYWwoXCJzaG93XCIpO1xuICAgIHRoaXMub2theUJ1dHRvbi5oaWRlKCk7XG4gICAgdGhpcy50YWcuZHJhZ2dhYmxlKHtcbiAgICAgICAgXCJoYW5kbGVcIjogXCIubW9kYWwtdGl0bGVcIlxuICAgIH0pO1xuXG4gICAgdGhpcy50YWcub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG9uY2xvc2UgIT09IHVuZGVmaW5lZCAmJiBvbmNsb3NlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLmNvbmZpcm0gPSBmdW5jdGlvbiAodGl0bGUsIGJvZHksIHllcywgbm8sIHllc1RleHQpIHtcbiAgICBpZiAoeWVzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHllc1RleHQgPSBcIk9rYXlcIjtcbiAgICB9XG4gICAgdGhpcy5zaG93KHRpdGxlLCBib2R5LCBubyk7XG4gICAgdGhpcy55ZXMgPSB5ZXM7XG4gICAgdGhpcy5ubyA9IG5vO1xuICAgIHRoaXMub2theUJ1dHRvbi5zaG93KCkuaHRtbCh5ZXNUZXh0KTtcbiAgICAvLyBUT0RPOiBhZGQgb2theSBidXR0b24gYW5kIGNhbmNlbCBidXR0b25cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkFTU0lHTk1FTlRfVkVSU0lPTl9DSEFOR0VEID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29uZmlybShcIkFzc2lnbm1lbnQgQ2hhbmdlZFwiLCBcIllvdXIgaW5zdHJ1Y3RvciBoYXMgbWFkZSBjaGFuZ2VzIHRvIHRoaXMgYXNzaWdubWVudC4gV291bGQgeW91IGxpa2UgdG8gcmVsb2FkPyBBbGwgeW91ciB3b3JrIGhhcyBiZWVuIHNhdmVkLlwiLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgQXNzaWdubWVudFwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBhc3NpZ25tZW50Ljxicj5cblBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi48YnI+UmVzcG9uc2UgZnJvbSBzZXJ2ZXIgd2FzOjxicj48cHJlPiR7cmVhc29ufTwvcHJlPmAsKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX0xJU1RJTkdfVVBMT0FERURfRklMRVMgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5zaG93KFwiRXJyb3IgTGlzdGluZyBVcGxvYWRlZCBGaWxlc1wiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsaXN0aW5nIHRoZSB1cGxvYWRlZCBmaWxlcy48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9VUExPQURJTkdfRklMRSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLnNob3coXCJFcnJvciBVcGxvYWRlZCBGaWxlXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwbG9hZGluZyB0aGUgZmlsZS48YnI+XG5QbGVhc2UgdHJ5IGFnYWluLjxicj5SZXNwb25zZSBmcm9tIHNlcnZlciB3YXM6PGJyPjxwcmU+JHtyZWFzb259PC9wcmU+YCwpO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfU0FWSU5HX0FTU0lHTk1ORU5UID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFNhdmluZyBBc3NpZ25tZW50XCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHNhdmluZyB0aGUgYXNzaWdubWVudC48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPlJlc3BvbnNlIGZyb20gc2VydmVyIHdhczo8YnI+PHByZT4ke3JlYXNvbn08L3ByZT5gLCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FUlJPUl9TSE9XX1NUVURFTlRfRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLnNob3coXCJPcmlnaW5hbCBFcnJvclwiLCBgV2hlbiBJIHJhbiB5b3VyIGNvZGUsIEkgZW5jb3VudGVyZWQgYW4gZXJyb3I6XFxuXFxuPGRpdiBjbGFzcz1cImJsb2NrcHktZGlhbG9nLXN0dWRlbnQtZXJyb3ItbWVzc2FnZVwiPiR7ZXJyb3J9PC9kaXY+YCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5QT1NJVElWRV9GRUVEQkFDS19GVUxMID0gZnVuY3Rpb24gKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5zaG93KHRpdGxlLCBtZXNzYWdlKTtcbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLlNDUkVFTlNIT1RfQkxPQ0tTID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE9cbn07XG5cbkJsb2NrUHlEaWFsb2cucHJvdG90eXBlLkVSUk9SX1VQREFUSU5HX1NVQk1JU1NJT05fU1RBVFVTID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIFVwZGF0aW5nIFN1Ym1pc3Npb24gU3RhdHVzXCIsIGBCbG9ja1B5IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIHlvdXIgc3VibWlzc2lvbiBzdGF0dXMuPGJyPlxuUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLmApO1xufTtcblxuQmxvY2tQeURpYWxvZy5wcm90b3R5cGUuRVJST1JfTE9BRElOR19ISVNUT1JZID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hvdyhcIkVycm9yIExvYWRpbmcgSGlzdG9yeVwiLCBgQmxvY2tQeSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIHlvdXIgaGlzdG9yeS48YnI+XG5QbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5PRkZFUl9GT1JLID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzZXR1cFVybCA9IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLnVybHMuaW5zdHJ1Y3Rpb25zQXNzaWdubWVudFNldHVwO1xuICAgIHNldHVwVXJsID0gc2V0dXBVcmwgPyBgICg8YSBocmVmPVwiJHtzZXR1cFVybH1cIiB0YXJnZXQ9XCJfYmxhbmtcIj5Ib3cgZG8gSSBkbyB0aGF0PzwvYT4pYCA6IFwiXCI7XG4gICAgdGhpcy5zaG93KFwiQXNzaWdubWVudCBOb3QgT3duZWQ7IEZvcms/XCIsIGBcbiAgICA8ZGl2IGNsYXNzPVwibWItNFwiPlxuICAgICAgICBJdCBsb29rcyBsaWtlIHlvdSB3YW50IHRvIGVkaXQgdGhpcyBhc3NpZ25tZW50LCBidXQgeW91IGFyZSBub3QgYW4gaW5zdHJ1Y3RvclxuICAgIG9yIGRlc2lnbmVyIGluIHRoZSBjb3Vyc2UgdGhhdCBvd25zIGl0IChcIkNvdXJzZSBOYW1lXCIpLiBXb3VsZCB5b3UgbGlrZSB0byBmb3JrXG4gICAgdGhpcyBhc3NpZ25tZW50IChvciBpdHMgZW50aXJlIGdyb3VwKSBzbyB0aGF0IHlvdSBjYW4gc2F2ZSB5b3VyIG1vZGlmaWNhdGlvbnM/XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cIm1iLTRcIj5cbiAgICAgICAgUmVtZW1iZXIgdG8gdXBkYXRlIHRoZSBMYXVuY2ggVVJMIGluIHRoZSBhc3NpZ25tZW50cycgc2V0dGluZ3Mgb24gQ2FudmFzISR7c2V0dXBVcmx9XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdj48YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4td2hpdGUnPkZvcmsgZW50aXJlIGFzc2lnbm1lbnQgZ3JvdXA8L2J1dHRvbj48L2Rpdj5cbiAgICA8ZGl2PjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi13aGl0ZSc+Rm9yayBqdXN0IHRoaXMgYXNzaWdubWVudDwvYnV0dG9uPjwvZGl2PlxuICAgIDxkaXY+PGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLWRhbmdlcic+UmVzZXQgbXkgbG9jYWwgY2hhbmdlczwvYnV0dG9uPjwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICAgICAgICAgIG5hbWU9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXRyYW5zZmVyLXN1Ym1pc3Npb25zXCI+VHJhbnNmZXIgU3R1ZGVudCBTdWJtaXNzaW9ucyBmb3IgdGhpcyBjb3Vyc2U8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCI+XG4gICAgPGxhYmVsIGNsYXNzPVwiZm9ybS10ZXh0XCIgZm9yPVwiYmxvY2tweS1jb3Vyc2UtaWRcIj5OZXcgb3duaW5nIGNvdXJzZSBpZDogPC9sYWJlbD5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImJsb2NrcHktY291cnNlLWlkXCIgdmFsdWU9XCIke3RoaXMubWFpbi5tb2RlbC51c2VyLmNvdXJzZUlkKCl9XCI+XG4gICAgPC9kaXY+XG4gICAgYCk7XG59O1xuXG5CbG9ja1B5RGlhbG9nLnByb3RvdHlwZS5FRElUX0lOUFVUUyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgaW5wdXRUZXh0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dCgpLmpvaW4oXCJcXG5cIik7XG4gICAgbGV0IGNsZWFySW5wdXRzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoKSA/IFwiXCIgOiBcImNoZWNrZWRcIjtcbiAgICBsZXQgeWVzID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hlY2tlZCA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIikucHJvcChcImNoZWNrZWRcIik7XG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktaW5wdXQtbGlzdFwiKS52YWwoKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuY2xlYXJJbnB1dHMoIWNoZWNrZWQpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KGlucHV0cyk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpcm0oXCJFZGl0IFJlbWVtYmVyZWQgSW5wdXRzXCIsIGBcblxuPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImJsb2NrcHktcmVtZW1iZXItaW5wdXRzIGZvcm0tY2hlY2staW5wdXRcIlxuICAgICAgICBuYW1lPVwiYmxvY2tweS1yZW1lbWJlci1pbnB1dHNcIiAke2NsZWFySW5wdXRzfT5cbjxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXJlbWVtYmVyLWlucHV0c1wiPlJldXNlIGlucHV0cyBmb3IgbmV4dCBleGVjdXRpb248L2xhYmVsPlxuPC9kaXY+XG5cbjx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktaW5wdXQtbGlzdCBmb3JtLWNvbnRyb2xcIiByb3dzPVwiNFwiPiR7aW5wdXRUZXh0fTwvdGV4dGFyZWE+PGJyPlxuRWRpdCB0aGUgaW5wdXRzIGFib3ZlIHRvIHN0b3JlIGFuZCByZXVzZSB0aGVtIGFjcm9zcyBtdWx0aXBsZSBleGVjdXRpb25zLlxuRWFjaCBpbnB1dCBzaG91bGQgYmUgcHV0IG9uIGl0cyBvd24gbGluZS5cbllvdSBkbyBub3QgbmVlZCBxdW90ZXM7IHRoZSB0ZXh0IHdpbGwgYmUgZW50ZXJlZCBsaXRlcmFsbHkuXG4gXG5gLCB5ZXMsIHRoaXMubm8sIFwiU2F2ZVwiKTtcbiAgICAvLyBUT0RPOiBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgdGhlIGluZmluaXRlIHN0cmluZyB0byBrZWVwIGdpdmluZyB3aGVuIHRoZSBvdGhlcnMgcnVuIG91dFxufTsiLCJpbXBvcnQge0VkaXRvcnN9IGZyb20gXCIuLi9lZGl0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRGaWxlKG1vZGVsLCBldmVudCkge1xuICAgIGxldCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC50YXJnZXQuZmlsZXM7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoZSA9PlxuICAgICAgICBtb2RlbC51aS5lZGl0b3JzLmN1cnJlbnQoKS51cGxvYWRGaWxlKGUpXG4gICAgKTtcbiAgICBmaWxlUmVhZGVyLmZpbGVOYW1lID0gZmlsZXNbMF0ubmFtZTtcbiAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbMF0pO1xuICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbHVnZ2lmeSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShtb2RlbCwgZXZlbnQpIHtcbiAgICBsZXQge25hbWUsIGV4dGVuc2lvbiwgY29udGVudHMsIG1pbWV0eXBlfSA9IG1vZGVsLnVpLmVkaXRvcnMuY3VycmVudCgpLmRvd25sb2FkRmlsZSgpO1xuICAgIC8vIE1ha2Ugc2FmZVxuICAgIG5hbWUgPSBzbHVnZ2lmeShuYW1lKTtcbiAgICBuYW1lID0gbmFtZSArIGV4dGVuc2lvbjtcbiAgICAvLyBNYWtlIHRoZSBkYXRhIGRvd25sb2FkIGFzIGEgZmlsZVxuICAgIGxldCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRzXSwge3R5cGU6IG1pbWV0eXBlfSk7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgbmFtZSk7XG4gICAgfSBlbHNle1xuICAgICAgICBsZXQgdGVtcG9yYXJ5RG93bmxvYWRMaW5rID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB0ZW1wb3JhcnlEb3dubG9hZExpbmsuZG93bmxvYWQgPSBuYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgICAgIHRlbXBvcmFyeURvd25sb2FkTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBvcmFyeURvd25sb2FkTGluayk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZpbGVTeXN0ZW0gPSBtYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlRmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLmRlbGV0ZUZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcihcImFuc3dlci5weVwiKTtcbiAgICB9XG5cbiAgICBvbkZpbGVEZWxldGVkKCkge1xuICAgICAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIGZpbGUgaW5zdGVhZCBvZiBhIGRlZmF1bHQgZmlsZVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5maWxlbmFtZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZWRpdG9ycy5jaGFuZ2VFZGl0b3IoXCJhbnN3ZXIucHlcIik7XG4gICAgfVxuXG4gICAgb25GaWxlVXBkYXRlZChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSB0aGlzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvL3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmNoYW5nZUVkaXRvcih0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3RoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2tDdXJyZW50RmlsZSgpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLndhdGNoRmlsZSh0aGlzLmZpbGVuYW1lLCB7XG4gICAgICAgICAgICB1cGRhdGVkOiB0aGlzLm9uRmlsZVVwZGF0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRoaXMub25GaWxlRGVsZXRlZC5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IG5ld0ZpbGVuYW1lO1xuICAgICAgICB0aGlzLmZpbGUgPSB0aGlzLmZpbGVTeXN0ZW0uZ2V0RmlsZShuZXdGaWxlbmFtZSk7XG4gICAgICAgIHRoaXMudHJhY2tDdXJyZW50RmlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0ZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIHRoYXQgdGhlIG90aGVyIGVkaXRvciB3aWxsIGJlIHN3aXRjaGluZyB0b1xuICAgICAqIEBwYXJhbSBvbGRFZGl0b3JcbiAgICAgKiBAcGFyYW0gbmV3RWRpdG9yXG4gICAgICovXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtLnN0b3BXYXRjaGluZ0ZpbGUodGhpcy5maWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGUoZXZlbnQpIHtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZXZlbnQudGFyZ2V0LmZpbGVOYW1lO1xuICAgICAgICBsZXQgY29udGVudHMgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZEZpbGUoKSB7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IEVkaXRvcnMucGFyc2VGaWxlbmFtZSh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLm5hbWUsXG4gICAgICAgICAgICBleHRlbnNpb246IGZpbGVuYW1lLnR5cGUsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5maWxlLmhhbmRsZSgpLFxuICAgICAgICAgICAgbWltZXR5cGU6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH07XG4gICAgfVxufSIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtEaXNwbGF5TW9kZXN9IGZyb20gXCIuL3B5dGhvblwiO1xuXG5jb25zdCBBU1NJR05NRU5UX1NFVFRJTkdTID0gW1xuICAgIFtcInRvb2xib3hcIiwgXCJ0b29sYm94XCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIldoaWNoIHZlcnNpb24gb2YgdGhlIHRvb2xib3ggdG8gcHJlc2VudCB0byB0aGUgdXNlci5cIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVcIiwgXCJibG9ja3B5XCIsIFwidHlwZVwiLCBcIlRoZSB0eXBlIG9mIHF1ZXN0aW9uOyBCbG9ja1B5IHByb2dyYW1taW5nIHByb2JsZW1zIGFyZSB0aGUgZGVmYXVsdCwgYnV0IHdlIGFsc28gc3VwcG9ydCBzdGF0aWMgcmVhZGluZ3MsIHF1aXogcXVlc3Rpb25zLCBhbmQgYSBNYXplIGdhbWUuXCJdLFxuICAgIFtcInBhc3Njb2RlXCIsIFwicGFzc2NvZGVcIiwgXCJcIiwgXCJzdHJpbmdcIiwgXCJBIHN0cmluZyB0aGF0IHRoZSB1c2VyIG11c3QgZW50ZXIgdG8gYWNjZXNzIHRoZSBwcm9ibGVtLiBJZiBibGFuaywgdGhlbiBubyBwYXNzY29kZSBpcyBwcm9tcHRlZC5cIl0sXG4gICAgLy9bXCJ0b29sYm94TGV2ZWxcIiwgXCJ0b29sYm94X2xldmVsXCIsIFwibm9ybWFsXCIsIFwidG9vbGJveFwiLCBcIklOQ09NUExFVEU6IFdoYXQgbGV2ZWwgb2YgdG9vbGJveCB0byBwcmVzZW50IHRvIHRoZSB1c2VyIChoaWRpbmcgYW5kIHNob3dpbmcgY2F0ZWdvcmllcykuXCJdLFxuICAgIFtcInN0YXJ0Vmlld1wiLCBcInN0YXJ0X3ZpZXdcIiwgRGlzcGxheU1vZGVzLlNQTElULCBEaXNwbGF5TW9kZXMsIFwiVGhlIFB5dGhvbiBlZGl0b3IgbW9kZSB0byBzdGFydCBpbiB3aGVuIHRoZSBzdHVkZW50IHN0YXJ0cyB0aGUgcHJvYmxlbS5cIl0sXG4gICAgW1wiZGF0YXNldHNcIiwgXCJkYXRhc2V0c1wiLCBcIlwiLCBcInN0cmluZ1wiLCBcIlRoZSBjdXJyZW50IGxpc3Qgb2YgZGF0YXNldHMgYXZhaWxhYmxlIG9uIGxvYWQgYXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nLlwiXSxcbiAgICBbXCJkaXNhYmxlVGltZW91dFwiLCBcImRpc2FibGVfdGltZW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBzdHVkZW50cyBjb2RlIGlzIGFsbG93ZWQgdG8gcnVuIHdpdGhvdXQgdGltZW91dHMgKHBvdGVudGlhbGx5IGFsbG93aW5nIGluZmluaXRlIGxvb3BzKS5cIl0sXG4gICAgW1wiaXNQYXJzb25zXCIsIFwiaXNfcGFyc29uc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGlzIGlzIGEgcGFyc29uJ3Mgc3R5bGUgcXVlc3Rpb24gKGp1bWJsZWQpLlwiXSxcbiAgICBbXCJzYXZlVHVydGxlT3V0cHV0XCIsIFwic2F2ZV90dXJ0bGVfb3V0cHV0XCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHR1cnRsZSAoYW5kIHB5Z2FtZSkgb3V0cHV0IGlzIHNhdmVkIHdoZW5ldmVyIHRoZSBwcm9ncmFtIHVzZXMgaXQuXCJdLFxuICAgIFtcImRpc2FibGVGZWVkYmFja1wiLCBcImRpc2FibGVfZmVlZGJhY2tcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gbm8gaW5zdHJ1Y3RvciBzY3JpcHRzIGFyZSBydW4gKGUuZy4sIG9uX3J1biBhbmQgb25fZXZhbCkuXCJdLFxuICAgIFtcImRpc2FibGVJbnN0cnVjdG9yUnVuXCIsIFwiZGlzYWJsZV9pbnN0cnVjdG9yX3J1blwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW5zdHJ1Y3RvciBvbl9ydW4gd2lsbCBub3QgYXV0b21hdGljYWxseSBydW4gdGhlIHN0dWRlbnRzJyBjb2RlLiBUaGlzIHN0aWxsIHJ1bnMgdGhlIHN0dWRlbnRzJyBjb2RlIG9uY2UgYmVmb3JlaGFuZCwgYnV0IHRoZSBvdXRwdXQvZGF0YSB3aWxsIG5vdCBiZSBhdmFpbGFibGUgdG8gdGhlIGluc3RydWN0b3IncyBvbl9ydW4ucHkgc2NyaXB0LlwiXSxcbiAgICBbXCJkaXNhYmxlU3R1ZGVudFJ1blwiLCBcImRpc2FibGVfc3R1ZGVudF9ydW5cIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHJ1biBidXR0b24gbm8gbG9uZ2VyIHJ1biB0aGUgc3R1ZGVudHMnIGNvZGUuIFRoaXMgc3RpbGwgcnVucyB0aGUgaW5zdHJ1Y3RvcidzIGZlZWRiYWNrIG9uX3J1biBzY3JpcHQuXCJdLFxuICAgIFtcImRpc2FibGVUaWZhXCIsIFwiZGlzYWJsZV90aWZhXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIGRvIG5vdCBhdXRvbWF0aWNhbGx5IHJ1biBUaWZhICh3aGljaCBjYW4gYmUgc2xvdykuXCJdLFxuICAgIFtcImRpc2FibGVUcmFjZVwiLCBcImRpc2FibGVfdHJhY2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNvZGUgd2lsbCBub3QgaGF2ZSBpdHMgZXhlY3V0aW9uIHRyYWNlZCAobm8gdmFyaWFibGVzIHJlY29yZGVkLCBubyBjb3ZlcmFnZSB0cmFja2VkKS5cIl0sXG4gICAgW1wiZGlzYWJsZUVkaXRcIiwgXCJkaXNhYmxlX2VkaXRcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzJyBmaWxlIHdpbGwgbm90IGJlIGVkaXRhYmxlLlwiXSxcbiAgICBbXCJlbmFibGVJbWFnZXNcIiwgXCJjYW5faW1hZ2VcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdXNlcnMgY2FuIGNvcHkvcGFzdGUgaW1hZ2VzIGRpcmVjdGx5IGludG8gdGhlIHRleHQgZWRpdG9yLlwiXSxcbiAgICBbXCJlbmFibGVCbG9ja3NcIiwgXCJjYW5fYmxvY2tzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnQgY2FuIGVkaXQgdGhlIGJsb2NrIGludGVyZmFjZSAoaWYgbm90LCB0aGVuIGl0IGlzIHZpc2libGUgYnV0IG5vdCBlZGl0YWJsZSkuXCJdLFxuICAgIFtcImNhbkNsb3NlXCIsIFwiY2FuX2Nsb3NlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBzdHVkZW50IHNob3VsZCBtYXJrIHRoZWlyIHN1Ym1pc3Npb24gY2xvc2VkIHdoZW4gdGhleSBhcmUgZG9uZS4gVGhlcmUgaXMgbm8gd2F5IHRvIGZvcmNlIGEgc3R1ZGVudCB0byBkbyBzby4gVW5saWtlIFJldmlld2VkLCB0aGlzIHN0aWxsIHN1Ym1pdHMgdGhlIGNvcnJlY3RuZXNzLlwiXSxcbiAgICBbXCJvbmx5SW50ZXJhY3RpdmVcIiwgXCJvbmx5X2ludGVyYWN0aXZlXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGUgZWRpdG9ycyBhcmUgaGlkZGVuLCB0aGUgcHJvZ3JhbSBpcyBhdXRvbWF0aWNhbGx5IHJ1biwgYW5kIHRoZW4gdGhlIGNvbnNvbGUgZW50ZXJzIEV2YWwgbW9kZSAoaW50ZXJhY3RpdmUpLlwiXSxcbiAgICBbXCJvbmx5VXBsb2Fkc1wiLCBcIm9ubHlfdXBsb2Fkc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgc3R1ZGVudHMnIGZpbGUgd2lsbCBub3QgYmUgZGlyZWN0bHkgZWRpdGFibGUgKHRoZXkgd2lsbCBoYXZlIHRvIHVwbG9hZCBzdWJtaXNzaW9ucykuXCJdLFxuICAgIC8vIFdoYXQgbWVudXMvZmVlZGJhY2sgdG8gc2hvdyBhbmQgaGlkZVxuICAgIFtcImhpZGVTdWJtaXNzaW9uXCIsIFwiaGlkZV9zdWJtaXNzaW9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZWlyIHN1Ym1pc3Npb24ncyBjb2RlIG9yIGhpc3Rvcnkgb24gQ2FudmFzLlwiXSxcbiAgICBbXCJoaWRlRmlsZXNcIiwgXCJoaWRlX2ZpbGVzXCIsIHRydWUsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gc3R1ZGVudHMgd2lsbCBub3Qgc2VlIHRoZSBWaWV3IEZpbGVzIHRvb2xiYXIuXCJdLFxuICAgIFtcImhpZGVRdWV1ZWRJbnB1dHNcIiwgXCJoaWRlX3F1ZXVlZF9pbnB1dHNcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIHN0dWRlbnRzIGNhbm5vdCBhY2Nlc3MgdGhlIHF1ZXVlZCBpbnB1dHMgYm94IChtYWtlcyByZXBlYXRlZCBkZWJ1Z2dpbmcgZWFzaWVyIGZvciB0aGUgaW5wdXQgZnVuY3Rpb24pLlwiXSxcbiAgICBbXCJoaWRlRWRpdG9yc1wiLCBcImhpZGVfZWRpdG9yc1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiBhbGwgb2YgdGhlIGVkaXRvcnMgYXJlIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZU1pZGRsZVBhbmVsXCIsIFwiaGlkZV9taWRkbGVfcGFuZWxcIiwgZmFsc2UsIFwiYm9vbFwiLCBcIklmIGNoZWNrZWQsIHRoZW4gdGhlIGNvbnNvbGUgYW5kIGZlZWRiYWNrIGFyZWFzIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUFsbFwiLCBcImhpZGVfYWxsXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJTkNPTVBMRVRFOiBJZiBjaGVja2VkLCB0aGVuIHRoZSBlbnRpcmUgaW50ZXJmYWNlIGlzIGhpZGRlbi5cIl0sXG4gICAgW1wiaGlkZUV2YWx1YXRlXCIsIFwiaGlkZV9ldmFsdWF0ZVwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgRXZhbHVhdGUgYnV0dG9uIGlzIG5vdCBzaG93biBvbiB0aGUgY29uc29sZS5cIl0sXG4gICAgW1wiaGlkZUltcG9ydERhdGFzZXRzQnV0dG9uXCIsIFwiaGlkZV9pbXBvcnRfZGF0YXNldHNfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHN0dWRlbnRzIGNhbm5vdCBzZWUgdGhlIGltcG9ydCBkYXRhc2V0cyBidXR0b24uXCJdLFxuICAgIC8vIFRPRE86IEZpeCB0aGlzIG9uZSB0byBiZSBzZXR0YWJsZVxuICAgIFtcImhpZGVJbXBvcnRTdGF0ZW1lbnRzXCIsIFwiaGlkZV9pbXBvcnRfc3RhdGVtZW50c1wiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgY2VydGFpbiBraW5kcyBvZiBpbXBvcnQgc3RhdGVtZW50cyAobWF0cGxvdGxpYiwgdHVydGxlLCBkYXRhc2V0cykgYXJlIG5vdCBzaG93biBpbiB0aGUgYmxvY2sgaW50ZXJmYWNlLlwiXSxcbiAgICBbXCJoaWRlQ292ZXJhZ2VCdXR0b25cIiwgXCJoaWRlX2NvdmVyYWdlX2J1dHRvblwiLCBmYWxzZSwgXCJib29sXCIsIFwiSU5DT01QTEVURTogSWYgY2hlY2tlZCwgdGhlIGNvdmVyYWdlIGJ1dHRvbiBpcyBub3Qgc2hvd24uXCJdLFxuICAgIFtcImhpZGVUcmFjZUJ1dHRvblwiLCBcImhpZGVfdHJhY2VfYnV0dG9uXCIsIGZhbHNlLCBcImJvb2xcIiwgXCJJZiBjaGVja2VkLCB0aGVuIHRoZSBUcmFjZSBidXR0b24gaXMgbm90IHNob3duLlwiXSxcbiAgICBbXCJzbWFsbExheW91dFwiLCBcInNtYWxsX2xheW91dFwiLCBmYWxzZSwgXCJib29sXCIsIFwiSWYgY2hlY2tlZCwgdGhlbiB0aGUgaW50ZXJmYWNlIGZpdHMgaW50byBhIHNtYWxsZXIgcmVnaW9uLlwiXSxcbl07XG5cbmV4cG9ydCBsZXQgQXNzaWdtZW50VHlwZSA9IHtcbiAgICBCTE9DS1BZOiBcImJsb2NrcHlcIixcbiAgICBNQVpFOiBcIm1hemVcIixcbiAgICBRVUlaOiBcInF1aXpcIixcbiAgICBSRUFESU5HOiBcInJlYWRpbmdcIlxufTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRhdGlvbihuYW1lKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgQVNTSUdOTUVOVF9TRVRUSU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQVNTSUdOTUVOVF9TRVRUSU5HU1tpXVswXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFTU0lHTk1FTlRfU0VUVElOR1NbaV1bNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiRG9jdW1lbnRhdGlvbiBub3QgZm91bmQgZm9yIGZpZWxkXCI7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdGFydFZpZXdUYWIobmFtZSwgaWNvbiwgbW9kZSkge1xuICAgIHJldHVybiBgPGxhYmVsIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBibG9ja3B5LW1vZGUtc2V0LWJsb2Nrc1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiBhc3NpZ25tZW50LnNldHRpbmdzLnN0YXJ0VmlldygpID09PSAnJHttb2RlfSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGFzc2lnbm1lbnQuc2V0dGluZ3Muc3RhcnRWaWV3LmJpbmQoJGRhdGEsICcke21vZGV9JylcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLSR7aWNvbn0nPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJsb2NrcHktc3RhcnQtdmlldy1zZXRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBjaGVja2VkPiAke25hbWV9XG4gICAgICAgICAgICA8L2xhYmVsPmA7XG59XG5cbmNvbnN0IEFTU0lHTk1FTlRfU0VUVElOR1NfQk9PTEVBTl9DT01QT05FTlRTX0hUTUwgPSBBU1NJR05NRU5UX1NFVFRJTkdTXG4gICAgLy8gT25seSBoYW5kbGUgdGhlIHNpbXBsZSBib29sZWFucyB0aGlzIHdheVxuICAgIC5maWx0ZXIoKHNldHRpbmcpID0+IHNldHRpbmdbM10gPT09IFwiYm9vbFwiKVxuICAgIC5tYXAoKHNldHRpbmcpID0+IHtcbiAgICAgICAgbGV0IHByZXR0eU5hbWUgPSBzZXR0aW5nWzFdLnNwbGl0KFwiX1wiKS5tYXAod29yZD0+KHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrd29yZC5zbGljZSgxKSkpLmpvaW4oXCIgXCIpO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtJHtzZXR0aW5nWzBdfVwiPiR7cHJldHR5TmFtZX08L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1jaGVja1wiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNoZWNrLWlucHV0XCIgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLSR7c2V0dGluZ1swXX1cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnNldHRpbmdzLiR7c2V0dGluZ1swXX1cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke3NldHRpbmdbNF19XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9KS5qb2luKFwiXFxuXFxuXCIpO1xuXG5leHBvcnQgY29uc3QgQVNTSUdOTUVOVF9TRVRUSU5HU19FRElUT1JfSFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS12aWV3LXNldHRpbmdzXCI+XG4gICAgXG4gICAgPGZvcm0+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEyIG14LWF1dG9cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc3VjY2Vzc1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnNldHRpbmdzLnNhdmVcIj5TYXZlIGNoYW5nZXM8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1uYW1lXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+TmFtZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLW5hbWVcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50Lm5hbWVcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBUaGUgc3R1ZGVudC1mYWNpbmcgbmFtZSBvZiB0aGUgYXNzaWdubWVudC4gQXNzaWdubWVudHMgd2l0aGluIGEgZ3JvdXAgYXJlIG9yZGVyZWQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgYnkgdGhlaXIgbmFtZSwgc28geW91IG1heSB3YW50IHRvIHVzZSBhIG5hbWluZyBzY2hlbWUgbGlrZSBcIiM0My41KSBXaGF0ZXZlclwiLlxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPlVSTDo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXVybFwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmFsdWU6IGFzc2lnbm1lbnQudXJsXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgVGhlIGNvdXJzZS11bmlxdWUgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uc2lzdGVudGx5IHJlZmVyIHRvIHRoaXMgYXNzaWdubWVudC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIj5QdWJsaWM6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wdWJsaWNcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LnB1YmxpY1wiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIG5vdCBwdWJsaWMsIHVzZXJzIG91dHNpZGUgb2YgdGhlIGNvdXJzZSB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlZSB0aGUgYXNzaWdubWVudCBpbiBjb3Vyc2UgbGlzdGluZ3MuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIj5IaWRkZW46PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjaGVja2VkOiBhc3NpZ25tZW50LmhpZGRlblwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PiAgXG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tOVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIElmIGhpZGRlbiwgc3R1ZGVudHMgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlaXIgZ3JhZGUgd2hpbGUgd29ya2luZyBvbiB0aGUgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTIgdGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tY2hlY2stbGFiZWxcIiBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXJldmlld2VkXCI+UmV2aWV3ZWQ6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNoZWNrZWQ6IGFzc2lnbm1lbnQucmV2aWV3ZWRcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj4gIFxuICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICBJZiByZXZpZXdlZCwgdGhlIGFzc2lnbm1lbnQgbmVlZCB0byBiZSBjb21tZW50ZWQgdXBvbiBhbmQgcmVncmFkZWQgYnkgdGhlIHN0YWZmIGFmdGVyIHN1Ym1pc3Npb24uXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcG9pbnRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UG9pbnRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1wb2ludHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnBvaW50c1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoaXMgYXNzaWdubWVudCBpcyB3b3J0aDsgZGVmYXVsdHMgdG8gMSBwb2ludC4gXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1yZXZpZXdlZFwiPlN0YXJ0aW5nIFZpZXc6PC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tZ3JvdXAtdG9nZ2xlIG1yLTJcIiBkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiQmxvY2tzXCIsIFwidGgtbGFyZ2VcIiwgRGlzcGxheU1vZGVzLkJMT0NLKX1cbiAgICAgICAgICAgICAgICAgICAgJHttYWtlU3RhcnRWaWV3VGFiKFwiU3BsaXRcIiwgXCJjb2x1bW5zXCIsIERpc3BsYXlNb2Rlcy5TUExJVCl9XG4gICAgICAgICAgICAgICAgICAgICR7bWFrZVN0YXJ0Vmlld1RhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tN1wiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInN0YXJ0Vmlld1wiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5JUCBSYW5nZXM6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiYmxvY2tweS1zZXR0aW5ncy1pcC1yYW5nZXNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LmlwUmFuZ2VzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIElQIEFkZHJlc3NlcyB0aGF0IHdpbGwgYmUgZXhwbGljaXRseSBhbGxvd2VkLiBJZiBibGFuayxcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBhbGwgYWRkcmVzc2VzIGFyZSBhbGxvd2VkLiBJZiBhbiBhZGRyZXNzIHN0YXJ0cyB3aXRoIDxjb2RlPl48L2NvZGU+IHRoZW4gaXQgaXQgaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3RlZCwgYnV0IHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdHVybiB3aXRoIGEgPGNvZGU+ITwvY29kZT4uIEFkZHJlc3NlcyBjYW4gYWxzb1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIGEgYml0IG1hc2sgdG8gYWxsb3cgYSByYW5nZSBvZiBhZGRyZXNzZXMuXG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtcGFzc2NvZGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5QYXNzY29kZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXBhc3Njb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy5wYXNzY29kZVwiPlxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImZvcm0tdGV4dCB0ZXh0LW11dGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICR7Z2V0RG9jdW1lbnRhdGlvbihcInBhc3Njb2RlXCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLWRhdGFzZXRzXCIgY2xhc3M9XCJjb2wtc20tMiBjb2wtZm9ybS1sYWJlbCB0ZXh0LXJpZ2h0XCI+UHJlbG9hZGVkIERhdGFzZXRzOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJsb2NrcHktc2V0dGluZ3MtZGF0YXNldHNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cInZhbHVlOiBhc3NpZ25tZW50LnNldHRpbmdzLmRhdGFzZXRzXCI+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwiZGF0YXNldHNcIil9XG4gICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJsb2NrcHktc2V0dGluZ3MtdG9vbGJveFwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWwgdGV4dC1yaWdodFwiPkJsb2NrIFRvb2xib3g6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXRvb2xib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC5zZXR0aW5ncy50b29sYm94XCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm5vcm1hbFwiPk5vcm1hbCBUb29sYm94PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN0XCI+Q1RAVlQgVG9vbGJveDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdDJcIj5DVEBWVCBUb29sYm94IFYyPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1pbmltYWxcIj5NaW5pbWFsIFNldDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJmdWxsXCI+QWxsIEJsb2Nrczwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjdXN0b21cIj5DdXN0b208L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJmb3JtLXRleHQgdGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAke2dldERvY3VtZW50YXRpb24oXCJ0b29sYm94XCIpfVxuICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIiBjbGFzcz1cImNvbC1zbS0yIGNvbC1mb3JtLWxhYmVsIHRleHQtcmlnaHRcIj5Qcm9ibGVtIFR5cGU6PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJibG9ja3B5LXNldHRpbmdzLXR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2YWx1ZTogYXNzaWdubWVudC50eXBlXCI+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJsb2NrcHlcIj5CbG9ja1B5PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1hemVcIj5NYXplPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInF1aXpcIj5RdWl6IFF1ZXN0aW9uPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJlYWRpbmdcIj5SZWFkaW5nPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZm9ybS10ZXh0IHRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtnZXREb2N1bWVudGF0aW9uKFwidHlwZVwiKX1cbiAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgJHtBU1NJR05NRU5UX1NFVFRJTkdTX0JPT0xFQU5fQ09NUE9ORU5UU19IVE1MfVxuICAgIDwvZm9ybT5cbiAgICBcbiAgICA8L2Rpdj5cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQXNzaWdubWVudFNldHRpbmdzKG1vZGVsKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdO1xuICAgICAgICBsZXQgdmFsdWUgPSBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKCk7XG4gICAgICAgIC8vIE9ubHkgc3RvcmUgdGhpcyBzZXR0aW5nIGlmIGl0cyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFxuICAgICAgICBpZiAodmFsdWUgIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgc2V0dGluZ3Nbc2VydmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzZXR0aW5ncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQXNzaWdubWVudFNldHRpbmdzKG1vZGVsLCBzZXR0aW5ncykge1xuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2V0dGluZ3MpO1xuICAgICAgICBBU1NJR05NRU5UX1NFVFRJTkdTLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdO1xuICAgICAgICAgICAgaWYgKHNlcnZlck5hbWUgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzW2NsaWVudE5hbWVdKHNldHRpbmdzW3NlcnZlck5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5nc1tjbGllbnROYW1lXShzZXR0aW5nWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN0YXJ0X3ZpZXcpIHtcbiAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShzZXR0aW5ncy5zdGFydF92aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50U2V0dGluZ3NNb2RlbChjb25maWd1cmF0aW9uKSB7XG4gICAgbGV0IHNldHRpbmdzID0ge307XG4gICAgQVNTSUdOTUVOVF9TRVRUSU5HUy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgICBsZXQgY2xpZW50TmFtZSA9IHNldHRpbmdbMF0sIHNlcnZlck5hbWUgPSBzZXR0aW5nWzFdLCBkZWZhdWx0VmFsdWUgPSBzZXR0aW5nWzJdLFxuICAgICAgICAgICAgZmllbGRUeXBlID0gc2V0dGluZ1szXTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bXCJhc3NpZ25tZW50LnNldHRpbmdzLlwiK3NlcnZlck5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2NsaWVudE5hbWVdID0ga28ub2JzZXJ2YWJsZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbmZpZ1ZhbHVlID0gY29uZmlndXJhdGlvbltcImFzc2lnbm1lbnQuc2V0dGluZ3MuXCIrc2VydmVyTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRUeXBlID09PSBcImJvb2xcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZ1ZhbHVlID0gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc1tjbGllbnROYW1lXSA9IGtvLm9ic2VydmFibGUoY29uZmlnVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5cbmNsYXNzIEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8vVE9ETzogdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXG4gICAgICAgIC8vIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZmlsZS5oYW5kbGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlRWRpdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcblxuICAgICAgICAvL1RPRE86IHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gdXBkYXRlXG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IudmFsdWUoKSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBVcGRhdGVcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgQXNzaWdubWVudFNldHRpbmdzID0ge1xuICAgIG5hbWU6IFwiQXNzaWdubWVudCBTZXR0aW5nc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IEFzc2lnbm1lbnRTZXR0aW5nc1ZpZXcsXG4gICAgdGVtcGxhdGU6IEFTU0lHTk1FTlRfU0VUVElOR1NfRURJVE9SX0hUTUxcbn07IiwiXHJcblxyXG5leHBvcnQgY29uc3QgZGVmYXVsdF9oZWFkZXIgPSBgXHJcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXB5dGhvbi10b29sYmFyIGNvbC1tZC0xMiBidG4tdG9vbGJhclwiXHJcbiAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiUHl0aG9uIFRvb2xiYXJcIj5cclxuICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIj5cclxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCI+PC9zcGFuPiBVcGxvYWRcclxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiYmxvY2tweS10b29sYmFyLXVwbG9hZFwiIHR5cGU9XCJmaWxlXCJcclxuICAgICAgICAgICAgICAgIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiZXZlbnQ6IHtjaGFuZ2U6IHVpLmVkaXRvcnMudXBsb2FkfVwiPlxyXG4gICAgICAgICA8L2xhYmVsPlxyXG5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXHJcbiAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxyXG4gICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXHJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXHJcbiAgICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgXHJcbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcclxuICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhbkRlbGV0ZVwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiLFxyXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9zcGFuPiBEZWxldGVcclxuICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgPC9kaXY+XHJcbiA8L2Rpdj5cclxuYDtcclxuIiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSU1BR0VfRURJVE9SX0hUTUwgPSBgXHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8aDM+QXZhaWxhYmxlIEltYWdlczwvaDM+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvbiBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5pbWFnZXMucmVsb2FkSW1hZ2VzXCI+UmVsb2FkIEF2YWlsYWJsZSBJbWFnZXM8L2J1dHRvbj5cclxuICAgICAgICA8IS0tIGtvIGlmOiBkaXNwbGF5LnVwbG9hZGVkRmlsZXMoKSAhPT0gbnVsbCAtLT5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6IE9iamVjdC5rZXlzKGRpc3BsYXkudXBsb2FkZWRGaWxlcygpKSwgYXM6ICdwbGFjZW1lbnQnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZyBkYXRhLWJpbmQ9XCJ0ZXh0OiAkZGF0YVwiPjwvc3Ryb25nPjpcclxuICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSBrbyBmb3JlYWNoOiB7IGRhdGE6ICRyb290LmRpc3BsYXkudXBsb2FkZWRGaWxlcygpW3BsYWNlbWVudF0sIGFzOiAnZmlsZW5hbWUnIH0gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGZpbGVuYW1lWzBdXCI+PC9zcGFuPjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgZGF0YS1iaW5kPVwiYXR0cjogeyBzcmM6IGZpbGVuYW1lWzFdLCBhbHQ6IGZpbGVuYW1lWzFdIH1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMzBweFwiIGhlaWdodD1cIjMwcHhcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPCEtLSAva28gLS0+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8IS0tIC9rbyAtLT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSW1hZ2VFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XHJcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcblxyXG4gICAgICAgIGxldCB1cGxvYWRlZEZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudXBsb2FkZWRGaWxlcygpO1xyXG4gICAgICAgIGlmICh1cGxvYWRlZEZpbGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkSW1hZ2VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cclxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9uKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTsqL1xyXG4gICAgfVxyXG5cclxuICAgIHJlbG9hZEltYWdlcygpIHtcclxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubGlzdFVwbG9hZGVkRmlsZXMoKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS51cGxvYWRlZEZpbGVzKHJlc3BvbnNlLmZpbGVzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZ3MuRVJST1JfTElTVElOR19VUExPQURFRF9GSUxFUyhyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICAvKnRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3IuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSW1hZ2VFZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkltYWdlXCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCI/aW1hZ2VzLmJsb2NrcHlcIl0sXHJcbiAgICBjb25zdHJ1Y3RvcjogSW1hZ2VFZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IElNQUdFX0VESVRPUl9IVE1MXHJcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XHJcblxyXG5leHBvcnQgY29uc3QgSlNPTl9FRElUT1JfSFRNTCA9IGBcclxuICAgICR7ZGVmYXVsdF9oZWFkZXJ9XHJcbiAgICAgPGRpdj5cclxuICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1qc29uXCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgSnNvbkVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLWpzb25cIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgbW9kZTogXCJqc29uXCIsXHJcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgICAgICAgICAgXCJUYWJcIjogXCJpbmRlbnRNb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcclxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcIkYxMVwiOiBmdW5jdGlvbiAoY20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XHJcbiAgICAgICAgc3VwZXIuZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSByZWxldmFudCBGaWxlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxyXG4gICAgICAgIHRoaXMuY3VycmVudExpc3RlbmVyID0gdGhpcy51cGRhdGVIYW5kbGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XHJcbiAgICAgICAgc3VwZXIuZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEpzb25FZGl0b3IgPSB7XHJcbiAgICBuYW1lOiBcIkpTT05cIixcclxuICAgIGV4dGVuc2lvbnM6IFtcIi5qc29uXCJdLFxyXG4gICAgY29uc3RydWN0b3I6IEpzb25FZGl0b3JWaWV3LFxyXG4gICAgdGVtcGxhdGU6IEpTT05fRURJVE9SX0hUTUxcclxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcbmltcG9ydCB7ZGVmYXVsdF9oZWFkZXJ9IGZyb20gXCIuL2RlZmF1bHRfaGVhZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBNQVJLRE9XTl9FRElUT1JfSFRNTCA9IGBcbiAgICAke2RlZmF1bHRfaGVhZGVyfVxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLW1hcmtkb3duXCI+PC90ZXh0YXJlYT4gICAgXG5gO1xuXG5cbmNsYXNzIE1hcmtkb3duRWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgdGFnKTtcbiAgICAgICAgdGhpcy5tZGUgPSBuZXcgRWFzeU1ERSh7XG4gICAgICAgICAgICBlbGVtZW50OiB0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci1tYXJrZG93blwiKVswXSxcbiAgICAgICAgICAgIGF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlU3luYzogdHJ1ZSxcbiAgICAgICAgICAgIG1pbkhlaWdodDogXCIzMDBweFwiLFxuICAgICAgICAgICAgLy9zY3JvbGxiYXJTdHlsZTogXCJuYXRpdmVcIixcbiAgICAgICAgICAgIC8vIFRPRE86IGltYWdlVXBsb2FkRnVuY3Rpb25cbiAgICAgICAgICAgIHJlbmRlcmluZ0NvbmZpZzoge1xuICAgICAgICAgICAgICAgIGNvZGVTeW50YXhIaWdobGlnaHRpbmc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWRlLmNvZGVtaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoLmJpbmQodGhpcy5tZGUuY29kZW1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZGUudmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMubWRlLnZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tZGUuY29kZW1pcnJvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1hcmtkb3duRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiTWFya2Rvd25cIixcbiAgICBleHRlbnNpb25zOiBbXCIubWRcIl0sXG4gICAgY29uc3RydWN0b3I6IE1hcmtkb3duRWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogTUFSS0RPV05fRURJVE9SX0hUTUxcbn07IiwiLyoqXG4gKiBUT0RPOiByZW5hbWUgZmlsZXMsIG1hbnVhbCBzYXZlLCB0YWdzLCBzYW1wbGVfc3VibWlzc2lvbnMsIG9uX2V2YWwsIG5vbi1idWlsdGluIGZpbGVzXG4gKiBUT0RPOiBpbXBvcnQgZGF0YSwgaGlzdG9yeSwgcnVuLCB1cmxfZGF0YSwgYXNzaWdubWVudF9zZXR0aW5ncywgcGFyc29uc19tb2RlXG4gKiBUT0RPOiBkZWxldGUgYmVjb21lcyBcImNsZWFyXCIgZm9yIGluc3RydWN0b3IgZmlsZXNcbiAqL1xuXG4vKipcbiAqXG4gKiBAZW51bSB7c3RyfVxuICovXG5pbXBvcnQge0Fic3RyYWN0RWRpdG9yLCBzbHVnZ2lmeX0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XG5pbXBvcnQge0hJU1RPUllfVE9PTEJBUl9IVE1MfSBmcm9tIFwiLi4vaGlzdG9yeVwiO1xuaW1wb3J0IHtTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnN9IGZyb20gXCIuLi9pbnRlcmZhY2VcIjtcblxuZXhwb3J0IGxldCBEaXNwbGF5TW9kZXMgPSB7XG4gICAgQkxPQ0s6IFwiYmxvY2tcIixcbiAgICBTUExJVDogXCJzcGxpdFwiLFxuICAgIFRFWFQ6IFwidGV4dFwiXG59O1xuXG5mdW5jdGlvbiBtYWtlVGFiKG5hbWUsIGljb24sIG1vZGUpIHtcbiAgICByZXR1cm4gYDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYmxvY2tweS1tb2RlLXNldC1ibG9ja3NcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczoge2FjdGl2ZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICcke21vZGV9J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZWRpdG9ycy5weXRob24udXBkYXRlTW9kZS5iaW5kKCRkYXRhLCAnJHttb2RlfScpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS0ke2ljb259Jz48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJibG9ja3B5LW1vZGUtc2V0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2hlY2tlZD4gJHtuYW1lfVxuICAgICAgICAgICAgPC9sYWJlbD5gO1xufVxuXG5leHBvcnQgY29uc3QgUFlUSE9OX0VESVRPUl9IVE1MID0gYFxuXG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktcHl0aG9uLXRvb2xiYXIgY29sLW1kLTEyIGJ0bi10b29sYmFyXCJcbiAgICAgICAgIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlB5dGhvbiBUb29sYmFyXCI+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSdW4gR3JvdXBcIj4gICAgICAgICBcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJsb2NrcHktcnVuIG5vdHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmV4ZWN1dGUucnVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzczogeydibG9ja3B5LXJ1bi1ydW5uaW5nJzogdWkuZXhlY3V0ZS5pc1J1bm5pbmd9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtcGxheVwiPjwvc3Bhbj4gPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdWkuZXhlY3V0ZS5ydW5MYWJlbFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC10b2dnbGUgbXItMlwiIGRhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiPlxuICAgICAgICAgICAgPCEtLSBrbyBpZjogJHJvb3QuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVCbG9ja3MoKSAtLT5cbiAgICAgICAgICAgICR7bWFrZVRhYihcIkJsb2Nrc1wiLCBcInRoLWxhcmdlXCIsIERpc3BsYXlNb2Rlcy5CTE9DSyl9XG4gICAgICAgICAgICAke21ha2VUYWIoXCJTcGxpdFwiLCBcImNvbHVtbnNcIiwgRGlzcGxheU1vZGVzLlNQTElUKX1cbiAgICAgICAgICAgICR7bWFrZVRhYihcIlRleHRcIiwgXCJhbGlnbi1sZWZ0XCIsIERpc3BsYXlNb2Rlcy5URVhUKX1cbiAgICAgICAgICAgIDwhLS0gL2tvIC0tPlxuICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgbXItMlwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJSZXNldCBHcm91cFwiPlxuICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnJlc2V0XCI+XG4gICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXN5bmNcIj48L3NwYW4+IFJlc2V0XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0ga28gaWY6ICFhc3NpZ25tZW50LnNldHRpbmdzLmhpZGVJbXBvcnREYXRhc2V0c0J1dHRvbigpICYmICF1aS5zbWFsbExheW91dCgpLS0+XG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSW1wb3J0IEdyb3VwXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLmltcG9ydERhdGFzZXRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1jbG91ZC1kb3dubG9hZC1hbHRcIj48L3NwYW4+IEltcG9ydCBkYXRhc2V0c1xuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5zbWFsbExheW91dFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS11cGxvYWRcIj48L3NwYW4+IFVwbG9hZFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJibG9ja3B5LXRvb2xiYXItdXBsb2FkXCIgdHlwZT1cImZpbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJldmVudDoge2NoYW5nZTogdWkuZWRpdG9ycy51cGxvYWR9XCI+XG4gICAgICAgICAgICAgICAgIDwvbGFiZWw+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgZHJvcGRvd24tdG9nZ2xlIGRyb3Bkb3duLXRvZ2dsZS1zcGxpdFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNhcmV0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0nZHJvcGRvd24taXRlbSBibG9ja3B5LXRvb2xiYXItZG93bmxvYWQnXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5kb3dubG9hZFwiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWRvd25sb2FkJz48L3NwYW4+IERvd25sb2FkXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiSGlzdG9yeSBHcm91cFwiIGRhdGEtYmluZD1cImhpZGRlbjogdWkuc21hbGxMYXlvdXRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi50b2dnbGVIaXN0b3J5TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZTogdWkuZWRpdG9ycy5weXRob24uaXNIaXN0b3J5QXZhaWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzOiB7IGFjdGl2ZTogZGlzcGxheS5oaXN0b3J5TW9kZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cjogeyAnYXJpYS1wcmVzc2VkJzogZGlzcGxheS5oaXN0b3J5TW9kZSB9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtaGlzdG9yeVwiPjwvc3Bhbj4gSGlzdG9yeVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0gRnVsbHkgZnVuY3Rpb25hbCwgYnV0IGEgbGl0dGxlIHRvby4uIEludmFzaXZlIFxuICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBtci0yXCIgcm9sZT1cImdyb3VwXCIgYXJpYS1sYWJlbD1cIkZ1bGxzY3JlZW4gR3JvdXBcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogZGlzcGxheS5weXRob25Nb2RlKCkgPT09ICd0ZXh0J1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uZnVsbHNjcmVlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWV4cGFuZC1hcnJvd3MtYWx0XCI+PC9zcGFuPiBGdWxsc2NyZWVuXG4gICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICAgIC0tPlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiU2F2ZSBHcm91cFwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5lZGl0b3JzLmNhblNhdmVcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLXNhdmVcIj48L3NwYW4+IFNhdmVcbiAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRGVsZXRlIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuRGVsZXRlXCI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIixcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZmlsZXMuZGVsZXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L3NwYW4+IERlbGV0ZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS08ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiUmVuYW1lIEdyb3VwXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMuY2FuUmVuYW1lXCI+XG4gICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtZmlsZS1zaWduYXR1cmVcIj48L3NwYW4+IFJlbmFtZVxuICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgPC9kaXY+LS0+XG4gICAgICAgICBcbiAgICA8L2Rpdj5cbiAgICBcbiAgICAke0hJU1RPUllfVE9PTEJBUl9IVE1MfVxuXG5cbiAgICA8ZGl2IGNsYXNzPVwiYmxvY2tweS1weXRob24tYmxvY2ttaXJyb3JcIlxuICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLm1lbnUuaXNTdWJtaXR0ZWRcIj5cbiAgICA8L2Rpdj5cbmA7XG5cblxuXG5mdW5jdGlvbiBjb252ZXJ0SXB5bmJUb1B5dGhvbihjb2RlKSB7XG4gICAgbGV0IGlweW5iID0gSlNPTi5wYXJzZShjb2RlKTtcbiAgICBsZXQgaXNVc2FibGUgPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIWNlbGwuc291cmNlWzBdLnN0YXJ0c1dpdGgoXCIlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgICAgICBjZWxsLmNlbGxfdHlwZSA9PT0gXCJyYXdcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IG1ha2VQeXRob24gPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNlbGwuY2VsbF90eXBlID09PSBcIm1hcmtkb3duXCIgfHxcbiAgICAgICAgICAgIGNlbGwuY2VsbF90eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInJydcIitjZWxsLnNvdXJjZS5qb2luKFwiXFxuXCIpK1wiJycnXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpcHluYi5jZWxscy5maWx0ZXIoaXNVc2FibGUpLm1hcChtYWtlUHl0aG9uKS5qb2luKFwiXFxuXCIpO1xufVxuXG5jbGFzcyBQeXRob25FZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcuZmluZChcIi5ibG9ja3B5LXB5dGhvbi1ibG9ja21pcnJvclwiKSk7XG4gICAgICAgIEJsb2NrbHkuc2V0UGFyZW50Q29udGFpbmVyKG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXJbMF0pO1xuICAgICAgICB0aGlzLmJtID0gbmV3IEJsb2NrTWlycm9yKHtcbiAgICAgICAgICAgIFwiY29udGFpbmVyXCI6IHRoaXMudGFnWzBdLFxuICAgICAgICAgICAgXCJydW5cIjogbWFpbi5jb21wb25lbnRzLmVuZ2luZS5ydW4uYmluZChtYWluLmNvbXBvbmVudHMuZW5naW5lKSxcbiAgICAgICAgICAgIFwic2tpcFNrdWxwdFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJibG9ja2x5TWVkaWFQYXRoXCI6IG1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5ibG9ja2x5UGF0aCxcbiAgICAgICAgICAgIFwidG9vbGJveFwiOiBtYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveCgpLFxuICAgICAgICAgICAgXCJpbWFnZU1vZGVcIjogdHJ1ZSxcbiAgICAgICAgICAgIGltYWdlRG93bmxvYWRIb29rOiAob2xkVXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFVybDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZVVwbG9hZEhvb2s6IChibG9iKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zdCB1dWlkID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW10pKS5zdWJzdHJpbmcoMzEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1pc3Npb25JZCA9IG1haW4ubW9kZWwuc3VibWlzc2lvbi5pZCgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluLmNvbXBvbmVudHMuc2VydmVyLnVwbG9hZEZpbGUoXCJzdWJtaXNzaW9uXCIsIHN1Ym1pc3Npb25JZCwgYmxvYi5uYW1lLCBibG9iLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZW5kcG9pbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzb2x2ZShKU09OLnN0cmluZ2lmeShtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJsc1tcImRvd25sb2FkRmlsZVwiXSArIGA/cGxhY2VtZW50PXN1Ym1pc3Npb24mZGlyZWN0b3J5PSR7c3VibWlzc2lvbklkfSZmaWxlbmFtZT0ke2Jsb2IubmFtZX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBQcm9taXNlLnJlc29sdmUoXCJJbWFnZShcIitKU09OLnN0cmluZ2lmeShVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKStcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnN0cmluZ2lmeShVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VMaXRlcmFsSG9vazogKG9sZFVybCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIGBJbWFnZShcIiR7b2xkVXJsfVwiKWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7b2xkVXJsfVwiYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLydoZWlnaHQnOiAnMjAwMHB4J1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYWtlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRQeXRob25Nb2RlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpO1xuXG4gICAgICAgIHRoaXMubWFrZVBlckFzc2lnbm1lbnRTdWJzY3JpcHRpb25zKCk7XG4gICAgfVxuXG4gICAgY29uZmlndXJlRXh0cmFCbG9ja2x5KCkge1xuICAgICAgICB0aGlzLmJtLmJsb2NrRWRpdG9yLndvcmtzcGFjZS5jb25maWd1cmVDb250ZXh0TWVudSA9IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJTY3JlZW5zaG90XCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5TQ1JFRU5TSE9UX0JMT0NLU1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBsZXQgb2xkRmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChuZXdGaWxlbmFtZSAhPT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgaWYgKG9sZEZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRQeXRob25Nb2RlID0gdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucHl0aG9uTW9kZShEaXNwbGF5TW9kZXMuVEVYVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKHRoaXMub2xkUHl0aG9uTW9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXG4gICAgICAgIHRoaXMuY3VycmVudEJNTGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJtLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudEJNTGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChuZXdGaWxlbmFtZSAhPT0gXCJhbnN3ZXIucHlcIikge1xuICAgICAgICAgICAgdGhpcy5ibS5pc1BhcnNvbnMgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYm0uaXNQYXJzb25zID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuaXNQYXJzb25zO1xuXG4gICAgICAgICAgICB0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGluZXNFcnJvci5zdWJzY3JpYmUoKGxpbmVzKSA9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci1lcnJvci1saW5lXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxpbmVVbmNvdmVyZWRTdWJzY3JpcHRpb24gPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmxpbmVzVW5jb3ZlcmVkLnN1YnNjcmliZSgobGluZXMpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5ibS5zZXRIaWdobGlnaHRlZExpbmVzKGxpbmVzLCBcImVkaXRvci11bmNvdmVyZWQtbGluZVwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5saW5lVHJhY2VTdWJzY3JpcHRpb24gPSB0aGlzLm1haW4ubW9kZWwudWkudHJhY2UuaGlnaGxpZ2h0ZWRMaW5lLnN1YnNjcmliZSgobGluZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLmNsZWFySGlnaGxpZ2h0ZWRMaW5lcyhcImVkaXRvci10cmFjZWQtbGluZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLnNldEhpZ2hsaWdodGVkTGluZXMobGluZXMsIFwiZWRpdG9yLXRyYWNlZC1saW5lXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vdGhpcy5ibS5ibG9ja0VkaXRvci53b3Jrc3BhY2UucmVuZGVyKCk7XG4gICAgICAgIC8vdGhpcy5ibS5yZWZyZXNoKCk7XG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoaXMgZG9lc24ndCBlbmQgdXAgbG9va2luZyByaWdodCAoZ28gdG8gYSBkaWZmZXJlbnQgZWRpdG9yLCBjb21lIGJhY2ssIGFuZCBpdCdsbCBiZSBzcXVpc2hlZClcbiAgICAgICAgLy90aGlzLmJtLnJlZnJlc2goKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmJtLnJlZnJlc2goKSwgMCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIGlmIChuZXdDb250ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGVudHMgPSB0aGlzLmZpbGUuaGFuZGxlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbWF0dGVyLCBmaWxlIHdhcyBhbHJlYWR5IHNodXQgZG93bi5cbiAgICAgICAgICAgICAgICBuZXdDb250ZW50cyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmV3Q29udGVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGNsb3NpbmcgdGhpcyBmaWxlXG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLmRlbGV0ZUZpbGVMb2NhbGx5Xyh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYm0uc2V0Q29kZShuZXdDb250ZW50cyk7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmJtLmNsZWFySGlnaGxpZ2h0ZWRMaW5lcygpO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmJtLmdldENvZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYm0ucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5jdXJyZW50Qk1MaXN0ZW5lcik7XG4gICAgICAgIGlmICh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5oaXN0b3J5TW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuZWRpdG9ycy5weXRob24udHVybk9mZkhpc3RvcnlNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckxpbmVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxuXG4gICAgY2xlYXJMaW5lU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5ibS5jbGVhckhpZ2hsaWdodGVkTGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUVycm9yU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVFcnJvclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lVW5jb3ZlcmVkU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubGluZVVuY292ZXJlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZVRyYWNlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmxpbmVUcmFjZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5ibS5zZXRNb2RlKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUoKSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnB5dGhvbk1vZGUuc3Vic2NyaWJlKG1vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibS5zZXRNb2RlKG1vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZW5hYmxlQmxvY2tzLnN1YnNjcmliZShlbmFibGVkID0+IHtcbiAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZShEaXNwbGF5TW9kZXMuVEVYVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm0uc2V0TW9kZSh0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5weXRob25Nb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveC5zdWJzY3JpYmUodGhpcy5yZWxvYWRUb29sYm94LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5lbmFibGVJbWFnZXMuc3Vic2NyaWJlKGltYWdlTW9kZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJtLnNldEltYWdlTW9kZShpbWFnZU1vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTbWFsbCBMYXlvdXQgU3R1ZmZcbiAgICAgICAgdGhpcy5vbGRIZWlnaHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNtYWxsTGF5b3V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMudXNlU21hbGxMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwudWkuc21hbGxMYXlvdXQuc3Vic2NyaWJlKHVzZVNtYWxsTGF5b3V0ID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VTbWFsbExheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlU21hbGxMYXlvdXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vbGRIZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24uaGVpZ2h0ID0gdGhpcy5vbGRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ibS50ZXh0RWRpdG9yLnJlc2l6ZVJlc3BvbnNpdmVseSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXNlU21hbGxMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuYm0udGV4dEVkaXRvci51cGRhdGVHdXR0ZXIoe2luZGVudFNpZGViYXI6IGZhbHNlfSk7XG4gICAgICAgIHRoaXMub2xkSGVpZ2h0ID0gdGhpcy5ibS5jb25maWd1cmF0aW9uLmhlaWdodDtcbiAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLmhlaWdodCA9IDMwMDsgLy8gVE9ETzogUGFyYW1ldGVyaXplIHRoaXNcbiAgICAgICAgdGhpcy5ibS50ZXh0RWRpdG9yLnJlc2l6ZVJlc3BvbnNpdmVseSgpO1xuICAgIH1cblxuICAgIHJlbG9hZFRvb2xib3godG9vbGJveCkge1xuICAgICAgICBpZiAodG9vbGJveCA9PT0gXCJjdXN0b21cIikge1xuICAgICAgICAgICAgbGV0IGN1c3RvbVRvb2xib3ggPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLmdldEZpbGUoXCI/dG9vbGJveC5ibG9ja3B5XCIpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVRvb2xib3ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvb2xib3ggPSBcImVtcHR5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xib3ggPSBKU09OLnBhcnNlKGN1c3RvbVRvb2xib3guaGFuZGxlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTsgLy8gVE9ETzogSW1wcm92ZSBlcnJvciBtZXNzYWdlIGZvciBpbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHRvb2xib3ggPSBcIm1pbmltYWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibS5jb25maWd1cmF0aW9uLnRvb2xib3ggPSB0b29sYm94O1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgaW52YWxpZCB0b29sYm94IGJldHRlclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5ibS5ibG9ja0VkaXRvci5yZW1ha2VUb29sYm94KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB0aGlzLmJtLmNvbmZpZ3VyYXRpb24udG9vbGJveCA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgIHRoaXMuYm0uYmxvY2tFZGl0b3IucmVtYWtlVG9vbGJveCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZVBlckFzc2lnbm1lbnRTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yLnN1YnNjcmliZSgoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkT25seSh0aGlzLmRlY2lkZUlmTm90RWRpdGFibGUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5VXBsb2Fkcy5zdWJzY3JpYmUoKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhZE9ubHkodGhpcy5kZWNpZGVJZk5vdEVkaXRhYmxlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZWNpZGVJZk5vdEVkaXRhYmxlKCkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgICAgIHJldHVybiBtb2RlbC5kaXNwbGF5Lmhpc3RvcnlNb2RlKCkgfHwgKFxuICAgICAgICAgICAgbW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5vbmx5VXBsb2FkcygpICYmICFtb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldFJlYWRPbmx5KGlzUmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5yZWFkT25seSA9IGlzUmVhZE9ubHk7XG4gICAgICAgIHRoaXMuYm0uc2V0UmVhZE9ubHkoaXNSZWFkT25seSk7XG4gICAgfVxuXG4gICAgdXBsb2FkRmlsZShldmVudCkge1xuICAgICAgICBsZXQgZmlsZW5hbWUgPSBldmVudC50YXJnZXQuZmlsZU5hbWU7XG4gICAgICAgIGxldCBjb2RlID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKFwiLmlweW5iXCIpKSB7XG4gICAgICAgICAgICBjb2RlID0gY29udmVydElweW5iVG9QeXRob24oY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1GaWxlLlVwbG9hZFwiLCBcIlwiLCBcIlwiLCBjb2RlLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5maWxlLmhhbmRsZShjb2RlKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZW5naW5lLnJ1bigpO1xuICAgICAgICAvLyBUT0RPOiBSdW4gY29kZVxuICAgIH1cblxuICAgIGRvd25sb2FkRmlsZSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN1cGVyLmRvd25sb2FkRmlsZSgpO1xuICAgICAgICBpZiAocmVzdWx0Lm5hbWUgPT09IFwiYW5zd2VyXCIgJiYgcmVzdWx0LmV4dGVuc2lvbiA9PT0gXCIucHlcIikge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBzbHVnZ2lmeSh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5uYW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5taW1ldHlwZSA9IFwidGV4dC94LXB5dGhvblwiO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuRG93bmxvYWRcIiwgXCJcIiwgXCJcIiwgXCJcIiwgcmVzdWx0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuXG5leHBvcnQgY29uc3QgUHl0aG9uRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiUHl0aG9uXCIsXG4gICAgZXh0ZW5zaW9uczogW1wiLnB5XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBQeXRob25FZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBQWVRIT05fRURJVE9SX0hUTUxcbn07IiwiaW1wb3J0IHtBYnN0cmFjdEVkaXRvcn0gZnJvbSBcIi4vYWJzdHJhY3RfZWRpdG9yXCI7XHJcblxyXG5leHBvcnQgY29uc3QgUVVJWl9FRElUT1JfSFRNTCA9IGBcclxuICAgIDxkaXY+XHJcbiAgICA8dGV4dGFyZWEgY2xhc3M9XCJibG9ja3B5LWVkaXRvci1xdWl6XCI+PC90ZXh0YXJlYT5cclxuICAgIDwvZGl2PlxyXG5gO1xyXG5cclxuY2xhc3MgUXVpekVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcclxuICAgICAgICBzdXBlcihtYWluLCB0YWcpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRleHRcIilbMF0sIHtcclxuICAgICAgICAgICAgc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXHJcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcclxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcclxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcclxuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgZHluYW1pY2FsbHkgd2hlbiBjaGFuZ2luZyBpbnN0cnVjdG9yIHN0YXR1c1xyXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRWYWx1ZShuZXdDb250ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZU1pcnJvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGUuaGFuZGxlKHRoaXMuY29kZU1pcnJvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xyXG4gICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuY3VycmVudExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UpO1xyXG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBRdWl6RWRpdG9yID0ge1xyXG4gICAgbmFtZTogXCJRdWl6XCIsXHJcbiAgICBleHRlbnNpb25zOiBbXCIucXVpelwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBRdWl6RWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBRVUlaX0VESVRPUl9IVE1MXHJcbn07IiwiLyoqXG4gKiBQYW5lbCBmb3IgZWRpdGluZyB0aGUgc2V0IG9mIFNhbXBsZSBTdWJtaXNzaW9ucy5cbiAqIFRoZXNlIGFyZSBub3QgcHJvdmlkZWQgYXQgYWxsIHRvIHN0dWRlbnRzIHdpdGhvdXQgdGhlIEdyYWRlciByb2xlLlxuICovXG5cbmltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuXG5leHBvcnQgY29uc3QgU3VibWlzc2lvblN0YXR1c2VzID0ge1xuICAgIFVOS05PV046IFwidW5rbm93blwiLFxuICAgIFBBU1NFRDogXCJwYXNzZWRcIixcbiAgICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG4gICAgRVJST1I6IFwiZXJyb3JcIixcbiAgICBTS0lQUEVEOiBcInNraXBwZWRcIlxufTtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZVN1Ym1pc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHN0YXR1cywgY29kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgQmxhbmsoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW1wbGVTdWJtaXNzaW9uKFwiVW50aXRsZWRcIisoY291bnQgfHwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJtaXNzaW9uU3RhdHVzZXMuVU5LTk9XTiwgXCJhPTBcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYW1wbGVTdWJtaXNzaW9uKGRhdGEubmFtZSwgZGF0YS5zdGF0dXMsIGRhdGEuY29kZSk7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFNBTVBMRV9TVUJNSVNTSU9OU19IVE1MID0gYFxuPGRpdj5cbiAgICA8ZGl2IGRhdGEtYmluZD1cImZvcmVhY2g6IHtkYXRhOiBhc3NpZ25tZW50LnNhbXBsZVN1Ym1pc3Npb25zfVwiXG4gICAgICAgIGNsYXNzPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogbmFtZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXNhbXBsZS1zdWJtaXNzaW9ucy1jb2RlXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjb2RlTWlycm9ySW5zdGFuY2U6IGNvZGVcIj48L3RleHRhcmVhPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdGF0dXNcIj48L3NwYW4+ICAgICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmA7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5jb2RlTWlycm9ySW5zdGFuY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBiaW5kaW5nIGlzIGZpcnN0IGFwcGxpZWQgdG8gYW4gZWxlbWVudFxuICAgICAgICAvLyBTZXQgdXAgYW55IGluaXRpYWwgc3RhdGUsIGV2ZW50IGhhbmRsZXJzLCBldGMuIGhlcmVcbiAgICAgICAgY29uc29sZS5sb2coXCJJTklUXCIpO1xuICAgICAgICBsZXQgY20gPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShlbGVtZW50LCB7XG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgZmlyc3RMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcbiAgICAgICAgICAgIHRhYlNpemU6IDQsXG4gICAgICAgICAgICBpbmRlbnRXaXRoVGFiczogZmFsc2UsXG4gICAgICAgICAgICBleHRyYUtleXM6IHtcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiOiBcImluZGVudExlc3NcIixcbiAgICAgICAgICAgICAgICBcIkVzY1wiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBjbS5zZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIsICFjbS5nZXRPcHRpb24oXCJmdWxsU2NyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbS5zZXRTaXplKFwiMTAwJVwiLCBcIjEwMHB4XCIpO1xuICAgICAgICByZXR1cm4gY207XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgb25jZSB3aGVuIHRoZSBiaW5kaW5nIGlzIGZpcnN0IGFwcGxpZWQgdG8gYW4gZWxlbWVudCxcbiAgICAgICAgLy8gYW5kIGFnYWluIHdoZW5ldmVyIGFueSBvYnNlcnZhYmxlcy9jb21wdXRlZHMgdGhhdCBhcmUgYWNjZXNzZWQgY2hhbmdlXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NIGVsZW1lbnQgYmFzZWQgb24gdGhlIHN1cHBsaWVkIHZhbHVlcyBoZXJlLlxuICAgICAgICBjb25zb2xlLmxvZyhcIlVQREFURVwiKTtcbiAgICB9XG59O1xuXG5jbGFzcyBTYW1wbGVTdWJtaXNzaW9uc1ZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBidWlsZEVkaXRvcihuZXdET00sIGluZGV4LCBuZXdFbGVtZW50KSB7XG5cbiAgICB9XG5cbiAgICByZWJ1aWxkRWRpdG9ycygpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZWJ1aWxkaW5nIGVkaXRvcnNcIik7XG4gICAgfVxuXG4gICAgZW50ZXIobmV3RmlsZW5hbWUsIG9sZEVkaXRvcikge1xuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcih0aGlzLmZpbGUuaGFuZGxlKCkpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uID0gdGhpcy5maWxlLmhhbmRsZS5zdWJzY3JpYmUodGhpcy51cGRhdGVFZGl0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIE5vdGlmeSByZWxldmFudCBmaWxlIG9mIGNoYW5nZXMgdG8gQk1cbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xuICAgICAgICAvL3RoaXMucmVidWlsZEVkaXRvcnMoKTtcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAob2xkRWRpdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRhZy5maW5kKFwiLkNvZGVNaXJyb3JcIikpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSxjbSkgPT4gY29uc29sZS5sb2coXCIrKytcIiwgY20uQ29kZU1pcnJvcikpKTtcbiAgICAgICAgICAgIHRoaXMudGFnLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5tYXAoKGksIGNtKSA9PiBjbS5Db2RlTWlycm9yLnJlZnJlc2goKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJFRlJFU0hcIik7XG4gICAgICAgICAgICAvLyBEZWxheSBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVuZGVyZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy50YWcuZmluZChcIi5Db2RlTWlycm9yXCIpLm1hcCgoaSwgY20pID0+IGNtLkNvZGVNaXJyb3IucmVmcmVzaCgpKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKG5ld0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5jb2RlTWlycm9ycyk7XG4gICAgICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMuZWFjaCggKGksIGNtKSA9PiBjbS5zZXRWYWx1ZShuZXdDb250ZW50cy5qb2luKFwiXFxuXCIpKSk7XG4gICAgICAgICAgICAvL3RoaXMuY29kZU1pcnJvcnMuZWFjaCggKGksIGNtKSA9PiBjbS5yZWZyZXNoKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlSGFuZGxlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maWxlLmhhbmRsZSh0aGlzLmNvZGVNaXJyb3JzLm1hcChjbSA9PiBjbS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IsIG5ld0VkaXRvcikge1xuICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNvZGVNaXJyb3JzID0gW107XG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9ycy5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xuICAgICAgICAvL3RoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2FtcGxlU3VibWlzc2lvbnMgPSB7XG4gICAgbmFtZTogXCJTYW1wbGUgU3VibWlzc2lvbnNcIixcbiAgICBleHRlbnNpb25zOiBbXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFNhbXBsZVN1Ym1pc3Npb25zVmlldyxcbiAgICB0ZW1wbGF0ZTogU0FNUExFX1NVQk1JU1NJT05TX0hUTUxcbn07XG4iLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcblxuZXhwb3J0IGNvbnN0IFRBR1NfRURJVE9SX0hUTUwgPSBgXG5DcmVhdGUgbmV3XG5JbXBvcnQgYnkgbmFtZVxuRmluZCBieSBvd25lci9jb3Vyc2Uva2luZFxuXG5UYWdzOlxuICAgIERhdGE6XG4gICAgICAgIE5hbWVcbiAgICAgICAgS2luZFxuICAgICAgICBMZXZlbFxuICAgICAgICBWZXJzaW9uXG4gICAgICAgIERlc2NyaXB0aW9uXG4gICAgQ29udHJvbHM6XG4gICAgICAgIEVkaXRcbiAgICAgICAgUmVtb3ZlXG4gICAgICAgIERlbGV0ZSBcbmA7XG5cbmNsYXNzIFRhZ3NFZGl0b3JWaWV3IGV4dGVuZHMgQWJzdHJhY3RFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICBzdXBlcihtYWluLCB0YWcuZmluZChcIi5ibG9ja3B5LWVkaXRvci10YWdzXCIpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUYWdzRWRpdG9yID0ge1xuICAgIG5hbWU6IFwiVGFnc1wiLFxuICAgIGV4dGVuc2lvbnM6IFtcIiF0YWdzLmJsb2NrcHlcIl0sXG4gICAgY29uc3RydWN0b3I6IFRhZ3NFZGl0b3JWaWV3LFxuICAgIHRlbXBsYXRlOiBUQUdTX0VESVRPUl9IVE1MXG59OyIsImltcG9ydCB7QWJzdHJhY3RFZGl0b3J9IGZyb20gXCIuL2Fic3RyYWN0X2VkaXRvclwiO1xuaW1wb3J0IHtkZWZhdWx0X2hlYWRlcn0gZnJvbSBcIi4vZGVmYXVsdF9oZWFkZXJcIjtcblxuZXhwb3J0IGNvbnN0IFRFWFRfRURJVE9SX0hUTUwgPSBgXG4gICAgJHtkZWZhdWx0X2hlYWRlcn1cbiAgICA8ZGl2PlxuICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXRleHRcIj48L3RleHRhcmVhPlxuICAgIDwvZGl2PlxuYDtcblxuY2xhc3MgVGV4dEVkaXRvclZpZXcgZXh0ZW5kcyBBYnN0cmFjdEVkaXRvciB7XG4gICAgY29uc3RydWN0b3IobWFpbiwgdGFnKSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRhZy5maW5kKFwiLmJsb2NrcHktZWRpdG9yLXRleHRcIilbMF0sIHtcbiAgICAgICAgICAgIHNob3dDdXJzb3JXaGVuU2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgICAgICBmaXJzdExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICBpbmRlbnRVbml0OiA0LFxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcbiAgICAgICAgICAgIGluZGVudFdpdGhUYWJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1xuICAgICAgICAgICAgICAgIFwiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxuICAgICAgICAgICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJGMTFcIjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKSB7XG4gICAgICAgIHN1cGVyLmVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKHRoaXMuZmlsZS5oYW5kbGUoKSk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgcmVsZXZhbnQgRmlsZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm90aWZ5IHJlbGV2YW50IGZpbGUgb2YgY2hhbmdlcyB0byBCTVxuICAgICAgICB0aGlzLmN1cnJlbnRMaXN0ZW5lciA9IHRoaXMudXBkYXRlSGFuZGxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5vbihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIC8vIERlbGF5IHNvIHRoYXQgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNvZGVNaXJyb3IucmVmcmVzaC5iaW5kKHRoaXMuY29kZU1pcnJvciksIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBkeW5hbWljYWxseSB3aGVuIGNoYW5naW5nIGluc3RydWN0b3Igc3RhdHVzXG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBuZXdGaWxlbmFtZS5zdGFydHNXaXRoKFwiJlwiKSAmJiAhdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuaW5zdHJ1Y3RvcigpKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3IobmV3Q29udGVudHMpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9ICF0aGlzLmRpcnR5O1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0VmFsdWUobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUhhbmRsZShldmVudCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhpdChuZXdGaWxlbmFtZSwgb2xkRWRpdG9yLCBuZXdFZGl0b3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcbiAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuY29kZU1pcnJvci5zZXRPcHRpb24oXCJyZWFkT25seVwiLCBmYWxzZSk7XG4gICAgICAgIHN1cGVyLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvcik7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dEVkaXRvciA9IHtcbiAgICBuYW1lOiBcIlRleHRcIixcbiAgICBleHRlbnNpb25zOiBbXCIudHh0XCJdLFxuICAgIGNvbnN0cnVjdG9yOiBUZXh0RWRpdG9yVmlldyxcbiAgICB0ZW1wbGF0ZTogVEVYVF9FRElUT1JfSFRNTFxufTsiLCJpbXBvcnQge0Fic3RyYWN0RWRpdG9yfSBmcm9tIFwiLi9hYnN0cmFjdF9lZGl0b3JcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBUT09MQk9YX0VESVRPUl9IVE1MID0gYFxyXG4gICAgPGRpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCJcclxuICAgICAgICAgcm9sZT1cInRvb2xiYXJcIiBhcmlhLWxhYmVsPVwiVG9vbGJveCBUb29sYmFyXCI+XHJcbiAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIG1yLTJcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiU2F2ZSBHcm91cFwiPiAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1lZGl0b3ItanNvbi1zYXZlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtc2F2ZVwiPjwvc3Bhbj4gU2F2ZVxyXG4gICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImJsb2NrcHktZWRpdG9yLXRvb2xib3hcIj48L3RleHRhcmVhPlxyXG4gICAgPC9kaXY+XHJcbmA7XHJcblxyXG5jbGFzcyBUb29sYm94RWRpdG9yVmlldyBleHRlbmRzIEFic3RyYWN0RWRpdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xyXG4gICAgICAgIHN1cGVyKG1haW4sIHRhZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGFnLmZpbmQoXCIuYmxvY2tweS1lZGl0b3ItdG9vbGJveFwiKVswXSwge1xyXG4gICAgICAgICAgICBzaG93Q3Vyc29yV2hlblNlbGVjdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpcnN0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgaW5kZW50VW5pdDogNCxcclxuICAgICAgICAgICAgdGFiU2l6ZTogNCxcclxuICAgICAgICAgICAgaW5kZW50V2l0aFRhYnM6IGZhbHNlLFxyXG4gICAgICAgICAgICBtb2RlOiBcImpzb25cIixcclxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlRhYlwiOiBcImluZGVudE1vcmVcIixcclxuICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IFwiaW5kZW50TGVzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJFc2NcIjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uc2V0T3B0aW9uKFwiZnVsbFNjcmVlblwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiRjExXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtLnNldE9wdGlvbihcImZ1bGxTY3JlZW5cIiwgIWNtLmdldE9wdGlvbihcImZ1bGxTY3JlZW5cIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGVudGVyKG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpIHtcclxuICAgICAgICBzdXBlci5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IodGhpcy5maWxlLmhhbmRsZSgpKTtcclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHJlbGV2YW50IEZpbGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmZpbGUuaGFuZGxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUVkaXRvci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvLyBOb3RpZnkgcmVsZXZhbnQgZmlsZSBvZiBjaGFuZ2VzIHRvIEJNXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGlzdGVuZXIgPSB0aGlzLnVwZGF0ZUhhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYnRuLWVkaXRvci1qc29uLXNhdmVcIikub24oXCJjbGlja1wiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgLy90aGlzLmNvZGVNaXJyb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChvbGRFZGl0b3IgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgLy8gRGVsYXkgc28gdGhhdCBldmVyeXRoaW5nIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jb2RlTWlycm9yLnJlZnJlc2guYmluZCh0aGlzLmNvZGVNaXJyb3IpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogdXBkYXRlIGR5bmFtaWNhbGx5IHdoZW4gY2hhbmdpbmcgaW5zdHJ1Y3RvciBzdGF0dXNcclxuICAgICAgICB0aGlzLmNvZGVNaXJyb3Iuc2V0T3B0aW9uKFwicmVhZE9ubHlcIiwgbmV3RmlsZW5hbWUuc3RhcnRzV2l0aChcIiZcIikgJiYgIXRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lmluc3RydWN0b3IoKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvcihuZXdDb250ZW50cykge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAhdGhpcy5kaXJ0eTtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldFZhbHVlKG5ld0NvbnRlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlTWlycm9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIYW5kbGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gIXRoaXMuZGlydHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZS5oYW5kbGUodGhpcy5jb2RlTWlycm9yLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MudG9vbGJveCgpID09PSBcImN1c3RvbVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5weXRob25FZGl0b3IucmVsb2FkVG9vbGJveChcImN1c3RvbVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXJcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYnRuLWVkaXRvci10b29sYm94LXNhdmVcIikub2ZmKFwiY2xpY2tcIiwgdGhpcy5jdXJyZW50TGlzdGVuZXIpO1xyXG4gICAgICAgIC8vdGhpcy5jb2RlTWlycm9yLm9mZihcImNoYW5nZVwiLCB0aGlzLmN1cnJlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5jb2RlTWlycm9yLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlKTtcclxuICAgICAgICBzdXBlci5leGl0KG5ld0ZpbGVuYW1lLCBvbGRFZGl0b3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVG9vbGJveEVkaXRvciA9IHtcclxuICAgIG5hbWU6IFwiVG9vbGJveFwiLFxyXG4gICAgZXh0ZW5zaW9uczogW1wiP3Rvb2xib3guYmxvY2tweVwiXSxcclxuICAgIGNvbnN0cnVjdG9yOiBUb29sYm94RWRpdG9yVmlldyxcclxuICAgIHRlbXBsYXRlOiBUT09MQk9YX0VESVRPUl9IVE1MXHJcbn07IiwiLyoqXG4gKiBFZGl0b3JzIGFyZSBpbmZlcnJlZCBmcm9tIEZpbGVuYW1lcy5cbiAqXG4gKiBUaGUgZWRpdG9yIGlzIGJhc2VkIG9uIHRoZSBleHRlbnNpb246XG4gKiAgLmJsb2NrcHk6IFNwZWNpYWwgZWRpdG9yICh3aWxsIGJlIGNob3NlbiBieSBmaWxlbmFtZSlcbiAqICAucHk6IFB5dGhvbiBFZGl0b3JcbiAqICAubWQ6IE1hcmtkb3duIEVkaXRvclxuICogIC50eHQ6IFRleHQgRWRpdG9yIChhbHNvIHVzZWQgZm9yIG90aGVyIHR5cGVzKVxuICogIC5wZW1sOiBQRU1MIEVkaXRvclxuICogIC5wbmcsIC5naWYsIC5qcGVnLCAuanBnLCAuYm1wOiBJbWFnZSBFZGl0b3JcbiAqICAuanNvbjogSlNPTiBFZGl0b3JcbiAqICAueWFtbDogWUFNTCBFZGl0b3JcbiAqL1xuXG5pbXBvcnQge1B5dGhvbkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3B5dGhvblwiO1xuaW1wb3J0IHtUZXh0RWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvdGV4dFwiO1xuaW1wb3J0IHtBc3NpZ21lbnRUeXBlIGFzIEFzc2lnbm1lbnRUeXBlLCBBc3NpZ25tZW50U2V0dGluZ3N9IGZyb20gXCIuL2VkaXRvci9hc3NpZ25tZW50X3NldHRpbmdzXCI7XG5pbXBvcnQge1RhZ3NFZGl0b3J9IGZyb20gXCIuL2VkaXRvci90YWdzXCI7XG5pbXBvcnQge01hcmtkb3duRWRpdG9yfSBmcm9tIFwiLi9lZGl0b3IvbWFya2Rvd25cIjtcbmltcG9ydCB7U2FtcGxlU3VibWlzc2lvbnN9IGZyb20gXCIuL2VkaXRvci9zYW1wbGVfc3VibWlzc2lvbnNcIjtcbmltcG9ydCB7SnNvbkVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL2pzb25cIjtcbmltcG9ydCB7VG9vbGJveEVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3Rvb2xib3hcIjtcbmltcG9ydCB7UXVpekVkaXRvcn0gZnJvbSBcIi4vZWRpdG9yL3F1aXpcIjtcbmltcG9ydCB7SW1hZ2VFZGl0b3J9IGZyb20gXCIuL2VkaXRvci9pbWFnZXNcIjtcblxuLyoqXG4gKiBUaGUgZGlmZmVyZW50IHBvc3NpYmxlIGVkaXRvcnMgYXZhaWxhYmxlXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgbGV0IEVkaXRvcnNFbnVtID0ge1xuICAgIFNVQk1JU1NJT046IFwic3VibWlzc2lvblwiLFxuICAgIEFTU0lHTk1FTlQ6IFwiYXNzaWdubWVudFwiLFxuICAgIElOU1RSVUNUSU9OUzogXCJpbnN0cnVjdGlvbnNcIixcbiAgICBPTl9SVU46IFwib25fcnVuXCIsXG4gICAgT05fQ0hBTkdFOiBcIm9uX2NoYW5nZVwiLFxuICAgIE9OX0VWQUw6IFwib25fZXZhbFwiLFxuICAgIFNUQVJUSU5HX0NPREU6IFwic3RhcnRpbmdfY29kZVwiLFxuICAgIFNBTVBMRV9TVUJNSVNTSU9OUzogXCJzYW1wbGVfc3VibWlzc2lvbnNcIixcbiAgICBJTlNUUlVDVE9SX0ZJTEU6IFwiaW5zdHJ1Y3Rvcl9maWxlXCJcbn07XG5cbmNvbnN0IFNQRUNJQUxfTkFNRVNQQUNFUyA9IFtcIiFcIiwgXCJeXCIsIFwiP1wiLCBcIiRcIl07XG5cbmNvbnN0IEFWQUlMQUJMRV9FRElUT1JTID0gW1xuICAgIFRleHRFZGl0b3IsIFB5dGhvbkVkaXRvciwgQXNzaWdubWVudFNldHRpbmdzLCBUYWdzRWRpdG9yLCBNYXJrZG93bkVkaXRvcixcbiAgICBTYW1wbGVTdWJtaXNzaW9ucywgSnNvbkVkaXRvciwgVG9vbGJveEVkaXRvciwgUXVpekVkaXRvciwgSW1hZ2VFZGl0b3Jcbl07XG5cbmV4cG9ydCBjb25zdCBFRElUT1JTX0hUTUwgPSBBVkFJTEFCTEVfRURJVE9SUy5tYXAoZWRpdG9yID0+IGBcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXBhbmVsIGJsb2NrcHktZWRpdG9yXCIgXG4gICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmVkaXRvcnMudmlldygpLm5hbWUgPT09ICcke2VkaXRvci5uYW1lfScsIGNsYXNzOiB1aS5lZGl0b3JzLndpZHRoXCI+XG4gICAgPGRpdj5cbiAgICAke2VkaXRvci50ZW1wbGF0ZX1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYFxuICAgIC8qXG4gICAgYFxuPCEtLSBrbyBpZjogdWkuZWRpdG9ycy52aWV3KCkubmFtZSA9PT0gJyR7ZWRpdG9yLm5hbWV9JyAtLT5cbiR7ZWRpdG9yLnRlbXBsYXRlfVxuPCEtLSAva28gLS0+YCovXG4pLmpvaW4oXCJcXG5cIik7XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3JzIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCB0YWcpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZF8gPSBbXTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zXyA9IHt9O1xuICAgICAgICB0aGlzLmJ5TmFtZV8gPSB7fTtcbiAgICAgICAgQVZBSUxBQkxFX0VESVRPUlMuZm9yRWFjaChlZGl0b3IgPT4gdGhpcy5yZWdpc3RlckVkaXRvcihlZGl0b3IpKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUuc3Vic2NyaWJlKHRoaXMuY2hhbmdlRWRpdG9yLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckVkaXRvcihkYXRhKSB7XG4gICAgICAgIGxldCBleHRlbnNpb25zID0gZGF0YS5leHRlbnNpb25zO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgZGF0YS5jb25zdHJ1Y3Rvcih0aGlzLm1haW4sIHRoaXMudGFnKTtcbiAgICAgICAgaW5zdGFuY2UubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkXy5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5ieU5hbWVfW2RhdGEubmFtZS50b0xvd2VyQ2FzZSgpXSA9IGluc3RhbmNlO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnNfW2V4dGVuc2lvbnNbaV1dID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBieU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieU5hbWVfW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgY2hhbmdlRWRpdG9yKG5ld0ZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBvbGRFZGl0b3IgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGxldCBuZXdFZGl0b3IgPSB0aGlzLmdldEVkaXRvcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICAgICAgaWYgKG9sZEVkaXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkRWRpdG9yLmV4aXQobmV3RmlsZW5hbWUsIG9sZEVkaXRvciwgbmV3RWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXdFZGl0b3I7XG4gICAgICAgIHRoaXMuY3VycmVudC5lbnRlcihuZXdGaWxlbmFtZSwgb2xkRWRpdG9yKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VGaWxlbmFtZShwYXRoKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IHBhdGguY2hhckF0KDApO1xuICAgICAgICBpZiAoU1BFQ0lBTF9OQU1FU1BBQ0VTLmluZGV4T2Yoc3BhY2UpICE9PSAtMSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BhY2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgICAgICBsZXQgdHlwZSA9IHBhdGguc3Vic3RyKHBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHtcInNwYWNlXCI6IHNwYWNlLCBcIm5hbWVcIjogbmFtZSwgXCJ0eXBlXCI6IHR5cGV9O1xuICAgIH1cblxuICAgIGdldEVkaXRvcihwYXRoKSB7XG4gICAgICAgIGxldCB7c3BhY2UsIG5hbWUsIHR5cGV9ID0gRWRpdG9ycy5wYXJzZUZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCIuYmxvY2tweVwiICYmIHBhdGggaW4gdGhpcy5leHRlbnNpb25zXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc19bcGF0aF07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzc2lnbm1lbnRUeXBlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQudHlwZSgpO1xuICAgICAgICBpZiAoYXNzaWdubWVudFR5cGUgIT09IEFzc2lnbm1lbnRUeXBlLkJMT0NLUFkpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImFuc3dlclwiICYmIHR5cGUgPT09IFwiLnB5XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCIuXCIrYXNzaWdubWVudFR5cGUgaW4gdGhpcy5leHRlbnNpb25zXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zX1tcIi5cIithc3NpZ25tZW50VHlwZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGVkaXRvciByZWdpc3RlcmVkIGZvciBhc3NpZ25tZW50IHR5cGU6XCIsIGFzc2lnbm1lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZF9bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIHRoaXMuZXh0ZW5zaW9uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNfW3R5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZF9bMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50eXBlKCksIHNwYWNlLCBuYW1lLCB0eXBlKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi9zZXJ2ZXJcIjtcbmltcG9ydCB7T25SdW5Db25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fcnVuXCI7XG5pbXBvcnQge1J1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9ydW5cIjtcbmltcG9ydCB7RXZhbENvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9ldmFsXCI7XG5pbXBvcnQge1NhbXBsZUNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9zYW1wbGVcIjtcbmltcG9ydCB7T25DaGFuZ2VDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9lbmdpbmUvb25fY2hhbmdlXCI7XG5pbXBvcnQge09uRXZhbENvbmZpZ3VyYXRpb259IGZyb20gXCIuL2VuZ2luZS9vbl9ldmFsXCI7XG5pbXBvcnQge09uU2FtcGxlQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vZW5naW5lL29uX3NhbXBsZVwiO1xuXG4vKipcbiAqIEFuIG9iamVjdCBmb3IgZXhlY3V0aW5nIFB5dGhvbiBjb2RlIGFuZCBwYXNzaW5nIHRoZSByZXN1bHRzIGFsb25nIHRvIGludGVyZXN0ZWQgY29tcG9uZW50cy5cbiAqXG4gKiBJbnRlcmVzdGluZyBjb21wb25lbnRzOlxuICogIEV4ZWN1dGlvbiBCdWZmZXI6IFJlc3BvbnNpYmxlIGZvciBjb2xsZWN0aW5nIHRoZSB0cmFjZSBkdXJpbmcgcHJvZ3JhbSBleGVjdXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgVGhpcyBwcmV2ZW50cyBLbm9ja291dGpzIGZyb20gdXBkYXRpbmcgdGhlIGVkaXRvciBkdXJpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlFZGl0b3J9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUVuZ2luZSB7XG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbk1vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbjtcblxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zID0ge1xuICAgICAgICAgICAgcnVuOiBuZXcgUnVuQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIGV2YWw6IG5ldyBFdmFsQ29uZmlndXJhdGlvbihtYWluKSxcbiAgICAgICAgICAgIG9uUnVuOiBuZXcgT25SdW5Db25maWd1cmF0aW9uKG1haW4pLFxuICAgICAgICAgICAgb25DaGFuZ2U6IG5ldyBPbkNoYW5nZUNvbmZpZ3VyYXRpb24obWFpbiksXG4gICAgICAgICAgICBvbkV2YWw6IG5ldyBPbkV2YWxDb25maWd1cmF0aW9uKG1haW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHJlY29uZmlndXJlIHNrdWxwdCBzbyB3ZSBjYW4gcGFyc2VcbiAgICAgICAgU2suY29uZmlndXJlKHRoaXMuY29uZmlndXJhdGlvbnMucnVuLmdldFNrdWxwdE9wdGlvbnMoKSk7XG5cbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHRyYWNpbmcgd2hpbGUgdGhlIHByb2dyYW0gaXMgZXhlY3V0aW5nXG4gICAgICAgIHRoaXMuZXhlY3V0aW9uQnVmZmVyID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluYWJsZSBmdW5jdGlvbiB0byBiZSBydW4gd2hlbiBleGVjdXRpb24gaGFzIGZ1bGx5IGVuZGVkLFxuICAgICAgICAgKiB3aGV0aGVyIGl0IHN1Y2NlZWRzIG9yIGZhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkJlZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgcmVwb3J0c1xuICAgICAqL1xuICAgIHJlc2V0UmVwb3J0cygpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMuZXhlY3V0aW9uTW9kZWwucmVwb3J0cztcbiAgICAgICAgcmVwb3J0W1widmVyaWZpZXJcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wicGFyc2VyXCJdID0ge307XG4gICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7fTtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHt9O1xuICAgICAgICByZXBvcnRbXCJtb2RlbFwiXSA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICB9O1xuXG4gICAgcmVzZXRTdHVkZW50TW9kZWwoKSB7XG4gICAgICAgIGxldCBzdHVkZW50ID0gdGhpcy5leGVjdXRpb25Nb2RlbC5zdHVkZW50O1xuICAgICAgICBzdHVkZW50LmNhbGxzID0ge307XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFN0ZXAobnVsbCk7XG4gICAgICAgIHN0dWRlbnQuY3VycmVudFRyYWNlU3RlcCgwKTtcbiAgICAgICAgc3R1ZGVudC5sYXN0U3RlcCgwKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50TGluZShudWxsKTtcbiAgICAgICAgc3R1ZGVudC5jdXJyZW50VHJhY2VEYXRhLnJlbW92ZUFsbCgpO1xuICAgICAgICBzdHVkZW50LnJlc3VsdHMgPSBudWxsO1xuICAgICAgICBzdHVkZW50LnRyYWNpbmcgPSBbXTtcbiAgICB9XG5cbiAgICByZXNldEV4ZWN1dGlvbkJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5leGVjdXRpb25CdWZmZXIgPSB7XG4gICAgICAgICAgICBcInRyYWNlXCI6IFtdLFxuICAgICAgICAgICAgXCJzdGVwXCI6IDAsXG4gICAgICAgICAgICBcImxpbmVcIjogMCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpbnRlcmZhY2UgYXNwZWN0cyBvZiB0aGUgcHJldmlvdXMgUnVuLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICAvLyBUT0RPOiBDbGVhciBvdXQgYW55IGNvdmVyYWdlL3RyYWNlL2Vycm9yIGhpZ2hsaWdodHMgaW4gZWRpdG9yc1xuICAgICAgICAvLyBSZXNldCBleGVjdXRpb24gaW4gbW9kZWxcbiAgICAgICAgdGhpcy5yZXNldFN0dWRlbnRNb2RlbCgpO1xuICAgICAgICAvLyBHZXQgcmVwb3J0cyByZWFkeVxuICAgICAgICB0aGlzLnJlc2V0UmVwb3J0cygpO1xuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGV4ZWN1dGlvbiBidWZmZXJcbiAgICAgICAgdGhpcy5yZXNldEV4ZWN1dGlvbkJ1ZmZlcigpO1xuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGNvbnNvbGUgb2YgcHJpbnRlZCBzdHVmZlxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCBhbnkgb2xkIGZlZWRiYWNrXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsYXllZFJ1bigpIHtcbiAgICAgICAgLy90aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIC8vJChcIi5ibG9ja3B5LXJ1blwiKS5hZGRDbGFzcyhcImJsb2NrcHktcnVuLXJ1bm5pbmdcIik7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIC8vc2V0VGltZW91dCh0aGlzLnJ1bi5iaW5kKHRoaXMpLCAxKTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuXG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLnJ1bi51c2UodGhpcyk7XG4gICAgICAgIGxldCBleGVjdXRpb24gPSB0aGlzLmV4ZWN1dGUoKS50aGVuKFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmZhaWx1cmUuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgICk7XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUZlZWRiYWNrKCkpIHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucHJvdmlkZVNlY3JldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25SdW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpO1xuICAgIH1cblxuICAgIG9uUnVuKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uUnVuLnVzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKCkudGhlbihcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zdWNjZXNzLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKSxcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbih0aGlzLmNvbmZpZ3VyYXRpb24uZmluYWxseS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbikpXG4gICAgICAgICAgICAudGhlbih0aGlzLmV4ZWN1dGlvbkVuZF8uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuQUNUSVZFKTtcbiAgICAgICAgbGV0IGV2YWx1YXRpb25JbnB1dCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuZXZhbHVhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coZXZhbHVhdGlvbklucHV0KTtcbiAgICAgICAgZXZhbHVhdGlvbklucHV0LnRoZW4oKHVzZXJJbnB1dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5ldmFsLnVzZSh0aGlzLCB1c2VySW5wdXQpO1xuICAgICAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnN1Y2Nlc3MuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5mYWlsdXJlLmJpbmQodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZUZlZWRiYWNrKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vbkV2YWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlU2VjcmV0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24udGhlbih0aGlzLm9uRXZhbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLnNob3dFcnJvcnMuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLmV2YWx1YXRlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0aW9uLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25FdmFsKCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLm9uRXZhbC51c2UodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpLnRoZW4oXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uc3VjY2Vzcy5iaW5kKHRoaXMuY29uZmlndXJhdGlvbiksXG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZmFpbHVyZS5iaW5kKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5ldmFsdWF0ZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb25maWd1cmF0aW9uLmZpbmFsbHkuYmluZCh0aGlzLmNvbmZpZ3VyYXRpb24pKTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5vbkNoYW5nZS51c2UodGhpcyk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICByZXR1cm4gU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UoKCkgPT5cbiAgICAgICAgICAgIFNrLmltcG9ydE1haW5XaXRoQm9keSh0aGlzLmNvbmZpZ3VyYXRpb24uZmlsZW5hbWUsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5jb2RlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5zeXNtb2R1bGVzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlZCB3aGVuZXZlciB0aGUgUHl0aG9uIGNvZGUgY2hhbmdlc1xuICAgICAqL1xuICAgIG9uX2NoYW5nZSgpIHtcbiAgICAgICAgbGV0IEZJTEVOQU1FID0gXCJvbl9jaGFuZ2VcIjtcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgaW5zdHJ1Y3RvciBoYXMgbm90IGRlZmluZWQgYW55dGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLm1haW4ubW9kZWwucHJvZ3JhbXNbRklMRU5BTUVdKCkudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdGF0dXMoXCJjaGFuZ2luZ1wiKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnNhdmVDb2RlKCk7XG4gICAgICAgIC8vIE9uIHN0ZXAgZG9lcyBub3QgcGVyZm9ybSBwYXJzZSBhbmFseXNpcyBieSBkZWZhdWx0IG9yIHJ1biBzdHVkZW50IGNvZGVcbiAgICAgICAgbGV0IGVuZ2luZSA9IHRoaXM7XG4gICAgICAgIGxldCBmZWVkYmFjayA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrO1xuICAgICAgICBlbmdpbmUucmVzZXRSZXBvcnRzKCk7XG4gICAgICAgIGVuZ2luZS52ZXJpZnlDb2RlKCk7XG4gICAgICAgIGVuZ2luZS51cGRhdGVQYXJzZSgpO1xuICAgICAgICBlbmdpbmUucnVuSW5zdHJ1Y3RvckNvZGUoRklMRU5BTUUsIHRydWUsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0pIHtcbiAgICAgICAgICAgICAgICAvLyBTVUNDRVNTLCBTQ09SRSwgQ0FURUdPUlksIExBQkVMLCBNRVNTQUdFLCBEQVRBLCBISURFXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogb25seSBzaG93IHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGNhdGVnb3J5ID09PSBcIkluc3RydWN0b3JcIiAmJiBsYWJlbCA9PT0gXCJObyBlcnJvcnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKGNhdGVnb3J5LCBsYWJlbCwgbWVzc2FnZSwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZ2luZS5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKG1vZHVsZS4kZCk7XG4gICAgICAgICAgICAgICAgZW5naW5lLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0YXR1cyhcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZW5naW5lLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJlbmdpbmVcIiwgXCJvbl9jaGFuZ2VcIik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBhdHRlbXB0IHRvIGNhbGwgdGhlIGRlZmluZWQgb25FeGVjdXRpb25FbmQsXG4gICAgICogYnV0IHdpbGwgZG8gbm90aGluZyBpZiB0aGVyZSBpcyBubyBmdW5jdGlvbiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkVuZF8oKSB7XG4gICAgICAgIGlmICh0aGlzLm9uRXhlY3V0aW9uRW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhlY3V0aW9uRW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkJlZ2luXygpIHtcbiAgICAgICAgaWYgKHRoaXMub25FeGVjdXRpb25CZWdpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkV4ZWN1dGlvbkJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX01PRFVMRSA9IFwibGV0ICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obW9kKXsgcmV0dXJuIG1vZDsgfVwiO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBob2xkaW5nIHNldHRpbmdzIG9mIGEgcGFydGljdWxhciBydW4gY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgaXMgdGhlIHJvb3QgY2xhc3MgZm9yIGFsbCBvdGhlciBjb25maWd1cmF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IobWFpbikge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeXNtb2R1bGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgLy8gQWNjZXNzIHBvaW50IGZvciBpbnN0cnVjdG9yIGRhdGFcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHMgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIFNrLmNvbnNvbGUgPSB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlO1xuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICBTay5jb25maWd1cmUodGhpcy5nZXRTa3VscHRPcHRpb25zKCkpO1xuICAgICAgICAvLyBTZXQgb3BlbkZpbGUgYXMgbWVjaGFuaXNtIHRvIHJlYWQgZmlsZXNcbiAgICAgICAgU2suaW5Ccm93c2VyID0gdGhpcy5vcGVuRmlsZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSByZXF1ZXN0c1xuICAgICAgICBTay5yZXF1ZXN0c0dldCA9ICh1cmwsIGRhdGEsIHRpbWVvdXQpID0+IHRoaXMub3BlblVSTCh1cmwsIGRhdGEsIHRpbWVvdXQpO1xuICAgICAgICAvLyBDb25maWd1cmUgYSBcImRvIHlvdSB3YW50IHRvIHdhaXQ/IHByb21wdFwiXG4gICAgICAgIFNrLnRpbWVvdXRIYW5kbGVyID0gKHRpbWVQYXNzZWQsIGV4ZWNMaW1pdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVUaW1lb3V0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcm9tcHRNZXNzYWdlID0gdGhpcy5nZXRUaW1lb3V0UHJvbXB0KHRpbWVQYXNzZWQvMTAwMCA+IDMwKTtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IHByb21wdChwcm9tcHRNZXNzYWdlLCBTay5leGVjTGltaXQvMTAwMCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgfHwgZGVsYXk9PTApIHtcbiAgICAgICAgICAgICAgICBkZWxheSA9IFNrLmV4ZWNMaW1pdCArIHBhcnNlSW50KGRlbGF5LCAxMCkgKiAxMDAwO1xuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdEZ1bmN0aW9uID0gKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpbWVvdXQoKSA/IEluZmluaXR5IDogZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsYXk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEF0dGFjaCBiZWZvcmVDYWxsXG4gICAgICAgIFNrLmJlZm9yZUNhbGwgPSB0aGlzLmJlZm9yZUNhbGwuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0VGltZW91dFByb21wdChsb25nVGltZW91dCkge1xuICAgICAgICBpZiAobG9uZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBwcm9ncmFtIGhhcyB0YWtlbiBhIFJFQUxMWSBsb25nIHRpbWUgdG8gcnVuICgzMCBvciBtb3JlIHNlY29uZHMpLiBZb3UgbWlnaHQgd2FudCB0byBjYW5jZWwgYW5kIGNoZWNrIHlvdXIgY29kZS4gT3IsIHlvdSBjYW4gYWRkIG1vcmUgc2Vjb25kcyB0byB3YWl0IGJlbG93LlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIHByb2dyYW0gaXMgdGFraW5nIGEgd2hpbGUgdG8gcnVuLiBIb3cgbWFueSBtb3JlIHNlY29uZHMgd291bGQgeW91IGxpa2UgdG8gd2FpdD9cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNrdWxwdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX2Z1dHVyZV9fOiBTay5weXRob24zLFxuICAgICAgICAgICAgLy8gaW1wb3J0XG4gICAgICAgICAgICByZWFkOiB0aGlzLmltcG9ydEZpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIG9wZW5cbiAgICAgICAgICAgIC8vZmlsZW9wZW46IHRoaXMub3BlbkZpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIGZpbGUud3JpdGVcbiAgICAgICAgICAgIGZpbGV3cml0ZTogdGhpcy53cml0ZUZpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIHByaW50XG4gICAgICAgICAgICBvdXRwdXQ6IHRoaXMucHJpbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIGlucHV0XG4gICAgICAgICAgICBpbnB1dGZ1bjogdGhpcy5pbnB1dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaW5wdXRmdW5UYWtlc1Byb21wdDogdHJ1ZSxcbiAgICAgICAgICAgIC8vIE1lZGlhIEltYWdlIFByb3h5IFVSTFxuICAgICAgICAgICAgaW1hZ2VQcm94eTogdGhpcy5nZXRJbWFnZVByb3h5LmJpbmQodGhpcyksXG4gICAgICAgICAgICAvLyBUT0RPOiBNYWtlIHRoaXMgc2V0IGJ5IHRoZSBzeXN0ZW0gc28gd2UgY2FuIHVzZSBvdXIgb3duIHNlcnZlcnMgaW4gcHJhY3RpY2VcbiAgICAgICAgICAgIGVtb2ppUHJveHk6IChwYXJ0KSA9PiBgaHR0cHM6Ly90d2Vtb2ppLm1heGNkbi5jb20vdi8xMy4xLjAvc3ZnLyR7cGFydC50b0xvd2VyQ2FzZSgpfS5zdmdgLFxuICAgICAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8ga2VlcCB0aGUgZ2xvYmFsc1xuICAgICAgICAgICAgcmV0YWluR2xvYmFsczogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYWNjZXNzIFNrdWxwdCBidWlsdC1pbnMuIFRoaXMgaXMgcHJldHR5IGdlbmVyaWMsIHRha2VuXG4gICAgICogYWxtb3N0IGRpcmVjdGx5IGZyb20gdGhlIFNrdWxwdCBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gVGhlIHB5dGhvbiBmaWxlbmFtZSAoZS5nLiwgXCJvc1wiIG9yIFwicHByaW50XCIpIHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEphdmFTY3JpcHQgc291cmNlIGNvZGUgb2YgdGhlIGZpbGUgKHdlaXJkLCByaWdodD8pXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzbid0IGZvdW5kLlxuICAgICAqL1xuICAgIGltcG9ydEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfTtcblxuICAgIG9wZW5VUkwodXJsLCBkYXRhLCB0aW1lb3V0KSB7XG4gICAgICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IG1vY2tVcmxEYXRhID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5nZXRGaWxlKFwiP21vY2tfdXJscy5ibG9ja3B5XCIpO1xuICAgICAgICBpZiAobW9ja1VybERhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKG5ldyBTay5idWlsdGluLklPRXJyb3IoXCJDYW5ub3QgYWNjZXNzIHVybDogVVJMIERhdGEgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2NrVXJsRGF0YSA9IEpTT04ucGFyc2UobW9ja1VybERhdGEuaGFuZGxlKCkpO1xuICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBpbiBtb2NrVXJsRGF0YSkge1xuICAgICAgICAgICAgaWYgKG1vY2tVcmxEYXRhLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG1vY2tVcmxEYXRhW2ZpbGVuYW1lXS5sZW5ndGg7IGkrPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2NrVXJsRGF0YVtmaWxlbmFtZV1baV0gPT09IHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVEYXRhID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmlsZVN5c3RlbS5yZWFkRmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGZpbGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3JlamVjdChuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFwiQ2Fubm90IGFjY2VzcyB1cmw6IFwiK3VybCtcIiB3YXMgbm90IG1hZGUgYXZhaWxhYmxlIGZvciB0aGlzIGFzc2lnbm1lbnRcIikpO1xuICAgICAgICB0aHJvdyAobmV3IFNrLmJ1aWx0aW4uSU9FcnJvcihcIkNhbm5vdCBhY2Nlc3MgdXJsOiBcIit1cmwrXCIgd2FzIG5vdCBtYWRlIGF2YWlsYWJsZSBmb3IgdGhpcyBhc3NpZ25tZW50XCIpKTtcbiAgICAgICAgLy99KTtcbiAgICB9XG5cbiAgICBvcGVuRmlsZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgd3JpdGVGaWxlKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmltcGxlbWVudGVkIG1ldGhvZCFcIik7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICBwcmludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpbnB1dCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgY2xlYXJJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmNsZWFySW5wdXRzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5wdXRNb2NrRnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChTay5xdWV1ZWRJbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBTay5xdWV1ZWRJbnB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldEltYWdlUHJveHkodXJsKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBzdGVwKCkge1xuXG4gICAgfVxuXG4gICAgbGFzdFN0ZXAoKSB7XG5cbiAgICB9XG5cbiAgICBpc0ZvcmJpZGRlbihmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3Qgc3VjY2VzcyBleGVjdXRpb25cIik7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdCBmYWlsdXJlIGV4ZWN1dGlvblwiKTtcbiAgICB9XG5cbiAgICBmaW5hbGx5KHJlc3VsdCkge1xuICAgICAgICAvLyBGb3JjZSBQeWdhbWUgdG8gc3RvcCB0cmFwcGluZyBrZXlib2FyZCBldmVudHNcbiAgICAgICAgaWYgKHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZSkge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5weWdhbWVMaW5lLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUucHlnYW1lTGluZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkdW1teU91dFNhbmRib3goKSB7XG4gICAgICAgIC8vU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi9wZWRhbC9zYW5kYm94L3NhbmRib3gucHlcIl0gPSBcImNsYXNzIFNhbmRib3g6IHBhc3NcXG5kZWYgcnVuKCk6IHBhc3NcXG5kZWYgcmVzZXQoKTogcGFzc1xcblwiO1xuICAgIH1cblxuICAgIGJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRSQUNLSU5HIENBTExcIiwgZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpO1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZmFzdGNhbGwgdG9vPyBDaGVjayBob3cgdGhhdCB3b3JrcyBpbiBTa3VscHQgc2lkZVxuICAgICAgICBsZXQgc3R1ZGVudE1vZGVsID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQ7XG4gICAgICAgIGlmICghKFwiY2FsbHNcIiBpbiBzdHVkZW50TW9kZWwpKSB7XG4gICAgICAgICAgICBzdHVkZW50TW9kZWwuY2FsbHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmdW5jdGlvbk5hbWUgaW4gc3R1ZGVudE1vZGVsLmNhbGxzKSkge1xuICAgICAgICAgICAgc3R1ZGVudE1vZGVsLmNhbGxzW2Z1bmN0aW9uTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXJncyA9IHt9O1xuICAgICAgICAvLyBHZXQgYWN0dWFsIHBhcmFtZXRlciBuYW1lcyEhXG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHBvc2FyZ3MubGVuZ3RoOyBpKz0gMSkge1xuICAgICAgICAgICAgYXJnc1tcIl9fQVJHXCIraV0gPSBwb3NhcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MgJiYga3dhcmdzWzBdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3NbXCJfX0FSR1NcIl0gPSBrd2FyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGt3YXJncyAmJiBrd2FyZ3NbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJnc1tcIl9fS1dBUkdTXCJdID0ga3dhcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coYXJncyk7XG4gICAgICAgIHN0dWRlbnRNb2RlbC5jYWxsc1tmdW5jdGlvbk5hbWVdLnB1c2goYXJncyk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQge1N0dWRlbnRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9zdHVkZW50XCI7XG5pbXBvcnQge1N0YXR1c1N0YXRlfSBmcm9tIFwiLi4vc2VydmVyXCI7XG5pbXBvcnQge0Jsb2NrUHlUcmFjZX0gZnJvbSBcIi4uL3RyYWNlXCI7XG5cbmV4cG9ydCBjbGFzcyBFdmFsQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lLCBjb2RlKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB0byBiZSBjdXJyZW50bHkgYWRkZWQgbGluZVxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2UoXCJSdW5uaW5nLi4uXCIpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJhbnN3ZXJcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJfID0gXCIgKyBjb2RlO1xuICAgICAgICBTay5hZnRlclNpbmdsZUV4ZWN1dGlvbiA9IG51bGw7XG4gICAgICAgIFNrLmJlZm9yZUNhbGwgPSBudWxsO1xuXG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIFNrLnJldGFpbkdsb2JhbHMgPSB0cnVlO1xuICAgICAgICBTay5nbG9iYWxzID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50Lmdsb2JhbHMoKTtcblxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZpbGUuQWRkXCIsIFwiXCIsIFwiXCIsIGNvZGUsIFwiZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGVcIiwgXCJcIiwgXCJcIiwgdGhpcy5jb2RlLCBcImV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXZhbCBzdWNjZXNzXCIpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUV2YWx1YXRlLlByb2dyYW1cIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKFNrLmdsb2JhbHMpO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5yZXN1bHRzID0gbW9kdWxlO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLnByaW50VmFsdWUoU2suZmZpLnJlbWFwVG9Kcyhtb2R1bGUuJGQuXy4kcigpKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvL3RoaXMuc3RlcChtb2R1bGUuJGQsIG1vZHVsZS4kZCwtMSwgMCwgZmlsZW5hbWUgKyBcIi5weVwiKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFN0ZXAoKTtcbiAgICAgICAgICAgIHJlcG9ydFtcInN0dWRlbnRcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0cmFjZVwiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UsXG4gICAgICAgICAgICAgICAgXCJsaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcInJlYWxMaW5lc1wiOiB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIudHJhY2UuZmlsdGVyKHggPT4gIXguaXNEb2NzdHJpbmcpLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZXN1bHRzXCI6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICBcIm91dHB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCxcbiAgICAgICAgICAgICAgICBcImV2YWx1YXRpb25cIjogdGhpcy5jb2RlLFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkV2YWwgZmFpbHVyZVwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuRkFJTEVEKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiQ29tcGlsZS5FcnJvclwiLCBcIlwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImV2YWx1YXRpb25zXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImV2YWx1YXRpb25cIjogdGhpcy5jb2RlLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7Q29uZmlndXJhdGlvbiwgRU1QVFlfTU9EVUxFfSBmcm9tIFwiLi9jb25maWd1cmF0aW9ucy5qc1wiO1xuaW1wb3J0IHskc2tfbW9kX2luc3RydWN0b3J9IGZyb20gXCIuLi9za3VscHRfbW9kdWxlcy9za19tb2RfaW5zdHJ1Y3RvclwiO1xuaW1wb3J0IHskc2tfbW9kX2NvdmVyYWdlfSBmcm9tIFwiLi4vc2t1bHB0X21vZHVsZXMvY292ZXJhZ2VcIjtcbmltcG9ydCB7JHBlZGFsX3RyYWNlcn0gZnJvbSBcIi4uL3NrdWxwdF9tb2R1bGVzL3BlZGFsX3RyYWNlclwiO1xuaW1wb3J0IHtjaG9tcFNwZWNpYWxGaWxlfSBmcm9tIFwiLi4vZmlsZXNcIjtcblxuY29uc3QgVVRJTElUWV9NT0RVTEVfQ09ERSA9IFwidmFyICRidWlsdGlubW9kdWxlID0gXCIgKyAkc2tfbW9kX2luc3RydWN0b3IudG9TdHJpbmcoKTtcbmNvbnN0IENPVkVSQUdFX01PRFVMRV9DT0RFID0gJHNrX21vZF9jb3ZlcmFnZTtcblxuZXhwb3J0IGNsYXNzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIGV4dGVuZHMgQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgLy8gSW5zdHJ1Y3RvcnMgZ2V0IDQgc2Vjb25kc1xuICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiA3MDAwO1xuICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAvLyBTdGVwcGVyISBFeGVjdXRlZCBhZnRlciBldmVyeSBzdGF0ZW1lbnQuXG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gbnVsbDsgLy8gMTAgKjEwMDBcbiAgICAgICAgLy8gTXV0ZSBldmVyeXRoaW5nXG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5Lm11dGVQcmludGVyKHRydWUpO1xuICAgICAgICAvLyBEaXNhYmxlIGlucHV0IGJveFxuICAgICAgICBTay5xdWV1ZWRJbnB1dCA9IFtdO1xuICAgICAgICAvLyBUT0RPIFNrLmlucHV0ZnVuID0gQmxvY2tQeUVuZ2luZS5pbnB1dE1vY2tGdW5jdGlvbjtcbiAgICAgICAgLy8gVE9ETzogQWxsb3cgaW5wdXQgZnVuY3Rpb24gdG8gZGlzYWJsZSB0aGUgdGltZXIsIHNvbWVob3dcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgYmVmb3JlQ2FsbCBjaGVja2VyIHVubGVzcyBzcGVjaWZpY2FsbHkgcmVxdWVzdGVkXG4gICAgICAgIFNrLmJlZm9yZUNhbGxCYWNrdXAgPSBTay5iZWZvcmVDYWxsO1xuICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcbiAgICAgICAgLy8gRW5hYmxlIHV0aWxpdHkgbW9kZVxuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3V0aWxpdHkvX19pbml0X18uanNcIl0gPSBVVElMSVRZX01PRFVMRV9DT0RFO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL2NvdmVyYWdlLnB5XCJdID0gQ09WRVJBR0VfTU9EVUxFX0NPREU7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgbmVlZHMgdG8gYmUgb3B0aW1pemVkXG4gICAgICAgIC8vY29uc3QgUEVEQUxfVFJBQ0VSX01PRFVMRV9DT0RFID0gU2suY29tcGlsZSgkcGVkYWxfdHJhY2VyLCBcInRyYWNlci5weVwiLCBcImV4ZWNcIiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBTay5idWlsdGluRmlsZXMuZmlsZXNbXCJzcmMvbGliL3BlZGFsL3NhbmRib3gvdHJhY2VyLnB5XCJdID0gJHBlZGFsX3RyYWNlcjtcbiAgICAgICAgZGVsZXRlIFNrLmJ1aWx0aW5GaWxlcy5maWxlc1tcInNyYy9saWIvcGVkYWwvc2FuZGJveC90cmFjZXIuanNcIl07XG4gICAgICAgIC8vIFRPRE86IE1vY2sgUGVkYWwncyB0cmFjZXIgbW9kdWxlIHdpdGggdGhlIGFwcHJvcHJpYXRlIHZlcnNpb25cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wiLi9faW5zdHJ1Y3Rvci9fX2luaXRfXy5qc1wiXSA9IEVNUFRZX01PRFVMRTtcbiAgICAgICAgLy8gUmV1c2UgYW55IGV4aXN0aW5nIHN5c21vZHVsZXMgdGhhdCB3ZSBwcmV2aW91c2x5IGZvdW5kLCBidXQgbm90IF9fbWFpbl9fIG1vZHVsZXNcbiAgICAgICAgdGhpcy5zeXNtb2R1bGVzID0gdGhpcy5jbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMoKTtcbiAgICAgICAgLy8gSG9ycmlmaWMgaGFjaywgdG8gcHJldmVudCBUaWZhIGZyb20gY2FjaGluZyBhIGJhZCB2ZXJzaW9uIG9mIHRoZSBzdHVkZW50cycgaW1wb3J0XG4gICAgICAgIFNrLmNsZWFyRXhpc3RpbmdTdHVkZW50SW1wb3J0cyA9IHRoaXMuY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nU3R1ZGVudEltcG9ydHMoKSB7XG4gICAgICAgIGxldCBzeXNtb2R1bGVzID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLnN5c21vZHVsZXM7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgX19tYWluX18gbW9kdWxlc1xuICAgICAgICBpZiAoc3lzbW9kdWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBvZiB0aGlzLmdldEFsbEZpbGVuYW1lcygpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNrRmlsZW5hbWUgPSBuZXcgU2suYnVpbHRpbi5zdHIoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIC8qaWYgKHN5c21vZHVsZXMucXVpY2skbG9va3VwKHNrRmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5c21vZHVsZXMucG9wJGl0ZW0oc2tGaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICAgc3lzbW9kdWxlcy5wb3AkaXRlbShza0ZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3lzbW9kdWxlcztcbiAgICB9XG5cbiAgICBnZXRBbGxTdHVkZW50RmlsZXMoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0ge1xuICAgICAgICAgICAgXCJhbnN3ZXIucHlcIjogdGhpcy5tYWluLm1vZGVsLnVpLmZpbGVzLmdldFN0dWRlbnRDb2RlKClcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2tpcCBzcGVjaWFsIGluc3RydWN0b3IgZmlsZXNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFJbnN0cnVjdG9yRmlsZXMoKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXCIhXiQjXCIuaW5jbHVkZXMoZmlsZS5maWxlbmFtZSgpWzBdKSkpIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmaWxlLmZpbGVuYW1lKCldID0gY2hvbXBTcGVjaWFsRmlsZShmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5jbHVkZSBub3JtYWwgc3R1ZGVudCBleHRyYSBmaWxlc1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGZpbGVzW2ZpbGUuZmlsZW5hbWUoKV0gPSBmaWxlLmNvbnRlbnRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuXG4gICAgZ2V0QWxsRmlsZW5hbWVzKCkge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbihmaWxlbmFtZSkge1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBjaG9tcFNwZWNpYWxGaWxlKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWxlbmFtZS5lbmRzV2l0aChcIi5weVwiKSkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBcIl9fbWFpbl9fXCIsXG4gICAgICAgICAgICBcIl9pbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAuLi50aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpLm1hcChmaWxlID0+IFwiX2luc3RydWN0b3IuXCIgKyBjbGVhbihmaWxlLmZpbGVuYW1lKCkpKSxcbiAgICAgICAgICAgIC4uLnRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmV4dHJhRmlsZXMoKS5tYXAoZmlsZSA9PiBjbGVhbihmaWxlLmZpbGVuYW1lKCkpKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBnZXRUaW1lb3V0UHJvbXB0KGxvbmdUaW1lb3V0KSB7XG4gICAgICAgIGlmIChsb25nVGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIGluc3RydWN0b3IgY29kZSBoYXMgdGFrZW4gYSBSRUFMTFkgbG9uZyB0aW1lIHRvIGNoZWNrIHlvdXIgY29kZSAoMzAgb3IgbW9yZSBzZWNvbmRzKS4gWW91IG1pZ2h0IHdhbnQgdG8gY2FuY2VsIGFuZCBjaGVjayB5b3VyIGNvZGUgKG9yIGdldCBoZWxwIGZyb20gYW4gaW5zdHJ1Y3RvcikuIE9yLCB5b3UgY2FuIGFkZCBtb3JlIHNlY29uZHMgdG8gd2FpdCBiZWxvdy5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSBpbnN0cnVjdG9yIGNvZGUgaXMgdGFraW5nIGEgbGl0dGxlIHdoaWxlIHRvIGNoZWNrIHlvdXIgY29kZTsgaXQgbWlnaHQganVzdCBuZWVkIGEgbGl0dGxlIG1vcmUgdGltZS4gSG93IG1hbnkgbW9yZSBzZWNvbmRzIHdvdWxkIHlvdSBsaWtlIHRvIHdhaXQ/XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm1haW4uY29tcG9uZW50cy5maWxlU3lzdGVtLnNlYXJjaEZvckZpbGUoZmlsZW5hbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogXCIrZmlsZW5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSA9PT0gXCIuL2Fuc3dlci5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vX2luc3RydWN0b3Ivb25fcnVuLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vX2luc3RydWN0b3Ivb25fZXZhbC5weVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkgfHwgXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZSA9PT0gXCIuL19pbnN0cnVjdG9yL19faW5pdF9fLmpzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9NT0RVTEU7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJCdWlsdC1pbiBtb2R1bGVzIG5vdCBhY2Nlc3NpYmxlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6ICdcIitmaWxlbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5wdXQocHJvbXB0TWVzc2FnZSkge1xuICAgICAgICAvL3JldHVybiBcIkFwcGxlUGllXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4+XCIsIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKSwgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCkpO1xuICAgICAgICBpZiAodGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnB1dEluZGV4KCkgPCB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRJbmRleCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG5leHRJbnB1dCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQoKVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXRJbmRleChpbnB1dEluZGV4KzEpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHRJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIkFwcGxlUGllXCI7XG4gICAgICAgIH1cbiAgICAgICAgLypyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoU2sucXVldWVkSW5wdXQucG9wKCkpO1xuICAgICAgICB9KTsqL1xuICAgIH1cblxuICAgIGJlZm9yZUNhbGwoZnVuY3Rpb25OYW1lLCBwb3NhcmdzLCBrd2FyZ3MpIHtcbiAgICAgICAgbGV0IHN0dWRlbnRNb2RlbCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50O1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiSEVZIElOU1RSVUNUT1IgQ0FMTFwiLCBmdW5jdGlvbk5hbWUsIHN0dWRlbnRNb2RlbC50cmFjaW5nKTtcbiAgICAgICAgaWYgKHN0dWRlbnRNb2RlbC50cmFjaW5nICYmIHN0dWRlbnRNb2RlbC50cmFjaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgc3VwZXIuYmVmb3JlQ2FsbChmdW5jdGlvbk5hbWUsIHBvc2FyZ3MsIGt3YXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQge0luc3RydWN0b3JDb25maWd1cmF0aW9ufSBmcm9tIFwiLi9pbnN0cnVjdG9yXCI7XG5cbmV4cG9ydCBjbGFzcyBPbkNoYW5nZUNvbmZpZ3VyYXRpb24gZXh0ZW5kcyBJbnN0cnVjdG9yQ29uZmlndXJhdGlvbiB7XG4gICAgdXNlKGVuZ2luZSkge1xuICAgICAgICBzdXBlci51c2UoZW5naW5lKTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwib25fY2hhbmdlLnB5XCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uQ2hhbmdlKCk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnRyaWdnZXJPbkNoYW5nZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSIsImltcG9ydCB7SW5zdHJ1Y3RvckNvbmZpZ3VyYXRpb259IGZyb20gXCIuL2luc3RydWN0b3JcIjtcbmltcG9ydCB7U3RhdHVzU3RhdGV9IGZyb20gXCIuLi9zZXJ2ZXJcIjtcbmltcG9ydCB7ZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQsIElOU1RSVUNUT1JfTUFSS0VSLCBORVdfTElORV9SRUdFWH0gZnJvbSBcIi4vb25fcnVuXCI7XG5pbXBvcnQge2luZGVudH0gZnJvbSBcIi4uL3V0aWxpdGllc1wiO1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFdSQVBfSU5TVFJVQ1RPUl9DT0RFID0gZnVuY3Rpb24gKHN0dWRlbnRDb2RlLCBpbnN0cnVjdG9yQ29kZSwgcXVpY2ssIGlzU2FmZSkge1xuICAgIGxldCBzYWZlQ29kZSA9IEpTT04uc3RyaW5naWZ5KHN0dWRlbnRDb2RlKTtcblxuICAgIHJldHVybiBgXG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcblxuIyBMb2FkIGluIHNvbWUgY29tbW9ubHkgdXNlZCB0b29sc1xuZnJvbSBwZWRhbC5jYWl0LmNhaXRfYXBpIGltcG9ydCBwYXJzZV9wcm9ncmFtXG5mcm9tIHBlZGFsLnNhbmRib3guY29tbWFuZHMgaW1wb3J0ICpcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgKlxuXG4jIEJhY2t1cCB0aGUgZmVlZGJhY2tcbm9uX3J1bl9mZWVkYmFjayA9IFtdXG5mb3IgZmVlZGJhY2sgaW4gTUFJTl9SRVBPUlQuZmVlZGJhY2s6XG4gICAgb25fcnVuX2ZlZWRiYWNrLmFwcGVuZChmZWVkYmFjaylcbk1BSU5fUkVQT1JULmZlZWRiYWNrLmNsZWFyKClcblxuZnJvbSBwZWRhbC5lbnZpcm9ubWVudHMuYmxvY2tweSBpbXBvcnQgc2V0dXBfZW52aXJvbm1lbnRcbiMgQWRkIGluIGV2YWx1YXRlZCBzdHVmZiBmcm9tIGxhc3QgdGltZVxuc3R1ZGVudCA9IGdldF9zYW5kYm94KClcbiMgVE9ETzogV2hhdCBhYm91dCBuZXcgaW5wdXRzIHNpbmNlIHdlIGxhc3QgcmFuL2V2YWxlZD9cbiMgTUFJTl9SRVBPUlQuc3VibWlzc2lvbi5maWxlc1snZXZhbHVhdGlvbiddID0gJHtzYWZlQ29kZX1cbmV2YWx1YXRlKCR7c2FmZUNvZGV9WydldmFsdWF0aW9uJ10pXG5cbiMgVE9ETzogUmVmYWN0b3IgcmVzb2x2ZXIgdG8gcmV0dXJuIGluc3RydWN0aW9uc1xuIyBNb25rZXktcGF0Y2ggcXVlc3Rpb25zXG4jZnJvbSBwZWRhbCBpbXBvcnQgcXVlc3Rpb25zXG4jcXVlc3Rpb25zLnNob3dfcXVlc3Rpb24gPSBzZXRfaW5zdHJ1Y3Rpb25zXG5cbiR7SU5TVFJVQ1RPUl9NQVJLRVJ9XG4ke2luc3RydWN0b3JDb2RlfVxuXG4jIFJlc29sdmUgZXZlcnl0aGluZ1xuZnJvbSBwZWRhbC5yZXNvbHZlcnMuc2ltcGxlIGltcG9ydCByZXNvbHZlXG5maW5hbCA9IHJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuIyBIYW5kbGUgcXVlc3Rpb25zXG5pZiBmaW5hbC5pbnN0cnVjdGlvbnM6XG4gICAgc2V0X2luc3RydWN0aW9ucyhmaW5hbC5pbnN0cnVjdGlvbnNbLTFdLm1lc3NhZ2UpXG4gICAgXG4jIEhhbmRsZSBwb3NpdGl2ZSBmZWVkYmFja1xuUE9TSVRJVkUgPSBbXVxuZm9yIHBvc2l0aXZlIGluIGZpbmFsLnBvc2l0aXZlczpcbiAgICBtZXNzYWdlID0gcG9zaXRpdmUubWVzc2FnZVxuICAgIGlmIG5vdCBwb3NpdGl2ZTpcbiAgICAgICAgbWVzc2FnZSA9IHBvc2l0aXZlLmVsc2VfbWVzc2FnZVxuICAgIFBPU0lUSVZFLmFwcGVuZCh7XG4gICAgICAgIFwidGl0bGVcIjogcG9zaXRpdmUudGl0bGUsXG4gICAgICAgIFwibGFiZWxcIjogcG9zaXRpdmUubGFiZWwsXG4gICAgICAgIFwibWVzc2FnZVwiOiBtZXNzYWdlXG4gICAgfSlcbiAgICBcbiMgSGFuZGxlIHN5c3RlbSBtZXNzYWdlc1xuZm9yIHN5c3RlbSBpbiBmaW5hbC5zeXN0ZW1zOlxuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnbG9nJzpcbiAgICAgICAgY29uc29sZV9sb2coc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG4gICAgaWYgc3lzdGVtLmxhYmVsID09ICdkZWJ1Zyc6XG4gICAgICAgIGNvbnNvbGVfZGVidWcoc3lzdGVtLnRpdGxlLCBzeXN0ZW0ubWVzc2FnZSk7XG5cbmA7XG59O1xuXG5leHBvcnQgY2xhc3MgT25FdmFsQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ldmFsXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbCgpIHx8IFwiXCI7XG5cbiAgICAgICAgbGV0IGRpc2FibGVUaWZhID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGlzYWJsZVRpZmEoKTtcblxuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICAvL2xldCBzdHVkZW50Q29kZVNhZmUgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuc3R1ZGVudC5ldmFsdWF0aW9uIHx8IFwiTm9uZVwiO1xuICAgICAgICBsZXQgc3R1ZGVudEZpbGVzID0gdGhpcy5nZXRBbGxTdHVkZW50RmlsZXMoKTtcbiAgICAgICAgc3R1ZGVudEZpbGVzW1wiZXZhbHVhdGlvblwiXSA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cy5zdHVkZW50LmV2YWx1YXRpb24gfHwgXCJOb25lXCI7XG4gICAgICAgIHRoaXMuZHVtbXlPdXRTYW5kYm94KCk7XG4gICAgICAgIGxldCBpbnN0cnVjdG9yQ29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgbGV0IGlzU2FmZSA9ICFyZXBvcnRbXCJwYXJzZXJcIl0uZW1wdHkgJiYgcmVwb3J0W1widmVyaWZpZXJcIl0uc3VjY2VzcztcbiAgICAgICAgaW5zdHJ1Y3RvckNvZGUgPSBXUkFQX0lOU1RSVUNUT1JfQ09ERShzdHVkZW50RmlsZXMsIGluc3RydWN0b3JDb2RlLCBkaXNhYmxlVGlmYSwgaXNTYWZlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCI+Pj5cIiwgaW5zdHJ1Y3RvckNvZGUpO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKTsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICByZXBvcnRbXCJpbnN0cnVjdG9yXCJdID0ge1xuICAgICAgICAgICAgXCJjb21wbGltZW50c1wiOiBbXSxcbiAgICAgICAgICAgIFwiZmlsZW5hbWVcIjogXCIuL19pbnN0cnVjdG9yL29uX2V2YWwucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29kZSA9IGluc3RydWN0b3JDb2RlO1xuXG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIC8vU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuICAgICAgICBTay5nbG9iYWxzID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPbkV2YWwgc3VjY2Vzc1wiKTtcbiAgICAgICAgLy8gVE9ETzogQWN0dWFsbHkgcGFyc2UgcmVzdWx0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3IuZ2xvYmFscyA9IFNrLmdsb2JhbHM7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5zdHJ1Y3Rvci5zeXNtb2R1bGVzID0gU2suc3lzbW9kdWxlcztcbiAgICAgICAgY29uc29sZS5sb2cobW9kdWxlKTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtb2R1bGUuJGQub25fZXZhbC4kZDtcbiAgICAgICAgY29uc29sZS5sb2cobW9kdWxlLiRkKTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudEZlZWRiYWNrKHJlc3VsdHMpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHNbXCJpbnN0cnVjdG9yXCJdW1wic3VjY2Vzc1wiXSA9IHRydWU7XG4gICAgICAgIGxldCBzdWNjZXNzID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLlNVQ0NFU1MpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KHN1Y2Nlc3MgfHwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29ycmVjdCgpKTtcbiAgICAgICAgLy8gQ2Fubm90IGV4Y2VlZCAxIHBvaW50LCBjYW5ub3QgZ28gYmVsb3cgMCBwb2ludHNcbiAgICAgICAgbGV0IHNjb3JlID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLlNDT1JFKTtcbiAgICAgICAgc2NvcmUgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgc2NvcmUpKTtcbiAgICAgICAgbGV0IG9sZFNjb3JlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoTWF0aC5tYXgob2xkU2NvcmUsIHNjb3JlKSk7XG4gICAgICAgIC8vIEhpZGUgc3RhdHVzXG4gICAgICAgIGxldCBoaWRlID0gU2suZmZpLnJlbWFwVG9KcyhyZXN1bHRzLkhJREUpO1xuICAgICAgICAvLyBBbmQgZmlyZSB0aGUgcmVzdWx0IVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIudXBkYXRlU3VibWlzc2lvbihzY29yZSwgc3VjY2VzcywgaGlkZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgLy9hZnRlcihtb2R1bGUpO1xuXG4gICAgICAgIC8qaWYgKHN1Y2Nlc3MgJiYgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmlkKCkpO1xuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoIVNrLmV4ZWN1dGlvblJlcG9ydHMuaW5zdHJ1Y3Rvci5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuY29uc29sZS5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk9uRXZhbCBmYWlsdXJlXCIsIGVycm9yKTtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgaWYgKGVycm9yLnRwJG5hbWUgPT09IFwiR3JhY2VmdWxFeGl0XCIpIHtcbiAgICAgICAgICAgIHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdGF0dXMub25FeGVjdXRpb24oU3RhdHVzU3RhdGUuUkVBRFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5GQUlMRUQpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wiY29kZVwiXSk7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50SW50ZXJuYWxFcnJvcihlcnJvciwgdGhpcy5maWxlbmFtZSk7XG4gICAgICAgICAgICAvL3JlcG9ydFtcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gZmFsc2U7XG4gICAgICAgICAgICAvL3JlcG9ydFtcImluc3RydWN0b3JcIl1bXCJlcnJvclwiXSA9IGVycm9yO1xuICAgICAgICAgICAgLy9UT0RPOiByZXBvcnRbXCJpbnN0cnVjdG9yXCJdW1wibGluZV9vZmZzZXRcIl0gPSBsaW5lT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vVE9ETzogYWZ0ZXIoZXJyb3IpO1xuICAgIH1cbn0iLCJpbXBvcnQge2luZGVudH0gZnJvbSBcIi4uL3V0aWxpdGllc1wiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuaW1wb3J0IHtJbnN0cnVjdG9yQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vaW5zdHJ1Y3RvclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZEFjdHVhbEluc3RydWN0b3JPZmZzZXQoaW5zdHJ1Y3RvckNvZGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0b3JDb2RlLmluZGV4T2YoSU5TVFJVQ1RPUl9NQVJLRVIpO1xuICAgIGNvbnN0IGJlZm9yZSA9IGluc3RydWN0b3JDb2RlLnNsaWNlKDAsIGluZGV4KTtcbiAgICBjb25zdCBtYXRjaCA9IGJlZm9yZS5tYXRjaChORVdfTElORV9SRUdFWCk7XG4gICAgcmV0dXJuIG1hdGNoID8gKDErbWF0Y2gubGVuZ3RoKSA6IDA7XG59XG5cbmV4cG9ydCBjb25zdCBJTlNUUlVDVE9SX01BUktFUiA9IFwiIyMjUnVuIHRoZSBhY3R1YWwgaW5zdHJ1Y3RvciBjb2RlIyMjXCI7XG5leHBvcnQgY29uc3QgTkVXX0xJTkVfUkVHRVggPSAvXFxuL2c7XG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFdSQVBfSU5TVFJVQ1RPUl9DT0RFID0gZnVuY3Rpb24gKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIHF1aWNrLCBpc1NhZmUpIHtcbiAgICBsZXQgc2FmZUNvZGUgPSBKU09OLnN0cmluZ2lmeShzdHVkZW50RmlsZXMpO1xuICAgIGxldCBza2lwX3RpZmEgPSBxdWljayA/IFwiVHJ1ZVwiOiBcIkZhbHNlXCI7XG5cbiAgICAvLyBUT0RPOiBBZGQgaW4gU2sucXVldWVkSW5wdXQgdG8gYmUgcGFzc2VkIGluXG5cbiAgICByZXR1cm4gYFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbmZyb20gcGVkYWwuY29yZS5yZXBvcnQgaW1wb3J0IE1BSU5fUkVQT1JUXG5NQUlOX1JFUE9SVC5jbGVhcigpXG5cbmZyb20gY2lzYzEwOCBpbXBvcnQgc3R1ZGVudF90ZXN0c1xuc3R1ZGVudF90ZXN0cy5yZXNldCgpXG5cbmZyb20gdXRpbGl0eSBpbXBvcnQgKlxuXG4jIExvYWQgaW4gc29tZSBjb21tb25seSB1c2VkIHRvb2xzXG5mcm9tIHBlZGFsLmNhaXQuY2FpdF9hcGkgaW1wb3J0IHBhcnNlX3Byb2dyYW1cbmZyb20gcGVkYWwuc2FuZGJveC5jb21tYW5kcyBpbXBvcnQgKlxuZnJvbSBwZWRhbC5jb3JlLmNvbW1hbmRzIGltcG9ydCAqXG5cbmZyb20gcGVkYWwuZW52aXJvbm1lbnRzLmJsb2NrcHkgaW1wb3J0IHNldHVwX2Vudmlyb25tZW50XG4jIERvIHdlIGV4ZWN1dGUgc3R1ZGVudCdzIGNvZGU/XG5za2lwX3J1biA9IGdldF9tb2RlbF9pbmZvKCdhc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVJbnN0cnVjdG9yUnVuJylcbmlucHV0cyA9IE5vbmUgaWYgc2tpcF9ydW4gZWxzZSBnZXRfbW9kZWxfaW5mbygnZXhlY3V0aW9uLmlucHV0JylcblxuIyBTZXQgdGhlIHNlZWQgdG8gdGhlIHN1Ym1pc3Npb24gSUQgYnkgZGVmYXVsdD9cbmZyb20gcGVkYWwucXVlc3Rpb25zIGltcG9ydCBzZXRfc2VlZFxuc2V0X3NlZWQoc3RyKGdldF9tb2RlbF9pbmZvKFwic3VibWlzc2lvbi5pZFwiKSkpXG5cbiMgSW5pdGlhbGl6ZSB0aGUgQmxvY2tQeSBlbnZpcm9ubWVudFxucGVkYWwgPSBzZXR1cF9lbnZpcm9ubWVudChza2lwX3RpZmE9JHtza2lwX3RpZmF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwX3J1bj1za2lwX3J1bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzPWlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9maWxlPSdhbnN3ZXIucHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcz0ke3NhZmVDb2RlfSlcbnN0dWRlbnQgPSBwZWRhbC5maWVsZHNbJ3N0dWRlbnQnXVxuXG4jIFRPRE86IFJlZmFjdG9yIHJlc29sdmVyIHRvIHJldHVybiBpbnN0cnVjdGlvbnNcbiMgTW9ua2V5LXBhdGNoIHF1ZXN0aW9uc1xuI2Zyb20gcGVkYWwgaW1wb3J0IHF1ZXN0aW9uc1xuI3F1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuXG4ke0lOU1RSVUNUT1JfTUFSS0VSfVxuJHtpbnN0cnVjdG9yQ29kZX1cblxuIyBSZXNvbHZlIGV2ZXJ5dGhpbmdcbmZyb20gcGVkYWwucmVzb2x2ZXJzLnNpbXBsZSBpbXBvcnQgcmVzb2x2ZVxuZmluYWwgPSByZXNvbHZlKClcblNVQ0NFU1MgPSBmaW5hbC5zdWNjZXNzXG5TQ09SRSA9IGZpbmFsLnNjb3JlXG5DQVRFR09SWSA9IGZpbmFsLmNhdGVnb3J5XG5MQUJFTCA9IGZpbmFsLnRpdGxlXG5NRVNTQUdFID0gZmluYWwubWVzc2FnZVxuREFUQSA9IGZpbmFsLmRhdGFcbkhJREUgPSBmaW5hbC5oaWRlX2NvcnJlY3RuZXNzXG5cbiMgSGFuZGxlIHF1ZXN0aW9uc1xuaWYgZmluYWwuaW5zdHJ1Y3Rpb25zOlxuICAgIHNldF9pbnN0cnVjdGlvbnMoZmluYWwuaW5zdHJ1Y3Rpb25zWy0xXS5tZXNzYWdlKVxuICAgIFxuIyBIYW5kbGUgcG9zaXRpdmUgZmVlZGJhY2tcblBPU0lUSVZFID0gW11cbmZvciBwb3NpdGl2ZSBpbiBmaW5hbC5wb3NpdGl2ZXM6XG4gICAgbWVzc2FnZSA9IHBvc2l0aXZlLm1lc3NhZ2VcbiAgICBpZiBub3QgcG9zaXRpdmU6XG4gICAgICAgIG1lc3NhZ2UgPSBwb3NpdGl2ZS5lbHNlX21lc3NhZ2VcbiAgICBQT1NJVElWRS5hcHBlbmQoe1xuICAgICAgICBcInRpdGxlXCI6IHBvc2l0aXZlLnRpdGxlLFxuICAgICAgICBcImxhYmVsXCI6IHBvc2l0aXZlLmxhYmVsLFxuICAgICAgICBcIm1lc3NhZ2VcIjogbWVzc2FnZVxuICAgIH0pXG4gICAgXG4jIEhhbmRsZSBzeXN0ZW0gbWVzc2FnZXNcbmZvciBzeXN0ZW0gaW4gZmluYWwuc3lzdGVtczpcbiAgICBpZiBzeXN0ZW0ubGFiZWwgPT0gJ2xvZyc6XG4gICAgICAgIGNvbnNvbGVfbG9nKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuICAgIGlmIHN5c3RlbS5sYWJlbCA9PSAnZGVidWcnOlxuICAgICAgICBjb25zb2xlX2RlYnVnKHN5c3RlbS50aXRsZSwgc3lzdGVtLm1lc3NhZ2UpO1xuXG5gO1xufTtcblxuZXhwb3J0IGNsYXNzIE9uUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIEluc3RydWN0b3JDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJfaW5zdHJ1Y3Rvci5vbl9ydW5cIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICBsZXQgZGlzYWJsZVRpZmEgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGlmYSgpO1xuICAgICAgICAvLyBQdXQgdGhlIGlucHV0IGluZGV4IGJhY2sgdG8gdGhlIGZyb250LCBzbyB3ZSBjYW4gcmVwbGF5IGlucHV0c1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0SW5kZXgoMSk7XG5cbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgLy9sZXQgc3R1ZGVudENvZGVTYWZlID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpO1xuICAgICAgICBsZXQgc3R1ZGVudEZpbGVzID0gdGhpcy5nZXRBbGxTdHVkZW50RmlsZXMoKTtcbiAgICAgICAgdGhpcy5kdW1teU91dFNhbmRib3goKTtcbiAgICAgICAgbGV0IGluc3RydWN0b3JDb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICBsZXQgaXNTYWZlID0gIXJlcG9ydFtcInBhcnNlclwiXS5lbXB0eSAmJiByZXBvcnRbXCJ2ZXJpZmllclwiXS5zdWNjZXNzO1xuICAgICAgICBpbnN0cnVjdG9yQ29kZSA9IFdSQVBfSU5TVFJVQ1RPUl9DT0RFKHN0dWRlbnRGaWxlcywgaW5zdHJ1Y3RvckNvZGUsIGRpc2FibGVUaWZhLCBpc1NhZmUpO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IGZpbmRBY3R1YWxJbnN0cnVjdG9yT2Zmc2V0KGluc3RydWN0b3JDb2RlKTsgLy9pbnN0cnVjdG9yQ29kZS5zcGxpdChORVdfTElORV9SRUdFWCkubGVuZ3RoO1xuICAgICAgICAvL2xpbmVPZmZzZXQgPSAwOyAvL2luc3RydWN0b3JDb2RlLnNwbGl0KE5FV19MSU5FX1JFR0VYKS5sZW5ndGggLSBsaW5lT2Zmc2V0IC0gNDtcbiAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXSA9IHtcbiAgICAgICAgICAgIFwiY29tcGxpbWVudHNcIjogW10sXG4gICAgICAgICAgICBcImZpbGVuYW1lXCI6IFwiLi9faW5zdHJ1Y3Rvci9vbl9ydW4ucHlcIixcbiAgICAgICAgICAgIFwiY29kZVwiOiBpbnN0cnVjdG9yQ29kZSxcbiAgICAgICAgICAgIFwibGluZU9mZnNldFwiOiBsaW5lT2Zmc2V0XG4gICAgICAgICAgICAvLydjb21wbGV0ZSc6IGZhbHNlIC8vIEFjdHVhbGx5LCBsZXQncyB1c2UgdW5kZWZpbmVkIGZvciBub3cuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2RlID0gaW5zdHJ1Y3RvckNvZGU7XG5cbiAgICAgICAgU2sucmV0YWluR2xvYmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MobW9kdWxlKSB7XG4gICAgICAgIC8vIFRPRE8gTG9nZ2luZyEhISFcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk9uUnVuIHN1Y2Nlc3NcIik7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IHBhcnNlIHJlc3VsdHNcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5pbnN0cnVjdG9yLmdsb2JhbHMgPSBTay5nbG9iYWxzO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmluc3RydWN0b3Iuc3lzbW9kdWxlcyA9IFNrLnN5c21vZHVsZXM7XG4gICAgICAgIFNrLmdsb2JhbHMgPSB7fTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtb2R1bGUuJGQub25fcnVuLiRkO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5wcmVzZW50RmVlZGJhY2socmVzdWx0cyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0c1tcImluc3RydWN0b3JcIl1bXCJzdWNjZXNzXCJdID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU1VDQ0VTUyk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvcnJlY3Qoc3VjY2VzcyB8fCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb3JyZWN0KCkpO1xuICAgICAgICAvLyBDYW5ub3QgZXhjZWVkIDEgcG9pbnQsIGNhbm5vdCBnbyBiZWxvdyAwIHBvaW50c1xuICAgICAgICBsZXQgc2NvcmUgPSBTay5mZmkucmVtYXBUb0pzKHJlc3VsdHMuU0NPUkUpO1xuICAgICAgICBzY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNjb3JlKSk7XG4gICAgICAgIGxldCBvbGRTY29yZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLnNjb3JlKCk7XG4gICAgICAgIHNjb3JlID0gTWF0aC5tYXgob2xkU2NvcmUsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uc2NvcmUoc2NvcmUpO1xuICAgICAgICAvLyBIaWRlIHN0YXR1c1xuICAgICAgICBsZXQgaGlkZSA9IFNrLmZmaS5yZW1hcFRvSnMocmVzdWx0cy5ISURFKTtcbiAgICAgICAgLy8gQW5kIGZpcmUgdGhlIHJlc3VsdCFcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLnVwZGF0ZVN1Ym1pc3Npb24oc2NvcmUsIHN1Y2Nlc3MsIGhpZGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIC8vYWZ0ZXIobW9kdWxlKTtcblxuICAgICAgICAvKmlmIChzdWNjZXNzICYmIHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmNhbGxiYWNrcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jYWxsYmFja3Muc3VjY2Vzcyh0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pZCgpKTtcbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKCFTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk9uUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAoZXJyb3IudHAkbmFtZSA9PT0gXCJHcmFjZWZ1bEV4aXRcIikge1xuICAgICAgICAgICAgcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJjb2RlXCJdKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmZlZWRiYWNrLnByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCB0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcInN1Y2Nlc3NcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vcmVwb3J0W1wiaW5zdHJ1Y3RvclwiXVtcImVycm9yXCJdID0gZXJyb3I7XG4gICAgICAgICAgICAvL1RPRE86IHJlcG9ydFtcImluc3RydWN0b3JcIl1bXCJsaW5lX29mZnNldFwiXSA9IGxpbmVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOiBhZnRlcihlcnJvcik7XG4gICAgfVxufVxuXG5cbi8qXG4jIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG9sZCBpbnN0cnVjdG9yIGNvZGUsIGxlYXZpbmcgaXQgaGVyZSBmb3Igbm93LlxuXG5mcm9tIHBlZGFsLmNvcmUucmVwb3J0IGltcG9ydCBNQUlOX1JFUE9SVFxuIyBTdXBwb3J0IG91ciBzeXNtb2R1bGVzIGhhY2sgYnkgY2xlYXJpbmcgb3V0IGFueSBsaW5nZXJpbmcgb2xkIGRhdGFcbk1BSU5fUkVQT1JULmNsZWFyKClcbmZyb20gcGVkYWwuY29yZS5jb21tYW5kcyBpbXBvcnQgY29udGV4dHVhbGl6ZV9yZXBvcnRcbmNvbnRleHR1YWxpemVfcmVwb3J0KCR7c2FmZUNvZGV9LCBcImFuc3dlci5weVwiKVxuJHt0aWZhQW5hbHlzaXN9XG5mcm9tIHBlZGFsLnNhbmRib3guc2FuZGJveCBpbXBvcnQgU2FuZGJveFxuZnJvbSBwZWRhbC5zYW5kYm94IGltcG9ydCBjb21wYXRpYmlsaXR5XG5mcm9tIHV0aWxpdHkgaW1wb3J0ICpcbnN0dWRlbnQgPSBNQUlOX1JFUE9SVFsnc2FuZGJveCddWydydW4nXSA9IFNhbmRib3goKVxuc3R1ZGVudC5yZXBvcnRfZXhjZXB0aW9uc19tb2RlID0gVHJ1ZVxubG9nKGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbnN0dWRlbnQuc2V0X2lucHV0KGdldF9tb2RlbF9pbmZvKCdleGVjdXRpb24uaW5wdXQnKSlcbmlmIG5vdCBnZXRfbW9kZWxfaW5mbygnYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlSW5zdHJ1Y3RvclJ1bicpOlxuICAgIGNvbXBhdGliaWxpdHkucnVuX3N0dWRlbnQocmFpc2VfZXhjZXB0aW9ucz1GYWxzZSlcbiNsb2coc3R1ZGVudC5kYXRhKVxuI3N0dWRlbnQgPSBnZXRfc3R1ZGVudF9kYXRhKClcbiNlcnJvciwgcG9zaXRpb24gPSBnZXRfc3R1ZGVudF9lcnJvcigpXG4jY29tcGF0aWJpbGl0eS5yYWlzZV9leGNlcHRpb24oZXJyb3IsIHBvc2l0aW9uKVxucnVuX3N0dWRlbnQgPSBjb21wYXRpYmlsaXR5LnJ1bl9zdHVkZW50XG5yZXNldF9vdXRwdXQgPSBjb21wYXRpYmlsaXR5LnJlc2V0X291dHB1dFxucXVldWVfaW5wdXQgPSBjb21wYXRpYmlsaXR5LnF1ZXVlX2lucHV0XG5nZXRfb3V0cHV0ID0gY29tcGF0aWJpbGl0eS5nZXRfb3V0cHV0XG5nZXRfcGxvdHMgPSBjb21wYXRpYmlsaXR5LmdldF9wbG90c1xuY29tcGF0aWJpbGl0eS50cmFjZV9saW5lcyA9IHRyYWNlX2xpbmVzXG5mcm9tIHBlZGFsIGltcG9ydCBxdWVzdGlvbnNcbnF1ZXN0aW9ucy5zaG93X3F1ZXN0aW9uID0gc2V0X2luc3RydWN0aW9uc1xuIyBUT0RPOiBSZW1vdmUgdGhlIG5lZWQgZm9yIHRoaXMgaGFjayFcbmRlZiBjYXB0dXJlX291dHB1dChmdW5jLCAqYXJncyk6XG4gICByZXNldF9vdXRwdXQoKVxuICAgc3R1ZGVudC5jYWxsKGZ1bmMuX19uYW1lX18sICphcmdzKVxuICAgcmV0dXJuIGdldF9vdXRwdXQoKVxuY29tcGF0aWJpbGl0eS5jYXB0dXJlX291dHB1dCA9IGNhcHR1cmVfb3V0cHV0XG5cbmZyb20gcGVkYWwuY2FpdC5jYWl0X2FwaSBpbXBvcnQgcGFyc2VfcHJvZ3JhbVxuJHtpbnN0cnVjdG9yQ29kZX1cbmZyb20gcGVkYWwucmVzb2x2ZXJzIGltcG9ydCBzaW1wbGVcbmZpbmFsID0gc2ltcGxlLnJlc29sdmUoKVxuU1VDQ0VTUyA9IGZpbmFsLnN1Y2Nlc3NcblNDT1JFID0gZmluYWwuc2NvcmVcbkNBVEVHT1JZID0gZmluYWwuY2F0ZWdvcnlcbkxBQkVMID0gZmluYWwudGl0bGVcbk1FU1NBR0UgPSBmaW5hbC5tZXNzYWdlXG5EQVRBID0gZmluYWwuZGF0YVxuSElERSA9IGZpbmFsLmhpZGVfY29ycmVjdG5lc3NcblxuICovIiwiaW1wb3J0IHtPblJ1bkNvbmZpZ3VyYXRpb259IGZyb20gXCIuL29uX3J1blwiO1xuXG5leHBvcnQgY2xhc3MgT25TYW1wbGVDb25maWd1cmF0aW9uIGV4dGVuZHMgT25SdW5Db25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gXCJvbl9ydW4ucHlcIjtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW4oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuaW1wb3J0IHtTdGF0dXNTdGF0ZX0gZnJvbSBcIi4uL3NlcnZlclwiO1xuXG5leHBvcnQgY2xhc3MgUnVuQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subWVzc2FnZShcIlJ1bm5pbmcuLi5cIik7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBcImFuc3dlclwiO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwudWkuZmlsZXMuZ2V0U3R1ZGVudENvZGUoKTtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmRpc2FibGVTdHVkZW50UnVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmNvZGUgPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5zYXZlRmlsZShcImFuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCksIG51bGwpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJDb21waWxlXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuY29kZSk7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuXG4gICAgICAgIGVuZ2luZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnNlKCk7XG5cbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzW1widmVyaWZpZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogQm9vbGVhbih0aGlzLmNvZGUudHJpbSgpKSxcbiAgICAgICAgICAgIFwiY29kZVwiOiB0aGlzLmNvZGVcbiAgICAgICAgfTtcblxuICAgICAgICBTay5yZXRhaW5HbG9iYWxzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3VjY2Vzcyhtb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBcImlucHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0KCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgICAgIFwib3V0cHV0c1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLm91dHB1dCgpLm1hcChsaW5lID0+IGxpbmUuY29udGVudCkuam9pbihcIlxcblwiKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiUnVuLlByb2dyYW1cIiwgXCJcIiwgXCJcIiwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYW5zd2VyLnB5XCIpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24oZmFsc2UpO1xuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmZpbmlzaFR1cnRsZXMoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1cy5vbkV4ZWN1dGlvbihTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5nbG9iYWxzKFNrLmdsb2JhbHMpO1xuICAgICAgICBTay5nbG9iYWxzID0ge307XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uc3R1ZGVudC5yZXN1bHRzID0gbW9kdWxlO1xuICAgICAgICBpZiAoIXRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzLmhpZGVFdmFsdWF0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5jb25zb2xlLmJlZ2luRXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAobW9kdWxlLiRkLCBtb2R1bGUuJGQsLTEsIDAsIGZpbGVuYW1lICsgXCIucHlcIik7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdGVwKCk7XG4gICAgICAgICAgICByZXBvcnRbXCJzdHVkZW50XCJdID0ge1xuICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHJhY2VcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLm1hcCh4ID0+IHgubGluZSksXG4gICAgICAgICAgICAgICAgXCJyZWFsTGluZXNcIjogdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLmZpbHRlcih4ID0+ICF4LmlzRG9jc3RyaW5nKS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVzdWx0c1wiOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5vdXRwdXQsXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgIFwiY2FsbHNcIjogdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5zdHVkZW50LmNhbGxzLFxuICAgICAgICAgICAgICAgIFwidHJhY2luZ1wiOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUnVuIGZhaWx1cmVcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzLm9uRXhlY3V0aW9uKFN0YXR1c1N0YXRlLkZBSUxFRCk7XG4gICAgICAgIGxldCByZXBvcnQgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHM7XG4gICAgICAgIGlmIChyZXBvcnQucGFyc2VyLnN1Y2Nlc3MgJiYgcmVwb3J0LnZlcmlmaWVyLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIkNvbXBpbGUuRXJyb3JcIiwgXCJcIiwgXCJcIiwgZXJyb3IudG9TdHJpbmcoKSwgXCJhbnN3ZXIucHlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJSdW4uUHJvZ3JhbVwiLCBcIlByb2dyYW1FcnJvck91dHB1dFwiLCBcIlwiLCBlcnJvci50b1N0cmluZygpLCBcImFuc3dlci5weVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVwb3J0W1wic3R1ZGVudFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiOiBlcnJvcixcbiAgICAgICAgICAgICAgICBcImxpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5tYXAoeCA9PiB4LmxpbmUpLFxuICAgICAgICAgICAgICAgIFwicmVhbExpbmVzXCI6IHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci50cmFjZS5maWx0ZXIoeCA9PiAheC5pc0RvY3N0cmluZykubWFwKHggPT4geC5saW5lKSxcbiAgICAgICAgICAgICAgICBcImlucHV0XCI6IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgXCJjYWxsc1wiOiB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnN0dWRlbnQuY2FsbHMsXG4gICAgICAgICAgICAgICAgXCJ0cmFjaW5nXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IHtTdHVkZW50Q29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc3R1ZGVudFwiO1xuXG5leHBvcnQgY2xhc3MgU2FtcGxlQ29uZmlndXJhdGlvbiBleHRlbmRzIFN0dWRlbnRDb25maWd1cmF0aW9uIHtcbiAgICB1c2UoZW5naW5lKSB7XG4gICAgICAgIHN1cGVyLnVzZShlbmdpbmUpO1xuICAgICAgICAvLyBUT0RPOiBGaXggdG8gYmUgdGhlIGN1cnJlbnQgc2FtcGxlIHN1Ym1pc3Npb25cbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IFwiYW5zd2VyLnB5XCI7XG4gICAgICAgIHRoaXMuY29kZSA9IFwicHJpbnQoJ05vdCByZWFkeSB5ZXQhJylcIjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59IiwiaW1wb3J0IHtDb25maWd1cmF0aW9uLCBFTVBUWV9NT0RVTEV9IGZyb20gXCIuL2NvbmZpZ3VyYXRpb25zXCI7XG5cbmV4cG9ydCBjbGFzcyBTdHVkZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIENvbmZpZ3VyYXRpb24ge1xuICAgIHVzZShlbmdpbmUpIHtcbiAgICAgICAgc3VwZXIudXNlKGVuZ2luZSk7XG4gICAgICAgIC8vIExpbWl0IGV4ZWN1dGlvbiB0byA0IHNlY29uZHNcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdGhpcy5tYWluLm1vZGVsLnNldHRpbmdzO1xuICAgICAgICBTay5leGVjTGltaXRGdW5jdGlvbiA9ICgpID0+XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5zZXR0aW5ncy5kaXNhYmxlVGltZW91dCgpID8gSW5maW5pdHkgOiA1MDAwO1xuICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAvLyBTdGVwcGVyISBFeGVjdXRlZCBhZnRlciBldmVyeSBzdGF0ZW1lbnQuXG4gICAgICAgIFNrLmFmdGVyU2luZ2xlRXhlY3V0aW9uID0gdGhpcy5zdGVwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gVW5tdXRlIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkubXV0ZVByaW50ZXIoZmFsc2UpO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZWFjaCBzdGVwXG4gICAgICAgIC8vIGFmdGVyU2luZ2xlRXhlY3V0aW9uXG5cbiAgICAgICAgU2suYnVpbHRpbkZpbGVzLmZpbGVzW1wic3JjL2xpYi91dGlsaXR5L19faW5pdF9fLmpzXCJdID0gRU1QVFlfTU9EVUxFO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG9wZW5GaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coZmlsZW5hbWUsIGZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChTay5idWlsdGluRmlsZXMgJiYgU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbkZpbGVzW1wiZmlsZXNcIl1bZmlsZW5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5PU0Vycm9yKFwiRmlsZSBub3QgZm91bmQ6IFwiICsgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmNvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbXBvcnRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9yYmlkZGVuKGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJGaWxlIG5vdCBhY2Nlc3NpYmxlOiAnXCIgKyBmaWxlbmFtZSArIFwiJ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lID09PSBcIi4vYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoU2suYnVpbHRpbkZpbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJCdWlsdC1pbiBtb2R1bGVzIG5vdCBhY2Nlc3NpYmxlLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtmaWxlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW2ZpbGVuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMubWFpbi5jb21wb25lbnRzLmZpbGVTeXN0ZW0uc2VhcmNoRm9yRmlsZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk9TRXJyb3IoXCJGaWxlIG5vdCBmb3VuZDogJ1wiK2ZpbGVuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuY29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0KHByb21wdE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbi5jb21wb25lbnRzLmNvbnNvbGUuaW5wdXQocHJvbXB0TWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaXNGb3JiaWRkZW4oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJzcmMvbGliL3V0aWxpdHkvXCIpIHx8XG4gICAgICAgICAgICBmaWxlbmFtZS5zdGFydHNXaXRoKFwic3JjL2xpYi9wZWRhbC9cIikgfHxcbiAgICAgICAgICAgIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCIuL19pbnN0cnVjdG9yL1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcIlN0ZXBzXCIgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY29kZSwgbWVhbnQgdG8gYmUgdXNlZCBhcyBhIGNhbGxiYWNrIHRvIHRoZSBTa3VscHRcbiAgICAgKiBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnbG9iYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGdsb2JhbCB2YXJpYWJsZXMgKFN0cmluZ3MpIHRvIHRoZWlyIFNrdWxwdCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIC0gSGFzaCB0aGF0IG1hcHMgdGhlIG5hbWVzIG9mIGxvY2FsIHZhcmlhYmxlcyAoU3RyaW5ncykgdG8gdGhlaXIgU2t1bHB0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lTnVtYmVyIC0gVGhlIGNvcnJlc3BvbmRpbmcgbGluZSBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbk51bWJlciAtIFRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBudW1iZXIgaW4gdGhlIHNvdXJjZSBjb2RlIHRoYXQgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaW5rIG9mIGl0IGFzIHRoZSBcIlhcIiBwb3NpdGlvbiB0byB0aGUgbGluZU51bWJlcidzIFwiWVwiIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBweXRob24gZmlsZSBiZWluZyBleGVjdXRlZCAoZS5nLiwgXCJfX21haW5fXy5weVwiKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRG9jc3RyaW5nIC0gV2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhY3R1YWwgbGluZSBvciBhIGRvY3N0cmluZy5cbiAgICAgKi9cbiAgICBzdGVwKGdsb2JhbHMsIGxvY2FscywgbGluZU51bWJlciwgY29sdW1uTnVtYmVyLCBmaWxlbmFtZSwgaXNEb2NzdHJpbmcsIGV4ZWNTdGFjaykge1xuICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgIGlmIChleGVjU3RhY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleGVjU3RhY2subWFwKChbbiwgb10pID0+IFtuLCB7Li4ub31dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcDtcbiAgICAgICAgICAgIGdsb2JhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMoey4uLmdsb2JhbHMsIC4uLmxvY2Fsc30pO1xuICAgICAgICAgICAgLy8gVE9ETzogVHJhY2UgbG9jYWwgdmFyaWFibGVzIHByb3Blcmx5XG4gICAgICAgICAgICAvL2xldCBsb2NhbHMgPSB0aGlzLm1haW4uY29tcG9uZW50cy50cmFjZS5wYXJzZUdsb2JhbHMobG9jYWxzKTtcbiAgICAgICAgICAgIC8vT2JqZWN0LmFzc2lnbihnbG9iYWxzLCBsb2NhbHMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic3RlcFwiOiBjdXJyZW50U3RlcCxcbiAgICAgICAgICAgICAgICBcImZpbGVuYW1lXCI6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIC8vJ2Jsb2NrJzogaGlnaGxpZ2h0TWFwW2xpbmVOdW1iZXItMV0sXG4gICAgICAgICAgICAgICAgXCJsaW5lXCI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiBnbG9iYWxzLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgXCJtb2R1bGVzXCI6IGdsb2JhbHMubW9kdWxlcyxcbiAgICAgICAgICAgICAgICBcImlzRG9jc3RyaW5nXCI6IGlzRG9jc3RyaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwID0gY3VycmVudFN0ZXAgKyAxO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgU2t1bHB0IGV4ZWN1dGlvbiB0byB0ZXJtaW5hdGUgdGhlIGV4ZWN1dGlvbkJ1ZmZlclxuICAgICAqIGFuZCBoYW5kIGl0IG9mZiB0byB0aGUgZXhlY3V0aW9uIHRyYWNlIGluIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBsYXN0U3RlcCgpIHtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb247XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZURhdGEodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnRyYWNlKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQuY3VycmVudFN0ZXAodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLnN0ZXApO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5sYXN0U3RlcCh0aGlzLmVuZ2luZS5leGVjdXRpb25CdWZmZXIuc3RlcCk7XG4gICAgICAgIGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRMaW5lKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5saW5lKTtcbiAgICAgICAgZXhlY3V0aW9uLnN0dWRlbnQubGFzdExpbmUodGhpcy5lbmdpbmUuZXhlY3V0aW9uQnVmZmVyLmxpbmUpO1xuICAgICAgICBleGVjdXRpb24uc3R1ZGVudC5jdXJyZW50VHJhY2VTdGVwKHRoaXMuZW5naW5lLmV4ZWN1dGlvbkJ1ZmZlci5zdGVwKTtcbiAgICB9O1xuXG4gICAgZ2V0TGluZXMoYXN0KSB7XG4gICAgICAgIGxldCB2aXNpdGVkTGluZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB2aXNpdEJvZHkgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubGluZW5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkTGluZXMuYWRkKG5vZGUubGluZW5vKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvZHkuZm9yRWFjaCgoc3RhdGVtZW50KSA9PiB2aXNpdEJvZHkoc3RhdGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5vcmVsc2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLm9yZWxzZS5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHZpc2l0Qm9keShzdGF0ZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmZpbmFsYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZmluYWxib2R5LmZvckVhY2goKHN0YXRlbWVudCkgPT4gdmlzaXRCb2R5KHN0YXRlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2aXNpdEJvZHkoYXN0KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmlzaXRlZExpbmVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGUgcGFyc2UgaW5mb3JtYXRpb24gaXMgdXAtdG8tZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVBhcnNlKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICAvLyBIb2xkIGFsbCB0aGUgYWN0dWFsbHkgZGlzY292ZXJlZCBsaW5lcyBmcm9tIHRoZSBwYXJzZVxuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgLy8gQXR0ZW1wdCBhIHBhcnNlXG4gICAgICAgIGxldCBhc3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcGFyc2UgPSBTay5wYXJzZSh0aGlzLmZpbGVuYW1lLCB0aGlzLmNvZGUpO1xuICAgICAgICAgICAgYXN0ID0gU2suYXN0RnJvbVBhcnNlKHBhcnNlLmNzdCwgdGhpcy5maWxlbmFtZSwgcGFyc2UuZmxhZ3MpO1xuICAgICAgICAgICAgbGluZXMgPSB0aGlzLmdldExpbmVzKGFzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXBvcnQgdGhlIGVycm9yXG4gICAgICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZXJyb3IsXG4gICAgICAgICAgICAgICAgXCJlbXB0eVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibGluZXNcIjogbGluZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZmlsZW5hbWUsIHRoaXMuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3VjY2Vzc2Z1bCBwYXJzZVxuICAgICAgICByZXBvcnRbXCJwYXJzZXJcIl0gPSB7XG4gICAgICAgICAgICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiYXN0XCI6IGFzdCxcbiAgICAgICAgICAgIFwiZW1wdHlcIjogYXN0LmJvZHkubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgXCJsaW5lc1wiOiBsaW5lc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzaG93RXJyb3JzKCkge1xuICAgICAgICBsZXQgcmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzO1xuICAgICAgICBpZiAocmVwb3J0W1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5mZWVkYmFjay5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2sucHJlc2VudFJ1bkVycm9yKHJlcG9ydC5zdHVkZW50LmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3ZpZGVTZWNyZXRFcnJvcigpIHtcbiAgICAgICAgbGV0IHJlcG9ydCA9IHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24ucmVwb3J0cztcbiAgICAgICAgbGV0IGZlZWRiYWNrID0gdGhpcy5tYWluLmNvbXBvbmVudHMuZmVlZGJhY2s7XG4gICAgICAgIGlmICghcmVwb3J0W1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JCdXR0b24gPSB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LXN0dWRlbnQtZXJyb3JcIik7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGZlZWRiYWNrLnByZXNlbnRSdW5FcnJvcihyZXBvcnQuc3R1ZGVudC5lcnJvciwgdHJ1ZSk7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi5hdHRyKFwidGl0bGVcIiwgXCJDbGljayB0byBzZWUgT3JpZ2luYWwgRXJyb3JcIik7XG4gICAgICAgICAgICBlcnJvckJ1dHRvbi50b29sdGlwKHtcInRyaWdnZXJcIjogXCJob3ZlclwiLCBcImNvbnRhaW5lclwiOiB0aGlzLm1haW4ubW9kZWwuY29uZmlndXJhdGlvbi5hdHRhY2htZW50UG9pbnR9KTtcbiAgICAgICAgICAgIGVycm9yQnV0dG9uLmNsaWNrKCgpID0+IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9TSE9XX1NUVURFTlRfRVJST1IobWVzc2FnZSkpO1xuICAgICAgICAgICAgZXJyb3JCdXR0b24uc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxufSIsImV4cG9ydCBsZXQgRkVFREJBQ0tfSFRNTCA9IGBcblxuPHNwYW4gY2xhc3M9J2Jsb2NrcHktZmxvYXRpbmctZmVlZGJhY2sgdGV4dC1tdXRlZC1sZXNzIHB1bGwtcmlnaHQgcG9zaXRpb24tc3RpY2t5IHN0aWNreS10b3AnXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtbGFiZWw9XCJOZXcgRmVlZGJhY2sgQWxlcnRcIj5cbiAgICBOZXcgZmVlZGJhY2sgJnVhcnI7XG48L3NwYW4+XG5cbjxkaXYgY2xhc3M9J2Jsb2NrcHktZmVlZGJhY2sgYmxvY2tweS1wYW5lbCdcbiAgICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiRmVlZGJhY2tcIlxuICAgICAgICAgICAgYXJpYS1saXZlPVwicG9saXRlXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsYXNzOiB1aS5jb25zb2xlLnNpemVcIj5cblxuICAgIDwhLS0gRmVlZGJhY2svVHJhY2UgVmlzaWJpbGl0eSBDb250cm9sIC0tPlxuICAgIDwhLS0ga28gaWZub3Q6IHVpLnNlY29uZFJvdy5oaWRlVHJhY2VCdXR0b24gLS0+XG4gICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICBjbGFzcz0nYnRuIGJ0bi1zbSBidG4tb3V0bGluZS1zZWNvbmRhcnkgZmxvYXQtcmlnaHQnXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuc2Vjb25kUm93LmFkdmFuY2VTdGF0ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLWV5ZSc+PC9zcGFuPlxuICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1aS5zZWNvbmRSb3cuc3dpdGNoTGFiZWxcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBQb3NpdGl2ZSBGZWVkYmFjayBSZWdpb24gLS0+XG4gICAgPGRpdiBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stcG9zaXRpdmUgZmxvYXQtcmlnaHRcIj5cbiAgICAgICAgXG4gICAgXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEFjdHVhbCBGZWVkYmFjayBSZWdpb24gLS0+ICAgIFxuICAgIDxkaXY+XG4gICAgICAgIDxzdHJvbmc+RmVlZGJhY2s6IDwvc3Ryb25nPlxuICAgICAgICA8c3BhbiBjbGFzcz0nYmFkZ2UgYmxvY2tweS1mZWVkYmFjay1jYXRlZ29yeSBmZWVkYmFjay1iYWRnZSdcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNzczogdWkuZmVlZGJhY2suYmFkZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHVpLmZlZWRiYWNrLmNhdGVnb3J5XCI+RmVlZGJhY2sgS2luZDwvc3Bhbj5cbiAgICAgICAgPHNtYWxsIGRhdGEtYmluZD1cInRleHQ6ICgxMDAqc3VibWlzc2lvbi5zY29yZSgpKSsnJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGRpc3BsYXkuaW5zdHJ1Y3RvcigpICYmIGV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbCgpXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGV4dC1tdXRlZFwiPjwvc21hbGw+XG4gICAgPC9kaXY+XG4gICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZyBjbGFzcz1cImJsb2NrcHktZmVlZGJhY2stbGFiZWxcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwidGV4dDogZXhlY3V0aW9uLmZlZWRiYWNrLmxhYmVsXCI+PC9zdHJvbmc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJibG9ja3B5LWZlZWRiYWNrLW1lc3NhZ2VcIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiaHRtbDogZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PiAgICAgICAgICAgIFxuYDtcblxuZXhwb3J0IGNsYXNzIEJsb2NrUHlGZWVkYmFjayB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoZSBmZWVkYmFjayBhcmVhLCB3aGVyZSB1c2VycyBhcmUgdG9sZCB0aGUgc3RhdGUgb2YgdGhlaXJcbiAgICAgKiBwcm9ncmFtJ3MgZXhlY3V0aW9uIGFuZCBnaXZlbiBndWlkYW5jZS4gQWxzbyBtYW5hZ2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgVHJhY2UgVGFibGUuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAdGhpcyB7QmxvY2tQeUZlZWRiYWNrfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIFRoZSBIVE1MIG9iamVjdCB0aGlzIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwgPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrO1xuXG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stY2F0ZWdvcnlcIik7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnRhZy5maW5kKFwiLmJsb2NrcHktZmVlZGJhY2stbGFiZWxcIik7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mZWVkYmFjay1tZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLnBvc2l0aXZlID0gdGhpcy50YWcuZmluZChcIi5ibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlXCIpO1xuXG4gICAgICAgIC8vIFRPRE86IElmIHRoZXkgY2hhbmdlIHRoZSBzdHVkZW50IGV4dHJhIGZpbGVzLCBhbHNvIHVwZGF0ZSB0aGUgZGlydHkgZmxhZ1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5kaXJ0eVN1Ym1pc3Npb24odHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgc2NyZWVuICh0YWtlcyAxIHNlY29uZCkgdG8gbWFrZSB0aGUgRmVlZGJhY2sgYXJlYSB2aXNpYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICAkKFwiaHRtbCwgYm9keVwiKS5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy50YWcub2Zmc2V0KCkudG9wXG4gICAgICAgIH0sIDcwMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZlZWRiYWNrIGFyZWEgaXMgY3VycmVudGx5IHZpc2libGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZlZWRiYWNrVmlzaWJsZSgpIHtcbiAgICAgICAgbGV0IHZpc2liaWxpdHlCdWZmZXIgPSAxMDA7XG4gICAgICAgIGxldCB0b3BPZkVsZW1lbnQgPSB0aGlzLnRhZy5vZmZzZXQoKS50b3A7XG4gICAgICAgIC8vbGV0IGJvdHRvbU9mRWxlbWVudCA9IHRoaXMudGFnLm9mZnNldCgpLnRvcCArIHRoaXMudGFnLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGxldCBib3R0b21PZkVsZW1lbnQgPSB0b3BPZkVsZW1lbnQgKyB2aXNpYmlsaXR5QnVmZmVyO1xuICAgICAgICBsZXQgYm90dG9tT2ZTY3JlZW4gPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAkKHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICAgIGxldCB0b3BPZlNjcmVlbiA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcbiAgICAgICAgLy9ib3R0b21fb2ZfZWxlbWVudCAtPSA0MDsgLy8gVXNlciBmcmllbmRseSBwYWRkaW5nXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAodG9wT2ZFbGVtZW50IDwgYm90dG9tT2ZTY3JlZW4pICYmXG4gICAgICAgICAgICAodG9wT2ZTY3JlZW4gPCBib3R0b21PZkVsZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFueSBvdXRwdXQgY3VycmVudGx5IGluIHRoZSBmZWVkYmFjayBhcmVhLiBBbHNvIHJlc2V0cyB0aGUgcHJpbnRlciBhbmRcbiAgICAgKiBhbnkgaGlnaGxpZ2h0ZWQgbGluZXMgaW4gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLm1lc3NhZ2UoXCIqUmVhZHkqXCIpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwuY2F0ZWdvcnkobnVsbCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5sYWJlbChudWxsKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmhpZGRlbihmYWxzZSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNVbmNvdmVyZWQucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRoaXMuY2xlYXJQb3NpdGl2ZUZlZWRiYWNrKCk7XG4gICAgfTtcblxuICAgIHN0YXRpYyBmaW5kRmlyc3RFcnJvckxpbmUoZmVlZGJhY2tEYXRhKSB7XG4gICAgICAgIGlmIChmZWVkYmFja0RhdGEucXVpY2skbG9va3VwKSB7XG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBmZWVkYmFja0RhdGEucXVpY2skbG9va3VwKG5ldyBTay5idWlsdGluLnN0cihcImxvY2F0aW9uXCIpKTtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbG9jYXRpb24udHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXCJsaW5lXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9KcyhsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8qZm9yIChsZXQgaSA9IGZlZWRiYWNrRGF0YS5sZW5ndGgtMTsgaSA+PSAwOyBpLT0gMSkge1xuICAgICAgICAgICAgaWYgKFwicG9zaXRpb25cIiBpbiBmZWVkYmFja0RhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVlZGJhY2tEYXRhW2ldLnBvc2l0aW9uLmxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7Ki9cbiAgICB9O1xuXG4gICAgdXBkYXRlUmVndWxhckZlZWRiYWNrKCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbW9kZWwgd2l0aCB0aGVzZSBuZXcgZXhlY3V0aW9uIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gZXhlY3V0aW9uUmVzdWx0c1xuICAgICAqL1xuICAgIHVwZGF0ZUZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpIHtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IGRhdGFcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBTay5mZmkucmVtYXBUb0pzKGV4ZWN1dGlvblJlc3VsdHMuTUVTU0FHRSk7XG4gICAgICAgIGxldCBjYXRlZ29yeSA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5DQVRFR09SWSk7XG4gICAgICAgIGxldCBsYWJlbCA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5MQUJFTCk7XG4gICAgICAgIGxldCBoaWRlID0gU2suZmZpLnJlbWFwVG9KcyhleGVjdXRpb25SZXN1bHRzLkhJREUpO1xuICAgICAgICBsZXQgZGF0YSA9IGV4ZWN1dGlvblJlc3VsdHMuREFUQTtcbiAgICAgICAgbGV0IHBvc2l0aXZlcyA9IFNrLmZmaS5yZW1hcFRvSnMoZXhlY3V0aW9uUmVzdWx0cy5QT1NJVElWRSk7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgYmFzZWQgb24gYXNzaWdubWVudHMnIHNldHRpbmdzXG4gICAgICAgIGxldCBoaWRlU2NvcmUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKTtcbiAgICAgICAgaWYgKGhpZGVTY29yZSAmJiBjYXRlZ29yeS50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gXCJubyBlcnJvcnNcIjtcbiAgICAgICAgICAgIGxhYmVsID0gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk5vIGVycm9ycyByZXBvcnRlZC5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbWFwIHRvIGV4cGVjdGVkIEJsb2NrUHkgbGFiZWxzXG4gICAgICAgIGlmIChjYXRlZ29yeS50b0xvd2VyQ2FzZSgpID09PSBcImluc3RydWN0b3JcIiAmJiBsYWJlbC50b0xvd2VyQ2FzZSgpID09PSBcImV4cGxhaW5cIikge1xuICAgICAgICAgICAgbGFiZWwgPSBcIkluc3RydWN0b3IgRmVlZGJhY2tcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHByZXNlbnQgYSBsYWNrIG9mIGVycm9yIGFzIGJlaW5nIGluY29ycmVjdFxuICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IFwiSW5zdHJ1Y3RvclwiICYmIGxhYmVsID09PSBcIk5vIGVycm9yc1wiKSB7XG4gICAgICAgICAgICBjYXRlZ29yeSA9IFwibm8gZXJyb3JzXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgbW9kZWwgYWNjb3JkaW5nbHlcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMubWFpbi51dGlsaXRpZXMubWFya2Rvd24obWVzc2FnZSkucmVwbGFjZSgvPHByZT5cXG4vZywgXCI8cHJlPlxcblxcblwiKTtcbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5jYXRlZ29yeShjYXRlZ29yeSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5sYWJlbChsYWJlbCk7XG4gICAgICAgIC8vbGV0IGhpZ2hsaWdodFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLmZpbmQoXCJwcmUgY29kZVwiKS5tYXAoIChpLCBibG9jaykgPT4ge1xuICAgICAgICAgICAgd2luZG93LmhsanMuaGlnaGxpZ2h0QmxvY2soYmxvY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgLy99LCA0MDApO1xuICAgICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHRyYWNraW5nIHN0dWRlbnQgZmlsZSwgbGV0J3MgdHJhY2sgdGhlIGluc3RydWN0b3IgZmlsZVxuICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJJbnRlcnZlbnRpb25cIiwgY2F0ZWdvcnksIGxhYmVsLCBtZXNzYWdlLCBcImFuc3dlci5weVwiKTtcblxuICAgICAgICAvLyBDbGVhciBvdXQgYW55IHByZXZpb3VzbHkgaGlnaGxpZ2h0ZWQgbGluZXNcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMucHl0aG9uRWRpdG9yLmJtLmNsZWFySGlnaGxpZ2h0ZWRMaW5lcygpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIG9uIGEgbGluZSBhbmQgcmVwb3J0IHRoYXRcbiAgICAgICAgbGV0IGxpbmUgPSBCbG9ja1B5RmVlZGJhY2suZmluZEZpcnN0RXJyb3JMaW5lKGRhdGEpO1xuICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5yZW1vdmVBbGwoKTtcbiAgICAgICAgaWYgKGxpbmUgIT09IG51bGwgJiYgbGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5wdXNoKGxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52ZXJ0IHRoZSBzZXQgb2YgdHJhY2VkIGxpbmVzXG4gICAgICAgIGxldCBzdHVkZW50UmVwb3J0ID0gdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5yZXBvcnRzLnN0dWRlbnQ7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc1VuY292ZXJlZC5yZW1vdmVBbGwoKTtcbiAgICAgICAgaWYgKHN0dWRlbnRSZXBvcnQuc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IHVuY292ZXJlZExpbmVzID0gW107XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMucGFyc2VyLmxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3R1ZGVudFJlcG9ydC5saW5lcy5pbmRleE9mKGxpbmUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB1bmNvdmVyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLmxpbmVzVW5jb3ZlcmVkKHVuY292ZXJlZExpbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwb3NpdGl2ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpdmVEYXRhID0gcG9zaXRpdmVzW2ldO1xuICAgICAgICAgICAgdGhpcy5hZGRQb3NpdGl2ZUZlZWRiYWNrKHBvc2l0aXZlRGF0YS5tZXNzYWdlLCBcInN0YXJcIiwgXCJncmVlblwiLCAoKSA9PiB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuUE9TSVRJVkVfRkVFREJBQ0tfRlVMTChwb3NpdGl2ZURhdGEudGl0bGUsIHBvc2l0aXZlRGF0YS5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhclBvc2l0aXZlRmVlZGJhY2soKSB7XG4gICAgICAgIHRoaXMucG9zaXRpdmUuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyLmZpbmQoXCIuYmxvY2tweS1zdHVkZW50LWVycm9yXCIpLmhpZGUoKTtcbiAgICB9XG5cbiAgICBhZGRQb3NpdGl2ZUZlZWRiYWNrKHRleHQsIGljb24sIGNvbG9yLCBvbmNsaWNrLCB0b0VuZCkge1xuICAgICAgICBsZXQgcG9zaXRpdmUgPSAkKFwiPHNwYW4+PC9zcGFuPlwiKTtcbiAgICAgICAgcG9zaXRpdmUuYWRkQ2xhc3MoXCJibG9ja3B5LWZlZWRiYWNrLXBvc2l0aXZlLWljb24gZmFzIGZhLVwiK2ljb24pO1xuICAgICAgICBwb3NpdGl2ZS5jc3MoXCJjb2xvclwiLCBjb2xvcik7XG4gICAgICAgIHBvc2l0aXZlLmF0dHIoXCJ0aXRsZVwiLCB0ZXh0KTtcbiAgICAgICAgaWYgKHRvRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aXZlLmFwcGVuZChwb3NpdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aXZlLnByZXBlbmQocG9zaXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aXZlLnRvb2x0aXAoe1widHJpZ2dlclwiOiBcImhvdmVyXCIsIFwiY29udGFpbmVyXCI6IHRoaXMubWFpbi5tb2RlbC5jb25maWd1cmF0aW9uLmF0dGFjaG1lbnRQb2ludH0pO1xuICAgICAgICBpZiAob25jbGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3NpdGl2ZS5jbGljayhvbmNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGl2ZS5ob3ZlcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLUZlZWRiYWNrXCIsIFwicG9zaXRpdmVcIiwgXCJob3ZlclwiLCB0ZXh0LCBcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlc2VudCBhbnkgYWNjdW11bGF0ZWQgZmVlZGJhY2tcbiAgICAgKi9cbiAgICBwcmVzZW50RmVlZGJhY2soZXhlY3V0aW9uUmVzdWx0cykge1xuICAgICAgICB0aGlzLnVwZGF0ZUZlZWRiYWNrKGV4ZWN1dGlvblJlc3VsdHMpO1xuXG4gICAgICAgIC8vIFRPRE86IExvZ2dpbmdcbiAgICAgICAgLy90aGlzLm1haW4uY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJmZWVkYmFja1wiLCBjYXRlZ29yeStcInxcIitsYWJlbCwgbWVzc2FnZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlGZWVkYmFja1VwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBub3RpZnlGZWVkYmFja1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmVlZGJhY2tWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFnLmZpbmQoXCIuYmxvY2tweS1mbG9hdGluZy1mZWVkYmFja1wiKS5zaG93KCkuZmFkZU91dCg3MDAwKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcmVzZW50UnVuRXJyb3IoZXJyb3IsIGp1c3RfcmV0dXJuKSB7XG4gICAgICAgIGlmIChqdXN0X3JldHVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBqdXN0X3JldHVybiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlLCBsYWJlbCwgY2F0ZWdvcnksIGxpbmVubztcbiAgICAgICAgbGFiZWwgPSBlcnJvci50cCRuYW1lO1xuICAgICAgICBjYXRlZ29yeSA9IFwicnVudGltZVwiO1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5jb252ZXJ0U2t1bHB0RXJyb3IoZXJyb3IpO1xuXG4gICAgICAgIGlmIChqdXN0X3JldHVybikge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWVkYmFja01vZGVsLm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5jYXRlZ29yeShjYXRlZ29yeSk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5sYWJlbChsYWJlbCk7XG4gICAgICAgIHRoaXMuZmVlZGJhY2tNb2RlbC5saW5lc0Vycm9yLnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAobGluZW5vICE9PSB1bmRlZmluZWQgJiYgbGluZW5vICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZlZWRiYWNrTW9kZWwubGluZXNFcnJvci5wdXNoKGxpbmVubyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBidWlsZFRyYWNlYmFjayhlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCkge1xuICAgICAgICByZXR1cm4gZXJyb3IudHJhY2ViYWNrLm1hcChmcmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZW5vID0gZnJhbWUubGluZW5vO1xuICAgICAgICAgICAgaWYgKGZyYW1lLmZpbGVuYW1lLnNsaWNlKDAsIC0zKSA9PT0gZmlsZW5hbWVFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGxpbmVubyAtPSB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLnJlcG9ydHMuaW5zdHJ1Y3Rvci5saW5lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpbGUgPSBgRmlsZSA8Y29kZSBjbGFzcz1cImZpbGVuYW1lXCI+XCIke2ZyYW1lLmZpbGVuYW1lfVwiPC9jb2RlPiwgYDtcbiAgICAgICAgICAgIGxldCBsaW5lID0gYG9uIGxpbmUgPGNvZGUgY2xhc3M9XCJsaW5lbm9cIj4ke2xpbmVub308L2NvZGU+LCBgO1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gKGZyYW1lLnNjb3BlICE9PSBcIjxtb2R1bGU+XCIgJiZcbiAgICAgICAgICAgIGZyYW1lLnNjb3BlICE9PSB1bmRlZmluZWQpID8gYGluIHNjb3BlICR7ZnJhbWUuc2NvcGV9YCA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChmcmFtZS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGBcXG48cHJlPjxjb2RlPiR7ZnJhbWUuc291cmNlfTwvY29kZT48L3ByZT5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGUgKyBsaW5lICsgc2NvcGUgKyBzb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnZlcnRTa3VscHRFcnJvcihlcnJvciwgZmlsZW5hbWVFeGVjdXRlZCwgaXNJbnN0cnVjdG9yKSB7XG4gICAgICAgIGxldCBuYW1lID0gZXJyb3IudHAkbmFtZTtcbiAgICAgICAgbGV0IGFyZ3MgPSBTay5mZmkucmVtYXBUb0pzKGVycm9yLmFyZ3MpO1xuICAgICAgICBsZXQgdG9wID0gYCR7bmFtZX06ICR7YXJnc1swXX1cXG48YnI+XFxuPGJyPmA7XG4gICAgICAgIGxldCB0cmFjZWJhY2sgPSBcIlwiO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmVyciAmJiBlcnJvci5lcnIudHJhY2ViYWNrICYmIGVycm9yLmVyci50cmFjZWJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRnJhbWVzID0gdGhpcy5idWlsZFRyYWNlYmFjayhlcnJvci5lcnIsIGZpbGVuYW1lRXhlY3V0ZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtcIlRyYWNlYmFjazpcIl07XG4gICAgICAgICAgICAgICAgaWYgKGFsbEZyYW1lcy5sZW5ndGggPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmFsbEZyYW1lcy5zbGljZSgwLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYC4uLiBIaWRpbmcgJHthbGxGcmFtZXMubGVuZ3RoIC0gM30gb3RoZXIgc3RhY2sgZnJhbWVzIC4uLixgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hbGxGcmFtZXMuc2xpY2UoLTMsIC0yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsRnJhbWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2ViYWNrID0gcmVzdWx0LmpvaW4oXCJcXG48YnI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSW5zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHRvcCA9IFwiRXJyb3IgaW4gaW5zdHJ1Y3RvciBmZWVkYmFjay4gUGxlYXNlIHNob3cgdGhlIGZvbGxvd2luZyB0byBhbiBpbnN0cnVjdG9yOjxicj5cXG5cIit0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IudHJhY2ViYWNrICYmIGVycm9yLnRyYWNlYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cmFjZWJhY2sgPSBcIlRyYWNlYmFjazo8YnI+XFxuXCIgKyB0aGlzLmJ1aWxkVHJhY2ViYWNrKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKS5qb2luKFwiXFxuPGJyPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wK1wiXFxuXCIrdHJhY2ViYWNrO1xuICAgIH1cblxuICAgIHByZXNlbnRJbnRlcm5hbEVycm9yKGVycm9yLCBmaWxlbmFtZUV4ZWN1dGVkKSB7XG4gICAgICAgIGlmIChlcnJvci50cCRuYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLmNhdGVnb3J5KFwicnVudGltZVwiKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5leGVjdXRpb24uZmVlZGJhY2subGFiZWwoXCJUaW1lb3V0IEVycm9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5jYXRlZ29yeShcImludGVybmFsXCIpO1xuICAgICAgICAgICAgdGhpcy5tYWluLm1vZGVsLmV4ZWN1dGlvbi5mZWVkYmFjay5sYWJlbChcIkludGVybmFsIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5jb252ZXJ0U2t1bHB0RXJyb3IoZXJyb3IsIGZpbGVuYW1lRXhlY3V0ZWQsIHRydWUpO1xuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZXhlY3V0aW9uLmZlZWRiYWNrLm1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlGZWVkYmFja1VwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtU3lzdGVtLkVycm9yXCIsIFwiaW50ZXJuYWxcIiwgXCJJbnRlcm5hbCBFcnJvclwiLCBtZXNzYWdlLCBmaWxlbmFtZUV4ZWN1dGVkKTtcbiAgICB9XG59IiwiaW1wb3J0IHtmaXJzdERlZmluZWRWYWx1ZX0gZnJvbSBcInV0aWxpdGllcy5qc1wiO1xuXG4vLyAke21ha2VUYWIoXCI/bW9ja191cmxzLmJsb2NrcHlcIiwgXCJVUkwgRGF0YVwiLCB0cnVlKX1cblxuY29uc3QgbWFrZVRhYiA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBmcmllbmRseU5hbWUsIGhpZGVJZkVtcHR5LCBub3RJbnN0cnVjdG9yKSB7XG4gICAgaWYgKGZyaWVuZGx5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyaWVuZGx5TmFtZSA9IGZpbGVuYW1lO1xuICAgIH1cbiAgICBsZXQgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiXCI7XG4gICAgbGV0IGhpZGVJZk5vdEluc3RydWN0b3IgPSBcInRydWVcIjtcbiAgICBpZiAoIW5vdEluc3RydWN0b3IpIHtcbiAgICAgICAgaW5zdHJ1Y3RvckZpbGVDbGFzcyA9IFwiYmxvY2tweS1maWxlLWluc3RydWN0b3JcIjtcbiAgICAgICAgaGlkZUlmTm90SW5zdHJ1Y3RvciA9IFwiZGlzcGxheS5pbnN0cnVjdG9yKClcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSAke2luc3RydWN0b3JGaWxlQ2xhc3N9XCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6IGRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gJyR7ZmlsZW5hbWV9J30sXG4gICAgICAgICAgICAgICAgY2xpY2s6IGRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgJyR7ZmlsZW5hbWV9JyksXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogKCEke2hpZGVJZkVtcHR5fSB8fCB1aS5maWxlcy5oYXNDb250ZW50cygnJHtmaWxlbmFtZX0nKSkgJiYgJHtoaWRlSWZOb3RJbnN0cnVjdG9yfVwiPlxuICAgICAgICAgICAgJHtmcmllbmRseU5hbWV9PC9hPlxuICAgIDwvbGk+YDtcbn07XG5cbmV4cG9ydCBsZXQgRklMRVNfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJibG9ja3B5LXBhbmVsIGJsb2NrcHktZmlsZXNcIlxuICAgIGRhdGEtYmluZD1cInZpc2libGU6IHVpLmZpbGVzLnZpc2libGUsIGNsYXNzOiB1aS5maWxlcy53aWR0aFwiPlxuPHVsIGNsYXNzPVwibmF2IG5hdi10YWJzXCIgcm9sZT1cInRhYmxpc3RcIj5cblxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgIDxzdHJvbmc+VmlldzogPC9zdHJvbmc+XG4gICAgPC9saT5cblxuICAgICR7bWFrZVRhYihcImFuc3dlci5weVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIWluc3RydWN0aW9ucy5tZFwiLCBcIkluc3RydWN0aW9uc1wiKX1cbiAgICAke21ha2VUYWIoXCIhYXNzaWdubWVudF9zZXR0aW5ncy5ibG9ja3B5XCIsIFwiU2V0dGluZ3NcIil9XG4gICAgJHttYWtlVGFiKFwiXnN0YXJ0aW5nX2NvZGUucHlcIiwgXCJTdGFydGluZyBDb2RlXCIpfVxuICAgICR7bWFrZVRhYihcIiFvbl9ydW4ucHlcIiwgXCJPbiBSdW5cIil9XG4gICAgJHttYWtlVGFiKFwiIW9uX2NoYW5nZS5weVwiLCBcIk9uIENoYW5nZVwiLCB0cnVlKX1cbiAgICAke21ha2VUYWIoXCIhb25fZXZhbC5weVwiLCBcIk9uIEV2YWxcIiwgdHJ1ZSl9XG4gICAgJHttYWtlVGFiKFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIsIFwiU2FtcGxlIFN1Ym1pc3Npb25zXCIsIHRydWUpfVxuICAgICR7bWFrZVRhYihcIiF0YWdzLmJsb2NrcHlcIiwgXCJUYWdzXCIsIHRydWUpfVxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyAtLT5cbiAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7J2Jsb2NrcHktZmlsZS1pbnN0cnVjdG9yJzogIWZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZmlsZW5hbWUoKS5zdGFydHNXaXRoKCcmJykgfHwgJHJvb3QuZGlzcGxheS5pbnN0cnVjdG9yKCkgXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZWRpdGFibGU6IGZpbGVuYW1lKCkuc3RhcnRzV2l0aCgnJicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJHJvb3QuZGlzcGxheS5maWxlbmFtZS5iaW5kKCRkYXRhLCBmaWxlbmFtZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAkcm9vdC51aS5maWxlcy5kaXNwbGF5RmlsZW5hbWUoZmlsZW5hbWUoKSlcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIDwhLS0ga28gZm9yZWFjaDogYXNzaWdubWVudC5leHRyYVN0YXJ0aW5nRmlsZXMgLS0+XG4gICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cInZpc2libGU6ICRyb290LmRpc3BsYXkuaW5zdHJ1Y3RvcigpXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjc3M6IHthY3RpdmU6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICRyb290LmRpc3BsYXkuZmlsZW5hbWUuYmluZCgkZGF0YSwgZmlsZW5hbWUoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmlsZW5hbWVcIj5cbiAgICAgICAgICAgIDwvYT4gICAgICAgIFxuICAgICAgICA8L2xpPlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuICAgIDwhLS0ga28gZm9yZWFjaDogc3VibWlzc2lvbi5leHRyYUZpbGVzIC0tPlxuICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY3NzOiB7YWN0aXZlOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGZpbGVuYW1lKCl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkcm9vdC5kaXNwbGF5LmZpbGVuYW1lLmJpbmQoJGRhdGEsIGZpbGVuYW1lKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICRyb290LnVpLmZpbGVzLmRpc3BsYXlGaWxlbmFtZShmaWxlbmFtZSgpKVwiPlxuICAgICAgICAgICAgPC9hPiAgICAgICAgXG4gICAgICAgIDwvbGk+XG4gICAgPCEtLSAva28gLS0+XG4gIFxuICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGRyb3Bkb3duXCI+XG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCIgaHJlZj1cIiNcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgIHJvbGU9XCJidXR0b25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPkFkZCBOZXc8L2E+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/bW9ja191cmxzLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJz9tb2NrX3VybHMuYmxvY2tweScpXCI+VVJMIERhdGE8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnP2ltYWdlcy5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/aW1hZ2VzLmJsb2NrcHknKVwiPkltYWdlczwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCc/dG9vbGJveC5ibG9ja3B5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICc/dG9vbGJveC5ibG9ja3B5JylcIj5Ub29sYm94PC9hPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiB1aS5maWxlcy5oYXNDb250ZW50cygnIXRhZ3MuYmxvY2tweScpXCI+VGFnczwvYT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IHVpLmZpbGVzLmhhc0NvbnRlbnRzKCchc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweScpXCI+U2FtcGxlIFN1Ym1pc3Npb25zPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbSBibG9ja3B5LWZpbGUtaW5zdHJ1Y3RvclwiIGhyZWY9XCIjXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJoaWRkZW46IGFzc2lnbm1lbnQub25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchb25fY2hhbmdlLnB5JylcIj5PbiBDaGFuZ2U8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiaGlkZGVuOiBhc3NpZ25tZW50Lm9uRXZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJyFvbl9ldmFsLnB5JylcIj5PbiBFdmFsPC9hPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWRpdmlkZXJcIj48L2Rpdj5cbiAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFhbnN3ZXJfcHJlZml4LnB5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchYW5zd2VyX3ByZWZpeC5weScpXCI+QW5zd2VyIFByZWZpeDwvYT5cbiAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtIGJsb2NrcHktZmlsZS1pbnN0cnVjdG9yXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImhpZGRlbjogdWkuZmlsZXMuaGFzQ29udGVudHMoJyFhbnN3ZXJfc3VmZml4LnB5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogdWkuZmlsZXMuYWRkLmJpbmQoJGRhdGEsICchYW5zd2VyX3N1ZmZpeC5weScpXCI+QW5zd2VyIFN1ZmZpeDwvYT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi1kaXZpZGVyXCI+PC9kaXY+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnc3RhcnRpbmcnKVwiPlN0YXJ0aW5nIEZpbGU8L2E+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW0gYmxvY2tweS1maWxlLWluc3RydWN0b3JcIiBocmVmPVwiI1wiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmZpbGVzLmFkZC5iaW5kKCRkYXRhLCAnaW5zdHJ1Y3RvcicpXCI+SW5zdHJ1Y3RvciBGaWxlPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgaHJlZj1cIiNcIlxuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5maWxlcy5hZGQuYmluZCgkZGF0YSwgJ3N0dWRlbnQnKVwiPlN0dWRlbnQgRmlsZTwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9saT5cbiAgXG48L3VsPlxuPC9kaXY+XG5gO1xuXG5jb25zdCBORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MID0gYFxuPGZvcm0+XG48ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3dcIj5cbiAgICA8IS0tIEZpbGVuYW1lIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+XG4gICAgICAgIDxsYWJlbCBmb3I9XCJibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctZmlsZW5hbWVcIj5GaWxlbmFtZTo8L2xhYmVsPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTBcIj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGVuYW1lXCI+ICAgIFxuICAgIDwvZGl2PlxuICAgIDwhLS0gRmlsZXR5cGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHQgbXQtMlwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLWZpbGV0eXBlXCI+RmlsZXR5cGU6IDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiXG4gICAgICAgICAgICBpZD1cImJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiPjwvc3Bhbj4gICAgXG4gICAgPC9kaXY+XG4gICAgPCEtLSBJbmFjY2Vzc2libGUgdG8gc3R1ZGVudD8gLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1zbS0yIHRleHQtcmlnaHQgbXQtMlwiPlxuICAgICAgICA8bGFiZWwgZm9yPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiPk5hbWVzcGFjZTogPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTRcIj5cbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbCBibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCJcbiAgICAgICAgICAgIGlkPVwiYmxvY2tweS1pbnN0cnVjdG9yLWZpbGUtZGlhbG9nLW5hbWVzcGFjZVwiPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiFcIj5Db21wbGV0ZWx5IGluYWNjZXNzaWJsZTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIj9cIj5IaWRkZW4gZnJvbSBzdHVkZW50LCBhY2Nlc3NpYmxlIHByb2dyYW1hdGljYWxseTwvb3B0aW9uPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIiZcIj5WaXNpYmxlIHRvIHN0dWRlbnQsIGJ1dCBub3QgZWRpdGFibGU8L29wdGlvbj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjwvZm9ybT5cbmA7XG5cbi8qKlxuICogRmlsZW5hbWVzIGxpdmUgaW4gb25lIG9mIGZpdmUgcG9zc2libGUgbmFtZXNwYWNlczpcbiAqICBJbnN0cnVjdG9yICghKTogSW52aXNpYmxlIHRvIHRoZSBzdHVkZW50IHVuZGVyIGFsbCBjaXJjdW1zdGFuY2VzXG4gKiAgU3RhcnQgU3BhY2UgKF4pOiBVc2VkIHRvIHJlc2V0IHRoZSBzdHVkZW50IG5hbWVzcGFjZVxuICogIFN0dWRlbnQgU3BhY2UgKCk6IFZpc2libGUgdG8gdGhlIHN0dWRlbnQgd2hlbiBkaXNwbGF5LmhpZGVGaWxlcyBpcyBub3QgdHJ1ZSwgYWJsZSB0byBiZSBlZGl0ZWRcbiAqICBIaWRkZW4gU3BhY2UgKD8pOiBOb3QgZGlyZWN0bHkgdmlzaWJsZSB0byB0aGUgc3R1ZGVudCwgYnV0IGFjY2Vzc2libGUgcHJvZ3JhbW1hdGljYWxseVxuICogIFJlYWQtb25seSBTcGFjZSAoJik6IEFuIGluc3RydWN0b3IgZmlsZSB0eXBlIHZpc2libGUgdG8gdGhlIHN0dWRlbnQsIGJ1dCBpcyB1bmVkaXRhYmxlIGJ5IHRoZW1cbiAqICBTZWNyZXQgU3BhY2UgKCQpOiBOb3QgdmlzaWJsZSBmcm9tIHRoZSBtZW51IGF0IGFsbCwgc29tZSBvdGhlciBtZWNoYW5pc20gY29udHJvbHMgaXRcbiAqICBHZW5lcmF0ZWQgU3BhY2UgKCopOiBWaXNpYmxlIHRvIHRoZSBzdHVkZW50LCBidXQgZGVzdHJveWVkIGFmdGVyIEVuZ2luZS5DbGVhci4gQ2FuIHNoYWRvdyBhbiBhY3R1YWwgZmlsZS5cbiAqICBDb25jYXRlbmF0ZWQgU3BhY2UgKCMpOiBVc2VkIHdoZW4gYnVuZGxpbmcgYSBzcGFjZSBmb3IgdGhlIHNlcnZlci5cbiAqL1xuXG5leHBvcnQgbGV0IFNUQVJUSU5HX0ZJTEVTID0gW1xuICAgIC8vIFN1Ym1pc3Npb25cbiAgICBcImFuc3dlci5weVwiLFxuICAgIC8vIEluc3RydWN0b3IgZmlsZXNcbiAgICBcIiFpbnN0cnVjdGlvbnMubWRcIixcbiAgICBcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIixcbiAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsXG4gICAgXCIhb25fcnVuLnB5XCIsXG4gICAgXCIkc2V0dGluZ3MuYmxvY2tweVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IEJBU0lDX05FV19GSUxFUyA9IFtcbiAgICBcIiFvbl9jaGFuZ2UucHlcIixcbiAgICBcIiFvbl9ldmFsLnB5XCIsXG4gICAgXCI/bW9ja191cmxzLmJsb2NrcHlcIixcbiAgICBcIj90b29sYm94LmJsb2NrcHlcIixcbiAgICBcIiF0YWdzLmJsb2NrcHlcIixcbiAgICBcIiFzYW1wbGVfc3VibWlzc2lvbnMuYmxvY2tweVwiLFxuICAgIFwiIWFuc3dlcl9wcmVmaXgucHlcIixcbiAgICBcIiFhbnN3ZXJfc3VmZml4LnB5XCJcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBjaG9tcFNwZWNpYWxGaWxlKGZpbGVuYW1lKSB7XG4gICAgaWYgKFwiIV4/JiQqI1wiLmluY2x1ZGVzKGZpbGVuYW1lWzBdKSkge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbn1cblxuY29uc3QgSU5TVFJVQ1RPUl9ESVJFQ1RPUlkgPSBcIl9pbnN0cnVjdG9yL1wiO1xuY29uc3QgU1RVREVOVF9ESVJFQ1RPUlkgPSBcIl9zdHVkZW50L1wiO1xuXG5jb25zdCBTZWFyY2hNb2RlcyA9IHtcbiAgICBFVkVSWVdIRVJFOiBcIkVWRVJZV0hFUkVcIixcbiAgICBTVEFSVF9XSVRIX0lOU1RSVUNUT1I6IFwiU1RBUlRfV0lUSF9JTlNUUlVDVE9SXCIsXG4gICAgT05MWV9TVFVERU5UX0ZJTEVTOiBcIk9OTFlfU1RVREVOVF9GSUxFU1wiXG59O1xuXG5jb25zdCBERUxFVEFCTEVfU0lNUExFX0ZJTEVTID0gW1wiIW9uX2NoYW5nZS5weVwiLCBcIiFvbl9ldmFsLnB5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5ERUxFVEFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCJdO1xuXG5leHBvcnQgY29uc3QgVU5SRU5BTUFCTEVfRklMRVMgPSBbXCJhbnN3ZXIucHlcIiwgXCIhaW5zdHJ1Y3Rpb25zLm1kXCIsIFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5zdGFydGluZ19jb2RlLnB5XCIsIFwiIW9uX3J1bi5weVwiLCBcIiRzZXR0aW5ncy5ibG9ja3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIhb25fY2hhbmdlLnB5XCIsIFwiIW9uX2V2YWwucHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj9tb2NrX3VybHMuYmxvY2tweVwiLCBcIj90b29sYm94LmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiF0YWdzLmJsb2NrcHlcIiwgXCIhc2FtcGxlX3N1Ym1pc3Npb25zLmJsb2NrcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiFhbnN3ZXJfcHJlZml4LnB5XCIsIFwiIWFuc3dlcl9zdWZmaXgucHlcIl07XG5cbmNsYXNzIEJsb2NrUHlGaWxlIHtcbiAgICBjb25zdHJ1Y3RvcihtYWluLCBmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29udGVudHMgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5vd25lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTW9kZWxGaWxlKGZpbGVuYW1lLCBjb250ZW50cykge1xuICAgIHJldHVybiB7XCJmaWxlbmFtZVwiOiBrby5vYnNlcnZhYmxlKGZpbGVuYW1lKSwgY29udGVudHM6IGtvLm9ic2VydmFibGUoY29udGVudHMgfHwgXCJcIil9O1xufVxuXG5mdW5jdGlvbiBtYWtlTW9ja01vZGVsRmlsZShmaWxlbmFtZSwgY29udGVudHMpIHtcbiAgICByZXR1cm4geyBmaWxlbmFtZTogKCkgPT4gZmlsZW5hbWUsIGNvbnRlbnRzOiAoKSA9PiBjb250ZW50cyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZENvbmNhdGVuYXRlZEZpbGUoY29uY2F0ZW5hdGVkRmlsZSwgbW9kZWxGaWxlTGlzdCkge1xuICAgIGlmIChjb25jYXRlbmF0ZWRGaWxlKSB7XG4gICAgICAgIGxldCBmaWxlcyA9IEpTT04ucGFyc2UoY29uY2F0ZW5hdGVkRmlsZSk7XG4gICAgICAgIGxldCBtb2RlbEZpbGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxGaWxlcy5wdXNoKG1ha2VNb2RlbEZpbGUoZmlsZW5hbWUsIGZpbGVzW2ZpbGVuYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZmlsZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUsIGZpbGUuY29udGVudHMpKTtcbiAgICAgICAgaWYgKG1vZGVsRmlsZUxpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsRmlsZUxpc3QobW9kZWxGaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxGaWxlcztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbEZpbGVMaXN0KSB7XG4gICAgICAgICAgICBtb2RlbEZpbGVMaXN0KFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbmNhdGVuYXRlZEZpbGUobW9kZWxGaWxlTGlzdCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtb2RlbEZpbGVMaXN0KCkubWFwKGZpbGUgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUuZmlsZW5hbWUoKSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBmaWxlLmNvbnRlbnRzKClcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlQ29uY2F0ZW5hdGVkRmlsZShtb2RlbEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIGtvLnB1cmVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbW9kZWxGaWxlTGlzdCgpLmZvckVhY2goZmlsZSA9PlxuICAgICAgICAgICAgcmVzdWx0W2ZpbGUuZmlsZW5hbWUoKV0gPSBmaWxlLmNvbnRlbnRzKCkpO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBkYXRhYmFzZSBsb2dpY1xuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUZpbGVTeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAgICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICAgICAgdGhpcy5maWxlc18gPSB7fTtcbiAgICAgICAgdGhpcy5tb3VudEZpbGVzKCk7XG5cbiAgICAgICAgdGhpcy53YXRjaE1vZGVsKCk7XG4gICAgICAgIHRoaXMud2F0Y2hlc18gPSB7fTtcblxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5pbnN0cnVjdG9yLnN1YnNjcmliZSgodmlzaWJsaXR5KT0+IHtcbiAgICAgICAgICAgICQoXCIuYmxvY2tweS1maWxlLWluc3RydWN0b3JcIikudG9nZ2xlKHZpc2libGl0eSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHdhdGNoRmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCEoZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlc19bZmlsZW5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgc3RvcFdhdGNoaW5nRmlsZShmaWxlbmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy53YXRjaGVzX1tmaWxlbmFtZV07XG4gICAgfVxuXG4gICAgd2F0Y2hNb2RlbCgpIHtcbiAgICAgICAgbGV0IGZpbGVzeXN0ZW0gPSB0aGlzO1xuICAgICAgICBbdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcyxcbiAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyxcbiAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzXS5mb3JFYWNoKGZpbGVBcnJheSA9PlxuICAgICAgICAgICAgZmlsZUFycmF5LnN1YnNjcmliZShmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiBzZWNvbmQuc3RhdHVzLmxvY2FsZUNvbXBhcmUoZmlyc3Quc3RhdHVzKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsRmlsZSA9IGNoYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayBuZXcgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXN5c3RlbS5uZXdGaWxlKG1vZGVsRmlsZS5maWxlbmFtZSgpLCBtb2RlbEZpbGUuY29udGVudHMoKSwgbW9kZWxGaWxlLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc3lzdGVtLm5vdGlmeVdhdGNoZXMoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5zdGF0dXMgPT09IFwiZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzeXN0ZW0uZGVsZXRlRmlsZUxvY2FsbHlfKG1vZGVsRmlsZS5maWxlbmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoKSA9PT0gbW9kZWxGaWxlLmZpbGVuYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXN5c3RlbS5tYWluLm1vZGVsLmRpc3BsYXkuZmlsZW5hbWUoXCJhbnN3ZXIucHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMsIFwiYXJyYXlDaGFuZ2VcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhbnN3ZXIucHlcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byBmaXJzdCBlbGVtZW50IG9mIHN1Ym1pc3Npb24uY29kZSlcbiAgICAvLyAhb25fcnVuLnB5LCAhb25fY2hhbmdlLnB5LCAhb25fZXZhbC5weVxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlbGV2YW50IGFzc2lnbm1lbnQuPHdoYXRldmVyPlxuICAgIC8vIF5zdGFydGluZ19jb2RlLnB5XG4gICAgLy8gICA9PiBzdWJzY3JpYmUgdG8gZmlyc3QgZWxlbWVudCBvZiBhc3NpZ25tZW50LnN0YXJ0aW5nQ29kZVxuICAgIC8vIF53aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIHJlc3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlXG4gICAgLy8gIXdoYXRldmVyIG9yID93aGF0ZXZlclxuICAgIC8vICAgPT4gc3Vic2NyaWJlIHRvIGVsZW1lbnRzIG9mIGFzc2lnbm1lbnQuZXh0cmFGaWxlc1xuICAgIC8vIE90aGVyd2lzZTpcbiAgICAvLyAgID0+IHN1YnNjcmliZSB0byByZXN0IG9mIHRoZSBlbGVtZW50cyBvZiBzdWJtaXNzaW9uLmNvZGVcbiAgICAvKipcbiAgICAgKiBOZXcgc3BlY2lhbCBmaWxlcyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgaGVyZVxuICAgICAqIEBwYXJhbSBmaWxlIHtCbG9ja1B5RmlsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ic2VydmVGaWxlXyhmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLmZpbGVuYW1lID09PSBcImFuc3dlci5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5zdWJtaXNzaW9uLmNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fcnVuLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25SdW47XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fY2hhbmdlLnB5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIhb25fZXZhbC5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50Lm9uRXZhbDtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFpbnN0cnVjdGlvbnMubWRcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCJec3RhcnRpbmdfY29kZS5weVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnN0YXJ0aW5nQ29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIj9tb2NrX3VybHMuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCI/dG9vbGJveC5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfcHJlZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiFhbnN3ZXJfc3VmZml4LnB5XCIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhSW5zdHJ1Y3RvckZpbGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlLmZpbGVuYW1lID09PSBcIiF0YWdzLmJsb2NrcHlcIikge1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC50YWdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIWFzc2lnbm1lbnRfc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LnNldHRpbmdzO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUgPT09IFwiIXNhbXBsZV9zdWJtaXNzaW9ucy5ibG9ja3B5XCIpIHtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2FtcGxlU3VibWlzc2lvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZSA9PT0gXCIkc2V0dGluZ3MuYmxvY2tweVwiKSB7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5O1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIl5cIikpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUluQXJyYXlfKGZpbGUsIHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50LmV4dHJhU3RhcnRpbmdGaWxlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlbmFtZS5zdGFydHNXaXRoKFwiIVwiKSB8fFxuICAgICAgICAgICAgICAgICAgIGZpbGUuZmlsZW5hbWUuc3RhcnRzV2l0aChcIj9cIikgfHxcbiAgICAgICAgICAgICAgICAgICBmaWxlLmZpbGVuYW1lLnN0YXJ0c1dpdGgoXCImXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbkFycmF5XyhmaWxlLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5leHRyYUZpbGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9ic2VydmVJbkFycmF5XyhmaWxlLCBhcnJheSkge1xuICAgICAgICBmaWxlLm93bmVyID0gYXJyYXk7XG4gICAgICAgIGxldCBjb2RlQnVuZGxlID0gZmlsZS5vd25lcigpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjb2RlQnVuZGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUJ1bmRsZVtpXS5maWxlbmFtZSgpID09PSBmaWxlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBjb2RlQnVuZGxlW2ldLmNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLmhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IG5ld0ZpbGUgPSBtYWtlTW9kZWxGaWxlKGZpbGUuZmlsZW5hbWUpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGUgPSBuZXdGaWxlLmNvbnRlbnRzO1xuICAgICAgICAgICAgYXJyYXkucHVzaChuZXdGaWxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vdW50RmlsZXMoKSB7XG4gICAgICAgIHRoaXMubmV3RmlsZShcImFuc3dlci5weVwiKTtcbiAgICAgICAgdGhpcy5uZXdGaWxlKFwiXnN0YXJ0aW5nX2NvZGUucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFvbl9ydW4ucHlcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFpbnN0cnVjdGlvbnMubWRcIik7XG4gICAgICAgIHRoaXMubmV3RmlsZShcIiFhc3NpZ25tZW50X3NldHRpbmdzLmJsb2NrcHlcIik7XG4gICAgfVxuXG4gICAgZGlzbW91bnRFeHRyYUZpbGVzKCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZmlsZXNfKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWxlc18uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoVU5ERUxFVEFCTEVfRklMRVMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNfW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53YXRjaGVzX1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VibWlzc2lvbi5jb2RlVE9ETzogU2hvdWxkbid0IHdlIG5vdGlmeSB0aGUgVUkgdGhhdCB0aGUgZmlsZSB3YXMgZGVsZXRlZD9cbiAgICB9XG5cbiAgICBuZXdGaWxlKGZpbGVuYW1lLCBjb250ZW50cywgbW9kZWxGaWxlKSB7XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzXykge1xuICAgICAgICAgICAgLy8gRmlsZSBhbHJlYWR5IGV4aXN0cyEgSnVzdCB1cGRhdGUgaXRzIGhhbmRsZVxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nRmlsZSA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIGlmIChtb2RlbEZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbGVfKGV4aXN0aW5nRmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nRmlsZS5oYW5kbGUgPSBtb2RlbEZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGlzdGluZ0ZpbGUuaGFuZGxlKGNvbnRlbnRzIHx8IFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgICAgIGxldCBuZXdGaWxlID0gbmV3IEJsb2NrUHlGaWxlKHRoaXMubWFpbiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgdGhpcy5maWxlc19bZmlsZW5hbWVdID0gbmV3RmlsZTtcbiAgICAgICAgICAgIGlmIChtb2RlbEZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbGVfKG5ld0ZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGaWxlLmhhbmRsZSA9IG1vZGVsRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RmlsZS5oYW5kbGUoY29udGVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZUZpbGUoZmlsZW5hbWUsIGNvbnRlbnRzKSB7XG4gICAgICAgIGNvbnRlbnRzID0gY29udGVudHMgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5maWxlc19bZmlsZW5hbWVdLmhhbmRsZShjb250ZW50cyk7XG4gICAgfVxuXG4gICAgcmVhZEZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5oYW5kbGUoKTtcbiAgICB9XG5cbiAgICBnZXRGaWxlKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxvYmplY3R9IFRoZSBpbmZvIGFib3V0IHRoZSBmaWxlLCBvciBmYWxzZSBpZiBpdCBjb3VsZCBub3QgYmUgZGVsZXRlZFxuICAgICAqL1xuICAgIGRlbGV0ZUZpbGUoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKERFTEVUQUJMRV9TSU1QTEVfRklMRVMuaW5kZXhPZihmaWxlbmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgZmlsZSA9IHRoaXMuZGVsZXRlRmlsZUxvY2FsbHlfKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrIHRvIGV2ZW50dWFsbHkgY2FsbCBkZWxldGVGaWxlTG9jYWxseV9cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lci5yZW1vdmUobW9kZWxGaWxlID0+IG1vZGVsRmlsZS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGVGaWxlTG9jYWxseV8oZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzX1tmaWxlbmFtZV07XG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiB0aGlzLndhdGNoZXNfKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoZXNfW2ZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmRlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgcmVuYW1lRmlsZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmIChVTlJFTkFNQUJMRV9GSUxFUy5pbmRleE9mKHNvdXJjZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5maWxlc19bZmlsZW5hbWVdLm93bmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrIHRvIGV2ZW50dWFsbHkgY2FsbCBkZWxldGVGaWxlTG9jYWxseV9cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZmlsZXNfW2ZpbGVuYW1lXS5vd25lci5yZW1vdmUobW9kZWxGaWxlID0+IG1vZGVsRmlsZS5maWxlbmFtZSgpID09PSBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub3RpZnlXYXRjaGVzKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuZmlsZW5hbWUgaW4gdGhpcy53YXRjaGVzXykge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzX1tmaWxlLmZpbGVuYW1lXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLnVwZGF0ZWQoZmlsZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yRmlsZShuYW1lLCBzdHVkZW50U2VhcmNoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IFRoaXMgaXMgY2FsbGVkIHF1aXRlIGEgYml0IGJ5IHRoZSBJbXBvcnQgbWVjaGFuaXNtLCBtaWdodCBuZWVkXG4gICAgICAgICAgICAgIHRvIG9wdGltaXplIGl0IHNvbWUgbW9yZS4gRG8gdGltaW5nIHRlc3RzLlxuXG4gICAgICAgIGZpbGVzLipcbiAgICAgICAgX2luc3RydWN0b3IvZmlsZXMuKlxuICAgICAgICBfc3R1ZGVudC9maWxlcy4qXG5cbiAgICAgICAgSWYgYSBzdHVkZW50IHNlYXJjaGVzIGZvciBhIGZpbGUsIGl0IGNoZWNrcyB0aGUgXCI/XCIsIFwiJlwiLCBcIipcIiwgXCJcIiBuYW1lc3BhY2VzXG4gICAgICAgICAgICBpbXBvcnQgaGVscGVyID0+IFwiLi9oZWxwZXIucHlcIlxuICAgICAgICAgICAgb3BlbihcImV4dGVybmFsLmpzb25cIikgPT4gXCJleHRlcm5hbC5qc29uXCJcbiAgICAgICAgSWYgYW4gaW5zdHJ1Y3RvciBzZWFyY2hlcyBmb3IgYSBmaWxlLCBpdCBjaGVja3MgXCIhXCIsIFwiXlwiLCBcIj9cIiwgXCImXCIsIFwiKlwiLCBcIlwiIG5hbWVzcGFjZXNcbiAgICAgICAgICAgIFRvIGV4cGxpY2l0bHkgc2VhcmNoIGluc3RydWN0b3IgbmFtZXNwYWNlcyBmaXJzdFxuICAgICAgICAgICAgICAgIGltcG9ydCBfaW5zdHJ1Y3Rvci5oZWxwZXIgPT4gXCIuL2luc3RydWN0b3IvaGVscGVyLnB5XCJcbiAgICAgICAgICAgICAgICBvcGVuKFwiX2luc3RydWN0b3IvZXh0ZXJuYWwuanNvblwiKSA9PiBcIl9pbnN0cnVjdG9yL2V4dGVybmFsLmpzb25cIlxuICAgICAgICAgICAgdG8gYWxsb3cgc3R1ZGVudCBmaWxlcyB0byBvdmVycmlkZTpcbiAgICAgICAgICAgICAgICBpbXBvcnQgaGVscGVyID0+IFwiLi9oZWxwZXIucHlcIlxuICAgICAgICAgICAgICAgIG9wZW4oXCJleHRlcm5hbC5qc29uXCIpID0+IFwiZXh0ZXJuYWwuanNvblwiXG4gICAgICAgICAgICB0byBvbmx5IGNoZWNrIHN0dWRlbnQgZmlsZXMsIHByZXBlbmQgd2l0aCBfc3R1ZGVudFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQ2hvcCBvZmYgc3RhcnRpbmcgXCIuL1wiXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5FVkVSWVdIRVJFO1xuICAgICAgICAvLyBTaG91bGQgdGhlIHNlYXJjaCBiZSBzdGFydCB3aXRoIGluc3RydWN0b3Igc2lkZT9cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChJTlNUUlVDVE9SX0RJUkVDVE9SWSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKElOU1RSVUNUT1JfRElSRUNUT1JZLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuU1RBUlRfV0lUSF9JTlNUUlVDVE9SO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCB0aGUgc2VhcmNoIGJlIGxpbWl0ZWQgdG8gdGhlIHN0dWRlbnQgbW9kZT9cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChTVFVERU5UX0RJUkVDVE9SWSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKFNUVURFTlRfRElSRUNUT1JZLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWFyY2hNb2RlID0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTO1xuICAgICAgICB9IGVsc2UgaWYgKHN0dWRlbnRTZWFyY2gpIHtcbiAgICAgICAgICAgIHNlYXJjaE1vZGUgPSBTZWFyY2hNb2Rlcy5PTkxZX1NUVURFTlRfRklMRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGluc3RydWN0b3IgdmVyc2lvbnNcbiAgICAgICAgbGV0IGV4dHJhU3R1ZGVudEZpbGVzID0gdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uZXh0cmFGaWxlcygpO1xuICAgICAgICBsZXQgZXh0cmFJbnN0cnVjdG9yRmlsZXMgPSB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5leHRyYUluc3RydWN0b3JGaWxlcygpO1xuICAgICAgICBsZXQgZXh0cmFTdGFydGluZ0ZpbGVzID0gdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuZXh0cmFTdGFydGluZ0ZpbGVzKCk7XG4gICAgICAgIC8vIENoZWNrIHNwZWNpYWwgZmlsZXMgKFRPRE86IGhvdyB3b3VsZCBhbiBpbnN0cnVjdG9yIGFjY2VzcyBcIi4vX2luc3RydWN0b3IvYW5zd2VyLnB5XCI/XG4gICAgICAgIGxldCBzcGVjaWFsRmlsZSA9IHRoaXMuc2VhcmNoRm9yU3BlY2lhbEZpbGVzXyhuYW1lLCBzZWFyY2hNb2RlKTtcbiAgICAgICAgaWYgKHNwZWNpYWxGaWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFsRmlsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydCBsb29raW5nIHRocm91Z2ggcG9zc2libGUgZmlsZXNcbiAgICAgICAgbGV0IHN0dWRlbnRWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYVN0dWRlbnRGaWxlcywgbmFtZSk7XG4gICAgICAgIGxldCBnZW5lcmF0ZWRWZXJzaW9uID0gdGhpcy5zZWFyY2hGb3JGaWxlSW5MaXN0XyhleHRyYVN0dWRlbnRGaWxlcywgXCIqXCIrbmFtZSk7XG4gICAgICAgIGxldCBkZWZhdWx0VmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiJlwiK25hbWUpO1xuICAgICAgICBsZXQgaGlkZGVuVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiP1wiK25hbWUpO1xuICAgICAgICBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3REZWZpbmVkVmFsdWUoaGlkZGVuVmVyc2lvbiwgZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5zdHJ1Y3RvclZlcnNpb24gPSB0aGlzLnNlYXJjaEZvckZpbGVJbkxpc3RfKGV4dHJhSW5zdHJ1Y3RvckZpbGVzLCBcIiFcIituYW1lKTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nVmVyc2lvbiA9IHRoaXMuc2VhcmNoRm9yRmlsZUluTGlzdF8oZXh0cmFTdGFydGluZ0ZpbGVzLCBcIl5cIituYW1lKTtcbiAgICAgICAgaWYgKHNlYXJjaE1vZGUgPT09IFNlYXJjaE1vZGVzLlNUQVJUX1dJVEhfSU5TVFJVQ1RPUikge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0RGVmaW5lZFZhbHVlKGluc3RydWN0b3JWZXJzaW9uLCBoaWRkZW5WZXJzaW9uLCBzdGFydGluZ1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWFyY2hNb2RlID09PSBTZWFyY2hNb2Rlcy5FVkVSWVdIRVJFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3REZWZpbmVkVmFsdWUoZGVmYXVsdFZlcnNpb24sIHN0dWRlbnRWZXJzaW9uLCBnZW5lcmF0ZWRWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0b3JWZXJzaW9uLCBoaWRkZW5WZXJzaW9uLCBzdGFydGluZ1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yRmlsZUluTGlzdF8obW9kZWxMaXN0LCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBtb2RlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtb2RlbExpc3RbaV0uZmlsZW5hbWUoKSA9PT0gZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2VhcmNoRm9yU3BlY2lhbEZpbGVzXyhmaWxlbmFtZSwgc2VhcmNoTW9kZSkge1xuICAgICAgICBpZiAoc2VhcmNoTW9kZSA9PT0gU2VhcmNoTW9kZXMuT05MWV9TVFVERU5UX0ZJTEVTKSB7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09IFwiYW5zd2VyLnB5XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9hbnN3ZXIucHlcIiwgdGhpcy5tYWluLm1vZGVsLnN1Ym1pc3Npb24uY29kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImFuc3dlci5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL2Fuc3dlci5weVwiLCB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5jb2RlKCkpO1xuICAgICAgICAgICAgY2FzZSBcIm9uX3J1bi5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL29uX3J1bi5weVwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5vblJ1bigpKTtcbiAgICAgICAgICAgIGNhc2UgXCJvbl9jaGFuZ2UucHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU1vY2tNb2RlbEZpbGUoXCJfaW5zdHJ1Y3Rvci9vbl9jaGFuZ2UucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UoKSk7XG4gICAgICAgICAgICBjYXNlIFwib25fZXZhbC5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL29uX2V2YWwubWRcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQub25FdmFsKCkpO1xuICAgICAgICAgICAgY2FzZSBcImluc3RydWN0aW9ucy5tZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL2luc3RydWN0aW9ucy5tZFwiLCB0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMoKSk7XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRpbmdfY29kZS5weVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTW9ja01vZGVsRmlsZShcIl9pbnN0cnVjdG9yL3N0YXJ0aW5nX2NvZGUucHlcIiwgdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc3RhcnRpbmdDb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbmV3RmlsZURpYWxvZyhraW5kKSB7XG4gICAgICAgIGxldCBib2R5ID0gJChORVdfSU5TVFJVQ1RPUl9GSUxFX0RJQUxPR19IVE1MKTtcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gYm9keS5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxlbmFtZVwiKTtcbiAgICAgICAgbGV0IGZpbGV0eXBlID0gYm9keS5maW5kKFwiLmJsb2NrcHktaW5zdHJ1Y3Rvci1maWxlLWRpYWxvZy1maWxldHlwZVwiKTtcbiAgICAgICAgbGV0IG5hbWVzcGFjZSA9IGJvZHkuZmluZChcIi5ibG9ja3B5LWluc3RydWN0b3ItZmlsZS1kaWFsb2ctbmFtZXNwYWNlXCIpO1xuICAgICAgICBsZXQgZXh0ZW5zaW9uUmVnZXggPSAvKD86XFwuKFteLl0rKSk/JC87XG4gICAgICAgIGZpbGVuYW1lLm9uKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuc2lvblJlZ2V4LmV4ZWMoZmlsZW5hbWUudmFsKCkpWzFdO1xuICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uID09PSB1bmRlZmluZWQgPyBcIk5vIGV4dGVuc2lvblwiIDogZXh0ZW5zaW9uO1xuICAgICAgICAgICAgLy9UT0RPOiB0aGlzLm1haW4uY29tcG9uZW50cy5lZGl0b3JzLmdldEVkaXRvckZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIGZpbGV0eXBlLnRleHQoZXh0ZW5zaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB5ZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImluc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IG5hbWVzcGFjZS52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJzdGFydGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJeXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWxlbmFtZS52YWwoKSkge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcHJlZml4K2ZpbGVuYW1lLnZhbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV3RmlsZShmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJvZHkuc3VibWl0KChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB5ZXMoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLmNvbmZpcm0oXCJNYWtlIE5ldyBGaWxlXCIsIGJvZHksIHllcywgKCk9Pnt9LCBcIkFkZFwiKTtcbiAgICB9XG59IiwiLy9UT0RPOiBNb3ZlIGdldCBsaW5rIGRvd24gdG8gZm9vdGVyLCByZW1vdmUgdmVydGljYWwgYmFyIGZyb20gcXVpY2stbWVudVxuZXhwb3J0IGxldCBGT09URVJfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJjb2wtbWQtMTIgYmxvY2tweS1wYW5lbCBibG9ja3B5LXN0YXR1c1wiPlxuICAgIDxkaXY+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvYWRBc3NpZ25tZW50JylcIj5Mb2FkIEFzc2lnbm1lbnRcbiAgICAgICAgICAgIDwhLS0ga28gaWY6IGRpc3BsYXkuaW5zdHJ1Y3RvciAtLT5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICBjbGFzcz1cImJsb2NrcHktZm9yY2UtbG9hZC1hc3NpZ25tZW50LWZpbGUgYmxvY2tweS1oaWRkZW4tZmlsZVwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJhcHBsaWNhdGlvbi9KU09OXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImV2ZW50OiB7Y2hhbmdlOiB1aS5zZXJ2ZXIuZm9yY2UubG9hZEFzc2lnbm1lbnR9XCI+XG4gICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgPC9sYWJlbD4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ3NhdmVBc3NpZ25tZW50JylcIj5TYXZlIEFzc2lnbm1lbnQ8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2FkRmlsZScpXCI+TG9hZCBGaWxlPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnc2F2ZUZpbGUnKVwiPlNhdmUgRmlsZTwvc3Bhbj4sIFxuICAgICAgICA8c3BhbiBjbGFzcz1cImJhZGdlXCIgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLnNlcnZlci5zdGF0dXMoJ2xvYWREYXRhc2V0JylcIj5Mb2FkIERhdGFzZXQ8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZVwiIGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZXJ2ZXIuc3RhdHVzKCdsb2dFdmVudCcpXCI+TG9nIEV2ZW50PC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygndXBkYXRlU3VibWlzc2lvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiB1aS5zZXJ2ZXIuZm9yY2UudXBkYXRlU3VibWlzc2lvblwiPlVwZGF0ZSBTdWJtaXNzaW9uPC9zcGFuPiwgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYmFkZ2VcIiBkYXRhLWJpbmQ9XCJjbGFzczogdWkuc2VydmVyLnN0YXR1cygnb25FeGVjdXRpb24nKVwiPkV4ZWN1dGlvbjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHVpLnNlcnZlci5tZXNzYWdlc1wiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2PlxuICAgICAgICA8c3Bhbj5Vc2VyOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmlkXCI+PC9zcGFuPiAoPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5uYW1lXCI+PC9zcGFuPiwgPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogdXNlci5yb2xlXCI+PC9zcGFuPik8L3NwYW4+LCBcbiAgICAgICAgPHNwYW4+Q291cnNlOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmNvdXJzZUlkXCI+PC9zcGFuPjwvc3Bhbj4sXG4gICAgICAgIDxzcGFuPkdyb3VwOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiB1c2VyLmdyb3VwSWRcIj48L3NwYW4+PC9zcGFuPixcbiAgICAgICAgPHNwYW4+QXNzaWdubWVudDogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogYXNzaWdubWVudC5pZFwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5Bc3NpZ25tZW50IFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IGFzc2lnbm1lbnQudmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5TdWJtaXNzaW9uOiBcbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24uaWRcIj48L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9XCJpZjogc3VibWlzc2lvbi5vd25lcklkKCkgIT0gdXNlci5pZCgpXCI+XG4gICAgICAgICAgICAgICAgKE93bmVyIElEOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLm93bmVySWQoKVwiPjwvc3Bhbj4pXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvc3Bhbj4sIFxuICAgICAgICA8c3Bhbj5TdWJtaXNzaW9uIFZlcnNpb246IDxzcGFuIGRhdGEtYmluZD1cInRleHQ6IHN1Ym1pc3Npb24udmVyc2lvblwiPjwvc3Bhbj48L3NwYW4+LFxuICAgICAgICA8c3Bhbj5FZGl0b3IgVmVyc2lvbjogPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogZGlzcGxheS5lZGl0b3JWZXJzaW9uXCI+PC9zcGFuPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYDsiLCIvLyBUT0RPOiBTaG91bGQgZGlzYWJsZSBidXR0b25zIGlmIHdlIGNhbid0IGFjdGl2YXRlIHRoZW0uXG5cbmV4cG9ydCBjb25zdCBISVNUT1JZX1RPT0xCQVJfSFRNTCA9IGBcbjxkaXYgY2xhc3M9XCJibG9ja3B5LWhpc3RvcnktdG9vbGJhciBjb2wtbWQtMTJcIiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiBkaXNwbGF5Lmhpc3RvcnlNb2RlXCI+XG5cbiAgICA8Zm9ybSBjbGFzcz1cImZvcm0taW5saW5lXCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJibG9ja3B5LWhpc3Rvcnktc3RhcnQgYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5zdGFydFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWJhY2t3YXJkJz48L3NwYW4+IFN0YXJ0XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBtci0yXCIgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuZWRpdG9ycy5weXRob24uaGlzdG9yeS5wcmV2aW91c1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1iYWNrd2FyZCc+PC9zcGFuPiBQcmV2aW91c1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cImJsb2NrcHktaGlzdG9yeS1zZWxlY3RvciBmb3JtLWNvbnRyb2wgY3VzdG9tLXNlbGVjdCBtci0yXCIgYXJpYS10aXRsZT1cIkhpc3RvcnkgU2VsZWN0b3JcIj5cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5LnVzZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1maWxlLWltcG9ydCc+PC9zcGFuPiBVc2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IG1yLTJcIiB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5lZGl0b3JzLnB5dGhvbi5oaXN0b3J5Lm5leHRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZm9yd2FyZCc+PC9zcGFuPiBOZXh0XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLmVkaXRvcnMucHl0aG9uLmhpc3RvcnkubW9zdFJlY2VudFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1zdGVwLWZvcndhcmQnPjwvc3Bhbj4gTW9zdCBSZWNlbnRcbiAgICAgICAgPC9idXR0b24+XG4gICAgPC9mb3JtPlxuPC9kaXY+XG5gO1xuXG4vKipcbiAqIEFuIG9iamVjdCBmb3IgZGlzcGxheWluZyB0aGUgdXNlcidzIGNvZGluZyBsb2dzICh0aGVpciBoaXN0b3J5KS5cbiAqIEEgbGlnaHR3ZWlnaHQgY29tcG9uZW50LCBpdHMgb25seSBqb2IgaXMgdG8gb3BlbiBhIGRpYWxvZy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtCbG9ja1B5SGlzdG9yeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWluIC0gVGhlIG1haW4gQmxvY2tQeSBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tQeUhpc3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5lZGl0RXZlbnRzID0gW107XG4gICAgfVxuXG4gICAgbG9hZChoaXN0b3J5KSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgICAgIHRoaXMuZWRpdEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJChcIi5ibG9ja3B5LWhpc3Rvcnktc2VsZWN0b3JcIikuZW1wdHkoKTtcbiAgICAgICAgbGV0IGVkaXRJZCA9IDA7XG4gICAgICAgIGhpc3RvcnlcbiAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiAoXG4gICAgICAgICAgICAgICAgIWVudHJ5LmZpbGVfcGF0aC5zdGFydHNXaXRoKFwiX2luc3RydWN0b3IuXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiQ29tcGlsZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmV2ZW50X3R5cGUgIT09IFwiSW50ZXJ2ZW50aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLm1haW4ubW9kZWwuYXNzaWdubWVudC5oaWRkZW4oKSB8fCBlbnRyeS5ldmVudF90eXBlICE9PSBcIlgtU3VibWlzc2lvbi5MTVNcIilcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50X3R5cGUgPSBSRU1BUF9FVkVOVF9UWVBFU1tlbnRyeS5ldmVudF90eXBlXSB8fCBlbnRyeS5ldmVudF90eXBlO1xuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5ZWQgPSBwcmV0dHlQcmludERhdGVUaW1lKGVudHJ5LmNsaWVudF90aW1lc3RhbXApICtcIiAtIFwiK2V2ZW50X3R5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRpc2FibGUgPSAoZW50cnkuZXZlbnRfdHlwZSAhPT0gXCJGaWxlLkVkaXRcIik7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbiA9ICQoXCI8b3B0aW9uPjwvb3B0aW9uPlwiLCB7dGV4dDogZGlzcGxheWVkLCBkaXNhYmxlZDogZGlzYWJsZX0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRWRpdEV2ZW50KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uYXR0cihcInZhbHVlXCIsIGVkaXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdEV2ZW50cy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdElkICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuYXBwZW5kKG9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5tYXgoMCwgZWRpdElkLTEpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5jaGFuZ2UoKGV2dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW92ZVRvU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKDApO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIG1vdmVQcmV2aW91cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5tYXgoMCwgY3VycmVudElkLTEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3IoKTtcbiAgICB9XG5cbiAgICBtb3ZlTmV4dCgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci52YWwoTWF0aC5taW4odGhpcy5lZGl0RXZlbnRzLmxlbmd0aC0xLCBjdXJyZW50SWQrMSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvcigpO1xuICAgIH1cblxuICAgIG1vdmVUb01vc3RSZWNlbnQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IudmFsKHRoaXMuZWRpdEV2ZW50cy5sZW5ndGgtMSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWRpdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0RXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5zZXRDb2RlKHRoaXMuZWRpdEV2ZW50c1tjdXJyZW50SWRdLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0RXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJZCA9IHBhcnNlSW50KHRoaXMuc2VsZWN0b3IudmFsKCksIDEwKTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5lZGl0RXZlbnRzW2N1cnJlbnRJZF0ubWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC51aS5lZGl0b3JzLnB5dGhvbi50dXJuT2ZmSGlzdG9yeU1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5maWxlLmhhbmRsZShjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRWRpdEV2ZW50KGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAoKGVudHJ5LmV2ZW50X3R5cGUgPT09IFwiRmlsZS5FZGl0XCIgfHxcbiAgICAgICAgICAgICAgICAgZW50cnkuZXZlbnRfdHlwZSA9PT0gXCJGaWxlLkNyZWF0ZVwiKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LmZpbGVuYW1lKCkgPT09IGVudHJ5LmZpbGVfcGF0aCk7XG4gICAgfVxuXG59XG5cbmNvbnN0IFJFTUFQX0VWRU5UX1RZUEVTID0ge1xuICAgIFwiU2Vzc2lvbi5TdGFydFwiOiBcIkJlZ2FuIHNlc3Npb25cIixcbiAgICBcIlgtSVAuQ2hhbmdlXCI6IFwiQ2hhbmdlZCBJUCBhZGRyZXNzXCIsXG4gICAgXCJGaWxlLkVkaXRcIjogXCJFZGl0ZWQgY29kZVwiLFxuICAgIFwiRmlsZS5DcmVhdGVcIjogXCJTdGFydGVkIGFzc2lnbm1lbnRcIixcbiAgICBcIlJ1bi5Qcm9ncmFtXCI6IFwiUmFuIHByb2dyYW1cIixcbiAgICBcIkNvbXBpbGUuRXJyb3JcIjogXCJTeW50YXggZXJyb3JcIixcbiAgICBcIlgtU3VibWlzc2lvbi5MTVNcIjogXCJVcGRhdGVkIGdyYWRlXCJcbn07XG5cbmNvbnN0IG1vbnRoTmFtZXMgPSBbXG4gICAgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIixcbiAgICBcIkFwclwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsXG4gICAgXCJBdWdcIiwgXCJTZXB0XCIsIFwiT2N0XCIsXG4gICAgXCJOb3ZcIiwgXCJEZWNcIlxuXTtcbmNvbnN0IHdlZWtEYXlzID0gW1xuICAgIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsXG4gICAgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIixcbiAgICBcIlNhdFwiXG5dO1xuXG5mdW5jdGlvbiBpc1NhbWVEYXkoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiBmaXJzdC5nZXREYXRlKCkgPT09IHNlY29uZC5nZXREYXRlKCkgJiZcbiAgICAgICAgZmlyc3QuZ2V0TW9udGgoKSA9PT0gc2Vjb25kLmdldE1vbnRoKCkgJiZcbiAgICAgICAgZmlyc3QuZ2V0RnVsbFllYXIoKSA9PT0gc2Vjb25kLmdldEZ1bGxZZWFyKCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGEgZGF0ZS90aW1lIHN0cmluZyBhbmQgcmV3cml0ZSBpdCBhcyBzb21ldGhpbmdcbiAqIG1vcmUgaHVtYW4gcmVhZGFibGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGltZVN0cmluZyAtIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSAoXCJZWVlZTU1ERCBISE1NU1NcIilcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gQSBodW1hbi1yZWFkYWJsZSB0aW1lIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJldHR5UHJpbnREYXRlVGltZSh0aW1lU3RyaW5nKSB7XG4gICAgLypsZXQgeWVhciA9IHRpbWVTdHJpbmcuc2xpY2UoMCwgNCksXG4gICAgICAgIG1vbnRoID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSg0LCA2KSwgMTApLTEsXG4gICAgICAgIGRheSA9IHRpbWVTdHJpbmcuc2xpY2UoNiwgOCksXG4gICAgICAgIGhvdXIgPSB0aW1lU3RyaW5nLnNsaWNlKDksIDExKSxcbiAgICAgICAgbWludXRlcyA9IHRpbWVTdHJpbmcuc2xpY2UoMTEsIDEzKSxcbiAgICAgICAgc2Vjb25kcyA9IHRpbWVTdHJpbmcuc2xpY2UoMTMsIDE1KTsqL1xuICAgIC8vIFRPRE86IEhhbmRsZSB0aW1lem9uZXMgY29ycmVjdGx5XG4gICAgaWYgKHRpbWVTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJVbmRlZmluZWQgVGltZVwiO1xuICAgIH1cbiAgICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgcGFzdCA9IG5ldyBEYXRlKHBhcnNlSW50KHRpbWVTdHJpbmcsIDEwKSk7XG4gICAgaWYgKGlzU2FtZURheShub3csIHBhc3QpKSB7XG4gICAgICAgIHJldHVybiBcIlRvZGF5IGF0IFwiK3Bhc3QudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRheVN0ciA9IHdlZWtEYXlzW3Bhc3QuZ2V0RGF5KCldO1xuICAgICAgICBsZXQgbW9udGhTdHIgPSBtb250aE5hbWVzW3Bhc3QuZ2V0TW9udGgoKV07XG4gICAgICAgIGxldCBkYXRlID0gZGF5U3RyICsgXCIsIFwiICsgbW9udGhTdHIgKyBcIiBcIiArIHBhc3QuZ2V0RGF0ZSgpO1xuICAgICAgICBpZiAobm93LmdldEZ1bGxZZWFyKCkgPT09IHBhc3QuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgKyBcIiBhdCBcIitwYXN0LnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgKyBcIiwgXCIrcGFzdC5nZXRGdWxsWWVhcigpICsgXCIgYXQgXCIrcGFzdC50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIE9wZW5zIHRoZSBoaXN0b3J5IGRpYWxvZyBib3guIFRoaXMgcmVxdWlyZXMgYSB0cmlwIHRvIHRoZSBzZXJ2ZXIgYW5kXG4gKiBvY2N1cnMgYXN5bmNocm9ub3VzbHkuIFRoZSB1c2VycycgY29kZSBpcyBzaG93biBpbiBwcmVmb3JtYXR0ZWQgdGV4dFxuICogdGFncyAobm8gY29kZSBoaWdobGlnaHRpbmcgY3VycmVudGx5KSBhbG9uZyB3aXRoIHRoZSB0aW1lc3RhbXAuXG4gKi9cbkJsb2NrUHlIaXN0b3J5LnByb3RvdHlwZS5vcGVuRGlhbG9nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpYWxvZyA9IHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZztcbiAgICB2YXIgYm9keSA9IFwiPHByZT5hID0gMDwvcHJlPlwiO1xuICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnNlcnZlci5nZXRIaXN0b3J5KGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGJvZHkgPSBkYXRhLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbXBsZXRlLCBlbGVtKSB7IFxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlX3N0ciA9IHByZXR0eVByaW50RGF0ZVRpbWUoZWxlbS50aW1lKTtcbiAgICAgICAgICAgIHZhciBuZXdfbGluZSA9IFwiPGI+XCIrY29tcGxldGVfc3RyK1wiPC9iPjxicj48cHJlPlwiK2VsZW0uY29kZStcIjwvcHJlPlwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlK1wiXFxuXCIrbmV3X2xpbmU7XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBkaWFsb2cuc2hvdyhcIldvcmsgSGlzdG9yeVwiLCBib2R5LCBmdW5jdGlvbigpIHt9KTtcbiAgICB9KTtcbn07IiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIG1haW4gSFRNTCBvZiBCbG9ja1B5IGludGVyZmFjZSwgYW5kIGhlbHBlciBmdW5jdGlvbnMuXG4gKiBDb21iaW5lcyBhIGxvdCBvZiBIVE1MIGZyb20gY29tcG9uZW50cy5cbiAqXG4gKiBIZXJlJ3MgdGhlIGxheW91dDpcbiAqICBSb3cgMTogSGVhZGVyIGFuZCBRdWljayBNZW51XG4gKiAgUm93IDI6IENvbnNvbGUgYW5kIEZlZWRiYWNrXG4gKiAgUm93IDM6IEZpbGUgTmF2aWdhdGlvblxuICogIFJvdyA0OiBWaWV3IFJvd1xuICogIFJvdyA1OiBGb290ZXIgUm93XG4gKi9cblxuaW1wb3J0IHtUUkFDRV9IVE1MfSBmcm9tIFwidHJhY2UuanNcIjtcbmltcG9ydCB7RElBTE9HX0hUTUx9IGZyb20gXCJkaWFsb2cuanNcIjtcbmltcG9ydCB7RkVFREJBQ0tfSFRNTH0gZnJvbSBcImZlZWRiYWNrLmpzXCI7XG5pbXBvcnQge0ZJTEVTX0hUTUx9IGZyb20gXCJmaWxlcy5qc1wiO1xuaW1wb3J0IHtGT09URVJfSFRNTH0gZnJvbSBcImZvb3Rlci5qc1wiO1xuaW1wb3J0IHtFRElUT1JTX0hUTUx9IGZyb20gXCJlZGl0b3JzLmpzXCI7XG5pbXBvcnQge0NPTlNPTEVfSFRNTH0gZnJvbSBcImNvbnNvbGUuanNcIjtcblxuLyoqXG4gKiBUaGUgZGlmZmVyZW50IGxheW91dCBvcHRpb25zIG9mIHRoZSBwYW5lcyBpbiB0aGUgc2Vjb25kIHJvdyBvZiB0aGUgbGF5b3V0LlxuICogQGVudW0ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBTZWNvbmRSb3dTZWNvbmRQYW5lbE9wdGlvbnMgPSB7XG4gICAgRkVFREJBQ0s6IFwiZmVlZGJhY2tcIixcbiAgICBUUkFDRTogXCJ0cmFjZVwiLFxuICAgIE5PTkU6IFwibm9uZVwiXG59O1xuXG4vKipcbiAqIFNldHVwIGFueSBhZGRpdGlvbmFsIEtub2Nrb3V0IHN1YnNjcmlwdGlvbnMgdG8gZmlyZSBvbiBpbnRlcmZhY2UgY2hhbmdlcy5cbiAqIEBwYXJhbSBzZWxmXG4gKiBAcGFyYW0gbW9kZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHRyYUludGVyZmFjZVN1YnNjcmlwdGlvbnMoc2VsZiwgbW9kZWwpIHtcbiAgICAvLyBIaWdobGlnaHQgTWFya2Rvd24gd2hlbiBpbnN0cnVjdGlvbnMgdXBkYXRlXG4gICAgbGV0IGhpZ2hsaWdodFRpbWVvdXQgPSBudWxsO1xuICAgIG1vZGVsLnVpLmluc3RydWN0aW9ucy5jdXJyZW50LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmIChoaWdobGlnaHRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaGlnaGxpZ2h0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaGxpZ2h0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIuZmluZChcIi5ibG9ja3B5LWluc3RydWN0aW9ucyBwcmUgY29kZVwiKS5tYXAoIChpLCBibG9jaykgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5obGpzLmhpZ2hsaWdodEJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCA0MDApO1xuICAgIH0pO1xuICAgIC8vIFByb3ZpZGUgRnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgbW9kZWwuZGlzcGxheS5mdWxsc2NyZWVuLnN1YnNjcmliZSgoaXNGdWxsc2NyZWVuKSA9PiB7XG4gICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5SZXF1ZXN0XCIsIFwiXCIsIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsc2NyZWVuLnRvU3RyaW5nKCksIFwiXCIpO1xuICAgICAgICBpZiAoaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBuYXZpZ2F0aW9uVUkgY291bGQgYWxsb3cgdXMgdG8gZm9yY2UgY29udHJvbHMgdG8gc2hvd1xuICAgICAgICAgICAgbW9kZWwuY29uZmlndXJhdGlvbi5jb250YWluZXIucGFyZW50KClbMF0ucmVxdWVzdEZ1bGxzY3JlZW4oKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYEVycm9yIGF0dGVtcHRpbmcgdG8gZW5hYmxlIGZ1bGwtc2NyZWVuIG1vZGU6ICR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5uYW1lfSlgO1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9uZW50cy5zZXJ2ZXIubG9nRXZlbnQoXCJYLURpc3BsYXkuRnVsbHNjcmVlbi5FcnJvclwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSwgIFwiXCIpO1xuICAgICAgICAgICAgICAgIGFsZXJ0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb25lbnRzLnNlcnZlci5sb2dFdmVudChcIlgtRGlzcGxheS5GdWxsc2NyZWVuLlN1Y2Nlc3NcIiwgXCJcIiwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbih0cnVlKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5jb25maWd1cmF0aW9uLmNvbnRhaW5lci5jc3MoXCJvdmVyZmxvdy15XCIsIFwiYXV0b1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvbmVudHMuc2VydmVyLmxvZ0V2ZW50KFwiWC1EaXNwbGF5LkZ1bGxzY3JlZW4uRXhpdFwiLCBcIlwiLCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsc2NyZWVuLnRvU3RyaW5nKCksIFwiXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsLmRpc3BsYXkuZnVsbHNjcmVlbihmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBUT0RPOiBHZXQgc2hhcmVhYmxlIGxpbmsgYnV0dG9uXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW50ZXJmYWNlKG1haW4pIHtcbiAgICByZXR1cm4gYFxuPGRpdiBjbGFzcz0nYmxvY2tweS1jb250ZW50IGNvbnRhaW5lci1mbHVpZCc+XG5cbiAgICA8IS0tIERpYWxvZyAtLT5cbiAgICAke0RJQUxPR19IVE1MfVxuICAgIFxuICAgIDwhLS0gSGlkZGVuIENhcHR1cmUgQ2FudmFzIC0tPlxuICAgIDxjYW52YXMgaWQ9J2NhcHR1cmUtY2FudmFzJyBjbGFzcz0nZC1ub25lJyByb2xlPVwicHJlc2VudGF0aW9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jYW52YXM+XG4gICAgXG4gICAgPCEtLSBSb3cgMTogSGVhZGVyIGFuZCBRdWljayBNZW51IC0tPlxuICAgIDxkaXYgY2xhc3M9J3Jvdyc+XG4gICAgICAgICBcbiAgICAgICAgIDwhLS0gRGVzY3JpcHRpb24gLS0+XG4gICAgICAgICA8ZGl2IGNsYXNzPSdjb2wtbWQtOSBibG9ja3B5LXBhbmVsIGJsb2NrcHktaGVhZGVyJ1xuICAgICAgICAgICAgICAgcm9sZT0naGVhZGluZycgYXJpYS1sYWJlbD0nQXNzaWdubWVudCBEZXNjcmlwdGlvbic+XG4gICAgICAgICBcbiAgICAgICAgICAgIDwhLS0gQXNzaWdubWVudCBOYW1lIC0tPlxuICAgICAgICAgICAgPHNwYW4gcm9sZT0naGVhZGluZycgYXJpYS1sZXZlbD0nMSdcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmxvY2tweS1uYW1lXCI+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz5CbG9ja1B5OiA8L3N0cm9uZz4gXG4gICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kPSd0ZXh0OiBhc3NpZ25tZW50Lm5hbWUnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBSZXNldCBJbnN0cnVjdGlvbnMgQnV0dG9uIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJsb2NrcHktaW5zdHJ1Y3Rpb25zLXJlc2V0XCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5pbnN0cnVjdGlvbnMuaXNDaGFuZ2VkXCI+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJmbG9hdC1yaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS5pbnN0cnVjdGlvbnMucmVzZXRcIlxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiXCI+XG4gICAgICAgICAgICAgICAgICAgIFJlc2V0IGluc3RydWN0aW9uczwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8IS0tIEluc3RydWN0aW9ucyAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Jsb2NrcHktaW5zdHJ1Y3Rpb25zJ1xuICAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJodG1sOiB1aS5pbnN0cnVjdGlvbnMuY3VycmVudFwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBjbGFzcz0nY29sLW1kLTMgYmxvY2tweS1wYW5lbCBibG9ja3B5LXF1aWNrLW1lbnUnXG4gICAgICAgICAgICAgcm9sZT0nbWVudWJhcicgYXJpYS1sYWJlbD0nUXVpY2sgTWVudScgdGl0bGU9XCJRdWljayBNZW51XCI+XG4gICAgICAgICAgICA8IS0tIEdldCBTaGFyZWFibGUgTGluayAtLT5cbiAgICAgICAgICAgIDwhLS08YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIj5cbiAgICAgICAgICAgICAgICBHZXQgc2hhcmVhYmxlIGxpbms8L2J1dHRvbj4tLT5cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZD1cInZpc2libGU6IHVpLm1lbnUuaXNTdWJtaXR0ZWRcIj5cbiAgICAgICAgICAgICAgICBZb3VyIHN1Ym1pc3Npb24gaXMgcmVhZHkgdG8gYmUgcmV2aWV3ZWQhPC9zcGFuPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB1aS5tZW51LmNhbk1hcmtTdWJtaXR0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB1aS5tZW51LnRleHRNYXJrU3VibWl0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHVpLm1lbnUuY2xpY2tNYXJrU3VibWl0dGVkXCI+PC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFZpZXcgYXMgaW5zdHJ1Y3RvciAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNoZWNrXCJcbiAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwidmlzaWJsZTogdWkucm9sZS5pc0dyYWRlclwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY2hlY2staW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIlwiIGlkPVwiYmxvY2tweS1hcy1pbnN0cnVjdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogZGlzcGxheS5pbnN0cnVjdG9yXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1jaGVjay1sYWJlbFwiIGZvcj1cImJsb2NrcHktYXMtaW5zdHJ1Y3RvclwiPlxuICAgICAgICAgICAgICAgICAgICBWaWV3IGFzIGluc3RydWN0b3JcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIFJlYWRvbmx5IG1vZGUgZm9yIHNweWluZyAtLT5cbiAgICAgICAgICAgIDxkaXYgZGF0YS1iaW5kPVwiaWY6IHN1Ym1pc3Npb24ub3duZXJJZCgpICE9IHVzZXIuaWQoKVwiPlxuICAgICAgICAgICAgICAgIE93bmVyOiA8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiBzdWJtaXNzaW9uLm93bmVySWRcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY2hlY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jaGVjay1pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiYmxvY2tweS1yZWFkLW9ubHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2hlY2tlZDogZGlzcGxheS5yZWFkT25seVwiPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWNoZWNrLWxhYmVsXCIgZm9yPVwiYmxvY2tweS1yZWFkLW9ubHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRvbmx5P1xuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPCEtLSBGdWxsc2NyZWVuIGJ1dHRvbiAtLT5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLm1lbnUuY2xpY2tGdWxsc2NyZWVuXCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkZ1bGwgU2NyZWVuXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcycgZGF0YS1iaW5kPVwiY2xhc3M6IHVpLm1lbnUudGV4dEZ1bGxzY3JlZW5cIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gRWRpdCBRdWV1ZWQgSW5wdXRzIC0tPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnkgYnRuLXNtXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS5lZGl0SW5wdXRzLCB2aXNpYmxlOiB1aS5tZW51LnNob3dRdWV1ZWRJbnB1dHNcIiB0aXRsZT1cIkVkaXQgSW5wdXRzXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1saXN0LWFsdCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8IS0tIFRvZ2dsZSBJbWFnZSBSZW5kZXJpbmcgLS0+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIlxuICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkubWVudS50b2dnbGVJbWFnZXNcIiB0aXRsZT1cIlRvZ2dsZSBJbWFnZXNcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcyBmYS1pbWFnZXNcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwhLS0gUGluayBCdWcgZm9yIGFjdHVhbCBlcnJvcnMgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJsb2NrcHktc3R1ZGVudC1lcnJvciBmYXMgZmEtYnVnXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9J3Jvdyc+XG4gICAgPCEtLSBSb3cgMjogQ29uc29sZSBhbmQgRmVlZGJhY2sgLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuc2Vjb25kUm93LmlzQWxsVmlzaWJsZSAtLT5cbiAgICA8ZGl2IGRhdGEtYmluZD1cImNsYXNzOiB1aS5zZWNvbmRSb3cud2lkdGhcIj5cbiAgICA8ZGl2IGNsYXNzPSdyb3cnPlxuICAgICAgICA8IS0tIENvbnNvbGUgLS0+XG4gICAgICAgICR7Q09OU09MRV9IVE1MfVxuICAgICAgICA8IS0tIEZlZWRiYWNrIC0tPlxuICAgICAgICA8IS0tIGtvIGlmOiB1aS5zZWNvbmRSb3cuaXNGZWVkYmFja1Zpc2libGUgLS0+XG4gICAgICAgICR7RkVFREJBQ0tfSFRNTH1cbiAgICAgICAgPCEtLSAva28gLS0+XG4gICAgICAgIDwhLS0gVHJhY2UgLS0+XG4gICAgICAgIDwhLS0ga28gaWY6IHVpLnNlY29uZFJvdy5pc1RyYWNlVmlzaWJsZSAtLT5cbiAgICAgICAgJHtUUkFDRV9IVE1MfVxuICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIC9rbyAtLT5cbiAgICBcbiAgICA8IS0tIFJvdyAzOiBGaWxlIE5hdmlnYXRpb24gLS0+XG4gICAgPCEtLSBrbyBpZjogdWkuZmlsZXMudmlzaWJsZSAtLT5cbiAgICAke0ZJTEVTX0hUTUx9XG4gICAgPCEtLSAva28gLS0+XG4gICAgXG4gICAgPCEtLSBSb3cgNDogVmlldyBSb3cgLS0+XG4gICAgJHtFRElUT1JTX0hUTUx9XG4gICAgPC9kaXY+XG4gICAgXG4gICAgXG4gICAgPCEtLSBSb3cgNTogRm9vdGVyIFJvdyAtLT4gICAgXG4gICAgPCEtLSBrbyBpZjogdWkuZm9vdGVyLnZpc2libGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAke0ZPT1RFUl9IVE1MfVxuICAgIDwvZGl2PlxuICAgIDwhLS0gL2tvIC0tPlxuICAgIFxuPC9kaXY+XG4gICAgYDtcbn0iLCJpbXBvcnQge0xvY2FsU3RvcmFnZVdyYXBwZXJ9IGZyb20gXCIuL3N0b3JhZ2VcIjtcbmltcG9ydCB7bG9hZEFzc2lnbm1lbnRTZXR0aW5ncywgc2F2ZUFzc2lnbm1lbnRTZXR0aW5nc30gZnJvbSBcIi4vZWRpdG9yL2Fzc2lnbm1lbnRfc2V0dGluZ3NcIjtcblxuLyoqXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGxldCBTdGF0dXNTdGF0ZSA9IHtcbiAgICBSRUFEWTogXCJyZWFkeVwiLFxuICAgIEFDVElWRTogXCJhY3RpdmVcIixcbiAgICBSRVRSWUlORzogXCJyZXRyeWluZ1wiLFxuICAgIEZBSUxFRDogXCJmYWlsZWRcIixcbiAgICBPRkZMSU5FOiBcIm9mZmxpbmVcIlxufTtcblxuLyoqXG4gKiBPYmplY3QgZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgZXh0ZXJuYWwgc2VydmVycy4gVGhpcyBpbmNsdWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuICogc2F2aW5nIGFuZCBsb2FkaW5nIGZpbGVzLCBsb2dnaW5nIGV2ZW50cywgc2F2aW5nIGNvbXBsZXRpb25zLCBhbmQgcmV0cmlldmluZyBoaXN0b3J5LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0Jsb2NrUHlTZXJ2ZXJ9XG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbiAtIFRoZSBtYWluIEJsb2NrUHkgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJsb2NrUHlTZXJ2ZXIobWFpbikge1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICAvLyBTYXZlIFVSTHMgbG9jYWxseSBmb3IgcXVpY2tlciBhY2Nlc3NcbiAgICB0aGlzLnVybHMgPSBtYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24udXJscztcblxuICAgIC8vIEFkZCB0aGUgTG9jYWxTdG9yYWdlIGNvbm5lY3Rpb25cbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlV3JhcHBlcihcIkJMT0NLUFlcIik7XG5cbiAgICAvLyBGYXVsdFJlc2lzdGFudENhY2hlXG4gICAgdGhpcy5xdWV1ZSA9IHtcbiAgICAgICAgXCJsb2dFdmVudFwiOiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXREZWZhdWx0KFwibG9nRXZlbnRcIiwgXCJbXVwiKSksXG4gICAgICAgIFwidXBkYXRlU3VibWlzc2lvblwiOiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXREZWZhdWx0KFwidXBkYXRlU3VibWlzc2lvblwiLCBcIltdXCIpKVxuICAgIH07XG4gICAgdGhpcy5NQVhfUVVFVUVfU0laRSA9IHtcbiAgICAgICAgXCJsb2dFdmVudFwiOiAyMDAsXG4gICAgICAgIFwidXBkYXRlU3VibWlzc2lvblwiOiA1MFxuICAgIH07XG5cbiAgICB0aGlzLlRJTUVSX0RFTEFZID0gMTAwMDtcbiAgICB0aGlzLkZBSUxfREVMQVkgPSAyMDAwO1xuXG4gICAgdGhpcy50aW1lcnMgPSB7fTtcblxuICAgIHRoaXMub3ZlcmxheSA9IG51bGw7XG4gICAgdGhpcy5ibG9ja2luZ0F0dGVtcHRzID0gMDtcblxuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzID0gW107XG4gICAgdGhpcy5jcmVhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgdGhpcy5jaGVja0NhY2hlcygpO1xuXG4gICAgdGhpcy5hbHRMb2dFbnRyeSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIElQIGFkZHJlc3MgaGFzIGNoYW5nZWQsIGxvZ2dpbmcgYW4gZXZlbnQgaWYgdGhhdCBvY2N1cnMuXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY2hlY2tJUCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwiSVBcIikpIHtcbiAgICAgICAgICAgIGxldCBvbGRJUCA9IHRoaXMuc3RvcmFnZS5nZXQoXCJJUFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRJUCAhPT0gcmVzcG9uc2UuaXApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgXCJvbGRcIjogb2xkSVAsXG4gICAgICAgICAgICAgICAgICAgIFwibmV3XCI6IHJlc3BvbnNlLmlwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWx0TG9nRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHRMb2dFbnRyeShcIlgtSVAuQ2hhbmdlXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiWC1JUC5DaGFuZ2VcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFwiSVBcIiwgcmVzcG9uc2UuaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldChcIklQXCIsIHJlc3BvbnNlLmlwKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGVyZSBoYXZlIGJlZW4gcHJldmlvdXMgZmFpbHVyZXMgY2FjaGVkLCBhbmQgaWYgc28gcmV0cmllcyB0aGVtLlxuICogVE9ETzogdXBkYXRlXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNoZWNrQ2FjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwic2F2ZUFzc2lnbm1lbnRcIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXQoXCJzYXZlQXNzaWdubWVudFwiKSk7XG4gICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBcImFzc2lnbm1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2F2ZUFzc2lnbm1lbnRcIiwgdGhpcy5USU1FUl9ERUxBWSk7XG4gICAgfVxuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzLmZvckVhY2goKGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaGFzKFwic2F2ZUZpbGVcIiArIGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXQoXCJzYXZlRmlsZVwiICsgZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBmaWxlbmFtZSwgXCJzYXZlRmlsZVwiLCB0aGlzLlRJTUVSX0RFTEFZKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBzZXJ2ZXIgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucXVldWUpLmZvckVhY2goZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgIChmdW5jdGlvbiBwdXNoQW55UXVldWVkKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXIucXVldWVbZW5kcG9pbnRdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uoc2VydmVyLnF1ZXVlW2VuZHBvaW50XS5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBzZXJ2ZXIudXJsc1tlbmRwb2ludF07XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5fcG9zdFJldHJ5KGRhdGEsIGVuZHBvaW50LCAxMDAwLCBwdXNoQW55UXVldWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKHtcInN1Y2Nlc3NcIjogdHJ1ZX0pO1xuICAgIH0pO1xufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlRmlsZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtb2RlbCwgZmlsZW5hbWUpIHtcbiAgICBtb2RlbC5zdWJzY3JpYmUoKGNvbnRlbnRzKSA9PlxuICAgICAgICB0aGlzLm1haW4ubW9kZWwuZGlzcGxheS5hdXRvU2F2ZSgpID8gdGhpcy5zYXZlRmlsZShmaWxlbmFtZSwgY29udGVudHMpIDogZmFsc2UsIHRoaXMpO1xuICAgIHRoaXMuY2FjaGVkRmlsZW5hbWVzLnB1c2goZmlsZW5hbWUpO1xufTtcblxuLyoqXG4gKiBUT0RPOiBmaXhcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnN1Ym1pc3Npb24uY29kZSwgXCJhbnN3ZXIucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25SdW4sIFwiIW9uX3J1bi5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5vbkV2YWwsIFwiIW9uX2V2YWwucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLmFzc2lnbm1lbnQub25DaGFuZ2UsIFwiIW9uX2NoYW5nZS5weVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5pbnN0cnVjdGlvbnMsIFwiIWluc3RydWN0aW9ucy5tZFwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwuYXNzaWdubWVudC5zdGFydGluZ0NvZGUsIFwiXnN0YXJ0aW5nX2NvZGUucHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhU3R1ZGVudEZpbGVzLCBcIiNleHRyYV9zdHVkZW50X2ZpbGVzLmJsb2NrcHlcIik7XG4gICAgdGhpcy5jcmVhdGVGaWxlU3Vic2NyaXB0aW9uKG1vZGVsLnVpLmZpbGVzLmV4dHJhU3RhcnRpbmdGaWxlcywgXCIjZXh0cmFfc3RhcnRpbmdfZmlsZXMuYmxvY2tweVwiKTtcbiAgICB0aGlzLmNyZWF0ZUZpbGVTdWJzY3JpcHRpb24obW9kZWwudWkuZmlsZXMuZXh0cmFJbnN0cnVjdG9yRmlsZXMsIFwiI2V4dHJhX2luc3RydWN0b3JfZmlsZXMuYmxvY2tweVwiKTtcbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50TG9ncyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5vbmJsdXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nRXZlbnQoXCJTZXNzaW9uLkVuZFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHdpbmRvdy5vbmZvY3VzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ0V2ZW50KFwiU2Vzc2lvbi5TdGFydFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogQWRkIGluIGJlYWNvbj9cbn07XG5cbi8qKlxuICpcbiAqIFNvbWUgc3Vic2NyaXB0aW9ucyBoYXZlIHRvIGhhcHBlbiBhZnRlciBvdGhlciB0aGluZ3MgaGF2ZSBiZWVuIGxvYWRlZC5cbiAqIFJpZ2h0IG5vdyB0aGlzIGlzIGp1c3QgYWZ0ZXIgQ09SR0lTIGxpYnJhcmllcyBoYXZlIGJlZW4gbG9hZGVkLCBidXQgbWF5YmVcbiAqIHdlJ2xsIGFkZCBtb3JlIGxhdGVyIGFuZCB0aGlzIHdpbGwgbmVlZCB0byBiZSByZWZhY3RvcmVkLlxuICpcbiAqIFRPRE86IGZpeFxuICpcbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuZmluYWxpemVTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vdGhpcy5tYWluLm1vZGVsLmFzc2lnbm1lbnQuc2V0dGluZ3MuZGF0YXNldHMuc3Vic2NyaWJlKHRoaXMuc2F2ZUFzc2lnbm1lbnQuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGRlZmF1bHQgcGF5bG9hZCBmb3IgYW55IGNvbW11bmljYXRpb24gd2l0aCB0aGUgc2VydmVyIEFQSVxuICogQHJldHVybnMge3thc3NpZ25tZW50X2lkOiAqLCBjb3Vyc2VfaWQ6ICosIGdyb3VwX2lkOiAqLCB1c2VyX2lkOiAqLCB0aW1lem9uZTogKiwgdmVyc2lvbjogKiwgdGltZXN0YW1wOiAqfX1cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuY3JlYXRlU2VydmVyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgYXNzaWdubWVudCA9IHRoaXMubWFpbi5tb2RlbC5hc3NpZ25tZW50O1xuICAgIGxldCB1c2VyID0gdGhpcy5tYWluLm1vZGVsLnVzZXI7XG4gICAgbGV0IHN1Ym1pc3Npb24gPSB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbjtcbiAgICBsZXQgZGlzcGxheSA9IHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5O1xuICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBtaWNyb3NlY29uZHMgPSBub3cuZ2V0VGltZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiYXNzaWdubWVudF9pZFwiOiBhc3NpZ25tZW50LmlkKCksXG4gICAgICAgIFwiYXNzaWdubWVudF9ncm91cF9pZFwiOiB1c2VyLmdyb3VwSWQoKSxcbiAgICAgICAgXCJjb3Vyc2VfaWRcIjogdXNlci5jb3Vyc2VJZCgpLFxuICAgICAgICBcInN1Ym1pc3Npb25faWRcIjogc3VibWlzc2lvbi5pZCgpLFxuICAgICAgICBcInVzZXJfaWRcIjogdXNlci5pZCgpLFxuICAgICAgICBcInZlcnNpb25cIjogYXNzaWdubWVudC52ZXJzaW9uKCksXG4gICAgICAgIFwidGltZXN0YW1wXCI6IG1pY3Jvc2Vjb25kcyxcbiAgICAgICAgXCJ0aW1lem9uZVwiOiBub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgXCJwYXNzY29kZVwiOiBkaXNwbGF5LnBhc3Njb2RlKClcbiAgICB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0dXMgYW5kIG1lc3NhZ2UgZm9yIHRoZSByZWxldmFudCBlbmRwb2ludC5cbiAqIEBwYXJhbSBlbmRwb2ludCB7c3RyaW5nfSBvbmUgb2YgdGhlIFVSTCBlbmRwb2ludHNcbiAqIEBwYXJhbSBzdGF0dXMge1N0YXR1c1N0YXRlfVxuICogQHBhcmFtIG1lc3NhZ2Uge3N0cmluZz99XG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uIChlbmRwb2ludCwgc3RhdHVzLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5tYWluLm1vZGVsLnN0YXR1c1tlbmRwb2ludF0oc3RhdHVzKTtcbiAgICB0aGlzLm1haW4ubW9kZWwuc3RhdHVzW2VuZHBvaW50ICsgXCJNZXNzYWdlXCJdKG1lc3NhZ2UgfHwgXCJcIik7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYW4gb3ZlcmxheSBvbiB0aGUgc2NyZWVuIHRoYXQgYmxvY2tzIG9wZXJhdGlvbiB1bnRpbCB0aGUgc3lzdGVtIGlzIHJlYWR5LlxuICogVGhlIG92ZXJsYXkgZ2V0cyBwcm9ncmVzc2l2ZWx5IGRhcmtlciB0byBpbmRpY2F0ZSByZXBlYXRlZCBmYWlsdXJlcy5cbiAqL1xuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2hvd092ZXJsYXkgPSBmdW5jdGlvbiAoYXR0ZW1wdCkge1xuICAgIHRoaXMuYmxvY2tpbmdBdHRlbXB0cyArPSAxO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImJsb2NrcHktb3ZlcmxheVwiKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gJCgnPGRpdiBjbGFzcz1cImJsb2NrcHktb3ZlcmxheVwiPiA8L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGF0dGVtcHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCIjOTg4XCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiIzY1NVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiMzMzNcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYmxhY2tcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIFVuZG8gYSBsZXZlbCBvZiBvdmVybGF5OyBpZiB0aGlzIHdhcyB0aGUgbGFzdCBsZXZlbCwgcmVtb3ZlcyBpdCBmcm9tIHRoZSBzY3JlZW4uXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLmhpZGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYmxvY2tpbmdBdHRlbXB0cyAtPSAxO1xuICAgIGlmICh0aGlzLmJsb2NraW5nQXR0ZW1wdHMgPD0gMCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkucmVtb3ZlKCk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuX2VucXVldWVEYXRhID0gZnVuY3Rpb24gKGNhY2hlLCBkYXRhKSB7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgbm90IG92ZXJmaWxsZWQgdGhlIHF1ZXVlXG4gICAgbGV0IGxlbmd0aCA9IHRoaXMucXVldWVbY2FjaGVdLmxlbmd0aDtcbiAgICBsZXQgbWF4ID0gdGhpcy5NQVhfUVVFVUVfU0laRVtjYWNoZV07XG4gICAgaWYgKGxlbmd0aCA+IG1heCkge1xuICAgICAgICB0aGlzLnF1ZXVlW2NhY2hlXSA9IHRoaXMucXVldWVbY2FjaGVdLnNsaWNlKGxlbmd0aCAtIG1heCwgbWF4KTtcbiAgICB9XG4gICAgLy8gT25seSBhZGQgdGhlIGVsZW1lbnQgaWYgaXQncyBuZXdcbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5xdWV1ZVtjYWNoZV0uaW5kZXhPZihrZXkpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtjYWNoZV0ucHVzaChrZXkpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGNhY2hlLCBKU09OLnN0cmluZ2lmeSh0aGlzLnF1ZXVlW2NhY2hlXSkpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9kZXF1ZXVlRGF0YSA9IGZ1bmN0aW9uIChjYWNoZSwgZGF0YSkge1xuICAgIGxldCBrZXkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnF1ZXVlW2NhY2hlXS5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtjYWNoZV0uc3BsaWNlKGluZGV4KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldChjYWNoZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5xdWV1ZVtjYWNoZV0pKTtcbiAgICB9XG59O1xuXG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9wb3N0UmV0cnkgPSBmdW5jdGlvbiAoZGF0YSwgZW5kcG9pbnQsIGRlbGF5LCBjYWxsYmFjaykge1xuICAgIC8vIFRyaWdnZXIgcmVxdWVzdFxuICAgIGxldCBwb3N0UmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBhIGJhY2t1cCBvZiB0aGUgY3VycmVudCBwb3N0XG4gICAgICAgIHRoaXMuX2VucXVldWVEYXRhKGVuZHBvaW50LCBkYXRhKTtcbiAgICAgICAgJC5wb3N0KHRoaXMudXJsc1tlbmRwb2ludF0sIGRhdGEpXG4gICAgICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXF1ZXVlRGF0YShlbmRwb2ludCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tJUChyZXNwb25zZS5pcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIElmIHNlcnZlciByZXF1ZXN0IGlzIHRoZSBsYXRlc3Qgb25lLCB0aGVuIGxldCdzIHRyeSBpdCBhZ2FpbiBpbiBhIGJpdFxuICAgICAgICAgICAgLmZhaWwoKGVycm9yLCB0ZXh0U3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFVFJZSU5HLCB0ZXh0U3RhdHVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RSZXRyeShkYXRhLCBlbmRwb2ludCwgZGVsYXkgKyB0aGlzLkZBSUxfREVMQVksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIHBvc3RSZXF1ZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChwb3N0UmVxdWVzdCwgZGVsYXkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZSBhIEFKQVggcmVxdWVzdCB0aGF0LCB1cG9uIGZhaWx1cmUsIHdpbGwgY2hlY2sgdG8gc2VlIGlmIHRoaXMgd2FzIHRoZVxuICogbGF0ZXN0IGF0dGVtcHQgZm9yIHRoaXMgYGNhY2hlYCBtYXJrZXIuIElmIHNvLCBpdCB3aWxsIGF0dGVtcHQgYWdhaW4gdW50aWxcbiAqIHN1Y2Nlc3NmdWw7IG90aGVyd2lzZSwgaXQgZ2l2ZXMgdXAgdGhlIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgQUpBWC1yZWFkeSBkYXRhIHRvIGJlIHBvc3RlZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gVGhlIHVuaXF1ZSBuYW1lIGdpdmVuIHRvIHRoZSByZWxldmFudCB0aW1lclxuICogQHBhcmFtIHtTdHJpbmd9IGVuZHBvaW50IC0gVGhlIHVuaXF1ZSBuYW1lIGdpdmVuIHRvIHRoZSByZWxldmFudCBjYWNoZSBlbnRyeVxuICogQHBhcmFtIHtJbnRlZ2VyfSBkZWxheSAtIFRoZSBjdXJyZW50IG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmVcbiB0cnlpbmcgdGhlIHJlcXVlc3QgYWdhaW4uXG4gKi9cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9wb3N0TGF0ZXN0UmV0cnkgPSBmdW5jdGlvbiAoZGF0YSwgZmlsZW5hbWUsIGVuZHBvaW50LCBkZWxheSwgZmFpbHVyZUZ1bmN0aW9uLCBkb25lRnVuY3Rpb24pIHtcbiAgICBsZXQgY2FjaGUgPSBlbmRwb2ludCArIGZpbGVuYW1lO1xuICAgIGxldCByZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIGEgYmFja3VwIG9mIHRoZSBjdXJyZW50IHBvc3RcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldChjYWNoZSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBsZXQgdGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAkLnBvc3QodGhpcy51cmxzW2VuZHBvaW50XSwgZGF0YSlcbiAgICAgICAgICAgIC5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tJUChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNlcnZlciByZXF1ZXN0IGlzIHRoZSBsYXRlc3Qgb25lLCBjbGVhciBpdCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPj0gY2FjaGVkVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLlJFQURZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbm5lY3RlZCBidXQgZmFpbGVkLCBkb24ndCB0cnkgYWdhaW4gYnV0IGxldCB0aGUgdXNlciBrbm93IHdoeS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgdGhlIGxhdGVzdCBvbmUsIGNsZWFyIGl0IGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lID49IGNhY2hlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlRnVuY3Rpb24ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mYWlsKChlcnJvciwgdGV4dFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZXJ2ZXIgcmVxdWVzdCBpcyB0aGUgbGF0ZXN0IG9uZSwgdGhlbiBsZXQncyB0cnkgaXQgYWdhaW4gaW4gYSBiaXRcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkVGltZSA9IHRoaXMuc3RvcmFnZS5nZXRUaW1lKGNhY2hlKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZSA+PSBjYWNoZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RMYXRlc3RSZXRyeShkYXRhLCBmaWxlbmFtZSwgZW5kcG9pbnQsIGRlbGF5ICsgdGhpcy5GQUlMX0RFTEFZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZG9uZUZ1bmN0aW9uKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1tjYWNoZV0pO1xuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZXJzW2NhY2hlXSA9IHNldFRpbWVvdXQocmVxdWVzdCwgZGVsYXkpO1xuICAgIH1cbn07XG5cbkJsb2NrUHlTZXJ2ZXIucHJvdG90eXBlLl9wb3N0QmxvY2tpbmcgPSBmdW5jdGlvbiAoZW5kcG9pbnQsIGRhdGEsIGF0dGVtcHRzLCBzdWNjZXNzLCBmYWlsdXJlLCBleHRyYVNldHRpbmdzPXt9KSB7XG4gICAgdGhpcy5zaG93T3ZlcmxheShhdHRlbXB0cyk7XG4gICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICB1cmw6IHRoaXMudXJsc1tlbmRwb2ludF0sXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIC4uLmV4dHJhU2V0dGluZ3NcbiAgICB9KVxuICAgICAgICAuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZU92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICBzdWNjZXNzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJUChyZXNwb25zZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5mYWlsKChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoZW5kcG9pbnQsIFN0YXR1c1N0YXRlLkZBSUxFRCwgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKGVuZHBvaW50LCBTdGF0dXNTdGF0ZS5SRVRSWUlORywgdGV4dFN0YXR1cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKGVuZHBvaW50LCBkYXRhLCBhdHRlbXB0cyAtIDEsIHN1Y2Nlc3MsIGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuRkFJTF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2FkQXNzaWdubWVudCA9IGZ1bmN0aW9uIChhc3NpZ25tZW50X2lkKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcImxvYWRBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJhc3NpZ25tZW50X2lkXCJdID0gYXNzaWdubWVudF9pZDtcbiAgICAgICAgdGhpcy5fcG9zdEJsb2NraW5nKFwibG9hZEFzc2lnbm1lbnRcIiwgZGF0YSwgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5sb2FkQXNzaWdubWVudERhdGFfKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvYWRBc3NpZ25tZW50XCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MT0FESU5HX0FTU0lHTk1ORU5UKHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfTE9BRElOR19BU1NJR05NTkVOVCh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9hZEFzc2lnbm1lbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVBc3NpZ25tZW50XCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJoaWRkZW5cIl0gPSBtb2RlbC5hc3NpZ25tZW50LmhpZGRlbigpO1xuICAgICAgICBkYXRhW1wicmV2aWV3ZWRcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnJldmlld2VkKCk7XG4gICAgICAgIGRhdGFbXCJwdWJsaWNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LnB1YmxpYygpO1xuICAgICAgICBkYXRhW1widXJsXCJdID0gbW9kZWwuYXNzaWdubWVudC51cmwoKTtcbiAgICAgICAgZGF0YVtcInBvaW50c1wiXSA9IG1vZGVsLmFzc2lnbm1lbnQucG9pbnRzKCk7XG4gICAgICAgIGRhdGFbXCJpcF9yYW5nZXNcIl0gPSBtb2RlbC5hc3NpZ25tZW50LmlwUmFuZ2VzKCk7XG4gICAgICAgIGRhdGFbXCJuYW1lXCJdID0gbW9kZWwuYXNzaWdubWVudC5uYW1lKCk7XG4gICAgICAgIGRhdGFbXCJzZXR0aW5nc1wiXSA9IHNhdmVBc3NpZ25tZW50U2V0dGluZ3MobW9kZWwpO1xuXG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcInNhdmVBc3NpZ25tZW50XCIsIGRhdGEsIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UG9zc2libGVGb3JrLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW4uY29tcG9uZW50cy5kaWFsb2cuRVJST1JfU0FWSU5HX0FTU0lHTk1ORU5UKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJzYXZlQXNzaWdubWVudFwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoU2F2ZSBBc3NpZ25tZW50KVwiKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2FkSGlzdG9yeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2FkSGlzdG9yeVwiKSkge1xuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcImxvYWRIaXN0b3J5XCIsIGRhdGEsIDIsIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLkVSUk9SX0xPQURJTkdfSElTVE9SWSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubGlzdFVwbG9hZGVkRmlsZXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibGlzdFVwbG9hZGVkRmlsZXNcIikpIHtcbiAgICAgICAgbGV0IG1vZGVsID0gdGhpcy5tYWluLm1vZGVsO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICB0aGlzLl9wb3N0QmxvY2tpbmcoXCJsaXN0VXBsb2FkZWRGaWxlc1wiLCBkYXRhLCAyLCBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9MSVNUSU5HX1VQTE9BREVEX0ZJTEVTKHRleHRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUudXBsb2FkRmlsZSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIGRpcmVjdG9yeSwgZmlsZW5hbWUsIGNvbnRlbnRzLCBjYWxsYmFjaykge1xuICAgIGxldCBtb2RlbCA9IHRoaXMubWFpbi5tb2RlbDtcbiAgICBpZiAobW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGxvYWRGaWxlXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJwbGFjZW1lbnRcIl0gPSBwbGFjZW1lbnQ7XG4gICAgICAgIGRhdGFbXCJkaXJlY3RvcnlcIl0gPSBkaXJlY3Rvcnk7XG4gICAgICAgIGRhdGFbXCJmaWxlbmFtZVwiXSA9IGZpbGVuYW1lO1xuICAgICAgICBkYXRhW1wiY29udGVudHNcIl0gPSBjb250ZW50cztcbiAgICAgICAgbGV0IGZkID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChkLGUpID0+IChkLmFwcGVuZCguLi5lKSwgZCksIG5ldyBGb3JtRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RCbG9ja2luZyhcInVwbG9hZEZpbGVcIiwgZmQsIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9VUExPQURJTkdfRklMRSh0ZXh0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge3Byb2Nlc3NEYXRhOiBmYWxzZSwgY29udGVudFR5cGU6IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGxvYWRGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUsIFwiU2VydmVyIGlzIG5vdCBjb25uZWN0ZWQhIChVcGxvYWQgRmlsZSlcIik7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUubG9nRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRfdHlwZSwgY2F0ZWdvcnksIGxhYmVsLCBtZXNzYWdlLCBmaWxlX3BhdGgpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJsb2dFdmVudFwiKSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuY3JlYXRlU2VydmVyRGF0YSgpO1xuICAgICAgICBkYXRhW1wiZXZlbnRfdHlwZVwiXSA9IGV2ZW50X3R5cGU7XG4gICAgICAgIGRhdGFbXCJjYXRlZ29yeVwiXSA9IGNhdGVnb3J5O1xuICAgICAgICBkYXRhW1wibGFiZWxcIl0gPSBsYWJlbDtcbiAgICAgICAgZGF0YVtcIm1lc3NhZ2VcIl0gPSBtZXNzYWdlO1xuICAgICAgICBkYXRhW1wiZmlsZV9wYXRoXCJdID0gZmlsZV9wYXRoO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImxvZ0V2ZW50XCIsIFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIC8vIFRyaWdnZXIgcmVxdWVzdFxuICAgICAgICB0aGlzLl9wb3N0UmV0cnkoZGF0YSwgXCJsb2dFdmVudFwiLCAwLCAoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwibG9nRXZlbnRcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc2F2ZUltYWdlID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgaW1hZ2UpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwic2F2ZUltYWdlXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJkaXJlY3RvcnlcIl0gPSBkaXJlY3Rvcnk7XG4gICAgICAgIGRhdGFbXCJpbWFnZVwiXSA9IGltYWdlO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5BQ1RJVkUpO1xuICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3RcbiAgICAgICAgdGhpcy5fcG9zdExhdGVzdFJldHJ5KGRhdGEsIFwidHVydGxlX291dHB1dFwiLCBcInNhdmVJbWFnZVwiLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVJbWFnZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS51cGRhdGVTdWJtaXNzaW9uU3RhdHVzID0gZnVuY3Rpb24obmV3U3RhdHVzKSB7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC5kaXNwbGF5LnJlYWRPbmx5KCkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1haW4ubW9kZWwudWkuc2VydmVyLmlzRW5kcG9pbnRDb25uZWN0ZWQoXCJ1cGRhdGVTdWJtaXNzaW9uU3RhdHVzXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJzdGF0dXNcIl0gPSBuZXdTdGF0dXM7XG4gICAgICAgIGxldCBwb3N0U3RhdHVzQ2hhbmdlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4ubW9kZWwuc3VibWlzc2lvbi5zdWJtaXNzaW9uU3RhdHVzKG5ld1N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyhcInVwZGF0ZVN1Ym1pc3Npb25TdGF0dXNcIiwgZGF0YSwgMiwgcG9zdFN0YXR1c0NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLmRpYWxvZy5FUlJPUl9VUERBVElOR19TVUJNSVNTSU9OX1NUQVRVUygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGxvYWQgZmlsZXMgYW5kIHdlYiByZXNvdXJjZXMuXG4gKlxuICogREVQUkVDQVRFRFxuICovXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5sb2FkRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgdHlwZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgdmFyIHNlcnZlciA9IHRoaXM7XG4gICAgaWYgKG1vZGVsLnVpLnNlcnZlci5pc0VuZHBvaW50Q29ubmVjdGVkKFwibG9hZF9maWxlXCIpKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJmaWxlbmFtZVwiXSA9IGZpbGVuYW1lO1xuICAgICAgICBkYXRhW1widHlwZVwiXSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX3Bvc3RCbG9ja2luZyh0aGlzLnVybHMubG9hZF9maWxlLCBkYXRhLCA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnNldFN0YXR1cyhcImxvYWRGaWxlXCIsIFN0YXR1c1N0YXRlLkZBSUxFRCwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soXCJTZXJ2ZXIgZmFpbHVyZSEgUmVwb3J0IHRvIGluc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvclRocm93bik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckNhbGxiYWNrKFwiTm8gZmlsZSBzZXJ2ZXIgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJsb2FkRmlsZVwiLCBTdGF0dXNTdGF0ZS5PRkZMSU5FLCBcIlNlcnZlciBpcyBub3QgY29ubmVjdGVkISAoTG9hZCBGaWxlKVwiKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS5zYXZlRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY29udGVudHMsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsYXkgPSB0aGlzLlRJTUVSX0RFTEFZO1xuICAgIH1cbiAgICBsZXQgbW9kZWwgPSB0aGlzLm1haW4ubW9kZWw7XG4gICAgaWYgKG1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLk9GRkxJTkUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInNhdmVGaWxlXCIpKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5jcmVhdGVTZXJ2ZXJEYXRhKCk7XG4gICAgICAgIGRhdGFbXCJmaWxlbmFtZVwiXSA9IGZpbGVuYW1lO1xuICAgICAgICBkYXRhW1wiY29kZVwiXSA9IGNvbnRlbnRzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInNhdmVGaWxlXCIsIFN0YXR1c1N0YXRlLkFDVElWRSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3N0TGF0ZXN0UmV0cnkoZGF0YSwgZmlsZW5hbWUsIFwic2F2ZUZpbGVcIiwgZGVsYXksIHRoaXMuc3RhcnRQb3NzaWJsZUZvcmsuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdHVzKFwic2F2ZUZpbGVcIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgfVxufTtcblxuQmxvY2tQeVNlcnZlci5wcm90b3R5cGUuc3RhcnRQb3NzaWJsZUZvcmsgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZm9ya2FibGUpIHtcbiAgICAgICAgdGhpcy5tYWluLmNvbXBvbmVudHMuZGlhbG9nLk9GRkVSX0ZPUksoKTtcbiAgICB9XG59O1xuXG5CbG9ja1B5U2VydmVyLnByb3RvdHlwZS51cGRhdGVTdWJtaXNzaW9uID0gZnVuY3Rpb24gKHNjb3JlLCBjb3JyZWN0LCBoaWRkZW5PdmVycmlkZSwgZm9yY2VVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5tYWluLm1vZGVsLmRpc3BsYXkucmVhZE9ubHkoKSkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuT0ZGTElORSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNhbGxiYWNrID0gdGhpcy5tYWluLm1vZGVsLmNvbmZpZ3VyYXRpb24uY2FsbGJhY2tzLnN1Y2Nlc3M7XG4gICAgaWYgKHRoaXMubWFpbi5tb2RlbC51aS5zZXJ2ZXIuaXNFbmRwb2ludENvbm5lY3RlZChcInVwZGF0ZVN1Ym1pc3Npb25cIikpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmNyZWF0ZVNlcnZlckRhdGEoKTtcbiAgICAgICAgZGF0YVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIGRhdGFbXCJjb3JyZWN0XCJdID0gY29ycmVjdDtcbiAgICAgICAgZGF0YVtcImhpZGRlbl9vdmVycmlkZVwiXSA9IGhpZGRlbk92ZXJyaWRlO1xuICAgICAgICBkYXRhW1wiZm9yY2VfdXBkYXRlXCJdID0gZm9yY2VVcGRhdGU7XG4gICAgICAgIHRoaXMubWFpbi5jb21wb25lbnRzLnB5dGhvbkVkaXRvci5ibS5ibG9ja0VkaXRvci5nZXRQbmdGcm9tQmxvY2tzKChwbmdEYXRhLCBpbWcpID0+IHtcbiAgICAgICAgICAgIGRhdGFbXCJpbWFnZVwiXSA9IHBuZ0RhdGE7XG4gICAgICAgICAgICBpZiAoaW1nLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGltZy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Bvc3RSZXRyeShkYXRhLCBcInVwZGF0ZVN1Ym1pc3Npb25cIiwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwidXBkYXRlU3VibWlzc2lvblwiLCBTdGF0dXNTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInVwZGF0ZVN1Ym1pc3Npb25cIiwgU3RhdHVzU3RhdGUuRkFJTEVELCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhpZGRlbk92ZXJyaWRlICYmIGNvcnJlY3QgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFbXCJhc3NpZ25tZW50X2lkXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59OyIsImV4cG9ydCBjb25zdCAkc2tfbW9kX2NvdmVyYWdlID0gYFxuXCJcIlwiXG5IaWRlb3VzIGZpbGwtaW4gcmVwbGFjZW1lbnQgZm9yIENvdmVyYWdlLCBsZXZlcmFnaW5nIHNvbWUgbWFnaWMgZnJvbSB0aGVcblV0aWxpdHkgZnVuY3Rpb24uIFRoZSBkYXRhIHRoaXMgcmV0dXJucyBpcyBmYWxzZSAtIGl0IGRvZXNuJ3QgYWN0dWFsbHlcbmRlc2NyaWJlIHRoZSBtaXNzaW5nIGxpbmVzIGFuZCBhbGwgbGluZXM7IGl0IGp1c3QgZGVzY3JpYmVzIHRoZSB0cmFjZWQgbGluZXMuXG5CdXQgc2luY2UgUGVkYWwgZG9lc24ndCBuZWVkIHRoZSBvdGhlciB0d28sIGl0IHdvcmtzIG91dCBmaW5lIHdoZW4geW91IGRvOlxuXG5zdGF0ZW1lbnRzIC0gbWlzc2luZ1xuXCJcIlwiXG5cbmltcG9ydCB1dGlsaXR5XG5cbmNsYXNzIENvdmVyYWdlOlxuICAgIGRlZiBzdGFydChzZWxmKTpcbiAgICAgICAgcGFzc1xuXG4gICAgZGVmIHN0b3Aoc2VsZik6XG4gICAgICAgIHBhc3NcblxuICAgIGRlZiBzYXZlKHNlbGYpOlxuICAgICAgICBwYXNzXG5cbiAgICBkZWYgX2FuYWx5emUoc2VsZiwgZmlsZW5hbWU6IHN0cik6XG4gICAgICAgIGxpbmVzID0gc2V0KHV0aWxpdHkudHJhY2VfbGluZXMoKSlcbiAgICAgICAgIyBsaW5lcyB3aWxsIGJlIHRoZSBsaW5lcyB0aGF0IHdlcmUgYWN0dWFsbHkgZXhlY3V0ZWRcbiAgICAgICAgcmV0dXJuIEFuYWx5c2lzKE5vbmUsIGxlbihsaW5lcyksIE5vbmUsIHNldCgpLCBsaW5lcylcblxuXG5jbGFzcyBOdW1iZXJzOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBuX21pc3NpbmcsIG5fc3RhdGVtZW50cywgcGNfY292ZXJlZCk6XG4gICAgICAgIHNlbGYubl9taXNzaW5nID0gbl9taXNzaW5nXG4gICAgICAgIHNlbGYubl9zdGF0ZW1lbnRzID0gbl9zdGF0ZW1lbnRzXG4gICAgICAgIHNlbGYucGNfY292ZXJlZCA9IHBjX2NvdmVyZWRcblxuXG5jbGFzcyBBbmFseXNpczpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbl9taXNzaW5nLCBuX3N0YXRlbWVudHMsIHBjX2NvdmVyZWQsIG1pc3NpbmcsIHN0YXRlbWVudHMpOlxuICAgICAgICBzZWxmLm1pc3NpbmcgPSBtaXNzaW5nXG4gICAgICAgIHNlbGYuc3RhdGVtZW50cyA9IHN0YXRlbWVudHNcbiAgICAgICAgc2VsZi5udW1iZXJzID0gTnVtYmVycyhuX21pc3NpbmcsIG5fc3RhdGVtZW50cywgcGNfY292ZXJlZClcblxuXG5jbGFzcyBweXRob246XG4gICAgZGVmIGdldF9weXRob25fc291cmNlKHNlbGYpOlxuICAgICAgICByZXR1cm4gTm9uZVxuYDsiLCJleHBvcnQgdmFyICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtb2QsIHNhbXBsZVdyYXBwZXI7XG4gICAgbW9kID0ge19fbmFtZV9fOiBcImltYWdlXCJ9O1xuXG4gICAgaWYgKCFTay5QSUwpIHtcbiAgICAgICAgU2suUElMID0ge2Fzc2V0czoge319O1xuICAgIH1cblxuICAgIC8vIEluc3RhbnRQcm9taXNlIGlzIGEgd29ya2Fyb3VuZCB0byBhbGxvdyB1c2FnZSBvZiB0aGUgY2xlYW4gcHJvbWlzZS1zdHlsZVxuICAgIC8vIHRoZW4vY2F0Y2ggc3ludGF4IGJ1dCB0byBpbnN0YW50bHkgY2FsbCByZXNvbHZlIHRoZSB0aGVuL2NhdGNoIGNoYWluIHNvIHdlXG4gICAgLy8gY2FuIGF2b2lkIGNyZWF0aW5nIFN1c3BlbnNpb25zIGluIHVubmVjZXNzYXJ5IGNhc2VzLiAgVGhpcyBpcyBkZXNpcmFibGVcbiAgICAvLyBiZWNhdXNlIFN1c3BlbnNpb25zIGhhdmUgYSBmYWlybHkgbGFyZ2UgbmVnYXRpdmUgaW1wYWN0IG9uIG92ZXJhbGxcbiAgICAvLyBwZXJmb3JtYW5jZS4gIFRoZXNlICdpbnN0YW50IHByb21pc2VzJyBjb21lIGludG8gcGxheSB3aGVuIGEgdHJhY2VyKClcbiAgICAvLyBjYWxsIGlzIG1hZGUgd2l0aCBhIHZhbHVlIG90aGVyIHRoYW4gMS4gIFdoZW4gdHJhY2VyIGlzIDAgb3IgZ3JlYXRlciB0aGFuIDFcbiAgICAvLyAsIHdlIGNhbiBieXBhc3MgdGhlIGNyZWF0aW9uIG9mIGEgU3VzcGVuc2lvbiBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBsaW5lIG9mXG4gICAgLy8gY29kZSBpbW1lZGlhdGVseSBpZiB0aGUgY3VycmVudCBsaW5lIGlzIG5vdCBnb2luZyB0byBpbnZvbHZlIGEgc2NyZWVuXG4gICAgLy8gdXBkYXRlLiBXZSBkZXRlcm1pbmUgaWYgYSByZWFsIHByb21pc2Ugb3IgSW5zdGFudFByb21pc2UgaXMgbmVjZXNzYXJ5IGJ5XG4gICAgLy8gY2hlY2tpbmcgRnJhbWVNYW5hZ2VyLndpbGxSZW5kZXJOZXh0KClcbiAgICBmdW5jdGlvbiBJbnN0YW50UHJvbWlzZShlcnIsIHJlc3VsdCkge1xuICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMubGFzdEVycm9yICA9IGVycjtcbiAgICB9XG5cbiAgICBJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gY2IodGhpcy5sYXN0UmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RFcnJvciAgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgPyB0aGlzLmxhc3RSZXN1bHQgOiB0aGlzO1xuICAgIH07XG5cbiAgICBJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gY2IodGhpcy5sYXN0RXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yICA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSA/IHRoaXMubGFzdFJlc3VsdCA6IHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBidWlsZEltYWdlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoU2suUElMLmFzc2V0c1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gU2suUElMLmFzc2V0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFNrLlBJTC5hc3NldHNbbmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBTay5QSUwuYXNzZXRzW25hbWVdID0gaW1nO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBhc3NldDogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IGZ1bmN0aW9uKCRnYmwsICRsb2MpIHtcbiAgICAgICAgLy8gb3BlbihmaWxlbmFtZSkgb3Igb3Blbih1cmwpXG4gICAgICAgIC8vIHNob3coKVxuXG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBmaWxlX29yX3VybCkge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcIl9faW5pdF9fXCIsIGFyZ3VtZW50cywgMiwgMik7XG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZmlsZV9vcl91cmxcIiwgXCJzdHJpbmdcIiwgU2suYnVpbHRpbi5jaGVja1N0cmluZyhmaWxlX29yX3VybCkpO1xuICAgICAgICAgICAgc2VsZi5maWxlX29yX3VybCA9IGZpbGVfb3JfdXJsO1xuICAgICAgICAgICAgLy8gVE9ETzogQ2hhbmdlIHRvIHN1c3BlbnNpb25cbiAgICAgICAgICAgIHZhciBpbWFnZVByb21pc2UgPSBnZXRBc3NldChTay5mZmkucmVtYXBUb0pzKGZpbGVfb3JfdXJsKSk7XG4gICAgICAgICAgICB2YXIgc3VzcCA9IG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKCk7XG4gICAgICAgICAgICBzZWxmLmltYWdlID0gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xuICAgICAgICAgICAgc3VzcC5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcC5kYXRhW1wiZXJyb3JcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgU2suYnVpbHRpbi5JT0Vycm9yKHN1c3AuZGF0YVtcImVycm9yXCJdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzdXNwLmRhdGFbXCJlcnJvclwiXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBzZWxmLmltYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdXNwLmRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTay5wcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgcHJvbWlzZTogaW1hZ2VQcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLndpZHRoID0gc2VsZi5pbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuaGVpZ2h0ID0gc2VsZi5pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2Uoc2VsZi5pbWFnZSwgMCwgMCwgc2VsZi5pbWFnZS53aWR0aCwgc2VsZi5pbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBpeGVscyA9IHNlbGYuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgc2VsZi5pbWFnZS53aWR0aCwgc2VsZi5pbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzdXNwO1xuICAgICAgICB9KTtcblxuICAgICAgICAkbG9jLnNob3cgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIGlmIChTay5jb25zb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgZHJhd2luZyBhcmVhLiBTay5jb25zb2xlIGlzIHVuZGVmaW5lZCFcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb25zb2xlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogc2VsZi5pbWFnZSxcbiAgICAgICAgICAgICAgICBmaWxlX29yX3VybDogc2VsZi5maWxlX29yX3VybFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2suY29uc29sZS5wcmludFBJTEltYWdlKGNvbnNvbGVEYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5mbGlwID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICBzZWxmLmltYWdlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKC0xKVwiO1xuICAgICAgICAgICAgaWYgKFNrLmNvbnNvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTay5idWlsdGluLk5hbWVFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBkcmF3aW5nIGFyZWEuIFNrLmNvbnNvbGUgaXMgdW5kZWZpbmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIG1vZC5JbWFnZSA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBpbWFnZSwgXCJJbWFnZVwiLCBbXSk7XG5cbiAgICByZXR1cm4gbW9kO1xufTsiLCJleHBvcnQgY29uc3QgJHBlZGFsX3RyYWNlciA9IGBcclxuXHJcblwiXCJcIlxyXG5XcmFwcyB0aGUgdHJhY2VyIG1vZHVsZSBpbiBQZWRhbFxyXG5cIlwiXCJcclxuXHJcbmltcG9ydCBvc1xyXG5pbXBvcnQgdXRpbGl0eVxyXG4gICAgICAgIFxyXG5jbGFzcyBTYW5kYm94QmFzaWNUcmFjZXI6XHJcbiAgICBcIlwiXCJcclxuXHJcbiAgICBcIlwiXCJcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICBzdXBlcigpLl9faW5pdF9fKClcclxuICAgICAgICBzZWxmLmZpbGVuYW1lID0gXCJzdHVkZW50LnB5XCJcclxuICAgICAgICBzZWxmLmNvZGUgPSBOb25lXHJcblxyXG4gICAgZGVmIGFzX2ZpbGVuYW1lKHNlbGYsIGZpbGVuYW1lLCBjb2RlKTpcclxuICAgICAgICBpZiBvcy5wYXRoLmlzYWJzKGZpbGVuYW1lKTpcclxuICAgICAgICAgICAgc2VsZi5maWxlbmFtZSA9IGZpbGVuYW1lXHJcbiAgICAgICAgZWxzZTpcclxuICAgICAgICAgICAgc2VsZi5maWxlbmFtZSA9IG9zLnBhdGguYWJzcGF0aChmaWxlbmFtZSlcclxuICAgICAgICBzZWxmLmNvZGUgPSBjb2RlXHJcbiAgICAgICAgcmV0dXJuIHNlbGZcclxuXHJcbiAgICBkZWYgX19lbnRlcl9fKHNlbGYpOlxyXG4gICAgICAgIHBhc3NcclxuXHJcbiAgICBkZWYgX19leGl0X18oc2VsZiwgZXhjX3R5cGUsIGV4Y192YWwsIHRyYWNlYmFjayk6XHJcbiAgICAgICAgcGFzc1xyXG5cclxuY2xhc3MgU2FuZGJveE5hdGl2ZVRyYWNlcihTYW5kYm94QmFzaWNUcmFjZXIpOlxyXG4gICAgXCJcIlwiXHJcbiAgICBUcmFja3MgbGluZXMgY292ZXJlZCBhbmQgZnVuY3Rpb24gY2FsbHMuIFBvc3NpYmx5IG90aGVyIHRoaW5ncz8gV2UgY291bGQgdHJhY2sgdmFyaWFibGVzLCBpZiB0aGF0XHJcbiAgICB3YXMgc29tZXRoaW5nIHBlb3BsZSB3YW50ZWQuXHJcblxyXG4gICAgVE9ETzogSGFuZGxlIG11bHRpcGxlIHN1Ym1pc3Npb24gZmlsZXM/XHJcbiAgICBcIlwiXCJcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICBzdXBlcigpLl9faW5pdF9fKClcclxuICAgICAgICAjc2VsZi5jYWxscyA9IHV0aWxpdHkudHJhY2VfY2FsbHMoKVxyXG4gICAgICAgIHNlbGYubGluZXMgPSB1dGlsaXR5LnRyYWNlX2xpbmVzKClcclxuICAgICAgICBzZWxmLnN0ZXBfaW5kZXggPSBsZW4odXRpbGl0eS50cmFjZV9saW5lcygpKVxyXG4gICAgXHJcbiAgICBkZWYgZ2V0X2NhbGxzKHNlbGYpOlxyXG4gICAgICAgIHJldHVybiB1dGlsaXR5LnRyYWNlX2NhbGxzKClcclxuICAgIFxyXG4gICAgY2FsbHMgPSBwcm9wZXJ0eShnZXRfY2FsbHMpXHJcbiAgICBcclxuICAgIGRlZiBfX2VudGVyX18oc2VsZik6XHJcbiAgICAgICAgdXRpbGl0eS5zdGFydF90cmFjZShzZWxmKVxyXG5cclxuICAgIGRlZiBfX2V4aXRfXyhzZWxmLCBleGNfdHlwZSwgZXhjX3ZhbCwgdHJhY2ViYWNrKTpcclxuICAgICAgICB1dGlsaXR5LnN0b3BfdHJhY2Uoc2VsZilcclxuXHJcblRSQUNFUl9TVFlMRVMgPSB7XHJcbiAgICAnbm9uZSc6IFNhbmRib3hCYXNpY1RyYWNlcixcclxuICAgICduYXRpdmUnOiBTYW5kYm94TmF0aXZlVHJhY2VyXHJcbn1cclxuXHJcbmA7IiwiLyoqXG4gKiBTa3VscHQgTW9kdWxlIGZvciBob2xkaW5nIHRoZSBJbnN0cnVjdG9yIEFQSS5cbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyBsb2FkZWQgaW4gYnkgZ2V0dGluZyB0aGUgZnVuY3Rpb25zJyBzb3VyY2UgY29kZSBmcm9tIHRvU3RyaW5nLlxuICogSXNuJ3QgdGhhdCBjcmF6eT9cbiAqXG4gKlxuICovXG5leHBvcnQgbGV0ICRza19tb2RfaW5zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE1haW4gbW9kdWxlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgYXQgdGhlIGVuZC5cbiAgICBsZXQgbW9kID0ge307XG4gICAgbGV0IG5vbmUgPSBTay5idWlsdGluLm5vbmUubm9uZSQ7XG4gICAgXG4gICAgbGV0IHByaW9yID0gbnVsbDtcbiAgICBtb2QudGltZWl0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJ0aW1laXRcIiwgYXJndW1lbnRzLCAxLCAxKTtcbiAgICAgICAgbGV0IGRpZmZlcmVuY2U7XG4gICAgICAgIGlmIChwcmlvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gRGF0ZS5ub3coKSAtIHByaW9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFNrLmZmaS5yZW1hcFRvSnMobmFtZSksIGRpZmZlcmVuY2UvMTAwMCk7XG4gICAgICAgIHByaW9yID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBMb2dzIGZlZWRiYWNrIHRvIGphdmFzY3JpcHQgY29uc29sZVxuICAgICAqL1xuICAgIG1vZC5jb25zb2xlX2xvZyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKChbLi4uYXJndW1lbnRzXSkubWFwKFNrLmZmaS5yZW1hcFRvSnMpKTtcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBMb2dzIGRlYnVnIHRvIGphdmFzY3JpcHQgY29uc29sZVxuICAgICAqL1xuICAgIG1vZC5jb25zb2xlX2RlYnVnID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY292ZXJ0cyB0aGUgb3V0cHV0IGluIHRoZSBzdHVkZW50IHJlcG9ydCB0byBhIHB5dGhvbiBcbiAgICAgKiBsaXN0IGFuZCByZXR1cm5zIGl0LlxuICAgICoqL1xuICAgIG1vZC5nZXRfb3V0cHV0ID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9vdXRwdXRcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXVtcIm91dHB1dFwiXSgpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0Lm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnRvU2t1bHB0KCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVzZXRzIHRoZSBvdXRwdXQsIHBhcnRpY3VsYXJseSB1c2VmdWwgaWYgdGhlIHN0dWRlbnRcbiAgICAgKiBjb2RlIGlzIGdvaW5nIHRvIGJlIHJlcnVuLlxuICAgICAqL1xuICAgIG1vZC5yZXNldF9vdXRwdXQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwicmVzZXRfb3V0cHV0XCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5vdXRwdXQucmVtb3ZlQWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICB9KTtcbiAgICBcbiAgICAvKm1vZC5xdWV1ZV9pbnB1dCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJxdWV1ZV9pbnB1dFwiLCBhcmd1bWVudHMsIDEsIEluZmluaXR5KTtcbiAgICAgICAgbGV0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGZvciAobGV0IGkgPSBhcmdzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0ID0gYXJnc1tpXTtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJpbnB1dFwiLCBcInN0cmluZ1wiLCBTay5idWlsdGluLmNoZWNrU3RyaW5nKGlucHV0KSk7XG4gICAgICAgICAgICBTay5xdWV1ZWRJbnB1dC5wdXNoKFNrLmZmaS5yZW1hcFRvSnMoaW5wdXQpKTtcbiAgICAgICAgfVxuICAgIH0pOyovXG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgaW5zdHJ1Y3RvcnMgdG8gZ2V0IHRoZSBzdHVkZW50cycgY29kZSBhcyBhIHN0cmluZy5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X3Byb2dyYW0gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X3Byb2dyYW1cIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoU2suZXhlY3V0aW9uUmVwb3J0c1tcInZlcmlmaWVyXCJdLmNvZGUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgaW5zdHJ1Y3RvcnMgdG8gZ2V0IHRoZSBzdHVkZW50cycgY29kZSBhcyBhIHN0cmluZy5cbiAgICAqKi9cbiAgICBtb2QuZ2V0X2V2YWx1YXRpb24gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X2V2YWx1YXRpb25cIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uZXZhbHVhdGlvbiB8fCBcIlwiKTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2QudHJhY2VfbGluZXMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0ucmVhbExpbmVzO1xuICAgICAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkobGluZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoW10pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2QudHJhY2VfY2FsbHMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiLS1cIiwgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ0hFQ0tJTkcgQ0FMTFNcIiwgU2suZXhlY3V0aW9uUmVwb3J0c1snc3R1ZGVudCddLnN1Y2Nlc3MpO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGNhbGxzID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uY2FsbHM7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShjYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3QoW10pO1xuICAgIH0pO1xuXG4gICAgbW9kLnN0YXJ0X3RyYWNlID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUL0JFR0lOXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICAgICAgaWYgKFNrLmJlZm9yZUNhbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFNrLmJlZm9yZUNhbGwgPSBTay5iZWZvcmVDYWxsQmFja3VwO1xuICAgICAgICB9XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcucHVzaCh0cnVlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUL0VORFwiLCBTay5iZWZvcmVDYWxsLCBTay5leGVjdXRpb25SZXBvcnRzLnN0dWRlbnQudHJhY2luZyk7XG4gICAgfSk7XG5cbiAgICBtb2Quc3RvcF90cmFjZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTVE9QL0JFR0lOXCIsIFNrLmJlZm9yZUNhbGwsIFNrLmV4ZWN1dGlvblJlcG9ydHMuc3R1ZGVudC50cmFjaW5nKTtcbiAgICAgICAgU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0udHJhY2luZy5wb3AoKTtcbiAgICAgICAgaWYgKFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLnRyYWNpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBTay5iZWZvcmVDYWxsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RPUC9FTkRcIiwgU2suYmVmb3JlQ2FsbCwgU2suZXhlY3V0aW9uUmVwb3J0cy5zdHVkZW50LnRyYWNpbmcpO1xuICAgIH0pO1xuICAgIFxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbW9kLmdldF9zdHVkZW50X2Vycm9yID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIGlmIChTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25vbmUsIG5vbmVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IudHJhY2ViYWNrICYmIGVycm9yLnRyYWNlYmFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25bXCJsaW5lXCJdID0gZXJyb3IudHJhY2ViYWNrWzBdLmxpbmVubztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb24gPSBTay5mZmkucmVtYXBUb1B5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbZXJyb3IsIHBvc2l0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFxuICAgIG1vZC5oYWRfZXhlY3V0aW9uX3RpbWVfZXJyb3IgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiaGFkX2V4ZWN1dGlvbl90aW1lX2Vycm9yXCIsIGFyZ3VtZW50cywgMCwgMCk7XG4gICAgICAgIHJldHVybiAhU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2VzcyAmJiBcbiAgICAgICAgICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5lcnJvciAmJlxuICAgICAgICAgICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJzdHVkZW50XCJdLmVycm9yLnRwJG5hbWUgPT09IFwiVGltZUxpbWl0RXJyb3JcIjtcbiAgICB9KTtcbiAgICBcbiAgICBsZXQgYmFja3VwVGltZSA9IHVuZGVmaW5lZDtcbiAgICBtb2QubGltaXRfZXhlY3V0aW9uX3RpbWUgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwibGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgYmFja3VwVGltZSA9IFNrLmV4ZWNMaW1pdDtcbiAgICAgICAgaWYgKFNrLmV4ZWNMaW1pdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBTay5leGVjTGltaXQgPSBTay5leGVjTGltaXRGdW5jdGlvbigpO1xuICAgICAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1vZC51bmxpbWl0X2V4ZWN1dGlvbl90aW1lID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInVubGltaXRfZXhlY3V0aW9uX3RpbWVcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suZXhlY0xpbWl0ID0gYmFja3VwVGltZTtcbiAgICAgICAgU2suZXhlY1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2Quc3VwcHJlc3Nfc2Nyb2xsaW5nID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcInN1cHByZXNzX3Njcm9sbGluZ1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBTay5leGVjdXRpb25SZXBvcnRzLmluc3RydWN0b3Iuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIFxuICAgIC8qXG4gICAgZGVmIGhpc3Qoc2VsZiwgZGF0YSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnSGlzdG9ncmFtJywgJ3ZhbHVlcyc6IGRhdGEsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgcGxvdChzZWxmLCB4cywgeXM9Tm9uZSwgKiprd2FyZ3MpOlxuICAgICAgICBsYWJlbCA9IGt3YXJncy5nZXQoJ2xhYmVsJywgTm9uZSlcbiAgICAgICAgaWYgeXMgPT0gTm9uZTpcbiAgICAgICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ0xpbmUnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3gnOiByYW5nZShsZW4oeHMpKSwgJ3knOiB4cywgJ2xhYmVsJzogbGFiZWx9KVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgc2VsZi5hY3RpdmVfcGxvdFsnZGF0YSddLmFwcGVuZCh7J3R5cGUnOiAnTGluZScsICd4JzogeHMsICd5JzogeXMsICdsYWJlbCc6IGxhYmVsfSlcbiAgICBkZWYgc2NhdHRlcihzZWxmLCB4cywgeXMsICoqa3dhcmdzKTpcbiAgICAgICAgbGFiZWwgPSBrd2FyZ3MuZ2V0KCdsYWJlbCcsIE5vbmUpXG4gICAgICAgIHNlbGYuYWN0aXZlX3Bsb3RbJ2RhdGEnXS5hcHBlbmQoeyd0eXBlJzogJ1NjYXR0ZXInLCAneCc6IHhzLCAneSc6IHlzLCAnbGFiZWwnOiBsYWJlbH0pXG4gICAgKi9cbiAgICBtb2QuZ2V0X3Bsb3RzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9wbG90c1wiLCBhcmd1bWVudHMsIDAsIDApO1xuICAgICAgICBpZiAoU2suZXhlY3V0aW9uUmVwb3J0c1tcInN0dWRlbnRcIl0uc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXVtcIm91dHB1dFwiXSgpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IG91dHB1dHMuZmlsdGVyKGZ1bmN0aW9uKG91dHB1dCkgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0LnR5cGUgPT09IFwicGxvdFwiO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcImRhdGFcIjogZ3JhcGguY29udGVudC5tYXAoZnVuY3Rpb24ocGxvdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGxvdCA9IHsgXCJ0eXBlXCI6IHBsb3QudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIjogXCJcIiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxvdC50eXBlID09PSBcImxpbmVcIiB8fCBwbG90LnR5cGUgPT09IFwic2NhdHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQbG90W1wieFwiXSA9IHBsb3QuZGF0YS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi54OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ5XCJdID0gcGxvdC5kYXRhLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Lnk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsb3QudHlwZSA9PT0gXCJoaXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bsb3RbXCJ2YWx1ZXNcIl0gPSBwbG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Bsb3Q7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIFwieGxhYmVsXCI6IFwiXCIsIFwieWxhYmVsXCI6IFwiXCIsIFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJcIiwgXCJsZWdlbmRcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gU2suZmZpLnJlbWFwVG9QeShvdXRwdXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTay5mZmkucmVtYXBUb1B5KFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG4gICAgLy8gUHJvdmlkZXMgYHN0dWRlbnRgIGFzIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSB0aGF0IHRoZSBzdHVkZW50IGRlY2xhcmVkLlxuICAgIG1vZC5TdHVkZW50RGF0YSA9IFNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLCBmdW5jdGlvbigkZ2JsLCAkbG9jKSB7XG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIC8vc2VsZi5kYXRhID0gU2suYnVpbHRpbi5kaWN0KCk7XG4gICAgICAgICAgICBsZXQgbmV3RGljdCA9IG5ldyBTay5idWlsdGluLmRpY3QoKTtcbiAgICAgICAgICAgIFNrLmFic3RyLnNhdHRyKHNlbGYsIG5ldyBTay5idWlsdGluLnN0cihcImRhdGFcIiksIG5ld0RpY3QsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBTay5leGVjdXRpb25SZXBvcnRzW1wic3R1ZGVudFwiXS5yZXN1bHRzO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHNlbGYubW9kdWxlLiRkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2suYWJzdHIub2JqZWN0U2V0SXRlbShuZXdEaWN0LCBTay5mZmkucmVtYXBUb1B5KFNrLnVuZml4UmVzZXJ2ZWQoa2V5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjYWxsX2YgPSBmdW5jdGlvbihrd2EpIHtcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXCJjYWxsXCIsIGFyZ3VtZW50cy5sZW5ndGgsIDEsIEluZmluaXR5LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBrd2FyZ3MgPSBuZXcgU2suYnVpbHRpbnMuZGljdChrd2EpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDIpO1xuXG4gICAgICAgICAgICB2YXIgaW5wdXRzID0ga3dhcmdzLm1wJGxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoXCJpbnB1dHNcIikpO1xuICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gU2suZmZpLnJlbWFwVG9KcyhpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFNrLnF1ZXVlZElucHV0LnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwiZGF0YVwiKSk7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25PYmplY3QgPSBkYXRhLm1wJGxvb2t1cChmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uT2JqZWN0LnRwJGNhbGwoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBjYWxsX2YuY29fa3dhcmdzID0gdHJ1ZTtcbiAgICAgICAgLy9jYWxsX2YuY29fdmFybmFtZXMgPSBbXCJzZWxmXCIsIFwiZnVuY3Rpb25cIl07XG4gICAgICAgIGNhbGxfZi5jb19uYW1lPSBuZXcgU2suYnVpbHRpbi5zdHIoXCJjYWxsXCIpO1xuICAgICAgICAkbG9jW1wiY2FsbF8kcm4kXCJdID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhjYWxsX2YpO1xuXG4gICAgICAgICRsb2NbXCJfX3JlcHJfX1wiXSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvYy5nZXRfbmFtZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9uYW1lc19ieV90eXBlXCIsIGFyZ3VtZW50cywgMiwgMyk7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXCJleGNsdWRlX2J1aWx0aW5zXCIsIFwiYm9vbGVhblwiLCBTay5idWlsdGluLmNoZWNrQm9vbChleGNsdWRlX2J1aWx0aW5zKSk7XG4gICAgICAgICAgICAgICAgZXhjbHVkZV9idWlsdGlucyA9IFNrLmZmaS5yZW1hcFRvSnMoZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBzZWxmLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubW9kdWxlW3Byb3BlcnR5XS50cCRuYW1lID09PSB0eXBlLnRwJG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXhjbHVkZV9idWlsdGlucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNrLmZmaS5yZW1hcFRvUHkoU2sudW5maXhSZXNlcnZlZChwcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICAkbG9jLmdldF92YWx1ZXNfYnlfdHlwZSA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgdHlwZSwgZXhjbHVkZV9idWlsdGlucykge1xuICAgICAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF92YWx1ZXNfYnlfdHlwZVwiLCBhcmd1bWVudHMsIDIsIDMpO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVfYnVpbHRpbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZXhjbHVkZV9idWlsdGluc1wiLCBcImJvb2xlYW5cIiwgU2suYnVpbHRpbi5jaGVja0Jvb2woZXhjbHVkZV9idWlsdGlucykpO1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfYnVpbHRpbnMgPSBTay5mZmkucmVtYXBUb0pzKGV4Y2x1ZGVfYnVpbHRpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gc2VsZi5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2R1bGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vZHVsZVtwcm9wZXJ0eV0udHAkbmFtZSA9PT0gdHlwZS50cCRuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZV9idWlsdGlucyAmJiBwcm9wZXJ0eS5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYubW9kdWxlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9LCBcIlN0dWRlbnREYXRhXCIpO1xuICAgIG1vZC5zdHVkZW50ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChtb2QuU3R1ZGVudERhdGEpO1xuICAgIFxuICAgIG1vZC5nZXRfc3R1ZGVudF9kYXRhID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2RhdGFcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdHVkZW50O1xuICAgIH0pO1xuXG4gICAgbW9kLnNldF9pbnN0cnVjdGlvbnMgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKG5ld0luc3RydWN0aW9ucykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwic2V0X2luc3RydWN0aW9uc1wiLCBhcmd1bWVudHMsIDEsIDIpO1xuICAgICAgICBuZXdJbnN0cnVjdGlvbnMgPSBTay5mZmkucmVtYXBUb0pzKG5ld0luc3RydWN0aW9ucyk7XG4gICAgICAgIFNrLmV4ZWN1dGlvblJlcG9ydHNbXCJtb2RlbFwiXS5kaXNwbGF5LmNoYW5nZWRJbnN0cnVjdGlvbnMobmV3SW5zdHJ1Y3Rpb25zKTtcbiAgICB9KTtcblxuICAgIG1vZC5nZXRfbW9kZWxfaW5mbyA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oa2V5cykge1xuICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tBcmdzKFwiZ2V0X21vZGVsX2luZm9cIiwgYXJndW1lbnRzLCAxLCAxKTtcbiAgICAgICAgbGV0IG1vZGVsID0gU2suZXhlY3V0aW9uUmVwb3J0c1tcIm1vZGVsXCJdO1xuICAgICAgICBrZXlzID0gU2suZmZpLnJlbWFwVG9KcyhrZXlzKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWxba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkobW9kZWwoKSk7XG4gICAgfSk7XG5cbiAgICBtb2QuY2xlYXJfZXhpc3Rpbmdfc3R1ZGVudF9pbXBvcnRzID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpIHtcbiAgICAgICAgU2suYnVpbHRpbi5weUNoZWNrQXJncyhcImdldF9zdHVkZW50X2RhdGFcIiwgYXJndW1lbnRzLCAwLCAwKTtcbiAgICAgICAgU2suY2xlYXJFeGlzdGluZ1N0dWRlbnRJbXBvcnRzKCk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG1vZDtcbn07XG4iLCJleHBvcnQgdmFyICRidWlsdGlubW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1vZCwgc2FtcGxlV3JhcHBlcjtcclxuICAgIG1vZCA9IHtfX25hbWVfXzogXCJ3ZWFrcmVmXCJ9O1xyXG5cclxuICAgIC8qbW9kLldlYWtTZXQgPSBTay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwid2Vha3JlZi5XZWFrU2V0XCIsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gV2Vha1NldCgpXHJcbiAgICB9KTsqL1xyXG5cclxuICAgIHZhciBXZWFrU2V0ID0gZnVuY3Rpb24oJGdibCwgJGxvYykge1xyXG4gICAgICAgICRsb2MuX19pbml0X18gPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXCJfX2luaXRfX1wiLCBhcmd1bWVudHMsIDIsIDIpO1xyXG4gICAgICAgICAgICBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFwiZGF0YVwiLCBcIml0ZXJhYmxlXCIsIFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShkYXRhKSk7XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaXRlciA9IFNrLmFic3RyLml0ZXIoZGF0YSk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gU2suYWJzdHIuaXRlcm5leHQoaXRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhLnB1c2gobmV3IFdlYWtSZWYobmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkbG9jLl9faXRlcl9fID0gbmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihzZWxmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdPZkRhdGEgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgc2VsZi5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2VsZi5kYXRhW2ldLmRlcmVmKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld09mRGF0YS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHZpZXdPZkRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBTay5hYnN0ci5pdGVyKG5ldyBTay5idWlsdGluLmxpc3Qodmlld09mRGF0YSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKiRsb2MubmV4dCQgPSBuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIChzZWxmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnRwJGl0ZXIoKTtcclxuICAgICAgICB9KTsqL1xyXG5cclxuICAgICAgICAkbG9jLmFkZCA9IG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oc2VsZiwgaXRlbSkge1xyXG4gICAgICAgICAgICBzZWxmLmRhdGEucHVzaChuZXcgV2Vha1JlZihpdGVtKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgbW9kLldlYWtTZXQgPSBTay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCwgV2Vha1NldCwgXCJXZWFrU2V0XCIsIFtdKTtcclxuXHJcbiAgICByZXR1cm4gbW9kO1xyXG59OyIsImxldCBMT0NBTF9TVE9SQUdFX1JFRjtcbnRyeSB7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYgPSBsb2NhbFN0b3JhZ2U7XG4gICAgbGV0IG1vZCA9IFwiQkxPQ0tQWV9MT0NBTFNUT1JBR0VfVEVTVFwiO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGLnJlbW92ZUl0ZW0obW9kKTtcbn0gY2F0Y2goZSkge1xuICAgIExPQ0FMX1NUT1JBR0VfUkVGID0ge1xuICAgICAgICBfZGF0YSAgICAgICA6IHt9LFxuICAgICAgICBzZXRJdGVtICAgICA6IGZ1bmN0aW9uKGlkLCB2YWwpIHsgcmV0dXJuIHRoaXMuX2RhdGFbaWRdID0gU3RyaW5nKHZhbCk7IH0sXG4gICAgICAgIGdldEl0ZW0gICAgIDogZnVuY3Rpb24oaWQpIHsgcmV0dXJuIHRoaXMuX2RhdGEuaGFzT3duUHJvcGVydHkoaWQpID8gdGhpcy5fZGF0YVtpZF0gOiBudWxsOyB9LFxuICAgICAgICByZW1vdmVJdGVtICA6IGZ1bmN0aW9uKGlkKSB7IHJldHVybiBkZWxldGUgdGhpcy5fZGF0YVtpZF07IH0sXG4gICAgICAgIGNsZWFyICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhID0ge307IH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBvYmplY3QgZm9yIGludGVyZmFjaW5nIHdpdGggdGhlIExvY2FsU3RvcmFnZS4gVGhlIExvY2FsU3RvcmFnZVxuICogYnJvd3NlciBBUEkgYWxsb3dzIGZvciBvZmZsaW5lIHN0b3JhZ2UuIFRoYXQgQVBJIGlzIHZlcnkgdW5zb3BoaXN0aWNhdGVkLFxuICogYW5kIGlzIGVzc2VudGlhbGx5IGEgbGFtZSBrZXktdmFsdWUgc3RvcmUuIFRoaXMgb2JqZWN0IHNpdHMgb24gdG9wXG4gKiBhbmQgcHJvdmlkZXMgYSBudW1iZXIgb2YgdXNlZnVsIHV0aWxpdGllcywgaW5jbHVkaW5nIHJ1ZGltZW50YXJ5Y2FjaGVcbiAqIGNhY2hlIGV4cGlyYXRpb24uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdGhpcyB7TG9jYWxTdG9yYWdlV3JhcHBlcn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBBIG5hbWVzcGFjZSB0byB1c2UgaW4gZ3JvdXBpbmcgYWNjZXNzIHRvIGxvY2Fsc3RvcmFnZS4gVGhpcyBrZWVwcyBhY2Nlc3MgY2xlYW4gYW5kIG9yZ2FuaXplZCwgd2hpbGUgYWxzbyBtYWtpbmcgaXQgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBMb2NhbFN0b3JhZ2UgY29ubmVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBMb2NhbFN0b3JhZ2VXcmFwcGVyKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xufVxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgYWRkaW5nIGEga2V5L3ZhbHVlIHBhaXIgdG8gTG9jYWxTdG9yYWdlLlxuICogTm90ZSB0aGF0IGJvdGggcGFyYW1ldGVycyBtdXN0IGJlIHN0cmluZ3MgKEpTT04uc3RyaW5naWZ5IGlzIHlvdXIgZnJpZW5kKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZS5cbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5zZXRJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiLCB2YWx1ZSk7XG4gICAgTE9DQUxfU1RPUkFHRV9SRUYuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdGltZXN0YW1wXCIsICQubm93KCkpO1xufTtcblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgcmVtb3ZpbmcgYSBrZXkgZnJvbSBMb2NhbFN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkgdG8gcmVtb3ZlLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl92YWx1ZVwiKTtcbiAgICBMT0NBTF9TVE9SQUdFX1JFRi5yZW1vdmVJdGVtKHRoaXMubmFtZXNwYWNlK1wiX1wiK2tleStcIl90aW1lc3RhbXBcIik7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIG5hbWUgb2YgdGhlIGtleSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZm9yLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIik7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB0aW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB0aW1lIGZvci5cbiAqIEByZXR1cm5zIHtJbnRlZ2VyfSAtIFRoZSB0aW1lc3RhbXAgKGxvY2FsIGVwb2NoKSB3aGVuIHRoZSBrZXkgd2FzIGxhc3Qgc2V0LlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKSk7XG59O1xuXG4vKipcbiAqIEEgbWV0aG9kIGZvciByZXRyaWV2aW5nIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAqIElmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIHRoZW4gdGhlIGRlZmF1bHQgdmFsdWUgaXMgdXNlZCBpbnN0ZWFkLlxuICogVGhpcyBkZWZhdWx0IHdpbGwgYmUgc2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBmb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlLiBNdXN0IGJlIGEgc3RyaW5nLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHRlc3QgZm9yIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBpbiBMb2NhbFN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdGVzdCBleGlzdGVuY2UgZm9yLlxuICovXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gTE9DQUxfU1RPUkFHRV9SRUYuZ2V0SXRlbSh0aGlzLm5hbWVzcGFjZStcIl9cIitrZXkrXCJfdmFsdWVcIikgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIEEgdGVzdCBmb3Igd2hldGhlciB0aGUgc2VydmVyIGhhcyB0aGUgbmV3ZXIgdmVyc2lvbi4gVGhpcyBmdW5jdGlvblxuICogYXNzdW1lcyB0aGF0IHRoZSBzZXJ2ZXIgdHJpcCB0YWtlcyBhYm91dCA1IHNlY29uZHMuIFRoaXMgbWV0aG9kXG4gKiBpcyBsYXJnZWx5IGRlcHJlY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHNlcnZlcl90aW1lIC0gVGhlIHNlcnZlcidzIHRpbWUgYXMgYW4gZXBvY2ggKGluIG1pbGxpc2Vjb25kcylcbiAqL1xuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaXNfbmV3ID0gZnVuY3Rpb24oa2V5LCBzZXJ2ZXJfdGltZSkge1xuICAgIHZhciBzdG9yZWRfdGltZSA9IExPQ0FMX1NUT1JBR0VfUkVGLmdldEl0ZW0odGhpcy5uYW1lc3BhY2UrXCJfXCIra2V5K1wiX3RpbWVzdGFtcFwiKTtcbiAgICByZXR1cm4gKHNlcnZlcl90aW1lID49IHN0b3JlZF90aW1lKzUwMDApO1xufTtcbiIsImV4cG9ydCBjb25zdCBUUkFDRV9IVE1MID0gYFxuXG48ZGl2IGNsYXNzPVwiYmxvY2tweS10cmFjZSBjb2wtbWQtNiBibG9ja3B5LXBhbmVsXCJcbiAgICAgICAgICAgIHJvbGU9XCJyZWdpb25cIiBhcmlhLWxhYmVsPVwiVHJhY2VcIj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiY2xlYXJmaXhcIj5cbiAgICAgICAgPHN0cm9uZz5UcmFjZTogPC9zdHJvbmc+XG4gICAgICAgIFxuICAgICAgICA8IS0tIEZlZWRiYWNrL1RyYWNlIFZpc2liaWxpdHkgQ29udHJvbCAtLT5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nXG4gICAgICAgICAgICAgICAgY2xhc3M9J2J0biBidG4tc20gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGZsb2F0LXJpZ2h0IGJsb2NrcHktaGlkZS10cmFjZSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkuc2Vjb25kUm93LmFkdmFuY2VTdGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2ZhcyBmYS1leWUnPjwvc3Bhbj4gSGlkZSBUcmFjZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zIGJsb2NrcHktdHJhY2UtY29udHJvbHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXByZXBlbmRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuZmlyc3RcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtYmFja3dhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5J1xuICAgICAgICAgICAgICAgIGRhdGEtYmluZD1cImNsaWNrOiB1aS50cmFjZS5iYWNrd2FyZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtYmFja3dhcmQnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+U3RlcDo8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IGV4ZWN1dGlvbi5zdHVkZW50LmN1cnJlbnRUcmFjZVN0ZXAnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAvIDxzcGFuIGRhdGEtYmluZD0ndGV4dDogZXhlY3V0aW9uLnN0dWRlbnQubGFzdFN0ZXAnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSdcbiAgICAgICAgICAgICAgICBkYXRhLWJpbmQ9XCJjbGljazogdWkudHJhY2UuZm9yd2FyZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdmYXMgZmEtZm9yd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J2J0biBidG4tb3V0bGluZS1zZWNvbmRhcnknXG4gICAgICAgICAgICAgICAgZGF0YS1iaW5kPVwiY2xpY2s6IHVpLnRyYWNlLmxhc3RcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nZmFzIGZhLXN0ZXAtZm9yd2FyZCc+PC9zcGFuPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmQ9J3RleHQ6IHVpLnRyYWNlLmxpbmUnPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPHRhYmxlIGNsYXNzPSd0YWJsZSB0YWJsZS1zbSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWhvdmVyJz5cbiAgICAgICAgPGNhcHRpb24+Q3VycmVudCB2YXJpYWJsZXMgYXQgdGhpcyBzdGVwPC9jYXB0aW9uPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICA8dHI+PHRoPk5hbWU8L3RoPjx0aD5UeXBlPC90aD48dGg+VmFsdWU8L3RoPjwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keSBkYXRhLWJpbmQ9XCJmb3JlYWNoOiB1aS50cmFjZS5kYXRhKCkucHJvcGVydGllc1wiPlxuICAgICAgICAgICAgPHRyIGRhdGEtYmluZD1cInZpc2libGU6IG5hbWUgIT0gJ19fZmlsZV9fJyAmJiBuYW1lICE9ICdfX3BhdGhfXydcIj5cbiAgICAgICAgICAgICAgICA8dGQgZGF0YS1iaW5kPVwidGV4dDogbmFtZVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZD1cInRleHQ6IHR5cGVcIj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgPGNvZGUgZGF0YS1iaW5kPVwidGV4dDogdmFsdWVcIj48L2NvZGU+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0ga28gaWY6IHR5cGUgPT0gXCJMaXN0XCIgLS0+XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiXCIgZGF0YS1iaW5kPVwiY2xpY2s6IC8vJHJvb3Qudmlld0V4YWN0VmFsdWUodHlwZSwgZXhhY3RfdmFsdWUpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSdnbHlwaGljb24gZ2x5cGhpY29uLW5ldy13aW5kb3cnPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIC9rbyAtLT5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICA8L3RhYmxlPlxuICAgIFxuPC9kaXY+XG5gO1xuXG5leHBvcnQgY2xhc3MgQmxvY2tQeVRyYWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKG1haW4sIHRhZykge1xuICAgICAgICB0aGlzLm1haW4gPSBtYWluO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcblxuICAgICAgICB0aGlzLklHTk9SRURfR0xPQkFMUyA9IFtcIl9fbmFtZV9fXCIsIFwiX19kb2NfX1wiLCBcIl9fcGFja2FnZV9fXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NtZXRob2RcIiwgXCJwcm9wZXJ0eVwiLCBcInN0YXRpY21ldGhvZFwiLCBcIiRmcmVlXCIsIFwiJGNlbGxcIl07XG5cbiAgICAgICAgLy8gdGhpcy50cmFjZS5jbGljayh0aGlzLmJ1aWxkVHJhY2VUYWJsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgc2V0IG9mIHZhcmlhYmxlcyB0cmFjZWQgZnJvbSB0aGUgZXhlY3V0aW9uIGFuZCBwYXJzZSBvdXQgYW55XG4gICAgICogZ2xvYmFsIHZhcmlhYmxlcyBhbmQgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJpYWJsZXMgLSBhIG1hcHBpbmcgb2YgdmFyaWFibGUgbmFtZXMgdG8gdGhlaXIgU2t1cHQgdmFsdWUuXG4gICAgICovXG4gICAgcGFyc2VHbG9iYWxzKHZhcmlhYmxlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtb2R1bGVzID0gW107XG4gICAgICAgIGNvbnNvbGUubG9nKHZhcmlhYmxlcyk7XG4gICAgICAgIGlmICghdGhpcy5tYWluLm1vZGVsLmRpc3BsYXkudHJhY2VFeGVjdXRpb24oKSkge1xuICAgICAgICAgICAgLyppZiAoXCIkY2VsbFwiIGluIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IHsuLi52YXJpYWJsZXMsIC4uLnZhcmlhYmxlcy4kY2VsbH07XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIC8qaWYgKFwiJGZyZWVcIiBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMgPSB7Li4udmFyaWFibGVzLCAuLi52YXJpYWJsZXMuJGZyZWV9O1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YXJpYWJsZXNbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLklHTk9SRURfR0xPQkFMUy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoXCJfJHJ3JFwiLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJfJHJuJFwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEJsb2NrUHlUcmFjZS5wYXJzZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0ge1wibmFtZVwiOiBwcm9wZXJ0eSwgXCJ0eXBlXCI6IFwiVW5rbm93blwiLCBcInZhbHVlXCI6IHZhbHVlLnRvU3RyaW5nKCl9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFNrLmJ1aWx0aW4ubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLnB1c2godmFsdWUuJGQuX19uYW1lX18udik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcInByb3BlcnRpZXNcIjogcmVzdWx0LCBcIm1vZHVsZXNcIjogbW9kdWxlc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBTa3VscHQgdmFsdWUgaW50byBhIG1vcmUgZWFzaWx5IHByaW50YWJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgc2t1bHB0IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlVmFsdWUocHJvcGVydHksIHZhbHVlLCBmdWxsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJVbmtub3duXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlVuZGVmaW5lZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRhY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJEZWNvcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiPGRhdGFjbGFzcyBkZWNvcmF0b3I+XCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5mdW5jOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJGdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIEFyZ3VtZW50czogXCIrdmFsdWUuZnVuY19jb2RlLmNvX3Zhcm5hbWVzLmpvaW4oXCIsIFwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgTm8gYXJndW1lbnRzXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5tb2R1bGU6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnN0cjpcbiAgICAgICAgICAgICAgICBpZiAoZnVsbExlbmd0aCB8fCB2YWx1ZS52Lmxlbmd0aCA8PSAzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIltcIit2YWx1ZS5zcSRsZW5ndGgoKStcIiBjaGFyYWN0ZXJzIG5vdCBzaG93bl1cIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2suYnVpbHRpbi5ub25lOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJOb25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJOb25lXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmJvb2w6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLm5tYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRcIiA9PT0gdmFsdWUuc2tUeXBlID8gXCJJbnRlZ2VyXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmludF86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLmZsb2F0XzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZS4kcigpLnZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBTay5idWlsdGluLnR1cGxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJUdXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4ubGlzdDpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudi5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmFsdWVcIjogXCJbLi4uIFwiK3ZhbHVlLnYubGVuZ3RoK1wiIGVsZW1lbnRzIC4uLl1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhhY3RfdmFsdWVcIjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNrLmJ1aWx0aW4uZGljdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1wibmFtZVwiOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IHZhbHVlICUgMSA9PT0gMCA/IFwiSW50ZWdlclwiIDogXCJGbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcIm5hbWVcIjogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIkJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiAodmFsdWUgPyBcIlRydWVcIjogXCJGYWxzZVwiKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XCJuYW1lXCI6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogdmFsdWUudHAkbmFtZSA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiB2YWx1ZS50cCRuYW1lLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLiRyID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLiRyKCkudlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUT0RPOiB2aWV3RXhhY3RWYWx1ZSIsIi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7YW55dGhpbmd9IG5lZWRsZSAtIFRoZSBlbGVtZW50IHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtBcnJheX0gaGF5c3RhY2sgLSBUaGUgbGlzdCB0byBzZWFyY2guXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IGV4aXN0c1xuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID4gLTE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheSwgcHJlc2VydmluZyBvcmRlci5cbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXksIHNvIGlzIG5vbi1kZXN0cnVjdGl2ZS5cbiAqIENvdXJ0ZXN5OlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU4NDM3MC9ob3ctdG8tbWVyZ2UtdHdvLWFycmF5cy1pbi1qYXZhc2NyaXB0LWFuZC1kZS1kdXBsaWNhdGUtaXRlbXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB1bmlxdWlmeS4gRWxlbWVudHMgY29tcGFyZWQgd2l0aCA9PT0uXG4gKi9cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgdmFyIGEgPSBhcnJheS5jb25jYXQoKTtcbiAgICBmb3IodmFyIGk9MDsgaTxhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYoYVtpXSA9PT0gYVtqXSkge2Euc3BsaWNlKGotLSwgMSk7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4dGVuZGluZyBhbiBhcnJheSBiYXNlZFxuICogb24gYW4gXCJhZGRBcnJheVwiIGFuZCBcInJlbW92ZUFycmF5XCIuIEFueSBlbGVtZW50XG4gKiBmb3VuZCBpbiByZW1vdmVBcnJheSBpcyByZW1vdmVkIGZyb20gdGhlIGZpcnN0IGFycmF5XG4gKiBhbmQgYWxsIHRoZSBlbGVtZW50cyBvZiBhZGRBcnJheSBhcmUgYWRkZWQuXG4gKiBBbnkgZHVwbGljYXRlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSwgc28gaXMgbm9uLWRlc3RydWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIG1hbmlwdWxhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFkZEFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZUFycmF5IC0gdGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBtb2RpZmllZCBhcnJheVxuICovXG5mdW5jdGlvbiBleHBhbmRBcnJheShhcnJheSwgYWRkQXJyYXksIHJlbW92ZUFycmF5KSB7XG4gICAgdmFyIGNvcHlBcnJheSA9IGFycmF5LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVBcnJheS5pbmRleE9mKGl0ZW0pID09PSAtMTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29weUFycmF5LmNvbmNhdChhZGRBcnJheSkpO1xufVxuXG4vKipcbiAqIERlZXBseSBjbG9uZXMgYSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQSBub2RlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHtOb2RlfSBBIGNsb25lIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbGwgaXRzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUsIHRoZW4gcmUtY3JlYXRlIGl0IHJhdGhlciB0aGFuIGNsb25lIGl0XG4gICAgdmFyIGNsb25lID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuIFxuICAgIC8vIFJlY3Vyc2UgICAgIFxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZShjaGlsZCkge1xuICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChjbG9uZU5vZGUoY2hpbGQpKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICB9XG4gICAgIFxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuLyoqXG4gKiBJbmRlbnRzIHRoZSBnaXZlbiBzdHJpbmcgYnkgNCBzcGFjZXMuIFRoaXMgY29ycmVjdGx5IGhhbmRsZXMgbXVsdGktbGluZSBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyB3aXRoIGZvdXIgc3BhY2VzIGFkZGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuZXcgbGluZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oPz0uKS9nbSwgXCIgICAgXCIpO1xufVxuXG4vKipcbiAqIFR1cm5zIHNwYWNlcyBpbnRvIHVuZGVyc2NvcmVzIGluIHRoZSBzdHJpbmcsIG1ha2VzIGl0IGxvd2VyY2FzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSB0aGUgc3RyaW5nIHRvIGJlIG1hbmlwdWxhdGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2x1ZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccy9nLCBcIl9cIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gYmUgY2FwaXRhbGl6ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbYG1pbmAsIGBtYXhgXS5cbiAqIFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBsb3dlc3QgcG9zc2libGUgaW50ZWdlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgaGlnaGVzdCBwb3NzaWJsZSBpbnRlZ2VyIChpbmNsdXNpdmUpLlxuICogQHJldHVybnMge251bWJlcn0gQSByYW5kb20gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50ZWdlcihtaW4sbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWF4LW1pbisxKSttaW4pO1xufVxuXG4vKipcbiAqIEVuY29kZXMgc29tZSB0ZXh0IHNvIHRoYXQgaXQgY2FuIGJlIHNhZmVseSB3cml0dGVuIGludG8gYW4gSFRNTCBib3guXG4gKiBUaGlzIGluY2x1ZGVzIHJlcGxhY2luZyBzcGVjaWFsIEhUTUwgY2hhcmFjdGVycyAoJiwgPCwgPiwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSB0ZXh0IHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEhUTUwtc2FmZSB0ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSFRNTChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKTtcbn1cblxuLyoqXG4gKiBTaHVmZmxlIHRoZSBibG9ja3MgaW4gdGhlIHdvcmtzcGFjZVxuICovXG5pZiAodHlwZW9mIEJsb2NrbHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBCbG9ja2x5LldvcmtzcGFjZVN2Zy5wcm90b3R5cGUuc2h1ZmZsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMuZ2V0TWV0cmljcygpO1xuICAgICAgICB2YXIgd2lkdGggPSBtZXRyaWNzLnZpZXdXaWR0aCAvIDIsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZXRyaWNzLnZpZXdIZWlnaHQ7XG4gICAgICAgIHZhciBibG9ja3MgPSB0aGlzLmdldFRvcEJsb2NrcyhmYWxzZSk7XG4gICAgICAgIHZhciB5ID0gNSwgeCA9IDAsXG4gICAgICAgICAgICBtYXhpbWFsX2luY3JlYXNlID0gaGVpZ2h0L2Jsb2Nrcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCBhIGJsb2NrXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IGJsb2NrLmdldFJlbGF0aXZlVG9TdXJmYWNlWFkoKTtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC1wcm9wZXJ0aWVzLngrcmFuZG9tSW50ZWdlcigxMCwgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2subW92ZUJ5KHgsIFxuICAgICAgICAgICAgICAgICAgICAgICAgIC1wcm9wZXJ0aWVzLnkreSk7XG4gICAgICAgICAgICB5ID0geSArIHJhbmRvbUludGVnZXIoNSwgbWF4aW1hbF9pbmNyZWFzZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE1vdmUgZWxlbWVudHMgZnJvbSBvbmUgYXJyYXkgdG8gYW5vdGhlciBiYXNlZCBvbiBhIGNvbmRpdGlvbmFsIGNoZWNrLlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzE4ODc5NjcvamF2YXNjcmlwdC1tb3ZlLW9iamVjdHMtZnJvbS1vbmUtYXJyYXktdG8tYW5vdGhlci1iZXN0LWFwcHJvYWNoXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50cyhzb3VyY2UsIHRhcmdldCwgbW92ZUNoZWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChtb3ZlQ2hlY2soZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH0gXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgb25lIG9mIHRoZSBTay5idWlsdGluIG9iamVjdHNcbiAqIFRPRE86IG1ha2UgdGhpcyBzbyB3ZSBkb24ndCBoYXZlIHRvIGV4cGxpY2l0bHkgcHV0IG91dCBldmVyeSBvcHRpb25cbiAqICAgICAgICAgIG9uZSBwb3NzaWJsZSB0aGluZyB3ZSBjb3VsZCBkbyBpcyBnZXQgYSBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgXG4gKiAgICAgICAgICBvZiB0aGUgY29uc3RydWN0b3IgYW5kIGxvb2sgZm9yIHRoZSBzdWJzdHJpbmcgXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIlxuICogICAgICAgICAgQnV0IEkgZG9uJ3Qga25vdyBob3cgcmVsaWFibGUgdGhhdCBpcy4gIFJhdGhlciwgaXQncyBraW5kIG9mIGhhY2tpc2guXG4gKiAgICAgICAgICBTaG91bGQgdGVob3JldGljYWxseSBiZWxvbmcgaW4gU2suZmZpXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBleGFtaW5lZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG9uZSBvZiB0aGUgU2suYnVpbHRpbiB0eXBlc1xuKiovXG5mdW5jdGlvbiBpc1NrQnVpbHRpbihvYmope1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbCkgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XykgfHxcbiAgICAgICAgKG9iaiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKSB8fFxuICAgICAgICAob2JqIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpIHx8XG4gICAgICAgIChvYmogaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyk7XG4gICAgLy92YXIgY29uc19zdHIgPSBvYmouY29uc3RydWN0b3IgKyBcIlwiO1xuICAgIC8vcmV0dXJuIGNvbnNfc3RyLmluZGV4T2YoXCJyZXR1cm4gbmV3IFNrLmJ1aWx0aW5cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBpc0FzdE5vZGUob2JqKXtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmIFwiX2FzdG5hbWVcIiBpbiBvYmo7XG59XG5cbi8qKlxuICogU2hvdWxkIHRoZW9yZXRpY2FsbHkgYmVsb25nIGluIFNrLmZmaSwgYnV0IEkgcHV0IGl0IGhlcmUgaW5zdGVhZCB0byBub3QgbWVzcyB1cCB0aGUgc2t1bHB0IGZpbGVzXG4gKiBsaWtlIHRoZSBub3JtYWwgU2suZmZpLnJlbWFwVG9QeSwgaXQgZG9lc24ndCB3b3JrIGZvciBmdW5jdGlvbnMgb3IgbW9yZSBjb21wbGV4IG9iamVjdHMsIGJ1dCBpdCBoYW5kbGVzXG4gKiBjYXNlcyB3aGVyZSB0aGUgdHlwZXMgaW4gb2JqIGFyZSBhIG1peCBvZiBweXRob24gU0lNUExFIG9iamVjdHMgYW5kIFNJTVBMRSBub3JtYWwgamF2YXNjcmlwdCBvYmplY3RzXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge1NrLmJ1aWx0aW4uPz8/fSAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcHl0aG9uIG9iamVjdCwgZHJvcHBpbmcgYWxsIGZ1bmN0aW9ucyBhbmQgdGhpbmdzIGl0IGNhbid0IGNvbnZlcnRcbioqL1xuZnVuY3Rpb24gbWl4ZWRSZW1hcFRvUHkob2JqKXtcbiAgICB2YXIgaztcbiAgICB2YXIga3ZzO1xuICAgIHZhciBpO1xuICAgIHZhciBhcnI7XG4gICAgLy9AVE9ETzogc2hvdWxkIHRoZW9yZXRpY2FsbHkgY2hlY2sgaWYgdGhlIG9iamVjdCBpcyBhIHB5aG9uIGRpY3Qgb3IgYXJyYXkgd2l0aCBqcyBvYmplY3RzXG4gICAgaWYgKGlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAvL29iamVjdCBpcyBhbHJlYWR5IHB5dGhvbiByZWFkeVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAvL29iamVjdCBpcyBhY3R1YWxseSBhIGphdmFzY3JpcHQgYXJyYXlcbiAgICAgICAgYXJyID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggb2JqZWN0LCBjb252ZXJ0IGl0IHRvIGEgcHl0aG9uIG9iamVjdCBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgdmFyIHN1YnZhbCA9IG9ialtpXTtcbiAgICAgICAgICAgIGlmKCFpc1NrQnVpbHRpbihzdWJ2YWwpKXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChtaXhlZFJlbWFwVG9QeShzdWJ2YWwpKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHN1YnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYXJyKTtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkgey8vbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYoIWlzU2tCdWlsdGluKG9iaikpe1xuICAgICAgICAgICAgLy9hc3N1bWluZyBpdCdzIGEgc3RhbmRhcmQgZGljdGlvbmFyeVxuICAgICAgICAgICAga3ZzID0gW107Ly9Tay5idWlsdGluLmRpY3QgdXNlcyBhbiBhcnJheSBvZiBrZXktdmFsdWUsa2V5LXZhbHVlLi4uXG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBrZXkgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkoaykpO1xuICAgICAgICAgICAgICAgIC8vY292ZXJ0IGNvcnJlc3BvbmRpbmcgdmFsdWUgaWYgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAgICAga3ZzLnB1c2gobWl4ZWRSZW1hcFRvUHkob2JqW2tdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgbmV3IGRpY3Rpb25hcnlcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2suYnVpbHRpbi5kaWN0KGt2cyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBTay5idWlsdGluLmFzc2skKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChvYmopO1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihvYmoubmFtZSk7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pxdWVyeV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9rbm9ja291dF9fOyJdLCJzb3VyY2VSb290IjoiIn0=